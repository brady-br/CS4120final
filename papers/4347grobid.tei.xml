<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:14+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. iOS, Your OS, Everybody&apos;s OS: Vetting and Analyzing Network Services of iOS Applications iOS, Your OS, Everybody&apos;s OS: Vetting and Analyzing Network Services of iOS Applications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhushou</forename><surname>Tang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuan</forename><surname>Tian</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haojin</forename><surname>Zhu</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhushou</forename><surname>Tang</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Shanghai Jiao</orgName>
								<orgName type="institution">Tong University</orgName>
							</affiliation>
							<affiliation key="aff7">
								<orgName type="laboratory">PWNZEN InfoTech Co., LTD</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ke</forename><surname>Tang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minhui</forename><surname>Xue</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Shanghai Jiao</orgName>
								<orgName type="institution">Tong University</orgName>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">The University of Adelaide</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuan</forename><surname>Tian</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">University of Virginia</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sen</forename><surname>Chen</surname></persName>
							<affiliation key="aff5">
								<orgName type="institution">Nanyang Technological University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muhammad</forename><surname>Ikram</surname></persName>
							<affiliation key="aff6">
								<orgName type="institution">Macquarie University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tielei</forename><surname>Wang</surname></persName>
							<affiliation key="aff7">
								<orgName type="laboratory">PWNZEN InfoTech Co., LTD</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haojin</forename><surname>Zhu</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Shanghai Jiao</orgName>
								<orgName type="institution">Tong University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Minhui Xue</orgName>
								<orgName type="institution" key="instit1">Shanghai Jiao Tong University</orgName>
								<orgName type="institution" key="instit2">PWNZEN InfoTech Co., LTD</orgName>
								<orgName type="institution" key="instit3">Ke Tang</orgName>
								<orgName type="institution" key="instit4">Shanghai Jiao Tong University</orgName>
								<orgName type="institution" key="instit5">The University of Adelaide</orgName>
								<orgName type="institution" key="instit6">University of Virginia</orgName>
								<address>
									<addrLine>Sen Chen</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">Muhammad Ikram, Macquarie University; Tielei Wang, PWNZEN InfoTech Co., LTD</orgName>
								<orgName type="institution" key="instit1">Nanyang Technological University</orgName>
								<orgName type="institution" key="instit2">Shanghai Jiao Tong University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. iOS, Your OS, Everybody&apos;s OS: Vetting and Analyzing Network Services of iOS Applications iOS, Your OS, Everybody&apos;s OS: Vetting and Analyzing Network Services of iOS Applications</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the 978-1-939133-17-5</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Smartphone applications that listen for network connections introduce significant security and privacy threats for users. In this paper, we focus on vetting and analyzing the security of iOS apps&apos; network services. To this end, we develop an efficient and scalable iOS app collection tool to down-load 168,951 iOS apps in the wild. We investigate a set of 1,300 apps to understand the characteristics of network service vulnerabilities, confirming 11 vulnerabilities in popular apps, such as Waze, Now, and QQBrowser. From these vul-nerabilities, we create signatures for a large-scale analysis of 168,951 iOS apps, which shows that the use of certain third-party libraries listening for remote connections is a common source of vulnerable network services in 92 apps. These vulnerabilities open up the iOS device to a host of possible attacks, including data leakage, remote command execution, and denial-of-service attacks. We have disclosed identified vulnerabilities and received acknowledgments from vendors.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A network service is built on an application programming interface (API) or a library that provides networked data storage, or other online functionality to applications. Many potential threats have spawned with the widespread use of smartphones with network service capabilities. Poor implementation practices expose users to denial-of-service (DoS) or remote code execution (RCE) attacks, and unauthorized access can occur due to the weak protection of network resources. Such threats have already been substantiated in the real world. One such example is the DoS or RCE attack against WhatsApp that can occur when a WhatsApp user accepts a call from a malicious peer <ref type="bibr">[5,</ref><ref type="bibr">17]</ref>. Another is the "wormhole" vulnerability, where open ports in Android apps allow an attacker to remotely access data or manipulate apps without sufficient authorization <ref type="bibr" target="#b38">[51]</ref>. Recently, a proof-of-concept DoS attack that prevents communication between iOS devices has been demonstrated by utilizing the specific design flaw of the Apple Wireless Direct Link (AWDL) protocol <ref type="bibr" target="#b61">[74]</ref>.</p><p>Recent research evaluating the security of open port usage in Android apps has demonstrated new attack avenues that can exploit the vulnerability of network services and access unauthorized sensitive data previously unthought of <ref type="bibr" target="#b10">[22,</ref><ref type="bibr" target="#b19">32,</ref><ref type="bibr" target="#b42">55,</ref><ref type="bibr" target="#b67">80]</ref>. Some works have also proposed vetting methodologies to handle dynamic code loading <ref type="bibr" target="#b56">[69]</ref>, complex implicit control/data flows <ref type="bibr" target="#b18">[31]</ref>, or advanced code obfuscation <ref type="bibr" target="#b33">[46,</ref><ref type="bibr" target="#b66">79]</ref>, techniques created to overcome the inherent limitations of Android app static analysis. Unfortunately, these sophisticated and ad hoc vetting approaches only target Android apps.</p><p>iOS's network architecture is built on top of BSD sockets. When acting as a resource provider, the app turns the iOS device into a server to provide services to a client once a connection is established. For example, the Handoff <ref type="bibr" target="#b11">[23]</ref> feature of iPhone serves as a server to receive commands from a client in the same Wi-Fi network. Apple encourages network connections between different components through Bonjour protocol <ref type="bibr" target="#b15">[28,</ref><ref type="bibr" target="#b60">73]</ref>, which broadcasts the network service to clients. Although Apple reviews third-party apps before releasing them on the iTunes App Store, The vetting process predominantly focuses on detecting malicious apps instead of network service vulnerabilities.</p><p>In this work, we propose the first vetting methodology of iOS apps' network services. There are three elements that make vetting and analyzing iOS apps more technically challenging than Android apps. (i) Android apps are easy to collect and analyze; however, a public repository of iOS apps is not readily available due to the closed nature of Apple's app ecosystem. (ii) Practical program analysis tools for automatically analyzing iOS apps (implemented in Objective-C or SWIFT) are not as well developed or diverse as tools for Android (written in Java) are <ref type="bibr" target="#b13">[26,</ref><ref type="bibr" target="#b32">45,</ref><ref type="bibr" target="#b64">77]</ref>. (iii) The layout of code in Android apps is highly structural, but the boundaries of iOS code are obscure, causing previous methods for thirdparty library identification in Android apps <ref type="bibr" target="#b14">[27,</ref><ref type="bibr" target="#b35">48,</ref><ref type="bibr" target="#b63">76]</ref> to function incorrectly on iOS apps.</p><p>To ensure the efficiency of our pipeline, we tailor our app collection (cf. § 3), vetting process (cf. § 4), and library identification (cf. § 5) techniques to overcome the unique challenges presented by iOS apps. First, to collect and analyze apps, we need to download, decrypt, and parse the executable, a process that leverages iTunes' unique download interface with a special decryption method to expedite app collection. Our collection methodology can download and decrypt over 5,000 apps per day using only two Apple accounts and two jailbroken iOS devices, providing better scaling up of tasks with lower latency than past works <ref type="bibr" target="#b49">[62,</ref><ref type="bibr" target="#b54">67]</ref>. After collection, we parse the iOS apps, obtain the metadata of apps, and feed it into a search engine for retrieval and subsequent analysis. Second, to improve the accuracy and efficiency of our vetting results, we write an "addon" which evaluates the network interface on the fly. To expedite the automated analysis, we leverage an on-demand inter-procedural <ref type="bibr" target="#b57">[70]</ref> data-flow analysis tool to restore the implicit call introduced by the message dispatch property <ref type="bibr">[24]</ref> of Objective-C or SWIFT runtime. Third, to deal with the obscure documentation of system and third-party network services, we propose a call stack based collection method that overcomes the limitations of the current class-clustering based third-party library identification <ref type="bibr" target="#b54">[67]</ref>. In our method, we first identify system network service APIs by traveling the call stack of each app; then thirdparty network service libraries can be distinguished through similarity analysis on the runtime call stack.</p><p>We begin our analysis with a set of 1,300 applications, which we refer to as "seed apps". Seed apps are used to understand the characteristics of network service vulnerabilities and extract signatures for large-scale analysis of network services. To analyze the seed apps, we adopt the vetting methodology of "dynamic first, static later, and manual confirmation last". The dynamic analysis can check for misconfigured network interfaces on a large scale, which allows us to pinpoint a small portion of candidate network service apps. The comparably more time-consuming static analysis can then be used to perform a fine-grained check for potential vulnerabilities. Finally, manual confirmation is involved in verifying static analysis results. In addition, the precise call stack of _bind collected by dynamic analysis can be used for the identification of APIs and libraries. Knowledge gained from seed apps is then applied to the large-scale analysis, including measuring the distribution of network services of iOS apps, finding the association of network service libraries, and fine-grained analysis on three typical libraries. Vetting results show that vulnerabilities of the network service open up the iOS app to data leakage, remote command execution, or denial-of-service attacks (cf. § 7). Responsible disclosure. We have reported these vulnerable apps to relevant stakeholders through the Security Response Center (SRC) of vendors. Three vulnerabilities have been acknowledged, including Google issue ID: 109708840 and Tencent issue IDs: 34162 and 23546 (see the list of major vulnerabilities found in <ref type="table" target="#tab_0">Table 1</ref>). We also helped the vendors patch these vulnerabilities and are currently discussing possibilities of vendor deployment of our vetting system. To foster further research, we release the dataset used in this paper and the code developed for analysis, and encourage readers to view short video demos of vulnerabilities we discovered at https://sites.google.com/site/iosappnss/.</p><p>The key contributions of this paper are as follows:</p><p>• An efficient iOS app collection tool. To facilitate our analysis, we introduce an iOS app collection tool thanks to the use of the headless-downloader and executable decryption. The headless-downloader enables us to download .ipa files from iTunes App Store fluently. The executable decryption we developed does not need to upload large .ipa files to iOS devices, install apps, or download entire decrypted .ipa files from iOS devices. The proposed downloading enables large-scale dataset collection with limited iOS devices, and can decrypt over 5,000 apps per day with only two iOS devices, improving the scalability of data collection by 17 times compared to the state-of-the-art collection method in <ref type="bibr" target="#b49">[62]</ref>. The collection of such a large dataset of iOS apps is a significant resource and also serves as a useful benchmark for future research.</p><p>• Systematic characterization of network services of iOS apps. We apply dynamic analysis to collect a call stack from each app. Based on the call stack information, we extract system APIs by backward traveling the stack, identify the third-party network service libraries by comparing the tokens originated from the stack. By taking signatures of the network services, we systematically characterize network services in iOS ecosystem, including the prevalent usage of network services of iOS apps, the distribution of network services across app categories, and the association of these network services.</p><p>• New vulnerabilities of iOS apps identified. This is the first work for vetting the security of iOS apps' network services. We use dynamic analysis to assess the interface of the network service and then improve (and implement)  <ref type="table">Table  String Table  Class Name(__TEXT,__objc_classname)</ref> Code(__TEXT,__text) the state-of-the-art static data-flow analysis tool <ref type="bibr" target="#b36">[49]</ref> to further scrutinize the apps at scale. The vetting process is performed on 1,300 seed apps, with 11 network service vulnerabilities confirmed manually, including some top popular apps, such as Waze, QQBrowser, and Now. By taking into account three typical third-party network service libraries integrated by 2,116 apps and case-by-case analysis, an additional 92 vulnerable apps are discovered. We cross check the vulnerabilities identified and find none of these vulnerabilities exist in Android apps.</p><p>To the best of our knowledge, this is the first paper to systematically examine the security of network services within iOS apps on a large scale. The entire vetting methodology proposed in this paper can serve as a starting point for further study of this important area.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and Threat Model</head><p>We begin by introducing the structure of iOS apps, defining the network services of the iOS apps, and presenting the threat model in this study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The Structure of iOS Apps</head><p>The iOS app is an archive file (i.e., .ipa) which stores an Application Bundle including Info.plist file, executable, resource files, and other support files. For the sake of digital rights management (DRM), Apple uses a .supp file containing the keys within the .ipa file to decrypt the executable <ref type="bibr" target="#b65">[78]</ref>. The executable in the Application Bundle is encoded in Mach-O format <ref type="bibr" target="#b55">[68]</ref> consisting of three parts: Header, Load commands, and Data. The Load commands region of a Mach-O file contains multiple segments and each segment specifies a group of sections. Each section within is parallel, such as the instructions in the __text section, C string in the __cstring section, and Objective-C class  object name in the __objc_classname section. In particular, instructions in the __text section are encoded with the ARM/THUMB instruction set. The simplified Mach-O format file is depicted in <ref type="figure" target="#fig_1">Figure 1</ref>. For security purposes, an iOS app's interactions with the file system are limited to the directories inside the app's sandbox directory <ref type="bibr" target="#b29">[42,</ref><ref type="bibr" target="#b30">43]</ref>. During the installation of a new app, the installer creates a bundle container directory that holds the Application Bundle, whereas the data container directory holds runtime generated data of the app. The bundle container directory and the data container directory reside in two randomly generated directories. For such design, if the root folder of a vulnerable network service is set to a bundle container directory, files within Application Bundle will be exposed. The randomly generated directories alleviate the path traversal threat due to the difficulty for the adversary to predict the data container path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Network Services of iOS Apps</head><p>A network service is built on an API or a library that provides networked data storage, or other online functionality to applications. A bottom-up network service is defined as having "open port," "communication protocol," "access control," and "resources/functionalities" layers (see <ref type="figure">Figure 2</ref>). In the example of a GPS navigation app, termed <ref type="bibr">Waze [15]</ref>, the app generally projects the app's UI to the vehicle's screen via USB connection. In particular, the app integrates the WebLink <ref type="bibr" target="#b8">[16]</ref> Figure 4: Overview of our system pipeline: (1) the green box shows the iOS app collection methodology (cf. § 3); (2) the red box shows the methodology for vetting the first 1,300 apps by using dynamic and static analysis (cf. § 4) and the call stack analysis for building signatures of system and third-party network services (cf. § 5); (3) the blue box shows the large-scale analysis on network service APIs/libraries over 168,951 iOS apps (cf. § 6) and a fine-grained analysis of 3 typical libraries; (4) the bottom gray bar includes two datasets of iOS apps for analysis.</p><p>library to stream a user's iPhone screen to the virtual app screen of the in-vehicle infotainment (IVI) system. Meanwhile, the app receives touch events on the in-vehicle device to respond to end-user's actions. In doing so, the WebLink library in the Waze app turns the app into a server to accept the connection from the IVI system.</p><p>As for the architecture of the network service of iOS apps, both system and third-party network service libraries are directly or indirectly built on top of BSD sockets (see <ref type="figure">Fig- ure</ref> 3). As shown in the dashed, pink box of <ref type="figure" target="#fig_2">Figure 3</ref>, iOS wrapped the BSD sockets for developers to facilitate the development of network services. For example, the system API _CFSocketSetAddress <ref type="bibr" target="#b12">[25]</ref> in Core Foundation framework bridges access to BSD sockets. Based on this API, developers can compose various applications on top of the TCP layer of the network protocol stack to provide network services. In addition, many third-party network service libraries are available for developers to use, as shown in the blue box of <ref type="figure" target="#fig_2">Figure 3</ref>. In general, network services provided by the thirdparty libraries operate on the application layer of the network protocol stack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Threat Model</head><p>Previous works <ref type="bibr" target="#b42">[55,</ref><ref type="bibr" target="#b67">80]</ref> classified Android network service adversaries to local, remote, and web adversaries. However, we do not consider attacks by a hostile app installed locally on the device (i.e., local adversary) or by enticing the victim to browse a JavaScript-enabled web page (i.e., web adversary) in our study. For example, the Libby's web service demonstrated in <ref type="figure" target="#fig_1">Figure 12</ref>(b) falls outside of our scope. This paper focuses on more practical remote adversaries for vulnerability analysis because these potential vulnerabilities are of high risk.</p><p>To find a potential victim, a remote adversary can scan and examine the network (i.e., the Wi-Fi network or cellular network) by designating specific port numbers <ref type="bibr" target="#b38">[51]</ref>. Such an adversary subsequently compares the banner 1 returned from the connected server (i.e., a network service of the iOS app). If the banner is expected, the adversary then confirms the real victim and can mount a remote 0-click attack, such as stealing personal information for profit. A real-world attack targets Android device to be exposed in a cellular network to thwart end-user privacy for extortion <ref type="bibr" target="#b1">[2]</ref>.</p><p>To further break down the role of a remote adversary, <ref type="figure">Fig- ure 2</ref> shows that each layer allows for different remote attacks: (i) The interface would be exposed if the network service is activated and the "open port" is misconfigured. (ii) A poor implementation of "communication protocol," usually written in a universal language C/C++, may lead to DoS or RCE of apps <ref type="bibr">[5,</ref><ref type="bibr">17,</ref><ref type="bibr" target="#b61">74]</ref>. (iii) Insufficient "access control" incurs unauthorized access to network resources/functionalities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Methodology of iOS App Collection</head><p>Collecting apps and meta-information on Apple iTunes is not a trivial task. iTunes implements various restrictions for app collection, such as capping the number of requests to limit automated crawling methods and encrypting the executable for DRM consideration. Because of these challenges, previous collection methods are limited in scalability and efficiency. Current iOS app downloading methods are UI manipulation <ref type="bibr" target="#b54">[67]</ref> and in-device app crawler <ref type="bibr" target="#b49">[62]</ref>. They decrypt executable by using either <ref type="bibr">Clutch [6]</ref>, dumpdecrypted <ref type="bibr">[10]</ref>, or the Frida <ref type="bibr" target="#b4">[8]</ref> extension frida-ios-dump <ref type="bibr">[20]</ref>. We realize that recent research <ref type="bibr" target="#b49">[62]</ref> expended three months to collect 28,625 iOS apps, lending evidence to the scalability issue when extending to large-scale analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">iOS App Collection</head><p>In this section, we describe our method for collecting iOS apps IDs, downloading the .ipa file from iTunes, removing DRM protection to get decrypted executable, and parsing executable. Our method consists of the following three modules (see green box of <ref type="figure">Figure 4</ref>): Collecting IDs and downloading apps from iTunes. Each iOS app on iTunes has a unique identifier (i.e., ID). For example, Instagram is identified by the unique ID: 389801252, and can be accessed from iTunes by using this ID. Based on the iTunes Search API <ref type="bibr" target="#b6">[13]</ref>, we collect the ID list recursively. For example, the following request returns meta-information of the top 20 apps in the "Productivity" category, such as ID and the app name.</p><p>https://itunes.apple.com/search?term=productivity&amp;country=u s&amp;media=software&amp;limit=20.</p><p>Afterwards, we use a breadth-first-search approach that obtains "similar apps" using iTunes Search API. Queries are relayed by different proxies to bypass the crawler blocking of iTunes.</p><p>To purchase and download a DRM protected .ipa file from iTunes, we implement a headless-downloader. In essence, we implement the requests for purchasing and downloading of iTunes, sign method for the requests, and modify the requests header to bypass device identification authentication. Our headless-downloader leverages the Windows' version of iTunes' .dll files and invokes the interface of the .dll files. The headless-downloader accepts ID and Apple accounts as arguments to download the .ipa file. Decrypting the executable. To investigate the code, we need to decrypt the executable of the downloaded apps. Since the state-of-the-art techniques require physical iOS devices to be involved in decrypting process <ref type="bibr">[6,</ref><ref type="bibr">10,</ref><ref type="bibr">20]</ref>, to avoid using many devices, we use an agent app which is pre-installed on a jailbroken iOS device. After the agent app is loaded into memory, the iOS system is set to decrypt the executable. We then suspend the decrypting process and inject the encrypted executable into the agent app to utilize the inherent decrypting process of the iOS system. After the iOS system decrypts the executable, we dump the executable on the jailbroken device, retrieve it through the USB connection, and merge the decrypted executable into the original .ipa file in a local desktop computer. In such a way, we obtain the decrypted executable without installation and uninstallation and only need to transfer the executable (not Application Bundle) between the desktop computer and the iOS device. Parsing the executable. In order to facilitate subsequent analysis and share our dataset for further research, we parsed the executable by using JTOOL <ref type="bibr">[14]</ref> and extracted relevant metadata such as the class name and string within an executable. Data in Info.plist is also withdrawn, such as bundle ID in "CFBundleIdentifier" field or the app name in "CFBundleName" field. These metadata and meta-information of an app, including category and popularity, are stored in a search engine, namely ELASTICSEARCH <ref type="bibr" target="#b37">[50]</ref> for later queries. Selecting seed apps. Seed apps are used to understand the characteristics of network service vulnerabilities and extract signatures for large-scale analysis of network services. Seed apps are the iTune's apps downloaded from both the United States and China app stores. To choose seed apps, we take the top 20 free apps from each category on iTunes, composing 1,300 apps in total. Since the list of apps on iTunes App Store leaderboards is constantly updated, we use a snapshot of the lists collected on May 8, 2018. Among these 1,300 apps, we have 24 categories (480 apps in total) from China region and 41 categories (820 apps in total) from the United States region. Apple classifies the "Game" apps in the United States region into more fine-grained categories, such as "Games-Card" and "Games-Action". These 1,300 apps provide a huge diversity across all app categories. There is almost no overlap between the top popular apps in China and the United States, and the taxonomy of apps in both countries are almost the same. We only found two apps (i.e., Rules of Survival <ref type="bibr">[19]</ref> and Dancing Line <ref type="bibr">[18]</ref>) that were ranked in the top 20 in both the United States and China.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Evaluation of iOS App Collection</head><p>Collecting iOS apps effectively is a challenging and critical problem. To evaluate the efficiency of our app collection scheme, we experiment with two procedures: app download and app decryption. Our unique design of these two procedures is the key to the performance improvement for app collection. For the comparison of executable decryption speed, we attempt to automate the state-of-the-practice tools ideviceinstaller <ref type="bibr">[12]</ref> and frida-ios-dump <ref type="bibr">[20]</ref> adopted by research <ref type="bibr" target="#b20">[33,</ref><ref type="bibr" target="#b28">41,</ref><ref type="bibr" target="#b54">67]</ref>. The decryption speed of these tools is largely concurrent with the download speed using our headless-downloader, which expends approximately 29 hours to decrypt the 1,300 seed apps with an iPhone 6s device, averaging out roughly 80 seconds per app. By contrast, our decrypting process, without manual handling .ipa files, takes approximately 21 seconds on average per app, almost four times faster than the tools. Nevertheless, we acknowledge that the speed-up of the app decryption is positively correlated to the existence of many "Game" apps in question (35.0% of the whole dataset), where their resource files are unnecessary to be delivered between a desktop computer and an iOS device (see <ref type="figure" target="#fig_3">Figure 5</ref>). Comparing the speed of downloads is not as trivial as comparing the speed of decryption. We acknowledge that a rigorous comparison of app download between ours and other de facto research-standard tools is difficult because of the unknown arguments of the UI manipulation adopted by CRiOS <ref type="bibr" target="#b54">[67]</ref> (e.g., time interval for UI manipulation), available network bandwidth (e.g., 50mbs or 500mbs), and the vague description of the implementation of the in-device crawler proposed by Yeonjoon et al. <ref type="bibr" target="#b49">[62]</ref>.</p><p>Based on the speed we tested for downloading the 1,300 seed apps, downloading 168,951 iOS apps in the wild with a single download task and an iOS jailbroken device is estimated to complete in 160 (assuming 24/7 activity) days. To achieve this efficiently in practice, we combine six downloading tasks with two jailbroken devices for app collection. To evade iTunes' detection of our automated downloader, two Apple accounts are iteratively used to download the .ipa files. This scheme enables us to collect 168,951 apps within just 30 days. Overall, our app collection can significantly improve the collection rate by 17 times faster in comparison to the methodology used by <ref type="bibr">Yeonjoon et al. [62]</ref>, which took three months to collect only 28,625 iOS apps. We highlight that not only the decrypting process can positively contribute to the speed-up of the app collection, but our headless-downloader can also fully utilize bandwidth for parallel apps download. In summary, the scalable app collection tool, developed in this paper, enables us to complete the collection of 168,951 iOS apps. Ethical considerations: We emphasize that routinely collecting and decrypting iOS apps using jailbroken iPhones is for the purpose of improving their service quality and security. The dataset and the research per se is to serve not only the research community but also to benefit the stakeholders, such as Apple.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Vetting Methodology</head><p>In this section, we introduce the vetting methodology (see the red box of <ref type="figure">Figure 4</ref>), which consists of dynamic analysis (cf. § 4.1) to select candidate apps, obtain a call stack from each app, static analysis and manual confirmation (cf. § 4.2) to scrutinize the network services of the candidate apps. The rationale behind the vetting methodology of "dynamic first, static later, and manual confirmation last" is that dynamic analysis can rapidly check for misconfigured network interfaces on a large scale, allowing us to pinpoint a small portion of candidate network service apps. The more time-consuming static analysis can then be used to perform a fine-grained analysis and check for potential vulnerabilities. Finally, we verify the identified vulnerabilities manually in order to ensure vulnerabilities are not misidentified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Dynamic Analysis</head><p>Dynamic analysis is used to check for remote accessible network interfaces in the wild. Specifically, we use dynamic analysis to check which app utilizes a network service and analyze the interface of the network service while preserving the call stack of the app. Vetting if apps provide network services. We leverage our dynamic analysis to detect whether apps provide network services. To provide network services, the standard process <ref type="bibr" target="#b12">[25]</ref> in light of POSIX Layer (see <ref type="figure" target="#fig_2">Figure 3</ref>) is to (i) create a socket, (ii) bind it to a port, and (iii) begin listening for incoming connections on that port. During the second step of the process, namely invoking _bind API, developers can pass rich parameters, indicating the property of the network service, to the _bind API to limit the access scope of the network service by designating the network interface as loopback for local host access or LAN for remote access from Wi-Fi/cellular networks.</p><p>To study the interface of a network service, we implement an "addon" for jailbroken iOS devices by using Cydia Substrate <ref type="bibr" target="#b59">[72]</ref>. The "addon" redirects the _bind API calls initiated by each analyzed app to the vetting code. As discussed in Section 2.3, we only consider remote adversaries because they are more practical threats to the apps. Therefore, by parsing parameters of _bind API, if the app uses the loopback interface (e.g., 127.0.0.1), the vetting code considers the app as safe and terminates the analysis. For the apps that use the LAN interface, for example, a developer passes a parameter 192.168.1.3 to _bind API, the vetting code in "addon" reports the app is accessible (i.e., a candidate app). We later run static analysis on these apps to vet the security of the network service. Call stack extraction. We carry out call stack extraction for generating unique signatures so we can identify system APIs and third-party libraries relevant to network services. For any active app, iOS maintains the runtime return address of a routine in a data structure known as the call stack. The call stack, filled with pointers, is depicted in the left-top box of <ref type="figure" target="#fig_6">Figure 8</ref>, where pointers indicate the site to which the routine should return when its execution is completed. Since the API _bind is a prerequisite for setting up a network service, to analyze the call trace reaching the _bind API, the call stack is preserved by our "addon" when analyzing the interface of the network service. The pointer in the call stack varies due <ref type="figure">Figure 6</ref>: The performance of our static analyzer. After the 113 apps pass our dynamic analysis, the static analysis (including decompilation, optimization, and slicing) takes 54 minutes per app on average. The overhead of decompiler should be in line with the instructions within an executable; however, for the executable larger than 120MB, memory compression and swapping time is involved as per the exhausted memory (16G), leading to a sharp increase of the time consumption of the decompiler and overall performance. The dramatic drop at 140MB is an exception that the instructions of the app are not in line with the executable size. The overall performance benefits from the slicer (on-demand inter-procedural), with comparison to the overhead of original inter-procedural analysis <ref type="bibr" target="#b36">[49]</ref> for program slicing, which takes in the order of days and is omitted herein.</p><p>to the Address Space Layout Randomization (ASLR) security mechanism of the iOS system. In order to map the runtime floating pointers in the call stack to the concrete offset of the static executable, the ASLR value for the executable is preserved. Limitations. Region lock checks (nine apps) from either iTunes or the developer may occasionally impede the dynamic analysis. In addition, social security numbers required (29 apps) for registration process or jailbreak detection (four apps) by developers will also prevent the apps from running. These apps account for 3.2% of our 1,300 seed apps. Subject to the accuracy of UI automation <ref type="bibr" target="#b28">[41]</ref>, the dynamic analysis would involve human interaction if necessary (e.g., app registration).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Static Analysis and Manual Confirmation</head><p>We note that only network services behind the LAN interface can reach the static code analysis. Dynamic analysis selects candidate apps that provide network services and excludes apps that use the loopback network interface. Next, by using static analysis, candidate apps are further narrowed down by using rules. Static analysis results are then manually confirmed.   <ref type="bibr" target="#b36">[49]</ref>, which is a static slicer for inter-procedural data-flow analysis on LLVM IR of 64-bit ARM binary. Specifically, three phases are involved in analyzing an iOS app, i.e., decompiling machine code to LLVM IR by using DAGGER <ref type="bibr" target="#b5">[9]</ref>, optimizing the IR, and slicing on the IR. To adapt this framework to our analysis task, we attempted to enhance the framework from the following aspects.</p><p>(i) We supplement semantics of more ARM instructions to the decompiler. Additionally, since the IR of a moderate app always consumes gigabytes of memory, some instructions are simplified to shrink the memory usage, such as removing floating point instruction. The simplification has little effect on the analysis results.</p><p>(ii) We convert inter-procedural data-flow analysis to ondemand inter-procedural <ref type="bibr" target="#b57">[70]</ref>. The complexity of point-to analysis in slicing is O(n 3 ) <ref type="bibr" target="#b9">[21]</ref>, where n is over ten million for a moderate app when performing inter-procedural analysis. This makes original analysis take several days to analyze an app. To speed up the performance, the on-demand interprocedural analysis starts analyzing the function enclosing the reference to the expected class object name or method name of a network service API. After slicing on the function and the callees (functions) are solved, it takes in all identified callees to start another slicing iteration. This strategy significantly reduces the n of point-to analysis. The overall performance of the static analyzer is depicted in <ref type="figure">Figure 6</ref>. We show that the overhead of the decompiler and slicer is almost linear in terms of the executable file size, and the slicing phase is bounded within a constant-time overhead.</p><p>(iii) We formulate and specify rules for the misuse of network services. For example, the static analysis result of the misuse of the GCDWebServer library is depicted in <ref type="figure" target="#fig_4">Figure 7</ref>. In comparison to dynamic analysis which investigates the network interface of an app, static analysis can check if the root folder of the web server is a data container directory, or a bundle container directory by using rule. The code of our static analyzer is publicly available at https://github.com /pwnzen-mobile.</p><p>Manual confirmation. To date, as the automated analysis is unable to verify iOS network service vulnerabilities end-toend, we resort to six expert researchers (three co-authors and three external experts) to identify private (e.g., cookies) or non-private (e.g., video clips) information, privileged functionality (e.g., install apps) exposure, and to study how to build a request to bypass the weak protection (e.g., hard-coded passwords) with the help of static analysis. The six expert researchers are separated into three groups and each group reports if the apps are considered vulnerable. Specifically, we focus on remote vulnerabilities for exploits. For example, although Waze provides a network service on port 12345 for the LAN interface and 55432 for the loopback interface simultaneously on startup, we only check the network service on port 12345. If private information or privileged functionality is exposed to cellular networks via a network service, we rank the vulnerable network service as high risk. If it is exposed to Wi-Fi networks, we rank the network service as medium risk. For non-private or non-privileged functionality, we rank the network service as low risk. For example, obtaining video snippets from the Prime Video app without authorization is ranked as low risk, since the video snippets are considered non-private. After generating all reports, the researchers discuss and finalize ranking the vulnerabilities. Limitations. The static analysis is efficient to identify security risks. Two types of divergence may occur in the static analysis: (i) Our on-demand inter-procedural analysis may result in loss of precision, subject to the failure of parsing 8.7% apps, leading to a false positive rate of 20.5%; (ii) 29.4% libraries implemented in C fail to be parsed through our static analyzer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Results of Vetting</head><p>In this subsection, we present the results of our dynamic and static analysis and our six expert researchers' verification. This process is performed on seed apps. Even with manual confirmation (done by six expert researchers), the entire vetting process for the 1,300 apps can be completed within 15 days. Dynamic analysis takes 2 days with one jailbroken iOS device (may need interaction) and static analysis, including the manual confirmation, takes 13 days.</p><p>Results of dynamic analysis. For the dynamic analysis, we install, launch, and uninstall each iOS app automatically by using ideviceinstaller <ref type="bibr">[12]</ref>. When the app reaches the main view, we end the dynamic vetting process, and collect the call stack of each analyzed app. Overall, 172 unique apps, 13.2% of our collected total, provide network services for either local or remote clients. <ref type="table" target="#tab_2">Table 2</ref> shows the details of our dynamic analysis. Our observations are as follows: (i) The dynamic port (the second column of <ref type="table" target="#tab_2">Table 2</ref>) to which a socket binds is usually used for in-app communication, and the network service on a dynamic port is immune to attacks; (ii) the apps that provide network services on multiple interfaces will be represented in each column; therefore, a unique app can be counted multiple times in this </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Building Signatures for Network Services</head><p>Two types of interfaces are available for developers to start up network services: by invoking system network service APIs or by using third-party libraries (see "app code" of <ref type="figure" target="#fig_2">Figure 3</ref>  signatures for system network service APIs and third-party libraries (see the red box of <ref type="figure">Figure 4</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Signatures of System APIs</head><p>System network service APIs and corresponding signatures are built on the call stack information recorded by our "addon" in our dynamic analysis phase. Specifically, we navigate the call stack to locate the system APIs and build hybrid signatures for the APIs.</p><p>Identifying system APIs. The challenge for identifying system network services is that there is no clear documentation that details the effects of API calls. For example, the API registerListener: of class object GKLocalPlayer spawns a port to provide the network service, but the official documentation does not mention the network service behind the API. Therefore, we identify the system network service APIs by leveraging the call stack information of the dynamically analyzed apps. Specifically, we travel the pointer in the call stack from top to bottom until we find the API the app code invoked. As shown in the top-left box of <ref type="figure" target="#fig_6">Figure 8</ref>, we travel the call stack from item 0 to 27, and stop traveling at item 1 as this pointer points to app code. By checking the target API of the app code invoked (top-right box of <ref type="figure" target="#fig_6">Figure 8</ref>), we get the system API (i.e., _bind). Building signatures for system APIs. The identified system APIs, presented as signatures for network services, can be used to determine whether the app is a potential network service app. There are two strategies for representing these APIs: (i) For network services provided by utilizing POSIX and Core Foundation <ref type="bibr" target="#b12">[25]</ref>, the API (e.g., _bind in <ref type="table" target="#tab_5">Table 3)</ref> is directly called by app code. In this case, the code for invoking APIs is directly assembled in the executable. By querying for this code in metadata preserved in our database, we know there is a network service in app or not. (ii) For the Objective-C APIs provided by other system frameworks, developers have to pass a message to an object through message dispatch interface (e.g., _objc_msgSend) to invoke the API. In this circumstance, the first and the second arguments of the message dispatch interface represent the instance of a class (e.g., _OBJC_CLASS_$_GKLocalPlayer in <ref type="table" target="#tab_5">Table 3</ref>) and a method (e.g., registerListener: in <ref type="table" target="#tab_5">Table 3</ref>), respectively. This class and method combination designates the real API being invoked. Hence, for the APIs of Objective-C, class object name in "Symbol <ref type="table">Table"</ref> and the method name in "String <ref type="table">Table"</ref> are used as signatures (see column 2 of <ref type="table" target="#tab_5">Table 3</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Signatures of Third-Party Libraries</head><p>Developers often use off-the-shelf third-party libraries to provide network services rather than building a server from scratch <ref type="bibr" target="#b14">[27,</ref><ref type="bibr" target="#b41">54]</ref>. There are many third-party network service libraries that reside on GITHUB or other repositories to help developers perform quick network service integration for their apps. For example, iOS app developers may opt for CocoaHTTPServer <ref type="bibr" target="#b3">[7]</ref> to provide web services. In order to figure out the real distributions of third-party libraries in iOS apps and extend our findings of the vulnerable libraries to the whole dataset, we firstly identify third-party network service libraries and extract signatures for these libraries. Previous work on Android third-party library identification <ref type="bibr" target="#b14">[27,</ref><ref type="bibr" target="#b63">76]</ref> is based on structurally organized code, (e.g., package), which does not scale well to iOS third-party library identification. Because there is no structure information preserved in the iOS executable, the developer's code and the statically linked third-party libraries are assembled into an executable binary file with no clear boundary. To find third-party libraries of iOS apps, the proposed class name cluster method <ref type="bibr" target="#b54">[67]</ref> expends enormous effort in building every library. But among these libraries, there are storage libraries for processing data, UI libraries for prettified views, etc. The third-party network service library is a subset of the whole library repository.</p><p>To identify the third-party network service libraries, we propose call stack similarity analysis, which is mainly used for hunting similar bugs <ref type="bibr" target="#b26">[39,</ref><ref type="bibr" target="#b52">65]</ref>, to identify these libraries. Our call stack analysis is based on the runtime properties of a program. After the third-party network service libraries are identified, we use Information Gain <ref type="bibr" target="#b46">[59]</ref> to select the most prominent signatures for these libraries. Identifying third-party libraries. The top-left box of <ref type="figure" target="#fig_6">Fig- ure 8</ref> shows that there are no rich information in the call stack C. Consequently, we map the call stack to the executable with the help of the ASLR value preserved in our dynamic analysis phase. We collect the strings s ii (e.g., "Error in listen() function" in <ref type="figure" target="#fig_6">Figure 8</ref>) in each method (e.g., "sub_10099E130" in <ref type="figure" target="#fig_6">Figure 8</ref>) that the pointers in the call stack point to in order to build a token t i . All t i acquired are concatenated to generate a longer token T (bottom-left box of <ref type="figure" target="#fig_6">Figure 8</ref>). Considering that the app code the pointers point to is always a mixture of developer's code and third-party library's code, so the token T collected is a mixture of t i from developer's code and third-party library's code. For example, the pointers in the call stack of the Covet Fashion app in <ref type="figure" target="#fig_6">Figure 8</ref> point to libraries Cocoa Async Socket (1, 2, 5), CocoaHTTPServer (6, 9), <ref type="bibr">Tapjoy (10, 11, 16, 17)</ref>, and developer's code (26) respectively; the token t i in developer's code (26) will affect similarity analysis since developer's code varies in different apps. To reduce noise induced by developer's code in similarity analysis, we propose a weighted edit distance algorithm to focus on the third-party library's code.</p><p>Since the third-party library's code is pointed by pointers at the top of the call stack, the token t i related to the top of the call stack is assigned a larger weight w i , and vice-versa. To factor in the weight, we duplicate t i multiple times according to the w i assigned to the token and then get a new longer token T 0 . After that, we measure the similarity ratio R of call stacks by using different T 0 . In practice, we adopt a Levenshtein edit distance ratio <ref type="bibr" target="#b50">[63]</ref> algorithm, that is</p><formula xml:id="formula_0">DistanceRatio(a, b) = 1 񮽙 EditDistance(a, b) |a| + |b|<label>(1)</label></formula><p>where a and b denote two tokens T 0 , respectively. The whole process is described in Algorithm 1.</p><p>Algorithm 1 Weighted edit distance for identifying third-party network service libraries Input: Call stack: C 1 , C 2 ; Token for call stack: T 1 , T 2 ; Output: Weighted edit distance of the two call stacks: R;</p><formula xml:id="formula_1">1: W Max(Len(C 1 ), Len(C 2 )) 2: T 0 1 GET_WEIGHTED_TOKEN(W,C 1 , T 1 ) 3: T 0 2 GET_WEIGHTED_TOKEN(W,C 2 , T 2 ) 4: R Levenshtein.ratio(T 0 1 , T 0 2 ) 5: function GET_WEIGHTED_TOKEN(W,C, T ) 6: for each i 2 [0,W 񮽙 1] do 7: w i W 񮽙 i 8: t i T [i] 9: t 0 i Duplicate(t i , w i ) 10: T 0 Concatenate(T 0 ,t 0 i ) 11:</formula><p>return T 0</p><p>The weighted edit distance can increase the edit distance ratio R of the call stacks for the same third-party network service library in different apps, but has slightly less influence for different libraries (see <ref type="table" target="#tab_6">Table 4</ref>). Empirically, we tune the parameter and finally consider as a third-party network service library if the ratio R 񮽙 0.6. Note that, the threshold is tuned to optimize the library identification. The results obtained are not overly-sensitive to the different thresholds chosen.</p><p>Building signatures for third-party libraries. In practice, if the similarity of two stacks reaches the threshold, the code pointed by the stack is considered as third-party libraries. Then we inspect the corresponding apps and tag the identified third-party network service libraries by searching GITHUB or GOOGLE. The most straightforward way to find the in-app network service is to identify the developer's code that exactly invokes the third-party network service API. However, this approach could be very time-consuming to scale up because it needs an extensive analysis of each app to build the API invocation due to the Objective-C runtime property, message dispatch <ref type="bibr" target="#b34">[47,</ref><ref type="bibr" target="#b54">67]</ref>. To address the challenge, we propose to use the string s ii relevant to the third-party library to generate a signature instead.</p><p>By leveraging the TF/IDF algorithm in GENSIM <ref type="bibr" target="#b58">[71]</ref>, we evaluate each s ii (bottom-left box of <ref type="figure" target="#fig_6">Figure 8</ref>) and obtain the prominent s ii , which is used for identifying third-party network service libraries. Finally, we obtain a &lt; signature,tag &gt; tuple for each library. For example, the GCDWebServer library is presented as &lt;"%@ started on port %i and reachable at %@", "GCDWebServer"&gt;. By using signatures of third-party network service libraries, we can execute a large-scale analysis of iOS apps and push forward the analysis boundary from the system APIs to thirdparty network service libraries (e.g., Section 7.2). Furthermore, the extracted signatures enable us to apply association analysis to figure out the relation between these third-party network service libraries.</p><p>In summary, the proposed library identification approach is specifically designed for a call trace which reaches the _bind API. The third-party library to which the call stack points is a network service library. This approach outperforms the cluster-based method <ref type="bibr" target="#b54">[67]</ref> by utilizing lower complexity (unnecessary to build the third-party library corpus before extracting network service libraries) and high precise (e.g., identifies the library Unreal Engine 4 which provides the network service but is commonly known as a game library) analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Results of Building Network Service Signatures</head><p>Using the proposed methodology, we identify six system APIs and 34 third-party libraries by analyzing the call stacks of seed apps. System network service APIs are collected by traveling the call stack. The results are shown in the first two columns of <ref type="table" target="#tab_5">Table 3</ref>. Third-party network service libraries are collected by analyzing the similarity of the call stack. The results are shown in x-axis of <ref type="figure" target="#fig_1">Figure 10</ref> and <ref type="table">Table 7</ref> in the Appendix. Given that there is no ground truth for the identification of network services, each app must be inspected to confirm the existence of network service usage. Unfortunately, inspecting more than one thousand apps is tedious and time consuming, so we instead chose to randomly sample 130 apps (10%) from the seed dataset. Each of the six expert researchers separately inspected each app and identified the use of system APIs and third-party libraries. Our analysis of the randomly sampled dataset suggests 100% accuracy, with 0% disagreement among the expert researchers, showing the effectiveness of our proposed system. Although the perfect accuracy would probably not be supported through verification of every app that we collected, with more time and effort, manual verification of a sample size greater than 400 apps (&gt; 30%) would give a more pronounced success rate. Furthermore, experimental results show that among the 1,300 apps, none of the apps is obfuscated, suggesting that obfuscation is not wildly applied to iOS apps to affect the analysis result (the detail is available on our website). We highlight that currently there is no benchmark dataset publicly available for any accuracy comparison of other iOS library identification approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Large-Scale Analysis of Network Services</head><p>We begin by analyzing the prevalence of the network service use in iOS apps. By taking signatures of APIs and libraries, we query the metadata of the collected apps stored in our database to find the percentage of apps that may use network services. We further analyze the association or interdependencies among these third-party network service libraries, in assistance with the extraction of apps for subsequent analysis. We highlight our main results in the remarks. (i) System network service APIs. To reveal the portion of iOS apps that make use of network services, we use the API signatures collected from the seed apps to query our database (see query result breakdowns in <ref type="table">Table 6</ref> in the Appendix). Apps assembling these APIs are potentially ready to start network services. As shown in <ref type="table" target="#tab_5">Table 3</ref> (columns 4 and 5), most of the apps follow the guidance of <ref type="bibr" target="#b12">[25]</ref>; specifically, using the API _CFSocketSetAddress of Core Foundation socket and the API _bind of BSD sockets can compose a network service. _res_9_nquery is an undocumented API used by iOS apps. Although Apple has documented the remaining three APIs, it does not clarify whether these APIs provide the network services.</p><p>Compared to the dynamic analysis results shown in <ref type="table" target="#tab_2">Table 2</ref>, our query found several-fold more apps capable of invoking system APIs for network services. We believe the reasons for the discrepancy are as follows: (i) The code snippet for invoking a system API for network services may be dead (i.e., unused or dummy) code; (ii) UI interaction may hinder execution of the code snippet that invokes these APIs, so dynamic analysis fails to pick it up.</p><p>The percentage of apps using network services decreases from 52.62% when querying the 1,300 seed apps to 40.98% when querying the 168,951 iOS apps (see the last two columns of <ref type="table" target="#tab_5">Table 3</ref>), since general apps are not as fully-featured as many of the top rate apps. Results grouped by category reveal that different categories of apps exhibit markedly different trends in their use of network services. Most iOS apps in the "Game" category are inclined to provide network services for multi-peer connection. These apps account for over 60% of  the designated categories. The categories "Reference" and "Photo &amp; Video" are comparably less likely to provide network services. Other libraries are distributed uniformly in different categories. The query results are depicted in <ref type="figure" target="#fig_7">Fig- ure 9</ref>. Remark 1. Network services are prevalent in iOS apps. 40.98% apps potentially invoke system APIs to provide network services. The results show that almost every top popular app in China (73.54%) contains code to start a network service. Queries further reveal that China apps are almost twice as likely to invoke network service APIs than their US counterparts (over 73.54% vs. over 40.37%).</p><p>(ii) Third-party network service libraries. iOS apps commonly integrate third-party libraries to provide their network services. In order to characterize the distribution of third-party network service libraries in iOS apps, we query the third-party libraries in top popular apps by using the collected signatures. As shown in <ref type="figure" target="#fig_1">Figure 10</ref>, we note that (i) as a basic support for establishing network services, CocoaAsyncSocket is a prevalent used third-party library in both the United States and China.</p><p>(ii) Apps from the United States are more willing to integrate the GCDWebServer, Google Cast, and UnityEngine.iOS third-party libraries. (iii) Due to poor accessibility of network resources in China, the Google Cast library is rarely used in apps from China. Libraries in China are largely more scattered in all categories than those in the United States. We further <ref type="figure" target="#fig_1">Figure 11</ref>: Third-party network service libraries across app categories. The color encodes the logarithm of the number of apps (log 2 (# apps)) using third-party libraries.</p><p>extend our analysis to the 168,951 iOS apps, and the results are grouped by the category of iOS apps (see breakdowns in <ref type="table">Table 7</ref> in the Appendix). As shown in the corresponding heatmap of <ref type="figure" target="#fig_1">Figure 11</ref>, we have the following observation.</p><p>Remark 2. Apps in the "Game" category are most likely to use third-party libraries. Besides the libraries of CocoaAsyncSocket and UnityEngine.iOS, the "Game" category mainly uses CocoaHTTPServer and Tapjoy-CocoaHTTPServer-Extension libraries. Among the top five used network service libraries, there are third-party libraries CocoaHTTPServer and GCDWebServer, providing various interfaces for developers to customize (e.g., designate the access interface, specify resources/functionalities) the network services. This may potentially lead to the library misuse.</p><p>(iii) The dependency relationship of network service libraries. The error-prone use of third-party libraries (e.g., <ref type="bibr">GCDWebServer, CocoaHTTPServer)</ref> are widely used in iOS apps. It is likely that these third-party network service libraries are supporting infrastructure for other libraries. We use the FP-GROWTH algorithm <ref type="bibr" target="#b39">[52]</ref> to mine the association of thirdparty libraries. The rules discovered by FP-GROWTH is listed in <ref type="table" target="#tab_7">Table 5</ref>. From <ref type="table" target="#tab_7">Table 5</ref>, we find dependencies between different third-party network service libraries. For example, the dependency of Tapjoy-CocoaHTTPServer-Extension can be depicted as Tapjoy-CocoaHTTPServer-Extension 񮽙! CocoaHTTPServer 񮽙! CocoaAsynSocket 񮽙! _bind (lines 1, 5, and 11 in <ref type="table" target="#tab_7">Table 5</ref>). This is verified by checking source code of this library. Even for closed source libraries, we know the dependency of the libraries from the table. For example, analysis result reveals that the closed source library TencentVideoHttpProxy is built on top of the open source CocoaAsyncSocket library (line 14). In the real world, the relations of third-party network service libraries are shown in the blue box of <ref type="figure" target="#fig_2">Figure 3</ref>. We also find the prevalent usage of Happy DNS library (demonstrated in <ref type="figure" target="#fig_1">Figure 10</ref>) in China leads to the prevalent usage of undocumented API usage _res_9_nquery in iOS apps (line 6). Based on the relation of network service libraries, we find that the widely used Ionic's Webview is built on top of the GCDWebServer. As the most recent version of Ionic's Webview has been adjusted to use loopback interface when integrating GCDWebServer, we can skip checking the apps using both GCDWebServer and Ionic's Webview libraries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Determining iOS App Vulnerabilities</head><p>In this section, we first closely examine the network service vulnerabilities discovered after vetting the 1,300 seed apps. We summarize four categories of vulnerabilities, and explain the details of two real-world vulnerable apps acknowledged by vendors, which are Waze, Now, and QQBrowser. Note that the acknowledgment of some vulnerabilities is pending. We finally scrutinize the vulnerabilities of 3 typical network service libraries in 168,951 iOS apps and discuss the underlying reason.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Vulnerabilities in Seed Apps</head><p>Previous 11 vulnerabilities identified among the 1,300 seed apps fall into four categories: (i) Connected with an IoT device with no/weak access control (Waze and SCOUT GPS LINK).</p><p>(ii) Served as a command server to execute command per the client's request (QQBrowser, Taobao4iPhone, and Youku).</p><p>(iii) Served as a file server to share files between a desktop computer and an iOS device (Now). (iv) Served as a content distribution networks (CDN) node to share videos with other peer devices. We regard these vulnerable apps (Amazon Prime Video, QQSports, etc.) of this category as low risks since the video clips shared are usually non-private.</p><p>(i) Remote Command Execution and Denial-of-Service: A case of an iOS app connected with an IoT device with no/weak access control. To connect with an IoT device, vulnerable apps always turn the iOS device to be a server. Two vulnerable apps, Waze and SCOUT GPS LINK, provide network services in the LAN interface for the IVI system, but these apps provide little to no access control. For example, Waze is a popular community-based traffic and navigation app in the United States. Dynamic analysis reveals that the app starts network service on port 12345 through the LAN interface. We also find that the network service on port 12345 accepts any connection attempts, and processes remote command messages in which a valid command message starts with "WL". The potential threats with the Waze network service are as follows. (i) For any incoming message (see M4 listed in <ref type="figure">Figure 2</ref>) starting with "WL", Waze will cache the message until the memory resource is exhausted (see M3 listed in <ref type="figure">Figure 2</ref>). Attackers can then drain the network traffic to crash the app remotely (A3). (ii) A message with format "WL|msgID|msgSize|msg" can be accepted by Waze and a malformed overlong message will lead to remote memory corruption, including OOB (out-of-boundary) access or UAF (use-after-free) (A3). (iii) The message "msgID" set to 48 can be used to send touch events to manipulate the app. The message can further reset the destination to maliciously navigate an end-user to alternative places (A1). The network service is pervasive, such that an attacker can even probe and attack iOS device with Waze running in cellular networks (A4). We have to mention that this vulnerability only exists in the iOS version of Waze since the Android version does not provide these network services. We reported the vulnerability to Waze company acquired by Google, Waze fixed this security issue three days after we reported, and Google finally acknowledged the vulnerability.</p><p>(ii) Data Leakage: A case of sharing files between a desktop computer and an iOS device. The current inconvenient file sharing of the iTunes client provides a chance for developers to ease the sharing process for users. Some apps turn an iOS device to be a web server for file sharing. The privacy-preserving sharing should be considered for access control but Now breaks the rule for file sharing. Now is a live broadcast and a popular social networking app in China. Dynamic analysis discovers that the app provides the network service on port 8080. Static analysis later reveals that the app sets the root folder of the network service to data container directory when using the third-party library GCDWebServer (see <ref type="figure" target="#fig_4">Figure 7</ref>). With this service, the app allows an unauthorized attacker (M2) to access the credentials within the data container directory of the app (M1). Data exposed by the app is depicted in <ref type="figure" target="#fig_1">Figure 12</ref>(a). By downloading credentials from the victim and uploading the acquired credentials to the attacker's device, the attacker can sign in the app using the victim's identity to perform in-app purchases with the pre-deposit money (A1). Similar to the Waze vulnerability, the attacker can scan the cellular network to identify the victims (A4). The vendor of this app, "Tencent Technology (Shenzhen) Company Limited," ranked this security issue as a high risk. This vulnerability was patched by switching off the relevant functionality remotely after we reported.</p><p>(iii) Remote Command Execution: A case of an iOS app executing command per the client's request. iOS apps may provide network services for end-users to manage the apps. However, the weak authorization may expose the services to any host in the same network with the victim. For example, an attacker can remotely compromise an iOS device by exploiting the flaw, e.g., the "exit" command disables the network service in Youku or "set" command controls UDID of Taobao4iPhone. Besides these two apps, a high risk vulnerability is discovered in the QQBrowser app. QQBrowser is a popular app, especially in China. Previous work showed the QQBrowser network service vulnerability in the Android app <ref type="bibr" target="#b19">[32]</ref>. By exploiting the vulnerability discovered in the Android app, an attacker can remotely perform unauthorized sensitive data access (e.g., obtain the app list or app setup) on the Android device. However, the same vulnerability has not been patched for the iOS counterpart. The port 8786 is used for connecting for Android, whereas the port 13145 is for iOS. Android implements the network service on NanoHTTPD library, whereas the iOS network service is established through an open source repository CocoaHTTPServer.</p><p>On top of the HTTP server, the iOS app provides the network service for two commands (i.e., "url" and "installurl"). Apart from the "installurl" command that drives the app to navigate to the items in iTunes, there are 9 additional sub commands behind "url" that provide more functionality, such as "tel" for dialing a specific number and "sms" for sending sms message (M1). These sub commands are enclosed in the body of a post request. In order to ensure the validity of each post request for the network service, the app enforces a Triple DES encryption to each post request and body data. However, the key (kM7hYp8lE69UjidhlPbD98Pm) for decryption is hardcoded in the app code (M2). This weak authorization can be bypassed by building a valid request for an attacker (A2). We demonstrate an example that the valid request would trigger the app to dial "10086": requests.post(http://+ip+:13145/ +encrypt_3des(data=send?uuid=a8f349666b833151a861e8beb6 11f21a&amp;type=url, key = key), data = encrypt_3des(data ='tel:10086', key = key), headers=headers). We have reported this vulnerability to "Tencent Security Response Center," which has ranked this security issue as a high risk. This vulnerability has already been patched in the most recent version.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Extensible Vulnerabilities of Affected Network Service Libraries</head><p>Through the lightweight large-scale analysis, we identify apps that use system APIs or integrate third-party libraries for network services. To have a better understanding of the network service vulnerabilities in the wild, we carry out static analysis of 2,116 apps, filtered out from the whole dataset, by using only the signatures of WebLink (3 apps), libupnp (16 apps), and GCDWebServer (2,097 apps). In the C library (e.g., WebLink and libupnp) vetting process, we manually verify the vulnerability; for Objective-C library, GCDWebServer for instance, we perform static analysis by using our static analysis tool. Dynamic analysis acts as an auxiliary for manual confirmation. We further identify an additional 92 vulnerabilities, and summarize them into three categories: (i) using vulnerable libraries, (ii) the abuse out-of-date vulnerable libraries, and (iii) the misuse of libraries.</p><p>(i) Using the vulnerable WebLink library. WebLink library, which renders the Waze app vulnerable, is used by another 3 apps: WebLink for KENWOOD, WebLink for JVC, and WebLink Host. In order to project a smart phone's screen to in-vehicle infotainment (IVI) systems, the WebLink library creates a virtual app screen on the IVI systems. To receive the commands from the virtual screen, it turns the iOS device into a server. By using this library, the app can capture user interactions on IVI systems. After studying this service, we find developers of the WebLink library make two mistakes in the design of the library. (i) Vendors mistakenly take the virtual screen and the smartphone as two logically separate devices as they use the LAN interface for connection (M4).</p><p>In fact, the virtual screen is a projector of the smartphone. (ii) There is no authorization required for executing the restricted functionality (M2), such that adversaries can remotely connect the smartphone via these apps and send touch events to manipulate (A1) or crash the app (A3).</p><p>(ii) Abusing the out-of-date vulnerable portable UPnP library. UPnP is a protocol that enables discovery, event notification, and control of devices over a network, independent of the operating system, programming language, or physical network connection.  <ref type="bibr" target="#b2">[4]</ref>; however, there is no warning for iOS apps. To quantify the impact of the Portable UPnP library vulnerability (i.e., # apps affected), we search this library among our collected dataset by using a signature. The result shows that 16 apps integrate the libupnp library, among 13 apps using out-of-date libupnp, 6 apps are seriously impacted by this library, these vulnerable apps have been installed millions of times. Interestingly, we find that the vendor "Flipps Media Inc." has upgraded the library in the product iMediaShare, whereas other products, Flipps TV (version 6.3.8) and FITE TV (version 2.1), are still using the vulnerable version of the library (e.g., "1.6.13."). The impacted apps are verified vulnerable by using module "multi/upnp/libupnp_ssdp_overflow" of Metasploit <ref type="bibr" target="#b45">[58]</ref>, which can crash the app remotely (A3) .</p><p>(iii) Misuse of the GCDWebServer library. The misuse of the GCDWebServer library exposes privacy or functionality to adversaries. To locate the misuse of this library, we look into the interface of the library and analyze how apps use this library. <ref type="bibr" target="#b1">2</ref> We highlight that multiple factors lead to the misuse of this library. In the case of a vulnerable "file listing service" when using this library, the following three factors constitute a rule for locating the misuse issue. (i) Arguments are passed to the library, indicating the use of the LAN interface. (ii) The root folder is set to the data container directory. (iii) The built-in file listing functionality is used by this app. The query result reveals that 2,097 apps integrate the GCDWebServer library. By using the association rule shown in <ref type="table" target="#tab_7">Table 5</ref>, the app integrating GCDWebServer which is a support for other libraries, is excluded. Finally, 517 apps are screened out, meaning they use this library exclusively. After checking these 517 apps using both static data-flow analysis, dynamic analysis and manual confirmation, 83 apps that misuse the GCDWebServer library are verified vulnerable. Note</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related Work</head><p>Vetting the security of network services. There has been a plethora of work dedicated to vetting the security of network services <ref type="bibr" target="#b10">[22,</ref><ref type="bibr" target="#b19">32,</ref><ref type="bibr" target="#b42">55,</ref><ref type="bibr" target="#b67">80]</ref> as well as hunting security bugs <ref type="bibr" target="#b22">[35,</ref><ref type="bibr" target="#b25">38]</ref> and malicious behaviors <ref type="bibr" target="#b21">[34,</ref><ref type="bibr" target="#b23">36,</ref><ref type="bibr" target="#b24">37]</ref> of Android apps. However, the analyzer for Android apps cannot be squarely applied to iOS due to the different programming language (e.g., Java and Objective-C). In addition, much work focuses on other security aspects of iOS apps, such as the secure usage of TLS/SSL certificates of iOS apps <ref type="bibr" target="#b54">[67]</ref> and the cryptographic misuse of iOS apps <ref type="bibr" target="#b36">[49]</ref>. <ref type="bibr">Kobold [44]</ref> examines access control flaws on iOS. However, security vetting for network services of iOS apps has not been extensively explored.</p><p>Third-party library identification. The current third-party library identification methodology falls into four categories: text-based <ref type="bibr" target="#b16">[29]</ref>, token-based <ref type="bibr" target="#b44">[57]</ref>, tree-based <ref type="bibr" target="#b17">[30]</ref>, as well as semantics-based <ref type="bibr" target="#b47">[60]</ref>. Android researchers have contributed widely to the third-party library identification <ref type="bibr" target="#b14">[27,</ref><ref type="bibr" target="#b35">48,</ref><ref type="bibr" target="#b63">76]</ref>. CRiOS <ref type="bibr" target="#b54">[67]</ref> is the only work focusing on third-party library identification in iOS. They clustered and studied the dependencies of classes in iOS apps in order to identify third-party libraries. CRiOS requires building all the third-party library repositories, whereas ours only builds a small portion of thirdparty network service libraries. Software testing techniques on iOS. (i) Dynamic analysis of iOS apps. <ref type="bibr">Szydlowski et al. [75]</ref> proposed an approach to tracking sensitive API calls by using debugger breakpoints and tried to automate the process by simulating the interaction with the identified UI views. ICRAWLER <ref type="bibr" target="#b43">[56]</ref> explored the UI states of iOS apps by hooking techniques to inspect the UI elements. DIOS <ref type="bibr" target="#b48">[61]</ref> utilized UI automation to retrieve the UI hierarchy and interact with UI elements to cover more code paths of iOS apps. IRIS <ref type="bibr" target="#b28">[41]</ref> transported the instrumentation framework, termed VALGRIND <ref type="bibr" target="#b53">[66]</ref>, to iOS to vet private API abuse. (ii) Static analysis of iOS apps. PIOS <ref type="bibr" target="#b34">[47]</ref> performed data-flow analysis to build the CFG and static taint analysis on top of the IDA <ref type="bibr" target="#b40">[53]</ref> to track the privacy transferred. MoCFI <ref type="bibr" target="#b27">[40]</ref> extracted the CFG of an app on top of the PiOS <ref type="bibr" target="#b34">[47]</ref> and checked whether the instructions that change an execution flow are valid at runtime. Chen et al.</p><p>[33] studied libraries in iOS and Android apps by considering invariant features between the two. We cross check the vulnerabilities identified and find none of these vulnerabilities exist in Android apps. <ref type="bibr">Feichtner et al. [49]</ref> proposed static analysis by using LLVM IR for iOS apps; however, the methodology needs to be adopted at scale. To the best of our knowledge, this is the first paper to systematically examine the security of iOS apps' network services on a large scale. We believe the vetting methodology and the results in this paper can inform security researchers as they closely inspect the iOS security in the future, and in particular, inform app developers and network operators on whether the policy of using the LAN network should be rectified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Concluding Remarks</head><p>Thanks to its open source framework, much work has already tested the security of Android apps. Unfortunately, Apple's closed ecosystem makes vetting iOS systems much more difficult. This paper proposes the first methodology for conducting a large-scale security analysis of iOS apps' network services. When applied to the top 1,300 iOS apps, our proposed approach found 11 apps with vulnerabilities, three of which were acknowledged by their vendors. Extending our analysis to 168,951 apps found an additional 92 vulnerabilities and showed that the most popular provenance for an iOS device remote attack involves turning the device into a server.</p><p>With hindsight that the inconsistent functionalities between Apple and Google will potentially trigger vulnerabilities, 3 for mitigation, we therefore recommend app developers to use the loopback interface as much as possible to avoid unnecessary use of the LAN interface, and to enforce the deliberately designed access control when using the LAN interface. Furthermore, to mitigate the attack via public Wi-Fi or cellular networks, we recommend network operators to implement stricter firewall strategies and block unknown connection attempts originating from the same LAN network. System vendors such as Apple should also apply a host-based firewall, such as the one adopted by the OS X system, to the iOS system. We hope that our findings can motivate iOS app developers to focus more on the security of their network services and that our methodology for determining faulty libraries can be used by stakeholders to vet the apps they choose to use or make. <ref type="bibr" target="#b33">46</ref>   </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The simplified inner structure of a Mach-O file.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Overview of system network service APIs and third-party network service libraries. The top sub-figure shows the relation among different third-party libraries leveraging BSD socket either directly or via system network service APIs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Performance of .ipa file decryption process. The time consumption is almost constant regardless the size of the .ipa file when only delivering the executable.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The static analysis result of the misuse of GCDWebServer in the Now app. The green item indicates a harmless usage of this library. The brown item reports another misuse of this library.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Static analysis.</head><label></label><figDesc>During the iOS app development, developers use a mixture of Objective-C and C or SWIFT to compose an app. To automatically analyze Objective-C and SWIFT binary, we opt to further optimize the open-source framework</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Overview of call stack analysis of Covet Fashion app. The subfigures on the left show the call stack and the extracted token for analyzing, the arrows indicate the returned address of a routine (right subfigure).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Network services across app categories.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Third-party network service libraries detected in the seed apps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Figure 12: Safari web-browser used to access the network service in the same host and Wi-Fi network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><head>Table 1 : Major Vulnerabilities Found.</head><label>1</label><figDesc></figDesc><table>App 
Vendor 
Vulnerability Impact 
Severity (by vendor) 
Status 1 CE: Command Execution. 
RCE: Remote Code Execution. 
DoS: Denial-of-Service. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><head>Table 2 : The results of our dynamic analysis of the apps ob- tained in the China and United States.</head><label>2</label><figDesc></figDesc><table>Dynamic 
Port (0) 
Loopback Interface 
(e.g., 127.0.0.1) 
LAN 
Interface 

China (480) 
16 (3.33%) 
14 (2.91%) 
51 (11.04%) 
United States 
(820) 
42 (5.12%) 
43 (5.24%) 
62 (7.01%) 

Total (1,300) 
58 (4.46%) 
57 (4.38%) 
113 (8.69%) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>table . We</head><label>.</label><figDesc></figDesc><table>found 65 unique 
apps from China and 107 from the United States that provide 
network services; and (iii) the analysis process was always 
performed in a Wi-Fi network. As shown in the last column 
of Table 2, a huge number (113) of iOS apps provide network 
services to other hosts in the same Wi-Fi networks, accounting 
for 8.69% of the 1,300 seed apps. Since developers can adjust 
their network services for different networks (i.e., Wi-Fi net-
works and cellular networks), the network services exposed 
to cellular networks are less than 8.69%. Compared to the 
apps in the United States, the apps in China are more inclined 
to provide network services on the LAN interface. That is, 
11.04% vs. 7.01%. 
Results of static analysis and manual confirmation. Based 
on dynamic analysis, we select candidate apps to examine in 
depth by static analysis and verify exploitable network ser-
vices by six exports' confirmation. Ultimately, we confirmed 
that 11 (9.7%) of the 113 candidate apps have vulnerabili-
ties, such as Waze, QQBrowser, Now, Scout GPS Link, and 
Youku. These vulnerable apps are described in Section 7. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><head>Table 3 : Signatures for system network service APIs and the network service distributions in iOS apps.</head><label>3</label><figDesc></figDesc><table>Library (a.k.a., Framework) 
Signatures 
Location 
China (480) United States (820) 
1,300 apps 
168,951 apps 
libSystem 
_bind 
Symbol Table 353 (73.54%) 
331 (40.37%) 
684 (52.62%) 69,238 (40.98%) 
libresolv 
_res_9_nquery 
Symbol Table 
56 (11.67%) 
1 (0%) 
57 (4.38%) 
1,481(0.88%) 
CoreFoundation 
_CFSocketSetAddress 
Symbol Table 112 (23.33%) 
57 (6.95%) 
169 (13%) 
11,965 (7.08%) 

GameKit (1) 
_OBJC_CLASS_$_GKLocalPlayer Symbol Table 
0 (0%) 
10 (1.22%) 
10 (0.77%) 
2,673 (1.58%) 
localPlayer 
String Table 
registerListener: 
String Table 

GameKit (2) 
_OBJC_CLASS_$_GKMatchmaker Symbol Table 
1 (0%) 
12 (1.46%) 
13 (1%) 
5,580 (3.3%) 
sharedMatchmaker 
String Table 
setInviteHandler: 
String Table 
MultipeerConnectivity 
_OBJC_CLASS_$_MCSession 
Symbol Table 
10 (2.08%) 
3 (0.37%) 
13 (1%) 
604 (0.36%) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="true"><head>Table 4 : Edit distance/weighted edit distance ratio R of call stack for third-party network service libraries.</head><label>4</label><figDesc></figDesc><table>Edit distance/ 
Weighted edit distance 
QQBrowser 
(CocoaHTTPServer) 

Taobao4iPhone 
(wangxin.taobao) 

Libby 
(GCDWebServer) 

QQSports 
(TencentVideoHttpProxy) 

bbtime (CocoaHTTPServer) 
0.74/0.82 
0.16/0.18 
0.36/0.37 
0.28/0.28 
Tmall4iPhone (wangxin.taobao) 
0.16/0.18 
1.00/1.00 
0.19/0.22 
0.12/0.18 
NOW (GCDWebServer) 
0.37/0.37 
0.17/0.19 
0.89/0.91 
0.30/0.29 
KuaiBao (TencentVideoHttpProxy) 
0.31/0.31 
0.15/0.20 
0.30/0.30 
0.54/0.66 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="true"><head>Table 5 : Association of third-party network service libraries and system network service APIs.</head><label>5</label><figDesc></figDesc><table># 
Library/API 
Library/API 

1 Tapjoy-CocoaHTTPServer-Extension CocoaHTTPServer 
2 Tapjoy-CocoaHTTPServer-Extension CocoaAsyncSocket 
3 PDRCoreHttpDaemon 
_CFSocketSetAddress 
4 Ionics_Webview 
GCDWebServer 
5 CocoaHTTPServer 
CocoaAsyncSocket 
6 Happy_DNS 
_res_9_nquery 
7 MAASDK 
CocoaAsyncSocket 
8 Ionics_Webview 
_bind 
9 wangxin.taobao 
_CFSocketSetAddress 
10 MongooseDaemon 
_bind 
11 CocoaAsyncSocket 
_bind 
12 Tapjoy-CocoaHTTPServer-Extension _bind 
13 CocoaHTTPServer 
_bind 
14 TencentVideoHttpProxy 
CocoaAsyncSocket 
15 Platinum_UPnP 
_bind 
16 GCDWebServer 
_bind 
17 upnpx 
_bind 
18 DIAL_UPnP 
_bind 
19 WebRTC 
_bind 
20 SmartDeviceLink 
_bind 
21 Connect_SDK_Core_(iOS) 
DIAL 
22 FunTV 
CocoaAsyncSocket 
23 Unreal_Engine_4 
Game_Kit_(2) 
24 TencentVideoHttpProxy 
CocoaHTTPServer 
25 wangxin.taobao 
_bind 
26 UnityEngine.iOS 
_bind 

</table></figure>

			<note place="foot" n="1"> Banner is a specific message to uniquely identify a network service. For instance, after connected to the network service of the Waze app, a client will receive the message &quot;WL&quot; from the server. 2418 29th USENIX Security Symposium USENIX Association</note>

			<note place="foot" n="2"> The automated static analysis process and results are available at https: //sites.google.com/site/iosappnss/home. that, static analysis helps us to find more vulnerabilities behind user interaction. For instance, with the vulnerability in GCDWebServer library (CVE-2019-14924 [11]), the vulnerability in the JDRead app arises when a user is turning on the file sharing functionality of the app, and the QQMail exposes attachment to the adversary in the same Wi-Fi network when a user is reviewing the attachment in an email.</note>

			<note place="foot" n="3"> One example is that Android provides cast functionality to project smartphone&apos;s screens to third-party screens while iOS developers must adopt an error-prone TCP-relay to implement such functionality.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank William Enck and the anonymous reviewers for their valuable feedback. We thank Cameron Ballard and Benjamin Zhao for proofreading the early version of this paper. We thank Xiaobo Chen, Tao Huang, and Jian Zhang, affiliated to PWNZEN InfoTech Co., LTD, for their valuable assistance of our manual analysis. This work was supported, in part, by the National Key Research and Development Program of China (2018YFE0126000, 2017YFB0802901) as well as the National Science Foundation of China <ref type="bibr">(61972453,</ref><ref type="bibr">61672350)</ref>. Haojin Zhu (zhu-hj@cs.sjtu.edu.cn) is the corresponding author of this paper.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sdk</forename><surname>Linux</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>for UPnP Devices (libupnp</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wormhole</surname></persName>
		</author>
		<ptr target="http://xlab.baidu.com/wp-content/uploads/2016/01/wormhole_external_final.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">How to fix apps with the portable SDK for UPnP library vulnerabilities</title>
		<ptr target="https://support.google.com/faqs/answer/6346109?hl=en-GB" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cocoahttpserver</surname></persName>
		</author>
		<ptr target="https://github.com/robbiehanson/CocoaHTTPServer" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frida</forename></persName>
		</author>
		<ptr target="https://www.frida.re/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dagger</surname></persName>
		</author>
		<ptr target="http://dagger.repzret.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Api</forename><surname>Itunes Search</surname></persName>
		</author>
		<ptr target="https://affiliate.itunes.apple.com/resources/documentation/itunes-store-web-service-search-api/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Waze</surname></persName>
		</author>
		<ptr target="https://www.waze.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Weblink</surname></persName>
		</author>
		<ptr target="https://www.abaltatech.com/press/weblink-from-abalta-technologies-brings-popular-waze-smartphone-app-into-the-connected-car" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Program analysis and specialization for the C programming language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">O</forename><surname>Andersen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
		<respStmt>
			<orgName>University of Cophenhagen</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Nearby threats: Reversing, analyzing, and attacking Google&apos;s&apos; &apos;nearby connections&apos; on Android</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Antonioli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">O</forename><surname>Tippenhauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Rasmussen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Make and receive calls on your Mac, iPad, or iPod touch</title>
		<ptr target="https://support.apple.com/en-hk/HT209456" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Writing a TCP-based server</title>
		<ptr target="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/UsingSocketsandSocketStreams.html#//apple_ref/doc/uid/CH73-SW8" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for Android apps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Arzt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rasthofer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fritz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bodden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bartel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Le Traon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Octeau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mcdaniel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Sigplan Notices</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Reliable third-party library detection in android and its security applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bugiel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Derr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Discovering and exploiting novel security vulnerabilities in Apple zeroconf</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Bai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Liao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-M</forename><surname>Hu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
			<pubPlace>In Black Hat USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">On finding duplication and near-duplication in large software systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">S</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Working Conference on Reverse Engineering</title>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Clone detection using abstract syntax trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">D</forename><surname>Baxter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Yahin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Moura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sant&amp;apos;anna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE ICSM</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Discovering flaws in security-focused static analysis tools for Android using systematic mutation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bonett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kafle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Moran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nadkarni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Poshyvanyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">When program analysis meets mobile security: An industrial study of misusing Android Internet sockets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Bu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM FSE</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Following devil&apos;s footprints: Cross-platform analysis of potentially harmful libraries on Android and iOS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Stormdroid: A streaminglized machine learning-based system for detecting Android malware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ASIACCS</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Are mobile banking apps secure? What can be improved</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM ESEC/FSE</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Automated poisoning attacks and defenses in malware detection systems: An adversarial machine learning approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
			<publisher>Elsevier Computers &amp; Security</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">GUI-Squatting Attack: Automated generation of Android phishing apps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE TDSC</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">An empirical assessment of security risks of global Android banking apps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM/IEEE ICSE</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">ReBucket: A method for clustering duplicate crash reports based on call stack similarity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Nobel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE ICSE</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">MoCFI: A framework to mitigate controlflow attacks on smartphones</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dmitrienko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Holz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Nürn-Berger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">iris: Vetting private API abuse in iOS applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Saltaformaggio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">SandScout: Automatic detection of flaws in iOS sandbox profiles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Deshotels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Deaconescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chiroiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">iOracle: Automated evaluation of access control policies in iOS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Deshotels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Deaconescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Carabas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Manda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chiroiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM AsiaCCS</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Kobold: Evaluating decentralized access control for remote NSXPC methods on iOS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Deshotels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Carabas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Beichler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Deaconescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Androguard</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Things you may not know about Android (un) packers: A systematic study based on whole-system emulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Bhaskar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">PiOS: Detecting privacy leaks in iOS applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Obfuscation-resilient code recognition in Android apps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Feichtner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rabensteiner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE ARES</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Automated binary analysis on iOS-a case study on cryptographic misuse in iOS applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Feichtner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Missmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Spreitzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Security and Privacy in Wireless and Mobile Networks</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Elasticsearch: The Definitive Guide: A Distributed Real-Time Search and Analytics Engine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gormley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Tong</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
			<publisher>Reilly Media, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">3G/4G Intranet scanning and its application on the wormhole vulnerability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Guangdong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Zhang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Mining frequent patterns without candidate generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Sigmod</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pro</forename><surname>Ida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Debugger</forename><surname>Disassembler</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A first look at mobile ad-blocking apps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ikram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Kaafar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Network Computing and Applications</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Open doors for Bob and Mallory: Open port usage in Android apps and security implications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">J</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">A</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">M</forename><surname>Mao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE EuroS&amp;P</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Reverse engineering iOS mobile applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Joorabchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mesbah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Working Conference on Reverse Engineering</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">CCFinder: A multilinguistic token-based code clone detection system for large scale source code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kamiya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kusumoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Metasploit: The penetration tester&apos;s guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kennedy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>O&amp;apos;gorman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kearns</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Aharoni</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<publisher>No Starch Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Information gain and a general measure of correlation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">T</forename><surname>Kent</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Using slicing to identify duplication in source code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Komondoor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Horwitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Static Analysis Symposium</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Dios: Dynamic privacy analysis of iOS applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kurtz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Weinlein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Settgast</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Freiling</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Understanding iOS-based crowdturfing through hidden UI analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Liao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Mi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Binary codes capable of correcting deletions, insertions, and reversals</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">I</forename><surname>Levenshtein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Soviet Physics Doklady</title>
		<imprint>
			<date type="published" when="1966" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Security flaws in universal plug and play: Unplug. don&apos;t play</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Moore</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Automatically discovering, reporting and reproducing Android application crashes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Moran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Linares-Vásquez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bernal-Cárdenas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Vendome</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Poshyvanyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE ICST</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Valgrind: a framework for heavyweight dynamic binary instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Nethercote</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Seward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Sigplan Notices</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">CRiOS: Toward large-scale iOS application analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Orikogbo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Büchler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Egele</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SPSM</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Mach-O file format reference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Os</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Execute this! Analyzing unsafe and malicious dynamic code loading in Android applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Poeplau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Fratantonio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bianchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Cryptoguard: High precision detection of cryptographic vulnerabilities in massive-sized Java projects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rahaman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Afrose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Shaon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Frantz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kantarcioglu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">D</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title level="m" type="main">Gensim-Python framework for vector space modelling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rehurek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sojka</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">Cydia substrate, the powerful code modification platform behind Cydia</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Saurikit</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<title level="m" type="main">Zero Configuration Networking: The Definitive Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">H</forename><surname>Steinberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Cheshire</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<publisher>Reilly Media, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">A billion open interfaces for Eve and Mallory: MitM, DoS, and tracking attacks on iOS and macOS through Apple wireless direct link</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stute</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mariotto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Heinrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kreitschmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Noubir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hollick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Challenges for dynamic analysis of iOS applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Szydlowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Open Problems in Network Security</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m" type="main">Securing Android applications via edge assistant third-party library detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ying</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Soot: A Java bytecode optimization framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Vallée-Rai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Co</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gagnon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hendren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sundaresan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CASCON First Decade High Impact Papers. IBM Corp</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">On the feasibility of large-scale infections of iOS devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Tackling runtime-based obfuscation in Android with TIRO</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Understanding open ports in Android applications: Discovery, diagnosis, and security assessment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Deng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
