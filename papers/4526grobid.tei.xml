<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:23+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Provenance Segmentation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rui</forename><surname>Abreu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Palo Alto Research Center</orgName>
								<orgName type="department" key="dep2">Inc</orgName>
								<orgName type="department" key="dep3">Inc</orgName>
								<orgName type="department" key="dep4">Palo Alto Research Center</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dave</forename><surname>Archer</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Palo Alto Research Center</orgName>
								<orgName type="department" key="dep2">Inc</orgName>
								<orgName type="department" key="dep3">Inc</orgName>
								<orgName type="department" key="dep4">Palo Alto Research Center</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erin</forename><surname>Chapman</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Palo Alto Research Center</orgName>
								<orgName type="department" key="dep2">Inc</orgName>
								<orgName type="department" key="dep3">Inc</orgName>
								<orgName type="department" key="dep4">Palo Alto Research Center</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Cheney</surname></persName>
							<email>jcheney@inf.ed.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Palo Alto Research Center</orgName>
								<orgName type="department" key="dep2">Inc</orgName>
								<orgName type="department" key="dep3">Inc</orgName>
								<orgName type="department" key="dep4">Palo Alto Research Center</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hoda</forename><surname>Eldardiry</surname></persName>
							<email>hoda.eldardiry@parc.com</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Palo Alto Research Center</orgName>
								<orgName type="department" key="dep2">Inc</orgName>
								<orgName type="department" key="dep3">Inc</orgName>
								<orgName type="department" key="dep4">Palo Alto Research Center</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Adrì</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Palo Alto Research Center</orgName>
								<orgName type="department" key="dep2">Inc</orgName>
								<orgName type="department" key="dep3">Inc</orgName>
								<orgName type="department" key="dep4">Palo Alto Research Center</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gascón</forename></persName>
							<email>agascon@inf.ed.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Palo Alto Research Center</orgName>
								<orgName type="department" key="dep2">Inc</orgName>
								<orgName type="department" key="dep3">Inc</orgName>
								<orgName type="department" key="dep4">Palo Alto Research Center</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Provenance Segmentation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Using pervasive provenance to secure mainstream systems has recently attracted interest from industry and government. Recording, storing and managing all of the provenance associated with a system is a considerable challenge. Analyzing the resulting noisy, heterogeneous , continuously-growing provenance graph adds to this challenge, and apparently necessitates segmentation, that is, approximating , compressing or summarizing part or all of the graph in order to identify patterns or features. In this paper, we describe this new problem space for provenance data management, contrast it with related problem spaces addressed by prior work on prove-nance abstraction and sanitization, and highlight challenges and future directions toward solutions to the provenance segmentation problem.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The relationship between provenance and security has been considered by a number of authors over the last few years. Some researchers have proposed using provenance as a basis for security (e.g. provenance-based access control <ref type="bibr" target="#b21">[20]</ref>) as well as of the security implications of provenance-tracking (e.g. techniques for provenance abstraction, sanitization, or redaction; see <ref type="bibr" target="#b6">[6]</ref> for a survey). An emerging application of provenance is its use in analyzing cause and effect in system activity as a means of identifying security threats to that system.</p><p>An advanced persistent threat (APT) is a stealthy, long-term application intended to penetrate a system, persist in it, and carry out either pre-determined or dynamically updated instructions from an adversary. Those instructions may result in continuing exfiltration of sensitive data as seen in the Office of Personnel Management (OPM) data breach <ref type="bibr" target="#b20">[19]</ref>, continuing corruption of data <ref type="bibr" target="#b8">[8]</ref>, or the capability to shut down <ref type="bibr" target="#b3">[3]</ref> or damage <ref type="bibr" target="#b10">[10]</ref> critical systems such as the industrial control systems that manage power grids. The stealthiness of APTs makes it difficult to detect them. APTs tend to rely on actions that violate no system security policies, nor any social Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.  The increase in such sophisticated threats has motivated the use and mining of pervasive provenance to identify relationships among system activities that may indicate malicious actions undetectable by policy-driven approaches. For example, DARPA's recently-funded Transparent Computing research program aims to instrument critical systems with pervasive logging of system activities, and apply provenance analysis that continuously monitors such logs to identify actions that could be part of an APT. The idea of monitoring provenance-like records to aid security has appeared in several places <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b22">21]</ref>, but there are numerous challenges to making it a reality.</p><p>In a transparent computing system, there is a separation of concerns between provenance recorders, which run on the critical systems we wish to protect, and provenance analysis, which may run on separate systems, either in forensic (batch processing) or online (stream processing) mode. It is expected that provenance recorders will provide large volumes of data at high velocity (at least in streaming mode). Therefore, provenance analysis systems will need to deal with large and rapidly growing data sets and do so with latencies that allow cyber network defense (CND) operators to mount effective defenses.</p><p>We are among the participants in the ADAPT (A Diagnostic Approach to Advanced Persistent Threat detection) project within the DARPA Transparent Computing program, whose goal is to analyze and recognize advanced persistent threats in provenance graphs. Our approach seeks to combine state-of-the-art provenance and database management technology, statistical anomaly detection, machine learning and diagnostics techniques <ref type="bibr" target="#b0">[1]</ref>. In the initial stages of the design of this system, we have identified the interface between the large-scale provenance graph data and the inputs expected by existing anomaly detection and classification and diagnostics techniques as a key design question. In particular, it appears necessary to perform some kind of approximation or downsampling on the raw provenance graph in order to provide inputs of manageable size for later stages. We call this problem provenance segmentation.</p><p>The ADAPT system (illustrated in <ref type="figure" target="#fig_1">Fig. 1</ref>) receives provenance graph data emitted by other systems. It ingests the data by storing the raw provenance graph in a graph database, then segments the graph to define an approximate provenance graph (which we call the segment layer) that can be used as a high-level proxy for the raw graph. Feature extraction is then performed on segments to summarize their contents. The segment layer and feature annotations are intended for the use of later stages (not shown) that recognize various types of activity detected in the graph, detect normal or abnormal behavior, or diagnose potential APT activity by analyzing causal relationships and matching patterns of behavior against known strategies recorded in a knowledge base. The intent is that most of the work of later stages can be performed at the segment layer, and when potential attacks are identified at that layer, the raw graph of the relevant segments can be inspected in detail.</p><p>In this paper, we present our analysis of the segmentation problem, whose requirements and design constraints have turned out to be relatively difficult to pin down, and differs in subtle but important respects from prior work on graph abstraction. This is work in progress, and we do not report on a fully-evaluated research contribution, but rather we hope that carefully describing the problem space will be of interest to other researchers seeking challenges in provenance data management. We believe that the problem(s) of segmentation are likely to be shared by other research projects seeking to analyze large amounts of continuously growing provenance data, and hope that calling attention to this problem will spur progress in this area.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Problem statement</head><p>We assume standard notation for directed, labeled graphs</p><formula xml:id="formula_0">G = (V, E ⊆ V × V, λ : V ∪ E → Σ)</formula><p>where Σ is some set of labels on vertices and edges. We define a segment to be a subgraph of G and write Seg(G) for the set of all segments of G.</p><p>We consider two high-level forms of the segmentation problem.</p><p>• The batch segmentation problem takes as input a graph (the raw graph), a collection of segmentation criteria that define segments and the relationships among them, and produces as output a summary graph (the segment layer), along with crosslinks from the nodes of the segmentation layer to the associated subgraphs.</p><p>• The incremental segmentation problem takes as input a raw graph, segmentation criteria and a sequence of insertions to the graph. The problem is to initialize and maintain the segmentation layer efficiently as the updates to the graph are performed.</p><p>In both cases, the principal output is the segment layer G = (V , E , λ ) along with a mapping Sg : V → Seg(G) from vertices of the segment layer to their associated segments, that is, subgraphs of G.</p><p>We do not assume that we have control over the behavior of the provenance recorders providing the input graph. Therefore, although we informally refer to the input graph as the provenance graph and the edge relationships as causal, this terminology should be taken with a grain of salt: it assumes a level of shared under- standing between recorders and analyzers concerning the semantics of the provenance graphs that has not yet been attained. In this paper, we focus on defining segmentation pragmatically in terms of structural properties of the input graph, and place the question of whether the input graph is "correct" or "complete" outside the scope of this paper. The provenance recorders will provide data by which to structure G as well as data that will describe the nodes and edges of G. For the moment, we consider two basic kinds of segmentation criteria based on such properties attached to nodes and edges in G. We note that these kinds of segmentation can obviously be combined or generalized:</p><p>• neighborhood segments consisting of all nodes and edges within a given distance of a given node; for example, all activity involving the process with PID 9002.</p><p>• temporal segments containing all activity observed (or reported) in some time interval (of any length); e.g. all activity between 11:00 and 11:05 GMT on December 1, 2015, or all activity during December 2015.</p><p>We believe that the former has direct application to APT discovery, while the latter may or may not, because APTs are typically extended campaigns with activities that occur over months to years, possibly eluding short-term time-based analysis. Segmentation may also draw on techniques for pattern-based semantic annotation of the graph (which we call "pattern extraction" in our current architecture).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Requirements</head><p>The functional requirements on the solution of the segmentation problems introduced above are related to the specific purpose of the segmentation process. The architectural overview depicted in <ref type="figure" target="#fig_1">Figure 1</ref>, in particular in the case of the incremental segmentation problem, can be seen as an instance of runtime verification. Runtime verification is a program analysis technique based on monitoring the execution of a running system in order to react to observed behavior satisfying a certain property. In runtime verification, an execution trace, i.e. a fixed representation of the execution, is provided in an online fashion to some inference system that checks the property to be verified. The segmentation process of the ADAPT system can be seen as an abstraction/annotation process of the execution trace to be provided to the inference systems that ultimately detect an ongoing attack.</p><p>Although detailing the algorithms that operate on the segmented graph produced by the segmenter is out of the scope of this paper, we identify several classes of requirements.</p><p>Updatability The interaction between the segmenter and the classification and diagnosis algorithms could also use feedback from such inference systems to refine the segmentation, as in a Counterexample-Guided Abstraction Refinement (CEGAR) <ref type="bibr" target="#b7">[7]</ref>. A scalable approach using this kind of technique would require an efficient way of updating the segmentation. This would require a data model for segments that supports efficient updates, which would in turn provide a way for the algorithms in charge of ultimately finding attacks to "guide" the segmentation.</p><p>Validity Intuitively, we would like it to be the case that the segmentation layer does not lose information with respect to the full graph: for example, does not introduce or remove existing paths. However, since the purpose of segmentation is to provide a more compact and tractable representation of the graph, information loss is sometimes inevitable. For example, <ref type="figure" target="#fig_2">Figure 2</ref> illustrates a segmentation of a graph and an edge that is required in order to preserve paths, but also introduces a false path. Therefore, "correctness" will generally be a weaker property, such as that all paths are preserved (but some false paths are introduced), or vice versa.</p><p>Hierarchical decomposition The segment layer should enable multi-resolution modeling where activity recognition algorithms can operate on high-level representations of the graph, and also zero in on low-level details when necessary. The goal of the activity classifier is to annotate the provenance graph with semantic descriptions of activities within each segment. This can involve recognizing composite activities. For example, an activity "remote shell access" is composed of a sequential set of logged events "browser forking bash", "bash initiating Netcat", and "Netcat listening on new port". The segmentation technique should therefore capture the various levels of semantic abstraction.</p><p>Features The segment layer should provide summary information useful for activity classification and normalcy detection models. These models will consume feature vectors that characterize key properties of the provenance graph (e.g., graph normality), perform intelligent analysis of these features, and output normalcy scores or activity descriptions. Different segmentations will provide different "views" of information in the provenance graph that will be useful to construct these features. For example, one view of the data may produce vectors that correspond to login activity or activity related to a system resource, such as a password file. This will enable ADAPT to implement powerful information fusion approaches to combine multiple sources of evidence during provenance analysis <ref type="bibr" target="#b11">[11]</ref>. As a starting point, features could consist of any aggregate queries answerable from the segment extent.</p><p>Boundary definitions The segment layer should provide boundary definitions that allow useful local activity classifications within segment boundaries. The diagnostic engine can then globally recognize APT activities that span multiple segments, crossing these segment boundaries. Key challenges such as segmentation noise and fuzzy boundaries, where activities span multiple segments, should be considered.</p><p>Properties of the segmentation layer It is not yet clear what properties are desirable for the segmentation layer; this is a topic of active discussion. For example, some diagnosis algorithms require a directed acyclic graph, whereas there may easily be cycles in the segmentation layer according to the relationships mentioned at the beginning of this section. Do these cycles need to be removed (as, for example, in PASS <ref type="bibr" target="#b19">[18]</ref>), in some principled way? Likewise, the segmentation layer is redundant, in the sense that it may be recomputed. Are segments themselves persistent or volatile? How long should they persist?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Design Considerations</head><p>Scale and Incremental Processing We are interested in segmentation in order to mediate between a large, and rapidly growing, amount of detailed data and sophisticated classification or diagnosis algorithms. Thus, the segmentation process itself must scale to large amounts of data. This suggests that segments should be relatively small, simple and easy to identify. Likewise, assuming the raw graph is stored in a database, it seems advantageous for segments to be easily definable via queries (and recorded using updates) in the same formalism.</p><p>Segment constraints and representations Other forms of provenance abstraction make stronger assumptions on the structure of the abstracted subgraphs, such as convexity (see the next section for additional discussion). We also want to record the relationship between a node in the segment layer and its extent (the actual subgraph it represents). Representing a segment explicitly as a set of nodes and edges could become expensive, however. If segments are assumed convex, then only the set of nodes needs to be recorded and the edges can be inferred. For non-convex segments, efficient representations (and techniques for recovering the extent from the representation) may need to be designed.</p><p>Incomplete information Temporal segments can be defined either in terms of the transaction time (that is, the time the corresponding raw graph data is recorded or entered into the database) or valid time (that is, the time the recorded events actually happened, according to the monitor). Valid time appears preferable, but complete valid time for all events may not be available, which leads to a problem of incomplete information (similar to that studied by Kwasnikowska et al. <ref type="bibr" target="#b15">[15]</ref> for OPM). If transaction time is used, this may affect the extent to which time-based information at the segmentation layer is useful to later processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Related approaches</head><p>Provenance segmentation is similar to several previously-studied problems, such as user views <ref type="bibr" target="#b4">[4]</ref>, hierarchical provenance <ref type="bibr" target="#b5">[5]</ref>, provenance publishing <ref type="bibr" target="#b9">[9]</ref>, and provenance abstraction <ref type="bibr" target="#b18">[17]</ref>. We surveyed several provenance abstraction techniques previously <ref type="bibr" target="#b6">[6]</ref>; here we focus only on closely related work.</p><p>User views, as implemented in the ZOOM system <ref type="bibr" target="#b4">[4]</ref>, mediate the full detail of the provenance graph for consumption by users who may only be interested in high-level details. Given a workflow and a specification of the workflow steps that are of interest to the users, ZOOM computes a provenance graph that (roughly speaking) combines uninteresting nodes as much as possible. While the end result is similar to the segmentation layer, ZOOM requires a pre-defined workflow graph that can be annotated with user preferences. In our setting, we have no such workflow and even if we did, it is not clear how to elicit appropriate preferences.</p><p>Buneman et al. <ref type="bibr" target="#b5">[5]</ref> proposed a hierarchical data model for provenance, and a technique for populating the hierarchical representation starting from simple functional programs, and using the call hierarchy as the basis for extracting abstract "views" of the raw graph. The segmentation layer we consider can be viewed as an instance of this data model (with just one layer of abstraction), but the techniques for populating and viewing the data are not directly applicable in this setting because (as with ZOOM) there is no fixed, known "program" generating the provenance graph.</p><p>Archer et al. proposed a hierarchical model for provenance of relational data as part of the Multi-granularity, Multi-Provenance Model (MMP) <ref type="bibr" target="#b1">[2]</ref>. MMP encodes provenance at the coarsest granularity for each relational algebra operation. MMP database instances thus store the minimum metadata needed to represent complete provenance of the data. The segmentation layer we consider can be viewed as a data model layer analogous to the higher levels of the relational model such as records or relations. However, the techniques proposed in that work only apply to relational data and the usual operators used to define, manipulate, and query such data.</p><p>The ProPub system <ref type="bibr" target="#b9">[9]</ref> "publishes" provenance according to a policy, specifying the requirements on what components of the provenance graph to make visible and what components to abstract. The ProvAbs system <ref type="bibr" target="#b18">[17]</ref> considers provenance graph abstraction operations such as taking the "convex closure" of a subgraph (to include all nodes and edges between existing nodes of the subgraph), extending subgraphs to make them compatible with an abstracted node type, and replacing a subgraph with an abstracted node. Both ProPub and ProvAbs operate on provenance graphs and do not require a workflow or program to be specified in advance. However, segments need not be convex and the segmentation graph need not be a provenance graph so it is unclear whether ProPub or ProvAbs policies match the requirements for provenance segmentation.</p><p>Provenance segmentation also appears related to the problem of streaming graph partitioning <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b23">22]</ref>. The goal of graph partitioning is to distribute graph data across nodes so as to allow efficient distributed query processing. When the graph data is continuously growing, it is of interest (just as in the case of provenance segmentation). However, the end result of (streaming) graph partitioning is a fixed partition of the whole graph, possibly with a query workload in mind <ref type="bibr" target="#b12">[12]</ref>. In contrast, segments may overlap and not all nodes are part of a segment.</p><p>Provenance segmentation is also related to graph summarization. Related work <ref type="bibr" target="#b13">[13]</ref> aims to exploit the graph structure to summarize and compress relational knowledge. This is done by extracting patterns and compressing structural knowledge encoded within relational graphs. Potential compression paths are found within repetitive or sequential structures. This makes it possible to augment initial knowledge by adding qualitative relationships over generalized entities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Conclusions and open problems</head><p>We have introduced the provenance segmentation problem and discussed it in the context of a specific application, in which classification and diagnostics algorithms are to be performed on an approximate representation of the raw provenance graph. We can generalize this picture to consider any analysis that is too expensive to be performed routinely on the full provenance graph, but may be able to work with an approximation of the graph. Given such an algorithm, the following general problems seem worthwhile to investigate:</p><p>• Validity of segmentation: What formal guarantees need to hold in order for algorithms working on the segment layer to produce acceptable results with respect to the raw graph? • Incremental segmentation: Given a segmentation strategy, how can we incrementalize it so that whenever the raw graph is (additively) updated, we can quickly produce the new segments and edges for the updated graph? • Adaptive segmentation: Given algorithms that operate on the segment layer, and an annotated training set that we can use to evaluate how well the algorithms are doing using a given segmentation strategy, can we learn a good segmentation strategy?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Overview of current approach</head><p>In this appendix, we provide details of our current prototype approach to segmentation. This is work in progress and likely to change in future versions of the system as we gain experience with real data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Segmentation specifications</head><p>We use segmentation specifications to describe what kinds of segments to construct and how to annotate the resulting segment layer nodes.</p><p>The abstract syntax of segmentation specifications is as follows: </p><formula xml:id="formula_1">&lt;rule&gt;</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>// sets of edge names</head><p>In our prototype implementation, we represent such specifications as JSON data structures to save effort on parsing. An example is shown in <ref type="figure">Figure 3</ref>.</p><p>The idea here is that each spec is a rule for identifying matching subgraphs, and this matching process may also result in binding some variables to values. The segment name is a special property that every segment has, so that we can tell different kinds of segments apart, and the additional &lt;prop&gt;=&lt;exp&gt; pairs are additional properties that get added to the resulting segment node, so that we can see that e.g. a given segment is for PID 42's activity starting at a given time. We can choose to include more information (such as the duration) or less.</p><p>For time window segments time window td from ts starting T the window time td is the duration of each segment, and the optional time ts is the time of the first segment in the window series. starting T means that for each resulting segment, X is bound to the start time of the segment's time window. (The end time could also be stored, but is recoverable from the segment specification and the start time.) For radius segments radius n from prop=X following {e1,...,em} the idea is that we start by identifying nodes having the property prop (whose value is bound to a variable X) and follow up to n edges (in either direction) whose labels are among e1,...,em.</p><p>Each specification produces (conceptually) a set of subgraphs and a binding of the variables in the specification. This results in a new segment node linked to (the nodes of the) subgraph, with a segment name property set to the declared name, and any additional properties set using the values of the variables. The and operation (conceptually) combines the results of two specifications as follows: for each pair (SG1, env1) in the result of spec1 and (SG2, env2) in the result of spec2, if SG1 overlaps with SG2 and env1 and env2 are compatible environments, produce (SG1 ∩ SG2, env1 env2) where env1 env2 is the merge of the two environments. (It probably makes sense to restrict attention to rules that do not reuse variables, so that combining environments is always possible).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Formal semantics</head><p>Fix sets Γ of property names, Σ of edge labels, and D of data values. We assume that there is a special attribute time associating certain nodes with times.</p><p>We extend the graph model to allow for properties and their values. Let G = (V, E, α, λ) be a graph where α : V × Γ → D ⊥ associates each property name with an optional data value, and λ : V ∪ E → Σ associates a label to each vertex and edge.</p><p>A graph G = (V , E , α , λ ) is a subgraph of G if (as usual) V ⊆ V , E ⊆ E and the labels in G are compatible with those in G, that is, for all v ∈ V and all p ∈ Γ we have α (v, p) = α(v, p), and similarly for all e ∈ E we have λ (e) = λ(e). Since α and λ are obtainable by restriction, we can represent a subgraph just as a set of nodes and edges. A valuation is a partial mapping ρ : V ar → D ⊥ from variables to data values. The result of segmentation of a graph G is a set of pairs (SG, ρ) where SG is a subgraph of G and ρ is a valuation.</p><p>In what follows, we fix an ambient graph G by which all subsequent definitions are parameterized and we discuss how to segment a graph G = (V , E ) which may be G itself (initially) or a subgraph of G.</p><p>To segment according to rule radius N from p = X following S suppose N is the radius, p is the property name and S is the set of possible edge labels to follow. Suppose v ∈ V . Then we define Radius(G , v, N, S) to be the subgraph of G obtained by adding v and all nodes reachable from v by paths of length ≤ N following edges whose labels are in S. Then the result of segmentation is</p><formula xml:id="formula_2">{(Radius(G , v, N, S), [X = d] | α(v, p) = d}</formula><p>that is we generate one segment for each node in G having p = d for some d, and we record this choice in the valuation.</p><p>To segment according to the rule time window T_s from T_s starting X suppose ts is the start time, and tw is the window length. Consider the periodic intervals starting at tw with period t d as follows:</p><formula xml:id="formula_3">[ts, ts + t d ), [ts + t d , ts + 2t d ), . . . , [ts + nt d , ts + (n + 1)t d ), . . .</formula><p>In a finite graph G there is a finite subset of these intervals that contains all time property values present in G . Let Starts(G ) be the set of starting times of such intervals, that is,</p><formula xml:id="formula_4">Starts = {ts+nt d | ∃v ∈ V .ts+nt d ≤ α(v, time) &lt; ts+(n+1)t d }</formula><p>We define T ime(G , I) as the subgraph of G obtained by retaining all nodes with a time property in interval I, and all edges between such nodes.</p><formula xml:id="formula_5">{(T ime(G , [t, t + t d )), [X = t]) | t ∈ Starts(G )}</formula><p>To segment the conjunction of two rules spec1 and spec2, let Y1 be the result of segmenting G according to spec1 and Y2 the result of segmenting according to spec2. The result of segmenting according to spec1 and spec2 is:</p><formula xml:id="formula_6">{(SG1 ∩ SG2, ρ1 ρ2) | (SG1, ρ1) ∈ Y1, (SG2, ρ2) ∈ Y2}</formula><p>where we consider only the compatible pairs ρ1, ρ2 that agree on any common variable values.</p><p>To segment the sequential composition of two rules spec1 then spec2, let Y1 be the result of segmenting G according to spec1. For any subgraph SG of G , let Y2(SG) be the result of segmenting SG (a) segment byPidTime(pid=X, startTime=T) by radius 3 from PID=X following {"wasDerivedFrom", "used", "wasGeneratedBy", "wasAssociatedWith", "wasInvalidatedBy"} and time window 24:00:00 from 2013-03-16T00:00:00 starting T (b) {"segmentation_specification" : {"segment" : {"name": "byPidTime", "args": [{"property" : "pid", "value" : {"var" : "X"}}, {"property" : "startTime", "value" : {"var" : "T"}}], "specifications" : [ {"radius" : { "r" : 3, "from" : {"property" : "PID", "var": "X"}, "edges" : ["wasDerivedFrom", "used", "wasGeneratedBy", "wasAssociatedWith", "wasInvalidatedBy"]}}, {"time" : {"window" : {"days" : 0, "hours" : 24, "minutes" : 0, "seconds" : 0}, "from" : "2013-03-16T00:00:00", "starting" : {"var" : "T"}}} ] } } } <ref type="figure">Figure 3</ref>. An example segmentation specification and its JSON representation according to spec2. Then the result is: {(SG2, ρ1 ρ2) | (SG1, ρ1) ∈ Y1, (SG2, ρ2) ∈ Y2(SG1)} where we again consider only the compatible pairs ρ1, ρ2 that agree on any common variable values.</p><p>The difference between and and then is that and considers each specification independently on the current graph, and takes the intersection of the resulting subgraphs, whereas then segments using the first specification, then "focuses" on each resulting subgraph and segments each one using the second specification. The variable bindings are combined using in either case.</p><p>In our current prototype, each segment in the final result is recorded in the graph database as a new segment node, whose name property is set to the declared segment name, and other properties in the segment header are set to the values obtained from the corresponding variable bindings. The segment node is also linked to all of the nodes in the segment.</p><p>Notice that we include empty segments in the result, as it may be interesting to record the fact that a segment with given metadata was considered and is indeed empty (e.g. process 42 had no activity between midnight and 1am on Friday.) It may, of course, be worthwhile to consider compression techniques to avoid storing large numbers of empty segments explicitly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Edges among segments</head><p>We can consider several kinds of relationships among segments, defined in terms of the raw graph, that can be recorded as edges in the segment layer. We say that a segment overlaps another segment if they have vertices in common, otherwise the segments are disjoint. Two segments are contiguous if the shortest path between them is of length 1. A segment S2 depends on S1 if there is a directed path from S1 to S2 in G. Two segments are concurrent if each depends on the other. Two segments are independent if neither depends on the other. If S2 depends on S1 but S1 does not depend on S2 then we say that S1 happens before S2.</p><p>Currently we do not define explicit edges among segments during segmentation. However, since the segments are linked to the nodes of their subgraphs, such edges can be defined implicitly as queries. For example, we could define an edge relationship between segment nodes to hold if there is a (directed) path from a node in one segment to a node in another. It is not yet clear whether we want to (or need to) persist such edges in the database or simply generate them on the fly when the segment layer is analyzed by later stages, such as the diagnostic engine <ref type="bibr" target="#b0">[1]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>TaPP 2016 ,</head><label>2016</label><figDesc>June 8-9, 2016, Washington, DC. Copyright remains with the owner/author(s). Ingestion Segmentation Incoming provenance data Graph DB Pattern Extraction Classification, normalcy detection and diagnostics</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Architectural overview</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Example of lossy segmentation</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Diagnosing advanced persistent threats: A position paper</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rui</forename><surname>Abreu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">G</forename><surname>Bobrow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hoda</forename><surname>Eldardiry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Hanley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomonori</forename><surname>Honda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johan</forename><surname>De Kleer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandre</forename><surname>Perez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dave</forename><surname>Archer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Burke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Workshop on Principles of Diagnosis (DX-2015)</title>
		<meeting>the 26th International Workshop on Principles of Diagnosis (DX-2015)</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="193" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">User trust and judgments in a curated database with explicit provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">W</forename><surname>Archer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lois</forename><forename type="middle">M L</forename><surname>Delcambre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Maier</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
			</analytic>
	<monogr>
		<title level="m">Search of Elegance in the Theory and Practice of Computation</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013" />
			<biblScope unit="volume">8000</biblScope>
			<biblScope unit="page" from="89" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Confirmation of a coordinated attack on the ukrainian power grid</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Assante</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Querying and managing provenance through user views in scientific workflows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olivier</forename><surname>Biton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sarah</forename><surname>Cohen-Boulakia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Susan</forename><forename type="middle">B</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carmem</forename><forename type="middle">S</forename><surname>Hara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1072" to="1081" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Hierarchical models of provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Egor</forename><forename type="middle">V</forename><surname>Kostylev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TaPP 2012</title>
		<meeting><address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="10" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An analytical survey of provenance sanitization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roly</forename><surname>Perera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPAW 2014, number 8628 in Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="113" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Counterexample-guided abstraction refinement for symbolic model checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edmund</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Orna</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Somesh</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Helmut</forename><surname>Veith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="752" to="794" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Deka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Baldick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Vishwanath</surname></persName>
		</author>
		<title level="m">Data attacks on power grids: Leveraging detection. Innovative Smart Grid Technologies Conference (ISGT)</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">ProPub: Towards a declarative approach for publishing customized, policy-aware provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Saumen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bertram</forename><surname>Zinn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ludäscher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SSDBM</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="225" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Mitigating the aurora vulnerability with existing technology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcos</forename><surname>Donolo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Armando</forename><surname>Guzman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Venkat</forename><surname>Mynam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Doug</forename><surname>Salmon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Zeller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Multi-source fusion for anomaly detection: using across-domain and across-time peer-group consistency checks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hoda</forename><surname>Eldardiry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kumar</forename><surname>Sricharan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juan</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Hanley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Price</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oliver</forename><surname>Brdiczka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eugene</forename><surname>Bart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Journal of Wireless Mobile Networks, Ubiquitous Computing, and Dependable Applications</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="39" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Workload-aware streaming graph partitioning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugo</forename><surname>Firth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Missier</surname></persName>
		</author>
		<ptr target="http://ceur-ws.org/Vol-1558/paper26.pdf" />
	</analytic>
	<monogr>
		<title level="m">Workshop on Querying Graph Structured Data</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Exploiting graph structure to summarize and compress relational knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><forename type="middle">E</forename><surname>Friedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Qualitative Reasoning</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Angelos D. Keromytis, and Sotiris Ioannidis. Towards a universal data provenance framework using dynamic instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eleni</forename><surname>Gessiou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vasilis</forename><surname>Pappas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elias</forename><surname>Athanasopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SEC 2012</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="103" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A formal account of the open provenance model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Natalia</forename><surname>Kwasnikowska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luc</forename><surname>Moreau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TWEB</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">10</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Mesnier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raja</forename><forename type="middle">R</forename><surname>Wachs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julio</forename><surname>Sambasivan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>López</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">R</forename><surname>Hendricks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">//trace: Parallel trace replay with approximate causal events</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>O&amp;apos;hallaron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST 2007</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="153" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">ProvAbs: Model, policy, and tooling for abstracting PROV graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Missier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><surname>Bryans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carl</forename><surname>Gamble</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vasa</forename><surname>Curcin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roxana</forename><surname>Dánger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPAW 2014</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="3" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Provenance-aware storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">A</forename><surname>Kiran-Kumar Muniswamy-Reddy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Uri</forename><surname>Holland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Margo</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Seltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="43" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">US Office of Personnel Management Office of the Inspector General</title>
		<idno>4a-ci-00-14-016</idno>
	</analytic>
	<monogr>
		<title level="m">Final audit report, report number</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A provenancebased access control model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jaehong</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dang</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ravi</forename><forename type="middle">S</forename><surname>Sandhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PST 2012</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="137" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Decoupling provenance capture and analysis from execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manolis</forename><surname>Stamatogiannakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herbert</forename><surname>Bos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TaPP &apos;15</title>
		<meeting><address><addrLine>Scotland</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2015-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Streaming graph partitioning for large distributed graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isabelle</forename><surname>Stanton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabriel</forename><surname>Kliot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD 2012</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1222" to="1230" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
