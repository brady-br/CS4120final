<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:07+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">PHMon: A Programmable Hardware Monitor and Its Security Use Cases PHMon: A Programmable Hardware Monitor and Its Security Use Cases</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leila</forename><surname>Delshadtehrani</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Boston University</orgName>
								<orgName type="institution" key="instit2">Boston University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sadullah</forename><surname>Canakci</surname></persName>
							<email>scanakci@bu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Boston University</orgName>
								<orgName type="institution" key="instit2">Boston University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boyou</forename><surname>Zhou</surname></persName>
							<email>bobzhou@bu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Boston University</orgName>
								<orgName type="institution" key="instit2">Boston University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schuyler</forename><surname>Eldridge</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Boston University</orgName>
								<orgName type="institution" key="instit2">Boston University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ajay</forename><surname>Joshi</surname></persName>
							<email>joshi@bu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Boston University</orgName>
								<orgName type="institution" key="instit2">Boston University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Egele</surname></persName>
							<email>megele@bu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Boston University</orgName>
								<orgName type="institution" key="instit2">Boston University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leila</forename><surname>Delshadtehrani</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Boston University</orgName>
								<orgName type="institution" key="instit2">Boston University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sadullah</forename><surname>Canakci</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Boston University</orgName>
								<orgName type="institution" key="instit2">Boston University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boyou</forename><surname>Zhou</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Boston University</orgName>
								<orgName type="institution" key="instit2">Boston University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schuyler</forename><surname>Eldridge</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Boston University</orgName>
								<orgName type="institution" key="instit2">Boston University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ajay</forename><surname>Joshi</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Boston University</orgName>
								<orgName type="institution" key="instit2">Boston University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Egele</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution" key="instit1">Boston University</orgName>
								<orgName type="institution" key="instit2">Boston University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">PHMon: A Programmable Hardware Monitor and Its Security Use Cases PHMon: A Programmable Hardware Monitor and Its Security Use Cases</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. ARTIFACT EVALUATED PASSED</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>There has been a resurgent trend in the industry to enforce a variety of security policies in hardware. The current trend for developing dedicated hardware security extensions is an imperfect , lengthy, and costly process. In contrast to this trend, a flexible hardware monitor can efficiently enforce and enhance a variety of security policies as security threats evolve. Existing hardware monitors typically suffer from one (or more) of the following drawbacks: a restricted set of monitoring actions, considerable performance and power overheads, or an invasive design. In this paper, we propose a minimally-invasive and efficient implementation of a Programmable Hardware Monitor (PHMon) with expressive monitoring rules and flexible fine-grained actions. PHMon can enforce a variety of security policies and can also assist with detecting software bugs and security vulnerabilities. Our prototype of PHMon on an FPGA includes the hardware monitor and its interface with a RISC-V Rocket processor as well as a complete Linux software stack. We demonstrate the versatility of PHMon and its ease of adoption through four different use cases: a shadow stack, a hardware-accelerated fuzzing engine, an information leak prevention mechanism, and a hardware-accelerated debugger. Our prototype implementation of PHMon incurs 0.9% performance overhead on average, while the hardware-accelerated fuzzing engine improves fuzzing performance on average by 16× over the state-of-the art software-based implementation. Our ASIC implementation of PHMon only incurs a 5% power overhead and a 13.5% area overhead.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In recent years, there has been a growing demand to enforce security policies in hardware with the goal of reducing the performance overhead of their software-level counterparts. As a response to this growing demand, leading processor companies have introduced several security extensions. A successful hardware-based enforcement of security policies, such as the NX (non-executable) bit, provides an efficient permanent security solution. The processor companies have also established secure and isolated execution environments such as Intel Trusted Execution Technology (TXT) <ref type="bibr" target="#b64">[64]</ref>, Intel Software Guard Extensions (SGX) <ref type="bibr" target="#b2">[3]</ref>, ARM TrustZone <ref type="bibr" target="#b62">[62]</ref>, and AMD Secure Virtual Machine (SVM) <ref type="bibr" target="#b61">[61]</ref>. Additionally, Intel has introduced Memory Protection Extensions (MPX) <ref type="bibr" target="#b65">[65]</ref> and Control-Flow Enforcement Technology (CET) <ref type="bibr" target="#b67">[67]</ref> to enforce security policies.</p><p>Unfortunately, the current trend to develop dedicated hardware security extensions suffers from several drawbacks. Implementing new security extensions in a new generation of processors is a lengthy and costly process (which can take up to several years and millions of dollars). Additionally, the implemented extensions apply fixed security policies. Since these fixed security policies are built in silicon, any problems in the design or implementation of these policies requires a fix in the next generation of the processors. For example, Intel introduced MPX as a hardware-assisted extension to provide spatial memory safety by adding new instructions and registers to assist with software-based bounds checking. Software-based techniques, such as Safe-C (1994) <ref type="bibr" target="#b5">[6]</ref> and <ref type="bibr">SoftBound (2009)</ref>  <ref type="bibr" target="#b53">[53]</ref>, existed several years before Intel MPX was announced in 2013 and introduced commercially in late 2015. Unexpectedly, Intel MPX incurs a considerable performance overhead (up to 4× slow down in the worst case <ref type="bibr" target="#b55">[55]</ref>) and its supporting infrastructure cannot compile/run 3-10% of legacy programs <ref type="bibr" target="#b55">[55]</ref>. Due to various Intel MPX problems, GCC, LLVM, and Linux discontinued their support for MPX <ref type="bibr" target="#b42">[42,</ref><ref type="bibr" target="#b43">43]</ref>. Additionally, MPX does not protect the stack against Return-Oriented Programming (ROP) attacks. Hence, in 2016, Intel announced a new security technology specification, called Control-Flow Enforcement Technology (CET), for full stack protection.</p><p>The above Intel MPX example shows the lengthy and imperfect process of implementing fixed hardware security extensions. As a result, these extensions cannot evolve with the same pace as security threats. In contrast to the current trend in the industry to develop rigid hardware security extensions,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association 29th USENIX Security Symposium 807</head><p>a flexible hardware implementation can enforce and enhance a variety of security policies as security threats evolve. Such a flexible hardware implementation provides a realistic environment (a hardware prototype with full software stack) to evaluate the security policies before a manufacturer enforces a policy as a dedicated feature in hardware.</p><p>A flexible hardware to enforce security policies can be designed in the form of a hardware-assisted runtime monitor. To characterize a general runtime monitor, we present an event-action model. In this model, we define the runtime monitoring by a set of events, where each event is defined by a finite set of monitoring rules, followed by a finite sequence of actions. This definition does not restrict events/actions to highlevel (e.g., accessing a file) or low-level (e.g., execution of an instruction) events/actions. Accordingly, runtime monitoring consists of three main steps: 1) collecting runtime execution information, 2) evaluating the finite set of monitoring rules on the collected information to detect events, and 3) performing a finite sequence of follow-up actions. Intuitively, a monitoring system that allows the user to define generic rules, events, and actions is more widely applicable than a system that restricts the expressiveness of these aspects. Such a monitoring system can be used in a wide range of applications, including, but not limited to, enforcing security policies, debugging, and runtime optimization.</p><p>A reference monitor <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b70">70]</ref> is a well-known concept, which defines the requirements for enforcing security policies. A reference monitor observes the execution of a process and halts or confines the process execution when the process is about to violate a specified security policy. The reference monitor observation can happen at different abstraction levels, e.g., OS kernel, hardware, or inline. We can describe a reference monitor using our event-action monitoring model, where the events are specified by security policies and the sequence of actions is limited to halting/confining the process execution. An event-action monitoring model has a broader scope and is not restricted to specifying reference monitors for enforcing security policies.</p><p>Software-only runtime monitoring techniques can enforce the event-action monitoring model with virtually no restriction. However, these software techniques are not suited for always on monitoring and prevention mechanisms due to their considerable performance overhead (2.5× to 10× <ref type="bibr" target="#b47">[47,</ref><ref type="bibr" target="#b60">60]</ref> caused by the dynamic translation process of Dynamic Binary Instrumentation (DBI) tools). Hardware-assisted monitoring techniques reduce this significant overhead <ref type="bibr" target="#b26">[26,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b89">89]</ref>. Nonetheless, they commonly restrict the expressiveness of the event-action monitoring model. Some of the hardwareassisted monitoring techniques are designed for a specific monitoring use case, e.g., Bounds Checking (BC) <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b51">51,</ref><ref type="bibr" target="#b52">52]</ref>, data-race detection <ref type="bibr" target="#b89">[89]</ref>, and Dynamic Information Flow Tracking (DIFT) <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b78">78,</ref><ref type="bibr" target="#b81">81]</ref>. Other techniques provide some flexibility <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b28">28]</ref> and can be applied to a range of use cases including BC, DIFT, and Control Flow Integrity (CFI). We refer to these flexible techniques as Flexible Hardware Monitors (FHMons). However, the existing FHMons suffer from three common limitations:</p><p>1. Most existing FHMon techniques (e.g., <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b28">28]</ref>) extend each memory address and register with a tag. These techniques provide a set of actions only for tag propagation and raising an exception (handled by software), which restricts the expressiveness of their actions. Overall, this limits their deployment beyond tag-based memory corruption prevention. In principle, we can consider the tag-based FHMons as hardware reference monitors to enforce memory protection policies.</p><p>2. Some FHMon techniques <ref type="bibr" target="#b11">[11,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b46">46]</ref> rely on a separate general-purpose core to perform generic monitoring actions. These techniques incur large overheads (in terms of performance, power, and area) despite leveraging filtering and hardware-acceleration strategies.</p><p>3. Some FHMons require invasive modifications to the processor design (e.g., <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b76">76]</ref>). This limits the feasibility of FHMon adoption in commercial processors as well as the composition of FHMon.</p><p>Overall, the existing hardware-assisted monitoring techniques only implement a restricted subset of an ideal event-action monitoring model. Hence, they suffer from limited applicability. To address the aforementioned limitations and expand the set of monitoring rules and follow-up actions, we propose a minimally-invasive and low-overhead implementation of a Programmable Hardware Monitor (PHMon). Our PHMon can enforce a variety of security policies and it can also assist with detecting software bugs and security vulnerabilities. We interface PHMon with a RISC-V <ref type="bibr" target="#b83">[83]</ref> Rocket <ref type="bibr" target="#b4">[5]</ref> processor and we minimally modify the core to expose an instruction execution trace to PHMon. This execution trace captures the whole architectural state of the core. Each event is identified based on programmable monitoring rules applied to the instruction execution trace. Once PHMon detects an event, it performs follow-up actions in the form of hardware operations including ALU operations and memory accesses or an interrupt (handled by software). We modify the Linux Operating System (OS) to support PHMon at process level. Hence, unlike most existing FHMons and tag-based memory corruption prevention techniques, PHMon offers the option of enforcing different security policies for different processes. Additionally, we provide a software API consisting of a set of C functions to program PHMon. A user can simply use this API to specify the monitoring rules and program PHMon to monitor separate events, count the number of event occurrences, and take a series of follow-up actions. We demonstrate the versatility of PHMon and its ease of adoption through four representative use cases: a shadow stack, a hardware-accelerated fuzzing engine, information leak prevention, and hardware-accelerated debugging.</p><p>To evaluate PHMon in a realistic scenario, we implement a prototype of PHMon interfaced with a RISC-V Rocket core <ref type="bibr" target="#b4">[5]</ref> using Xilinx Zedboard FPGA <ref type="bibr" target="#b63">[63]</ref>. Our FPGA-based evaluation shows that PHMon improves the performance of fuzzing by 16× over the state-of-the art software-based implementation while our programmed shadow stack (for call stack integrity protection) has 0.9% performance overhead, on average. When implemented as an ASIC, PHMon incurs less than 5% power and 13.5% area overhead compared to an unmodified RISC-V core.</p><p>In summary, we make the following contributions:</p><p>• Design: We propose a minimally-invasive and efficient programmable hardware monitor to enforce an eventaction monitoring model with programmable monitoring rules and flexible hardware-level follow-up actions. Additionally, we provide the OS and software support for our hardware monitor.</p><p>• Application: We demonstrate the flexibility and ease of adoption of our hardware monitor to enforce different security policies and to assist with detecting software bugs and security vulnerabilities via four use cases.</p><p>• Implementation: We implement a practical prototype, consisting of a Linux kernel and user-space running on a RISC-V processor interfaced with our PHMon, on an FPGA. Our evaluation indicates that PHMon incurs low performance, power, and area overheads. In the spirit of open science and to facilitate reproducibility of our experiments, we will open-source the hardware implementation of our PHMon, our patches to the Linux kernel, and our software API: https://github.com/buicsg/PHMon.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>In this section, we discuss existing hardware features in processors and hardware-assisted monitors, which are applied in security use cases, and compare them with PHMon. We classify the hardware-assisted runtime monitors into two categories: "trace-based" and "tag-based". Trace-based monitors apply the monitoring rules and actions on the whole execution trace, while the tag-based monitors restrict the monitoring rules and/or actions to tag propagation. <ref type="table" target="#tab_0">Table 1</ref> compares different features of our trace-based PHMon with other tagbased and trace-based monitors. We can consider the tagbased monitors as reference monitors that can enforce one or more security policies for memory corruption prevention. In general, trace-based monitors are applied to a wider range of applications than merely memory protection. For example, as listed in <ref type="table" target="#tab_0">Table 1</ref>, data race detection is one of the use cases of the Log-Based Architectures (LBA) <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Custom Hardware for Monitoring</head><p>Dedicated hardware monitors have been used for a variety of debugging and security applications including hardwareassisted watchpoints for software debugging <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b88">88]</ref> and hardware-assisted Bounds Checking (BC) <ref type="bibr" target="#b27">[27,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b51">51]</ref>. Similar to <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b88">88]</ref>, PHMon can be integrated with an interactive debugger, such as GDB, and provide watchpoints by effectively filtering and monitoring different ranges of memory addresses. PHMon can also evaluate conditional break points and we illustrate this capability in Section 5.4. Dynamic Information Flow Tracking (DIFT) is a technique for tracking information during the program's execution by adding tags to data and tracking the tag propagation. Software-only implementations of DIFT <ref type="bibr" target="#b50">[50,</ref><ref type="bibr" target="#b54">54,</ref><ref type="bibr" target="#b59">59]</ref> have large performance overheads. To reduce the performance overhead, hardware implementations for DIFT have been proposed <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b78">78,</ref><ref type="bibr" target="#b81">81]</ref>. These techniques provide different levels of flexibility for DIFT, from 1-bit tags <ref type="bibr" target="#b59">[59]</ref> and multibit tags <ref type="bibr" target="#b19">[19]</ref> to more flexible designs <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b81">81]</ref>. Instead of comparing PHMon with custom hardware for BC and DIFT, Section 2.2 provides a comparison with FHMons that are capable of performing both BC and DIFT.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Flexible Hardware Monitors (FHMons)</head><p>FHMons provide flexible monitoring capabilities and can be applied to a range of applications. MemTracker <ref type="bibr" target="#b82">[82]</ref> implements tag-based hardware support to detect memory bugs. Several existing works <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b28">28]</ref> extend DIFT tag-based monitoring into more flexible frameworks capable of supporting different security use cases. PUMP <ref type="bibr" target="#b28">[28]</ref> provides programmable software policies for tag-based monitoring with invasive changes to the processor pipeline. FlexCore <ref type="bibr" target="#b25">[25]</ref> is a re-configurable architecture decoupled from the processor, which provides a range of runtime monitoring techniques. The programmable FPGA fabric of FlexCore restricts its integration with a high-performance core. Harmoni <ref type="bibr" target="#b26">[26]</ref> is a coprocessor designed to apply different runtime tag-based monitoring techniques, where the tagging capability is not as flexible as FlexCore or PUMP. HDFI <ref type="bibr" target="#b76">[76]</ref> and REST <ref type="bibr" target="#b74">[74]</ref> provide memory safety through data-flow isolation by adding a 1-bit tag to the L1 data cache.</p><p>Among the tag-based FHMons, HDFI <ref type="bibr" target="#b76">[76]</ref> is the closest work to PHMon in terms of providing a realistic evaluation environment. Both HDFI and PHMon implement a hardware prototype, rather than relying on simulations, and evaluate a full Linux-based software stack on an FPGA. Contrary to PHMon, HDFI applies invasive modifications to the processor pipeline (adds a 1 bit tag to L1 data cache and modifies the decode and execute stages of the pipeline). HDFI is restricted to enforcing data-flow isolation policies to prevent memory corruption. Although PHMon can be used for sensitive data protection (e.g., preventing Heartbleed), compared to HDFI, PHMon has limited capabilities to protect against memory corruption. However, unlike HDFI, PHMon can be applied in security use cases beyond memory corruption prevention, such as accelerating the detection of security vulnerabilities "Inv" = Invasive; "Min-inv" = Minimally-invasive; "# N/A" = Numbers not available; Sim = "Simulation"; Emul = "Emulation"; "MC" = Memory Checking; "RC" = Reference Counting "BC" = Bounds Checking; "FI" = Fault Isolation; "SEC" = Soft Error Checking; "SEP" = Seperation; "SL" = Standard Library; "Ptr" = Pointer; "Prot" = Protection; "Info" = Information; "Leak" = Leakage (we demonstrate this capability in Section 5).</p><p>Overall, to the best of our knowledge, the existing flexible tag-based monitoring techniques are a subset of an eventaction monitoring model, where the actions are restricted to tag-propagation and raising an exception (handled by software). In this regard, these tag-based FHMons are reference monitors that enforce memory protection policies. PHMon provides a more comprehensive language for actions. Hence, we can leverage PHMon in a wider range of security applications, not limited as a reference monitor to enforce memory protection policies. An efficient implementation of a tagbased FHMon, such as HDFI, is complementary to PHMon.</p><p>In a multi-core system, Log-Based Architectures (LBA) <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11]</ref> implement trace-based monitors that capture an execution log from a monitored program on one core and transfer the collected log to another general-purpose core, where a dynamic tool (lifeguard) executes and enforces the security policies. The optimized LBA <ref type="bibr" target="#b12">[12]</ref> considerably reduces the performance overhead of LBA <ref type="bibr" target="#b11">[11]</ref> (from 3×-5× to ∼50%) at the cost of higher power and area overheads. From the perspective of the event-action monitoring model, LBA's expressiveness in terms of monitoring rules and actions is close to software-based techniques. However, the LBA tracebased monitor suffers from considerable performance, power, and area overheads. Similar to optimized LBA, FADE <ref type="bibr" target="#b30">[30]</ref>, DISE <ref type="bibr" target="#b16">[16]</ref>, and partial monitoring <ref type="bibr" target="#b46">[46]</ref> apply filtering, pattern matching, and dropping decisions to the execution trace, respectively. Rather than utilizing an additional general-purpose core, PHMon provides a programmable hardware capable of performing a smaller range of monitoring techniques, but does so efficiently and with significantly lower power and area overheads. Among the trace-based FHMons, Nile <ref type="bibr" target="#b23">[23]</ref> is the closest work to PHMon. Compared to LBA architectures and PHMon, Nile provides a restricted set of possible actions; however, Nile's actions are not limited to tag propagation. Nile only supports comparison operations (no other arithmetic or logical operations), which restricts its applicability for different use cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Generic Monitoring Hardware Extensions</head><p>Modern processors provide hardware features and extensions to collect runtime hardware usage information. Hardware Performance Counters (HPCs) are hardware units for counting the occurrence of microarchitectural events, such as cache hits and misses, at runtime. A number of previous works use HPCs for malware detection <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b40">40,</ref><ref type="bibr" target="#b57">57,</ref><ref type="bibr" target="#b73">73]</ref>. However, recent studies <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b87">87]</ref> shed light on the pitfalls and challenges of using HPCs for security. Moreover, HPCs are limited to a predefined pool of microarchitectural events, while PHMon and FHMons provide a set of monitoring rules to specify cus- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RoCC Interface</head><p>Figure 2: The RoCC interface extended with commit log execution trace.</p><p>tom events. Additionally, PHMon and FHMons are capable of performing follow-up actions, while HPCs are restricted to interrupts. Last Branch Record (LBR) is a hardware feature available in the recent Intel processors, which records a history of the 16 most recent indirect jumps. Several works <ref type="bibr" target="#b14">[14,</ref><ref type="bibr" target="#b58">58,</ref><ref type="bibr" target="#b84">84</ref>] rely on LBR, as a pseudo shadow stack, to mitigate Return-Oriented Programming (ROP) attacks. However, history-flushing attacks <ref type="bibr" target="#b9">[9,</ref><ref type="bibr" target="#b72">72]</ref> can evade such LBR-based detection techniques. LBR is not designed for security purposes; hence, it cannot provide a principled security solution. Unlike LBR, PHMon's implemented shadow stack is not limited to maintaining only the last 16 branch records (the limit for PHMon is the allocated memory size); hence, PHMon is not vulnerable to history flushing attacks.</p><p>Modern processors also provide architectural extensions, like Intel Processor Trace (PT) <ref type="bibr" target="#b66">[66]</ref> and ARM CoreSight <ref type="bibr" target="#b48">[48]</ref>, to capture debugging information. Both Intel PT and ARM CoreSight provide enormous debugging capabilities; however, these technologies are primarily designed to provide debugging traces for post-processing. Online processing capabilities, however, are essential for the timely detection of security threats. FHMons and PHMon expand the online monitoring with efficient online processing and prevention capabilities. Although Intel PT is designed for offline debugging and failure diagnosis, recent techniques <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b39">39]</ref> utilize this hardware extension to enforce Control Flow Integrity (CFI) at runtime. Similarly, kAFL <ref type="bibr" target="#b71">[71]</ref> is a kernel fuzzing engine that uses Intel PT to obtain code coverage information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Threat Model and Assumptions</head><p>In this work, we focus on detecting software security vulnerabilities and preventing attackers from leveraging these vulnerabilities. We follow the common threat model among the related works. We assume software may include one or more security bugs and vulnerabilities that attackers can leverage to perform an attack. We do not assume any restrictions about what an attacker would do after a successful attack.</p><p>Specifically for our use cases, we assume an application may suffer from a security vulnerability such as buffer overflow and an attack can leverage that to gain the control of program's stack. Also, motivated by our information leakage prevention use case, we assume that sensitive memory contents can be leaked to unauthorized entities.</p><p>Since PHMon relies on OS support, we assume that the OS kernel is trusted. However, in principle, PHMon can be extended to protect (part of) the OS kernel. Section 7.2 provides a more detailed discussion about PHMon's capabilities and limitations in protecting the OS kernel. Also, we assume all hardware components are trusted and bug free. Hence, hardware-based attacks such as row hammer <ref type="bibr" target="#b41">[41]</ref> and cachebased side-channel attacks are out-of-scope of this work.</p><p>As mentioned before, for security enforcement use cases, we can consider PHMon as a reference monitor <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b70">70]</ref>. A reference monitor should satisfy three principles: complete mediation, tamperproofness, and verifiability. PHMon satisfies the complete mediation principle. Whenever a context switch into a monitored process occurs, PHMon continues monitoring. Additionally, PHMon monitors the execution of the forked processes of a parent process. Regarding tamperproofness, as we will discuss in Section 4.2, PHMon provides the option of "sealing" configurations to prevent further modifications. With respect to verifiability, PHMon is small enough to be subject to verification (13.5% area overhead compared to an in-order processor).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">PHMon</head><p>We propose a minimally-invasive programmable hardware monitor (for a general-purpose processor) to enforce an eventaction monitoring model. <ref type="figure">Figure 1</ref> presents a high-level overview of PHMon that implements such an event-action monitoring model. To enable per process monitoring, software API (to configure/program the hardware monitor) and OS support are mandatory. A user/admin can configure the hardware to monitor the execution of one or more processes. Then, the hardware monitor collects the runtime execution information of the processor, checks for the specified events, and performs follow-up actions. Once the process terminates or the user/admin disables the monitoring, the hardware monitor stops monitoring. In the rest of this section, we discuss the challenges associated with designing PHMon and our design decisions to address these challenges. In the next three subsections, we explain the hardware design for PHMon, its software interface, and the OS support for PHMon.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">PHMon: Architecture</head><p>In this subsection, we present the hardware design of PHMon. Our main design goal for our hardware monitor is to provide an efficient and minimally invasive design. According to the event-action monitoring model, our hardware monitor should perform three main tasks: collect the instruction execution trace of a processor, examine the execution trace to find matches with programmed events, and take follow-up actions. To perform these tasks, PHMon consists of three main architectural units: a Trace Unit (TU), Match Units (MUs), and an Action Unit (AU).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Trace Unit (TU)</head><p>The TU is responsible for performing the first task, i.e., collecting the instruction execution trace. To design our TU, we need to answer the following questions: what information should the TU collect, from where should it collect this information, and how to transfer the collected information to the hardware monitor?</p><p>In this work, we only collect information about the architectural state of the processor (not the micro-architectural state). To this end, the TU collects the entire architectural state of the processor using five separate entries, i.e., the undecoded instruction (inst), the current Program Counter (PC) (pc_src), the next PC (pc_dst), the memory/register address used in the current instruction (addr), and the data accessed by the current instruction (data). The inst entry contains the opcode as well as the input and output operand identifiers. In principle, we can collect this information from different stages of a processor's pipeline (i.e., decode, execute, memory, and write-back stages). We can take advantage of the FIRRTL <ref type="bibr" target="#b45">[45]</ref> compiler 1 (via annotations) to extract specific signals with low effort and transfer them to PHMon. To ensure that we monitor the instructions that are actually executed and in the order they are committed, we collect the above-mentioned information from the commit stage of the pipeline. Hence, we call the collected information a commit log.</p><p>During each execution cycle, the TU collects a commit log and transfers it to our hardware monitor. To prevent stalling the processor's pipeline while PHMon processes each commit log, we design PHMon as a parallel decoupled monitor. Such <ref type="bibr" target="#b0">1</ref>  Config Unit-0 (CFU-0)</p><p>...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Type 2b</head><p>In1 3b</p><p>In2 3b</p><p>Fn 4b</p><p>Out 3b</p><p>Data 64b</p><p>Action Config <ref type="table">Table   conf_ctr</ref> Action Unit (AU)</p><formula xml:id="formula_0">Commit Log -inst -pc_src -pc_dst -addr -data</formula><p>Cmd a decoupled monitor requires an interface to receive the commit log from the processor. In this work, we design PHMon as an extension to the open-source RISC-V Rocket processor <ref type="bibr" target="#b4">[5]</ref> via its Rocket Custom Coprocessor (RoCC) interface. RISC-V <ref type="bibr" target="#b83">[83]</ref> is an open standard Instruction Set Architecture (ISA). We choose the Rocket processor due to the availability of its RISC-V open ISA and the capability of running the Linux OS on the processor. However, our PHMon design is independent of the transport interface and ISA. <ref type="figure">Figure 2</ref> depicts the extended RoCC interface used in our design to communicate with the Rocket processor. The RoCC interface provides transmitting/receiving register data for communication, status/exception bits, and direct communication with the memory hierarchy (L1 data cache in our design). We have extended the RoCC interface to carry the commit log trace (shown in red in <ref type="figure">Figure 2</ref>). Since Rocket is an in-order processor, we minimally modify the write-back stage of the Rocket processor's pipeline to collect the commit log trace.</p><p>PHMon receives the commit log, collected by the TU, from the RoCC interface. Then, as shown in <ref type="figure" target="#fig_0">Figure 3</ref>, PHMon applies the configured monitoring rules to the commit log to detect events (handled by MUs) and performs follow-up actions (managed by the AU). As mentioned before, PHMon is decoupled from the processor and it processes the incoming commit logs one by one. Hence, we need a queuing mechanism to record incoming commit log traces. Rather than placing a queue between the RoCC interface and PHMon, we filter the incoming packets using MUs and only record the matched events in a queue prior to taking actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Match Units (MUs)</head><p>MUs are responsible for monitoring an incoming commit log and finding matches with programmed events. Each MU is in charge of detecting a distinct event using a set of monitoring rules. An event is specified at bit-granularity by a match entry and its corresponding care/don't care mask entry, which are applied on each commit log entry. An MU matches the care bits of each match entry with the corresponding bits in the commit log entry. As an example, consider a scenario where a user wants to monitor any of the four branch instructions including BLT, BGE, BLTU, and BGEU. The user can configure an MU to monitor these four instructions using the following matching condition:</p><p>BLT, BGE, BLTU, BGEU: inst = 0x00004063; mask bit = 0xffffbf80</p><p>The matching condition for inst evaluates to true when the current instruction is a match with one of the BLT, BGE, BLTU, or BGEU instructions. Note that each of these instructions is identified based on the opcode and func3 bits (refer to <ref type="bibr" target="#b83">[83]</ref>). For each of the remaining entries of the commit log (i.e., pc_src, pc_dst, addr, and data), we set the masking bits to 0xffffffffffffffff, indicating these fields are don't cares. In Section 4.2, we will present our software interface for programming MUs to monitor the target events. Whenever the predicate (the logical conjunction of the matches on all the commit log entries) evaluates to true, a counter in the corresponding MU increases. Once the counter reaches a programmed threshold value, the MU triggers an activation signal and sends a match packet to the AU. The AU queues the incoming match packets, while it performs actions for the packets arrived earlier. To reduce the queuing traffic, an MU filters commit log traces based on the monitoring rules before queuing them.</p><p>An MU may be programmed by a user process to monitor only its own execution or by an admin to monitor processes with lower permissions. In both cases, MU configuration becomes part of a process' context and is preserved across context switches by the OS. In Section 6.2, we evaluate the performance overhead caused by preserving PHMon's configuration across context switches.</p><p>Although each MU monitors a separate event, PHMon is capable of monitoring a sequence of events using multiple MUs communicating through a shared memory space set up by either the OS or the monitored process itself. For example, multiple MUs may all write to or read from the shared memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Action Unit (AU)</head><p>The AU is responsible for performing the follow-up actions. Our main goal in designing the AU is to provide a minimal design that supports a variety of actions including arithmetic and logical operations, memory operations, and interrupts. To this end, we effectively design our AU as a small microcontroller with restricted I/O consisting of four microarchitectural components: Config Units (CFUs), an Arithmetic and Logical Unit (ALU), a Local Register File, and a Control Unit (CU). In addition to these four components, the Match Queue that records the match packets (generated by MUs) is placed in the AU (see <ref type="figure" target="#fig_0">Figure 3)</ref>.</p><p>Each MU is paired with a CFU, where the CFU stores the sequence of actions to be executed once the MU detects a match. These programmable actions are in fact the instructions of a small program that executes in the AU. The CU performs the sequence of actions via hardware operations (i.e., ALU operations and memory requests) or an interrupt (handled by software). The CU uses the registers in the Local Register File (6 registers in total) to perform the hardware operations. Our AU implementation enforces the atomic execution of actions. To this end, the CU executes all of the follow-up actions of one match packet before switching to the actions of the next match packet.</p><p>As part of the actions, the AU can access memory by sending requests to the L1 data cache, a virtually-indexed physically-tagged cache, through the RoCC interface. Hence, all memory accesses are to virtual addresses. The L1 data cache of Rocket processor has an arbiter to handle incoming requests from several agents including the Rocket core and the RoCC interface. Note that the memory hierarchy of Rocket core manages the memory consistency.</p><p>In Appendix A, we provide a detailed description about each of the AU's microarchitectural components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">PHMon: Software Interface</head><p>We use RISC-V's standard ISA extensions <ref type="bibr" target="#b83">[83]</ref>, called custom RISC-V instructions, to configure PHMon's MUs and CFUs, as well as to communicate with PHMon. We provide a list of functions that one can use to communicate with PHMon, where each function is accessible by a user-space process, a supervisor, or both. Note that when a user process programs PHMon, then PHMon only monitors that process' execution. When an admin programs PHMon, it can be configured to monitor a specific user process or monitor all user processes. To prevent an unauthorized process from reconfiguring PHMon (after an MU and its paired CFU are configured), we provide an optional feature to stop any further configuration. To this end, we leverage the Rocket's privilege level (MStatus.priv) provided to PHMon through the RoCC interface. According to the privilege level, PHMon permits or blocks incoming configuration requests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">PHMon: OS Support</head><p>In this section, we discuss the necessary modifications to the Linux OS kernel to support PHMon. We categorize our modifications into two classes: per process modifications and interrupt handling modifications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Per Process OS Support</head><p>We extend Linux to support PHMon and provide a complete computing stack including the hardware, the OS, and software applications. We provide the OS support for PHMon at the process level. To this end, we alter the task_struct in the Linux Kernel to maintain PHMon's state for each process. We store the MUs' counters, MUs' thresholds, the value of local registers, and CFUs' configurations as part of the task_struct (using the custom instructions for reading PHMon register values).</p><p>We modify the Linux kernel to initialize the PHMon information before the process starts its execution. Once PHMon is configured to monitor a process, we enable a flag (part of the task_struct) for that process. Our modified OS allocates a shared memory space for communication between MUs. After allocation, the OS maintains the base address and the size of the shared memory as part of the PHMon information for the process in the task_struct. Additionally, the OS sends the base and size values to PHMon. PHMon can simply protect the shared memory from unauthorized accesses, where only the AU and the OS are authorized to access the shared memory. To provide this protection, one of the MUs can monitor any user-space load or store accesses to this range of memory and trigger an interrupt in case of memory access violation.</p><p>During a context switch, the OS reads the MU information (counter and threshold values) as well as the Local Register File information from PHMon and stores them as the PHMon information of the previous process in the task_struct. Before the OS context switches to a monitored process, it reads the MU information of the next process and writes it to PHMon registers using the functions provided in the PHMon API. Note that to retain the atomicity of the programmed actions, our modifications to the OS delay a context switch until the execution of the current set of actions and the corresponding actions of all the match packets stored in the Match Queue are completed. It is worth mentioning that our current implementation of PHMon is not designed for real-time systems. Hence, we currently do not provide any guarantees for meeting stringent real-time deadlines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Interrupt Handling OS Support</head><p>The OS is responsible for handling an incoming interrupt triggered by the CU. We configure our RISC-V processor to delegate the interrupt to the OS. Additionally, we modify the Linux kernel to handle the incoming interrupts from the RoCC interface. In our security-oriented use case, the OS terminates the process that caused the interrupt based on the assumption that an anomaly or violation has triggered the interrupt. Note that the OS can handle the interrupt in various ways according to the user's requirements (e.g., trapping into GDB for the debugging use case in Section 5.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Use Cases</head><p>PHMon distinguishes itself from related work by its flexibility, versatile application domains, and its ease of adoption. To demonstrate the versatility of PHMon, we present four use cases: a shadow stack, a hardware-accelerated fuzzing engine, an information leakage prevention mechanism, and hardwareaccelerated debugging.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Shadow Stack</head><p>Our first use case is a shadow stack, a security mechanism that detects and prevents stack-based buffer overflows as well as Return-Oriented-Programming (ROP) attacks. As data on the stack is interleaved with control information such as function return addresses, an overflow of a buffer can violate the integrity of such control information and in consequence compromise system security. A shadow stack is a secondary stack that keeps track of function return addresses to protect them from being tampered with by an attacker. A stack buffer overflow attack occurs when a program writes data into a stack-allocated buffer, such that the data is larger than the buffer itself. ROP is a contemporary code-reuse attack that combines a sequence of so-called gadgets into a ROP-chain. Gadgets typically consist of a small number of instructions ending in a ret instruction. However, executing a ROP-chain violates function call semantics (i.e., there are no corresponding calls to the rets in the chain). A shadow stack can therefore detect ROP attacks.</p><p>Rather than providing a dedicated hardware solution (e.g., Intel's proposed shadow stack <ref type="bibr" target="#b67">[67]</ref>), we leverage PHMon's flexibility to implement a hardware shadow stack. A shadow stack can easily be realized in PHMon with two MUs. We program one MU (MU0) to monitor call instructions and another MU (MU1) to monitor ret instructions. Also, we configure each of the MUs to trigger an action for every monitored instance of call and ret (threshold = 1).</p><p>The OS allocates a shared memory space, i.e., space for the shadow stack, for each process that is being monitored. Both MUs have access to this shared memory space. We can simply protect this shared memory space against unauthorized accesses by monitoring load and store accesses to this range of addresses leveraging a third MU (as described in Section 4.3). Any user-space access to this memory space results in an interrupt and termination of the violating process. Once the OS allocates this memory space (during the initialization of a new process), it stores the base address and the size of the allocated memory in the first two general-purpose registers of the Local Register File in PHMon (refer to Appendix A for more information about the Local Register File). We configure the CFUs to use the base address register as the shadow stack pointer. The AU accesses the shadow stack by sending memory requests to the L1 cache using the RoCC interface.</p><p>The summary of our event-action scenario for implementing a shadow stack is as follows: the first MU (MU0) monitors calls and pushes the corresponding pc_src value to the shadow stack. The second MU (MU1) monitors rets and compares the pc_dst value with the value stored on the top of the shadow stack. If there is a mismatch between calls and rets (e.g., an illegal ret address or a ROP attack), PHMon triggers an interrupt and the OS handles the interrupt. In our current implementation, the OS simply terminates the process that caused the interrupt. Note that analogous to <ref type="bibr" target="#b8">[8]</ref>, we can address call-ret matching violations caused by setjmp/longjmp by augmenting the jmp_buf struct with one more field to store the shadow stack pointer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Hardware-Accelerated Fuzzing</head><p>Fuzzing is the process of providing a program under test with random inputs with the goal of eliciting a crash due to a software bug. It is commonly used by software developers and security experts to discover bugs and security vulnerabilities during the development of a software product and mostly for the deployed software. Big software companies such as Google <ref type="bibr" target="#b1">[2]</ref> and Microsoft <ref type="bibr" target="#b68">[68]</ref> use fuzzing extensively and continuously. For instance, Google's OSS-Fuzz platform found over 1,000 bugs in 5 months <ref type="bibr" target="#b33">[33]</ref>. Similarly, American Fuzzy Lop (AFL) <ref type="bibr" target="#b85">[85]</ref> is one of the state-of-the-art fuzzers that successfully identified zero-day vulnerabilities in popular programs, such as PHP and OpenSSH.</p><p>AFL aims to explore new execution paths in the code to discover potential vulnerabilities. AFL consists of two main units: the fuzzing logic and the instrumentation suite. The fuzzing logic controls the mutation and scheduling of the inputs, and also decides if the current input is interesting enough for further fuzzing. During fuzzing, the instrumentation suite collects branch coverage information of the program for the current input. In the current version of AFL (2.52b), the instrumentation can be applied either at compile time with a modified gcc compiler (afl-gcc) if source is available or at runtime by adding instructions to the native binary through user-mode QEMU for closed-source programs. As QEMU uses DBI, it can instrument each control-flow instruction with the necessary book-keeping logic. While this capability is flexible, DBI comes at a significant performance overhead (2.5× to 5× <ref type="bibr" target="#b60">[60]</ref>). PHMon can easily monitor the controlflow instructions and apply the necessary book-keeping logic without incurring the DBI overhead. In this study, we do not modify the fuzzing logic of AFL. However, we program PHMon to implement the instrumentation suite.</p><p>AFL uses a shared memory region, called bitmap, to store the encountered basic block transitions (a basic block is an instruction sequence with only one entry and one exit point) for the program executed with the most recent input. Each basic block has an id, calculated by performing logical and bitwise operations using the current basic block address. The address that points to the transition information in the bitmap is calculated based on the current and the previous block id.</p><p>We use PHMon as part of AFL as follows (see <ref type="figure" target="#fig_1">Figure 4</ref>): (1) AFL starts executing the target program on the RISC-V processor. (2) PHMon monitors the control-flow instructions of the target binary. (3) Whenever PHMon detects a controlflow instruction, it updates the bitmap. (4) The child process (fuzzed program) terminates. <ref type="formula">(5)</ref> The fuzzing unit compares the output bitmap with the global bitmap (the collection of the previously observed basic block transitions) and determines whether the current input is interesting enough for further fuzzing.</p><p>PHMon conducts step (2) and step (3) of the abovedescribed AFL process. To this end, we program two MUs to monitor the control-flow instructions (branches and jumps) with threshold = 1. Both of these MUs have access to the bitmap allocated by AFL. We program each MU with 12 actions to update the bitmap. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Preventing Information Leakage</head><p>PHMon can also be used to prevent the leakage of sensitive information, such as cryptographic keys. A concrete example is Heartbleed <ref type="bibr" target="#b34">[34]</ref>, a buffer over-read vulnerability in the popular OpenSSL library that allowed attackers to leak the private key 2 of any web-server relying on that library <ref type="bibr" target="#b34">[34]</ref>.</p><p>To prevent Heartbleed, we first identified the memory addresses that contain the private key. Second, we manually white-listed all legitimate read accesses (i.e., instructions that access the key). As legitimate accesses to the key are confined to three functions that implement cryptographic primitives, this was a straightforward task. Finally, we programmed PHMon to trigger an interrupt in case any instruction but those white-listed above accesses the key. To this end, we configure an MU to monitor load instructions that access the key, and the CFU contains a series of actions that compare the pc_src of the load instruction against the white-list. As a proof of concept, we programmed PHMon to prevent the leakage of the prime number p and PHMon successfully prevented the disclosure. Note that the location of sensitive information and its legitimate accesses can vary in different environments. Ideally, the information about the location of an instruction that accesses sensitive data would be produced by a compiler (e.g., by annotating sensitive variables). However, we leave augmenting a compiler tool-chain to produce such metainformation which can be readily enforced by PHMon as future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Watchpoints and Accelerated Debugger</head><p>As the last use case, we focus on the debugging capabilities of PHMon. PHMon can provide watchpoints for an interactive debugger, such as GDB, by monitoring memory addresses (addr entry of the commit log) and then triggering an interrupt. Although the number of MUs dictates the maximum number of unique watchpoints that PHMon can monitor, our watchpoint capability is not limited by the number of MUs. Each MU can monitor a range of monitoring addresses, specified by match and mask bits. Here, the range of watchpoint addresses can be contiguous or non-contiguous. Additionally, for each range, the user can configure PHMon to monitor read accesses, write accesses, or both by specifying the inst entry of the commit log. It is worth mentioning that most modern architectures only provide a few watchpoint registers (e.g., four in Intel x86). We have used and validated the watchpoint capability of PHMon as part of the information leak prevention use case, described in Section 5.3.</p><p>In addition to watchpoints, PHMon accelerates the debugging process. As an example, PHMon can provide an efficient conditional breakpoint and trap into GDB. Consider a debugging scenario for a conditional breakpoint in a loop as "break foo.c:1234 if i==100", where i is the loop counter. Here, we want to have a breakpoint and trap into GDB when the loop reaches its 100 th iteration. To this end, PHMon monitors an event where pc_src has the corresponding PC value of line 1234. Then, PHMon triggers an interrupt when the MU's counter reaches the threshold of 100. Subsequently, the interrupt handler traps into GDB. In Section 6.2, we measure the performance improvement of PHMon over GDB for such a conditional breakpoint.</p><p>For the debugging use cases, such as watchpoints and conditional breakpoints, the only required action in case of detecting an event is triggering an interrupt. As a result, PHMon is synchronized with the program's execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>In this section, we discuss our approach to validate the functionality of PHMon as well as our evaluation of PHMon using performance, power, and area metrics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Experimental Setup</head><p>We implemented PHMon as a RoCC (using Chisel HDL <ref type="bibr" target="#b6">[7]</ref>) and interfaced it with the RISC-V Rocket processor <ref type="bibr" target="#b4">[5]</ref> that we prototyped on a Xilinx Zynq Zedboard evaluation platform <ref type="bibr" target="#b63">[63]</ref>. We performed all experiments with a modified RISC-V Linux (v4.15) kernel. We compared the PHMon design with a baseline implementation of the Rocket processor. For both the baseline and PHMon experiments, we used the same Rocket processor configurations featuring a 16K L1 instruction cache and a 16K L1 data cache. <ref type="table" target="#tab_3">Table 2</ref> lists the microarchitectural parameters of Rocket core and PHMon. Note that similar to HDFI <ref type="bibr" target="#b76">[76]</ref>, we do not include an L2 data cache in our experiments running on Rocket core. Currently, TileLink2 (the protocol that Rocket Chip uses to implement the cache coherent interconnect) does not support L2 cache while the L2 cache in older versions of TileLink is not mature enough <ref type="bibr" target="#b76">[76]</ref>. Due to the limitations of our evaluation board, in our experiments, the Rocket Core operated with a maximum frequency of 25 MHz (both in the baseline and PHMon experiments). Note that for our ASIC evaluation, we synthesized the Rocket core with a target frequency of 1 GHz.</p><p>For our shadow stack use case, we calculated the run time overhead of 14 applications from MiBench <ref type="bibr" target="#b36">[36]</ref>, 9 applications (out of 12) from SPECint2000 <ref type="bibr" target="#b37">[37]</ref>, and 8 applications (out of 12) from SPECint2006 <ref type="bibr" target="#b38">[38]</ref> benchmark suites. To measure the performance improvement of our hardware- To assess power and area, we used Cadence ASIC toolflow for 45nm NanGate process <ref type="bibr" target="#b69">[69]</ref> to synthesize PHMon and the Rocket processor to operate at 1 GHz. We then measured the post-extraction power consumption and the area of our system as well as our baseline system, i.e., the unmodified Rocket processor. We considered all memory blocks (both in PHMon and Rocket) as SRAM blocks and used CACTI 6.5 [80] to estimate their power and area.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Functionality Validation and Performance Results</head><p>In this subsection, we validate the functionality of our use cases and evaluate their performance overhead. Additionally, we evaluate the performance overhead PHMon imposes during context switches. Shadow Stack. We validated the functionality of our shadow stack using benign benchmarks and programs vulnerable to buffer overflow attacks. All benchmark programs ran successfully with the shadow stack enabled resulting in no false detections from PHMon. We developed simple programs vulnerable to the buffer overflow using strcpy and exploited this vulnerability. 3 As designed, PHMon detected the mismatches between calls and rets, triggered an interrupt, and the Linux Kernel terminated the process. We measured the runtime overhead of our shadow stack on different benchmark applications from MiBench, SPECint2000, and SPECint2006 benchmark suites. We ran each benchmark five times and calculated the average runtime overhead. All standard deviations were below 1.5%. Unfortunately, we were not able to successfully cross-compile and run three of the SPECint2000 benchmarks, i.e., eon, perlbmk, and vortex, for RISC-V. For the rest of the SPECint2000 benchmarks, we used -O2 for compilation and reference input for evaluation (we clarify the exceptions in the results). For SPECint2006 benchmark applications, we used -O2 for compilation. Considering the limitations of our evaluation board,  Figure 5: The performance overhead of PHMon as a shadow stack. † We were not able to run mcf benchmark with reference input on our evaluation board; as a result, we used the test input for this benchmark. Due to the memory limitations of our evaluation board, we had to reduce the buffer size of the reference input to 3 MB for gzip and bzip2 benchmarks. ± We had to use -O0 and an input buffer size of 96 MB to successfully run gap benchmark.</p><p>we used the test inputs to evaluate SPECint2006. Nevertheless, we were not able to run mcf, sjeng, omnetpp, and perlbench benchmarks mainly due to memory limitations. <ref type="figure">Figure 5</ref> shows the performance overhead of PHMon as a shadow stack over the baseline Rocket processor. On average, PHMon incurs 0.5%, 1.4%, and 1.2% performance overhead for our evaluated MiBench, SPECint2000, and SPECint2006 applications, respectively. Overall, PHMon has a 0.9% performance overhead on the evaluated benchmarks. <ref type="table" target="#tab_5">Table 3</ref> (the first three columns) provides a head-to-head comparison for the performance overhead of PHMon-based and HDFI-based shadow stacks. For both PHMon and HDFI, the evaluation baseline is the RISC-V Rocket processor. Unfortunately, HDFI only provides the shadow stack overhead numbers for four SPECint2000 benchmarks <ref type="bibr" target="#b76">[76]</ref>. These four benchmarks are cross-compiled for RISC-V using the GCC toolchain. On average, for these four benchmarks, PHMon has a 1.0% performance overhead compared to a 2.1% performance overhead of HDFI.</p><p>In the last column of <ref type="table" target="#tab_5">Table 3</ref>, we reported the performance overhead of our front-end pass LLVM implementation of a shadow stack. Our LLVM pass instruments the prologue and epilogue of each function to push the original return address and pop the shadow return address, respectively. We used Clang to compile four SPECint2000 benchmarks and used the reference input for our evaluations. We only compiled the main executable of SPEC benchmarks (without libraries such as glibc) using Clang. Hence, the implemented frontend pass only protects the main executable. On average, our Similar to HDFI, due to the memory limitations of our evaluation board, we had to reduce the buffer size of the reference input to 3 MB for gzip and bzip2 benchmarks. ± We used -O0 for PHMon and -O2 for LLVM and an input buffer size of 96 MB to run gap. † Due to memory limitation of our evaluation board, we used test input for mcf benchmark.</p><p>LLVM plugin has a 5.4% performance overhead.</p><p>The main source of performance overhead for PHMon is an increase in the number of memory accesses. Unlike our Rocket processor configuration, in a realistic deployment, the processor would at least include an L2 data cache. Hence, we expect PHMon's performance overhead to be lower in a realistic deployment, which alleviates the significant performance overhead caused by a cache miss.</p><p>To put PHMon's performance overhead into perspective, <ref type="table" target="#tab_6">Table 4</ref> compares PHMon's overhead with that of other stateof-the-art software and hardware shadow stack implementations. To facilitate this comparison, we have only listed the implementations that measure their performance overhead on SPEC benchmarks. As an overall criterion, the average overhead of a technique should be less than 5% for getting adopted by industry <ref type="bibr" target="#b79">[79]</ref>, which PHMon's shadow stack im-  <ref type="bibr" target="#b17">[17]</ref> Software (binary rewriting) 20.53% on SPEC2000 (encoding) 53.60% on SPEC2000 (memory isolation) <ref type="bibr" target="#b22">[22]</ref> Software (Pin tool) 2.17× on SPEC2006</p><p>[75] Software (DynamoRIO) 18.21% on SPEC2000</p><p>[86] Software (static binary instrumentation) 18% on SPEC2006</p><p>[20] Software 3.5% on SPEC2006</p><p>[56] Hardware ∼0.5%-∼2.4% on SPEC2000 Baseline AFL PHMon Fork Server plementation satisfies.</p><p>Hardware-Accelerated Fuzzing. To fuzz RISC-V programs, we integrated AFL into the user-mode RISC-V QEMU version 2.7.5. We fuzzed each of the 6 vulnerable programs for 24 hours using QEMU on the Zedboard FPGA. To provide a fair comparison, for the PHMon-based AFL experiments, we fuzzed each of these programs for the same number of executions as in the QEMU experiments. Similar to other works in fuzzing <ref type="bibr" target="#b71">[71,</ref><ref type="bibr" target="#b77">77]</ref>, we used the number of executions per second as our performance metric. We fuzzed each vulnerable program three times and calculated the average value of performance (all standard deviations were below 1%). For performance evaluation, we used the user-mode QEMU-based AFL running on the FPGA as our baseline. We also ran the QEMU-based fork server version of AFL as a comparison point for PHMon. <ref type="figure" target="#fig_3">Figure 6</ref> shows the performance improvement of the PHMon-based AFL over our baseline compared to the performance improvement of the fork server version of AFL. On average, PHMon improves AFL's performance by 16× and 3× over the baseline and fork server version, respectively. Similar to the baseline AFL, we can integrate PHMon with the fork server version of AFL. We expect this integration to further enhance PHMon's performance improvement of AFL. We validated the correct functionality of the PHMon-based AFL by examining the found crashes. On average, for the 6 evaluated vulnerable programs, PHMon-based AFL and the baseline AFL detected 12 and 11 crashes, respectively, for the same number of executions. The mismatch between the two approaches is due to the probabilistic nature of AFL-based fuzzing. Since PHMon improves the performance of AFL, it increases the probability of finding more unique crashes compared to the baseline.</p><p>Detecting Information Leakage. To validate that PHMon detects and prevents confidential information leakage, specifically private key of a server, we reproduced the Heartbleed attack on the FPGA by using OpenSSL version 1.0.1f. We initially sent non-malicious heartbeat messages to the server. As expected, none of these messages resulted in false positives. Next, we sent malicious heartbeat messages to the server to leak information. PHMon successfully detected the information leakage attempt and triggered an interrupt; and then, the OS terminated the process. For the non-malicious heartbeat messages, PHMon has virtually no performance overhead (only once a key is accessed, PHMon performs a few ALU operations). Watchpoints and Accelerated Debugger. We have used and validated the watchpoint capability of PHMon as part of the information leak prevention use case. Also, we evaluated PHMon's capability in accelerating a conditional breakpoint in a loop. Once the program execution reaches the breakpoint, PHMon triggers an interrupt. We evaluated two scenarios for handling the interrupt, trapping into GDB (PHMon_GDB) and terminating the process by generating the core dump file (PHMon_CoreDump). <ref type="figure">Figure 7</ref> shows the activation time of the breakpoint over the loop index value for GDB compared to two PHMon-accelerated scenarios. In case of GDB, which uses software breakpoints, each loop iteration results in two context switches to/from GDB, where GDB compares the current value of the loop index with the target value.</p><p>For the PHMon_GDB case, since PHMon monitors and evaluates the conditional breakpoint, GDB can omit the software breakpoints used in the previous case. Due to the initial overhead of running GDB, PHMon_GDB has a similar execution time as GDB for the first breakpoint index (i = 0). By increasing the breakpoint index, PHMon_GDB's execution time virtually stays the same while GDB's execution time increases linearly. For the PHMon_CoreDump case, since PHMon monitors the conditional breakpoint and generates a core dump (without running GDB), the performance overhead is negligible (i.e., virtually 0). This experiment clearly indicates PHMon's advantage as an accelerated debugger. Context Switch Performance Overhead. We measured the performance overhead of maintaining PHMon's configuration (including the configuration of MUs and CFUs, the counter and threshold of each MU, and local registers) across context switches for mcf benchmark with test input. On average, over three runs, PHMon increases the execution time The required operation to maintain PHMon's configuration during a context switch is constant. Hence, we expect the performance overhead of PHMon during context switches to be the same for other benchmarks. According to our evaluations for the shadow stack use case, the activation queue is empty before each context switch and there is no need to delay a context switch to complete the remaining actions. However, for different use cases depending on the actions, we might need to delay a context switch to perform the remaining actions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Power and Area Results</head><p>We measured the post-extraction power and area consumption of PHMon and the Rocket processor using the Cadence Genus and Innovus tools (at 1 GHz clock frequency). In this measurement, we used black box SRAMs for all of the memory components; then, we used CACTI 6.5 to estimate the leakage power and energy/access of memory components. Rocket contains an L1 data cache and L1 instruction cache while PHMon includes a Match Queue and Action Config Table as the main memory components. In our implementation, the Match Queue and each Action Config <ref type="table">Table consist</ref> of 2,048 and 16 elements, respectively. Each Match Queue element is 129-bit wide (for a configuration with 2 MUs), while each Action Config Table is 79-bit wide. Due to the small size of the Action Config Table, its power and area overheads are negligible.</p><p>To estimate the dynamic power of the Rocket's L1 caches and PHMon's Match Queue, we determined the average memory access rate of these components using PHMon and CSR cycle address. We estimated the access rate of the Match Queue for two of our use cases, 4 i.e., the shadow stack and the hardware-accelerated AFL, by leveraging PHMon (2 MUs with threshold=max) to count the number of calls and rets, jumps and branches, and call and branches, respectively. We averaged the access rates of our two use cases and determined the average dynamic power consumption based on this metric. <ref type="figure">Figure 8</ref> depicts the total area overhead as well as the power overhead of the main components of PHMon compared to the baseline Rocket processor. There is a trade-off between the number of MUs and the power and area overheads of PHMon. For the number of MUs ranging from 1 to 6, PHMon incurs a power overhead ranging from 3.6% to 10.4%. Similarly, area overhead ranges from 11% to 19.9% as we increase the MU count from 1 to 6. For all of our use cases in this paper, we used a design with only 2 MUs. This design has a 5% power overhead and it incurs a 13.5% area overhead. <ref type="table" target="#tab_8">Table 5</ref> lists the absolute power and area consumed by PHMon's AU and the Rocket core. <ref type="bibr" target="#b4">5</ref> Our FPGA evaluation shows that a PHMon configuration with 2 MUs increases the number of logic Slice LUTs by 16%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Discussion and Future Work</head><p>In this Section, we address some of undiscussed aspects of PHMon and present our future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Architecture Aspect</head><p>As discussed in Section 4, PHMon maintains the incoming match packets in a queue prior to performing follow-up actions. The size of this queue is a design decision, which affects the number of match packets that PHMon can have in flight. We envision that when the queue is full, PHMon can take one of the following actions: 1) PHMon may opt to drop the incoming match packets; 2) PHMon could stall the instruction fetch stage of Rocket's pipeline; 3) PHMon could raise an interrupt, then the OS stays in a sleep state, until a certain number of empty slots are available. In our current prototype, PHMon stalls the pipeline once the queue gets full. For all our experiments, a size of 2KB entries for the queue was sufficient to avoid any stalling. PHMon performs actions in a blocking manner, i.e., it only performs one action at a time. Although the L1 data cache in Rocket is non-blocking, PHMon blocks the rest of the actions while waiting to receive a memory response. This can increase the run time for performing actions. The evaluation results presented in the paper include the effect of blocking actions. Potentially, we can modify PHMon such that it can perform non-blocking actions. Although such a design will improve the performance, it will increase the complexity and power/area overheads of PHMon.</p><p>In this paper, we interface our PHMon with an in-order RISC-V processor. We implement the AU of PHMon as a microcontroller with restricted I/O, which implements a limited hand-crafted 16-bit ISA and provides a safe and restricted domain to take actions. Our developed ISA does not include branches/jumps, i.e., our AU is not Turing complete. This limited processing implementation is useful for preventing security threats. However, if a user requires actions that cannot be implemented by our restricted ISA, the option of triggering an interrupt provides the user with flexibility of executing actions in form of arbitrary programs. Then, PHMon can enforce the programmed security policies on these arbitrary action programs.</p><p>In the current implementation, we monitor the committed instruction stream. However, PHMon can apply the same monitoring model using other data streams, e.g., execution information from different stages of the pipeline or cache access information. Applying PHMon to other data streams will require minimal modifications to the processor for collecting the data streams and transmitting them to PHMon.</p><p>The number of MUs is another design decision when designing PHMon. The number of MUs directly affects power and area overheads. A user can monitor more events than the available number of MUs by time-multiplexing the MUs (similar to HPCs). Note that several MUs may trigger actions simultaneously; in this case, several match packets enter the Match Queue, where the MU with the lowest MU_id gets the highest priority to enter the queue. The user has an option to set a priority order for MUs. Currently, PHMon does not include a dedicated local memory shared between MUs. For future work, we will include a scratchpad memory or a Content Addressable Memory (CAM) in PHMon to reduce the number of outgoing accesses to the L1 data cache and in turn further reduce the performance overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Security Aspect</head><p>Regarding the security capabilities, in principle, we can extend PHMon to protect (parts of) the OS kernel as well. However, to achieve this protection from an attacker who has compromised the kernel, PHMon must be able to guarantee that an attacker cannot reprogram or disable engaged protections. As PHMon is configured from the kernel, providing such a guarantee is challenging against an adversary who holds the same privilege as the defense mechanism. The same is true for most architecturally supported security features, such as page permissions or Intel's proposed CET. While PHMon can easily be configured to ensure the integrity of configuration information and control instructions, integrity is merely a necessary condition to protect against a kernel-level adversary, it is not sufficient. For example, with integrity intact, attackers can launch mimicry or confused deputy attacks to reprogram PHMon. "Sealing" configurations (as mentioned in Section 4.2) and protecting integrity will raise the bar against kernel-level adversaries, but a complete solution that protects an OS kernel with a kernel-controlled defense mechanism requires further study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Application Aspect</head><p>The user can leverage multiple MUs to apply several monitoring policies simultaneously. For example, one can use 6 MUs to simultaneously apply all four use cases of PHMon presented in this paper. PHMon enables per process monitoring capabilities; hence, we can reuse an MU to apply different policies based on the requirements of the running process. For example, an MU that is used for debugging of a specific process can be reconfigured to prevent Heartbleed in any other process that is using openssl.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We presented the design, implementation, and evaluation of PHMon, a minimally-invasive programmable hardware monitor. PHMon is capable of enforcing a variety of security policies at runtime and also assisting with detecting software bugs and security vulnerabilities. Our PHMon prototype includes a full FPGA implementation that interfaces the monitor with a RISC-V processor, along with the necessary OS and software support. We demonstrated the versatility and ease of adoption of PHMon through four use cases; a shadow stack, a hardware-accelerated fuzzing engine, information leak prevention, and a hardware-accelerated debugger. On average, our shadow stack incurs 0.9% performance overhead while our hardware-assisted AFL improves the performance by up to 16×. An ASIC implementation of PHMon with 2 MUs has less than 5% and 13.5% power and area overheads, respectively.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: PHMon's microarchitecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Integration of PHMon with AFL.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Performance improvement of PHMon over the baseline AFL compared to fork server AFL. The numbers below the "Baseline AFL" bars show the number of executions per second for the baseline AFL.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :Figure 8 :</head><label>78</label><figDesc>Figure 7: The performance overhead of PHMon compared to GDB for a loop conditional breakpoint.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><head>Table 1 : Comparison of previous hardware monitoring techniques with PHMon</head><label>1</label><figDesc></figDesc><table>Mechanism 
Monitoring 
Use Cases 
Source Code 
Hardware 
Evaluation 
Avg. Performance 
Power/Area 
Mechanism 
Requirement Modification Methodology 
Overhead 
Overhead 

Hardbound [27] 
Tag-based 
BC 
Yes 
Inv 
Sim 
5%-9% 
# N/A 

SafeProc [32] 
Tag-based 
BC 
Yes 
Inv 
Sim 
5% 
# N/A 

Watchdog [51] 
Tag-based 
BC 
Yes 
Inv 
Sim 
15%-25% 
# N/A 

LIFT [59] 
SW (DBI) 
DIFT 
No 
SW 
SW 
∼200%-300% 
# N/A 

TaintCheck [54] 
SW (Tag-based) 
DIFT 
No 
SW 
SW 
Avg: # N/A 
# N/A 

Multi-Core DIFT [50] 
SW (Threads) 
DIFT 
No 
SW 
Sim 
48% 
# N/A 

DIFT [78] 
Tag-based 
DIFT 
No 
Min-inv 
Sim &amp; Emul 
1.1% 
# N/A 

Raksha [19] 
Tag-based 
DIFT 
No 
Inv 
FPGA 
48% 
# N/A 

FlexiTaint [81] 
Tag-based 
DIFT 
Yes 
Min-inv 
Sim 
1%-3.7% 
# N/A 

MemTracker [82] 
Tag-based 
MC 
Yes 
Inv 
Sim 
2.7% 
# N/A 

DataSafe [13] 
Tag-based 
DIFT 
No 
Inv 
Sim 
Avg: # N/A 
# N/A 

DISE [16] 
Binary Rewriting 
FI, (De)compress 
No 
Inv 
Sim 
Avg: # N/A 
# N/A 

LBA [11] 
Trace-based 
MC, DIFT, LOCKSET 
No 
Min-inv 
Sim 
390%-700% 
# N/A 

Optimized LBA [12] 
Trace-based 
MC, DIFT, LOCKSET 
No 
Min-inv 
Sim 
2%-327% 
# N/A 

FADE [30] 
Trace-based 
Memory &amp; Propagation Tracking 
No 
Min-inv 
Sim 
20%-80% 
Raw numbers 

Partial Monitoring [46] 
Trace-based 
MC, RC, DIFT, BC 
No 
Min-inv 
Sim 
50% 
(4%-11%) / (7%) 

PUMP [28] 
Tag-based 
NXD+NWC, DIFT, CFI, MC 
Yes 
Inv 
Sim 
∼8% 
(47%) / (55%) 

Harmoni [26] 
Tag-based 
MC, RC, DIFT, BC 
Yes 
Min-inv 
RTL Sim 
∼1%-8% 
(10%) / (110%) 

FlexCore [25] 
Tag-based 
MC, DIFT, BC, SEC 
Yes 
Min-inv 
RTL Sim 
5%-44% 
(14.6%) / (32.5%) 

HDFI [76] 
Tag-based 
SL Enhancement, Code Ptr Sep, Info Leak 
Yes 
Inv 
FPGA 
0.94% 
# N/A 
Kernel, Stack, and VTable Ptr Prot 

Nile [23] 
Trace-based 
Shadow Stack 
No 
Min-inv 
FPGA 
0.78% 
(26%) / (15%) 

REST [74] 
Tag-based 
Stack &amp; Heap Prot 
No 
Inv 
Sim 
2%-25% 
# N/A 

PHMon (This Work) 
Trace-based 
Shadow Stack, Fuzzing 
No 
Min-inv 
FPGA 
0.94% 
(5%) / (13.5%) 
Info Leak, Debugging 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>PHMon : Monitor Events/Take Actions User/Admin</head><label>PHMon</label><figDesc></figDesc><table>Event/Action 
Specification 
Using PHMon API 

Program 
PHMon 

PHMon 

Monitor the Process 
Execution &amp; 
Take Actions 

Process Is 
Terminated? 

PHMon Is 
Disabled? 

PHMon 

Stop Monitoring 

PHMon: Match Units 

A Match to an Event 
Is Found? 

PHMon: Queue 

Enqueue the Match 
Packet to Take Actions 

Y 
N 

Y 

Monitor Events 
Take Actions 

Y 

Y 

Actions Are Done? 

PHMon: Action Unit 

Take an Action 

Interrupt 
ALU Operation 
Memory 
Operation 
Skip Actions 

PHMon: Queue 

Dequeue a 
Match Packet 

Figure 1: An overview of the event-action model provided in PHMon. 

RISC-V Rocket 
Microprocessor 

Pipelined 
Processor Core 

L1 
Data Cache 

PC_GEN 
/Fetch 
Dec Exe Mem WB 

TU 

PHMon 

Commit Log 
-inst (32 bits) 
-pc_src (64 bits) 
-pc_dst (64 bits) 
-addr (64 bits) 
-data (64 bits) 

CoreInterrupt 

Memory Request 

Command 
-inst 
-[Rs1] 
-[Rs2] 
Response 
-Rd 
-[Rd] 

CoprocessorInterrupt 

MachineStatus 

Busy 

PageTableWalker 

Memory Response 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head></head><label></label><figDesc>FIRRTL is an Intermediate Representation (IR) for digital circuits. The FIRRTL compiler is analogous to the LLVM compiler.</figDesc><table>PHMon 

ALU 
Local 
Register 
File 

Control Unit 
(CU) 

Match Queue 

MU_data MU_addr MU_id 

... 

Match Packet 

conf_ptr 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><head>Table 2 : Parameters of Rocket core and PHMon.</head><label>2</label><figDesc></figDesc><table>Rocket Core 

Pipeline 
6-stage, in-order 
L1 instruction cache 16 KB, 4-way set-associative 
L1 data cache 
16 KB, 4-way set-associative 
Register file 
31 entries, 64-bit 

PHMon 

MUs 
2 
Local Register File 
6 entries, 64-bit 
Match Queue 
2,048 entries, 129-bit 
Action Config Table 16 entries 

accelerated AFL, we evaluated 6 vulnerable applications [85] 
including indent 2.2.1, zstd, PCRE 8.38, sleuthkit 4.1.3, 
nasm 2.11.07, and unace 1.2b. 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Performance overhead of PHMon-based shadow 
stack compared to that of HDFI-based (as reported in [76]) 
and LLVM-based shadow stacks. 

Benchmark PHMon HDFI LLVM Plugin 

gzip 
1.12% 1.12% 
2.24% 

mcf 
0.42%  † 1.76% 
8.42%  † 

gap 
1.92% ± 3.34% 
12.30% ± 

bzip2 
1.15% 3.05% 
3.66% 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Table 4 : Performance overhead of previous software and hard- ware implementations of shadow stack compared with PH- Mon.</head><label>4</label><figDesc></figDesc><table>Mechanism 
Methodology 
Performance Overhead 

[79] 
Software (LLVM plugin) 
5% on SPEC2006 

[1] 
Software (binary rewriting) 
21% on SPEC2000 (CFI + ID check) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>Table 5 : The power and area of PHMon's AU and RISC-V Rocket core determined using 45nm NanGate.</head><label>5</label><figDesc></figDesc><table>Power (µW /MHz) 
Description 
@1 GHz @180 MHz 
Area (mm 2 ) 

Rocket core 
534.3 
556.7 
0.359 
PHMon's AU 
43.8 
25.0 
0.048 

</table></figure>

			<note place="foot" n="2"> More precisely, the attack leaks the private prime number p which allows the attacker to reconstruct the private key.</note>

			<note place="foot" n="3"> We disabled Address Space Layout Randomization (ASLR) to simplify our buffer overflow attack.</note>

			<note place="foot" n="818"> 29th USENIX Security Symposium USENIX Association</note>

			<note place="foot" n="4"> The access rate for the other two use cases is negligible. 5 Note that in 40GPLUS TSMC process, Rocket processor has 0.034 mW/MHz dynamic power consumption and its area is 0.39 mm 2 [44]. Here, we use a non-optimized but publicly available process (45nm NanGate) for power and area measurements.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This material is based upon work supported by the National Science Foundation under Grant No. CNS-1916393 and CCF-1533663 and a Google Faculty Research award.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Appendix</head><p>In this appendix, we present the microarchitectural details of PHMon's Action Unit (AU) design. As discussed in Section 4.1, PHMon receives the commit log from the RoCC interface and then PHMon applies the configured monitoring rules to the commit log to detect events and perform follow-up actions. Once an MU finds a match, the MU sends an activation signal alongside a match packet to the AU. The match packet consists of an address (MU_addr), data (MU_data), and an MU identification number (MU_id). The MU_addr contains the address of the instruction in the commit log (i.e., pc_src element), while MU_data is programmable and can contain the contents of any one of the commit log entries. The MU_id specifies the index of the MU that triggered the activation signal. The AU enqueues an incoming match packet from the MU into the Match Queue while it performs actions for the packets arrived earlier. To perform actions, as shown in <ref type="figure">Figure 3</ref>, the AU consists of four distinct microarchitectural components: Config Units (CFUs), Local Register File, Arithmetic and Logic Unit (ALU), and Control Unit (CU). In the next subsections, we explain each of AU's microarchitectural components in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Config Units (CFUs)</head><p>In the PHMon design, each MU is paired with a CFU. Each CFU consists of three main components: an Action Config Table, a conf_ctr, and a conf_ptr. The Action Config <ref type="table">Table contains</ref> the list of actions (programmed by the user) that PHMon should perform after the MU finds a match and triggers the activation signal. The conf_ctr and conf_ptr preserve the index of the total number of actions and the current action, respectively. Each entry in the Action Config Table, called action description, consists of Type, In1, In2, Fn, Out, and Data elements (see <ref type="figure">Figure 3)</ref>.</p><p>Type specifies one of the following four types: ALU operation, memory operation, interrupt, and skip actions. In case of an ALU operation, In1 and In2 act as programmable input arguments of the ALU whereas for memory operations, In1 and In2 are interpreted as data and address of the memory request. In both cases, In1 and In2 can be programmed to hold the local register values (maintained in Local Register File) or an immediate value. The Out element specifies where the output of the ALU/memory operation is stored. The Fn element determines the functionality of an ALU operation or the type of the memory request. The Data element only applies to an ALU operation as immediate data. Note that in case of a memory operation, PHMon sends a memory request through the L1 data cache using the RoCC interface. The interrupt action triggers an interrupt, which will be handled by the OS. The skip actions provide the option of early action termination. In this case, when the result of an ALU operation is equal to zero, the AU will skip the remaining actions of the current event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Local Register File</head><p>The Local Register File consists of three dedicated registers for memory requests and their responses: Mem_addr, Mem_data, and Mem_resp, and three general-purpose registers: Local_1, Local_2, and Local_3. Memory operations occur using Mem_addr and Mem_data registers as the addr and data of the request while the result gets stored in the Mem_resp register. The user can use Local_1, Local_2, and Local_3 registers for ALU operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Arithmetic and Logic Unit (ALU)</head><p>We include a small ALU in PHMon to support a variety of actions. The ALU operations are restricted inside PHMon; however, these operations can be combined with other PHMon's actions (i.e., memory operations and interrupts) to provide the user with the capability to influence the process' execution. The input and output arguments of our ALU (including In1, In2, Fn, and Out) are programmable. The Fn argument determines the ALU function out of the following 10 different operations: Addition, Subtraction, Logical Shift Left, Logical Shift Right, Set Less Than, Set Equal, AND, OR, XOR, and NOP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4 Control Unit (CU)</head><p>The CU handles all the tasks related to performing actions. Our CU consists of a small FSM with three states: ready, wait, and busy. Depending on the current state of the CU, it performs one or more of the following tasks: dequeue a match packet from the Match Queue, update the Local Register File, receive the next action description, and perform an action. Once all of the listed actions are performed, the CFU notifies the CU. In this case, the CU enters the ready state, repeating all of the described tasks for the next element stored in the Match Queue.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Control-flow integrity principles, implementations, and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abadi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ú</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ligatti</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information and System Security (TISSEC)</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Announcing OSS-Fuzz: continuous fuzzing for open source software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aizatsky</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Serebryany</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Arya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Whittaker</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
			<publisher>Google Testing Blog</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Innovative technology for CPU based attestation and sealing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anati</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Gueron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scarlata</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Hardware and Architectural Support for Security and Privacy (HASP)</title>
		<meeting>the International Workshop on Hardware and Architectural Support for Security and Privacy (HASP)</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The Mitre Corporation, Air Force Systems Division</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anderson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename></persName>
		</author>
		<idno>ESD-TR-73-51</idno>
	</analytic>
	<monogr>
		<title level="j">Hanscom AFB</title>
		<imprint>
			<date type="published" when="1972" />
		</imprint>
	</monogr>
<note type="report_type">Tech. Report</note>
	<note>Computer security technology planning study</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The Rocket Chip generator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Asanovi´casanovi´</forename><surname>Asanovi´c</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Avizienis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Beamer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Biancolin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Celio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Dabbelt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Izraelevitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Karandikar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Koenig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Love</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Maas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Magyar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Moreto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Richards</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Twigg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Waterman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
		<respStmt>
			<orgName>EECS Department, UC Berkeley</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Efficient detection of all pointer and array access errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Austin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename><surname>Breach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sohi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Programming Language Design and Implementation (PLDI)</title>
		<meeting>the Conference on Programming Language Design and Implementation (PLDI)</meeting>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bachrach</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Richards</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Water-Man</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Avižienis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wawrzynek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And Asanovi´asanovi´ C</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Chisel: constructing hardware in a scala embedded language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Design Automation Conference (DAC)</title>
		<meeting>the Design Automation Conference (DAC)</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scrash: a system for generating secure crash information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Broadwell</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Harren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sastry</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">ROP is still dangerous: breaking modern defenses</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlini</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wagner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Logs and lifeguards: accelerating dynamic program monitoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kozuch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mowry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Teodorescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schlosser</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<idno>IRP-TR-06-05</idno>
		<imprint>
			<date type="published" when="2006" />
			<pubPlace>Intel Research</pubPlace>
		</imprint>
	</monogr>
<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Log-based architectures for general-purpose monitoring of deployed code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">B</forename><surname>Kozuch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mowry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">C</forename><surname>Teodorescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ailamaki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schlosser</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Architectural and System Support for Improving Software Dependability (ASID</title>
		<meeting>the Workshop on Architectural and System Support for Improving Software Dependability (ASID</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Flexible hardware acceleration for instruction-grain program monitoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kozuch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Strigkos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Gib-Bons</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">B</forename><surname>Mowry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">C</forename><surname>Ramachandran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ruwase</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Ryan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vlachos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Computer Architecture (ISCA)</title>
		<meeting>the International Symposium on Computer Architecture (ISCA)</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A software-hardware architecture for self-protecting data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-Y</forename><surname>Jamkhedkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Computer and Communications Security (CCS)</title>
		<meeting>the Conference on Computer and Communications Security (CCS)</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">ROPecker: A generic and practical approach for defending against ROP attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cheng</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">H</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Effective memory protection using dynamic tainting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clause</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Doudalis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Orso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prvulovic</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Automated Software Engineering (ASE)</title>
		<meeting>the International Conference on Automated Software Engineering (ASE)</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">DISE: a programmable macro engine for customizing applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Corliss</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Computer Architecture (ISCA)</title>
		<meeting>the International Symposium on Computer Architecture (ISCA)</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Using DISE to protect return addresses from attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Corliss</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Minos: control data attack prevention orthogonal to memory model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Crandall</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chong</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Microarchitecture (MICRO)</title>
		<meeting>the International Symposium on Microarchitecture (MICRO)</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Raksha: a flexible information flow architecture for software security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dalton</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kozyrakis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Computer Architecture (ISCA</title>
		<meeting>the International Symposium on Computer Architecture (ISCA</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The performance cost of shadow stacks and stack canaries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">H</forename><surname>Maniatis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wagner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Information</title>
		<meeting>the Symposium on Information</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">SoK: the challenges, pitfalls, and perils of using hardware performance counters for security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Das</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Werner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Antonakakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Polychron-Akis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Monrose</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Security and Privacy (S&amp;P)</title>
		<meeting>the Symposium on Security and Privacy (S&amp;P)</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">ROPdefender: a detection tool to defend against return-oriented programming attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Davi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Winandy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Information</title>
		<meeting>the Symposium on Information</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
		<respStmt>
			<orgName>Computer and Communications Security (ASIACCS</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Nile: a programmable monitoring coprocessor</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Delshadtehrani</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Eldridge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Canakci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Architecture Letters (CAL)</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">On the feasibility of online malware detection with performance counters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Demme</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Maycock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schmitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Waks-Man</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sethumadhavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stolfo</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Computer Architecture (ISCA)</title>
		<meeting>the International Symposium on Computer Architecture (ISCA)</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Flexible and efficient instruction-grained run-time monitoring using on-chip reconfigurable fabric</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deng</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">Y</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Malysa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Suh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Microarchitecture (MICRO)</title>
		<meeting>the International Symposium on Microarchitecture (MICRO)</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">High-performance parallel accelerator for flexible and efficient run-time monitoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deng</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Suh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Dependable Systems and Networks (DSN)</title>
		<meeting>the International Conference on Dependable Systems and Networks (DSN)</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Hardbound: architectural support for spatial safety of the C programming language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Devietti</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Blundell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zdancewic</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Architectural support for softwaredefined metadata processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dhawan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Hritcu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Vasilakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Chiricescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Knight Jr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">F</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dehon</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Efficient protection of path-sensitive control security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ding</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">FADE: a programmable filtering accelerator for instruction-grain monitoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fytraki</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Vlachos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kocberber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Falsafi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Grot</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on High Performance Computer Architecture (HPCA)</title>
		<meeting>the International Symposium on High Performance Computer Architecture (HPCA)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">GRIFFIN: guarding control flows using Intel processor trace</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jaeger</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS</title>
		<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Architectural support for low overhead detection of memory violations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ghose</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gilgeous</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Dudnik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Aggarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Waxman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Design, Automation and Test in Europe</title>
		<meeting>the Conference on Design, Automation and Test in Europe</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Google</forename><surname>Oss-Fuzz</surname></persName>
		</author>
		<ptr target="https://opensource.googleblog.com/2017/05/oss-fuzz-five-months-later-and.html" />
		<title level="m">five months later, and rewarding projects</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Searching for the prime suspect: how heartbleed leaked private keys</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham-Cumming</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<ptr target="https://blog.cloudflare.com/searching-for-the-prime-suspect-how-heartbleed-/leaked-private-keys/" />
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A case for unlimited watchpoints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greathouse</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Austin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">MiBench: a free, commercially representative embedded benchmark suite</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guthaus</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Ringenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Austin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename><surname>Mudge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Workload Characterization (WWC)</title>
		<meeting>the International Workshop on Workload Characterization (WWC)</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">SPEC CPU2000: measuring CPU performance in the new millennium</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henning</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page">7</biblScope>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">SPEC CPU2006 benchmark descriptions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henning</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Special Interest Group on Computer Architecture News (SIGARCH)</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Enforcing unique code target property for control-flow integrity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Yagemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P H</forename><surname>Har-Ris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">R</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Computer and Communications Security (CCS)</title>
		<meeting>the Conference on Computer and Communications Security (CCS)</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Ensemble learning for low-level hardware-supported malware detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Khasawneh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">N</forename><surname>Ozsoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Donovick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Abu-Ghazaleh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ponomarev</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Recent Advances in Intrusion Detection (RAID)</title>
		<meeting>the International Symposium on Recent Advances in Intrusion Detection (RAID)</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Flipping bits in memory without accessing them: an experimental study of DRAM disturbance errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Fallin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wilkerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mutlu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Computer Architecture (ISCA)</title>
		<meeting>the International Symposium on Computer Architecture (ISCA)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Intel MPX support will be removed from Linux</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larabel</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<ptr target="https://www.phoronix.com/scan.php?page=news_item&amp;px=Intel-MPX-Kernel-Removal-Patch/" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Intel MPX support removed from GCC 9</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larabel</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<ptr target="https://www.phoronix.com/scan.php?page=news_item&amp;px=MPX-Removed-From-GCC9/" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">A 45nm 1.3 GHz 16.7 double-precision GFLOPS/W RISC-V processor with vector accelerators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Waterman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Avizienis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stojanovi´cstojanovi´ Stojanovi´c</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Asanovi´casanovi´</forename><surname>Asanovi´c</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Solid State Circuits Conference (ESSCIRC)</title>
		<meeting>the European Solid State Circuits Conference (ESSCIRC)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Specification for the FIRRTL language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S</forename><surname>Izraelevitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bachrach</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<idno>UCB/EECS- 2016-9</idno>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
		<respStmt>
			<orgName>EECS Department, UC Berkeley</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Run-time monitoring with adjustable overhead using dataflow-guided filtering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">O</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ismail</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Suh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on High Performance Computer Architecture (HPCA)</title>
		<meeting>the International Symposium on High Performance Computer Architecture (HPCA)</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Pin: building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luk</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-K</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hazel-Wood</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Programming Language Design and Implementation (PLDI)</title>
		<meeting>the Conference on Programming Language Design and Implementation (PLDI)</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mijat</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
		<title level="m">Better trace for better software: introducing the new ARM CoreSight system trace macrocell and trace memory controller. ARM, White Paper</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Hardware techniques against memory corruption attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moon</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
		<respStmt>
			<orgName>Seoul National University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Dynamic information flow tracking on multicores</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nagarajan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-S</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gupta</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Interaction Between Compilers and Computer Architectures (INTERACT)</title>
		<meeting>the Workshop on Interaction Between Compilers and Computer Architectures (INTERACT)</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Watchdog: hardware for safe and secure manual memory management and full memory safety</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nagarakatte</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zdancewic</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Computer Architecture (ISCA</title>
		<meeting>the International Symposium on Computer Architecture (ISCA</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Watchdoglite: hardware-accelerated compiler-based pointer checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nagarakatte</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zdancewic</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Code Generation and Optimization (CGO)</title>
		<meeting>the International Symposium on Code Generation and Optimization (CGO)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Softbound: highly compatible and complete spatial memory safety for C</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nagarakatte</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zdancewic</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Programming Language Design and Implementation (PLDI</title>
		<meeting>the Conference on Programming Language Design and Implementation (PLDI</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Dynamic taint analysis: automatic detection, analysis, and signature generation of exploit attacks on commodity software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Newsome</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Song</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed Systems Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed Systems Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Intel MPX explained: a cross-layer analysis of the Intel MPX system stack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oleksenko</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Kuvaiskii</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bhatotia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Felber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fetzer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM on Measurement and Analysis of Computing Systems (SIGMETRICS)</title>
		<meeting>the ACM on Measurement and Analysis of Computing Systems (SIGMETRICS)</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">SmashGuard: a hardware solution to prevent security attacks on the function return address</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ozdoganoglu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Vijaykumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Brodley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Kuperman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jalote</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers (TC)</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page">10</biblScope>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Malware-aware processors: a framework for efficient online malware detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ozsoy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Donovick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gorelik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Abu-Ghazaleh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ponomarev</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on High Performance Computer Architecture (HPCA)</title>
		<meeting>the International Symposium on High Performance Computer Architecture (HPCA)</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Transparent ROP exploit mitigation using indirect branch tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pappas</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Polychronakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keromytis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Lift: a low-overhead practical information flow tracking system for detecting security attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-S</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Microarchitecture (MICRO)</title>
		<meeting>the International Symposium on Microarchitecture (MICRO)</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Pin: a binary instrumentation tool for computer architecture research and education</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reddi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">J</forename><surname>Settle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Connors</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cohn</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Computer Architecture Education (WCAE)</title>
		<meeting>the Workshop on Computer Architecture Education (WCAE)</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<title level="m" type="main">AMD64 architecture programmer&apos;s manual volume 2: system programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Advanced</forename><surname>Micro Devices</surname></persName>
		</author>
		<ptr target="https://support.amd.com/techdocs/24593.pdf" />
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<monogr>
				<ptr target="http://infocenter.arm.com/help/topic/com.arm.doc.prd29-genc-009492c/PRD29-GENC-009492C_trustzone_security_whitepaper.pdf" />
		<title level="m">ARM. ARM security technology, building a secure system using TrustZone technology</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Digilent&amp;apos;s Zedboard Zynq</forename><surname>Fpga</surname></persName>
		</author>
		<ptr target="http://www.digilentinc.com/Products/Detail.cfm?Prod=ZEDBOARD" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">Intel trusted execution technology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Intel</forename><surname>Corporation</surname></persName>
		</author>
		<ptr target="https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/trusted-execution-technology-security-paper.pdf" />
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<title level="m" type="main">Introduction to Intel memory protection extensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Intel</forename><surname>Corporation</surname></persName>
		</author>
		<ptr target="https://software.intel.com/en-us/articles/introduction-to-intel-memory-protection-extensions/" />
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Intel 64 and IA-32 architectures software developer&apos;s manual. System Programming Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Intel</forename><surname>Corporation</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Part</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<title level="m" type="main">Control-flow enforcement technology preview</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Intel</forename><surname>Corporation</surname></persName>
		</author>
		<ptr target="https://software.flow-enforcement-technology-preview.pdf" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title level="m" type="main">Microsoft security development lifecycle</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Microsoft</forename><surname>Corporation</surname></persName>
		</author>
		<ptr target="https://www.microsoft.com/en-us/sdl/process/verification.aspx" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nangate</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sunnyvale</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">California</forename></persName>
		</author>
		<imprint/>
	</monogr>
	<note>45nm open cell library</note>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Enforceable security policies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information and System Security (TISSEC)</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">kAFL: hardware-assisted feedback fuzzing for OS kernels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schumilo</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Aschermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gawlik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Schinzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Holz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Evaluating the effectiveness of current anti-ROP defenses</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schuster</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Tendyck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Pewny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Maass</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Steegmanns</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Contag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Holz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Research in Attacks, Intrusions and Defenses (RAID)</title>
		<meeting>the International Symposium on Research in Attacks, Intrusions and Defenses (RAID)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">On the detection of kernel-level rootkits using hardware performance counters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Singh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Evtyushkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Elwell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Riley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cervesato</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Asia Conference on Computer and Communications Security</title>
		<meeting>the Asia Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>AsiaCCS</publisher>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Practical memory safety with REST</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sinha</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sethumadhavan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Computer Architecture (ISCA</title>
		<meeting>the International Symposium on Computer Architecture (ISCA</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<monogr>
		<title level="m" type="main">Transparent runtime shadow stack: protection against malicious return address modifications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sinnadurai</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Wong</surname></persName>
		</author>
		<ptr target="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.120.5702&amp;rep=rep1&amp;type=pdf" />
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">HDFI: hardware-assisted data-flow isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Song</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Alam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paek</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Security and Privacy (S&amp;P)</title>
		<meeting>the Symposium on Security and Privacy (S&amp;P)</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Driller: augmenting fuzzing through selective symbolic execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephens</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Grosen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Salls</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dutcher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Corbetta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vigna</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Secure program execution via dynamic information flow tracking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Suh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Devadas</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">SoK: Eternal war in memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Szekeres</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Payer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Song</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Security and Privacy</title>
		<meeting>the Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thoziyoor</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muralimanohar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jouppi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">P</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
		<respStmt>
			<orgName>HP Labs</orgName>
		</respStmt>
	</monogr>
<note type="report_type">CACTI 5.1. Tech. rep</note>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Flexitaint: A programmable accelerator for dynamic taint propagation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Venkataramani</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Doudalis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Solihin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prvulovic</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on High Performance Computer Architecture (HPCA)</title>
		<meeting>the International Symposium on High Performance Computer Architecture (HPCA)</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Memtracker: efficient and programmable support for memory access monitoring and debugging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Venkataramani</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Roemer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Solihin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prvulovic</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on High Performance Computer Architecture (HPCA)</title>
		<meeting>the International Symposium on High Performance Computer Architecture (HPCA)</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<monogr>
		<title level="m" type="main">The RISC-V instruction set manual, volume i: Base user-level ISA</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Waterman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Asanovi´casanovi´</forename><surname>Asanovi´c</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
		<idno>UCB/EECS-2011-62</idno>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
		<respStmt>
			<orgName>EECS Department, UC Berkeley</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Tech. Report</note>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Hardware-assisted finegrained code-reuse attack detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ding</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Research in Attacks, Intrusions and Defenses (RAID)</title>
		<meeting>the International Symposium on Research in Attacks, Intrusions and Defenses (RAID)</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<monogr>
		<title level="m" type="main">American fuzzy lop (AFL) fuzzer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zalewski</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<ptr target="http://lcamtuf.coredump.cx/afl" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">A platform for secure static binary instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Qiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hasabnis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sekar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Virtual Execution Environments (VEE)</title>
		<meeting>the International Conference on Virtual Execution Environments (VEE)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Hardware performance counters can detect malware: myth or fact?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Jahanshahi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Asia Conference on Computer and Communications Security (ASIACCS)</title>
		<meeting>the Asia Conference on Computer and Communications Security (ASIACCS)</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">iWatcher: efficient architectural support for software debugging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Torrellas</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Computer Architecture (ISCA)</title>
		<meeting>the International Symposium on Computer Architecture (ISCA)</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">HARD: hardware-assisted lockset-based race detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Teodorescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on High Performance Computer Architecture (HPCA)</title>
		<meeting>the International Symposium on High Performance Computer Architecture (HPCA)</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
