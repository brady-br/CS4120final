<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:14+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Testing Error Handling Code in Device Drivers Using Characteristic Fault Injection Testing Error Handling Code in Device Drivers Using Characteristic Fault Injection</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>June 22-24. 2016</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jia-Ju</forename><surname>Bai</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu-Ping</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jie</forename><surname>Yin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shi-Min</forename><surname>Hu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jia-Ju</forename><surname>Bai</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu-Ping</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jie</forename><surname>Yin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shi-Min</forename><surname>Hu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Technology</orgName>
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Testing Error Handling Code in Device Drivers Using Characteristic Fault Injection Testing Error Handling Code in Device Drivers Using Characteristic Fault Injection</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2016 USENIX Annual Technical Conference (USENIX ATC &apos;16)</title>
						<meeting>the 2016 USENIX Annual Technical Conference (USENIX ATC &apos;16) <address><addrLine>Denver, CO, USA</addrLine></address>
						</meeting>
						<imprint>
							<biblScope unit="volume">635</biblScope>
							<biblScope unit="page">1</biblScope>
							<date type="published">June 22-24. 2016</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 2016 USENIX Annual Technical Conference (USENIX ATC &apos;16) is sponsored by USENIX. https://www.usenix.org/conference/atc16/technical-sessions/presentation/bai USENIX Association</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Device drivers may encounter errors when communicating with OS kernel and hardware. However, error handling code often gets insufficient attention in driver development and testing, because these errors rarely occur in real execution. For this reason, many bugs are hidden in error handling code. Previous approaches for testing error handling code often neglect the characteristics of device drivers, so their efficiency and accuracy are limited. In this paper, we first study the source code of Linux drivers to find useful characteristics of error handling code. Then we use these characteristics in fault injection testing, and propose a novel approach named EH-Test, which can efficiently test error handling code in drivers. To improve the representativeness of injected faults, we design a pattern-based extraction strategy to automatically and accurately extract target functions which can actually fail and trigger error handling code. During execution, we use a monitor to record runtime information and pair checkers to check resource usages. We have evaluated EH-Test on 15 real Linux device drivers and found 50 new bugs in Linux 3.17.2. The code coverage is also effectively increased. Comparison experiments to previous related approaches also show the effectiveness of EH-Test.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>As important components of the operating system, device drivers control hardware and provide fundamental supports for high-level programs. During driver execution, different kinds of occasional errors may occur, such as kernel exceptions and hardware malfunctions <ref type="bibr" target="#b30">[31]</ref>. Therefore, device drivers need error handling code to assure reliability. But in some drivers, error handling code is incorrect or even missed. In these drivers, serious problems like system crashes and hangs may occur when occasional errors are triggered. According to our study on Linux driver patches, more than 40% of accepted patches add or update corresponding error handling code. It shows that error handling code in device drivers is not reliable enough, so testing error handling code and detecting bugs inside are very necessary.</p><p>A challenge of testing error handling code is that occasional errors are infrequent to happen in real execution <ref type="bibr" target="#b33">[34]</ref>. For example, "bad address" (EFAULT) is a common error should be handled, but it happens only when the memory or I/O address is invalid. Another example is hardware error, which happens only when the hardware malfunctions. Triggering these errors in real environment is very hard and uncontrollable.</p><p>To simulate software and hardware errors at runtime, software fault injection (SFI) is often used in driver testing. This technique mutates the code to inject specific errors into the program, and enforces error handling code to be executed at runtime. Linux Fault Injection Capabilities Infrastructure (LFICI) <ref type="bibr" target="#b41">[43]</ref> is a well-known project integrated in Linux kernel. It can simulate common errors, such as memory-allocation failures and bad data requests. Inspired by LFICI, other fault injection approaches <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b31">32]</ref> have been proposed in recent years, and they have shown promising results in driver testing and bug detection. However, these approaches still have some limitations in practical use.</p><p> The representativeness of injected faults is often neglected, and most injected faults are random or manually selected. Random faults can not reflect real errors well. Manually selected faults often omit representative injected faults.</p><p> Numerous redundant test cases are generated. In fact, many generated test cases may cover the same error handling code, but they all need to be actually tested at runtime. For this reason, they often spend much time in runtime testing.</p><p> Only several kinds of faults can be injected, such as memory-allocation failures. But these faults can not cover most error handling code in drivers.</p><p> Much manual effort is needed. The kinds and places of injected faults are often manually decided. In fact, previous fault injection approaches aim to support general software, but they neglect the characteristics of target programs. To relieve their limitations, we should consider the key driver characteristics in SFI. For example, because drivers are often written in C, so built-in error handling mechanisms (such as "try-catch") are not supported. For this reason, the developers often use an if check to decide whether the error handling code should be triggered in device drivers. This characteristic can help to decide which functions can actually fail and should be fault-injected.</p><p>In this paper, we first study Linux driver code, and find three useful characteristics in error handling code: function return value trigger, few branches and check decision. Then based on these characteristics and SFI, we propose a practical approach named EH-Test <ref type="bibr" target="#b0">1</ref> to efficiently test error handling code and detect bugs inside. Firstly, EH-Test uses a pattern-based extraction strategy to extract target functions which can fail from the captured runtime traces of normal execution. This strategy can automatically and accurately extract real target functions to improve the representativeness of inject faults. Then, we generate test cases by corrupting the return values of target functions. Next, we run each test case on the real hardware, and use a monitor to record runtime information and pair checkers to check resource-usage violations. These pair checkers contain the basic information of resource-acquiring and resourcereleasing functions, which can be obtained from specification mining techniques <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b37">38]</ref> and user configuration. During driver execution, system crashes and hangs can be easily identified through kernel crash logs or user observation. After driver execution, EH-Test can report resource-release omissions. We have implemented EH-Test using LLVM, and evaluated it on 15 Linux drivers of three classes. The results show that EH-Test can accurately find real bugs in error handling code and improve code coverage in runtime testing. Comparison experiments to previous approaches also show its effectiveness.</p><p>Compared to previous SFI approaches for testing drivers, our approach have four advantages: 1) Representative injected faults. We design a pattern-based extraction strategy to automatically and accurately extract real target functions as representative injected faults. It uses code patterns to decide whether a function can actually fail in driver execution. This strategy can largely improve the effectiveness of SFI.</p><p>2) Efficient test cases. According to our study, many drivers have few branches in error handling code, so injecting a single fault in each test case is enough to cover most error handling code. Moreover, our patternbased extraction strategy can filter many unrepresentative injected faults. Therefore, the test cases generated by EH-Test are efficient, and the time usage of runtime testing can be largely shortened.</p><p>3) Accurate bug detection. By injecting representative faults, EH-Test can realistically simulate different kinds of occasional errors to cover error handling code. Moreover, EH-Test runs on the real hardware and uses exact execution information to perform analysis. These points assure the accuracy of bug detection.  show that EH-Test can efficiently perform driver testing and accurately find real bugs. The rest of this paper is organized as follows. Section 2 introduces the motivation. Section 3 presents the three characteristics of device drivers found by our study on Linux driver code. Section 4 presents our pattern-based extraction strategy. Section 5 introduces EH-Test in detail. Section 6 shows our evaluation on 15 Linux device drivers and comparison experiments to previous approaches. Section 7 introduces the related work and Section 8 concludes this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Motivation</head><p>To ensure the reliability of device drivers, error handling code should be correctly implemented to handle different kinds of occasional errors. But in fact, error handling code is incorrect or even missed in some drivers, so hard-to-find bugs may occur during execution. In this section, we first reveal this problem using a concrete example and our study on Linux driver patches, and then we sketch the software fault injection technique used in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Motivating Example</head><p>We first motivate our work using a real Linux driver bnx2. This driver manages Broadcom NetXtreme II Ethernet Controller. <ref type="figure" target="#fig_0">Figure 1</ref>  In this example, we have three findings. Firstly, error handling code in drivers is often used to release allocated resources and undo recent operations <ref type="bibr" target="#b29">[30]</ref>. It is because that many drivers are based on the fail-stop model <ref type="bibr" target="#b32">[33]</ref>, namely a simple error can force the driver to exit. Due to this feature, many bugs in error handling are related to resource-usage violations, such as resource leaks and deadlocks. Secondly, error handling code is often written in a separate segment in drivers (line 8274-8253 in <ref type="figure" target="#fig_0">Figure 1</ref> is an example), and different "goto" target labels handle different errors. This gotobased strategy is recommended by the Linux kernel documentation <ref type="bibr" target="#b42">[44]</ref>, because this strategy can simplify error handling logic and reduce repeated code. Thirdly, bugs in error handling code are hard-to-find. It is because that error handling code is rarely executed, and maintainers pay insufficient attention to it. In the example, from Linux 3.1.1 (released in November 2011) to 3.17.2 (released in October 2014), the memory leak in <ref type="figure" target="#fig_0">Figure 1</ref> had not been fixed. Thus, it is very necessary to reveal and detect bugs in error handling code.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Study on Linux Patches</head><p>To clearly illustrate the reliability of current error handling code in device drivers, we make a study on Linux driver patches. We manually read patches in the Patchwork project 2 and select accepted patches from them in July 2015. These patches are from 5 driver classes, namely I2C bus drivers, PCI bus drivers, PowerPC drivers, real-time clock (RTC) drivers and network drivers. Among them, we identify those which add or update corresponding error handling code. The result is listed in <ref type="table">Table 1</ref>. The first column presents the driver class name; the second column shows the number of accepted patches; the third column shows the number and percentage of accepted patches add or update corresponding error handling code.</p><p>From <ref type="table">Table 1</ref>, we find that 40% accepted patches add or update corresponding error handling code. In these accepted patches, many are used to fix common bugs, such as memory leaks and null pointer dereferences. One reason for this phenomenon is that complex control flows and different kinds of occasional errors make it difficult to implement correct error handling code. Another reason is that error handling code is often triggered by specific and infrequent conditions (such as insufficient memory and hardware errors), so developers hardly test it well at runtime.</p><p>In brief, current error handling code in device drivers is not reliable enough as we expected, and many bugs are hidden in it. Once these bugs are triggered, serious system problems may occur, such as crashes and resource leaks. Therefore, it is important and necessary to test error handling code in device drivers and detect bugs inside.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Software Fault Injection</head><p>Software fault injection (SFI) is a widely used technique of testing error handling code. It intentionally introduces faults or occasional errors into the program, and then tests whether the program can correctly handle the injected faults or errors at runtime. In this paper, we use SFI to test drivers and detect bugs. To help better understand this paper, we explain several terms about SFI.</p><p>Fault Injection. We inject faults or errors to make error handling code executed at runtime. In this paper, fault injection and error injection <ref type="bibr" target="#b16">[17]</ref> can be identical, and injected faults can also be called injected errors. As shown in <ref type="figure" target="#fig_0">Figure 1</ref>, we can inject a fault or error to make the function ioremap_nocache (line 7937) fail, and let its error handling code (line 8247-8253) executed. Fault Representativeness. It reflects whether an injected fault can represent a real fault or error to trigger error handling code. If the injected fault is representative, it means that this fault or error can occur in real execution, so the bugs detected in this situation can be regarded as real bugs. Otherwise, the detected bugs are very probably false. Fault representativeness is a key factor, and it decides the effectiveness of SFI <ref type="bibr" target="#b23">[24]</ref>. Target Function. A target function is a called function which can fail and trigger error handling code, so it should be fault-injected in SFI. A target function can be a kernel interface or defined in the driver code. If a target function is real, its failure can be a representative injected fault, because its failure can cause a real error and actually trigger error handling code. Namely, the realness of target functions largely decides the fault representativeness of SFI. For example in <ref type="figure" target="#fig_0">Figure 1</ref>, the function ioremap_nocache can actually fail and return a null pointer to trigger error handling code, so it is a real target function. False Positive. There are two kinds of false positives in this paper. One is the false positive of fault representativeness, which is the injected fault that can not actually trigger error handling code. The other is the false positive of bug detection, which is the false detected bug.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Driver Class Number "Goto" Statement Return Value</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Characteristics</head><p>Previous SFI approaches often have limitations in practical use, such as reporting many false bugs and needing much manual effort. One reason is that they are often used for general software, but neglect key characteristics of device drivers. To improve SFI in testing drivers, we first study the source code of Linux device drivers to find key characteristics of error handling code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Function Return Value Trigger</head><p>Occasional errors in drivers are often triggered with the function failures, which are reflected as bad return values (null pointers or negative integers of error codes). As shown in <ref type="figure" target="#fig_0">Figure 1</ref>, when an error occurs in memory mapping, ioremap_nocache returns a null pointer. In the example, we find that error handling code is triggered by a bad function return value. To know about the proportion of this specific form, we write a program to automatically analyze the source code of 848 Linux (version 3.17.2) device drivers from 7 driver classes. These driver classes are all commonly used, so the study result on them can be applicative to most drivers.</p><p>In the study, we search for "goto" statements in the code, because they are often the entries of error handling code according to the goto-based strategy <ref type="bibr" target="#b29">[30]</ref>.</p><p>The result is shown in <ref type="table" target="#tab_4">Table 2</ref>. The first column shows the driver class name; the second column shows the number of drivers in each class; the third column shows the number of "goto" statements; the fourth column shows the number and proportion of "goto" statements in the "if" branches of bad function return values.</p><p>From <ref type="table" target="#tab_4">Table 2</ref>, we find that about 75% of "goto" statements are in the "if" branches of bad function return values. It indicates that most error handling code in device drivers is triggered by bad function return values. There are two common data types of function return values in device drivers, namely pointer and integer. According to the Linux kernel documentation <ref type="bibr" target="#b42">[44]</ref>, a null pointer or non-zero integer indicates the operation failure. Moreover, different non-zero integers represent different failure types. For example, -EIO indicates an input/output error and -ENODEV indicates no such device. As for the remaining 25% "goto" statements, they are triggered by data failures in the code, such as erroneous data read from registers and bad device states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Few Branches</head><p>In user-mode applications, error handling code often contains many if branches <ref type="bibr" target="#b38">[39]</ref>. The main reason is that most user-mode applications are based on fail-recovery model. During recovery, error handling code should handle other errors. Therefore, multiple faults need to be injected in user-mode applications to cover most error handling code in runtime testing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Procedure: Pattern-based extraction strategy</head><p>1: func_set := ø; cand_set := ø; fault_set := ø; 2: func_set := called functions in normal execution traces;</p><p>3: foreach func in func_set do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4:</head><p>if GetRetType(func) == integer or pointer then 5:</p><p>AddSet(cand_set, func);</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6:</head><p>end if 7 end foreach 8: foreach func in cand_set do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>9:</head><p>if func's RetVal is checked by "if" in the driver then 10:</p><p>AddSet(fault_set, func);</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11:</head><p>else if func's RetVal is checked in other drivers then 12:</p><p>AddSet(fault_set, func);</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>13:</head><p>else if func's RetVal is specified to be checked then 14:</p><p>AddSet(fault_set, func); Different from user-mode applications, many device drivers are based on the fail-stop model <ref type="bibr" target="#b32">[33]</ref>. Namely, when an error occurs, the driver only handles it and prepares to exit, but other errors are never handled at that time. Thus, there are few if branches in error handling code of device drivers. To validate this characteristic, we also write a program to automatically analyze the source code of these 848 Linux drivers. In the study, we first filter out all annotations and blank lines, and then count source code lines with and without if branches in error handling code. The result is shown in <ref type="table" target="#tab_5">Table 3</ref>. The first column shows the driver class name; the second column shows the number of drivers in each class; the third column presents the number of source code lines in error handling code; the fourth column presents the number and proportion of source code lines without if branches in error handling code.</p><p>From <ref type="table" target="#tab_5">Table 3</ref>, we can see that nearly 78% of error handling code is not in if branches in these drivers. It indicates that injecting a single fault in each test case is enough to cover most error handling code. This characteristic can help to simplify the complexity of injected faults and improve the efficiency of SFI. The remaining 22% error handling code is in if branches because different resource-usage states or device states need to be separately handled in the same error handling code.</p><p>This characteristic commonly exists in fail-stop drivers. However, some drivers like SATA are based on the fail-recovery model, namely they will restart when an error occurs. Thus, many branches are needed to handle the recovery procedure. For these drivers, injecting a single fault is not enough to cover most error handling code. In this paper, we mainly focus on fail-stop drivers, because they occupy a large part of existing drivers <ref type="bibr" target="#b33">[34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Check Decision</head><p>Linux drivers are often implemented in C, so built-in error handling mechanisms (such as "try-catch") are not supported. To check whether an occasional error occur, an if check is often used in the source code. The if statement checks whether the key data is erroneous and decides whether error handling code should be executed. This key data can be a common variable or a function return value. Thus, the characteristic in Section 3.1 can be regarded as an aspect of it. For example in <ref type="table" target="#tab_4">Table 2</ref>, all "goto" statements triggered by bad function return values are in if checks. Particularly, most if checks for function return values only check whether the value is a null pointer or non-zero integer (line 7938 in <ref type="figure" target="#fig_0">Figure 1</ref> is an example). Namely, different bad function return values are often handled by the same error handling code.</p><p>This if check decision characteristic is also recommended by the Linux kernel documentation <ref type="bibr" target="#b42">[44]</ref>. It can help us inject more representative and efficient faults for SFI. Specifically, we can inject faults in the data checked by these if checks, to simulate more realistic errors in device drivers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Pattern-based Extraction</head><p>The representativeness of injected faults is a key factor of SFI <ref type="bibr" target="#b23">[24]</ref>. This property largely determines the accuracy of bug detection and the efficiency of runtime testing. Injecting representative faults can simulate realistic errors to trigger real error handling, so detected bugs are very probably real. Meanwhile, useless test cases are less generated when the injected faults are representative, so the time usage can be largely reduced.</p><p>A common strategy is to inject random faults, which has been used in many previous SFI approaches <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22]</ref>. But some studies <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b23">24]</ref> have proved this strategy can not well represent real errors, and they also introduces many false positives in bug detection. Because most error handling code in drivers is triggered by bad function return values (in Section 3.1), it is feasible to inject faults in some manually selected target functions which can fail at runtime. This strategy has been used in some previous approaches <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b41">43]</ref> to test drivers, but it has three problems. Firstly, new target functions should be manually selected when testing a new driver. Secondly, it is hard to assure the selected target functions can actually trigger realistic errors at runtime. Thirdly, many real target functions may be omitted in manual selection.</p><p>Based on the characteristics mentioned in Section 3.1 and 3.3, we propose a pattern-based extraction strategy to automatically and accurately extract real target functions from the source code. <ref type="figure" target="#fig_2">Figure 2</ref> shows the main procedure of this strategy, which consists of two phases. The return values of some kernel interface functions are clearly specified to be checked in their declarations or annotations, because they can trigger errors. For example in the Linux kernel code, a specific macro "__must_check" is defined. If this macro is noted in the declaration of a function, its return value must be checked. The function pci_request_regions in <ref type="figure" target="#fig_0">Figure 1</ref> uses this macro. Besides, some key phrases in the function annotation also indicate the function return value should be checked. Therefore, the declaration and annotation of candidate functions should be checked as well. This strategy has three advantages. Firstly, when the driver source code and hardware are available, this strategy can automatically extract target functions without manual effort. Secondly, by using exact runtime information and common code patterns, many unreal target functions are filtered out. Thirdly, no real target functions in the captured runtime traces are omitted. By using this strategy, we can automatically and accurately extract real target functions as representative injected faults to improve the effectiveness of SFI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Approach</head><p>To efficiently test error handling code in device drivers, we propose EH-Test based on driver characteristics, code instrumentation and dynamic analysis. <ref type="figure">Figure 3</ref> shows the overall architecture of EH-Test, which consists of five modules:</p><p> Fault extractor. This module uses the patternbased extraction strategy to automatically extract target functions. It needs the source code of the target driver, other drivers and kernel interface functions as input, which can be obtained from the OS source code. Based on the architecture, two phases are performed when EH-Test works, namely test case generation and runtime testing. The manual work only includes writing pair checkers, checking extracted target functions and rebooting the system when crash bugs are detected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Test Case Generation</head><p>In this phase, we have two tasks, namely extracting target functions from the code and generating test cases of the driver by injecting faults on target functions. The detailed steps are as follows.</p><p>Firstly, we input the driver code and OS source code to the fault extractor. It uses the pattern-based extraction strategy to extract target functions. After extraction, the user also is allowed to check and modify target functions as needed.</p><p>Secondly, we inject faults into target functions. A key question is that how many faults should be injected in each test case. Many previous approaches <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b38">39]</ref> inject multiple faults in each test case, because they aim to cover as much error handling code as possible. But fault scenario explosion may occur in this situation,  <ref type="figure">Figure 4</ref>: Compilation procedure of the tested driver.</p><p>which can largely reduce testing efficiency. To relieve this problem and speed up testing, these approaches have to use some expedients, such as limiting the number of injected faults (or searching paths) <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b38">39]</ref> and resorting to user guidance <ref type="bibr" target="#b21">[22]</ref>. For many Linux drivers, a key characteristic is that there are few if branches in error handling code (in Section 3.2). Namely, the error handling code in many device drivers only handles a single error at a time. Thus, to cover most error handling code with less testing time, we only corrupt the return value of one target function in each test case. The target function call is replaced by an error function in the code. What this error function does is only returning a bad value. If the return value of the target function is a pointer, the error function will return a null pointer; if the return value of the target function is an integer, the error function will return a random negative number. Thirdly, we instrument probes to collect runtime information and count code coverage during execution. The runtime information is used to detect bugs in the next phase. The code coverage is used to quantify the effectiveness of runtime testing. Finally, driver test cases are generated. Each test case is a kernel object file, namely a loadable driver.</p><p>In the second and third steps, code instrumentation is used. We implement it at compile time using the Clang <ref type="bibr">[40]</ref> compiler. <ref type="figure">Figure 4</ref> shows the compilation procedure of the tested driver. Firstly, we use the Clang compiler to compile the C source code of the driver into the LLVM bytecode. Secondly, we utilize the fault injector and probe inserter to instrument our handled code in the bytecode. Thirdly, we use the Clang compiler to compile the bytecode into the assembly code, and then build the object file using GCC. Finally, we link the object file and the runtime monitor's program together, and generate a kernel object file as a test case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Runtime Testing</head><p>In this phase, we run each test case on the real hardware and detect bugs during execution. Three kinds of bugs are detected in current implementation, namely crashes, hangs and resource-release omissions.</p><p>When driver crashes occur, the OS outputs the dump information into the kernel crash log. Therefore, we can check the kernel crash log to detect and locate crash bugs like null pointer dereferences. For driver hangs, we can detect them by observing whether the system freezes. These two kinds of bugs are easy to observe in real execution.  <ref type="table">Table 4</ref>: Selected paired functions in device drivers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Function</head><p>As for resource-release omissions, they are hard-tofind in real execution, because they rarely lead to obvious exceptions. However, they often cause resourceusage problems, such as resource leaks and memory leaks. Moreover, resource-release omissions often occur in device drivers, especially in error handling code <ref type="bibr" target="#b30">[31]</ref>. For these reasons, EH-Test should detect resourcerelease omissions in device drivers. A resource-release omission occurs when a resource-acquiring function is successfully called but its resource-releasing function is not called. For example in <ref type="figure" target="#fig_0">Figure 1</ref>, kzalloc is a resource-acquiring function and it is used to allocate kernel memory, but the resource-releasing function kfree is not called, which leads to a resource-release omission. A resource-acquiring function and its resource-releasing function should be called in pairs, so they can be called paired functions <ref type="bibr" target="#b19">[20]</ref>. Besides, they should operate the same mapped data (parameter or return value) as the handled resource. In EH-Test, we implement some pair checkers to detect resource-release omissions. Each pair checker contains the basic information of a pair of paired functions, including function names and mapped data. Some previous approaches for specification mining <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b37">38]</ref> can be used to extract paired functions from the code. In this paper, we use the mining result of PF-Miner <ref type="bibr" target="#b19">[20]</ref>, which is a static approach for mining paired functions in Linux drivers, to build the pair checkers. <ref type="table">Table 4</ref> shows some selected paired functions in the checkers. The first column shows function names; the second column shows the description; the third column shows the mapped data.</p><p>During driver execution, the runtime monitor uses the inserted probes to record the runtime information of function calls and maintains a resource-usage list. For each function call, the monitor checks whether it is in the pair checkers. When a resource-acquiring function is called, the monitor checks its return value to judge whether the resource is successfully allocated. If it is true, the monitor will create a node containing the function name and mapped data, and add it into the resource-usage list. When a resource-releasing function is called, the monitor scans the list to match the node with the function information. If it is matched, the node will be deleted to indicate the resource is released. When the driver is removed, the monitor checks the nodes in the list. If the list is not empty, it indicates resource-release omissions occur, so the monitor will report them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Experimental Setup</head><p>To validate the effectiveness of EH-Test, we evaluate it on real device drivers. The tested drivers should satisfy three criteria. Firstly, they should be commonly used in practice. Secondly, they should be within the driver classes in Section 3, because they can satisfy the characteristics found by the study. Thirdly, they should run as kernel modules, because the test cases of them can be directly installed and removed without rebooting the operating system. According to these criteria, 15 Linux device drivers are selected, including wireless, USB and Ethernet drivers.  The experiment runs on a Lenovo PC with two Intel i5-3470@3.20G processors and 2GB physical memory. GCC 4.8 and Clang 3.2 are used for compilation. We write 75 pair checkers based on the result of PF-Miner. For each test case of the drivers, we install it in the system, run it on the workload, and finally remove it. The workload consists of three kinds. For wireless drivers, we turn on WiFi, ping another computer and turn off WiFi; for Ethernet drivers, we ping another computer; For USB drivers, we copy a 4MB file to the USB disk.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Target Function Extraction</head><p>The representativeness of injected faults is a key factor of SFI. In this paper, injected faults are bad return values of target functions, and all target functions are automatically extracted by our pattern-based extraction strategy. Thus, the fault representativeness of SFI largely depends on the effectiveness of our pattern-based extraction strategy. There are three important research questions about its effectiveness:</p><p>RQ1: How many unrepresentative candidate functions are automatically filtered out? RQ2: How much is the false positive rate of the strategy? RQ3: How many real target functions are omitted?</p><p>To answer these questions, we first evaluate EH-Test on the 15 drivers to extract candidate functions and target functions. Then we manually check the extracted target functions to judge their realness. <ref type="table" target="#tab_13">Table 6</ref> shows the result in Linux 3.17.2. The first column presents the driver name; the second column shows the number of candidate functions; the third column shows the number of extracted target functions; the fourth column shows the number of real target functions.</p><p>From <ref type="table" target="#tab_13">Table 6</ref>, we can find that 523 target functions are extracted from 2183 candidate functions. It indicates that 76% candidate functions are automatically filtered out because they are unrepresentative, which can answer RQ1. By manually checking the documents and implementations of the extracted target functions, we find that 470 target functions are real, which means they can actually fail and trigger error handling code. It indicates that the false positive rate of our pattern-based extraction strategy is only 10%, which can answer RQ2. Many false target functions return integers which are also checked by if statements, but they reflect different driver configurations or states but never trigger occasional errors. Answering RQ3 is difficult, because target   functions are extracted from normal execution traces, but different execution paths may have different runtime traces. Thus, the real target functions within the unexecuted paths will be omitted. However, we find that all target functions in the captured runtime traces are extracted by our strategy.</p><p>Reviewing the result, we also find an interesting phenomenon. Most target functions are in the initialization procedure. The data in the parenthesis of the fourth column show the numbers of these functions. They occupy 86% of all target functions. Namely, most kinds of occasional errors in drivers occur in the initialization procedure. In fact, it has been noted in the Linux driver manual <ref type="bibr" target="#b8">[9]</ref>, and our results can successfully verify it. The explanation for this phenomenon is that different kinds of configurations need to be made in the initialization, and each configuration can cause a kind of occasional error. After the driver is initialized, only several kinds of errors can occur in the running procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Bug Detection</head><p>With the extracted target functions, we perform runtime testing to detect bugs in error handling code. Each test case is generated by making one target function fail. To validate whether EH-Test can find the known bugs having been fixed, we first use EH-Test to test the 15 drivers in an older Linux version 3.1.1 (released in November 2011). Then we test these drivers in a newer Linux version 3.17.2 (released in October 2014) to validate whether EH-Test can find new bugs. <ref type="table" target="#tab_15">Table 7</ref> shows the result. The first column shows the driver name; the second and seventh columns ("Test case") show the number of generated test cases; the third and eighth columns ("Time usage") present the time usage of the runtime testing; the fourth and ninth columns ("Crash / Hang") show the number of detected crashes and hangs; the fifth and tenth columns ("Resource") present the number of detected resource-release omissions; the sixth and eleventh columns ("Bugs") show the number of detected bugs. Specifically, the number of memory leaks is shown in the parenthesis of the fifth and tenth columns ("Resource"), because the memory leak is an important kind of resource-release omission.</p><p>From <ref type="table" target="#tab_15">Table 7</ref>, we make the following observations: Firstly, EH-Test finds 32 bugs in the 15 drivers in Linux 3.1.1, including 10 crashes and 22 resourcerelease omissions. Among these resource-release omissions, 10 are memory leaks. Reviewing the driver code, 8 resource-release omissions (sky2 driver) and 1 crash (rt2800 driver) have been fixed in Linux 3.17.2. It indicates that EH-Test can find the known bugs.</p><p>Secondly, EH-Test finds 50 bugs in the 15 drivers in Linux 3.17.2, including 13 crashes, 1 hang and 36 resource-release omissions. Among the resource-release omissions, 29 are memory leaks. Moreover, 23 bugs are reserved from the legacy code in 3.1.1, and 27 bugs are introduced due to new implementations. We send all the bugs to the driver developers, and all of them have been confirmed. We also send 17 patches 3 to fix them, and 15 have been applied by the maintainers. It indicates that EH-Test can accurately find new bugs in drivers.</p><p>Actually, a threat to validity is that false extracted target functions may introduce false bugs. In our evaluation, no false bugs are detected for this reason.</p><p>Thirdly, the time usage of EH-Test is short. About 2 hours are spent in totally testing the 15 drivers, and only several minutes are spent for most drivers. This time usage is shorter than many previous SFI approaches <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b22">23]</ref> for testing drivers. One reason is that EH-Test uses the pattern-based extraction strategy to filter out many unrepresentative candidate functions, so no redundant test cases are generated. Thus, the test cases are efficient, and the testing time is largely shortened.  <ref type="figure">Figure 6</ref>: Code coverage of the tested drivers.</p><p>Fourthly, resource-release omissions occupy a large part of detected bugs. The main reason is that resourcerelease omissions often get little attention by developers. The complex execution paths make it difficult to correctly manage resources in error handling code. Meanwhile, resource-release omissions rarely lead to obvious exceptions, so they are hard-to-find in runtime testing. <ref type="figure" target="#fig_4">Figure 5</ref> shows a crash detected by EH-Test in the e100 driver. The function pci_pool_create (line 2967) is called to create a pool of consistent memory blocks for the PCI device, and this function returns a pointer (nic-&gt;cbs_pool) to this memory area. But the function pci_pool_create may fail when the memory is insufficient, and it will return a null pointer in this situation. Thus, a null pointer dereference will occur, when the function pci_pool_alloc (line 1910) uses this pointer to allocate a memory block. This crash is detected when we inject a fault in the function pci_pool_create. This function is extracted as a target function in our patternbased extraction strategy, because many other drivers check its return value in the code (pattern 2 in Section 4). To fix this bug, we add an if check after the function pci_pool_create (line 2967) to check its return value and implement the corresponding error handling code. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Code Coverage</head><p>Code coverage is a key criterion in runtime testing. To calculate code coverage, we use the inserted probes to count executed instructions at runtime. Because most target functions are in the initialization procedure, we focus on measuring the code coverage in this procedure. <ref type="figure">Figure 6</ref> shows the results in Linux 3.17.2. The average code coverage of EH-Test is increased by 8.82% compared to the normal execution. It indicates that hundreds of more instructions are executed in runtime testing.</p><p>In fact, not all error handling code can be covered by EH-Test. Firstly, EH-Test only injects faults in target functions, but some error handling code is triggered by erroneous data read from hardware registers. Secondly, our approach injects a single fault in each test case, but some error handling code is triggered by multiple errors. Thirdly, target functions in unexecuted paths are not extracted in our pattern-based strategy, so their error handling code can not be covered. These points cause that the bugs in the uncovered code will be missed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Comparison Experiments</head><p>Software fault injection and symbolic execution are two runtime techniques which are often used to test drivers. Software Fault Injection. We compare EH-Test to ADFI <ref type="bibr" target="#b6">[7]</ref>, a state-of-the-art SFI approach for testing drivers. It uses a bounded trace-based iterative strategy to relieve fault scenario explosion and a permutationbased replay mechanism to assure the fidelity of fault injection. Similar to EH-Test, it injects faults in some target functions and generates test cases to detect bugs. But there are two main differences between ADFI and EH-Test. Firstly, the target functions in ADFI are all manually selected. Only memory, DMA and PCI related interfaces are considered. Thus, much manual work is needed, and many real target functions may be omitted. EH-Test can automatically and accurately extract all target functions in the captured runtime traces without omissions, and the only optional manual work is checking the extracted target functions. Secondly, ADFI injects multiple faults in each test case. The advantage is that much more configuration and error handling code can be covered to detect more bugs. But numerous test cases are generated, so it spends much more time (often several hours) than EH-Test when testing a driver.</p><p>ADFI program and its detailed bug reports are not available, thus we compare the number of its detected bugs from the paper. ADFI and EH-Test both test three drivers with the same workload. For the e100 and r8169 drivers, they both find the same number of bugs. For the ehci_hcd driver, EH-Test finds 10 bugs, but ADFI does not find any bug in this driver. Reviewing the code, we find that these bugs are triggered by the target functions which are not memory, DMA or PCI related functions, so ADFI omits them. Symbolic Execution. We select SymDrive <ref type="bibr" target="#b27">[28]</ref>, a famous symbolic execution approach to make the comparison. This approach uses a symbolic device and some checkers to detect bugs, including memory leaks and null pointer dereferences.</p><p>SymDrive program is open-source, and we successfully run it to test the e100 driver. It runs for nearly 80 minutes and searches 4838 paths, finally exits due to insufficient disk space. In the experiment, SymDrive does not find the bug shown in <ref type="figure" target="#fig_4">Figure 5</ref>. The reason is that the return value of the function pci_pool_create is not marked as a symbolic value in SymDrive, so the corresponding error handling path is not searched. Besides, SymDrive can only test the drivers whose devices are supported by QEMU <ref type="bibr" target="#b3">[4]</ref>. But many devices are not supported by the QEMU used in SymDrive, so the drivers for these devices can not be directly tested. The sky2 and iwl4965 drivers are the typical examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related Work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Software Fault Injection</head><p>In software testing, software fault injection is a technique for testing rarely executed code by deliberately injecting faults. In particular, it is often used to test error handling code in software systems.</p><p>Many approaches <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22]</ref> use random fault injection in software testing. They replace the program data with random faulty data or inject faults into random places, and then run test cases to validate whether the software can properly handle the faults. But random fault injection often leads to poor code coverage and low bug-detection accuracy. To relieve this problem, some approaches <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b38">39]</ref> use program information to guide fault injection and generate efficient test cases. Moreover, to improve the representativeness of injected faults, much research <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b24">25]</ref> gives useful solutions through empirical studies. In fact, these approaches are often used for general software, especially usermode applications. They often neglect the characteristics of device drivers, so their effectiveness may be largely limited when directly testing device drivers.</p><p>Besides user-mode applications, SFI is also carefully designed to test drivers <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b34">35]</ref>. Mendonca et al. <ref type="bibr" target="#b22">[23]</ref> perform robustness testing for Windows drivers based on random fault injection. Frequently used kernel interfaces in drivers are called with random parameters. ADFI <ref type="bibr" target="#b6">[7]</ref> uses a bounded trace-based iterative strategy to relieve fault scenario explosion and a permutation-based replay mechanism to assure the fidelity of fault injection. But these approaches still have limitations when testing device drivers. A typical limitation is that they often neglect the representativeness of injected faults, and their injected faults are often random or manually selected. To relieve this limitation, EH-Test uses a pattern-based extraction strategy to automatically and accurately extract real target functions as representative injected faults.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Symbolic Execution</head><p>Some approaches <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b27">28]</ref> introduce symbolic execution in driver testing without the real hardware. DDT <ref type="bibr" target="#b15">[16]</ref> is a tool for testing binary drivers against undesired behaviors, such as resource leaks and race conditions. It combines virtualization with selective symbolic execution to test drivers using some modular dynamic checkers. SymDrive <ref type="bibr" target="#b27">[28]</ref> provides a symbolic device based on QEMU <ref type="bibr" target="#b3">[4]</ref> to simulate real hardware behaviors. It utilizes a favor-success path-selection algorithm in execution, which can increase the exploration priority of executing path at every successful function return within drivers and kernel interfaces. Some checkers are provided to detect common bugs like memory leaks.</p><p>Symbolic execution is very time consuming, and it needs much programmer guidance to avoid path explosion. Moreover, many devices can not be simulated well in virtual machines, so their drivers can not be directly tested using symbolic execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Static Analysis</head><p>Static analysis is often used to detect bugs in device drivers. It only analyzes the driver source code or binary code without actually running target drivers. Some approaches <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b39">41,</ref><ref type="bibr" target="#b40">42]</ref> are based on program verification. For example, SDV <ref type="bibr" target="#b1">[2]</ref> is a famous static tool to verify Windows drivers. It abstracts the C source code to a simpler form encoded as a state machine, and checks violations of kernel API usage rules. Some approaches <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b30">31]</ref> mine implicit specifications from the driver code and detect related bugs. For example, PR-Miner <ref type="bibr" target="#b18">[19]</ref> exploits data mining techniques to automatically extract implicit programming rules from software code and detect violations against these extracted rules.</p><p>Compared to runtime testing, static analysis lacks precise context information of real execution, so some false positives may be introduced in bug detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion</head><p>In this paper, we first study the source code of Linux drivers, and find three useful characteristics of error handling code. Then based on these characteristics, we propose a practical approach named EH-Test to efficiently test error handling code and detect bugs inside. It uses a pattern-based extraction strategy to automatically and accurately extract real target functions as representative injected faults. It has been evaluated on 15 Linux drivers and found 50 new real bugs. Our work shows that by introducing the characteristics of target programs, software testing can be more effective.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>1</head><label>1</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Part of the bnx2 driver code in Linux 3.1.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Procedure of extracting target functions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: A detected bug in the e100 driver 4 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>scalability. Most working procedure of EH-Test is automated, including target- function extraction, fault injection and test-case execu- tion. And it can support many kinds of existing drivers. In this paper, we make the following contributions:</head><label></label><figDesc></figDesc><table>EH-Test program can be downloaded from the link: 
http://oslab.cs.tsinghua.edu.cn/EHTest/index.html 

4) High automation and  We study the source code of Linux device drivers, 
and find three useful characteristics in error han-
dling code. 

 Based on the patterns of error handling code in 
drivers, we design a pattern-based extraction strate-
gy to automatically and accurately real target func-
tions as representative injected faults. 

 Based on the characteristics, we design a practical 
approach named EH-Test, which can efficiently test 
error handling code in device drivers and detect 
bugs inside. 

 We evaluate EH-Test on 15 device drivers in Linux 
3.1.1 and 3.17.2, and respectively find 32 and 50 
bugs. All the detected bugs in 3.17.2 have been 
confirmed by developers. The code coverage is also 
effectively increased in runtime testing. We also 
perform comparison experiments to previous ap-
proaches, and find that EH-Test can detect the bugs 
which are missed by them. The experimental results 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>1. The function bnx2_init_board calls pci_request_regions (line 7906) to request PCI I/O and memory resources when initializing the hardware. If anoccurs when mapping bus memory into CPU, the function ioremap_nocache (line 7937) will fail and return NULL. In this situation, the driver calls pci_release_regions (line 8248) to release allocated resources in error handling code. Reviewing the code, the function kzalloc (line 7885) is called to</head><label></label><figDesc>shows a part of its source code in Linux 3.1.</figDesc><table>Path: linux-3.1.1/drivers/net/bnx2.c 

7869. static int __devinit bnx2_init_board(….) 
7870. { 
…… 

7885. 
bp-&gt;temp_stats_blk = kzalloc(…); 
…… 

7906. 
rc = pci_request_regions(pdev, …); 
…… 

7937. 
bp-&gt;regview = ioremap_nocache(…); 
7938. 
if (!bp-&gt;regview) { 
7939. 
dev_err("Cannot map register space, aborting\n"); 
7940. 
rx = -ENOMEM; 
7940. 

goto err_out_release; 
7941. 
} 
…… 

8247. err_out_release: 
8248. pci_release_regions(pdev); 
8249. err_out_disable: 
8250. 
pci_disable_device(pdev); 
8251. 
pci_set_drvdata(pdev, NULL); 
8252. err_out: 
8253. 
return rc; 
8254. } 

occasional error allocate 
kernel-space memory. But this memory is not freed in 
error handling code, so a memory leak occurs. In fact, 
this bug still remains in Linux 3.17.2. 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Study result of "goto" statements. 

Driver Class Number 
Error handling Without Branch 

Wireless 
116 
3903 
3111 (79.71%) 
Ethernet 
219 
2587 
1941 (75.03%) 
Block 
56 
149 
127 (85.23%) 
Bluetooth 
21 
330 
239 (72.42%) 
Clock 
117 
467 
422 (90.36%) 
PCI 
51 
470 
371 (78.94%) 
USB 
268 
701 
493 (70.32%) 
Total 
848 
8607 
6704 (77.89%) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table 3 : Study result of branches in error handling code.</head><label>3</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>EH - Test</head><label>-</label><figDesc></figDesc><table>Fault 
Extractor 

Fault-injected 
Functions 

OS source code 

+ 
+ 

Target 
Driver 

Other 
Drivers 
Interface 
Functions 

Fault 
Injector 

Test Cases 

Probe 
Inserter 
Runtime 
Monitor 
Pair Checkers 

Bug Reports 

Figure 3: Overall architecture of EH-Test. 

Firstly, we run the driver normally on the hardware, and 
record the runtime traces during normal execution. All 
functions whose return values are pointers and integers 
are selected from the recorded runtime traces. These 
functions are regarded as candidate functions for fault 
injection. Secondly, for each candidate function, we 
judge whether it can trigger a realistic error. According 
to the code patterns of Linux device drivers, a candidate 
function can be regarded as a real target function under 
three patterns. 
Pattern 1. The return value of the candidate function is 
checked by an if statement in the driver. Because an if 
check is often used to decide whether error handling 
code should be triggered (in Section 3.3). In most cases, 
this if check is often closely behind the function call. 
Pattern 2. The return value of the candidate function is 
checked in other drivers. In some cases, the developer 
may forget to check the return value of a certain func-
tion in the driver. But this function's bad return value 
can be deemed to trigger a realistic error, when it is 
checked by an if statement in other drivers. 
Pattern 3. </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>Para1 pci_enable_device Initialize / disable the device on the PCI bus Para1 pci_disable_device Para1 dma_pool_alloc Allocate / free a block of con- sistent memory for DMA RetVal dma_pool_free Para1</head><label></label><figDesc></figDesc><table>Names 
Description 
Data 

request_irq 
Enable / disable the interrupt 
line and IRQ handling 

Para1 

free_irq 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="true"><head>Table 5 shows</head><label>5</label><figDesc>the basic information of tested drivers in Linux 3.17.2.</figDesc><table>Class 
Driver 
Hardware 
Lines 

Wireless 

rtl8180 
Realtek RTL8180L Wireless Controller 
4.6K 

b43 
Broadcom BCM4322 Wireless Controller 57.5K 

iwl4965 
Intel 4965AGN Wireless Controller 
29.1K 

rt2800 
Ralink RT3060 Wireless Controller 
22.5K 

USB 

usb_storage Kingston 4GB USB disk 
7.6K 

uhci_hcd 
Intel USB UHCI Controller 
7.2K 

ehci_hcd 
Intel USB2 EHCI Controller 
11.2K 

Ethernet 

e100 
Intel 82559 Ethernet Controller 
3.2K 

e1000e 
Intel 82572EI Ethernet Controller 
28.3K 

igb 
Intel 82575EB Ethernet Controller 
24.9K 

r8169 
Realtek RTL8169 Ethernet Controller 
7.4K 

8139too 
Realtek RTL8139D Ethernet Controller 
2.7K 

3c59x 
3Com 3c905B Ethernet Controller 
3.4K 

sky2 
Marvell 88E8056 Ethernet Controller 
7.7K 

ipg 
ICPlus IP1000 Ethernet Controller 
3.0K 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>Table 5 :</head><label>5</label><figDesc></figDesc><table>Tested drivers in Linux 3.17.2. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13" validated="false"><head>Table 6 :</head><label>6</label><figDesc></figDesc><table>Result of the pattern-based extraction. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15" validated="false"><head>Table 7 : Bug-detection result of EH-Test.</head><label>7</label><figDesc></figDesc><table></table></figure>

			<note place="foot" n="2"> Patchwork project. http://patchwork.ozlabs.org/</note>

			<note place="foot" n="3"> The patches can be found in the link: http://oslab.cs.tsinghua.edu.cn/EHTest/patch.html</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Acknowledgments</head><p>We would like to express our gratitude to our shepherd Jon Howell and other reviewers for their helpful comments and suggestions. We also thank the Linux driver developers for their useful feedbacks. This work is supported by Research Grant of Beijing Higher Institution Engineering Research Center and Tsinghua University Initiative Scientific Research Program (2014z09102). Shi-Min Hu is the corresponding author of this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Static analysis of device drivers: we can do better</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Amani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ryzhyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">F</forename><surname>Donaldson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Legg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd Asia-Pacific Workshop on Systems</title>
		<meeting>the 2nd Asia-Pacific Workshop on Systems</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Thorough static analysis of device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bounimova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lichtenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mcgarvey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ondrusek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ustuner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st European Conference on Computer Systems</title>
		<meeting>the 1st European Conference on Computer Systems</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="75" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fast black-box testing of system recovery code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Banabic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th European conference on Computer Systems</title>
		<meeting>the 7th European conference on Computer Systems</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="281" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">QEMU, a fast and portable dynamic translator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Bellard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 USENIX Annual Technical Conference</title>
		<meeting>the 2005 USENIX Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="41" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">S2E: a platform for in-vivo multi-path analysis of software systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Chipounov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the 16th International Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="265" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A tool for checking ANSI-C programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lerda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Conference on Tools and Algorithms for the Construction and Analysis of Systems</title>
		<meeting>the 10th International Conference on Tools and Algorithms for the Construction and Analysis of Systems</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="168" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automatic fault injection for driver robustness testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 International Symposium on Software Testing and Analysis</title>
		<meeting>the 2015 International Symposium on Software Testing and Analysis</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="361" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Symbolic execution of virtual devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Quality Software</title>
		<meeting>the 13th International Conference on Quality Software</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Corbet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rubini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">K</forename><surname>Hartman</surname></persName>
		</author>
		<title level="m">Linux Device Drivers</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="32" to="35" />
		</imprint>
	</monogr>
	<note>3rd ed. O&apos;Reilly Media</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Emulation of software faults: a field data study and a practical approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Duraes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S</forename><surname>Madeira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Software Engineering</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="849" to="867" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Testing of java web services for robustness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">G</forename><surname>Ryder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Milanova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wonnacott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 International Symposium on Software Testing and Analysis</title>
		<meeting>the 2004 International Symposium on Software Testing and Analysis</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="23" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">EDFI: a dependable fault injection tool for dependability benchmarking experiments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Giuffrida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kuijsten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename><surname>Tanenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th Pacific Rim Symposium on Dependable Computing</title>
		<meeting>the 19th Pacific Rim Symposium on Dependable Computing</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On the selection of error model(s) for OS robustness evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Suri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Murphy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th International Conference on Dependable Systems and Networks</title>
		<meeting>the 37th International Conference on Dependable Systems and Networks</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="502" to="511" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">PREFAIL: a programmable tool for multiple-failure injection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S</forename><surname>Gunawi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 International Conference on Object Oriented Programming Systems Languages and Applications</title>
		<meeting>the 2011 International Conference on Object Oriented Programming Systems Languages and Applications</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="171" to="188" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Do injected faults cause real failures? A case study of Linux</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kikuchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Yoshimura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sakuma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kono</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 International Symposium on Software Reliability Engineering Workshops</title>
		<meeting>the 2014 International Symposium on Software Reliability Engineering Workshops</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Testing closed-source binary device drivers with DDT</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Chipounov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 USENIX Annual Technical Conference</title>
		<meeting>the 2010 USENIX Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An empirical study of injected versus actual interface errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lanzaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Natella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Winter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cotroneo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Suri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 International Symposium on Software Testing and Analysis</title>
		<meeting>the 2014 International Symposium on Software Testing and Analysis</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="397" to="408" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">WYSIWIB: a declarative approach to finding API protocols and bugs in Linux code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Brunel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Palix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Stuart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th International Conference on Dependable Systems and Networks</title>
		<meeting>the 39th International Conference on Dependable Systems and Networks</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="43" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">PR-Miner: automatically extracting implicit programming rules and detecting violations in large software code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Symposium on Foundations of Software Engineering</title>
		<meeting>the 13th International Symposium on Foundations of Software Engineering</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="306" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">PF-Miner: a new paired functions mining method for Android kernel in error paths</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th International Computer Software and Applications Conference</title>
		<meeting>the 38th International Computer Software and Applications Conference</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="33" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">LFI: a practical and general library-level fault injector</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">D</forename><surname>Marinescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th International Conference on Dependable Systems and Networks</title>
		<meeting>the 39th International Conference on Dependable Systems and Networks</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="379" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient testing of recovery code using fault injection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">D</forename><surname>Marinescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Robustness testing of the Windows DDK</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mendonca</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Neves</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th International Conference on Dependable Systems and Networks</title>
		<meeting>the 37th International Conference on Dependable Systems and Networks</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="554" to="564" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">On fault representativeness of software fault injection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Natella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cotroneo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Duraes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S</forename><surname>Maderia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Transactions on Software Engineering</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="80" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Representativeness analysis of injected software faults in complex software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Natella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cotroneo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Duraes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Maderia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th International Conference on Dependable Systems and Networks</title>
		<meeting>the 40th International Conference on Dependable Systems and Networks</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="437" to="446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">STANSE: bugfinding framework for C programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Obdrzalek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Slaby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Trtik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematical and Engineering Methods in Computer Science</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">7119</biblScope>
			<biblScope unit="page" from="167" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Integrated static analysis for Linux device driver verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Post</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Kuchlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on Integrated Formal Methods</title>
		<meeting>the 6th International Conference on Integrated Formal Methods</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="518" to="537" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">SymDrive: testing drivers without devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Renzelmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kadav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Conference on Operating Systems Design and Implementation</title>
		<meeting>the 10th International Conference on Operating Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="279" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Runtime verification of Linux kernel modules based on call interception</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">V</forename><surname>Rubanov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Shatokhin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Conference on Software Testing, Verification and Validation</title>
		<meeting>the 4th International Conference on Software Testing, Verification and Validation</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="180" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">An approach to improving the structure of error-handling code in the Linux kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 International Conference on Languages, Compilers and Tools for Embedded Systems</title>
		<meeting>the 2011 International Conference on Languages, Compilers and Tools for Embedded Systems</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="41" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Hector: detecting resource-release omission faults in error-handling code for systems software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Lozi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd International Conference on Dependable Systems and Networks</title>
		<meeting>the 43rd International Conference on Dependable Systems and Networks</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Device driver fault simulation using KEDR</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename><surname>Shekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Meshram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Varshapriya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Journal of Advanced Research in Computer Engineering and Technology</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="580" to="584" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Recovering device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Annamalai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">M</forename><surname>Leny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="333" to="360" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Improving the reliability of commodity operating systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th ACM Symposium on Operating Systems Principles</title>
		<meeting>the 19th ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="207" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">simFI: From single to simultaneous software fault injections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Winter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tretter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Sattler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Suri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd International Conference on Dependable Systems and Networks</title>
		<meeting>the 43rd International Conference on Dependable Systems and Networks</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Model checking concurrent linux device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Witkowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Blanc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Weissenbacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Conference on Automated Software Engineering</title>
		<meeting>the 22nd International Conference on Automated Software Engineering</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="501" to="504" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Iterative mining of resource-releasing specifications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Mei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Conference on Automated Software Engineering</title>
		<meeting>the 26th International Conference on Automated Software Engineering</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="233" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Perracotta: mining temporal API rules from imperfect traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bhardwaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Bhat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Conference on Software Engineering</title>
		<meeting>the 28th International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="282" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Amplifying tests to validate exception handling code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Elbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th International Conference on Software Engineering</title>
		<meeting>the 34th International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="595" to="605" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clang</forename><surname>Static</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Analyzer</forename></persName>
		</author>
		<ptr target="http://clang-analyzer.llvm.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Cppcheck: A tool for static C/C++ code analysis</title>
		<ptr target="http://cppcheck.sourceforge.net/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
				<ptr target="http://www.kernel.org/doc/Documentation/fault-injection/fault-injection.txt" />
		<title level="m">Linux Fault Injection Capabilities Infrastructure</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
				<ptr target="http://www.kernel.org/doc/Documentation/CodingStyle" />
		<title level="m">Linux Kernel Coding Style</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
