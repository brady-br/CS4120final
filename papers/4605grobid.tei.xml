<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:26+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sean</forename><surname>Heelan</surname></persName>
							<email>sean.heelan@gmail.com</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">SMT Solvers for Software Security Julien Vanegue</orgName>
								<orgName type="department" key="dep2">Immunity Inc</orgName>
								<orgName type="institution">Microsoft Security Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rolf</forename><surname>Rolles</surname></persName>
							<email>rolf.rolles@gmail.comunaffiliated</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">SMT Solvers for Software Security Julien Vanegue</orgName>
								<orgName type="department" key="dep2">Immunity Inc</orgName>
								<orgName type="institution">Microsoft Security Science</orgName>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Computational capacity of modern hardware and algo-rithmic advances have allowed SAT solving to become a tractable technique to rely on for the decision of properties in industrial software. In this article, we present three practical applications of SAT to software security in static vulnerability checking, exploit generation, and the study of copy protections. These areas are some of the most active in terms of both theoretical research and practical solutions. Investigating the successes and failures of approaches to these problems is instructive in providing guidance for future work on the problems themselves as well as other SMT-based systems.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Satisfiability (SAT) is a decidable computational problem with the following structure: given a boolean formula, is there a valuation of the variables for which the formula is true? If such a valuation exists, the formula is said to be satisfiable. If there is no such valuation, the formula is said to be unsatisfiable. The complexity of SAT is NP complete which means that there is no efficient algorithm to resolve all instances of the problem. Therefore, a variety of heuristics are used to lower the execution time of decision procedures in practice. Yet, the SAT problem is the object of active research as more optimized strategies are crafted and larger scale experiments with conclusive results are performed every year. More recently SAT solvers have become the driving engines behind a more expressive approach to constraint specification and solving. The Satisfiability Modulo Theories (SMT) problem extends the SAT problem with support for higher level theories, such as bitvector arithmetic among others, and relational operators, such as equality. Due to these higher level concepts, SMT allows for a more natural modeling of the semantics of code and as such is typically used instead of SAT in reasoning about properties of software applications. In this paper, we study the practical use of SMT solvers as black box oracles to answer questions that encode the essence of problems of static vulnerability checking, exploit generation, and analysis of copy protection. We show that SMT solvers are convenient tools to decide many important security queries about programs. Nonetheless, a key point throughout is the separation of concerns between constraint generation and constraint solving. A solver is not in charge of the constraint generation step but a failure to generate constraints that accurately model properties of the system under inspection limits the relevance of the answers a solver can provide. The constraint generation step is known as the inference problem. Inference consists of automatically generating constraints from inspection of the analyzed program. Those constraints are passed to the SMT solver for resolution. Constraint generation and solving been studied in functional programming and compilers <ref type="bibr" target="#b28">[28]</ref> but less so in applications related to software security <ref type="bibr" target="#b8">[9]</ref>. While one might expect resolution to be the bottleneck in systems based on SMT solvers, we will later discuss how, in many instances, the problem of constraint generation is currently the main limiting factor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Vulnerability checking</head><p>The last decade has seen some success in deploying program verification tools to industrial software. The main techniques for program verification are theorem proving <ref type="bibr" target="#b2">[3]</ref>, abstract interpretation <ref type="bibr" target="#b12">[12]</ref> and model checking <ref type="bibr" target="#b10">[11]</ref>. In this article, we focus on security vulnerability checking based on theorem proving for imperative programs written in C language using the HAVOC <ref type="bibr" target="#b21">[21]</ref> tool. Theorem proving is a mature technique that has been applied to verify call-free, loop-free programs and large hardware systems <ref type="bibr" target="#b22">[22]</ref>. Applications of theorem proving to software is more recent thanks to global analysis techniques such as Predicate abstraction <ref type="bibr" target="#b3">[4]</ref>. Predicate Abstraction is a potentially diverging but automated technique to infer constraints at procedure and loop boundaries. Software model-checking tools based on predicate abstraction (such as SLAM <ref type="bibr" target="#b3">[4]</ref>) have brought considerable value for automated analysis of software by uncovering hundreds of software bugs in mediumsized drivers. To address the scalability issues arising from the state space explosion problem induced by model checking, the Houdini algorithm <ref type="bibr" target="#b17">[17]</ref> has been devised to answer the problem of monomial predicate abstraction. Houdini is a simple yet powerful technique based on candidate contracts (or may be constraints) allowing the user to provide simple constraints templates and using the constraint solver in a fixed-point algorithm to determine whether or not those constraints always hold at function or loop boundaries. Houdini is implemented in the Boogie verification framework <ref type="bibr" target="#b24">[24]</ref> for which HAVOC is a front-end. While Houdini is a terminating and deterministic algorithm, it is unable to answer existential queries, as candidate constraints are only persisted when they hold in every function contexts. Thus, Houdini cannot be used to answer the following question: is it feasible for parameter p to hold value v in some context? . On the other hand, it can answer questions such as: is it provable that parameter p always has value v?. Section 2 illustrates the inference problem on C programs using a simple yet non-trivial loop program based on a Sendmail vulnerability <ref type="bibr" target="#b33">[33]</ref> for which the SMT solver does an excellent job at deciding satisfiability of a set of constraints at given program points, but does not provide a mechanism to synthesize the required constraints automatically. While Houdini is able to reason about candidate loop invariants, automatically inferring such complex invariants is out of reach. As such, the constraints fed to the solver are often provided by an expert analyst or generated using limited strategies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Exploit generation</head><p>Exploit generation is a more recent field of study than vulnerability checking. Work so far has primarily fallen into two categories -attempts at automated generation of inputs aimed at hijacking the control flow of a system <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b0">1]</ref> and attempts at automating the generation of malicious payloads <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b34">34,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b32">32]</ref>. Work in the former category has relied on symbolic/concolic execution systems <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b4">5]</ref> to perform constraint generation. Such systems track the semantic relationship and constraints between symbolic input data and all other bytes in program memory and CPU registers. Using this information it is then possible to generate SMT formulae that ask questions about the potential values of such bytes. Exploit generation systems have utilized this ability to check if data that correspond to potentially sensitive pointers can be controlled by an attacker. So far the problems tackled in this area have been simplified scenarios where commonplace operating system security measures and binary hardening techniques are disabled. The reasons these limitations have been necessary will be discussed in section 3.1.</p><p>The research performed on generation of malicious payloads has had more success at solving real world problem instances. For the purposes of this article we define the payload of an exploit to be code executed once the control flow of an application has been hijacked. The payloads generated as part of exploitation research have so far been sequences of return-oriented programming (ROP) gadgets. A gadget is a sequence of instructions, within a shared library or executable in the target program, that performs some useful computation and ends by transferring control flow to the next gadget in the sequence. A collection of such gadgets is usually chained together to accomplish a specific task, such as changing permissions of a memory segment, copying in a second stage payload and then executing that second stage. This approach to executing malicious code is necessary to deal with protection mechanisms that prevent one from executing code that has been placed on the stack or heap. By instead executing sequences of instructions within the program's code this mechanism can be avoided and sometimes disabled entirely.</p><p>SMT solvers have been used as the reasoning component of systems that prove functional equivalence between a desired computation and a sequence of instructions <ref type="bibr" target="#b34">[34]</ref>. They have also formed part of end-to-end ROP compilers <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b32">32]</ref> that attempt to automatically chain together sequences of such gadgets so that the sequence is semantically equivalent to a model payload. These systems usually incorporate a SMT solver as a small part of an larger set of algorithms. Section 3.2 discusses both approaches and their integration of SMT solvers. As with many other successful applications of SMT solvers, there is a focus on reducing the number of queries that most be made and pre-processing the input to a solver through other algorithms in order to reduce the complexity of each query.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Copy protection analysis</head><p>In the domain of copy protections, we consider the two problems of equivalence checking of obfuscated programs and automated cryptanalysis. We find, similarly to the aforementioned domains of vulnerability check-ing and exploit generation, that the main issue that is faced is not so much feeding a constraint system into an SMT solver, but rather, how to generate the constraint system from the program (and which constraint system to generate) in the first place. For our application of equivalence checking to verify the proper working of a deobfuscator for a virtualization obfuscator, the use of an SMT solver is easily feasible. If we wish to apply the same methodology to simply verifying that a virtualized program is equivalent to its original version, we run into issues surrounding input-dependent branches in the obfuscated version. For our application of automated cryptanalysis, problems exist surrounding how properly to model code with input-dependent branches, particularly input-dependent loops over unbounded quantities. Other program-analytic techniques such as invariant inference can furnish solutions to these problems, but they fall under the inference phase and are orthogonal to the actual solving of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">SMT in vulnerability checking</head><p>In this section, we use a verification tool HAVOC <ref type="bibr" target="#b21">[21]</ref> (a heap-aware verifier for C and C++ programs) to translate to an intermediate form Boogie <ref type="bibr" target="#b24">[24]</ref> which then calls SMT solver Z3 <ref type="bibr" target="#b26">[26]</ref> to decide a vulnerable program from a non-vulnerable one. For conciseness, we do not make explicit the step of transforming the source code into an intermediate representation (IR) and go straight to the construction of the formula. The Boogie IR is based on the Static Single Assignment form (SSA <ref type="bibr" target="#b13">[13]</ref>) which makes it easier to construct the final formula passed to the solver. We use the code snippet <ref type="bibr" target="#b15">[15]</ref> in <ref type="figure" target="#fig_0">Figure 1</ref>, a simplified version of the Sendmail crackaddr vulnerability <ref type="bibr" target="#b33">[33]</ref> published by Mark Dowd in 2003. This example contains a non-trivial loop program parsing an untrusted string parameter.</p><p>A buffer overflow vulnerability exists at line 36 due to a missing decrement of the ulimit variable. The correct fix for this loop is to enable such decrement at line 28. At first sight, this loop seems rather complex to verify. A few key remarks about the structure of the loop are fundamental in understanding the behavior of this function. First, the function contains two state variables quotation and rquote corresponding to the value of the currently processed character as pointed by variable c . The two state variables hold value False at the initial state of the loop. Only a small number of combinations of state values are possible due to the fact that the inner conditionals in the loop are mutually exclusive, since the value of variable c does not change within the same iteration of the loop. The second fundamental remark on this loop is about the ulimit variable. The initial value of this variable as assigned on line 7 is pointing on offset 15 of the local buffer (since BUFFERSIZE equals 25). Depending on the processed input string, this value can either be incremented or decremented. It is possible to model the expected behavior of the loop using a finite state automata corresponding to the expected and valid results of its computations (with line 28 enabled). Here, we model the state of the loop as a triple of type (bool,bool,int) corresponding to the value of variables quotation, rquote and the value of upperlimit -lbuf as shown in <ref type="figure" target="#fig_0">Figure 1</ref>.</p><p>Note that upperlimit is a pointer variable and not an integer offset, thus the numerical value in the third component of the triple should in fact be read lbuf + num where num is the relative offset from the beginning <ref type="figure">Figure 2</ref>: Automaton corresponding to loop in <ref type="figure" target="#fig_0">Fig. 1</ref> of the buffer. We represent this value by only displaying num in the automaton for conciseness. The absence of line 28 in the studied loop introduces a problematic transition in this automata, since the ulimit variable is not bounded anymore. It is then possible to assign a value to ulimit that is big enough to trigger an out of bound write access to the local buffer on line 35. We can formalize a logical representation corresponding to this automata by ignoring transitions and only retaining state values. The automaton then corresponds to the following formula P :</p><formula xml:id="formula_0">(F, F, 15) (T, F, 14) (F, T, 14) (T, T, 13) ′ &lt; ′ ′ &gt; ′ ′ ( ′ ′ ) ′ ′ &lt; ′ ′ &gt; ′</formula><formula xml:id="formula_1">(ulim = lbuf + 15 ∧ quotation = F ∧ rquote = F ) ∨ (ulim = lbuf + 14 ∧ quotation = T ∧ rquote = F ) ∨ (ulim = lbuf + 14 ∧ quotation = F ∧ rquote = T ) ∨ (ulim = lbuf + 13 ∧ quotation = T ∧ rquote = T )</formula><p>The technique used by SMT solvers to verify such invariant is known as proof by induction. In a nutshell, a proof by induction involves two steps:</p><p>1. Prove that the formula holds for the base case (at the entry point of the loop) : P <ref type="formula">(0)</ref> 2. Prove that if the formula holds at iteration n of the loop, then it also holds at the next iteration : ∀n : P (n) ⇒ P (n + 1) P (0) means invariant P holds at the entry state while P(n) means that P holds at the n th iteration. Such formula is indeed inductive and easily solved by a SMT solver. We now give the full version of this proof.</p><p>Proof. The proof involves analysis of all possible loop states and valid transitions between states. It is trivial to notice that the formula indeed holds at the entry point of the loop since the entry state (ulimit = lbuf + 15 ∧ quotation = F ∧ rquote = F) exactly corresponds to the value of the variables at the loop entry. Thus P (0) holds.</p><p>The next step consists of the following: assuming that the loop is in one of the states described by the invariant at the beginning of the iteration, does the loop remain in a state described by the invariant? There are four cases to consider (assuming the loop start in one of the four states) and four sub-cases for each case (assuming we take one of the four available transition, corresponding to one of the four conditionals of the loop). In practice, not all transitions are available from all states. As such, the proof will be smaller than unrolling 16 different cases.</p><p>1. Assume that the loop iteration starts in state (ulimit = lbuf + 15 ∧ quotation = F ∧ rquote = F). Thus, all possible states of the loop are correctly captured by the invariant. In other words, ∀n : P (n) ⇒ P (n + 1)</p><p>On the other hand, the formula is violated when line 28 is absent from the loop. This shows that, when correctly queried, the solver is able to differentiate between a correct program and an invalid program even when subtle conditions are modelled. However, the loop invariant has to be provided manually. To our knowledge, there is no tool available to the public that would be able to infer such conditions automatically. Abstract interpretation techniques <ref type="bibr" target="#b12">[12]</ref> based on control-flow partitioning <ref type="bibr" target="#b25">[25]</ref> have shown to be useful for synthesizing loop invariants but synthesis of such complex invariants seems out of reach due to the over-approximation employed by abstract interpretation to keep full automation. Another strategy to infer simple loop invariants is to generate the candidates using invariant synthesis strategies based on simple grammars. Such approach has been used to perform runtime invariant synthesis and discover likely invariants <ref type="bibr" target="#b27">[27]</ref> in software programs based on witnessed executions. We believe that this latter approach would not bring the desired result on this example since the invariant is not respected in the presence of a security vulnerability and thus would not be discovered by executing the program trace on which the vulnerability is to be found.</p><p>In order to illustrate the inference problem better, let us try to verify a more abstract formula that is a relaxation of the real invariant. Such simpler formula is an interesting candidate invariant for the loop as it contains less sub-formulae and thus is more likely to be generated automatically.</p><formula xml:id="formula_2">(ulim = lbuf + 15 ∧ quotation = F ∧ rquote = F ) ∨(ulim = lbuf + 14 ∧(quotation = T ∨rquote = T )) ∨ (ulim = lbuf + 13 ∧ quotation = T ∧ rquote = T )</formula><p>This second formula corresponds to the automaton in <ref type="figure" target="#fig_2">Figure 3</ref>. We do not indicate the input vocabulary of this second automaton as it does not correspond to a concrete representation of the loop, but a candidate abstraction of it. Unfortunately, this second invariant is not provable due to the introduced spurious state (T,T,14) which is not a real behavior of the loop. When starting the loop in such spurious state and executing the second conditional code of the loop (from line 20 to 24 on <ref type="figure" target="#fig_0">Figure 1</ref>), another spurious state (F,T,15) can be reached. Such state is violating invariant 2. Thus, invariant 2 does not hold at every iteration of the loop. This failed example shows the difficulty of abstracting information from an invariant without losing soundness. The case study of this section illustrate well the limits of SMT solvers in absence of a proper constraint generation engine to feed them. It is possible to verify code invariants as long as those invariants are provided by the developer. Yet, automated analysis of such loop constructs is extremely challenging when no input from the developer is available, since generating the expected contract from a piece of code is not the role of the solver, and existing inference techniques are usually unable to cope with such complex loop invariants. Fortunately, there also exists many other properties <ref type="bibr" target="#b1">[2]</ref> [23] <ref type="bibr" target="#b38">[38]</ref> for which the contracts can be more easily guessed. We will see in the next section that such limitations are not specific to the scenario of vulnerability discovery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SMT in Exploit Generation</head><p>Since 2008 there have been a number of papers <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b0">1]</ref> in which attempts have been made to develop systems for Automatic Exploit Generation (AEG) that rely on an SMT solver for constraint solving. This early work generally took the definition of an exploit to be an input to a program that, through leveraging memory corruption of some kind, results in the hijacking of the program counter and the execution of attacker controlled code. At their core, these systems are extensions of the input generation techniques that have successfully been applied to vulnerability detection <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b6">7]</ref>.</p><p>While they have had limited success in synthesizing exploits for simple vulnerabilities, with relaxed operating system security measures, there is a large theoretical and practical gap still to be bridged before they are applicable to real world problems. In this section we will explain how this gap results from primitive modeling of the problem domain, rather than a limitation of SMT-based technologies. We will also discuss some of the more successful applications of SMT-based technologies to problems found in exploit development.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Restricted-Model Exploit Generation</head><p>Assume that we have a standard symbolic/concolic execution environment, such as S2E <ref type="bibr" target="#b9">[10]</ref>, BAP <ref type="bibr" target="#b4">[5]</ref>, TEMU <ref type="bibr" target="#b35">[35]</ref>, KLEE <ref type="bibr" target="#b6">[7]</ref> or those described elsewhere <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b19">19]</ref>. With any of these systems we can pause symbolic execution and for any memory address or register identifier retrieve the path condition for the data at that location. The path condition pc is a logical formula describing the constraints and manipulations performed on that data between its introduction from an attacker controlled source and the current point of execution. Consider the following sample x86 assembly code, with the assumption that byte in the AL register is under attacker control: 0: add al, al 1: sub al, 0x0f 2: test al, al 3: jz 5 4: ... 5: jmp 7 6: ...</p><p>If we represent the input byte as b 0 , and create a new variable b n on each write to a variable, then at address 6 the path condition for the byte in AL is the following conjunction of clauses</p><formula xml:id="formula_3">b 1 = b 0 + b 0 ∧ b 2 = b 1 − 15 ∧ b 2 = 0</formula><p>whereas at address 4 the path condition is</p><formula xml:id="formula_4">b 1 = b 0 + b 0 ∧ b 2 = b 1 − 15 ∧ b 2 񮽙 = 0</formula><p>One can then use a SMT solver to ask queries about the states represented by these formulae by appending constraints and looking for satisfying assignments. For example, if we wanted to check at address 4 whether the value 11 can be in the AL register we would create the formula:</p><formula xml:id="formula_5">b 1 = b 0 + b 0 ∧ b 2 = b 1 − 15 ∧ b 2 񮽙 = 0 ∧ b 2 = 11</formula><p>An SMT solver will then return a satisfying assignment, if one exists, such as b 0 = 13 in this case.</p><p>Effectively, the sum total of knowledge possessed by the system can be expressed as a map K from a collection of register/memory identifiers (i 0 , i 1 , ..., i n ) to a path condition for each (pc 0 , pc 1 , ..., pc n ). K has type K : I → F . I is the union of the set of register identifiers, one for each register and subregister, with the set of identifiers for all valid memory addresses, one for each address. F is the set of closed quantifier free formulae over the theory of fixed sized bitvectors.</p><p>Exploit generation systems up to now have relied entirely on K in conjunction with a set of ad-hoc exploit templates to extend the work performed for input generation to produce exploits. We will refer to this approach as restricted-model exploit generation. The lack of success of such systems in tackling non-trivial exploits can be directly attributed to the restricted model of the execution environment used. Before discussing why this is, let us first define what we mean by an exploit template and then look at the two typical approaches to AEG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Exploit Templates</head><p>A set of exploit templates T is a collection of algorithmic descriptions of basic strategies for taking advantage of vulnerabilities, that meet a set of criteria, in order to execute malicious code. A template t ∈ T will take as input K and produce a SMT formula f . A satisfying assignment for f will be an exploit for P if the model encoded in f accurately models the constraints imposed on program inputs and any other relevant program state and environment properties. An AEG system will typically include several of these templates and select among them based on information derived from K and other information available about the type of vulnerability. As an example, if the AEG system detects, based on K, that on the execution of a ret instruction the memory pointed to by the ESP register is attacker controlled it would likely select a template that expresses the following constraint:</p><formula xml:id="formula_6">K(m) = v 0 ∧ K(m + 1) = v 1 ∧ K(m + 2) = v 2 ∧ K(m + 3) = v 3</formula><p>where m is the value in the ESP register and</p><formula xml:id="formula_7">(v 0 , v 1 , v 2 , v 3 )</formula><p>are each values in the range 0-255 specifying the address we wish to redirect control flow to.</p><p>Overall the strategies encoded in exploit templates so far have been rudimentary. Due to the fact that the only information source for accurate constraints on the program's state is K, the templates can only generate formulae that ask questions about the possible value ranges of bytes for which we have path conditions. Complex exploit strategies, such as those usually required to deal with modern binary hardening and OS protection mechanisms, require one to reason about a far richer domain than that described by K. For example, the state of the heap and its relationship with user input. Similarly, the exploitation of other vulnerability categories requires further abstractions and models to be introduced into the symbolic/concolic execution phases of AEG. Use-afterfree issues, for example, require both a description of the heap state and also higher level abstractions that entail objects and their allocation status.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">AEG with Restricted Models</head><p>Two similar mechanisms have been used for AEG, both of which can be classed as restricted-model exploit generation. In the first <ref type="bibr" target="#b20">[20]</ref>, we start with a program P and an input I that we know to be bad. For example, I might have been produced by a fuzzer and causes P to crash. Under this approach we execute P (I) within a concolic execution environment up until the point where a crash would occur during normal execution. At this point, K is available and we also have information on the cause of the crash e.g. we know if it was due to an attempt to execute, read or write invalid memory. Such a system will also include a library of exploit templates T as described above. Using K and the knowledge of the cause of the crash, one or more templates can be selected and a set of formulae are generated.</p><p>The second approach integrates the vulnerability checking process with AEG <ref type="bibr" target="#b0">[1]</ref>. Under this approach a symbolic/concolic execution environment is used to execute the program on symbolic input data. A safety predicate φ is invoked at particular program points to check whether a potentially unsafe operation is occurring. For example, on a memcpy call the safety predicate might check that the size argument is sufficiently restricted to prevent an overflow of the destination buffer. Once a safety predicate returns false this approach again has access to K but with the possibility of checking multiple possible exploit scenarios that depend on the value of elements of K.</p><p>For example, on a vulnerable memcpy assume that the destination buffer is n bytes in size but the size parameter can be m bytes, with m &gt; n. Then there are m − n possible lengths that would violate the safety property. Under the first approach a bad input provides a single violation of the safety property. In this case, each different input length n &lt; l ≤ m results in the corruption of a different amount of data. Thus, for each value of l a set of formulae may be generated using K and T . Depending on the value of l the data corrupted could lead to different possibilities for exploitation, e.g. corrupting 4 bytes might lead to control of a pointer used as the destination of a write, while corrupting 12 might lead to control of a function pointer. The second approach can therefore generate more exploit candidates using a wider variety of templates. It is important to note though that each of these candidates is generated using K and T and is thus limited as previously described.</p><p>Conceptually, both of these approaches are quite close to the technology required for vulnerability detection systems based on symbolic/concolic execution. As such it is instructive to ask, Why does this approach succeed for vulnerability detection in real world scenarios but fail for exploit generation in real world scenarios?. The answer can be found by considering the accuracy of the model used in reasoning with respect to the problem being modeled. Successful vulnerability detection systems have found a wealth of vulnerabilities as a result of unsafe arithmetic within programs. The information required to accurately decide whether a sequence of instructions is unsafe or not, in this context, is contained within the path condition for the output bytes. In this case the model K is quite close to an ideal model for deciding questions of the problem domain.</p><p>If we ignore binary hardening, such as stack canaries, and OS security measures, such as address space layout randomization (ASLR), no-execute (NX) permissions on memory regions and more secure memory allocators, then AEG is also a tractable problem using the model K for certain vulnerability classes. In this environment the primary factor impacting the success or failure of an exploit is the manipulations and constraints imposed by the executed instructions. As these factors are modeled by K then it is possible for a template to create a SMT formula that accurately describes the requirements for a working exploit.</p><p>Some AEG systems account for certain protection mechanisms, such as limited ASLR without NX <ref type="bibr" target="#b20">[20]</ref> and NX with limited ASLR <ref type="bibr" target="#b32">[32]</ref>, in conjunction with support for a limited set of vulnerability types, such as stack based overflows without functional stack hardening. The restrictions imposed by these systems on the problems they can handle effectively reduce the state of the exploited programs environment to one that is sufficiently accurately modeled by K.</p><p>The accuracy of K as a model rapidly deteriorates once one begins to consider correctly implemented protection mechanisms as found in modern Linux and Windows operating systems. It also deteriorates once one begins to consider exploitation of vulnerabilities that require the manipulation of environmental factors such as the heap layout. In these scenarios a useful model must account for the effects of user input on the memory layout.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">The Future of AEG</head><p>In order to become a practical solution much work remains to be done in AEG. SMT-backed approaches have shown promise but the constraint generation phase still restricts the applicability of these systems to modern software and operating systems. In particular the model of the program and its environment must be improved.</p><p>Alongside this, it is worth considering the changes that will have to be made to the template driven approach to AEG in order to fit in with the trend towards more application and vulnerability-specific exploitation techniques.</p><p>Closing the gap between the model of a system and the system can be done in two ways. The first is the approach that has been taken so far with AEG, to reduce the complexity of the system until the model is sufficiently accurate. The second is to increase the sophistication of the model so that it entails more information on the system.</p><p>The reason the former approach was taken in the early work on AEG is straightforward; it is relatively cheap to extend previous work on symbolic/concolic execution to produce the model K. It is apparent that this model is an unrealistic abstraction of the state that must be taken into account for modern exploit generation. This can be seen if we consider the lack of any information on the relationship between the program's input and the layout of heap memory. Without such information we cannot generate constraints for which a satisfying assignment can manipulate the heap accurately. As a result, we cannot perform reliable AEG for any vulnerabilities that may be impacted by heap randomisation. This includes heap overflows but also use-after-free vulnerabilities which are the most prolific form of security flaw in web browsers.</p><p>When considering future directions for AEG it is important to look at the latest developments in manual exploit creation. For quite some time, the era of generic exploitation techniques that take advantage of obvious flaws in allocators and protection mechanisms has been drawing to a close. While there will always be exceptions, it is more common than not for exploits to leverage application and vulnerability-specific methods to avoid protection mechanisms than attempt to defeat them. For example, on a heap overflow it is far more likely to be successful if a controlled overwrite can be made to a pointer value within the same chunk that will later be called than attempting to corrupt heap metadata.</p><p>Modern exploits are also far more likely to leverage information leakage attacks, a topic that has so far received no attention in terms of AEG. While many may consider information leakage to result from different vulnerability types it is common for certain vulnerabilities, such as use-after-free, double-free etc, to be leverage for both information leakage and code execution.</p><p>Both of these issues combined call into question the potential of template driven AEG to be sufficiently general to be useful. We consider it likely that once sufficiently accurate models are available it will be more useful to allow user-driven constraint generation based on their knowledge of exploitation, the application and the vulnerability in combination with more limited general and application specific templates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Automated Payload Creation</head><p>While AEG systems have attempted to automate the control flow hijacking part of exploitation there has also been research on the application of SMT-based systems to the generation of ROP payloads <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b34">34,</ref><ref type="bibr" target="#b16">16,</ref><ref type="bibr" target="#b32">32]</ref>. These systems have been developed to free an exploit developer from the tedious process of pouring over the potentially hundreds of thousands of candidate gadgets that may be found within a large binary.</p><p>As mentioned in the introduction, the approaches taken have fallen into two categories. Those that attempt to prove equivalence between a single gadget at a time and a model of some computation we wish to perform <ref type="bibr" target="#b34">[34]</ref>, and later systems that have attempted to provide a full compiler that can assemble multiple gadgets in sequence to achieve this computation <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b32">32]</ref>.</p><p>In the former approach, we first collect every valid sequence of instructions in the binary that ends in an instruction that can successfully transfer execution to the next gadget in sequence e.g. a ret instruction if the gadget addresses are provided at the location pointed to by ESP. The system takes as input these candidate gadgets and the specification of a computation s we require to be performed e.g. ESP &lt;-EAX + 8, which specifies we are looking for a gadget that puts the value stored in the EAX register plus 8 in the ESP register. First, the system will create an SMT representation s smt of the computation specification. In other words, it will convert the specification to an SMT formula. The system will then perform a number of heuristic, but sound, reductions of the candidate gadget set e.g. eliminating any gadgets that neither read EAX or write ESP. At this point the system will iterate over the remaining candidate gadgets C and for each gadget g ∈ C create the conjunction of a set of formulae that express the semantics g. For each g ∈ C the formula g ⇔ s smt is then created and checked for validity. If the formula is valid it means that under all interpretations of the variables in g and s smt their semantics are equivalent. This tells us that the gadget can be used to express the computation we require. If the formula is satisfiable but not valid it means that the gadget may work under some interpretations but may not under others. This would not be a desirable property of a component in a reliable exploit.</p><p>This approach can be quite useful in quickly discovering gadgets for simple computation specifications, such as the example given. However, such a system can only check if there is an exact correspondence between one gadget and the specification. Ideally, we would like to check whether the computation can be performed by chaining together n gadgets if necessary. This is often a requirement once our specification requires more complex data movement or arithmetic. A collection of m gadgets can potentially be arranged in m! different ways. Discovering the most useful potential combinations and then reasoning about their semantics requires a combination of heuristics and formula solving.</p><p>Systems have been developed and successfully applied to this problem, which have used SMT technology for different purposes. In <ref type="bibr" target="#b16">[16]</ref>, an SMT solver was used to reason about gadgets that contained branches. For example, if the gadget contained a branch an instruction sequence that might result in a crash a solver would be employed to check if it is possible that branch is never taken given the gadget's semantics. In <ref type="bibr" target="#b32">[32]</ref>, an SMT solver was used to look for arrangements of gadgets that meet the requirements of the computation specification.</p><p>Both the single-gadget and gadget compiler approaches have been successful at alleviating a certain amount of manual effort in the process of ROP payload creation. In both approaches we can see the pattern that exists throughout must successful integrations of SMT technology -minimizing the number of queries that must be made to a solver, reducing the problem space through the use of less computationally expensive algorithms and ensuring the constraints generated are a sufficiently accurate model of the problem being reasoned about.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SMT in protection analysis</head><p>Software protection analysis is critically important in dealing with malware, since most samples employ some sort of packing or obfuscation techniques in order to thwart analysis. It is also an area of economic concern in protecting digital assets from piracy and intellectual property theft. We present several areas in which SMT solvers have been practically applied towards these problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Equivalence checking for verification of deobfuscation results</head><p>Virtualization obfuscators <ref type="bibr" target="#b31">[31]</ref> are an especially complex category of software protection tools that are commonly abused by malware. These tools work by converting portions of the program-to-be-protected's x86 machine language into a randomly-generated language that is then executed at runtime in an interpreter, which itself is also randomly-generated and obfuscated. The original x86 machine code in these regions is then overwritten. Code is generated within the binary such that, at run-time, when the program goes to execute the protected code, the register state is saved to some location (e.g., onto the stack), the interpreter executes, the register state is reloaded, and then the unprotected portion of the program executes normally. The end result is that the malware analyst must either possess a tool to invert the translation, or reverse engineer the code as it is running inside of the interpreter (rather than in the form to which he or she is more accustomed, viz., x86 code). Such tools make life difficult for the reverse engineer, and they are also quite complex for the protection author to construct. The translation must capture precisely the semantics of the instructions under consideration, otherwise the virtualized program has the potential to produce different behaviors than the original, which -by explicit design goal -would be very difficult for the developer to diagnose. Given this complexity, it is not a surprising notion that these tools might have bugs in the form of improper translations. Similarly, if the analyst were to construct an inversion tool to deobfuscate a virtualization obfuscator, the complexity of such a tool could easily lead to bugs in the form of improper deobfuscation.</p><p>Equivalence checking is a well-known technique for verifying the equivalence of two pieces of code. The simplest case is when the code snippets are straight-line (i.e. branchless). As an example, consider the C programs x 0 = y + y; and x 1 = y &lt;&lt; 1;. Both of these programs logically encode the notion of doubling the variable y and storing the result in some other variable (since shifting left by one corresponds to multiplying by two). To determine whether these sequences produce equivalent results, we encode them as SMT formulae and then query the decision procedure for the condition x 0 񮽙 = x 1 . If this formula is satisfiable, the SMT solver will return a counterexample, namely, a value of y for which the sequences differ. If this formula is unsatisfiable, this is a proof (assuming the soundness of the solver) that the two sequences always produce the same output, given the same input.</p><p>To apply this procedure to two branchless sequences of x86 instructions, we convert both sequences to our intermediate representation, then put both sequences in Single Static Assignment (SSA <ref type="bibr" target="#b13">[13]</ref>) form, convert the SSA version of the IR to SMT formulae, and query the decision procedure as to whether the output variables (i.e., flags, registers, and memory) can ever differ (i.e., eax seq1 񮽙 = eax seq2 ∨ ebx seq1 񮽙 = ebx seq2 . . .). To compare the contents of memory in this way, the solver must support the theory of extensional arrays (which many modern solvers fortunately do).</p><p>SMT-backed equivalence checking provides a powerful primitive for ensuring the correctness of a deobfuscation procedure on branchless sequences. One simply generates some branchless program that falls within the purview of the virtualization obfuscator, obfuscates it, deobfuscates it, and uses equivalence checking to compare the resulting code against the original code.</p><p>Applying this procedure helped discover potentially incorrect translations in TheMida CISC VM <ref type="bibr" target="#b37">[37]</ref> after having constructed a deobfuscation procedure for this protection. The virtualization of certain instructions such as ror and inc did not take some of the subtleties of those instructions into account. In the case of ror and similar instructions, the Intel manuals dictate that these instructions do not modify the flags if the shiftand is zero. Therefore, improper maintenance of the flags prior to the execution of these instructions could cause the flags to take different values in the obfuscated and deobfuscated versions. Similarly, "inc" does not modify the carry flag, so any modification to this flag induced by the obfuscator before the instruction executes would result in incorrect machine state. <ref type="figure" target="#fig_4">Figure 4</ref> illustrates a more subtle example of potential incorrectness in translation. This (deobfuscated) instruction sequence loads an address (stored in enciphered form) from the memory location pointed at by the esi register, deciphers the address in the next four instructions, then loads a byte from that address and pushes it onto the stack. Since the ciphering process is invertible, this code snippet enforces no restriction upon the range of addresses from which the byte could potentially be loaded. Therefore, the address could well point onto the stack, below the location of the current stack pointer. Since the obfuscator introduces many spurious writes to the stack, the value loaded in the deobufscated world could differ from the one in the obfuscated world. This translation error would be unlikely to result in a runtime error in the real world, but it demonstrates the exhaustive capabilities of SMT solvers towards the equivalence checking problem.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">SMT-based input crafting for semiautomated cryptanalysis</head><p>When it comes to constructing licensing systems, best practices dictate that only properly-vetted implementations of trusted cryptographic algorithms be utilized as part of securely-designed cryptosystems. (Even then, that this may be insufficient to prevent against certain types of attacks such as those where the attacker is able to replace private keys within a binary or otherwise patch the program's logic. As part of the never-ending cat and mouse game in software protection, techniques such as <ref type="bibr" target="#b39">[39]</ref> can be used to obfuscate cryptographic keys, and techniques such as <ref type="bibr" target="#b36">[36]</ref> demonstrate that these techniques are not necessarily infallible). Many protection authors unfortunately still do not heed this advice, leading to a glut of cracked software available on peer-to-peer networks.</p><p>SMT solvers can be utilized as a medium for manually modelling licensing schemes. <ref type="bibr" target="#b14">[14]</ref> focuses on one scheme in particular, which is partially depicted in <ref type="figure">Fig- ure</ref>   First, the authors manually cryptanalyze the protection from an algebraic standpoint and construct a highly efficient key generator. Next, the authors demonstrate how to manually model the scheme in terms of an instance of the SAT problem. Since modern SMT solvers subsume SAT solvers, the scheme can obviously be manually modelled in terms of operations within the bitvector theory, in a manner that is more succinct and natural than the low-level bitwise manual CNF encoding. For instance, a multiplication operator can be modelled natively as one term within many solvers, whereas to model such a thing in terms of operations upon individual bits (as in a SAT instance) generates complex circuits. One iteration of the loop shown in <ref type="figure" target="#fig_5">Figure 5</ref> can be manually modelled in SMT as follows:</p><p>First, the authors manually cryptanalyze the protection from an algebraic standpoint and construct a highly efficient key generator. Next, the authors demonstrate how to manually model the scheme in terms of an instance of the SAT problem. Since modern SMT solvers subsume SAT solvers, the scheme can obviously be manually modelled in terms of operations within the bitvector theory, in a manner that is more succinct and natural than the low-level bitwise manual CNF encoding. For instance, a multiplication operator can be modelled natively as one term within many solvers, whereas to model such a thing in terms of operations upon individual bits (as in a SAT instance) generates complex circuits. One iteration of the loop (particulary, iteration i) as shown in <ref type="figure" target="#fig_5">Figure 5</ref> can be manually modelled in SMT as follows: In this formula, activation code corresponds to the memory region pointed at by the esi register and is an input to the serial algorithm, output corresponds to the memory region pointed at by the edi register, and rotate lef t is a built-in function in many SMT solvers for performing leftward rotation.</p><p>The same technology that is used in other problem domains for more conventional tasks in programming language theory, such as those discussed hereinbefore i.e. vulnerability discovery and test-case/exploit generation, can also be repurposed for the sake of solving problems such as this one semi-automatically. The Pandemic binary program analysis framework was employed <ref type="bibr" target="#b30">[30]</ref> to automatically (statically) generate an execution trace of a run of the algorithm, where the user's input is treated as free variables. We then manually constructed the postcondition that the output must satisfy, and then fed the results to an SMT solver. The inputs derived by the solver correctly break the scheme. Space considerations force us to refer the interested reader to <ref type="bibr" target="#b30">[30]</ref> for more details of the problem, the system architecture of Pandemic, and the solutions.</p><p>These problems can be attacked purely statically, if the analyst is willing to invest the time in manually modelling the state required to simulate the execution of the serial algorithm, or in a concolic fashion (which allows for greater automation). Static solutions may be preferred when the analyst wishes to investigate the properties of some piece of code that he or she might not know how to trigger; a static investigation may inform the analyst whether such an undertaking is merited (i.e., whether the portion of code exhibits some vulnerability; if this is not the case, then the broader problem of driving execution to that location would be fruitless).</p><p>This particular problem instance has the nice property that the path that the algorithm takes is not dependent upon the user's input. Specifically, the algorithm consists of a loop that executes for a fixed number of iterations before comparing the output to a fixed value. Hence, the problem is easier to solve than what might be the case if the path were input-dependent, for example, if multiple checks lead to failure cases, or if the input length were unbounded and the algorithm iterated over it in its entirety (such conditions could potentially be mitigated through the use of loop invariants, perhaps automatically-synthesized ones). We emphasize, however, that there is nothing special about serial algorithms that place them in a strictly restricted class of the general input-crafting problem: any type of code (including obfuscated code) with unrestricted programming language constructs might be utilized to implement a serial check -and in fact, the constraints might even be harder than the ordinary case due to the prevalence of hard cryptographic operations. Hence, progress towards this pursuit is tied to progress in binary program analysis and verification/SMT solvers in general. Nevertheless, these early results are encouraging.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>SMT solvers are becoming an integral part of the security engineer's tool kit. We presented three applications of SMT solvers in vulnerability discovery by static analysis, exploit generation (a specialization of input crafting), and copy protection analysis. In these three applications, solvers do a remarkable job of assisting the analysts in deciding whether suggested solutions are valid in their respective problem space. Yet, solvers are not suited for generating domain-specific problem descriptions as the preliminary constraint generation step has to be performed outside the solver. We expect that specialized constraint inference assistants will improve in the future and help generate formal problem definitions for non-trivial problems in the area of computer security.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Essence of the Sendmail crackaddr vuln.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>(</head><label></label><figDesc>a) The loop enters state (ulimit = lbuf + 14 ∧ quotation = T ∧ rquote = F) if it executes the first conditional (lines 15-19) (b) The loop enters state (ulimit = lbuf + 14 ∧ quotation = F ∧ rquote = T) if it executes the third conditional (lines 25-29) (c) No other conditional can be entered from such entry state. 2. Assume that the loop iteration starts in state (ulimit = lbuf + 14 ∧ quotation = T ∧ rquote = F). (a) The loop enters state (ulimit = lbuf + 15 ∧ quotation = F ∧ rquote = F) if it executes the second conditional (lines 20-24) (b) No other conditional can be entered from such entry state. 3. Assume that the loop iteration starts in state (ulimit = lbuf + 14 ∧ quotation = F ∧ rquote = T). (a) The loop enters state (ulimit = lbuf + 15 ∧ quotation = F ∧ rquote = F) if it executes the fourth conditional (lines 30-34) (b) The loop enters state (ulimit = lbuf + 13 ∧ quotation = T ∧ rquote = T) if it executes the first conditional (lines 15-19) (c) No other conditional can be entered from such entry state. 4. Assume that the loop iteration starts in state (ulimit = lbuf + 13 ∧ quotation = T ∧ rquote = T). (a) The loop enters state (ulimit = lbuf + 14 ∧ quotation = F ∧ rquote = F) if it executes the second conditional (lines 25-29) (b) No other conditional can be entered from such entry state.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Simpler automaton that fails to model loop</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1</head><label></label><figDesc>: lodsd dword ptr ds:[esi] 2: sub eax, ebx 3: xor eax, 7134B21Ah 4: add eax, 2564E385h 5: xor ebx, eax 6: movzx ax, byte ptr ds:[eax] 7: push ax</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Deobfuscated sequence</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The main loop of the serial algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>al 0,i = activation code[i] ∧ al 1,i = al 0,i − ebx i [7 : 0] ∧ al 2,i = al 1,i ⊕ edx i [7 : 0] ∧ output[i] = al 2,i ∧ edx i+1 = rotate lef t(edx i , 1) ∧ ebx i+1 = rotate lef t(ebx i , 1)</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Acknowledgements</head><p>The authors would like to thank Shuvendu Lahiri and Matt Miller for their insights on this article.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">AEG: Automatic exploit generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Avgerinos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">L T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brumley</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed System Security Symposium</title>
		<imprint>
			<date type="published" when="2011-02" />
			<biblScope unit="page" from="283" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Towards scalable modular checking of userdefined properties</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hackett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Lahiri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vanegue</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third international conference on Verified software: theories, tools, experiments</title>
		<meeting>the Third international conference on Verified software: theories, tools, experiments<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Automated theorem proving for software analysis. In Logic for Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lahiri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Musuvathi</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zap</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<editor>Reasoning, G. Sutcliffe and A. Voronkov</editor>
		<imprint>
			<biblScope unit="volume">3835</biblScope>
			<biblScope unit="page" from="2" to="22" />
			<date type="published" when="2005" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>Artificial Intelligence</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A decade of software model checking with SLAM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>And Rajamani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page" from="68" to="76" />
			<date type="published" when="2011-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">BAP: a binary analysis platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brumley</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Jager</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Avgerinos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Schwartz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd international conference on Computer aided verification</title>
		<meeting>the 23rd international conference on Computer aided verification<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="463" to="469" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automatic patch-based exploit generation is possible: Techniques and implications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brumley</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Poosankam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zheng</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<idno>SP &apos;08</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2008 IEEE Symposium on Security and Privacy<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="143" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">KLEE: unassisted and automatic generation of high-coverage tests for complex systems programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cadar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dunbar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th USENIX conference on Operating systems design and implementation</title>
		<meeting>the 8th USENIX conference on Operating systems design and implementation<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="209" to="224" />
		</imprint>
	</monogr>
	<note>OSDI&apos;08, USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Automatically generating inputs of death</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cadar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pawlowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Dill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Exe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Inf. Syst. Secur</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Improving computer security using extended static checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chess</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">V</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The S2E platform: Design, implementation, and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chipounov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Candea</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Model checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clarke</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Software Technology and Theoretical Computer</title>
		<editor>Science, S. Ramesh and G. Sivakumar</editor>
		<meeting><address><addrLine>Berlin / Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997" />
			<biblScope unit="volume">1346</biblScope>
			<biblScope unit="page" from="54" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">/</forename><surname>Bfb0058022</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cousot</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cousot</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
		<idno>POPL &apos;77</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th ACM SIGACT-SIGPLAN symposium on Principles of programming languages</title>
		<meeting>the 4th ACM SIGACT-SIGPLAN symposium on Principles of programming languages<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1977" />
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficiently computing static single assignment form and the control dependence graph</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cytron</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ferrante</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rosen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">K</forename><surname>Wegman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zadeck</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="451" to="490" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dcoder</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">And</forename><forename type="middle">Andrewl</forename><surname>Kaos</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>toy project&quot; and algebraic cryptanalysis</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The future of exploitation revisited</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dullien</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>Infiltrate conference</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A framework for automated architecture-independent gadget search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dullien</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kornau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weinmann</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R.-P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th USENIX conference on Offensive technologies</title>
		<meeting>the 4th USENIX conference on Offensive technologies<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
	<note>WOOT&apos;10, USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Flanagan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leino</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">R M</forename><surname>Houdini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">;</forename><surname>Esc/Java</surname></persName>
		</author>
		<title level="m">FME 2001: Formal Methods for Increasing Software Productivity</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">DART: Directed automated random testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Godefroid</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Klarlund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 ACM SIGPLAN conference on Programming language design and implementation</title>
		<meeting>the 2005 ACM SIGPLAN conference on Programming language design and implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="213" to="223" />
		</imprint>
	</monogr>
	<note>PLDI &apos;05, ACM</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">SAGE: Whitebox fuzzing for security testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Godefroid</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Molnar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Queue</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">27</biblScope>
			<date type="published" when="2012-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Automatic generation of control flow hijacking exploits for software vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heelan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2009-09" />
		</imprint>
		<respStmt>
			<orgName>University of Oxford</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Msc. dissertation</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lahiri</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">S B S</forename><surname>Havoc</surname></persName>
		</author>
		<ptr target="http://research.microsoft.com/en-us/projects/havoc/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Unbounded system verification using decision procedures and predicate abstraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lahiri</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
		<respStmt>
			<orgName>Carnegie Melon University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Tech. rep., Phd thesis</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Making Houdini inference transparent</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lahiri</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vanegue</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Explainhoudini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th international conference on Verification, model checking, and abstract interpretation</title>
		<meeting>the 12th international conference on Verification, model checking, and abstract interpretation<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>SpringerVerlag</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="309" to="323" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The Boogie 2 project</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leino</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">R M</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Trace partitioning in abstract interpretation based static analyzers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mauborgne</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>And Rival</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Languages and Systems, M. Sagiv</title>
		<meeting><address><addrLine>Berlin / Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005" />
			<biblScope unit="volume">3444</biblScope>
			<biblScope unit="page" from="139" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">The Z3 constraint solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikolai</forename><surname>Bjorner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">D M</forename></persName>
		</author>
		<ptr target="http://research.microsoft.com/projects/z3/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Efficient incremental algorithms for dynamic detection of likely invariants</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Perkins</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ernst</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGSOFT Softw. Eng. Notes</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="23" to="32" />
			<date type="published" when="2004-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The essence of ml type inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pottier</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Remy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advanced Topics in Types and Programming</title>
		<editor>C. Pierce</editor>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="389" to="489" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Return-oriented programming: Systems, languages, and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roemer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Buchanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Info. &amp; System Security</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<date type="published" when="2012-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Semi-automated input crafting by symbolic execution, with an application to automatic key generator generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rolles</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Unpacking virtualization obfuscators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rolles</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd USENIX conference on Offensive technologies</title>
		<meeting>the 3rd USENIX conference on Offensive technologies<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="1" to="1" />
		</imprint>
	</monogr>
	<note>WOOT&apos;09, USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Q: Exploit hardening made easy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Avgerinos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brumley</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2011-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Sendmail release notes for the crackaddr vulnerability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sendmail</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sole</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
<note type="report_type">DEPLIB 2.0. Ekoparty</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">BitBlaze: A new approach to computer security via binary analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Song</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Caballero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jager</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Poosankam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saxena</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Conference on Information Systems Security. Keynote</title>
		<meeting>the 4th International Conference on Information Systems Security. Keynote<address><addrLine>Hyderabad, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-12" />
		</imprint>
	</monogr>
	<note>invited paper.</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Practical cracking of white-box implementations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sysk</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Themida</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Themida</surname></persName>
		</author>
		<ptr target="http://www.oreans.com/themida.php" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Zero-sized heap allocations vulnerability analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vanegue</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th USENIX conference on Offensive technologies</title>
		<meeting>the 4th USENIX conference on Offensive technologies<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
	<note>WOOT&apos;10, USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wyseur</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>White-Box</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cryptography</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
		<respStmt>
			<orgName>Katholieke Universiteit Leuven</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
