<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:36+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">This paper is included in the Proceedings of the 13th USENIX Conference on File and Storage Technologies (FAST &apos;15). Open access to the Proceedings of the 13th USENIX Conference on File and Storage Technologies is sponsored by USENIX How Much Can Data Compressibility Help to Improve NAND Flash Memory Lifetime? How Much Can Data Compressibility Help to Improve NAND Flash Memory Lifetime?</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>February 16-19,</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiangpeng</forename><surname>Li</surname></persName>
							<email>lijiangpeng1984@gmail.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Zhao</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xuebin</forename><surname>Zhang</surname></persName>
							<email>tzhang@ecse.rpi.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jun</forename><surname>Ma</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shanghai</forename><surname>Jiao</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tong</forename><surname>University</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming</forename><surname>Zhao</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tong</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiangpeng</forename><surname>Li</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Zhao</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xuebin</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jun</forename><surname>Ma</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Shanghai Jiao Tong University</orgName>
								<address>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming</forename><surname>Zhao</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">School of Computing and Information Sciences</orgName>
								<orgName type="institution">Florida International University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tong</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Rensselaer Polytechnic Institute</orgName>
								<address>
									<postCode>2015 •</postCode>
									<settlement>Santa Clara</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Florida International University</orgName>
								<orgName type="institution" key="instit2">Rensselaer Polytechnic Institute</orgName>
								<orgName type="institution" key="instit3">Rensselaer Polytechnic Institute</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">This paper is included in the Proceedings of the 13th USENIX Conference on File and Storage Technologies (FAST &apos;15). Open access to the Proceedings of the 13th USENIX Conference on File and Storage Technologies is sponsored by USENIX How Much Can Data Compressibility Help to Improve NAND Flash Memory Lifetime? How Much Can Data Compressibility Help to Improve NAND Flash Memory Lifetime?</title>
					</analytic>
					<monogr>
						<title level="m">USENIX Association 13th USENIX Conference on File and Storage Technologies (FAST &apos;15)</title>
						<imprint>
							<biblScope unit="page">227</biblScope>
							<date type="published">February 16-19,</date>
						</imprint>
					</monogr>
					<note>https://www.usenix.org/conference/fast15/technical-sessions/presentation/li</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Although data compression can benefit flash memory lifetime, little work has been done to rigorously study the full potential of exploiting data compressibility to improve memory lifetime. This work attempts to fill this missing link. Motivated by the fact that memory cell damage strongly depends on the data content being stored, we first propose an implicit data compression approach (i.e., compress each data sector but do not increase the number of sectors per flash memory page) as a complement to conventional explicit data compression that aims to increase the number of sectors per flash memory page. Due to the runtime variation of data com-pressibility, each flash memory page almost always contains some unused storage space left by compressed data sectors. We develop a set of design strategies for exploiting such unused storage space to reduce the overall memory physical damage. We derive a set of mathematical formulations that can quantitatively estimate flash memory physical damage reduction gained by the proposed design strategies for both explicit and implicit data compression. Using 20nm MLC NAND flash memory chips, we carry out extensive experiments to quantify the content dependency of memory cell damage, based upon which we empirically evaluate and compare the effectiveness of the proposed design strategies under a wide spectrum of data compressibility characteristics.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>NAND flash memory cells gradually wear out with program/erase (P/E) cycling due to physical device damage caused by each P/E cycle, and cycling endurance drastically degrades with the technology scaling down. Hence, how to maximize memory lifetime has been widely studied from different aspects, e.g., signal processing and error correction coding (ECC) <ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref>, flash translation layer (FTL) <ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref>, and system software stack <ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref>.</p><p>Nevertheless, to our best knowledge, no prior work has thoroughly studied how data compressibility can be leveraged to improve flash memory lifetime. It is actually not surprising, since this question appears to be trivial at first glance: In conventional practice, the sole objective of data compression is to improve storage efficiency (i.e., explicitly increase the number of data sectors that can be stored in one flash memory page). This is referred to as explicit data compression in this work. Due to the runtime variation of data compressibility, explicit data compression results in heterogeneity among flash memory pages in terms of the number of sectors per page, which can complicate FTL and/or file system design. As a result, it is not uncommon that commercial flash-based storage devices do not use data compression at all. If sophisticated FTL and/or file systems, which can employ explicit compression to improve storage efficiency, are indeed available, one may simply expect that storing data with an average compression ratio 1 of α can directly improve the flash memory lifetime by 1/α. Therefore, one may easily draw the following conclusion: If we do not want to complicate the FTL and/or file system, we should simply leave the user data uncompressed, for which the data compressibility is totally irrelevant to flash memory lifetime; If we use complicated FTL and/or file systems to support explicit data compression, the flash memory lifetime improvement solely depends on the average data compression ratio.</p><p>This work contends that the above intuitive conclusion is far from revealing the complete potential of how data compressibility can help to improve flash memory lifetime. In essence, it overlooks two factors. First, flash memory experiences content-dependent memory damage, i.e., the damage suffered by each memory cell depends on its content (e.g., '11', '10', '00', and '01' in MLC flash memory) being stored. Once data compression leaves some unused storage space within flash memory pages, we can manipulate their data content in a damage-friendly manner to reduce physical damage. Hence, conventional explicit data compression is not necessarily the only option of exploiting data compressibility to improve memory lifetime. We propose implicit data compression as an alternative to complement with explicit data compression. With implicit data compression, we compress each data sector but do not increase the number of data sectors per flash memory page. Therefore, implicit compression has no impact on FTL and/or file system but meanwhile does not improve storage efficiency either. Second, for multi-bit per cell (e.g., MLC and TLC) flash memory, physical damage depends on a variety of factors (e.g., distribution characteristics of compressed data size, relative placement or layout of different pages on the same memory wordline), which have not been considered in prior work.</p><p>This paper presents a thorough study on exploiting data compressibility to reduce physical damage and hence improve flash memory lifetime. Since random read latency is one of the most important metrics of flash-based storage devices, this work assumes that each compressed data sector must reside entirely in one flash memory page. As a result, each flash memory page almost always contains some unused storage space left by compressed data sectors. Motivated by the content dependency of flash memory cell damage, we present a set of design strategies that can exploit the unused storage space within a flash memory page to reduce the overall memory damage, for both explicit and implicit data compression. Then we derive a set of mathematical formulations for quantitatively estimating flash memory damage reduction gained by the proposed design strategies. These rigorous mathematical formulations build a framework that directly links flash memory lifetime with data compressibility characteristics (e.g., mean and deviation of data compression ratio) and memory cell damage content dependency. Using 20nm MLC NAND flash memory chips, we carried out experiments to quantitatively measure the content-dependent memory cell damage factors, based upon which we empirically evaluated and compared the effectiveness of the proposed design strategies with either explicit or implicit compression. In summary, the main contributions of this work include:</p><p>1. We propose an implicit data compression strategy as a viable complement to conventional explicit data compression for exploiting data compressibility to improve flash memory lifetime;</p><p>2. A set of design strategies are developed to leverage the unused storage space left by data compression within flash memory pages to reduce the memory cell physical damage;</p><p>3. We derive a set of mathematical formulations to accurately estimate the flash memory damage based upon the characteristics of data compressibility and content-dependent memory cell damage;</p><p>4. We quantitatively compare explicit data compression and implicit data compression under a wide spectrum of runtime data compressibility characteristics and show that it is important to fully understand the data compressibility characteristics in order to choose the appropriate design strategy.</p><p>Finally, we note that, although this work focuses on flash memory, the developed design strategies and mathematical formulations are readily applicable to other emerging memory technologies, e.g., PCM and ReRAM, that experience similar content dependency of memory cell physical damage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Design Strategies</head><p>This section presents a set of design strategies that can exploit data compressibility to reduce memory cell damage. We first discuss the content dependency of cyclinginduced memory damage that motivates us to propose implicit compression (i.e., compress the data without increasing the number of sectors per flash memory page) in addition to the conventional explicit compression (i.e., compress the data and increase the number of sectors per page as much as possible). We further present different strategies on laying out the compressed data within flash memory pages that aim to leverage the contentdependent memory damage phenomenon for improving flash memory lifetime. We note that this work only focuses on MLC memory, and the discussions could be readily extended to the more complicated TLC case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Content-Dependent Damage</head><p>NAND flash memory handles data programming and read in page units with a typical size of 4kB or 8kB. For high-density MLC and TLC memory, different bits within each MLC/TLC memory cell belong to different pages. This can be illustrated in <ref type="figure" target="#fig_0">Fig. 1</ref> for MLC flash memory, where the two bits within each memory cell belong to lower and upper pages, respectively. NAND flash memory cells wear out with P/E cycling due to the oxide damage caused by the electrons that pass through the gate oxide during each P/E cycle. Although current practice estimates the memory cell damage solely dependent upon the number of P/E cycles endured by memory cells, actual physical damage further depends on the data content being programmed to memory cells. This can be intuitively explained using <ref type="figure" target="#fig_0">Fig. 1</ref>: different data content (e.g., '11', '10', '00', and '01') correspond to different number of electrons that pass through the gate oxide, and hence different amount of physical damage <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b14">15]</ref>.</p><p>To further demonstrate such content dependency, we carried out experiments using 20nm MLC NAND flash memory chips. To evaluate the effect of writing the content D test ∈{'11','10','00','01'}, we program each flash memory block with the pattern as shown in <ref type="figure">Fig. 2</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Data Storage Schemes</head><p>Since each compressed sector resides entirely in one memory page, each page will have a certain amount of unused storage space. This subsection first discusses how we should determine the content of the unused storage space to minimize the overall damage, then discusses different options of laying out the compressed data within flash memory pages. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Content of Unused Storage Space</head><p>For MLC NAND flash memory, each pair of lower and upper pages together determine the memory cell content and hence the flash memory damage. To minimize the flash memory damage, we should appropriately determine the data content in the unused storage space left by data compression. Let S (l) and S (u) denote the unused storage space in lower and upper page, and b l and b u denote the two bits in the same memory cell and belong to lower and upper page, respectively. Recall that the memory cell damage caused by the content '11', '10', '00', and '01' monotonically increase (where the left bit and right bit resides in lower and upper page, respectively), as illustrated in <ref type="figure" target="#fig_1">Fig. 3</ref>. Therefore, for each memory cell, we should apply the following rules to minimize flash memory damage:</p><p>• If b l ∈ S (l) and b u ∈ S (u) (i.e., we can freely set the values of both bits), we set b l = b u = 1 hence the least harmful content '11' is written to the cell;</p><p>• If b l ∈ S (l) and b u / ∈ S (u) (i.e., we can only freely set the value of b l ), we always set b l as '1' regardless to the value of b u ;</p><p>• If b l / ∈ S (l) and b u ∈ S (u) (i.e., we can only freely set the value of b u ), we always set b u = b l .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Compressed Data Layout</head><p>Since the memory cells covered by S (l) or S (u) experience less damage than the other memory cells, we should keep shifting the location of S (l) and S (u) within flash memory pages in order to equalize the damage among all the memory cells. We define a parameter l head to represent the location from where the compressed data are continuously stored in the lower and upper pages. We should keep changing l head in order to equalize the memory cell damage. Since the storage device FTL module always keeps track of the P/E cycles of each memory block, we can fix a relationship between l head and P/E cycle number, e.g., let L denote the memory page size and N P/E denote the P/E cycle number, we can calculate</p><formula xml:id="formula_0">l head = 񮽙 񮽙t · N P/E 񮽙mod L 񮽙 ,</formula><p>where t is a fixed constant integer. As a result, the storage device controller does not need to record the value of l head for each memory block.</p><p>In addition, as decompression is a process that is done serially, the length of the compressed data need not be kept in the FTL. For each compressed memory page, the decompression process can be terminated once the decompressed data length reaches the page length. Therefore, in order to support the proposed design strategy, the only overhead at the FTL layer is to calculate the l head for each memory page. For MLC NAND flash memory, there are two different options for laying out the compressed data in lower and upper pages. As illustrated in <ref type="figure" target="#fig_2">Fig. 4</ref>, the first option is to lay out the compressed data towards the same direction from l head in both the lower and upper pages, that we refer is referred to as unidirectional data layout. The other option is to lay out the compressed data towards opposite directions in the lower and upper pages, that we refer to as bidirectional data layout. As shown in <ref type="figure" target="#fig_2">Fig. 4</ref>, all the memory cells can be categorized into three types: (1) In each type-I memory cell, both bits belong to the compressed data; (2) In each type-II memory cell, one bit belongs to the compressed data while the other bit belongs to the unused storage space; (3) In each type-III memory cell, both bits belong to the unused storage space. Apparently, the physical damage experienced by type-I, type-II, and type-III memory cells monotonically reduces. Compared with unidirectional data layout, bidirectional data layout leads to more type-II memory cells and less type-I and type-III memory cells.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">Conditional Data Exchange</head><p>According to the discussion in Section 2.2.1, the content of each type-II memory cell can only belong to {'11', '10'} or {'11', '00'} if the lower or upper page bit belongs to unused storage space. As shown in <ref type="figure" target="#fig_1">Fig. 3</ref>, '10' causes less damage than '00'. Hence, the memory damage tends to be less if the lower page has more unused storage space (i.e., data being stored in the lower page have better compressibility). This observation directly motivates us to propose conditional data exchange: Let D (l) and D (u) denote the compressed data that have been originally arranged by the storage device FTL to store in one pair of lower and upper pages. If the length of </p><formula xml:id="formula_1">D (l) is not larger than that of D (u) (i.e., |D (l) | ≤ |D (u) |),</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Mathematical Formulations</head><p>This section presents the mathematical formulations that can accurately estimate flash memory physical damage reduction when using the design strategies presented in Section 2, for both explicit and implicit data compression. It is evident that different types of data can have different compressibility characteristics. With the popular LZ77 <ref type="bibr" target="#b15">[16]</ref> compression algorithm and sector size of 4kB, <ref type="figure" target="#fig_4">Fig. 5</ref> shows the per-sector compression ratio distribution for some common types of data. The results show that the compression ratio tends to approximately follows a Gaussian distribution. We carried out further experiments to verify the accuracy of such distribution approximation. <ref type="figure" target="#fig_4">Fig. 5</ref> shows the absolute difference (denoted as "Appr. error" in the <ref type="figure">figure)</ref> between the exact distribution and the approximate distribution for different types of data. The corresponding mean square errors (MSE) for these types of data are all at the magnitude of 10 −5 . Therefore, we can conclude that such a Gaussianbased approximation is reasonable with almost negligible inaccuracy. Therefore, to facilitate the mathematical derivation, we set that per-sector data compression ratio follows a Gaussian distribution in this work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Content-dependent Damage Factor</head><p>We first introduce a parameter, called normalized content-dependent damage factor, to quantify the impact of different content on memory cell damage. Let BER max denote the maximum memory raw BER that can be tolerated by the storage device error correction mechanism.   max . In this work, we define the content-dependent damage factor ρ i for each content i by normalizing with the average damage caused by random content, i.e.,</p><formula xml:id="formula_2">ρ i = η (r) max η (i) max , where i ∈ [0, 2 l − 1],<label>(1)</label></formula><p>and hence the damage factor ρ r for random content is 1. Using the measurement results shown in <ref type="figure" target="#fig_1">Fig. 3</ref> as an example, assume the BER max is 5 × 10 −3 , we calculate the four damage factors as ρ 11 = 0.33, ρ 10 = 0.69, ρ 00 = 1.01, and ρ 01 = 1.58.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Effect of Compression</head><p>We first derive the mathematical formulations for estimating the distribution characteristics of the compressed data and unused storage space size in each page. Let C s denote the size of each uncompressed data sector (e.g., 4kB), m s denote the number of uncompressed sectors in each page, and C p = m s · C s denote the size of each flash memory page (e.g., 8kB). As pointed out above, the per-sector compression ratio x approximately follows a Gaussian distribution N(µ, σ 2 ). Let m  </p><formula xml:id="formula_3">C (e) s = ∞ ∑ m (e) s =m s x · m (e) s ·C s · P 񮽙 m (e) s 񮽙 ,<label>(2)</label></formula><formula xml:id="formula_4">P 񮽙 m (e) s 񮽙 = P 񮽙 x · m (e) s ≤ m s &lt; x · 񮽙 m (e) s + 1 񮽙񮽙 = P 񮽙 x · m (e) s ≤ m s 񮽙 · 񮽙 1 − P 񮽙 x · 񮽙 m (e) s + 1 񮽙 ≤ m s 񮽙񮽙 . Since x ∼ N(µ, σ 2 ), we have that x · m (e) s and x · 񮽙 m (e) s + 1 񮽙 follow N 񮽙 µm (e) s , (σ m (e) s ) 2 񮽙 and N 񮽙 µ(m (e) s + 1), (σ (m (e) s + 1)) 2 񮽙 , respectively. Hence, P 񮽙 x · m (e) s ≤ m s 񮽙 and P 񮽙 x · 񮽙 m (e) s + 1 񮽙 ≤ m s 񮽙 is the CDF (cumulative distribution function) for the random variant x · m (e) s and x · 񮽙 m (e) s + 1 񮽙 . Accordingly, we have that P 񮽙 m (e) s 񮽙 = 񮽙 1 + er f 񮽙 m s −m (e) s µ σ m (e) s √ 2 񮽙񮽙 · 񮽙 1 − er f 񮽙 m s −(m (e) s +1)µ σ (m (e) s +1) √ 2 񮽙񮽙 /4 ,<label>(3)</label></formula><p>where er f (z) is the error function for Gaussian distribution, i.e., er f (z) = 1 </p><formula xml:id="formula_5">√ π 񮽙 z −z e −t 2 dt.</formula><formula xml:id="formula_6">s ∼ N 񮽙 µ c (e) s , σ 2 c (e) s</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>񮽙</head><p>, where</p><formula xml:id="formula_7">         µ c (e) s = µC s · ∑ m (e) s m (e) s P 񮽙 m (e) s 񮽙 , σ 2 c (e) s = (σC s ) 2 · ∑ m (e) s 񮽙 m (e) s P 񮽙 m (e) s 񮽙񮽙 2 .<label>(4)</label></formula><p>When using implicit compression, the number of compressed sectors per flash memory page always remains as m s and the length of compressed data per page is C</p><formula xml:id="formula_8">(i) s = x · m s · C s . Therefore, we have that the random variable C (i) s ∼ N 񮽙 µm s C s , σ 2 m 2 s C 2 s 񮽙 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Memory Damage Estimation</head><p>We further derive the mathematical formulations for calculating average memory cell damage per P/E cycle. Based upon the above discussions, we should consider four different design scenarios: (1) UD: unidirectional data layout without conditional data exchange, (2) BD: bidirectional data layout without conditional data exchange, (3) UDC: unidirectional data layout with conditional data exchange, (4) BDC: bidirectional data layout with conditional data exchange. Since the mathematical formulations can be derived with the same principle for all the scenarios, we first show the mathematical derivation in detail for UD (i.e., unidirectional data layout without conditional data exchange) and then present the results for the others without detailed derivations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Derivation for the UD Design Scenario</head><p>We first define two parameters x l and x u as the ratios between the compressed data size and flash memory page size for lower and upper pages, respectively. Recall that both C . Therefore, we can calculate the average memory cell damage per P/E cycle for the UD design scenario, which is normalized against the case of without using compression, as</p><formula xml:id="formula_9">ρ UD = 1 r 񮽙 z l + |x l − x u | ρ 00 + 2ρ 11 + ρ 10 4 + (1 − z u )ρ 11 񮽙 = 1 r 񮽙 1 − ρ 00 + 2ρ 11 + ρ 10 4 񮽙 z l + 1 r 񮽙 ρ 00 + ρ 10 − 2ρ 11 4 񮽙 z u + ρ 11 r = λ l UD r · z l + λ u UD r · z u + ρ 11 r ,<label>(5)</label></formula><p>where</p><formula xml:id="formula_10">λ l UD = 1 − ρ 00 + 2ρ 11 + ρ 10 4 , λ u UD = ρ 00 + ρ 10 − 2ρ 11 4 .</formula><p>In order to obtain the distribution of ρ UD , we must derive the distributions of z u and z l . The CDF of z u can be written as</p><formula xml:id="formula_11">F z u (z) = P(x l ≤ z, x u ≤ z) = P(x l ≤ z) · P(x u ≤ z) = F x l (z) · F x u (z),</formula><p>where F x l and F x u denote the CDF of x u and x l . Since x u and x l follow the same Gaussian distribution (denoted as f N ), we have that F x l = F x u . By taking the derivative of the CDF, we can obtain the PDF of z u as</p><formula xml:id="formula_12">f z u (z) = F 񮽙 z u (z) = f N (z) · 񮽙 1 + er f 񮽙 z − ˜ µ √ 2 ˜ σ 񮽙񮽙 ≈ f N (z) · 񮽙 1 + z − ˜ µ √ 2 ˜ σ 񮽙 .<label>(6)</label></formula><p>Hence, f z u can be approximately expressed as the product of the PDF of a Gaussian distribution and a straight line with the slope of</p><formula xml:id="formula_13">√ 2 ˜ σ . Since z ∈ (0, 1], we could further approximate f z u to a PDF of a Gaus- sian distribution, i.e., z u ∼ N 񮽙 µ z u , σ 2 z u 񮽙 and f z u (z) = 1 σ zu √ 2π exp 񮽙 − (z−µ zu ) 2 2σ 2 zu</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>񮽙</head><p>. The value of µ z u and σ z u can be obtained by solving</p><formula xml:id="formula_14">       d( f zu (z)) dz 񮽙 񮽙 񮽙 z=µ zu ≈ d 񮽙 f N (z)· 񮽙 1+ z− ˜ µ √ 2 ˜ σ 񮽙񮽙 dz 񮽙 񮽙 񮽙 񮽙 񮽙 z=µ zu = 0, f z u (z)| z=µ zu ≈ f N (z) · 񮽙 1 + z− ˜ µ √ 2 ˜ σ 񮽙񮽙 񮽙 񮽙 z=µ zu .<label>(7)</label></formula><p>Accordingly, we have that</p><formula xml:id="formula_15">   µ z u = ˜ µ + √ 6− √ 2 2 · ˜ σ , σ z u = 2 √ 2 √ 6+ √ 2 · ˜ σ · exp 񮽙 ( √ 6− √ 2) 2 8 񮽙 .<label>(8)</label></formula><p>We can obtain the PDF of z l in similar manner. First, we can express the CDF of z l as</p><formula xml:id="formula_16">F z l (z) = 1 − P (x l &gt; z, x u &gt; z) = 1 − (1 − P(x l ≤ z)) · (1 − P (x u ≤ z)) = 1 − (1 − F N (z)) 2 .</formula><p>By taking the derivative of F z l , we obtain the PDF of z l as</p><formula xml:id="formula_17">f z l (z) = 2 (1 − F N (z)) · f N (z) .<label>(9)</label></formula><p>Similar to the above derivations for the case of z u , we can approximate the PDF f z l as a Gaussian distribution To justify the Gaussian approximation of f z u (z) and f z l (z) (i.e., the PDF of z u and z l ) in the above derivations, <ref type="figure" target="#fig_8">Fig. 6</ref> compares the Gaussian approximation and the exact PDF, where we considered three different sets of { ˜ µ, ˜ σ } (i.e., {0.2, 0.05}, {0.5, 0.1}, and {0.8, 0.02}, respectively) to cover a wide range of the compressed data length ratio and deviations. As clearly shown in <ref type="figure" target="#fig_8">Fig. 6</ref>, the Gaussian approximation of f z u (z) and f z l (z) incurs almost negligible inaccuracy.</p><formula xml:id="formula_18">N 񮽙 µ z l , σ 2 z l 񮽙 , where    µ z l = ˜ µ − √ 6− √ 2 2 · ˜ σ , σ z l = 2 √ 2 √ 6+ √ 2 · ˜ σ · exp 񮽙 ( √ 6− √ 2) 2 8 񮽙 .<label>(10)</label></formula><p>Since </p><formula xml:id="formula_19">z l ∼ N 񮽙 µ z l , σ</formula><formula xml:id="formula_20">񮽙 µ UD = 1 r 񮽙 λ l UD · µ z l + λ u UD · µ z u + ρ 11 񮽙 , σ UD = 1 r 񮽙 񮽙 λ l UD · σ z l 񮽙 2 + 񮽙 λ u UD · σ z u 񮽙 2 .<label>(11)</label></formula><p>Given the same data compressibility, the use of implicit and explicit compression leads to different distribution of x u and x l , and different r, leading to different memory cell damage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">More Formulation Results</head><p>Using the same principle, we can derive the mathematical formulations that can calculate the normalized average memory cell damage per P/E cycle for the other three design scenarios. Due to the page limit, we will directly present the final mathematical formulations without showing the derivation details.</p><p>For the BD design scenario that uses bidirectional data layout without conditional data exchange, its average memory cell damage is</p><formula xml:id="formula_21">ρ (BD) ∼ N 񮽙 µ (BD) , σ 2<label>(BD)</label></formula><p>񮽙 : 񮽙 :</p><formula xml:id="formula_22">   µ (BD) = 1 r 񮽙񮽙 λ l (BD) + λ u (BD) 񮽙 · ˜ µ +C (BD) 񮽙 , σ (BD) = 1 r 񮽙 (λ l (BD) ) 2 + (λ u (BD) ) 2 · ˜ σ .</formula><formula xml:id="formula_23">   µ (UDC) = 1 r 񮽙 λ l (UDC) · µ z l + λ u (UDC) · µ z u + ρ 11 񮽙 , σ (UDC) = 1 r 񮽙 (λ l (UDC) · σ z l ) 2 + (λ u (UDC) · σ z u ) 2 .</formula><p>where</p><formula xml:id="formula_24">λ l (UDC) = 1 − ρ 11 + ρ 10 2 , λ u (UDC) = ρ 11 + ρ 10 2 − ρ 11 .</formula><p>For the BDC design scenario that uses bidirectional data layout with conditional data exchange, its average memory cell damage is</p><formula xml:id="formula_25">ρ (BDC) ∼ N 񮽙 µ (BDC) , σ 2<label>(BDC)</label></formula><p>񮽙 :</p><formula xml:id="formula_26">   µ (BDC) = 1 r 񮽙 λ l (BD) · µ z l + λ u (BD) · µ z u +C (BD) 񮽙 , σ (BDC) = 1 r 񮽙 (λ l (BD) · σ z l ) 2 + (λ u (BD) · σ z u ) 2 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Estimation of Memory Lifetime</head><p>This subsection discusses how we estimate the flash memory lifetime improvement based upon the average memory cell damage derived in the above section. In this work, we assume ideal wear-leveling, i.e., all the memory blocks always experience the same number of P/E cycles, and quantitatively define memory lifetime as the P/E cycle number that one memory block can survive before reaching the maximum allowable BER. Since it is common practice to use capacity overprovisioning in flash-based storage devices, we define an over-provisioning factor τ ≥ 1, i.e., the total physical storage capacity inside the storage device is τ× larger than the storage capacity visible to the host. Let η denote the memory block P/E cycling endurance of the baseline scenario without using any data compression. Straightforwardly, the overall memory lifetime of the baseline scenario is τ · η cycles. Once data compression is used, the average memory cell damage becomes a random variable with a Gaussian distribution due to the Gaussian-like distribution of runtime data compression ratio. As a result, the cycling endurance of each memory block and hence overall memory lifetime also become random variables. Let P (t) b denote the probability that one memory block can survive (i.e., can ensure the storage integrity even for incompressible data) after t P/E cycles, referred to as memory block survival probability. As the granularity of data erasure is in memory block units in NAND Flash memory,  the number of P/E cycles is independent among memory blocks. Hence, the survival of memory blocks is independent. Let N denote the number of memory blocks visible to the host, then the storage device contains τ · N memory blocks in total. Therefore, once P (t) b is known, based on the law of total probability, we can calculate the probability that the storage device can survive t cycles as</p><formula xml:id="formula_27">SP (t) = (τ−1)N ∑ k=0 񮽙񮽙 Nτ k 񮽙 · 񮽙 P (t) b 񮽙 Nτ−k · 񮽙 1 − P (t) b 񮽙 k 񮽙 ,<label>(12)</label></formula><p>which is called storage device survival probability. Suppose each memory block contains M wordlines and let P (t) wl denote the survival probability of one wordline, we have that P</p><formula xml:id="formula_28">(t) b = 񮽙 P (t) wl</formula><p>񮽙 M , i.e., one memory block survives only when all the wordlines inside this block survive. In the following, we will discuss how we can estimate the memory wordline survival probability P (t)</p><p>wl . For the baseline scenario without using data compression, the storage device fails to survive once the accumulated average damage of each memory cell reaches η · ρ r (recall that ρ r = 1 is the normalized memory cell damage factor when storing random data). When using data compression, let ρ w denote the memory cell damage per cycle, where ρ w could be ρ (UD) , ρ (BD) , ρ (UDC) , or ρ (BDC) dependent upon the design strategies being used. By setting η · ρ r as the maximum tolerable accumulated memory cell damage, we can express the P/E cycling endurance of each wordline as</p><formula xml:id="formula_29">T = max (t) , t · ρ w ≤ η · ρ r − ρ r .<label>(13)</label></formula><p>Since ρ w follows Gaussian distribution, t · ρ w also follows Gaussian distribution with mean of t · µ ρ w and variance of t 2 · σ 2 ρ w . Therefore, we can calculate the wordline survival probability P (t) wl at t cycles as</p><formula xml:id="formula_30">P (t) wl = 1 2 񮽙 1 + er f 񮽙 τ · η − 1 − t · µ ρ w tσ ρ w 񮽙񮽙 ,<label>(14)</label></formula><p>where µ ρ w and σ ρ w can be obtained using the formulations presented above for the four different design scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Quantitative Studies</head><p>With the formulations derived in Section 3, we studied the effectiveness of the design strategies presented in Section 2 for both explicit and implicit data compression. Based upon our measurement results with 20nm MLC NAND flash memory chips, we set the damage factors ρ 11 = 0.33, ρ 10 = 0.69, ρ 00 = 1.01, and ρ 01 = 1.58, as discussed in Section 3.1. As shown in (12), the storage device survival probability SP (t) depends on the overprovisioning factor τ and the total number of memory blocks N visible to the host. Assume the storage capacity of 512GB visible to the host and a block size of 4MB, we have N equals 128k. Each flash memory page has a size of 8kB, and we set the data sector size as 4kB. We further set the over-provisioning factor τ as 1.2. Based upon the memory chip measurement results and the overprovisioning factor of 1.2, we set the cycling endurance of the baseline scenario (i.e., without using data compression) as 8000.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Lifetime with Different Data Types</head><p>Using the measured compression ratio distribution of different data types as shown in <ref type="figure" target="#fig_4">Fig. 5</ref>, we evaluated the effectiveness of the developed design strategies on improving memory lifetime over the baseline scenario. <ref type="figure" target="#fig_9">Fig. 7</ref> shows the results when using the four different design scenarios. Recall that the design scenario UD uses unidirectional data layout without conditional data exchange, BD uses bidirectional data layout without conditional data exchange, UDC uses unidirectional data layout with conditional data exchange, BDC uses bidirectional data layout with conditional data exchange. For the baseline scenario, the storage device lifetime remains 8000 regardless to the data types. When using data compression with different design strategies, the storage device lifetime becomes a random variable, whose CDF (i.e., its survival probability) is calculated according to the formulations derived in Section 3. As shown in <ref type="figure" target="#fig_9">Fig. 7</ref>, explicit compression always outperforms implicit compression, which can be intuitively justified because explicit compression always tries to fit as many sectors as possible into each flash page. By comparing the data compressibility shown in <ref type="figure" target="#fig_4">Fig. 5</ref> and the results shown in <ref type="figure" target="#fig_9">Fig. 7</ref>, we can clearly see that the difference between explicit compression and implicit compression strongly relies on the data compressibility. The higher data compressibility is, the larger difference between explicit compression and implicit compression is. In addition, the BDC design scenario always performs the best under both explicit and implicit data compression.</p><p>When explicit compression is being used, the difference among different design strategies tends to diminish for data with better compressibility (e.g., LOG and HTML). This can be explained as follows. With highly compressible data, explicit compression can fit more compressed data and hence leave less unused storage space within each flash memory page. As a result, there is a smaller room for these different design strategies to exploit the unused storage space, leading to almost the same storage device lifetime. On the other hand, when implicit compression is being used, unidirectional data layout and bidirectional data layout tend to have noticeable different effect, especially for data with better compressibility. As pointed out in Section 2.2.2, compared with bidirectional data layout, unidirectional data layout leads to more cells with random data content and '11'. Although '11' causes the least memory cell damage, random data tend to cause relatively large damage, as shown in <ref type="figure" target="#fig_1">Fig. 3</ref>. Based upon the content-dependent damage factors measured from our 20nm MLC flash memory chips, the penalty of having more random data can noticeably off-set the gain of having more '11'. As a result, unidirectional data layout tends to be inferior to bidirectional data layout. In the case of implicit compression, for data with worse compressibility (e.g., DLL and EXE ), most memory cells would store random data content in both unidirectional and bidirectional data layout. As a result, bidirectional data layout will be inferior to unidirectional data layout in this scenario, which is shown in <ref type="figure" target="#fig_9">Fig. 7(a)</ref> and (c). Meanwhile, as shown in the results, the benefit of using conditional data exchange is not significant. Conditional data exchange aims to convert memory cell content from '00' to '10', since '10' causes less damage than '00'. Nevertheless, as shown in <ref type="figure" target="#fig_1">Fig. 3</ref>, the damage difference between '00' and '10' is not significant, which explains the low effectiveness of conditional data exchange observed in our study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Sensitivity to Data Compressibility</head><p>The above results are based upon the measured compressibility characteristics of several different types of data. To more thoroughly elaborate on the impact of data compressibility, we carried out further evaluations by considering a much wider range of data compressibility in terms of compression ratio mean and standard deviation.</p><p>We first fix the data compression ratio standard deviation as 0.01, and <ref type="figure" target="#fig_10">Fig. 8</ref> shows the corresponding storage device survival probability vs. lifetime for a wide range of compression ratio mean from 0.1 to 0.9. Data with better compressibility (i.e., smaller compression ratio mean) lead to larger lifetime improvement in both explicit compression and implicit compression. In addition, the advantage of explicit compression over implicit compression increases as the data have better compressibility. At the compression ratio mean of 0.1 (i.e., the data can be compressed by 10:1 on average), explicit and implicit compression can improve the storage device lifetime by 9.6 and 4.8 times, respectively. As shown in <ref type="figure" target="#fig_10">Fig. 8</ref>, for less compressible data (e.g., with the compression ratio mean of 0.7 and higher), explicit and implicit compression have almost the same effect. This is because, with low data compressibility, explicit compression can hardly increase the number of compressed data sectors per page. The results more clearly reveal the observations discussed above in Section 4.1: Under explicit compression, the difference between different de-     sign strategies quickly shrinks as we reduce the compression ratio mean; Under implicit compression, bidirectional data layout is always noticeably more beneficial than unidirectional data layout. By setting the storage device lifetime as the P/E cycles corresponding to 99.9% of storage device survival probability, <ref type="figure" target="#fig_12">Fig. 9</ref> further plots the storage device lifetime gain over the baseline scenario without using compression under different compression ratio mean.</p><p>Next, we examined the impact of data compression ratio standard deviation. With the compression ratio mean of 0.5, <ref type="figure" target="#fig_0">Fig. 10</ref> shows the storage device survival probability vs. P/E cycles when the compression ratio standard deviation varies from 0.01 to 0.14. As the data compression ratio standard deviation increases, advantage of explicit compression over implicit compression becomes more significant, and the storage device lifetime improvement generally reduces. In addition, the difference among the four different design scenarios reduces as the compression ratio standard deviation increases, for both explicit and implicit compression. Again, the design scenario of BDC is the most effective for both explicit and implicit compression.</p><p>By setting the storage device lifetime as the P/E cycles corresponding to 99.9% of storage device survival probability, <ref type="figure" target="#fig_0">Fig. 11</ref> further shows the storage device lifetime gain over the baseline scenario under different compression ratio standard deviation. It shows that the lifetime gain monotonically reduces as we increase the data compression ratio standard deviation for implicit data compression. Nevertheless, for explicit data compression, the storage device lifetime gain first reduces and then saturates and even slightly increases as we increase the compression ratio standard deviation. The figure more clearly reveals the dependency of comparison between explicit and implicit compression on compression ratio standard deviation. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Discussions</head><p>The above quantitative studies show that the proposed implicit data compression is a viable complement to the conventional explicit data compression. Although explicit data compression may noticeably complicate the design of FTL and/or OS, it always outperforms implicit data compression from the storage device lifetime perspective. Nevertheless, the advantage of explicit compression over implicit compression strongly depends on the data compressibility. As shown in the above evaluation results, the advantage of explicit compression over implicit compression reduces as the data compressibility drops, and becomes very small as the data compression ratio mean becomes sufficiently large (e.g., over 0.6∼0.7 in this study), particularly when the data compression ratio has a small standard deviation. Our studies show that the bidirectional data layout outperforms the unidirectional data layout, especially when using the implicit data compression. Nevertheless, we should emphasize that this conclusion may not be always true. As pointed out above, compared with bidirectional data layout, unidirectional data layout result in more memory cells with random data content and '11'. Hence, which data layout option is better is fundamentally dependent on the exact values of the contentdependent damage factors. In this work, we extracted the content-dependent damage factors based upon measurements with 20nm MLC flash memory chips. However, for further scaled technology nodes such as 16nm or the emerging 3D flash memory, content-dependent damage factors and their relative comparison may (largely) change. This could essentially change the conclusion on the comparison between unidirectional data layout and bidirectional data layout. In addition, the above results suggest that the design strategy of conditional data exchange is not very effective, which is again also essentially due to the content-dependent damage factors being used in this work. For MLC NAND flash memory, the conditional data exchange will become more effective if the damage factors of '10' and '00' have a larger difference in future memory technology nodes.</p><p>Therefore, when applying the developed design framework in practice, one should carry out sufficient measurements and experiments to fully understand the content dependency of NAND flash memory damage and runtime data compressibility characteristics, in order to determine the most appropriate design strategy for leveraging data compressibility to improve device lifetime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related Work</head><p>Prior work <ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref> has studied the practical implementation of data compression in flash-based data storage systems, aiming to improve the storage system I/O speed performance and flash memory lifetime. In <ref type="bibr" target="#b16">[17]</ref>, a blocklevel compression engine is devised to support on-line compression for SSD-based cache, which is transparent to the file system. The authors of <ref type="bibr" target="#b17">[18]</ref> develop a compression-aware FTL that can support compressionaware address mapping and garbage collection. The authors of <ref type="bibr" target="#b18">[19]</ref> implement a caching system with commodity SSD by integrating data compression and data deduplication. All the prior work aimed to explicitly improve the storage efficiency, like the explicit data compression scenario being considered in this work. Besides data compression, prior work <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21]</ref> also investigated the practical implementation of data deduplication in flashbased storage systems.</p><p>FTL plays an important role in determining the lifetime of flash-based data storage devices, hence it has been well studied. The wear-leveling function in FTL aims to equalize the physical damage among all the flash memory block by appropriately allocating the memory blocks for erase and programming. A variety of techniques have been proposed to optimize the design of the wear-leveling function (e.g., see <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23]</ref>). Aiming to reduce the write amplification and hence improve flash memory lifetime, the garbage collection function in FTL has been well studied (e.g., see <ref type="bibr" target="#b23">[24]</ref>). The log-structured approach to managing flash memory have been considered through direct management of raw flash memory chips <ref type="bibr" target="#b10">[11]</ref> or by facilitating the operation of the FTL inside SSDs <ref type="bibr" target="#b12">[13]</ref>. Such log-structured file system level management of memory chips lead to improved flash memory lifetime and storage system performance.</p><p>The strength of fault tolerance, in particular ECC, also largely affect the storage device lifetime. Although classical BCH codes are still widely used in commercial flash-based storage devices <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b26">26]</ref>, the more powerful LDPC codes are receiving significant attention from the industry (e.g., see several industrial presentations at recent Flash Summit <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b28">28]</ref>). A variety of techniques <ref type="bibr" target="#b29">[29]</ref><ref type="bibr" target="#b30">[30]</ref><ref type="bibr" target="#b31">[31]</ref><ref type="bibr" target="#b32">[32]</ref> have been developed to optimize the implementation of LDPC codes in future flash-based data storage devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>This paper presents a thorough study on exploiting data compressibility to reduce cycling-induced flash memory cell physical damage and hence improve storage device lifetime. This work is essentially motivated by the content dependency of flash memory cell damage. We first present an unconventional implicit data compression strategy as a viable complement to explicit data compression being used in current practice, both of which represent different trade-offs between flash memory lifetime improvement and impact on FTL and system design complexity. In addition, their effectiveness and comparison largely vary with the runtime data compressibility characteristics. We further develop a set of design strategies that can exploit the unused storage space left by data compression within flash memory pages in order to minimize the overall memory physical damage. Furthermore, we derive a set of mathematical formulations that can quantitatively estimate the effectiveness of the proposed design strategies. Using 20nm MLC NAND flash memory chips, we carried out experiments to empirically evaluate the content dependency of flash memory cell damage. Employing these quantized experimental results, we compare the effectiveness of the proposed design strategies when using either explicit or implicit compression. Although this work focuses on flash memory, the proposed design strategies and developed mathematical formulations are readily applicable to other emerging memory technologies, e.g., PCM and ReRAM, that experience similar content dependency of memory cell damage.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Illustration of MLC NAND flash memory cell.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Measured memory raw bit error rate (BER) vs. cycling with different data content.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Two different data layout strategies.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Measured distribution of compression ratio for different types of data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>For</head><label></label><figDesc>l-bit/cell NAND flash memory, let Ψ (i) (η) denote the raw BER after we keep programming memory cells with the same content i ∈ [0, 2 l − 1] for η cycles. Let Ψ (r) (η) denote the raw BER after we have programmed memory cells with random content for η cycles. Let η (i) max and η (r) max denote the P/E cycle number under which the raw BER Ψ (i) (η) and Ψ (r) (η) equal to BER max , respectively. Hence, we can estimate that the physical memory cell damage caused by each programming operation with the content i is proportional to 1/η (i) max . In addition, on av- erage the physical memory cell damage caused by pro- gramming random content is proportional to 1/η (r)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>(e) s denote the number of compressed sectors per page when using ex- plicit compression, and C (e) s denote the length of the compressed data within one page. Due to the variation of the compression ratio x, both m (e) s and C (e) s are ran- dom variables. Since x · m (e) s · C s denotes the length of the compressed data within one page when m (e) s is deter- mined, C (e) s can be expressed as</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>s</head><label></label><figDesc>(i.e., compressed data size within each flash memory page when using explicit and implicit com- pression, respectively) follow Gaussian distributions as derived in Section 3.2. Hence, x l and x u also follow the Gaussian distribution N( ˜ µ, ˜ σ 2 ), where˜µwhere˜ where˜µ = µ c (e) s /C p and˜σand˜ and˜σ 2 = σ 2 c (e) s /C 2 p for explicit compression, and˜µand˜ and˜µ = µm s C s /C p and˜σand˜ and˜σ 2 = σ 2 m 2 s C 2 s /C 2 p for implicit compres- sion. Define z l = min(x l , x u ) and z u = max(x l , x u ) and re- call that {ρ 11 , ρ 10 , ρ 00 , ρ 01 } represent the memory dam- age factors for the four different memory cell content and the damage factor ρ r for random content is 1. In addi- tion, let m (c) s denote the average number of sectors per flash memory page and recall that m s denote the number of sectors per flash memory page without using compres- sion, and define r = m (c) s m s</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>LengthFigure 6 :</head><label>6</label><figDesc>Figure 6: Comparison between the exact PDF of z l , z u and their Gaussian approximations with different sets of˜µ of˜ of˜µ and˜σand˜ and˜σ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Storage device survival probability when storing (a) DLL, (b) Text, (c) Exe, (d) Log, (e) XML, and (f) HTML data in flash memory. Both explicit compression and implicit compression are considered.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Storage device survival probability when data compression ratio standard deviation is 0.01 and mean is (a) 0.9, (b) 0.7, (c) 0.6, (d) 0.4, (e) 0.3, and (f) 0.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Storage device lifetime survival probability when compression ratio mean is 0.5 and standard deviation is (a) 0.01, (b) 0.03, (c) 0.05, (d) 0.09, (e) 0.1, and (f) 0.14.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Lifetime gain under different data compression ratio mean.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Lifetime gain for different data compression ratio standard deviation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>, i .e., to examine the cell content D test , each memory cell written with D test is surrounded by memory cells written with random data. This can incorporate the effect of cell-to- cell interference and program disturb in practice. The memory cells written with D test are called cells under test (CUT). Different memory blocks are used for test- ing different D test , and</head><label>i</label><figDesc>the locations of all the CUTs are fixed throughout the entire cycling. We capture the raw bit error rate (BER) of all the CUTs every few hundreds cycles by writing random data to all the memory cells. The measurement results are shown in Fig. 3.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>we directly store D (l) and D (u</head><label>we</label><figDesc>damage, it could complicate the FTL design. If the FTL uses the page-level address mapping, we need to update the mapping table once the data exchange oper- ation occurs. This will not introduce any mapping table storage overhead. If the FTL uses block-level or hybrid page/block-level address mapping, we must keep a 1-bit flag for each memory wordline, leading to extra mapping table storage overhead.</figDesc><table>) to the lower and upper 
pages, respectively; otherwise we switch their page lo-
cation, i.e., store D (l) to the upper page and D (u) to the 
lower page. 
Although this design scheme can reduce flash mem-
ory </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>where P 񮽙 m (e) s 񮽙 is the probability that m (e) s compressed sectors can fit into one page. We can express P 񮽙 m (e) s 񮽙 as</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>񮽙 µ UD , σ 2 UD 񮽙 , where</head><label></label><figDesc></figDesc><table>2 

z l 

񮽙 and z u ∼ N 
񮽙 µ z u , σ 2 

z u 

񮽙 , accord-

ing to (5), the average cell damage ρ UD also follows a 
Gaussian distribution, i.e., ρ UD ∼ N 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>where 񮽙 λ l (BD) = 1 − ρ 11 +ρ 10 2 , λ u (BD) = 1 − ρ 11 +ρ 00 2 , C (BD) = 2ρ 11 +ρ 10 +ρ 00 2 − 1. For the UDC design scenario that uses unidirectional data layout with conditional data exchange, its average memory cell damage is ρ (UDC) ∼ N 񮽙 µ (UDC) , σ 2</head><label></label><figDesc></figDesc><table>(UDC) 

</table></figure>

			<note place="foot" n="1"> Let S o and S c denote the size of the original and compressed data, then we define compression ratio as S c /S o , which falls into (0, 1].</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank our shepherd Sam H. Noh and the anonymous reviewers for their insight and suggestions for improvement. This work was supported by the National Science Foundation under Grants No. 1162152 and 1406154, National Science Foundation CAREER award CNS-125394, and the Department of Defense award W911NF-13-1-0157.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On the use of soft-decision error-correction codes in NAND Flash memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Circuits and Systems I: Regular Papers</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="429" to="439" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An LDPC-enabled flash controller in 40nm CMOS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Yeo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Flash Memory Summit</title>
		<meeting>Flash Memory Summit</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">LDPC codes for Flash channel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Flash Memory Summit</title>
		<meeting>Flash Memory Summit</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A space-efficient flash translation layer for compact flash systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Noh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Consumer Electronics</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="366" to="375" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A flash compression layer for smart media card systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Yim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Bahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Consumer Electronics</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="192" to="197" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Algorithms and data structures for flash memories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Toledo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="138" to="163" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A superblockbased flash translation layer for NAND Flash memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th ACM &amp; IEEE International conference on Embedded software</title>
		<meeting>the 6th ACM &amp; IEEE International conference on Embedded software</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="161" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Compression support for flash translation layer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Workshop on Software Support for Portable Storage</title>
		<meeting>the International Workshop on Software Support for Portable Storage</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="19" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Improving performance and lifetime of solid-state drives using hardware-accelerated compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fleming</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Consumer Electronics</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1732" to="1739" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Error rate-based wear-leveling for NAND Flash memory at highly scaled technology nodes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Very Large Scale Integration (VLSI) Systems</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1350" to="1354" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Introducing yaffs, the first NANDspecific flash file system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Manning</surname></persName>
		</author>
		<ptr target="http://linuxdevices.com" />
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Abstract specification of the UBIFS file system for flash memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schierl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Schellhorn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Haneberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Reif</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FM 2009: Formal Methods</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="190" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">F2FS: A New File System for Flash Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hwang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Cho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th USENIX File and Storage Technologies (FAST)</title>
		<meeting>the 13th USENIX File and Storage Technologies (FAST)</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Error patterns in MLC NAND flash memory: Measurement characterization and analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">F</forename><surname>Haratsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE)</title>
		<meeting>Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE)</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="521" to="526" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Bit error rate in NAND Flash memories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mielke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Marquart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kessenich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Belgal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Eric</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Trivedi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Goodness</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">R</forename><surname>Nevill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Reliability Physics Symposium</title>
		<meeting>IEEE International Reliability Physics Symposium</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="9" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A universal algorithm for sequential data compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ziv</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lempel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="issue">23</biblScope>
			<biblScope unit="page" from="337" to="343" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Using transparent compression to improve SSD-based i/o caches</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Makatos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Klonatos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Marazakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Flouris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bilas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Computer Systems (EuroSys)</title>
		<meeting>the European Conference on Computer Systems (EuroSys)</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Improving performance and lifetime of solid-state drives using hardware-accelerated compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fleming</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arvind</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Consumer Electronics</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1732" to="1739" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Nitro: A capacity-optimized SSD cache for primary storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shilane</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Douglis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Shim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Smaldone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wallace</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of USENIX Annual Technical Conference (ATC)</title>
		<meeting>USENIX Annual Technical Conference (ATC)</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="501" to="512" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Leveraging value locality in optimizing NAND Flash-based SSDs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pisolkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Urgaonkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sivasubramaniam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX File and Storage Technologies (FAST)</title>
		<meeting>the 9th USENIX File and Storage Technologies (FAST)</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">CAFTL: A content-aware flash translation layer enhancing the lifespan of Flash memory based solid state drives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX File and Storage Technologies (FAST)</title>
		<meeting>the 9th USENIX File and Storage Technologies (FAST)</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Extending the lifetime of flash-based storage through reducing write amplification from file systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX File and Storage Technologies (FAST)</title>
		<meeting>the 11th USENIX File and Storage Technologies (FAST)</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="257" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Wear unleveling: improving NAND Flash lifetime by balancing page endurance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Jimenez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Novo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Ienne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th USENIX File and Storage Technologies (FAST)</title>
		<meeting>the 12th USENIX File and Storage Technologies (FAST)</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="47" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Real-time garbage collection for flash-memory storage systems of real-time embedded systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kuo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Embedded Computing Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="837" to="863" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yoo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Yoo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Park</surname></persName>
		</author>
		<idno>6.4</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">gb/s multi-threaded BCH encoder and decoder for multi-channel SSD controllers</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Solid-State Circuits Conference (ISSCC)</title>
		<meeting>IEEE International Solid-State Circuits Conference (ISSCC)</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="426" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">An efficient BCH decoder with 124-bit correctability for multichannel SSD applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Tsai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Asian Solid State Circuits Conference (A-SSCC)</title>
		<meeting>IEEE Asian Solid State Circuits Conference (A-SSCC)</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="61" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The efficient LDPC DSP system for SSD</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Flash Memory Summit</title>
		<meeting>Flash Memory Summit</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Non binary LDPC codes: The next frontier in ECC for flash</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Dolecek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Flash Memory Summit</title>
		<meeting>Flash Memory Summit</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Soft information for LDPC decoding in flash: mutual-information optimized quantization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Courtade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Shankar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wesel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Global Telecommunications Conference (GLOBECOM)</title>
		<meeting>IEEE Global Telecommunications Conference (GLOBECOM)</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Over-10-extended-lifetime 76%-reduced-error solid-state drives (SSDs) with error-prediction LDPC architecture and error-recovery scheme</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tanakamaru</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yanagihara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Takeuchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Solid-State Circuits Conference (ISSCC)</title>
		<meeting>IEEE International Solid-State Circuits Conference (ISSCC)</meeting>
		<imprint>
			<biblScope unit="page">2012</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Realizing unequal error correction for NAND flash memory at minimal read latency overhead</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Circuits and Systems II: Express Briefs</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="354" to="358" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Enhanced precision through multiple reads for LDPC decoding in flash memories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Vakilinia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Courtade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Shankar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wesel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="880" to="891" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
