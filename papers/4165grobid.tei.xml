<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:00+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">DIZK: A Distributed Zero Knowledge Proof System DIZK: A Distributed Zero Knowledge Proof System</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 15-17. 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Howard</forename><surname>Wu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Raluca Ada Popa, and Ion Stoica</orgName>
								<orgName type="laboratory">UC Berkeley Ion Stoica UC Berkeley</orgName>
								<address>
									<settlement>Berkeley, Berkeley, Berkeley, Berkeley</settlement>
									<country>UC</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenting</forename><surname>Zheng</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Raluca Ada Popa, and Ion Stoica</orgName>
								<orgName type="laboratory">UC Berkeley Ion Stoica UC Berkeley</orgName>
								<address>
									<settlement>Berkeley, Berkeley, Berkeley, Berkeley</settlement>
									<country>UC</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alessandro</forename><surname>Chiesa</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Raluca Ada Popa, and Ion Stoica</orgName>
								<orgName type="laboratory">UC Berkeley Ion Stoica UC Berkeley</orgName>
								<address>
									<settlement>Berkeley, Berkeley, Berkeley, Berkeley</settlement>
									<country>UC</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Howard</forename><surname>Wu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Raluca Ada Popa, and Ion Stoica</orgName>
								<orgName type="laboratory">UC Berkeley Ion Stoica UC Berkeley</orgName>
								<address>
									<settlement>Berkeley, Berkeley, Berkeley, Berkeley</settlement>
									<country>UC</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenting</forename><surname>Zheng</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Raluca Ada Popa, and Ion Stoica</orgName>
								<orgName type="laboratory">UC Berkeley Ion Stoica UC Berkeley</orgName>
								<address>
									<settlement>Berkeley, Berkeley, Berkeley, Berkeley</settlement>
									<country>UC</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alessandro</forename><surname>Chiesa</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Raluca Ada Popa, and Ion Stoica</orgName>
								<orgName type="laboratory">UC Berkeley Ion Stoica UC Berkeley</orgName>
								<address>
									<settlement>Berkeley, Berkeley, Berkeley, Berkeley</settlement>
									<country>UC</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raluca</forename><forename type="middle">Ada</forename><surname>Popa</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Raluca Ada Popa, and Ion Stoica</orgName>
								<orgName type="laboratory">UC Berkeley Ion Stoica UC Berkeley</orgName>
								<address>
									<settlement>Berkeley, Berkeley, Berkeley, Berkeley</settlement>
									<country>UC</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">DIZK: A Distributed Zero Knowledge Proof System DIZK: A Distributed Zero Knowledge Proof System</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 27th USENIX Security Symposium</title>
						<meeting>the 27th USENIX Security Symposium <address><addrLine>Baltimore, MD, USA</addrLine></address>
						</meeting>
						<imprint>
							<date type="published">August 15-17. 2018</date>
						</imprint>
					</monogr>
					<note>Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX. This paper is included in the</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Recently there has been much academic and industrial interest in practical implementations of zero knowledge proofs. These techniques allow a party to prove to another party that a given statement is true without revealing any additional information. In a Bitcoin-like system, this allows a payer to prove validity of a payment without disclosing the payment&apos;s details. Unfortunately, the existing systems for generating such proofs are very expensive, especially in terms of memory overhead. Worse yet, these systems are &quot;monolithic&quot;, so they are limited by the memory resources of a single machine. This severely limits their practical applicability. We describe DIZK, a system that distributes the generation of a zero knowledge proof across machines in a compute cluster. Using a set of new techniques, we show that DIZK scales to computations of up to billions of logical gates (100× larger than prior art) at a cost of 10 µs per gate (100× faster than prior art). We then use DIZK to study various security applications.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Cryptographic proofs with strong privacy and efficiency properties, known as zkSNARKs (zero-knowledge Succinct Non-interactive ARgument of Knowledge) <ref type="bibr" target="#b50">[52,</ref><ref type="bibr" target="#b35">38,</ref><ref type="bibr" target="#b16">19]</ref>, have recently received much attention from academia and industry <ref type="bibr" target="#b10">[13,</ref><ref type="bibr" target="#b6">9,</ref><ref type="bibr" target="#b38">41,</ref><ref type="bibr" target="#b49">51,</ref><ref type="bibr" target="#b17">20,</ref><ref type="bibr" target="#b34">37,</ref><ref type="bibr" target="#b53">55,</ref><ref type="bibr" target="#b8">11,</ref><ref type="bibr" target="#b12">15,</ref><ref type="bibr" target="#b46">48,</ref><ref type="bibr" target="#b76">78,</ref><ref type="bibr" target="#b28">31,</ref><ref type="bibr" target="#b30">33,</ref><ref type="bibr" target="#b7">10,</ref><ref type="bibr" target="#b73">75,</ref><ref type="bibr" target="#b28">31,</ref><ref type="bibr" target="#b44">46,</ref><ref type="bibr" target="#b45">47,</ref><ref type="bibr" target="#b51">53,</ref><ref type="bibr" target="#b33">36,</ref><ref type="bibr" target="#b19">22]</ref>, and have seen industrial deployments <ref type="bibr" target="#b4">[7,</ref><ref type="bibr" target="#b3">5,</ref><ref type="bibr">3,</ref><ref type="bibr" target="#b2">4]</ref>. For example, zkSNARKs are the core technology of Zcash <ref type="bibr" target="#b4">[7,</ref><ref type="bibr" target="#b7">10]</ref>, a popular cryptocurrency that, unlike Bitcoin, preserves a user's payment privacy. Bitcoin requires users to broadcast their private payment details in the clear on the public blockchain, so other participants can check the validity of the payment. In contrast, zkSNARKs enable users to broadcast encrypted transactions details and prove the validity of the payments without disclosing what the payments are.</p><p>More formally, zkSNARKs allow a prover (e.g., a Zcash user making a payment) to convince a verifier (e.g., any other Zcash user) of a statement of the form "given a function F and input x, there is a secret w such that F(x, w) = true". In the cryptocurrency example, w is the private payment details, x is the encryption of the payment details, and F is a predicate that checks that x is an encryption of w and w is a valid payment. These proofs provide two useful properties: succinctness and zero knowledge. The first property allows for extremely small proofs (128 B) and cheap verification (2 ms plus a few µs per byte in x), regardless of how long it takes to evaluate F (even if F takes years to compute). The second property enables privacy preservation, which means that the proof reveals no information about the secret w (beyond what is already implied by the statement itself).</p><p>The remarkable power of zkSNARKs comes at a cost: the prover has a significant overhead. zkSNARKs are based on probabilistically checkable proofs (PCPs) from Complexity Theory, which remained prohibitively slow for two decades until a line of recent work brought them closer to practical systems (see §12). One of the main reasons for the prover's overhead is that the statement to be proved must be represented via a set of logical gates forming a circuit, and the prover's cost is quasi-linear in this circuit's size. Unfortunately, this prover cost is not only in time but also in space.</p><p>Thus, in existing systems, the zkSNARK prover is a monolithic process running on a single machine that quickly exceeds memory bounds as the circuit size increases. State-of-the-art zkSNARK systems <ref type="bibr" target="#b57">[59]</ref> can only support statements of up to 10-20 million gates, at a cost of more than 1 ms per gate. Let us put this size in perspective via a simple example: the SHA-256 compression function, which maps a 512-bit input to a 256-bit output, has more than 25,000 gates <ref type="bibr" target="#b7">[10]</ref>; no more than 400 evaluations of this function fit in a circuit of 10 million gates, and such a circuit can be used to hash files of up to a mere 13 kB. In sum, 10 million gates is not many. This bottleneck severely limits the applicability of SNARKs, and motivates a basic question: can zkSNARKs be used for circuits of much larger sizes, and at what cost? DIZK. We design and build DIZK (DIstributed Zero Knowledge), a zkSNARK system that far exceeds the scale of previous state-of-the-art solutions. At its core, DIZK distributes the execution of a zkSNARK across a compute cluster, thus enabling it to leverage the aggregated cluster's memory and computation resources. This allows DIZK to support circuits with billions of gates (100× larger than prior art) at a cost of 10 µs per gate (100× faster than prior art).</p><p>We evaluate DIZK on two applications: proving authenticity of edited photos (as proposed in <ref type="bibr" target="#b51">[53]</ref>), and proving integrity of machine learning models. DIZK enables applications on significantly larger instance sizes, e.g., image editing on photos of 2048 by 2048 pixels.</p><p>DIZK makes a significant conceptual step forward, enlarging the class of applications feasible for zkSNARKs. We implement DIZK via Apache Spark <ref type="bibr" target="#b1">[2]</ref> and will release all source code under a permissive software license.</p><p>DIZK does inherit important limitations of zkSNARKs (see §13). First, while DIZK supports larger circuits than prior systems, its overhead is still prohibitive for many practical applications; improving the efficiency of zkSNARKs for both small and large circuits remains an important challenge. Also, like other zkSNARKs, DIZK requires a trusted party to run a setup procedure that uses secret randomness to sample certain public parameters; the cost of this setup grows with circuit size, which means that this party must also use a cluster, which is harder to protect against attackers than a single machine. Nevertheless, the recent progress on zkSNARKs has been nothing short of spectacular, which makes us optimistic that future advancements will address these challenges, and bring the power of zkSNARKs to many more practical applications. Challenges and techniques. Distributing a zkSNARK is challenging. Protocols for zkSNARKs on large circuits involve solving multiple large instances of tasks about polynomial arithmetic over cryptographically-large prime fields and about multi-scalar multiplication over elliptic curve groups. For example, generating proofs for billiongate circuits requires multiplying polynomials of a degree in the billions, and merely representing these polynomials necessitates terabit-size arrays. Moreover, fast algorithms for solving these tasks, such as Fast Fourier Transforms (FFTs), are notoriously memory intensive, and rely on continuously accessing large pools of shared memory in complex patterns. But each node in a compute cluster can store only a small fraction of the overall state, and thus memory is distributed and communication between nodes incurs network delays. In addition, these heavy algorithmic tasks are all intertwined, which is problematic as reshuffling large amounts of data from the output of one task to give as input to the next task is expensive.</p><p>We tackle the above challenges in two steps. First, we single out basic computational tasks about field and group arithmetic and achieve efficient distributed realizations of these. Specifically, for finite fields, DIZK provides distributed FFTs and distributed Lagrange interpolant evaluation ( §4.1); for finite groups, it provides distributed multi-scalar multiplication with fixed bases and with variable bases ( §4.2). Throughout, we improve efficiency by leveraging characteristics of the zkSNARK setting instead of implementing agnostic solutions. Second, we build on these components to achieve a distributed zkSNARK. Merely assembling these components into a zkSNARK as in prior monolithic systems, however, does not yield good efficiency. zkSNARKs transform the computation of a circuit into an equivalent representation called a Quadratic Arithmetic Program <ref type="bibr" target="#b34">[37,</ref><ref type="bibr" target="#b53">55]</ref>: a circuit with N wires and M gates is transformed into a satisfaction problem about O(N) polynomials of degree O(M). The evaluations of these polynomials yield matrices of size O(N) × O(M) that are sparse, with only O(N + M) non-zero entries. While this sparsity gives rise to straightforward serial algorithms, the corresponding distributed computations suffer from stragglers with large overheads.</p><p>The reason lies in how the foregoing transformation is used in a zkSNARK. Different parts of a zkSNARK leverage the sparsity of the matrices above in different ways: the so-called QAP instance reduction relies on their column sparsity ( §5), while the corresponding QAP witness reduction relies on their row sparsity ( §6). However, it turns out that the columns and rows are almost sparse: while most columns and rows are sparse, some are dense, and the dense ones create stragglers.</p><p>We address this issue via a two-part solution. First, we run a lightweight distributed computation to identify and annotate the circuit with which columns/rows are dense. Second, we run a hybrid distributed computation that uses different approaches to process the sparse and dense columns/rows. Overall we achieve efficient distributed realizations for these QAP routines. In particular, this approach outperforms merely invoking generic approaches that correct for load imbalances such as skewjoin <ref type="bibr">[6]</ref>.</p><p>Finally, we emphasize that most of the technical work described above can be re-used as the starting point to distribute many other similar proof systems. We have thus packaged these standalone components as a separate library, which we deem of independent interest.</p><p>We also briefly mention that supporting billion-gate circuits required us to generate and use a pairing-friendly elliptic curve suitable for this task. See §9 for details.</p><p>Authenticity of photos &amp; integrity of ML models. We study the use of DIZK for two natural applications: (1) authenticity of edited photos <ref type="bibr" target="#b51">[53]</ref> (see §7.1); and (2) integrity of machine learning models (see §7.2). Our experiments show that DIZK enables such applications to scale to much larger instance sizes than what is possible via previous (monolithic) systems.</p><p>An application uses DIZK by constructing a circuit for the desired computation, and by computing values for the circuit's wires from the application inputs. We do this, for the above applications, via distributed algorithms that exploit the parallel nature of computations underlying editing photos and ML training algorithms.</p><p>Cryptography at scale. DIZK exemplifies a new paradigm. Cryptographic tools are often executed as monolithic procedures, which hampers their applicability to large problem sizes. We believe that explicitly designing such tools with distributed architectures in mind enables "cryptography at scale", and we view DIZK as a step in this direction for the case of zkSNARKs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background on zkSNARKs</head><p>The notion of a zkSNARK, formulated in <ref type="bibr" target="#b50">[52,</ref><ref type="bibr" target="#b35">38,</ref><ref type="bibr" target="#b16">19]</ref>, has several definitions. We consider one known as a publiclyverifiable preprocessing zkSNARK (see <ref type="bibr" target="#b17">[20,</ref><ref type="bibr" target="#b34">37]</ref>). We cover necessary background on zkSNARKs by providing a high-level description ( §2.1), an informal definition ( §2.2), and the protocol that we start from ( §2.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">High-level description</head><p>A zkSNARK can be used to prove/verify statements of the form "given a public predicate F and a public input x, I know a secret input w such that F(x, w) = true". It has three components: setup, prover, and verifier <ref type="figure">(Fig. 1</ref>).</p><p>• The setup receives a predicate F (expressed in a certain way as discussed in §2.2) and outputs a proving key pk F and verification key vk F . Both keys are published as public parameters and pk F /vk F can be used to prove/verify any number of statements about F. In particular, the setup for F needs to be run only once. While the setup outputs keys that are public information, its intermediate computation steps involve secret values that must remain secret. Thus, the setup must be run by a trusted party -this requirement is challenging, however prior work has studied mitigations (see §13).</p><p>• The prover receives the proving key pk F , a public input x for F, and a secret input w for F, and outputs a proof π. The proof attests to the statement "given F and x, I know a secret w such that F(x, w) = true", but reveals no information about w. The generation of π involves randomness that imbues it with zero knowledge. Anyone can run the prover.</p><p>• The verifier receives the verification key vk F , a public input x for F, and a proof π, and outputs a decision bit ('accept' or 'reject'). Anyone can run the verifier. A zkSNARK's costs are determined by the 'execution time' T F of F (see §2.2) and the size k of the input x (which is at most T F ). The execution time is at least the size of the input and, in many applications, much larger than it. Thus, T F is seen to be significantly larger than k.</p><p>The key efficiency feature of a zkSNARK is that the verifier running time is proportional to k alone (regardless of T F ) and the proof has constant size (regardless of k, T F ). The size of vk F is proportional to k (regardless of T F ).</p><p>However, the setup and the prover are very expensive: their running times are (at least) proportional to T F . The size of pk F is large, because it is proportional to T F .</p><p>Running the setup and prover is a severe bottleneck in prior zkSNARK systems since time and space usage grows in T F . Our focus is to overcome these bottlenecks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The zkSNARK language and interface</head><p>While one typically expresses a computation F via a high-level programming language, a zkSNARK requires expressing F via a set of quadratic constraints φ F , which is closely related to circuits of logical gates. A zkSNARK proof then attests that such a set of constraints is satisfiable. The size of φ F is related to the execution time of F. There has been much research <ref type="bibr" target="#b53">[55,</ref><ref type="bibr" target="#b8">11,</ref><ref type="bibr" target="#b12">15,</ref><ref type="bibr" target="#b19">22,</ref><ref type="bibr" target="#b46">48,</ref><ref type="bibr" target="#b76">78,</ref><ref type="bibr" target="#b28">31,</ref><ref type="bibr" target="#b73">75,</ref><ref type="bibr" target="#b11">14]</ref> devoted to techniques for encoding programs via sets of constraints, and in this paper, we consider φ F as given. The zkSNARK language. We describe the type of computation used in the interface of a zkSNARK. Values are in a field F of a large prime order p.</p><p>An R1CS instance φ over F is parameterized by the number of inputs k, number of variables N (with k ≤ N), and number of constraints M; φ is a tuple (k, N, M, a, b, c) where a, b, c are (1 + N) × M matrices over F.</p><p>An input for φ is a vector x in F k , and a witness for φ is a vector w in F N−k . An input-witness pair (x, w) satisfies φ if, letting z be the vector F 1+N composed of 1, x, and w, the following holds for all j ∈ [M]:</p><formula xml:id="formula_0">∑ N i=0 a i, j z i · ∑ N i=0 b i, j z i = ∑ N i=0 c i, j z i .</formula><p>One can treat each quadratic constraint above as representing a logical gate. Boolean and arithmetic circuits are easily reducible to this form. We view a, b, c as containing the 'left', 'right', and 'output' coefficients respectively; rows index variables and columns index constraints. The zkSNARK interface. A zkSNARK consists of three algorithms: setup S , prover P, and verifier V .</p><p>• Setup. On input a R1CS instance φ = (k, N, M, a, b, c), S outputs a proving key pk and a verification key vk.</p><p>• Prover. On input a proving key pk (for an R1CS instance φ ), input x in F k , and witness w in F N−k , P outputs a proof π that attests to the x-satisfiability of φ .</p><p>• Verifier. On input a verification key vk (generated for φ ), input x in F k , and proof π, V outputs a decision bit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The zkSNARK protocol of Groth</head><p>Our system provides a distributed implementation of a zkSNARK protocol due to Groth <ref type="bibr" target="#b39">[42]</ref>. We selected Groth's protocol because it is, to our knowledge, the  <ref type="figure">Figure 2</ref>: A distributed zkSNARK. The setup algorithm is run on a compute cluster, and generates a long proving key pk, held in distributed storage, and a short verification key vk. The prover algorithm is also run on a compute cluster.</p><p>most efficient zkSNARK protocol. That said, our techniques are easily adapted to similar zkSNARK protocols <ref type="bibr" target="#b34">[37,</ref><ref type="bibr" target="#b17">20,</ref><ref type="bibr" target="#b53">55,</ref><ref type="bibr" target="#b29">32,</ref><ref type="bibr" target="#b40">43]</ref>. We now describe only the parts of Groth's protocol that are needed to understand our techniques, and refer the reader to <ref type="bibr" target="#b39">[42]</ref> for details (including correctness and security, which we inherit). For reference, we include the full protocol in <ref type="figure" target="#fig_4">Fig. 10</ref> (in the appendix) using the notation introduced in this section.</p><p>QAPs. Groth's zkSNARK protocol uses Quadratic Arithmetic Programs (QAPs) <ref type="bibr" target="#b34">[37,</ref><ref type="bibr" target="#b53">55]</ref> to efficiently express the satisfiability of R1CS instances via certain lowdegree polynomials. Essentially, the M constraints are 'bundled' into a single equation that involves univariate polynomials of degree O(M). The prover's goal is then to convince the verifier that this equation holds. In fact, it suffices for the verifier to know that this equation holds at a random point because distinct polynomials of small degree can only agree on a small number of points.</p><p>In a little more detail, we now define what is a QAP instance, and what does satisfying such an instance mean.</p><p>A QAP instance Φ over F has three parameters, the number of inputs k, number of variables N (with k ≤ N), and degree M; Φ is a tuple (k, N, M, A, B, C, D) where A, B, C are each a vector of 1 + N polynomials over F of degree &lt; M, and D is a subset of F of size M.</p><p>An input for Φ is a vector x in F k , and a witness for Φ is a pair (w, h) where w is a vector in F N−k and h is a vector in F M−1 . An input-witness pair x, (w, h) satisfies Φ if, letting z ∈ F 1+N be the concatenation of 1, x, and w:</p><formula xml:id="formula_1">∑ N i=0 A i (X)z i · ∑ N i=0 B i (X)z i = ∑ N i=0 C i (X)z i + ∑ M−2 i=0 h i X i · Z D (X) ,</formula><p>where</p><formula xml:id="formula_2">Z D (X) := ∏ α∈D (X − α).</formula><p>One can efficiently reduce R1CS instances to QAP instances <ref type="bibr" target="#b34">[37,</ref><ref type="bibr" target="#b53">55]</ref>: there is a QAP instance reduction qapI and a QAP witness reduction qapW, for which our system provides distributed implementations of both.</p><p>QAP instance reduction. For every R1CS instance</p><formula xml:id="formula_3">φ = (k, N, M, a, b, c), qapI(φ ) outputs a QAP instance Φ = (k, N, M, A, B, C, D) that preserves satisfiability: for every input x in F k , φ is x-satisfiable iff Φ is x-satisfiable.</formula><p>It works as follows: let D be a subset of F of size M and then, for each i ∈ {0, 1, . . . , N}, let A i be the polynomial of degree &lt; M that interpolates over D the i-th row of the matrix a; similar for each B i and C i in regards to b and c.</p><p>QAP witness reduction. For every witness w in</p><formula xml:id="formula_4">F N−k s.t. (x, w) satisfies φ , qapW(φ , x, w) outputs h in F M−1 s.t. (x, (w, h)) satisfies Φ.</formula><p>It works as follows: let h be the coefficients of the polynomial H(X) of degree less than M − 1 that equals the quotient of</p><formula xml:id="formula_5">(∑ N i=0 A i (X)z i ) · (∑ N i=0 B i (X)z i ) − ∑ N i=0 C i (X)z i and Z D (X)</formula><p>. Bilinear encodings. Groth's protocol uses bilinear encodings, which enable hiding secrets while still allowing for anyone to homomorphically evaluate linear functions as well as zero-test quadratic functions.</p><p>We denote by G a group, and consider only groups with a prime order p, which are generated by an element G . We use additive notation for group arithmetic: P + Q denotes addition of the two elements P and Q. Thus, s · P denotes scalar multiplication of P by the scalar s ∈ Z. Since p · P equals the identity element, we can equivalently think of a scalar s as in the field F of size p. The</p><formula xml:id="formula_6">encoding (relative to G ) of a scalar s ∈ F is [s] := s · G ; similarly, the encoding of a vector of scalars s ∈ F n is [s] := (s 1 · G , . . . , s n · G ).</formula><p>The encoding of a scalar can be efficiently computed via the double-and-add algorithm; yet (for suitable choices of G) its inverse is conjecturally hard to compute, which means that [s] hides (some) information about s. Encodings are also linearly homomorphic:</p><formula xml:id="formula_7">[αs + βt] = α[s] + β [t] for all α, β , s,t ∈ F.</formula><p>Bilinear encodings involve three groups of order p:</p><formula xml:id="formula_8">G 1 , G 2 , G 3 generated by G 1 , G 2 , G 3 respectively. The en- coding of a scalar s ∈ F in G i is [s] i := s · G i . Moreover,</formula><p>there is an efficiently computable map e :</p><formula xml:id="formula_9">G 1 × G 2 → G 3 , called pairing, that is bilinear: for every nonzero α, β ∈ F, it holds that e ([α] 1 , [β ] 2 ) = αβ · e (G 1 , G 2 ). (Also, e is non-degenerate in that e ([1] 1 , [1] 2 ) = [0] 3 .) Pairings al- low zero-testing quadratic polynomials evaluated on en- codings. For example, given [s] 1 , [t] 2 , [u] 1 , one can test if st + u = 0 by testing if e ([s] 1 , [t] 2 ) + e ([u] 1 , [1] 2 ) = [0] 3 .</formula><p>3 Design overview of DIZK <ref type="figure">Fig. 2</ref> shows the outline of DIZK's design. The setup and the prover in DIZK are modified from monolithic procedures to distributed jobs on a cluster; F, pk F , and w are stored as data structures distributed across multiple machines instead of on a single machine. The verifier remains unchanged from the vanilla protocol as it is inexpensive, enabling DIZK's proofs to be verified by existing implementations of the verifier. Spark. We implemented DIZK using Apache Spark <ref type="bibr" target="#b1">[2]</ref>, a popular cluster computing framework, though our design principles behind DIZK are applicable to other frameworks <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b32">35,</ref><ref type="bibr" target="#b42">44]</ref>. Spark consists of two components: the driver and executors. Applications are created by the driver and assigned to executors, consisting of jobs split into stages that dictate a set of tasks. Large datasets are stored as Resilient Distributed Datasets (RDDs). System interface. The interface of DIZK matches the interface of a zkSNARK for proving/verifying satisfiability of R1CS instances (see §2.2) except that large objects are represented via RDDs. More precisely:</p><p>• The setup receives an R1CS instance φ = (k, N, M, a, b, c) and outputs corresponding keys pk and vk. As instance size grows (i.e., as the number of variables N and of constraints M grow), φ and pk grow in size (linearly in N and M), so both are represented as RDDs.</p><p>• The prover receives the proving key pk, input x in F k , and witness w in F N−k . The prover outputs a proof π of constant size (128 B). As typically the input size k is small and the witness size N − k is large, we represent the input as an array and the witness as an RDD. When using DIZK in an application, the application setup needs to provide φ to the DIZK setup, and the application prover needs to provide x and w to the DIZK prover. Since these items are big, they may also need to be generated in a distributed way; we do so for our applications in §7. High-level approach. The setup and prover in serial implementations of zkSNARKs run monolithic space- intensive computations that quickly exceed memory bounds. Our approach for an efficient distributed implementation is as follows.</p><p>First, we identify the heavy computational tasks that underlie the setup and prover. In Groth's protocol these fall in three categories: (1) arithmetic (multiplication and division) for polynomials of large degree over large prime fields; (2) multi-scalar multiplication over large prime groups; (3) the QAP instance and witness reductions described in §2.3. Such computations underlie other proof systems too (see full version).</p><p>Second, we design distributed implementations of these components. While there are simple strawman designs that follow naive serial algorithms, these are too expensive (e.g., run in quadratic time); on the other hand, non-naive serial algorithms gain efficiency by leveraging large pools of memory. We explain how to distribute these memoryintensive algorithms.</p><p>Finally, we assemble the aforementioned distributed components into a distributed setup and distributed prover. This assembly poses challenges as the dataflow from one component to another requires several large-scale re-shuffles that we resolve with tailored data structures. <ref type="figure" target="#fig_0">Fig. 3</ref> presents a diagram of the main parts of the design, and we describe them in the following sections: §4 discusses how to distribute polynomial arithmetic and multi-scalar multiplication; §5 discusses how to distribute the QAP instance reduction, and how to obtain the distributed setup from it; §6 discusses how to distribute the QAP witness reduction, and how to obtain the distributed prover from it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Design: distributing arithmetic</head><p>We describe the computational tasks involving finite field and finite group arithmetic that arise in the zkSNARK, and how we distribute these tasks. These form subroutines of the distributed setup and distributed prover computations (see §5 and §6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association</head><p>27th USENIX Security Symposium 679</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Distributed fast polynomial arithmetic</head><p>The reduction from an R1CS instance φ = (k, N, M, a, b, c) to a QAP instance Φ = (k, N, M, A, B, C, D) (in the setup) and its witness reduction (in the prover) involves arithmetic on Θ(N) polynomials of degree Θ(M); see §2.3. (N is the number of variables and M is the number of constraints.)</p><p>We distribute the necessary polynomial arithmetic, allowing us to scale to N and M that are in the billions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Arithmetic from evaluation and interpolation</head><p>Fast polynomial arithmetic is well-known to rely on fast algorithms for two fundamental tasks: polynomial evaluation and interpolation. In light of this, our approach is the following: (i) we achieve distributed fast implementations of evaluation and interpolation, and (ii) use these to achieve distributed fast polynomial arithmetic such as multiplication and division.</p><p>Recall that (multi-point) polynomial evaluation is as follows: given a polynomial P(X) = ∑ n−1 j=0 c j X j over F and elements u 1 , . . . , u n in F, compute the elements P(u 1 ), . . . , P(u n ). One can do this by evaluating P at each point, costing Θ(n 2 ) field operations overall.</p><p>Conversely, polynomial interpolation is as follows: given elements u 1 , v 1 , . . . , u n , v n in F, compute the polynomial P(X) = ∑ n−1 j=0 c j X j over F such that v i = P(u i ) for every i ∈ {1, . . . , n}. One can do this by using u 1 , . . . , u n to compute the Lagrange interpolants L 1 (X), . . . , L n (X), which costs Θ(n 2 log n) field operations <ref type="bibr" target="#b69">[71]</ref>, and then output ∑ n j=1 v j L j (X), which costs another Θ(n 2 ). While both solutions are straightforward to distribute, they are too expensive due to the quadratic growth in n. We describe distributed FFT in the next section, while leaving the details of Lag to the appendix ( §4.1.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Distributed FFT</head><p>Fast Fourier Transforms (FFTs) <ref type="bibr" target="#b69">[71]</ref> provide much faster solutions, which run in time˜Otime˜ time˜O(n). For instance, the Cooley-Tukey algorithm <ref type="bibr" target="#b26">[29]</ref> solves both problems with O(n log n) field operations, provided that F has suitable algebraic structure (in our setting it does). The algorithm requires storing an array of n field elements in working memory, and performing O(log n) 'passes' on this array, each costing O(n). The structure of this algorithm can be viewed as a butterfly network since each pass requires shuffling the array according to certain memory patterns.</p><p>While the Cooley-Tukey algorithm implies a fast parallel algorithm, its communication structure is not suitable for compute clusters. At each layer of the butterfly network, half of the executors are left idle and the other half have their memory consumption doubled; moreover, each such layer requires a shuffle involving the entire array.</p><p>We take a different approach, suggested by Sze <ref type="bibr" target="#b63">[65]</ref>, who studies the problem of computing the product of terabit-size integers on compute clusters, via MapReduce.</p><p>Sze's approach requires only a single shuffle. Roughly, an FFT computation with input size n is reduced to two batches of √ n FFT computations, each on input size √ n. The first batch is computed by the mappers; after the shuffle, the second batch is computed by the reducers. We use the same approach to implement a distributed FFT, but in the setting of finite fields.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Distributed Lag</head><p>An additional task that arises (in the setup, see §5) is a problem related to polynomial evaluation that we call Lag (from 'Lagrange'): given a domain {u 1 , . . . , u n } ⊆ F and an element t ∈ F, compute the evaluation at t of all Lagrange interpolants L 1 (X), . . . , L n (X) for the domain.</p><p>A common approach to do so is via the barycentric Lagrange formula <ref type="bibr" target="#b14">[17]</ref>: compute the barycentric weights r 1 , . . . , r n as r i := 1/ ∏ j =i (u i − u j ), and then compute</p><formula xml:id="formula_10">L 1 (t), . . . , L n (t) as L i (t) := r i t−u i · L(t) where L(X) := ∏ n j=1 (X − u j ).</formula><p>When the domain is a multiplicative subgroup of the field generated by some ω ∈ F (in our setting it is), this approach results in an expression, L i (X) = ω i /n X−ω i · (X n − 1), that is cheap to evaluate. This suggests a simple but effective distributed strategy: each executor in the cluster receives the value t ∈ F and a chunk of the index space i, and uses the inexpensive formula to evaluate L i (t) for each index in that space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Distributed multi-scalar multiplication</head><p>In addition to the expensive finite field arithmetic discussed above, the setup and prover also perform expensive group arithmetic, which we must efficiently distribute.</p><p>After obtaining the evaluations of Θ(N + M) polynomials, the setup encodes these values in the groups G 1 and G 2 , performing the operations s → [s] 1 and s → [s] 2 for Θ(N + M) values of s. In contrast, the prover computes linear combinations of Θ(N + M) encodings. Again, we seek to scale to N and M that are in the billions.</p><p>These operations can be summarized as two basic computational problems within a group G of a prime order p (where scalars come from the field F of size p).</p><p>• Fixed-base multi-scalar multiplication (fixMSM).</p><p>Given a vector of scalars s in F n and element P in G, compute the vector of elements s · P in G n .</p><p>• Variable-base multi-scalar multiplication (varMSM).</p><p>Given a vector of scalars s in F n and a vector of elements</p><formula xml:id="formula_11">(P i ) n i=1 in G n , compute ∑ n i=1 s i · P i in G.</formula><p>For small n, both problems have simple solutions: for fixMSM, compute each element s i · P and output it; for varMSM, compute each s i · P i and output their sum.</p><p>In our setting, these solutions are expensive not only because n is huge, but also because the scalars are (essentially) random in F, whose cryptographically-large prime size p has k ≈ 256 bits. This means that the (average) number of group operations in these simple solutions is ≈ 1.5kn, a prohibitive cost.</p><p>Both problems can be solved via algorithms that, while being much faster, make an intensive use of memory. We next discuss our approach to efficiently distribute varMSM. We leave the discussion of distributing fixMSM to §4.2.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Distributed varMSM</head><p>An efficient algorithm for varMSM is Pippenger's algorithm <ref type="bibr" target="#b55">[57]</ref>, which is within 1 + o(1) of optimal for nearly all scalar vectors <ref type="bibr" target="#b56">[58]</ref>. In the setting of serial zkSNARKs this algorithm outperforms, by 20-30%, the popular BosCoster algorithm <ref type="bibr">[34, §4]</ref>. (Other well-known algorithms like Straus' algorithm <ref type="bibr" target="#b62">[64]</ref> and the Chang-Lou algorithm <ref type="bibr" target="#b22">[25]</ref> are not as fast on large instances; see <ref type="bibr" target="#b13">[16]</ref>.) Given scalars s 1 , . . . , s n and their bases P 1 , · · · , P n , Pippenger's algorithm chooses a radix 2 c , computes s 1 /2 c P 1 + · · · + s n /2 c P n , doubles it c times, and sums it to (s 1 mod 2 c )P 1 + · · · + (s n mod 2 c )P n . For the last step, the algorithm sorts the base elements into 2 c buckets according to (s 1 mod 2 c ), . . . , (s n mod 2 c ) (discarding bucket 0), sums the base elements in the remaining buckets to obtain intermediate sums Q 1 , . . . , Q 2 c −1 , and computes Q 1 +2Q 2 +· · ·+(2 c −1)Q 2 c −1 = (s 1 mod 2 c )P 1 + · · · + (s n mod 2 c )P n . For a suitable choice of 2 c , this last step saves computation because each bucket contains the sum of several input bases.</p><p>A natural approach to distribute Pippenger's algorithm is to set the number of partitions to 2 c and use a custom partitioner that takes in a scalar s i as the key and maps its base element b i to partition (s i mod 2 c ). While this approach is convenient, we find in practice that the cost of shuffling in this approach is too high. Instead, we find it much faster to merely split the problem evenly across executors, run Pippenger's algorithm serially on each executor, and combine the computed results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Distributed fixMSM</head><p>Efficient algorithms for fixMSM use time-space tradeoffs <ref type="bibr" target="#b20">[23]</ref>. Essentially, one first computes a certain look-up table of multiples of P, and then uses it to compute each s i · P. As a simple example, via log |F| group operations, one can compute the table (P, 2 · P, 4 · P, . . . , 2 log |F| · P), and then compute each s i · P with only log |F|/2 group operations (on average). More generally one can increase the 'density' of the look-up table and further reduce the time to compute each s i · P. As n increases, it is better for the look-up table to also grow, but larger tables require more memory to store them.</p><p>A natural approach to distribute this workload across a cluster is to evenly divide the n scalars among the set of executors, have each executor build its own in-memory look-up table and perform all assigned scalar multiplications aided by that table, and then assemble the output from all executors. However, this approach does not fit Spark because each executor receives many 'partitions' and these cannot hold shared references to local results previously computed by the executor. Instead, we let a single executor (the driver) build the look-up table and broadcast it to all other executors. Each executor receives this table and an even distribution of the scalars, and computes all its assigned scalar multiplications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Distributing the zkSNARK setup</head><p>The zkSNARK setup receives as input an R1CS instance φ = (k, N, M, a, b, c) and produces a proving key pk and a verification key vk.</p><p>Informally, the protocol has three stages: (i) evaluate the polynomials A, B, C at a random element t, where A, B, C are from the QAP instance Φ = (k, N, M, A, B, C, D) corresponding to φ ; (ii) compute certain random linear combinations of these; (iii) compute encodings of corresponding vectors. The second stage is straightforward to distribute, and the third stage is an instance of fixMSM (see §4.2.2). Thus here we discuss efficient distribution of the first stage only.</p><p>Recall from the QAP instance reduction (in §2.3) that A = (A 0 , . . . , A N ) where A i is the polynomial of degree &lt; M that interpolates over D the i-th row of the matrix a; similarly for each B and C with regard to b and c. Focusing on a for simplicity and letting L 1 , . . . , L M be the Lagrange interpolants for the set D (i.e., L j evaluates to 1 at the j-th element of D and to 0 everywhere else in D), the task we need to solve in a distributed way is:</p><formula xml:id="formula_12">in: a ∈ F (1+N)×M and t ∈ F out: (A i (t)) N i=0 where A i (t) := ∑ M j=1 a i, j L j (t)</formula><p>The parameters N and M are big enough such that no single machine can store any vector of length N or M.</p><p>In both serial zkSNARK systems and in our distributed system, the first step is to compute (L j (t)) M j=1 . We do so via the distributed Lag protocol described in §4.1.3, which computes and stores (L j (t)) M j=1 in an RDD. We now focus on the remainder of the task.</p><p>A key property of the matrix a exploited in serial zk-SNARK systems is its sparsity; that is, a contains very few non-zero entries. This enables the serial algorithm to iterate through every nonzero a i, j , look up the value L j (t), and add a i, j L j (t) to the i-th entry in A(t). Distributing this approach in the natural way, however, results in a solution that is both inefficient in time and cannot scale to large N and M, as discussed next.</p><p>Strawman. Represent a = (a i, j ) i, j and (L j (t)) j as two RDDs and perform the following computations: 1. Join the set (a i, j ) i, j with the set (L j (t)) j by index j. 2. Map each pair (a i, j , L j (t)) to its product a i, j L j (t).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Reduce the evaluations by</head><formula xml:id="formula_13">i to get (∑ M j=1 a i, j L j (t)) N i=0 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association 27th USENIX Security Symposium 681</head><p>When running this computation, we encounter notable issues at every step: the set of joined pairs (a i, j , L j (t)) is unevenly distributed among executors, the executors take drastically differing amounts of time to perform the pair evaluations, and a small set of executors quickly exceed memory bounds from insufficient heap space.</p><p>Our problems lie in that, while the matrix a is sparse, its columns are merely almost sparse: most columns are sparse, but a few are dense. This occurs when in an R1CS instance φ some constraints "touch" many variables. This is not a rarity, but a common occurrence in typical constraint systems. E.g., consider the basic linear-algebraic operation of computing the dot product between a large variable vector and a large constant vector. The single constraint in φ that captures this dot product has as many variables as the number of non-zero constants in the constant vector, inducing a dense column.</p><p>The default (hash-based) partitioner of the join algorithm maps all entries in a column to the same executor, resulting in executors for dense columns becoming stragglers. While there exist alternative join algorithms to handle load imbalances, like blockjoin and skewjoin <ref type="bibr">[6]</ref>, these do not perform well, as we now explain.</p><p>First, blockjoin replicates each entry in one RDD (the one for (L j (t)) j ) in the hopes that when joining with the other RDD (the one for (a i, j ) i, j ) the partitions will be more evenly distributed. However, in our setting we cannot afford blowing up the size of the first RDD.</p><p>Second, skewjoin takes a more fine-grained approach, by computing statistics of the second RDD and using it to calculate the replication factor for each entry in the first RDD. While the memory footprint is smaller, it remains undesirable.</p><p>A problem in both approaches is that replicating entries entails changing the keys of the two RDDs, by first adding counters to each key before joining and then removing these after joining. Each of these changes requires expensive shuffles to relocate keys to the correct partitions based on their hash. A second inefficiency comes from performing a single monolithic join on the two (modified) RDDs, costing significant working memory.</p><p>We circumvent all these problems via systematic twopart solution tailored to our setting, as described below. (And only briefly mention that the foregoing skewjoin approach does not scale beyond 50 million constraints on even 128 executors and is twice as slow as our solution.) Part 1: identify dense vectors. Before running the setup, DIZK runs a lightweight, distributed computation to identify the columns that have many non-zero elements and annotates them for Part 2. Using a straightforward map and reduce computation would also result in stragglers because of the dense columns. DIZK avoids stragglers as follows. Suppose that the matrix a is stored as an RDD with partitions. First, DIZK assigns each partition to a random executor. Second, each executor computes, for every column j, the number of non-zero elements it receives. Third, the executors run a shuffle, during which the elements for the same column go to the same executor. Finally, each executor computes the final count for its assigned columns. Thus even dense columns will have at most values to aggregate, avoiding stragglers.</p><p>DIZK identifies which columns have more than a threshold of non-zero elements and annotates them for Part 2. We heuristically set the threshold to be √ M. As a is overall sparse, there are not many dense constraints.</p><p>Let J a be the set of indices j identified as dense. Part 2: employ a hybrid solution. DIZK now executes two jobs: one for the few dense columns, and one for the many sparse columns. The first computation filters each dense column into multiple partitions, so that no executor deals with an entire dense column but only with a part of it, and evaluates the joined pairs. The second computation is the strawman above, limited to indices not in J a . We do so without having to re-key RDDs or incur any replication. In more detail, the computation is:</p><p>1. For all dense column indices j ∈ J a :</p><p>(a) filter a by index j to obtain column a j as an RDD; (b) join the RDD (a i, j ) i, j with L j (t) for j;</p><formula xml:id="formula_14">(c) map each pair (a i, j , L j (t)) to its product a i, j L j (t). 2. Join the set (a i, j ) i, j / ∈J a with L j (t) by index j. 3. Map each pair (a i, j , L j (t)) to its evaluation a i, j L j (t). 4. Union (a i, j L j (t)) j∈J a with (a i, j L j (t)) j / ∈J a . 5.</formula><p>Reduce all a i, j L j (t) by i to get (A i (t)) N i=0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Distributing the zkSNARK prover</head><p>The zkSNARK prover receives a proving key pk, input x in F k , and witness w in F N−k , and samples a proof π. The protocol has two stages: (i) extend the x-witness w for the R1CS instance φ to a x-witness (w, h) for the QAP instance Φ; (ii) use x, w, h and additional randomness to compute certain linear combinations of pk. The second stage is an instance of varMSM (see §4.2.1). Thus here we discuss efficient distribution of the first stage only.</p><p>Recall from the QAP witness reduction (in §2.3) that h is the vector of coefficients of the polynomial H(X) of degree less than M − 1 that equals the ratio</p><formula xml:id="formula_15">(∑ N i=0 A i (X)z i ) · (∑ N i=0 B i (X)z i ) − ∑ N i=0 C i (X)z i Z D (X)</formula><p>. Let us focus for simplicity on computing the evaluation of the polynomial A z (X) := ∑ N i=0 A i (X)z i on D, which is one of the terms in the numerator. Since the evaluation of A i on D equals the i-th row of a, the task that needs to be solved in a distributed way is the following.</p><formula xml:id="formula_16">in: a ∈ F (1+N)×M and z ∈ F 1+N out: (∑ N i=0 a i, j z i ) M j=1</formula><p>Again, the parameters N and M are huge, so no single machine can store an array with N or M field elements.</p><p>Strawman. Encode a = (a i, j ) i, j and z = (z i ) i as two RDDs and perform the following distributed computation:</p><p>1. Join the set (a i, j ) i, j and the set (z i ) i by the index i.</p><p>2. Map each (a i, j , z i ) pair to their product a i, j z i .</p><p>3. Reduce the evaluations by index j to get</p><formula xml:id="formula_17">(∑ N i=0 a i, j z i ) M j=1</formula><p>. When running this computation, we ran into a stragglers problem that is the converse of that described in §5: while matrix a is sparse, its rows are almost sparse because, while most rows are sparse, some rows are dense. The join overloaded the executors assigned to dense rows. The reason underlying the problem is also the converse: some variables participate in many constraints. This situation too is a common occurrence in R1CS instances. For example, the constant value 1 is used often (e.g., every constraint capturing boolean negations) and this constant appears as an entry in z.</p><p>Generic solutions for load imbalances like skewjoin <ref type="bibr">[6]</ref> were not performant for the same reasons as in §5. Our approach. We solve this problem via a two-part solution analogous to that in §5, with the change that the computation is now for rows instead of columns. The dense vectors depend on the constraints alone so they do not change during proving, even for different inputs x. Hence, Part 1 runs once during setup, and not again during proving (only Part 2 runs then).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Applications</head><p>We study two applications for our distributed zkSNARK: (1) authenticity of edited photos <ref type="bibr" target="#b51">[53]</ref> (see §7.1); and (2) integrity of machine learning models (see §7.2). In both cases the application consists of algorithms for two tasks. One task is expressing the application predicate as an R1CS instance, which means generating a certain set of constraints (ideally, as small as possible) to pass as input to the setup. The other task is mapping the application inputs to a satisfying assignment to the constraints, to pass as input to the prover.</p><p>Recall that our distributed zkSNARK expects the R1CS instance (set of constraints) and witness (assignment) to be distributed data structures (see §3). In both applications, we distribute the constraint generation and witness generation across multiple machines, which for sufficiently large instance sizes, confers greater efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Authenticity of photos</head><p>Authenticity of photos is crucial for journalism and crime investigations but is difficult to ensure due to powerful digital editing tools. A recent paper, PhotoProof <ref type="bibr" target="#b51">[53]</ref>, proposes an approach that relies on a combination of special signature signing cameras and zkSNARKs to prove, in zero knowledge, that an edited image was obtained from a signed (and thus valid) input image only according to a set of permissible transformations. More precisely, the camera actually signs a commitment to the input image, and this commitment and signature also accompany the edited image, and thus can be verified separately.</p><p>We benchmark our system on this application because the original PhotoProof relies on monolithic zkSNARK implementations and is thus limited to small photo sizes. Our system's scalability allows for proofs of relatively large images (see §11). Below we describe the three transformations that we implemented: crop, rotation, and blur; the first two are also implemented in <ref type="bibr" target="#b51">[53]</ref>, while the third one is from <ref type="bibr" target="#b47">[49]</ref>. Throughout, we consider images of dimension r × c that are black and white, which means that each pixel is an integer between 0 and 255; we represent such an image as a list of rc field elements each storing a pixel. Our algorithms can be extended to color images via RGB representation, but we do not do so in this work.</p><p>Crop. The crop transformation is specified by a r × c mask and maps an input r × c image into an output r × c image by keeping or zeroing out each pixel according to the corresponding bit in the mask. This choice is realized via a MUX gadget controlled by the mask's bit. We obtain that the number of constraints is rc and the number of variables is 3rc. In our implementation, we distribute the generation of constraints and variable assignment by individually processing blocks of pixels.</p><p>Rotation. The rotation transformation is specified by an angle θ ∈ [0, π/4] and maps a pixel in position (x, y) to cos θ − sin θ sin θ cos θ (x, y); this rotates the image by angle θ around (0, 0). Some pixels go outside the image and are thus lost, while new pixels appear and are set to zero.</p><p>We follow the approach of <ref type="bibr" target="#b51">[53]</ref>, and use the method of rotation by shears <ref type="bibr" target="#b52">[54]</ref>, which uses the identity cos θ − sin θ</p><formula xml:id="formula_18">sin θ cos θ = 1 − tan(θ /2) 0 1 1 0 sin θ 1 1 − tan(θ /2) 0 1 .</formula><p>The first is a shear by row, the second a shear by column, and the third again a shear by row. Each shear is performed by individually invoking a barrel shifter to every row or column, with the correct offset. For more details on how to compute the offsets and the shear transformations, please refer to the full version.</p><p>In our implementation, we distribute the generation of constraints and variable assignment by distributing each shear, which can be done by generating each barrel shifter's constraints and variable assignment in parallel. Blur. The blur transformation is specified by a position (x, y), height u, and width v; it maps an input r × c image into an output r × c image in which Gaussian blur has been applied to the u × v rectangle whose bottomleft corner is at (x, y). More precisely, we approximate Gaussian blur via three sequential box blurs, which are further reduced to six directional blurs <ref type="bibr" target="#b47">[49]</ref>. To realize this transformation as constraints, we need to verify, for each of the uv positions in the selected region and for each of the 6 directional blurs, that the new pixel is the correct (rounded) average of the 2r + 1 pixels in the old image. For more details on the algorithm, please refer to the full version.</p><p>In our implementation, since the value of each new pixel only depends on several surrounding pixels, we distribute the generation of constraints and witnesses by pixel blocks in the selected region.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Integrity of machine learning models</head><p>Suppose that a hospital owns sensitive patient data, and a researcher wishes to build a (public) model by running a (public) training algorithm on this sensitive data. The hospital does not want (or legally cannot) release the data; on the other hand, the researcher wants others to be able to check the integrity of the model. One way to resolve this tension is to have the hospital use a zkSNARK to prove that the model is the output obtained when running it on the sensitive data. <ref type="bibr" target="#b0">1</ref> In this paper, we study two operations: linear regression and covariance matrix calculation (an important subroutine for classification). Both rely on linear algebraic operations that are simple to express as constraints and to distribute across machines. Linear regression. Least-squares linear regression is a popular supervised machine learning training algorithm that models the relationship between variables as linear. The input is a labeled dataset D = (X,Y ) where rows of X ∈ R n×d and Y ∈ R n×1 are the observations' independent and dependent variables. Assuming that Xw ≈ Y for some w ∈ R d×1 , the algorithm's goal is to find such a w that minimizes the mean squared-error loss. The solution to the optimization problem is w = (X T X) −1 X T Y .</p><p>While the formula to compute w uses a matrix inversion, one can easily check correctness of w by verifying that X T Xw = X T y. The problem is thus reduced to checking matrix multiplications, which can be easily expressed and distributed as we now describe.</p><p>We generate the constraints and variable assignments by following a distributed block-based algorithm for matrix multiplication <ref type="bibr" target="#b21">[24,</ref><ref type="bibr" target="#b48">50,</ref><ref type="bibr" target="#b68">70]</ref>. Such an algorithm splits the output matrix into blocks, and assigns and shuffles the data needed to generate each block to the same machine. Each block can independently generate its constraints and variable assignments after receiving the necessary values. This simple approach works well for us because memory usage is dominated by the number of constraints and variables rather than the size of the input/output matrices.</p><p>Covariance matrix. Computing covariance matrices is an important subroutine in classification algorithms such as Gaussian naive Bayes and linear discriminant analysis <ref type="bibr" target="#b15">[18]</ref>. These algorithms classify observations into discrete classes by constructing a probability distribution for each class. This reduces to computing the mean and covariance matrix for each class of sample points.</p><p>Suppose that</p><formula xml:id="formula_19">{x i ∈ R d×1 } i=1.</formula><p>.n is an input data set from a single class. Its covariance matrix is M :</p><formula xml:id="formula_20">= 1 n−1 ∑ n i=1 (x i − ¯ x)(x i − ¯ x) T ∈ R d×d , where ¯ x := ( 1 n ∑ n i=1 x i ) ∈ R d×1</formula><p>is the average of the n observations.</p><p>To verify M, we first check the correctness of ¯ x by individually checking each of the d entries; for each entry we use the same approach as in the case of blur (in §7.1). Then, we check correctness of each matrix multiplication (x i − ¯ x)(x i − ¯ x) T , using the same distribution technique from linear regression. Finally, we check correctness of the 'average' of the n resulting matrices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Implementation</head><p>We implemented the distributed zkSNARK in ≈ 10K lines of Java code over Apache Spark <ref type="bibr" target="#b1">[2]</ref>, a popular cluster computing framework. All data representations are designed to fit within the Spark computation model. For example, we represent an R1CS instance φ = (k, N, M, a, b, c) via three RDDs, one for each of the three matrices a, b, c, and each record in an RDD is a tuple <ref type="figure">( j, (i, v)</ref>) where v is the (i, j)-th entry of the matrix. (Recall from §2.2 that a, b, c are coefficient matrices that determine all constraints of the instance.) Since DIZK deals with large instances, we carefully adjust the RDD partition size such that each partition fits on an executor's heap space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Experimental setup</head><p>We evaluated DIZK on Amazon EC2 using r3.large instances (2 vCPUs, 15 GiB of memory) and r3.8xlarge instances (32 vCPUs, 244 GiB of memory). For singlemachine experiments, we used one r3.large instance.</p><p>For distributed experiments, we used a cluster of ten r3.8xlarge instances for up to 128 executors, and a cluster of twenty r3.8xlarge for 256 executors.</p><p>We instantiate the zkSNARK via a 256-bit BarretoNaehrig curve <ref type="bibr" target="#b5">[8]</ref>, a standard choice in prior zkSNARK implementations. This means that G 1 and G 2 are elliptic curve groups of a prime order p of 256 bits, and the scalar field F has this same size.</p><p>An important technicality is that we cannot rely on curves used in prior zkSNARK works, because they do not support the large instance sizes in this work, as we now explain. To allow for efficient implementations of the setup and the prover one needs a curve in which the group order p is such that p − 1 is divisible by 2 a , where 2 a is larger than the maximum instance size to be supported <ref type="bibr" target="#b8">[11]</ref>. As the instance sizes that we support are in the billions (at least 2 30 ), we need, say, a ≥ 40.</p><p>We thus generated (by modifying the sampling algorithm in <ref type="bibr" target="#b5">[8]</ref>) a 256-bit Barreto-Naehrig curve with a = 50, which suffices for our purposes. The curve is E/F q : y 2 = x 3 + 13 with q = 178558083348049028502 609238317702557737797405798625193380108245358 56509878273, and its order is p = 17855808334804902 850260923831770255773646114952324966112694569 107431857586177.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Evaluation of the distributed zkSNARK</head><p>We evaluated our distributed zkSNARK and show that: 1. We support instances of more than a billion gates, a significant improvement over serial implementations, which exceed memory bounds at 10-20 million gates. 2. Fixing a number of executors on the cluster and letting the instance size increase (from several millions to over a billion), the running time of the setup and prover increases close to linearly as expected, demonstrating scalability over this range of instance sizes. 3. Fixing an input size and increasing the number of executors, the running time of the setup and prover decreases close to linearly as expected, demonstrating parallelization over this range of executors. In the next few sub-sections we support these findings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.1">Evaluation of the setup and prover</head><p>We evaluate our distributed implementation of the zk-SNARK setup and prover. Below we use 'instance size' to denote the number of constraints M in a R1CS instance. <ref type="bibr" target="#b1">2</ref> First, we measure the largest instance size (as a power of 2) that is supported by:</p><p>• the serial implementation of Groth's protocol <ref type="bibr" target="#b57">[59]</ref>, a state-of-the-art zkSNARK library; and • our distributed implementation of the same protocol. (Also, we plot the same for the serial implementation of PGHR <ref type="bibr" target="#b53">[55]</ref>'s protocol in libsnark, a common zk-SNARK choice.) Data from our experiments, reported in <ref type="figure">Fig. 4</ref>, shows that using more executors allows us to support larger instance sizes, in particular supporting billions of constraints with sufficiently many executors. Instances of this size are much larger than what was previously possible via serial techniques.</p><p>Next, we measure the running time of the setup and the prover on an increasing number of constraints and with an increasing number of executors. Data from our experiments, reported in <ref type="figure" target="#fig_2">Fig. 5</ref>, shows that (a) for a given number of executors, running times increase nearly linearly as expected, demonstrating scalability over a wide range of instance sizes; (b) for a given instance size, running times decrease nearly linearly as expected, demonstrating parallelization over a wide range of number of executors.</p><p>Finally, we again stress that we do not evaluate the zk-SNARK verifier because it is a simple and fast algorithm that can be run even on a smartphone. Thus, we simply use libsnark's implementation of the verifier <ref type="bibr" target="#b57">[59]</ref>, whose running time is ≈ 2 ms + 0.5 µs · k where k is the number of field elements in the R1CS input (not a large number in typical applications).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2">Evaluation of the components</head><p>We separately evaluate the performance and scalability of key components of our distributed SNARK implementation: the field algorithms for Lag and FFT ( §10.2.1) and group algorithms for fixMSM and varMSM ( §10.2.2). We single out these components since they are starting points to distribute other similar proof systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2.1">Field components: Lag and FFT</head><p>We evaluate our implementation of distributed algorithms for Lag (used in the setup) and FFT (used in the prover). For the scalar field F, we measure the running time, for an increasing instance size and increasing number of executors in the cluster. Data from our experiments, reported in <ref type="figure">Fig. 6</ref>, shows that our implementation behaves as desired: for a given number of executors, running times increase close to linearly in the instance size; also, for a given instance size, running times decrease close to linearly as the number of executors grow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2.2">Group components: fixMSM and varMSM</head><p>We evaluate our implementation of distributed algorithms for fixMSM (used in the setup) and varMSM (used in the prover). For each of the elliptic-curve groups G 1 and G 2 , we measure the total running time, for increasing instance size and number of executors in the cluster. Data  from our experiments, reported in <ref type="figure">Fig. 7</ref>, shows that our implementation behaves as desired: for a given number of executors, running times increase close to linearly in the instance size; also, for a given instance size, running times decrease close to linearly in the number of executors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.3">Effectiveness of our techniques</head><p>We ran experiments (32 and 64 executors for all feasible instances) comparing the performance of the setup and prover with two implementations: (1) the implementation that is part of DIZK, which has optimizations described in the design sections ( §4, §5, §6); and (2) an implementation that does not employ these optimizations (e.g., uses skewjoin instead of our solution, and so on). Our data established that our techniques allow achieving instance sizes that are 10 times larger, at a cost that is 2-4 times faster in the setup and prover.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">Evaluation of applications</head><p>We evaluated the performance of constraint and witness generation for the applications described in §7. <ref type="figure">Fig. 9</ref> shows, for various instances of our applications, the number of constraints and the performance of constraint and witness generation. In all cases, witness generation is markedly more expensive than constraint generation due to data shuffling. Either way, both costs are insignificant when compared to the corresponding costs of the SNARK setup and prover. Hence, we did not try to optimize this performance further. <ref type="figure">Fig. 8</ref> shows the scaling behavior of constraint and witness generation for one application, linear regression. <ref type="figure">Fig. 8a</ref> and <ref type="figure">Fig. 8b</ref> show the time for constraint and witness generation when fixing the number of executors and increasing the instance size (as determined by the number of constraints); the graphs show that time scales nearly linearly, which means that the algorithm parallelizes well with respect to instance size. <ref type="figure">Fig. 8c</ref> and <ref type="figure">Fig. 8d</ref> show the time for constraint and witness generation when fixing the instance size and increasing the number of executors; the graphs show that the system scales well as the number of executors are increased (at some point, a fixed overhead dominates, so the time flattens out).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12">Related work</head><p>Optimization and implementation of proof systems. Recent years have seen beautiful works that optimize and implement information-theoretic and cryptographic proof systems. These proof systems enable a weak verifier (e.g., a mobile device) to outsource an expensive computation to a powerful prover (e.g., a cloud provider). For example, doubly-efficient interactive proofs for parallel computation <ref type="bibr" target="#b37">[40]</ref> have been optimized and implemented in software <ref type="bibr" target="#b27">[30,</ref><ref type="bibr" target="#b66">68,</ref><ref type="bibr" target="#b64">66,</ref><ref type="bibr" target="#b65">67,</ref><ref type="bibr" target="#b75">77]</ref> and hardware <ref type="bibr" target="#b71">[73,</ref><ref type="bibr" target="#b72">74]</ref>. Also, batch arguments based on Linear PCPs <ref type="bibr" target="#b43">[45]</ref> have attained remarkable efficiency <ref type="bibr" target="#b58">[60,</ref><ref type="bibr" target="#b60">62,</ref><ref type="bibr" target="#b61">63,</ref><ref type="bibr" target="#b59">61,</ref><ref type="bibr" target="#b70">72,</ref><ref type="bibr" target="#b19">22]</ref>.</p><p>Some proof systems, such as zkSNARKs, also provide zero knowledge, which is important for applications <ref type="bibr" target="#b30">[33,</ref><ref type="bibr" target="#b7">10,</ref><ref type="bibr" target="#b73">75,</ref><ref type="bibr" target="#b28">31,</ref><ref type="bibr" target="#b44">46,</ref><ref type="bibr" target="#b45">47,</ref><ref type="bibr" target="#b51">53,</ref><ref type="bibr" target="#b33">36]</ref>. Approaches to construct zkSNARKs include using PCPs <ref type="bibr" target="#b50">[52,</ref><ref type="bibr" target="#b10">13]</ref> or Linear PCPs <ref type="bibr" target="#b38">[41,</ref><ref type="bibr" target="#b49">51,</ref><ref type="bibr" target="#b17">20,</ref><ref type="bibr" target="#b34">37]</ref>. An implementation following the first approach has been attained <ref type="bibr" target="#b6">[9]</ref>, but most other implementations follow the second approach <ref type="bibr" target="#b53">[55,</ref><ref type="bibr" target="#b8">11,</ref><ref type="bibr" target="#b12">15,</ref><ref type="bibr" target="#b46">48,</ref><ref type="bibr" target="#b76">78,</ref><ref type="bibr" target="#b28">31]</ref>. The zkSNARK setup and prover in prior implementations run on a single machine.</p><p>Some recent work explores zero knowledge proofs based not on probabilistic checking techniques and do not offer constant-size proofs, but whose provers are cheaper (and need no setup). See <ref type="bibr" target="#b36">[39]</ref> and references therein.</p><p>Proof systems &amp; distributed systems. While prior work does not distribute the prover's computation across a cluster, some prior work did show how even monolithic provers can be used to prove correct execution of distributed computations. For example, the system Pantry <ref type="bibr" target="#b19">[22]</ref> transforms a proof system such as a batch argument or a zkSNARK into an interactive argument for outsourcing MapReduce computations (though it does not preserve zero knowledge). Also, the framework of Proof-Carrying Data <ref type="bibr" target="#b23">[26,</ref><ref type="bibr" target="#b24">27]</ref> allows reasoning, and proving the correctness of, certain distributed computations via the technique of recursive proof composition on SNARKs. This technique can be used to attain zkSNARKs for MapReduce <ref type="bibr" target="#b25">[28]</ref>, and also for 'breaking up' generic computation into sub-computations while proving each correct <ref type="bibr" target="#b11">[14,</ref><ref type="bibr" target="#b28">31]</ref>.</p><p>Our work is complementary to the above approaches: prior work can leverage our distributed zkSNARK (instead of a 'monolithic' one) to feasibly support larger instance sizes. For instance, Pantry can use our distributed zkSNARK as the starting point of their transformation.</p><p>Trusted hardware. If one assumes trusted hardware, achieving 'zero knowledge proofs', even ones that are short and cheap to verify, is easier. For example, trusted hardware with attested execution (e.g. Intel SGX) suffices <ref type="bibr" target="#b67">[69,</ref><ref type="bibr" target="#b54">56]</ref>. DIZK does not assume trusted hardware, and thus protects against a wider range of attackers at the prover than these approaches.</p><p>While we are excited about scaling to larger circuits, zkSNARKs continue to suffer from important limitations.</p><p>First, even if DIZK enables using zkSNARKs for much larger circuits than what was previously possible, doing so is still very expensive (we resort to using a compute cluster!) and so scaling to even larger sizes (say, hundreds of billions of gates) requires resources that may even go beyond those of big clusters. Making zkSNARKs more efficient overall (across all circuit sizes) remains a challenging open problem.</p><p>Second, the zkSNARKs that we study, like most other 'practical' ones, require a trusted party to run a setup procedure that uses secret randomness to sample certain public parameters. This setup is needed only once per circuit, but its time and space costs also grow with circuit size. While DIZK does provide an efficient distributed setup (in addition to the same for the prover), performing this setup in practice is challenging due to many real-world security concerns. Currently-deployed zkSNARKs have relied on Secure Multi-party Computation "ceremonies" for this <ref type="bibr" target="#b9">[12,</ref><ref type="bibr" target="#b18">21]</ref>, and it remains to be studied if those techniques can be distributed by building on our work.</p><p>Our outlook is optimistic as the area of efficient proof systems sees tremendous progress <ref type="bibr" target="#b74">[76]</ref>, not only in terms of real-world deployment <ref type="bibr" target="#b4">[7]</ref> but also for zkSNARK constructions that, while still somewhat expensive, rely only on public randomness (no setup is needed) <ref type="bibr" target="#b10">[13,</ref><ref type="bibr" target="#b6">9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="14">Conclusion</head><p>We design and build DIZK, a distributed zkSNARK system. While prior systems only support circuits of up to 10-20 million gates (at a cost of 1 ms per gate in the prover), DIZK leverages the combined CPU and memory resources in a cluster to support circuits of up to billions of gates (at a cost of 10 µs per gate in the prover). This is a qualitative leap forward in the capabilities zkSNARKs, a recent cryptographic tool that has garnered much academic and industrial interest.</p><p>Setup. The setup S receives an R1CS instance φ = (k, N, M, a, b, c) and then samples a proving key pk and a verification key vk as follows. First, S reduces the R1CS instance φ to a QAP instance Φ = (k, N, M, A, B, C, D) by running the algorithm qapI. Then, S samples random elements t, α, β , γ, δ in F (this is the randomness that must remain secret). After that, S evaluates the polynomials in A, B, C at the element t, and computes Finally, the setup algorithm computes encodings of these elements and outputs pk and vk defined as follows:</p><formula xml:id="formula_21">pk := [α] 1 , [β ] 1 , [δ ] 1 [β ] 2 , [δ ] 2 , [A(t)] 1 , [B(t)] 1 [B(t)] 2 , [K pk (t)] 1 [Z(t)] 1 , vk :=(e (α, β ) , [γ] 2 , [δ ] 2 , [K vk (t)] 1 ) .</formula><p>Prover. The prover P receives a proving key pk, input x in F k , and witness w in F N−k , and then samples a proof π as follows. First, P extends the x-witness w for the R1CS instance φ to a x-witness (w, h) for the QAP instance Φ by running the algorithm qapW. Then, P samples random elements r, s in F (this is the randomness that imbues the proof with zero knowledge). Next, letting z := 1xw, P computes three encodings obtained as follows</p><formula xml:id="formula_22">[A r ] 1 :=[α] 1 + N ∑ i=0 z i [A i (t)] 1 + r[δ ] 1 , [B s ] 1 :=[β ] 1 + N ∑ i=0 z i [B i (t)] 1 + s[δ ] 1 [B s ] 2 :=[β ] 2 + N ∑ i=0 z i [B i (t)] 2 + s[δ ] 2 .</formula><p>Then P uses these two compute a fourth encoding:</p><formula xml:id="formula_23">[K r,s ] 1 := s[A r ] 1 + r[B s ] 1 − rs[δ ] 1 + N ∑ i=k+1 z i [K pk i (t)] 1 + M−2 ∑ j=0 h j [Z j (t)] 1 .</formula><p>The output proof is π :</p><formula xml:id="formula_24">= ([A r ] 1 , [B s ] 2 , [K r,s ] 1 ).</formula><p>Verifier. The verifier V receives a verification key vk, input x in F k , and proof π, and, letting x 0 := 1, checks that the following holds: </p><formula xml:id="formula_25">e ([A r ] 1 , [B s ] 2 ) = e (α, β ) +e k ∑ i=0 x i [K vk i (t)] 1 , [γ] 2 + e ([K r,s ] 1 , [δ ] 2 ) .</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Distributed setup and prover (and subcomponents).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>This polynomial division can be achieved by: (a) choos- ing a domain D disjoint from D of size M (so that the denominator Z D (X) never vanishes on D , avoiding divi- sions by zero); (b) computing the component-wise ratio of the evaluations of the numerator and denominator on D and then interpolating the result. Below we discuss how to evaluate the numerator on D because the same problem for the denominator is not hard since Z D (X) is a sparse polynomial (for suitably chosen D). The evaluation of the numerator on D is computed by first evaluating the numerator on D, and then using FFT techniques to convert this evaluation into an evaluation on the disjoint domain D (run an inverse FFT on D and a forward FFT on D ∪ D ). The second part is done via a distributed FFT ( §4.1.2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Setup and prover running times for different combinations of instance size and number of executors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>K</head><label></label><figDesc>vk (t) := β A i (t) + αB i (t) + C i (t) γ i=0,...,k K pk (t) := β A i (t) + αB i (t) + C i (t) δ i=k+1,...,N and Z(t) := t j Z D (t) δ j=0,...,M−2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: The zkSNARK setup, prover, and verifier of Groth [42] (using notation from §2.3).</figDesc></figure>

			<note place="foot" n="1"> More precisely, the hospital also needs to prove that the input data is consistent, e.g., with some public commitment that others trust is a commitment to the hospital&apos;s data. This can be a very expensive computation to prove, but we do not study it in this paper since hashbased computations have been studied in many prior works, and we instead focus on the machine learning algorithms. In a real-world application both computations should be proved.</note>

			<note place="foot" n="2"> The number of variables N also affects performance, but it is usually close to M and so our discussions only mention M with the understanding that N ≈ M in our experiments. The number of inputs k in an R1CS instance is bounded by the number of variables N, and either way does not affect the setup&apos;s and prover&apos;s performance by much; moreover, k is much, much smaller than N in typical applications and so we do not focus on it.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors are grateful to Jiahao Wang for participating in early stages of this work. This work was supported by the Intel/NSF CPS-Security grants #1505773 and #20153754, the UC Berkeley Center for Long-Term Cybersecurity, and gifts to the RISELab from Amazon, Ant Financial, CapitalOne, Ericsson, GE, Google, Huawei, IBM, Intel, Microsoft, and VMware. The authors thank Amazon for donating compute credits to RISELab, which were extensively used in this project.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Apache</forename><surname>Hadoop</surname></persName>
		</author>
		<ptr target="http://hadoop.apache.org/" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Apache</forename><surname>Spark</surname></persName>
		</author>
		<ptr target="http://spark.apache.org/" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Morgan Quorum</surname></persName>
		</author>
		<ptr target="https://www.jpmorgan.com/country/US/EN/Quorum" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Qed-It</surname></persName>
		</author>
		<ptr target="http://qed-it.com/" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zcash</forename><surname>Company</surname></persName>
		</author>
		<ptr target="https://z.cash/" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Pairingfriendly elliptic curves of prime order</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S L M</forename><surname>Barreto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Naehrig</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Selected Areas in Cryptography</title>
		<meeting>the 12th International Conference on Selected Areas in Cryptography</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="319" to="331" />
		</imprint>
	</monogr>
	<note>SAC&apos;05</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Computational integrity with a public random string from quasilinear PCPs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben-Sasson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bentov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gabi-Zon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hamilis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Perga-Ment</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Riabzev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Virza</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<idno>EURO- CRYPT &apos;17</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th Annual International Conference on Theory and Application of Cryptographic Techniques</title>
		<meeting>the 36th Annual International Conference on Theory and Application of Cryptographic Techniques</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="551" to="579" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Decentralized anonymous payments from Bitcoin</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben-Sasson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Garman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Miers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Virza</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zerocash</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2014 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="459" to="474" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">SNARKs for C: Verifying program executions succinctly and in zero knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben-Sasson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Virza</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd Annual International Cryptology Conference</title>
		<meeting>the 33rd Annual International Cryptology Conference</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="90" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Secure sampling of public parameters for succinct zero knowledge proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben-Sasson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Virza</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th IEEE Symposium on Security and Privacy</title>
		<meeting>the 36th IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="287" to="304" />
		</imprint>
	</monogr>
	<note>S&amp;P &apos;15</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Interactive oracle proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben-Sasson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Spooner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th Theory of Cryptography Conference</title>
		<meeting>the 14th Theory of Cryptography Conference</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="31" to="60" />
		</imprint>
	</monogr>
	<note>TCC &apos;16-B</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Scalable zero knowledge via cycles of elliptic curves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben-Sasson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Virza</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2014/595" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual International Cryptology Conference</title>
		<meeting>the 34th Annual International Cryptology Conference</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="276" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Succinct non-interactive zero knowledge for a von Neumann architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben-Sasson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Virza</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2013/879" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd USENIX Security Symposium</title>
		<meeting>the 23rd USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="781" to="796" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Faster batch forgery identification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Doumen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oosterwijk</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Cryptology in India</title>
		<meeting>the 13th International Conference on Cryptology in India</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="454" to="473" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berrut</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trefethen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Barycentric Lagrange interpolation. SIAM Review</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="501" to="517" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Pattern recognition and machine learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bishop</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bitansky</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tromer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Innovations in Theoretical Computer Science Conference</title>
		<meeting>the 3rd Innovations in Theoretical Computer Science Conference</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="326" to="349" />
		</imprint>
	</monogr>
	<note>ITCS &apos;12</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Succinct noninteractive arguments via linear interactive proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bitansky</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Os-Trovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paneth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Theory of Cryptography Conference</title>
		<meeting>the 10th Theory of Cryptography Conference</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="315" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">A multi-party protocol for constructing the public parameters of the Pinocchio zk</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bowe</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gabizon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Green</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<ptr target="https://github.com/zcash/mpc/blob/master/whitepaper.pdf" />
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Verifying computations with state</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walfish</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th ACM Symposium on Operating Systems Principles</title>
		<meeting>the 25th ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="341" to="357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Fast exponentiation with precomputation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brickell</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">F</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Mccurley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wilson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename></persName>
		</author>
		<idno>EU- ROCRYPT &apos;92</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th Annual International Conference on Theory and Application of Cryptographic Techniques</title>
		<meeting>the 11th Annual International Conference on Theory and Application of Cryptographic Techniques</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="200" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">A cellular computer to implement the Kalman filter algorithm. Tech. rep., DTIC Document</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cannon</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">E</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1969" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Fast parallel computation of multi-exponentiation for public key cryptosystems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D.-C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Conference on Parallel and Distributed Computing, Applications and Technologies</title>
		<meeting>the 4th International Conference on Parallel and Distributed Computing, Applications and Technologies</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="955" to="958" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Proof-carrying data and hearsay arguments from signature cards</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chiesa</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tromer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st Symposium on Innovations in Computer Science</title>
		<meeting>the 1st Symposium on Innovations in Computer Science</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="310" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Proof-carrying data: Secure computation on untrusted platforms (highlevel description)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chiesa</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tromer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="40" to="46" />
		</imprint>
	</monogr>
	<note>The Next Wave: The National Security Agency&apos;s review of emerging technologies</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Cluster computing in zero knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chiesa</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Virza</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual International Conference on Theory and Application of Cryptographic Techniques</title>
		<meeting>the 34th Annual International Conference on Theory and Application of Cryptographic Techniques</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="371" to="403" />
		</imprint>
	</monogr>
	<note>EUROCRYPT &apos;15</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">An algorithm for the machine calculation of complex Fourier series</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cooley</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tukey</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Computation</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="297" to="301" />
			<date type="published" when="1965" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Practical verified computation with streaming interactive proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cormode</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Mitzenmacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thaler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Symposium on Innovations in Theoretical Computer Science</title>
		<meeting>the 4th Symposium on Innovations in Theoretical Computer Science</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="90" to="112" />
		</imprint>
	</monogr>
	<note>ITCS &apos;12</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Versatile verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Costello</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kreuter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Naehrig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zahur</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Geppetto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th IEEE Symposium on Security and Privacy</title>
		<meeting>the 36th IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="250" to="273" />
		</imprint>
	</monogr>
	<note>S&amp;P &apos;15</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Square span programs with applications to succinct NIZK arguments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danezis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kohlweiss</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Conference on the Theory and Application of Cryptology and Information Security</title>
		<meeting>the 20th International Conference on the Theory and Application of Cryptology and Information Security</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="532" to="550" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Pinocchio Coin: building Zerocoin from a succinct pairing-based proof system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danezis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Parno</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 Workshop on Language Support for Privacy Enhancing Technologies</title>
		<meeting>the 2013 Workshop on Language Support for Privacy Enhancing Technologies</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note>PETShop &apos;13</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Efficient exponentiation using precomputation and vector addition chains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>De Rooij</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Annual International Conference on Theory and Application of Cryptographic Techniques</title>
		<meeting>the 13th Annual International Conference on Theory and Application of Cryptographic Techniques</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="389" to="399" />
		</imprint>
	</monogr>
	<note>EUROCRYPT &apos;94</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Simplified data processing on large clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dean</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ghemawat</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mapreduce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Symposium on Operating System Design and Implementation</title>
		<meeting>the 6th Symposium on Operating System Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="137" to="149" />
		</imprint>
	</monogr>
	<note>OSDI &apos;04</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Cinderella: Turning shabby X.509 certificates into elegant anonymous credentials with the magic of verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Delignat-Lavaud</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Parno</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th IEEE Symposium on Security and Privacy</title>
		<meeting>the 37th IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="235" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Quadratic span programs and succinct NIZKs without PCPs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gennaro</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raykova</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques</title>
		<meeting>the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="626" to="645" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Separating succinct non-interactive arguments from all falsifiable assumptions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gentry</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wichs</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd Annual ACM Symposium on Theory of Computing</title>
		<meeting>the 43rd Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Faster zero-knowledge for boolean circuits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giacomelli</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Madsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Orlandi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Zkboo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th USENIX Security Symposium</title>
		<meeting>the 25th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1069" to="1083" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Delegating computation: Interactive proofs for muggles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Goldwasser</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roth-Blum</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page">64</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Short pairing-based non-interactive zeroknowledge arguments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Groth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security</title>
		<meeting>the 16th International Conference on the Theory and Application of Cryptology and Information Security</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="321" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">On the size of pairing-based noninteractive arguments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Groth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<idno>EU- ROCRYPT &apos;16</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th Annual International Conference on Theory and Application of Cryptographic Techniques</title>
		<meeting>the 35th Annual International Conference on Theory and Application of Cryptographic Techniques</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="305" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Snarky signatures: Minimal signatures of knowledge from simulationextractable SNARKs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Groth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maller</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th</title>
		<meeting>the 37th</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
				<title level="m">Annual International Cryptology Conference</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="581" to="612" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Dryad: distributed data-parallel programs from sequential building blocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isard</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Birrell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fetterly</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 EuroSys Conference</title>
		<meeting>the 2007 EuroSys Conference</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="59" to="72" />
		</imprint>
	</monogr>
	<note>EuroSys &apos;07</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Efficient arguments without short PCPs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ishai</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kushilevitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ostrovsky</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second Annual IEEE Conference on Computational Complexity</title>
		<meeting>the Twenty-Second Annual IEEE Conference on Computational Complexity</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="278" to="291" />
		</imprint>
	</monogr>
	<note>CCC &apos;07</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">The ring of Gyges: Investigating the future of criminal smart contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juels</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2016 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="283" to="295" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">The blockchain model of cryptography and privacy-preserving smart contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kosba</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Papamanthou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hawk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2016 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="839" to="858" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">TRUESET: Faster verifiable set computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kosba</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Papaman-Thou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sayed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trian-Dopoulos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd USENIX Security Symposium</title>
		<meeting>the 23rd USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="765" to="780" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Fastest Gaussian blur</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kutskir</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename></persName>
		</author>
		<imprint/>
	</monogr>
	<note>in linear time</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Generalized Cannon&apos;s algorithm for parallel matrix multiplication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>And Fortes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Conference on Supercomputing</title>
		<meeting>the 11th International Conference on Supercomputing</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="44" to="51" />
		</imprint>
	</monogr>
	<note>ICS &apos;97</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lipmaa</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography</title>
		<meeting>the 9th Theory of Cryptography Conference on Theory of Cryptography</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="169" to="189" />
		</imprint>
	</monogr>
	<note>TCC &apos;12</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Computationally sound proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Micali</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1253" to="1298" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
	<note>Preliminary version appeared in FOCS &apos;94</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Photoproof: Cryptographic image authentication for any set of permissible transformations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Naveh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tromer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2016 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="255" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">A fast algorithm for general raster rotation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paeth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings on Graphics Interface &apos;86/Vision Interface</title>
		<meeting>on Graphics Interface &apos;86/Vision Interface</meeting>
		<imprint>
			<date type="published" when="1986" />
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="77" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Nearly practical verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Parno</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And Raykova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pinocchio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th IEEE Symposium on Security and Privacy</title>
		<meeting>the 34th IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Formal abstractions for attested execution secure processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pass</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tram`ertram` Tram`er</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th Annual International Conference on Theory and Application of Cryptographic Techniques</title>
		<meeting>the 36th Annual International Conference on Theory and Application of Cryptographic Techniques</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="260" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">On the evaluation of powers and related problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pippenger</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th Annual Symposium on Foundations of Computer Science</title>
		<meeting>the 17th Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="1976" />
			<biblScope unit="page" from="258" to="263" />
		</imprint>
	</monogr>
	<note>FOCS &apos;76</note>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">On the evaluation of powers and monomials</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pippenger</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="230" to="250" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title level="m" type="main">libsnark: a C++ library for zk-SNARK proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scipr</forename><surname>Lab</surname></persName>
		</author>
		<ptr target="https://github.com/scipr-lab/libsnark" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Toward practical and unconditional verification of remote computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Setty</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walfish</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th USENIX Conference on Hot Topics in Operating Systems</title>
		<meeting>the 13th USENIX Conference on Hot Topics in Operating Systems</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="29" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Resolving the conflict between generality and plausibility in verified computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Setty</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Vu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walfish</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th EuoroSys Conference</title>
		<meeting>the 8th EuoroSys Conference</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="71" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Making argument systems for outsourced computation practical (sometimes)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Setty</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mcpherson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walfish</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 Network and Distributed System Security Symposium</title>
		<meeting>the 2012 Network and Distributed System Security Symposium</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Taking proof-based verified computation a few steps closer to practicality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Setty</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Vu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Panpalia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walfish</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st USENIX Security Symposium</title>
		<meeting>the 21st USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="253" to="268" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Addition chains of vectors (problem 5125)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Straus</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The American Mathematical Monthly</title>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="page" from="806" to="808" />
			<date type="published" when="1964" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Schönhage-Strassen algorithm with mapreduce for multiplying terabit integers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sze</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 International Workshop on SymbolicNumeric Computation</title>
		<meeting>the 2011 International Workshop on SymbolicNumeric Computation</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="54" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Time-optimal interactive proofs for circuit evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thaler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd Annual International Cryptology Conference</title>
		<meeting>the 33rd Annual International Cryptology Conference</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="71" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<title level="m" type="main">A note on the GKR</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thaler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<ptr target="http://people.cs.georgetown.edu/jthaler/GKRNote.pdf" />
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Verifiable computation with massively parallel interactive proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thaler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Roberts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pfister</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th USENIX Workshop on Hot Topics in Cloud Computing</title>
		<meeting>the 4th USENIX Workshop on Hot Topics in Cloud Computing</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Sealed-glass proofs: Using transparent enclaves to prove and sell knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tram`ertram` Tram`er</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hubaux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 IEEE European Symposium on Security and Privacy</title>
		<meeting>the 2017 IEEE European Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="19" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">SUMMA: scalable universal matrix multiplication algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Van De Geijn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And Watts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency -Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="255" to="274" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<title level="m" type="main">Modern Computer Algebra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Von</forename><surname>Zur Gathen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gerhard</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
	<note>3rd ed</note>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">A hybrid architecture for interactive verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wal-Fish</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th IEEE Symposium on Security and Privacy</title>
		<meeting>the 34th IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="223" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wahby</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Howald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>She-Lat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walfish</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Verifiable</forename><surname>Asics</surname></persName>
		</author>
		<title level="m">Proceedings of the 37th IEEE Symposium on Security and Privacy</title>
		<meeting>the 37th IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="759" to="778" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Full accounting for verifiable outsourcing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wahby</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Shelat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Thaler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Walfish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wies</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Efficient RAM and control flow in verifiable outsourced computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wahby</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walfish</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd Network and Distributed System Security Symposium</title>
		<meeting>the 22nd Network and Distributed System Security Symposium</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note>NDSS &apos;15</note>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Verifying computations without reexecuting them</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walfish</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Blumberg</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="74" to="84" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Verifying arbitrary SQL queries over dynamic outsourced databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Papadopou-Los</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Papamanthou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Vsql</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th IEEE Symposium on Security and Privacy</title>
		<meeting>the 38th IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="863" to="880" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Towards practical verifiable graph processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Alitheia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st ACM Conference on Computer and Communications Security</title>
		<meeting>the 21st ACM Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="856" to="867" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
