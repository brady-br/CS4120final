<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:13+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. Donky: Domain Keys -Efficient In-Process Isolation for RISC-V and x86 Donky: Domain Keys -Efficient In-Process Isolation for RISC-V and x86</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Schrammel</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><surname>Weiser</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Steinegger</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Schwarzl</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Schrammel</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><surname>Weiser</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Steinegger</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Schwarzl</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Graz University of Technology</orgName>
								<orgName type="institution" key="instit2">Graz University of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. Donky: Domain Keys -Efficient In-Process Isolation for RISC-V and x86 Donky: Domain Keys -Efficient In-Process Isolation for RISC-V and x86</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the 978-1-939133-17-5</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Efficient and secure in-process isolation is in great demand, as evidenced in the shift towards JavaScript and the recent revival of memory protection keys. Yet, state-of-the-art systems do not offer strong security or struggle with frequent domain crossings and oftentimes intrusive kernel modifications. We propose Donky, an efficient hardware-software co-design for strong in-process isolation based on dynamic memory protection domains. The two components of our design are a secure software framework and a non-intrusive hardware extension. We facilitate domain switches entirely in userspace, thus minimizing switching overhead as well as kernel complexity. We show the versatility of Donky in three realistic use cases, secure V8 sandboxing, software vaults, and untrusted third-party libraries. We provide an open-source implementation on a RISC-V Ariane CPU and an Intel-MPK-based emulation mode for x86. We evaluate the security and performance of our implementation for RISC-V synthesized on an FPGA. We also evaluate the performance on x86 and show why our new design is more secure than Intel MPK. Donky does not impede the runtime of in-domain computation. Cross-domain switches are 16-116x faster than regular process context switches. Fully protecting the mbedTLS cryptographic operations has a 4 % overhead.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Memory isolation is a fundamental building block for developing secure systems. Hence, concepts of memory isolation can be found on all layers in the software stack, e.g., via process isolation via separate address spaces. However, recent use cases demand more fine-grained isolation, especially within a process, where traditional process isolation would incur too substantial performance costs. Especially cloud providers are in the process of abandoning process isolation in favor of language-level sandboxing, e.g., via V8 Isolates <ref type="bibr" target="#b20">[16]</ref>.</p><p>Isolation through the V8 sandbox has use cases in the cloud <ref type="bibr" target="#b20">[16]</ref>, desktop applications <ref type="bibr" target="#b66">[61]</ref>, and browsers <ref type="bibr" target="#b85">[81]</ref>.</p><p>Unfortunately, JavaScript engines have a huge potential for vulnerabilities, such as memory corruption, incorrect compiler optimizations, type confusion, or erroneous code generation <ref type="bibr" target="#b37">[33,</ref><ref type="bibr" target="#b73">68,</ref><ref type="bibr" target="#b75">70]</ref>, and strong hardware-backed sandboxing is needed. Similarly, native applications may load untrusted (and potentially closed-source) third-party libraries <ref type="bibr" target="#b83">[78]</ref>, or use a library for certain secure operations. The principle of least privilege would require isolation of such libraries from the rest of the program. However, traditional process isolation is oftentimes prohibitive in practice. Hence, prior work studied more lightweight in-process isolation techniques <ref type="bibr" target="#b18">[14,</ref><ref type="bibr">15,</ref><ref type="bibr" target="#b34">30,</ref><ref type="bibr" target="#b39">35,</ref><ref type="bibr" target="#b48">44,</ref><ref type="bibr" target="#b54">50,</ref><ref type="bibr" target="#b55">51,</ref><ref type="bibr" target="#b60">56,</ref><ref type="bibr" target="#b77">72,</ref><ref type="bibr" target="#b86">82,</ref><ref type="bibr" target="#b89">85,</ref><ref type="bibr" target="#b93">89,</ref><ref type="bibr" target="#b98">94,</ref><ref type="bibr" target="#b103">99]</ref>.</p><p>In-process isolation mechanisms range from control flow schemes <ref type="bibr" target="#b34">[30]</ref>, over capability designs <ref type="bibr" target="#b62">[58,</ref><ref type="bibr" target="#b89">85,</ref><ref type="bibr" target="#b93">89]</ref>, to protection key mechanisms operating on memory pages <ref type="bibr">[15,</ref><ref type="bibr" target="#b86">82,</ref><ref type="bibr" target="#b103">99]</ref> for various architectures <ref type="bibr" target="#b8">[4,</ref><ref type="bibr" target="#b23">19,</ref><ref type="bibr" target="#b26">22,</ref><ref type="bibr" target="#b41">37,</ref><ref type="bibr" target="#b68">63]</ref>. These designs follow either a security-focused approach (e.g., privileged key switches) with oftentimes significant performance impact or favor performance (e.g., fast key switches) at the cost of reduced security. For instance, Intel MPK <ref type="bibr" target="#b23">[19,</ref><ref type="bibr" target="#b50">46]</ref> is fast but allows manipulations of the MPK access policy and, thus, cannot directly be used as a secure sandbox. Instead, prior work uses binary scanning and non-writable code pages to prevent manipulations (e.g., ERIM <ref type="bibr" target="#b86">[82]</ref>), complicating sandboxing just-in-time-compiled JavaScript code. If an attacker gains arbitrary code execution, all MPK-based approaches lose their protection guarantees. Others guard their memory access policy via the kernel, which, while secure, demands costly or intrusive kernel interaction and modifications <ref type="bibr">[15,</ref><ref type="bibr" target="#b39">35,</ref><ref type="bibr" target="#b54">50,</ref><ref type="bibr" target="#b103">99]</ref>. Finally, existing architectures are oftentimes limited to 16 protection domains <ref type="bibr" target="#b8">[4,</ref><ref type="bibr" target="#b23">19]</ref>, and software emulation of more domains has a substantial performance cost <ref type="bibr" target="#b69">[64]</ref>.</p><p>Since existing solutions have different security and performance goals or involve heavy kernel interaction, we identify the following research question and challenge: As the objectives of MPK (high performance) and kernelbased approaches (high security) are seemingly contradictory, can these two approaches be combined? How can protection keys be securely and efficiently managed in userspace?</p><p>In this paper, we solve this challenge with Donky, a hardware-software co-design providing strong in-process isolation guarantees based on memory protection keys. Donky offers pure userspace policy management with negligible overhead and full backward-compatibility. Memory pages are dynamically assigned to protection domains, providing strict hardware-backed isolation between domains. Moreover, policy management is entirely decoupled from the kernel and instead delegated to a self-protecting userspace monitor. Donky provides substantially stronger security guarantees than previous designs <ref type="bibr" target="#b86">[82]</ref>, at a low performance cost.</p><p>We demonstrate the versatility of Donky in three realistic use cases: First, we augment the JavaScript V8 engine with isolation guarantees that usually can only be achieved by spawning multiple instances of the V8 engine, i.e., process isolation. Second, we isolate a third-party library from the main program, preventing illegitimate access to the main program's data, e.g., a parsing library without full access to the program's address space. Third, we build a software vault using Donky with security guarantees that can usually only be obtained by running the software vault in a separate process.</p><p>Our design consists of two components. The first component is a secure software framework to define and handle memory protection domains in userspace, e.g., for just-in-time compiled code or third-party binary code. Its core, a lightweight protection domain monitor library called DonkyLib, exposes Donky functionality, such as secure in-userspace domain switching and modification, to an application developer. We completely outsource system call filtering to a privileged userspace domain to avoid usage of extended Berkeley Packet Filters (eBPFs), which have been used several times for kernel exploitation <ref type="bibr" target="#b82">[77]</ref>. Expensive context switches to the kernel are not necessary for switching or modifying protection domains.</p><p>The second component of Donky is a small hardware extension. Our full open-source hardware implementation is based on the RISC-V Ariane CPU and evaluated on a Xilinx Kintex-7 FPGA KC705. We also implement an Intel-MPK-based emulation mode for x86. We show that a full Donky implementation provides higher security guarantees than MPK-based schemes currently can provide: Donky has a special userspace protection key policy register protected via a hardware call gate. Consequently, we do not need binary inspection or rewriting to guarantee that malicious code cannot change it, unlike all isolation techniques building upon Intel's current MPK implementation <ref type="bibr" target="#b86">[82]</ref>, and Donky can shield against arbitrary code execution. We outline hardware changes to Intel MPK for full Donky support.</p><p>We provide a thorough performance analysis for our RISC-V-based implementation and also, despite the lower security guarantees, for our emulation mode on x86. We show that the performance cost in both implementations of Donky is negligible when compared to the cost of process isolation and earlier proposals. Finally, we discuss previous work on inprocess isolation in detail and find that previous work focused only on some goals of Donky (e.g., only isolating trusted code <ref type="bibr">[15]</ref>) or even entirely orthogonal goals like CFI <ref type="bibr" target="#b34">[30]</ref>. In summary, our contributions are as follows:</p><p>• We propose Donky, efficient userspace memory protection domains, without requiring control-flow integrity, binary inspection, or binary rewriting.</p><p>• We provide an open-source implementation 1 on a RISC-V CPU, with higher security than MPK-based schemes.</p><p>• We repurpose the RISC-V extension for user-level interrupts for managing access policies entirely in userspace.</p><p>• We evaluate Donky on V8 just-in-time-compiled JavaScript code and native code. Donky is 1-2 orders of magnitude faster than process-based isolation and shows a negligible overhead over no isolation on real-world software. Paper Outline. Section 2 provides background on RISC-V and protection keys. Section 3 overviews Donky's design. Section 4 details the software component. Section 5 details the hardware extension. Section 6 evaluates Donky's performance and security. Section 7 qualitatively evaluates Donky in terms of applicability, performance, and security. Section 8 discusses related work, and Section 9 concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>In this section, we overview RISC-V, virtual memory, existing protection key architectures, and JavaScript JIT engines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">RISC-V</head><p>RISC-V is a free and open-source instruction set architecture (ISA). It comprises the unprivileged ISA <ref type="bibr" target="#b32">[28]</ref>, and the privileged ISA <ref type="bibr" target="#b31">[27]</ref>. A set of control and status registers (CSRs) allows configuring the CPU behavior, access performance metrics, and provides additional scratch space for exception handling. CSRs are typically prefixed with m, for machine mode, s, for supervisor mode, or u, for user mode. Exceptions occur upon various occasions, e.g., memory violations. To handle the exception, the CPU switches to machine mode and jumps to the address specified in the trap-vector base-address register (mtvec CSR). Exceptions can be delegated to supervisor mode in the medeleg CSR. The instructions mret and sret are used to return from the exception handler.</p><p>RISC-V specifies the so-called "Standard Extension for User-Level Interrupts", also abbreviated as N extension <ref type="bibr" target="#b33">[29]</ref>. <ref type="bibr" target="#b6">2</ref> The N extension is intended for embedded systems, and user mode exception handling (e.g., for garbage collection or integer overflows) is only briefly discussed as a potential use case for non-embedded systems (e.g., Unix). The N extension adds the utvec and sedeleg CSRs, amongst others, to delegate exceptions and interrupts directly to user mode handlers without invoking higher privileged code. As with higher privilege modes, utvec allows for vectorized exceptions, and the uret instruction is used to return from the handler.</p><p>Ariane <ref type="bibr" target="#b5">[1,</ref><ref type="bibr" target="#b100">96]</ref> is a 64-bit single issue, 6-stage, in-order CPU, optimized for short critical path length. It implements the RV64IMAC RISC-V ISA and features the M, S, and U privilege modes. Ariane implements v1.10 of the privileged and the working draft of the unprivileged RISC-V ISA v2.3. Thus, it can run Unix-like operating systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Address Translation</head><p>Modern 64-bit CPUs typically support 48-bit (recently also 57-bit) virtual address spaces, used for process isolation. For virtual-to-physical address translation, address spaces are mapped in blocks of pages, most commonly 4 KiB. Modern CPUs support multiple levels of translation tables, which are stored in memory. Their entries (also called page-table entries) are cached in the so-called translation-lookaside buffer (TLB). Switching between processes, and thus address spaces, means updating a CPU register to point to a different set of translation tables and flushing the TLB unless it is tagged with an address-space identifier. Via the page-table entries (PTEs), access permissions are managed per page, such that the same physical page may be mapped in multiple virtual address spaces (i.e., multiple processes, shared memory), even with different access permissions. Updates to permissions, mappings, or the switching of the address space can only be done by the kernel. Hence, context switches are required for any of these operations to isolate contexts (e.g., processes) from each other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Memory Protection Keys</head><p>Memory protection keys are an extension to page-based memory permissions, allowing to change permissions of memory ranges without the slow kernel-level modification of page tables. Instead, page-table entries are tagged with a protection key, but the permissions (which the hardware enforces) for these keys are stored separately. Keys are usually associated with a protection domain (e.g., application, library, module), and each (typically virtual) memory region can have one associated key. Processes can have one or more keys assigned (e.g., one key per application on System/360) via special registers.</p><p>Today's implementations differ mainly in the number of loaded keys per thread and process, the types of permissions, if the protection key policy register is privileged or not, as well as memory region granularity. The main differences of protection key implementations of some notable hardware architectures are as follows:</p><p>Intel's Memory Protection Keys (MPK) <ref type="bibr" target="#b23">[19]</ref> use 4-bit keys stored in the page-table entry, allowing for 15 different domains per process. The corresponding read-and writedisable bits for each key are stored in the PKRU (User Page Key Register) and checked by the hardware upon access. As the PKRU is non-privileged, allowing fast domain-switching in userspace, MPK itself does not provide secure in-process isolation and, to obtain such, has to be combined with other mechanisms (such as CFI and binary scanning).</p><p>ARM Memory Domains <ref type="bibr" target="#b8">[4]</ref> are defined in ARMV8 for AArch32 but were dropped in AArch64. They use 4-bit domain IDs (keys) in the translation tables and a kernel-mode Domain Access Control Register (DACR) with a 2-bit field per key. With DACR, access can either be denied, enforced at PTE level, or fully allowed, bypassing PTE permissions. Since only the first-level page-table entries contain domain IDs, domain boundaries must be aligned at 1 MB blocks.</p><p>IBM's Power <ref type="bibr" target="#b41">[37]</ref> architecture supports 5-bit protection keys, allowing 32 different memory domains. Its privileged (kernel mode) registers (AMR and IAMR) store read, write, and execute permissions for each key.</p><p>HP PA-RISC <ref type="bibr" target="#b68">[63]</ref> uses 15-18-bit "protection identifiers" with a write-disable bit each stored in privileged control registers. Instead of storing a write-disable bit for each of the keys (which would require a 2 18 bit register), they have four registers to load one key each.</p><p>Itanium (IA-64) <ref type="bibr" target="#b26">[22]</ref> is very similar to PA-RISC but provides (at least) 16 registers with 18-24-bit keys each and have additional read-and execute-disable bits as well as a valid bit.</p><p>The above hardware designs have various trade-offs. If the protection key policy register can be changed from the userspace using unprivileged operations, domain transitions can be very fast and do not require any kernel interaction. Having a privileged register, however, completely changes the threat model and possible use cases. In this case, the kernel needs to know about the different memory domains, which requires many complex kernel modifications. Existing work based on Intel MPK works around the inherent problem of malicious protection key policy register modification by utilizing additional mechanisms such as compiler-based code rewriting <ref type="bibr" target="#b45">[41]</ref>, binary inspection <ref type="bibr" target="#b86">[82]</ref> and Write-XOR-Execute to ensure there are no unintended writes to the PKRU.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">JIT and JavaScript Engines</head><p>Just-in-time compilation (JIT) dynamically compiles interpreted programming languages, e.g., JavaScript, into an intermediate representation (byte code) or machine code. A JavaScript engine manages the tasks of compilation and execution of JavaScript, memory management, and optimization. In the case of V8, which is used in Chrome, Chromium, and Node.js <ref type="bibr" target="#b85">[81]</ref>, the source code is first compiled into a byte code representation, which is then interpreted and executed. While the code is executed, another component of the engine analyses the runtime and further optimizes the byte code directly into machine code. This requires the code region to be both writable and executable.</p><p>Typically, browsers use sandboxing to minimize the attack surface for attackers exploiting vulnerabilities via JavaScript. <ref type="figure">Figure 1</ref>: Donky structures a user process into security domains, orchestrating a set of memory regions. Each region is assigned a unique protection key, and access is controlled via a policy register. Keys can be domain-private to implement software vaults (Dom B), or shared across domains. Limiting a domain's keys allows to sandbox malicious code (Dom C). The domain monitor manages protection keys, the policy register, and system call filtering. Call gates prevent control-flow attacks across domains.</p><p>E.g., in V8, an Isolate is an independent copy of the entire JavaScript runtime environment. Each Isolate has its own code cache, heap, garbage collection, and call stack. Thus, JavaScript code runs in parallel in a separate Isolate within the same process. However, sandbox escapes are still possible by exploiting vulnerabilities in both the JavaScript engine and the sandbox <ref type="bibr" target="#b6">[2,</ref><ref type="bibr" target="#b37">33,</ref><ref type="bibr" target="#b75">70]</ref>. An additional security enhancement is to use process isolation, e.g., in the form of site isolation <ref type="bibr" target="#b72">[67]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Donky System Design</head><p>In this section, we define our threat model and present Donky, a hardware-software co-design for strong and efficient memory isolation within a single user process. Donky provides highly flexible and lightweight domains atop of hardwarebacked memory protection keys, as visualized in <ref type="figure">Figure 1</ref>. Threat model. Donky supports complex user programs with multiple software modules and mixed trust assumptions (cf. <ref type="figure">Figure 1</ref>). Modules can range from small components like individual C++ classes over compounds like plugins or browser tabs to entire binaries and libraries. For the sake of demonstration, we discuss two common scenarios.</p><p>First, in a sandbox scenario, an application wants to execute untrusted code modules without specific security assumptions. They may contain vulnerabilities that are actively exploited by an adversary, or even run malicious (e.g., user-provided JavaScript) or arbitrary code, such that it issues adversarychosen system calls or accesses adversary-chosen memory locations. The adversary may repeatedly inject arbitrary instructions at runtime, including WRPKRU. The application encapsulates this untrusted code in a Donky in-process sandbox. Donky shields not only application memory and sandbox transitions but also the system call interface at the discretion of the application. In contrast to ERIM <ref type="bibr" target="#b86">[82]</ref>, we do not require binary scanning. Also, Donky does not rely on recompiling programs with CFI. Instead, Donky can sandbox unmodified, pre-compiled binaries. Unlike ERIM, we do not assume Write-XOR-Execute and also support self-modifying code. This enables use cases such as JIT compilation, one of the main applications of Donky, without modifying the JIT compiler to not emit unsafe WRPKRU instructions.</p><p>Second, in a vault scenario, an application wants to shield highly sensitive modules such as cryptographic libraries. While not being adversarial, the application wants to enforce the principle of least privilege <ref type="bibr" target="#b74">[69]</ref> to reduce the attack surface in case of corruption. For example, the application might be subject to vulnerabilities and exploitation. It might also load other modules (e.g., libc), which themselves are vulnerable or malicious and cannot be securely sandboxed. The application shields sensitive modules in a Donky in-process vault and renounces all access rights to it. Donky enforces memory isolation and call gate protection towards the vault.</p><p>We assume that the developer correctly uses Donky. Illdesigned trust relationships, domain interfaces, or system call filter rules <ref type="bibr" target="#b13">[9,</ref><ref type="bibr" target="#b35">31]</ref> are out of scope. <ref type="bibr">3</ref> While DonkyLib carefully validates all untrusted input, we consider confused deputy or corruption attacks <ref type="bibr" target="#b16">[12,</ref><ref type="bibr" target="#b40">36,</ref><ref type="bibr" target="#b56">52,</ref><ref type="bibr" target="#b63">59]</ref> out of scope. We assume a trusted code base consisting of DonkyLib, all code that is executed before DonkyLib, and the operating system.</p><p>We consider side-channel and fault attacks out of scope, and these types of attacks must be addressed by orthogonal mechanisms <ref type="bibr" target="#b12">[8,</ref><ref type="bibr" target="#b21">17,</ref><ref type="bibr" target="#b36">32,</ref><ref type="bibr" target="#b42">38,</ref><ref type="bibr" target="#b61">57,</ref><ref type="bibr" target="#b80">75,</ref><ref type="bibr" target="#b96">92]</ref>. However, Donky can, just as process isolation <ref type="bibr" target="#b72">[67]</ref>, reduce the attack surface of Spectre attacks <ref type="bibr" target="#b44">[40]</ref>, as we also show in Section 6.1.</p><p>Design Overview. While memory protection keys are a powerful building block for in-process isolation, they do not provide proper abstraction for securely shielding software components. In particular, each memory page has exactly one protection key. However, a software component might require multiple protection keys to share memory with other components. To capture this, we use the term "domain" to denote a set of protection keys (and associated memory), their precise usage rights, and their allowed entry points. By assigning each domain a different set of protection keys, depicted as circles in <ref type="figure">Figure 1</ref>, a variety of trust models can be enforced, as we demonstrate in our use case studies in Section 7. For example, Donky supports sandboxing of untrusted or even malicious code (see domain C in <ref type="figure">Figure 1</ref>). In particular, strong sandboxing of runtime compilers for scripting languages such as JavaScript is in great demand <ref type="bibr" target="#b20">[16,</ref><ref type="bibr">80]</ref>. Also, Donky, by design, supports the inverse trust model in which sensitive data is safeguarded in a vault via privilege separation to, e.g., tackle programming errors and their exploitation <ref type="bibr" target="#b71">[66]</ref> (see domain B). The versatility of Donky's design supports a variety of intermediary trust models as well, including shared memory (e.g., key K5 is shared between domain B and C) and unprotected legacy code (key K0).</p><p>On the hardware side, Donky extends the concept of protection keys with a userspace call-gate mechanism for secure in-userspace domain transitions. This subtle design change solves the non-trivial challenge of combining userspace protection keys with pure userspace key management. Moreover, the hardware call gate intercepts system calls, allowing for efficient in-userspace system call filtering. On the software side, a thin userspace layer called Donky Monitor leverages the hardware call gate for self-protection. Hence, we can safely entrust Donky Monitor with management of domains and protection keys and the interposition of critical system calls. Moreover, Donky Monitor enables fast and secure domain switches via software-defined call gates without kernel interaction (cf. the call into the vault in <ref type="figure">Figure 1</ref>).</p><p>In Section 5.1, we prototype Donky on RISC-V and implement it on top of the Ariane RISC-V CPU running on an FPGA, and also discuss lightweight adaptations making Intel MPK fully benefit from Donky. In the following, we show how our Donky design meets the goals of secure and efficient in-process isolation and highlight all involved components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Software Design of Donky</head><p>In this section, we present the software design of Donky. At its core lies a small handler called Donky Monitor that combines the benefits of a secure hardware call gate with the performance and convenience of pure userspace policy management. Donky Monitor offers a rich software abstraction layer towards application developers via an intuitive Donky API. Also, the monitor safeguards domain transitions via Listing 1: The Donky API offers intuitive and secure-bydefault management of domains and protection keys.</p><p>secure in-userspace software call gates, supports traditional multithreading, and dynamic system call filtering.</p><p>Our software design is agnostic to the underlying ISA and works both with our full RISC-V implementation, as well as the x86 emulation mode based on Intel MPK. DonkyLib can sandbox code without recompilation or transformations <ref type="bibr">[15,</ref><ref type="bibr" target="#b90">86]</ref>, and be easily integrated into existing projects. Donky Monitor is our trusted handler in charge of managing in-process access policies in userspace and securing domains from each other. Unlike previous work <ref type="bibr">[15,</ref><ref type="bibr" target="#b39">35,</ref><ref type="bibr" target="#b54">50,</ref><ref type="bibr" target="#b103">99]</ref>, Donky domains are a pure userspace concept upheld by Donky Monitor without involvement of the kernel. <ref type="bibr" target="#b8">4</ref> Donky Monitor is invoked for any operation on domains or protection keys. It also safeguards domain switches via dcalls. To protect itself from tampering, Donky Monitor encapsulates its memory in a separate domain, which has access to all other domains. To achieve security, even in the presence of malicious code, a hardware call-gate mechanism ensures that the monitor can only be entered at its defined entry point. Furthermore, triggering the hardware call gate grants the Donky Monitor permission to update the protection key policy register. Outside the monitor, the register is protected, which obviates the need for binary scanning, CFI, and W⊕X <ref type="bibr" target="#b86">[82]</ref>. Software Abstraction Layer. The Donky API is our software abstraction layer, which expands the POSIX interface with Donky API calls. In particular, it allows to manage domains, protection keys and associated memory, and share keys with other domains. The API also manages software call gates to allow for cross-domain calls denoted as dcalls. <ref type="table" target="#tab_0">Table 1</ref> lists our API, of which we discuss the essentials in the following.</p><p>Donky API follows a secure-by-default principle, e.g., new domains are isolated by default, and permissions (e.g., to register dcalls to its memory) have to be explicitly granted to other domains. Also, each domain is automatically assigned a unique protection key used to protect its private memory, e.g., stack and mmap'ed memory (see Listing 1, line 2). A protection key is owned by a domain but can be shared with other domains. Starting in the root domain, a program can set up child domains (line 8) with different permissions, also for cross-domain shared memory. A domain can request new protection keys (line 4), tag memory areas with them (line 4), and assign them to other domains for shared memory (line 9). Domain switches require explicit switching permission and well-defined entry points (dcalls) that prevent cross-domain control-flow diversion attacks (lines 11 and 12). Parent domains may drop permissions for child domains (line 14) to reduce attack surface, or to implement a secure software vault (cf. <ref type="figure">Figure 1)</ref>. Furthermore, Donky API distinguishes protection key ownership (e.g., for memory mapping) from mere access permission. In line 9, the child domain is only given a copy of the protection key without ownership. E.g., DonkyLib uses this to make its own dynamic string tables read-only visible to others (necessary for the dynamic loader). Finally, DonkyLib ensures that protection keys can only be freed if they are no longer in use, preventing use-after-free <ref type="bibr" target="#b69">[64]</ref>.</p><p>Domain Transitions. Previous work on memory protection keys either requires kernel interaction <ref type="bibr">[15,</ref><ref type="bibr" target="#b103">99,</ref><ref type="bibr" target="#b103">99]</ref> or Write-XOR-Execute <ref type="bibr" target="#b86">[82]</ref> for domain switches. DonkyLib provides fast and secure domain switches without kernel interaction. As shown in <ref type="figure" target="#fig_0">Figure 2</ref>, dcalls are used to call a function in a different domain and return to the caller again. A dcall invokes the hardware call-gate mechanism to securely trap to Donky Monitor, which handles the domain transition. Automatically generated wrapper code hides interaction with Donky Monitor from the application developer. This is similar to the code generation for SGX's enclave entry points. Moreover, the generated wrapper code has the same type signature as the desired dcall, such that code can transparently invoke dcalls without reordering arguments or return values. DonkyLib also supports nested dcalls, even across an arbitrary number of domains (only constrained by stack size).</p><p>DonkyLib registers dcall with unique IDs and their entry addresses to ensure trusted and unforgeable dcalls. At runtime, the monitor is provided with the ID and the information if it is a call or return. It can then decide if the action is allowed and perform the switch to the target domain, which securely switches the protection key policy register and the stack.</p><p>As shown in <ref type="figure" target="#fig_0">Figure 2</ref>, wrappers exist for both the calling and the target domain. They are responsible for interacting with Donky Monitor, saving and restoring non-argument registers before and after a dcall, as well as optionally wiping registers. This ensures integrity and confidentiality of CPU registers across domain transitions. We currently provide macros to auto-generate wrapper code for C functions, and a C++ template class for wrapping C++ member functions in a dcall. The C++ template class furthermore catches uncaught exceptions in the target domain, sanitizes them to avoid information leakage, and re-throws them in the calling domain. Our wrappers support efficient argument passing via CPU registers similar to the system call interface. Large data structures can be passed across domains via shared memory. Tools such as Intel SGX Edger8r <ref type="bibr" target="#b25">[21]</ref>   <ref type="figure" target="#fig_0">Figure 2</ref>, domain A has three threads, of which the second does a dcall. Since domain B was never entered before, Donky Monitor allocates a new stack for this thread.</p><p>Each thread gets assigned a separate exception stack, which is protected by Donky Monitor (cf. <ref type="figure" target="#fig_0">Figure 2</ref>). When invoked, DonkyLib immediately switches to the exception stack in low-level assembler. This ensures that multiple threads can call into DonkyLib. Donky Monitor stores critical thread data in a protected thread-local storage (TLS) area, which we allocate page-aligned in the static TLS and assign it the private protection key of Donky Monitor. Dynamic System Call Filtering. Controlling system calls is essential for realizing sandboxed environments. Prior work either defines system call protection as an orthogonal problem <ref type="bibr" target="#b39">[35]</ref> or demands intrusive changes to the kernel <ref type="bibr" target="#b103">[99]</ref>.</p><p>We filter system calls entirely in userspace using perdomain rules. Compared to kernel filters, our approach offers key advantages: First, we allow fully dynamic filter rules that can be expressed as normal program flow, as opposed to seccomp <ref type="bibr" target="#b51">[47]</ref> and eBPF <ref type="bibr" target="#b29">[25]</ref>. Appendix A gives an example. Second, we interpose relevant library calls and, thus, can filter at a higher abstraction level. <ref type="bibr">5</ref> For example, we interpose pthread_create, while only blacklisting the underlying clone system call. Third, userspace filtering reduces complexity and, thus, also the attack surface of the kernel.</p><p>Library interposition is only a convenience, not a security feature. If a malicious domain bypasses it (e.g., by issuing a system call), an exception is raised. We discuss an appropriate hardware and a software mechanism in Section 5.1. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Hardware Design of Donky</head><p>In this section, we present our hardware implementation of Donky on RISC-V. We design memory protection keys from the ground up on RISC-V and repurpose the RISC-V N extension to implement secure call gates in userspace. Furthermore, we describe minimal hardware changes required for Intel MPK to fully support Donky on x86.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Donky for RISC-V</head><p>To evaluate and fully implement Donky on a hardware level, we use the Ariane RISC-V core, a 6-stage, single issue, inorder CPU supporting the RV64IMAC instruction set.</p><p>We design memory protection keys for RISC-V, including our protection key policy register and permission checks in the MMU. Furthermore, we augment the Ariane CPU with the N extension and repurpose it to support secure hardware call gates in userspace. As of now, N extension has only been used for securing embedded systems <ref type="bibr" target="#b70">[65]</ref> (cf. Section 2). To our knowledge, we are the first to implement and utilize it for securing a non-embedded system. Our Donky exception mechanism not only guarantees the security of memory protection keys itself. It additionally enables lazy scheduling of protection keys, system call filtering in userspace, as <ref type="bibr">well</ref>   defines two 64-bit virtual memory systems: Sv39 and Sv48, with 39 and 48-bit address spaces, respectively. As shown in <ref type="figure" target="#fig_1">Figure 3</ref>, both have the upmost 10 bits of a PTE reserved for possible future extensions and to facilitate research experimentation <ref type="bibr" target="#b31">[27]</ref>. For Donky, we use these 10 bits for memory protection keys, allowing 1024 different protection keys. Policy register. Intel MPK keeps the permissions for their 16 protection keys in a single 32-bit register. However, as Donky supports a much higher number of 1024 keys, this is not possible. Instead, we implement key slots, allowing for four simultaneously loaded protection keys in our 64-bit DKRU register (cf. <ref type="figure" target="#fig_2">Figure 4</ref>). Each key slot holds a 10-bit protection key. Only if a protection key is loaded, its associated memory pages can be read or written. Furthermore, each slot has a write-disable bit in the upmost slot bit to enforce read-only memory. While previous architectures <ref type="bibr" target="#b26">[22,</ref><ref type="bibr" target="#b68">63]</ref> also supported large keys, Donky only uses a single register and allows pure userspace management of the DKRU register.</p><p>We add the DKRU register as a user-mode control and status register (CSR). Thus, DKRU can be, in principle, configured with standard CSR instructions from all privilege levels. The upmost bit of the DKRU register is the so-called monitor bit. If cleared, any access to DKRU is disallowed from user mode (see <ref type="figure" target="#fig_2">Figure 4)</ref>. Thus, by clearing this monitor bit, Donky Monitor can prevent unauthorized alteration of the protection key policy. The monitor bit can only be set again by privileged software or by triggering the hardware call gate into Donky Monitor. Finally, DKRU offers 19 software-defined bits (SW), which Donky Monitor can freely use to store metadata, such as the domain ID. To support multicore systems, DKRU is core-local, as is PKRU for x86. Donky CPU exception. We define a new CPU exception called Donky exception. It is raised whenever Donky detects a security violation while the monitor bit in DKRU is cleared. This includes memory access checks as well as illegal access to DKRU or CSR's defined by the N extension. We extend the memory management unit (MMU) of the Ariane core to verify that for any data access, the protection key in the corresponding PTE matches at least one key loaded in DKRU. For store operations, the MMU also checks the corresponding write-disable bits in DKRU. For backward compatibility, we exempt protection key zero, which is the default value of PTEs, from the above checks. Hardware call gate and the N extension. The N extension allows the kernel to delegate interrupts and exceptions to a user mode exception handler via the sedeleg CSR. This user handler can be specified via utvec. A separate uscratch register offers scratch space for setting up an exception stack.</p><p>We integrate our Donky hardware call gate into the N extension as follows: First, the utvec and uscratch CSRs cannot be accessed if the monitor bit in the DKRU register is cleared. Second, for any delegated user exception, the CPU sets the monitor bit, disabling Donky protection. Third, when returning from the user handler with uret, the CPU automatically clears the monitor bit, enforcing protection again. This call gate mechanism ensures the security of Donky Monitor. At initialization, Donky Monitor configures utvec to point to its entry point and clears the monitor bit. Since Donky Monitor protects its own memory using protection keys, Donky Monitor can only be invoked at this well-defined entry point by triggering, e.g., a Donky exception. Any other attempt to divert code execution into Donky Monitor will keep the monitor bit cleared and, thus, prevent manipulation of DKRU and, consequently, Donky Monitor data. Scheduling of protection keys. If a domain accesses memory for which no protection key is loaded, a Donky exception is triggered that invokes Donky Monitor. Donky Monitor validates whether the access is allowed, and loads the missing protection key into DKRU. This happens completely transparent to the domain. To decide which slot to use for the new key, Donky Monitor currently uses a round-robin based technique on key slots 1-3. Slot 0 is always reserved for the domain's default key. Of course, more sophisticated key scheduling methods can be implemented as well. As our scheduling mechanism purely operates on userspace data structures, it does not need expensive kernel invocations to schedule keys and permissions in the PTEs <ref type="bibr" target="#b69">[64]</ref>. Syscall filtering in userspace. Donky supports lightweight system call filtering entirely in userspace. On RISC-V, system calls are triggered via the ecall instruction, which throws a dedicated exception. We use the same N extension delegation mechanism (sedeleg) to delegate these system call exceptions directly to Donky Monitor. If the monitor bit is set, however, the system call is forwarded to the kernel. This allows Donky Monitor to do actual system calls.</p><p>Note that, while part of our design, our proof-of-concept prototype does not use system call delegation but instead uses a small kernel module to enforce system call interposition. This simplifies the evaluation of our x86 emulation mode. Virtualization. Donky supports virtualization of the DKRU and the N extension CSRs. As long as the monitor bit is cleared, all accesses to the corresponding CSRs are blocked. Instead, they raise a Donky exception that traps to Donky Monitor, allowing it to emulate the desired behavior of both, DKRU and the N extension. This is in line with RISC-V's trapand-emulate approach to, e.g., implement missing hardware extensions in software. Hence, other schemes can utilize the N extension or protection keys for their own purposes without knowledge of Donky, e.g., to achieve CFI <ref type="bibr" target="#b45">[41]</ref>.</p><p>Linux support. The Linux kernel already supports the RISC-V ISA. However, it does not support its N extension yet. We extended the Linux kernel 5.1 with our modified N extension and have ported the memory protection key feature, which already existed for other architectures. For this, we added all registers necessary for the N extension, as well as DKRU, to the relevant per-thread kernel structs used during context-switch. The kernel also delegates Donky exceptions to the userspace by configuring sedeleg. In total, 700 LoC were changed to support Donky on RISC-V. Hardware Utilization. The total utilization of our modified Ariane RISC-V CPU on our evaluation board is 69 321 LUTs (+1.85 %) and 51 395 FFs (+0.94 %) to the unmodified CPU. The increase is due to the CSRs of the N extension as well as our DKRU CSR, and the corresponding control logic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Extension to Intel MPK</head><p>Intel MPK lacks a mechanism for safeguarding its protection key policy register. The PKRU register can be changed by anyone via the unprivileged WRPKRU instruction. Thus, MPK does not provide the same security as Donky, and schemes using it impose limitations (CFI, W⊕X, and binary scanning).</p><p>We propose the following adaptations to make MPK benefit from Donky. Similar to RISC-V, we propose a secure hardware call gate to a trusted handler (Donky Monitor), which safeguards access to PKRU. This can be achieved by having one additional Donky Handler Register (DKHR), similar to utvec, specifying the handler address. Two new instructions allow entering and exiting the handler. The DENTER instruction acts similarly to SYSENTER. It enables write access to the PKRU and jumps to the address in DKHR. The register rcx will contain the return address (i.e., the address following DENTER). Similar to SYSRET, DRET returns to the previous code (stored in rcx, and disables write access to PKRU.</p><p>We propose using the top-most bit of DKHR as the monitor bit to control write access to PKRU as well as DKHR. It is set and cleared by DENTER and DRET, respectively. The monitor bit also decides if MPK access violations should be triggered and delegated to DKHR. This is required to permit Donky Monitor to access all application memory. DKHR exists per core, and the operating system saves and restores it at context switches. New processes automatically have the top-most bit set, so that they can set up DKHR themselves. This also provides backward compatibility for programs unaware of DKHR.</p><p>While x86 does not have a native system call delegation feature like RISC-V, it could be implemented via a hypervisor. However, for better performance, we envision a lightweight hardware extension similar to our RISC-V design: while the monitor bit is set, syscalls should be delegated to the monitor. More keys. MPK currently only uses 4 PTE bits, supporting 16 protection keys. Since PTE bits 46-51 are reserved for future use, they could be repurposed to support 1024 keys. The same key slotting, as in <ref type="figure" target="#fig_2">Figure 4</ref>, could be used for PKRU.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Security and Performance Evaluation</head><p>In this section, we evaluate both the security of Donky, as well as its performance using both micro and macro benchmarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Security Evaluation</head><p>The security of Donky is built on several layers. First, the security of its building blocks, i.e., memory isolation, call gates, and kernel interaction via system calls and signals. Second, the security of Donky Monitor, its API, and dcalls. And third, the security of a concrete application leveraging Donky. We defer the latter to our case studies in Section 7. Hardware Call Gates. We prevent code-reuse attacks on Donky Monitor as it can only be legitimately entered via a hardware call gate. Donky exceptions are delivered to this call gate, and the CPU enables the monitor bit inside DKRU.</p><p>Note that for Donky and Intel MPK, code fetches are not subject to protection key checks, as opposed to read and write data accesses. However, this is not a security issue. If a domain jumps into Donky Monitor code, it cannot manipulate DKRU, utvec, and uscratch since the monitor bit in DKRU is still cleared. Moreover, it cannot access Donky Monitor data since it uses a different protection key. Exempting code fetches from protection key checks simplifies code sharing across domains and also allows implementing execute-only memory <ref type="bibr" target="#b101">[97]</ref>. As our threat model already considers arbitrary code execution, access to more code does not weaken our security guarantees. System Calls and Signals. A third building block is to safeguard kernel functionality, i.e., system calls and signals that allow bypassing Donky. Donky interposes system calls by redirecting them to Donky Monitor such that a malicious domain cannot bypass it. For our prototype, we implement a traditional approach, blacklisting dangerous system calls directly in the kernel unless issued by Donky Monitor. For RISC-V, we describe a hardware mechanism to interpose system calls without kernel involvement. Donky Monitor filters system calls based on two criteria. First, it constrains syscalls to uphold domain isolation. Second, an application can install arbitrary domain-specific system call filters, similar to seccomp. Definition of appropriate filter rules is crucial for any domain isolation scheme, yet an orthogonal problem to study (e.g., boomerang attacks <ref type="bibr" target="#b56">[52]</ref>). To demonstrate feasibility, our prototype filters memory-related system calls (e.g., mmap, mprotect) to only operate on memory of the current domain.</p><p>Our prototype does not yet implement signal handling, as this is merely an engineering effort. Since our use case studies do not strictly demand signals, this has no effect on performance. Nevertheless, we argue why signal handling with Donky can be implemented securely. First, Donky Monitor can protect the signal origin by only accepting signals from the kernel, discarding fake ones (i.e., induced by malicious code jumping into the monitor's signal handler). Since Linux drops PKRU privileges to protection key zero during signal dispatch, which malicious domains cannot achieve, this boils down to a simple PKRU check. Second, signal delivery is safeguarded by interposing the registration of signal handlers and loading the correct stack and protection key policy register. Third, interruption of Donky Monitor itself (e.g., via asynchronous signals) is not a security issue when using its own protected signal stack and blocking normal Donky API calls and dcalls for the interrupted thread until signal handling is finished. Donky Monitor. The above building blocks guarantee the security of Donky Monitor, which is the base for all security services offered by the Donky API. For domains, Donky Monitor stores critical domain metadata in its internal protected data structures, and per-thread information is kept in protected thread-local storage. Donky Monitor carefully validates all untrusted input given to Donky API to avoid confused deputy or corruption attacks <ref type="bibr" target="#b16">[12,</ref><ref type="bibr" target="#b40">36]</ref>. Furthermore, we ensure that stack pointers are within a domain's memory before accessing it inside Donky Monitor. Donky API. The expressiveness of Donky API allows to represent a variety of protection models, e.g., hierarchical sandboxing, vaults, shared memory, and mutual distrust. To study the concrete security guarantees of a program using Donky is a research field on its own, and a general statement cannot be made. One could, for example, analyze concrete security properties as a sequence of graphs via the take-grant model <ref type="bibr" target="#b53">[49]</ref>. Since this is orthogonal to our work, we will focus on the security of our use case scenarios from a programmer's perspective instead, which we defer to Section 7.</p><p>We informally describe Donky API rules in terms of the take-grant model. Donky API is designed such that domains can only handle their own resources. These resources include a domain's memory, protection keys, call gates as well as its child domains. A domain can request new resources (create rule), constrain their usage (remove rule), grant permission to other domains (grant rule), but not access foreign resources (limited take rule). The grant rule allows domains to open up its call gates to other domains, or share their protection keys. The remove rule fosters the concept of least privilege by dropping ownership of protection keys, reducing their usage rights, or releasing a parent-child relationship. Unless released, a parent domain can always act on behalf of its child domains. The limited take rule only allows elevating privileges on resources for which a domain already has ownership. For example, if a domain owns a protection key, it is eligible to reprotect the associated memory, e.g., from read-only to read-write (mprotect system call). For granting another domain read-only access to its memory, a domain would create a copy of the associated protection key without ownership. Secure dcalls. Domain transitions via dcalls demand proper stack management and handling of CPU registers. On the one hand, DonkyLib maintains the call stack abstraction to prevent domains from returning from a dcall that has not been called <ref type="bibr" target="#b16">[12]</ref>. We do so by pushing metadata on the caller stack inaccessible to the target domain upon each dcall. Thus, Donky Monitor can verify its validity when the target domain attempts to return. On the other hand, a target domain might violate the calling convention defined by the application binary interface (ABI) and corrupt callee-saved registers. Our call wrapper ensures that these registers are restored. Furthermore, the call wrapper optionally erases non-argument registers upon a dcall to avoid information leakage towards the target domain. Similarly, to prevent information leakage to the calling domain, the target wrapper optionally erases the non-return-argument caller-saved registers before returning. Spectre attacks. Although Spectre attacks <ref type="bibr" target="#b44">[40]</ref> are outside our threat model, Donky can also reduce the attack surface by means of protection keys on Meltdown-resilient systems <ref type="bibr" target="#b17">[13,</ref><ref type="bibr" target="#b52">48]</ref>. <ref type="bibr">Kiriansky et al. [39]</ref> proposed to use Intel MPK to mitigate Spectre attacks by shielding sensitive data with a separate protection key. We reproduced this result with DonkyLib by constructing a Spectre V1 gadget that leaks a secret but is blocked as soon as protection keys are enforced. Therefore, Donky reduces the attack surface of Spectre attacks significantly, just as process-based isolation (e.g., site isolation <ref type="bibr" target="#b72">[67]</ref>) at significantly lower domain switch costs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Performance Evaluation</head><p>Donky's performance is characterized by the domain switch latency and the execution speed of isolated code and system call interposition. We used microbenchmarks to measure the domain switch latency and macro benchmarks to measure the performance impact of isolated code. The performance of real-world applications is evaluated in Section 7. Setup. We evaluated the performance on three different machines (1) an Intel Xeon 4208 running at 2.1 GHz and with 16 GB RAM, (2) an Amazon AWS c5.2xlarge instance with an Intel Xeon 8275CL running at 3.6 GHz and 16 GB RAM, and (3) our modified Ariane RISC-V CPU running on Xilinx Kintex-7 FPGA KC705 at 50 MHz. We use the Linux kernel version 5.0.0 for (1), 5.3.0 for (2), and 5.1.0 for (3) in its default configuration. Our microbenchmarks measure the latency in CPU cycles and compare it to the system call latency measured using LMbench <ref type="bibr" target="#b58">[54]</ref>. Code size. DonkyLib consists of 2693 lines of C code and 34 lines of generic assembly macros, as measured by sloccount. RISC-V adds 605+272, and our x86 implementation 516+226 lines of C and assembly code, respectively. This includes extensive error checks and debugging code. Latency. <ref type="figure">Figure 5</ref> shows Donky latencies relative to a null system call, as this represents the lowest possible time a kernel-based protection mechanism would need to switch domains. We ran each test 1000 times and plotted the mean runtime as well as the standard deviation. Simple Donky API calls to DonkyLib take 160 cycles (σ = 1.4 %) on RISC-V, as opposed to the getpid system call taking 724 cycles (σ = 1.9 %), as DonkyLib only needs to prepare its stack and Xeon 8275CL</p><p>Figure 5: Donky latency for domain switches , compared to system call latency (LMbench) . save a few registers. Due to the low latency, performance numbers vary across CPUs and Linux kernel versions. On Xeon 8275CL, simple API calls are even eleven times faster than a system call. To measure a single domain switch, we tested the latency of returning from a dcall to its caller (i.e., the dashed lines in <ref type="figure" target="#fig_0">Figure 2</ref>). To measure an isolated function call, we tested a full dcall that returns a static value (i.e., the solid and dashed lines in <ref type="figure" target="#fig_0">Figure 2</ref>). Their runtime is dominated by the domain switches, which include register saving and stack switching, alongside several security checks. Still, dcalls can compete with the fastest possible system calls. On RISC-V, it takes 2.8x the time of a null system call. For our Xeon 4208, it is 2.2x, while on a Xeon 8275CL CPU used in Amazon Web Services, it is even 66.9 % faster than a null system call. When compared to a full process context switch, as reported by LMbench, Donky is even 16-116x faster, making it a viable alternative for process-based isolation mechanisms.</p><p>Comparing against related work. <ref type="table" target="#tab_3">Table 2</ref> compares isolated function calls (dcalls) to other in-process schemes, according to their reported numbers. We collect the dcall/syscall ratio and raw dcall cycles to highlight architectural differences. Donky easily outperforms OS-based schemes <ref type="bibr" target="#b48">[44,</ref><ref type="bibr" target="#b54">50]</ref>. While virtualization seems to achieve good performance <ref type="bibr" target="#b55">[51]</ref>, the numbers only report overhead for switching translation tables, i.e., extended page tables, but do not prepare stacks or CPU registers necessary for a full dcall. Although the performance of capability-based systems is compelling <ref type="bibr" target="#b89">[85,</ref><ref type="bibr" target="#b92">88]</ref>, they require significant changes to both hardware and software. SGX has a different threat model, protecting enclaves from malicious operating systems <ref type="bibr" target="#b45">[41]</ref>. Other protection key systems either require significant kernel support for domain switches, instrumentation+CFI+W⊕X, or both <ref type="bibr">[15,</ref><ref type="bibr" target="#b86">82,</ref><ref type="bibr" target="#b103">99]</ref>. Especially CFI enforcement adds significant runtime overhead <ref type="bibr" target="#b86">[82]</ref> not shown here, as opposed to Donky. ARM discontinued protection key support, whose domain switch overhead could compete with Donky <ref type="bibr" target="#b103">[99]</ref> at the expense of kernel changes. Syscalls. To benchmark system call interposition on x86, we run LMbench once with and without our system call blacklisting kernel module. We could not observe measurable overhead even for the fastest Null system call, i.e., the overhead is below the variance. Triggering a blocked system call outside Donky Monitor terminates the application. To evaluate the performance overhead of our proposed RISC-V system call delegation, we benchmark the most restrictive sandboxing filter rule that denies all system calls for the sandboxed domain while allowing them for the root domain. As Donky Monitor can check the domain ID in optimized assembly, the overhead is only 30 cycles (13 instructions), compared to an unfiltered syscall. Thus, on RISC-V, the fastest system call (null system call) is slowed down by only 3.7 %. Computation. To test the impact of Donky on computation intense workloads without domain switches, we ran the SPEC CPU 2017 intspeed <ref type="bibr" target="#b78">[73]</ref> benchmark suite. Since SPEC is longrunning, it recommends three runs. To increase significance, we used ten runs. We preloaded DonkyLib with LD_PRELOAD and LD_BIND_NOW, which initializes itself upon process start and wraps the entire benchmark in a single domain. For comparison, we ran SPEC natively with LD_BIND_NOW to avoid bias. As expected, <ref type="figure" target="#fig_4">Figure 6</ref> shows that the isolated code runs de-facto at the same speed as native code. The geometric mean runtime overhead for the Xeon 8275CL is -0.16% (σ = 0.91%) and 0.10% (σ = 0.32%) for the Xeon 4208. Due to its high memory requirements, we could not run SPEC on our RISC-V platform. Memory overhead. DonkyLib uses metadata for managing domains, which mainly consist of an exception stack for each thread (i.e., 64 KiB), a stack for each actively used threaddomain combination (i.e., with the system's default stack size), and static domain data. This static data includes a list of memory regions along with their permissions and owners and a list of domains with their protection keys and trust-relationships. For 256 domains, each with at most 4096 memory regions, 1024 keys, and 256 threads, this amounts to 2 MiB of static data. Of course, these numbers could be optimized, e.g., by dynamically allocating only as much as is needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Case Studies</head><p>In this section, we evaluate three different real-world use cases. First, we modify the JavaScript engine V8 to provides strong Donky isolation, similar to process isolation (e.g., site isolation). Second, we sandbox the XML-parsing library TinyXML-2 <ref type="bibr" target="#b49">[45]</ref>, without changing the library. Third, we isolate the cryptographic library Mbed TLS without changing the library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Case Study 1: Strong JavaScript Isolation</head><p>JavaScript engines have a huge potential for vulnerabilities, such as memory corruption, incorrect compiler optimizations, type confusion, or erroneous code generation <ref type="bibr" target="#b37">[33]</ref>. The popular V8 JavaScript engine already uses so-called Isolates for separation, where an Isolate is one instance of a JavaScript runtime environment. While V8 Isolates already encapsulate all the required data, there is no hardware-enforced isolation. Hence, typical exploits escape V8 Isolates by injecting shellcode in their writable code cache <ref type="bibr" target="#b75">[70]</ref>, and previous work enforced a W⊕X policy <ref type="bibr" target="#b69">[64]</ref>. However, advanced sandbox escapes are still possible <ref type="bibr" target="#b37">[33,</ref><ref type="bibr" target="#b73">68]</ref>. In V8, WASM memory is writable and executable by default <ref type="bibr" target="#b84">[79]</ref>, allowing for the same injection attacks as on the code cache. As a first layer of defense, we use Donky to enforce a W⊕X policy on WASM memory. Furthermore, we add in-process isolation to V8 by encapsulating each Isolate in a separate domain. That is, each Isolate is assigned one domain key. Thus, even if an Isolate gains arbitrary code execution, it is sandboxed in its domain. Figure 8: V8 benchmark score with standard deviation running in Donky-protected V8 Isolates, compared to unprotected V8 (dotted line). Higher is better.</p><p>We modify V8 (version 8.1.99) to use one allocator per Isolate instead of a global allocator. These per-Isolate allocators leverage DonkyLib to allocate memory with the domain key of the Isolate. The root domain (A) creates Isolates and sets up protection keys and call gates. If a script is executed, the root domain dispatches the script execution to an Isolate, and we switch execution into its domain (B) (see <ref type="figure" target="#fig_5">Figure 7)</ref>. In V8, the WebAssembly (WASM) engine is shared between Isolates. Thus, we create a separate WASM allocator with an additional protection key (K3). Since WASM compilation happens in the root domain, we give the Isolate a read-only copy of its key (k3). Hence, a compromised Isolate cannot use WASM memory to inject custom shellcode. Even if it gains arbitrary code execution, the Isolate cannot access the root domain, since it does not have access to the root key (K1). Only a total of 358 LoC were changed in the V8 engine. Evaluation. To evaluate sandboxing of V8, we run three JavaScript benchmarks, namely Octane, Kraken, and SunSpider 500 times each. Note that the recommended number of repetitions is 10 for Octane, 100 for SunSpider, and 80 for Kraken <ref type="bibr" target="#b85">[81]</ref>. <ref type="figure">Figure 8</ref> shows the overall scores. In total, there is a performance overhead of 0 to 2 %.</p><p>WASM memory corruption is prevented by making its memory writable only by the root domain. To evaluate it, we ported a standard C benchmark program <ref type="bibr" target="#b81">[76]</ref> to WASM and measured the overhead between DonkyLib and the original unprotected code. We looped the setup of the WASM program and the calculations 100 times internally to produce WASM memory allocations, with 100 test repetitions, thus giving 10 000 repetitions of the experiment. In total, we observe a runtime overhead of about 2.96 % (σ = 1.02%).</p><p>To evaluate the security of our Donky V8 sandboxing, we model a strong attacker by providing an arbitrary read and write primitive accessible as global JavaScript functions. We simulate an exploit by performing reads and writes on memory that is not owned by the Isolate's domain. As expected, all memory corruption attempts on memory that is not explicitly assigned to the Isolate domain fail. Since unprotected memory (key zero) might still be vulnerable, one would also protect memory outside V8 from corruption by means of Donky.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Case Study 2: Third-Party Library</head><p>In the second case study, we consider an untrusted third-party library. In the threat model, we assume that the third-party library contains a vulnerability that can be exploited for arbitrary code execution. As this is often the case for parsingrelated activities, we show that Donky can isolate TinyXML-2 <ref type="bibr" target="#b49">[45]</ref>, an XML-parsing library.</p><p>To sandbox the library, we wrap the XMLDocument and XMLElement classes behind Donky dcalls. As these wrappers only call the original methods and handle the domain switch, they can be generated fully automated, similar to SGX Edger8r. Hence, the only difference for an application developer is a different name for the base class. This case study consists of 105 LoC and uses the unmodified TinyXML-2 library. We provide it as part of our open-source code. Evaluation. To evaluate the security benefits of sandboxing TinyXML-2, we introduce an artificial vulnerability in the library. Donky prevents the library from manipulating any data structures in the host domain, such as the stack. We verified that any such access to host data structures leads to an immediate abortion of the application. Hence, the library cannot mount return-oriented programming attacks on the host, as this can be done from SGX enclaves <ref type="bibr" target="#b76">[71]</ref>, for example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Case Study 3: Library as a Vault</head><p>In this case study, we show a different threat model, where DonkyLib protects a library from the rest of the application in a vault. We use Mbed TLS, a cryptographic library, with cryptographic keys as the assets to protect. In the threat model, we assume a vulnerability in the host application, which allows arbitrary memory reads, similar to the Heartbleed bug <ref type="bibr" target="#b97">[93]</ref>.</p><p>We isolate Mbed TLS in its own domain and expose all functions as dcalls. The host application can provide a custom memory allocator to Mbed TLS. By providing the memory management functions from DonkyLib, we ensure that all internal data structures and states of the library are protected with the same domain key. Furthermore, all cryptographic secrets are allocated using DonkyLib to protect them with the same key as the library. Cryptographic secrets are protected from the host application and are only modified through the API, resulting in a strong protection of these assets.</p><p>Evaluation. To evaluate the performance impact of the isolation using DonkyLib, we use Mbed TLS's integrated benchmarking suite <ref type="bibr">[5]</ref>. We added 95 LoC to the benchmark, which then uses the unmodified Mbed TLS library. <ref type="figure">Figure 9</ref> shows the overhead when using the cryptographic functions on a 1 KiB block of input data, which is the default choice. Internally, the benchmark runs for 1000 iterations for each cipher. We ran this experiment 10 times, resulting in a total number of 10 000 repetitions, and plotted their mean values as well as the standard deviations across the 10 runs. As a baseline, we use the performance of the unprotected Mbed TLS library. We group similar cryptographic functions (e.g., same algorithm but different key size) by summing up their respective runtimes. With a throughput of 96 % (geomean) compared to the unprotected version, the performance impact of Donky is minimal. Even the fastest operation (Poly1305), i.e., the function requiring the most domain switches, has only a small throughput reduction of 15 %.</p><p>To account for different block sizes, we compared Donky with process-based isolation by isolating Poly1305 using both techniques. We chose Poly1305 as it does most domain switches. Other algorithms would show significantly less overhead. For process isolation, we used a semaphore and shared memory for synchronization and pinned both processes to the same CPU core. As shown in <ref type="figure">Figure 10</ref>, at a block size of 16 Bytes, process-based isolation runs 42-118x slower, while Donky is only 2.9-4.7x slower.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Discussion</head><p>In this section, we discuss limitations as well as future work and elaborate on related work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Limitations and Future Work</head><p>Static Limits. Our prototype uses statically allocated arrays to store its metadata, which poses an upper limit on the number of domains, memory regions, and keys. To overcome these limits, one could dynamically allocate Donky Monitor's memory. Moreover, Donky is limited to 16 protection keys for x86 and 1024 for RISC-V. If an application needs more keys, one could schedule protection keys, as done by <ref type="bibr" target="#b69">[64]</ref>. Alternatively, one could resort to weaker probabilistic protection by reusing protection keys. We prototyped a virtualization scheme that hands out protection keys marked for virtualization multiple times. One could also increase the number of keys supported by the hardware, as mentioned in Section 5. Availability. DonkyLib is designed for security and, in-line with related shielding technologies, e.g., Intel SGX, denial-ofservice attacks are possible. One could retrofit DonkyLib with safety guarantees, e.g., by limiting the number of protection keys a domain can allocate, or rate-limiting the API calls. Thread-Local Storage. Previous work largely ignores the security of the TLS across domain switches. While Intel SGX is a notable exception, we believe more research is needed. SGX switches the TLS at enclave entry and exit, and Donky could similarly swap the TLS pointer for dcalls. <ref type="bibr" target="#b10">6</ref> However, SGX enclaves are built as standalone libraries without external dependencies, and code is never shared across domains. It is unclear whether and how secure code reuse across domains is possible, should this code make use of TLS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Related Work</head><p>Software-based Approaches. Software Fault Isolation (SFI) schemes <ref type="bibr" target="#b28">[24,</ref><ref type="bibr" target="#b30">26,</ref><ref type="bibr" target="#b57">53,</ref><ref type="bibr" target="#b77">72,</ref><ref type="bibr" target="#b90">86,</ref><ref type="bibr" target="#b99">95,</ref><ref type="bibr" target="#b102">98]</ref> use CFI and binary rewriting to confine sandboxes to a restricted memory area. In comparison to SFI, our context-switching overheads are higher, but the overhead within a domain is lower. Furthermore, Donky's threat model is stronger. We can isolate unmodified code without enforcing the control-flow integrity of isolated code. Because CFI usually requires W⊕X, it cannot easily support self-modifying code. This is a clear advantage for Donky. Also, some CFI schemes only offer probabilistic protection <ref type="bibr" target="#b46">[42]</ref>.</p><p>NaClJIT <ref type="bibr">[3]</ref> adds SFI to a JIT compiler with a runtime overhead of 50 to 60 % for V8. Other works <ref type="bibr" target="#b11">[7,</ref><ref type="bibr" target="#b14">10,</ref><ref type="bibr" target="#b39">35,</ref><ref type="bibr" target="#b54">50,</ref><ref type="bibr" target="#b79">74]</ref> rely on substantial kernel modifications to provide isolation between domains, such as, e.g., separate address spaces for threads <ref type="bibr" target="#b39">[35,</ref><ref type="bibr" target="#b91">87]</ref>.</p><p>NaCl <ref type="bibr" target="#b99">[95]</ref> and Dune <ref type="bibr" target="#b11">[7]</ref> can provide similar software-based system call filtering as Donky. However, in contrast to NaCl, Donky provides a mechanism to enforce these filters even when the application manages to break out of its SFI/CFI sandbox. Compared to Dune, Donky addresses multiple inprocess compartments not only on a thread boundary. Also, Donky's syscalls are significantly faster than Dune's. Hardware Protection Key Approaches. ERIM <ref type="bibr" target="#b86">[82]</ref> uses MPK for in-process isolation. Unlike Donky, they demand binary scanning and rewriting, alongside W⊕X. While they defer setting up private stacks to the developer, DonkyLib provides them by default. ERIM's binary rewriting could be integrated into a JIT compiler. However, it may lead to crashes if the compiler accidentally emits unsafe WRPKRU instructions. Also, the performance and implementation costs to adapt JIT compilers accordingly is unclear. However, NaClJIT <ref type="bibr">[3]</ref> could serve as a starting point for further research. <ref type="bibr">Koning et al. [41]</ref> survey different hardware isolation mechanisms such as Intel MPK and isolate safe regions (e.g., shadow stacks) atop of them. libmpk <ref type="bibr" target="#b69">[64]</ref> schedules protection keys for Intel MPK via expensive PTE updates if more than 16 keys are used.</p><p>ARMLock <ref type="bibr" target="#b103">[99]</ref> implements an in-process isolation framework using ARM's Memory Domains <ref type="bibr" target="#b8">[4]</ref>. Binary scanning is not required on ARM, as their protection key policy register cannot be written in userspace. ARMLock implements domains in the kernel, which increases the attack surfaces and likely impedes wide adoption. Also, ARM removed Memory Domains on 64-bit architectures. In contrast, Donky manages domain metadata and domain transitions entirely in userspace, which allows for faster inter-domain calls.</p><p>Shreds <ref type="bibr">[15]</ref> uses ARM's Memory Domains to isolate socalled shreds from the rest of an application. They do not support the sandboxing scenario, demand recompilation of inshred code, and a coarse-grained CFI policy. Different shreds cannot easily share data. Protection keys are lazily switched during context switches using an expensive page-  <ref type="bibr" target="#b67">[62]</ref>, and proposed RISC-V extensions <ref type="bibr" target="#b27">[23,</ref><ref type="bibr" target="#b47">43]</ref> protect against a malicious operating system. However, they require extensive hardware modifications, and communication between domains is typically slow.</p><p>Intel SGX <ref type="bibr" target="#b24">[20]</ref> runs code in so-called enclaves, which only allow an asymmetric trust model <ref type="bibr" target="#b94">[90]</ref>, in which an enclave has access to the entire process. Furthermore, they have a higher performance overhead <ref type="bibr" target="#b95">[91]</ref>. Recent work used MPK to also protect the host application from the enclave <ref type="bibr" target="#b94">[90]</ref> or to provide additional privilege separation within an enclave <ref type="bibr" target="#b59">[55]</ref>. Compartmentalization. Decomposing software to run in isolated compartments is an orthogonal problem. Previous work aids in finding suitable isolation boundaries, but splitting up existing software is still a hard problem <ref type="bibr" target="#b15">[11,</ref><ref type="bibr" target="#b38">34,</ref><ref type="bibr" target="#b55">51,</ref><ref type="bibr" target="#b87">83,</ref><ref type="bibr" target="#b88">84]</ref>. Choosing an isolation boundary is always a trade-off between fine isolation granularity and minimizing switching overhead and, hence, it often cannot be fully automated. <ref type="bibr">RLBox [59]</ref> identifies such compartmentalization boundaries in Firefox and designs secure interfaces. Furthermore, they automatically sanitize pointers across compartments to prevent confused deputy attacks. In contrast, Donky provides a strong, generic isolation framework RLBox could use to enforce their compartmentalization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion</head><p>In this paper, we proposed Donky, a hardware-software codesign solution for secure and efficient in-process isolation. It provides strong isolation guarantees with a negligible performance impact. It is fully backward compatible with existing software libraries and dynamically generated code (e.g., JIT). Donky relies on a small hardware extension of memory protection keys to back the security guarantees of our software framework called DonkyLib. We presented a fully working implementation on a RISC-V processor and showed that Donky can be implemented on top of commodity x86 processors with a minimal hardware extension. Our trusted monitor runs entirely in userspace, thus minimizing switching overhead as well as kernel complexity. DonkyLib works on both x86 and RISC-V CPUs and provides pure userspace domains atop protection keys through an intuitive API.</p><p>Donky combines the high performance of MPK with the security of kernel-based schemes. Donky cross-domain switches are 16-116x faster than process context switches and have only 4 % overhead compared to fully unprotected mbedTLS cryptographic operations. We support self-modifying code, just-in-time compilation, and in-process third-party binary sandboxing without scanning or rewriting instructions. This addresses recent challenges in JavaScript sandboxing, ranging from browsers and desktop applications to the cloud.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Donky cross-domain dcalls are managed purely in userspace by Donky Monitor, entered via a hardware call gate. Donky Monitor switches domains by switching stacks, updating the policy register (i.e., DKRU), and entering the new domain at a software-registered call gate.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Donky uses reserved top 10 bits of RISC-V page-table entries for protection keys.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Our RISC-V Donky userspace register (DKRU) has four protection key slots with optional write-disable (WD), a monitor bit, and software-defined (SW) space.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Normalized SPECint 2017 score, isolated with Donky. (Higher is better.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Interactions between root domain and V8 Isolates. Each Isolate and the WASM-Engine share a key. A separate allocator is created in the root domain.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :Figure 10 :</head><label>910</label><figDesc>Figure 9: Relative performance of Mbed TLS [6] benchmarks [5], when protected with Donky (higher is better). Similar cryptographic functions are grouped.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><head>Table 1 : Donky API handles protection keys and do- mains (did), and wraps some standard library calls ().</head><label>1</label><figDesc></figDesc><table>Donky API function 
Description 
dk_init(), dk_deinit() 
(De)Initialize DonkyLib 
dk_domain_create(), dk_domain_free(did) 
Create/destroy child domain 
dk_mmap([did], [key], addr, len, prot ...) 
Allocate memory 
dk_mprotect([did], addr, len, prot) 
Protect memory 
dk_munmap([did], addr, length) 
Deallocate memory 
dk_pkey_alloc(flags, access) 
Allocate protection key 
dk_pkey_mprotect([did], addr, len, prot, key) Assign memory a prot. key 
dk_pkey_free(key) 
Free an unused prot. key 
dk_domain_default_key(did) 
Get domain's default key 
dk_domain_assign_key(did, key, flags, acc) 
Assign prot. key to domain 
dk_domain_release_child(did) 
Untie child dom. from parent 
dk_domain_register_dcall([did], callid, entry) 
Register an dcall 
dk_domain_allow_caller([did], caller_did) 
Allow dcalls among domains 
dk_pthread_create(thread, attr, entry, arg) 
Create new thread 
dk_pthread_exit(retval) 
Exit thread 
dk_signal(sig, handler), dk_sigaction(sig, ...) Register signal handler 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head></head><label></label><figDesc>could be repurposed for automated copying of such data structures across dcalls. Multithreading. Donky natively supports POSIX threads. DonkyLib assigns threads to the domain that creates them. Each thread executes in exactly one domain at any point in time. It can switch domains via dcalls. Domains have private user stacks per thread, allocated lazily on first use. For example, in</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><head>Table 2 : Hardware-based In-process Isolation Systems</head><label>2</label><figDesc></figDesc><table>Scheme 
dcall/syscall 
(dcall cycles) 
CPU 
(Linux) 
kernel 
lwC [50] 

n.a. (5350*) 
Xeon X5650 
FreeBSD11 
x86-Rings [44] 
n.a. (~1400/1200) i7-4770/AMD1800X 4.13 
vmfunc [51] 

&gt;2x (n.a.) 
Xeon 3.4GHz 
3.13.7 
CHERI [88] 
C 
n.a. (500) 
CHERI 64-bit MIPS CheriBSD 
CODOMs [85] C 
0.1x (30) 
gem5-Nehalem 
2.6.27 
SGX [41] 

71x (7664) 
E3-1240v5 
3.19 
ARMLock [99] 
2.6x (385*) 
Raspberry Pi 
3.6.11 
Shreds [15] 

41.7x (n.a.) 
Raspberry Pi 2 B 
4.1.15 
ERIM [82] 

0.65x (99) 
Xeon 6142 
4.9.60 
Donky 

2.8x (2136) 
RISC-V Ariane 
5.1.0 
Donky 

2.2x (455) 
Xeon 4208 
5.0.0 
Donky 

0.3x (428) 
Xeon 8275CL 
5.3.0 

C Capabilities Enclave Protection keys * Computed from CPU freq. 
Domain switch via kernel 
No full context switch Instrumentation/CFI 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>table walk .</head><label>walk</label><figDesc></figDesc><table>Apart from [41, 64, 82], others did not open-source their 
code, hindering further research. We open-source both 
DonkyLib and our RISC-V hardware. 
Trusted Execution Environments. Intel SGX [20], ARM 
TrustZone [60], Sancus </table></figure>

			<note place="foot" n="1"> https://github.com/IAIK/Donky 2 It is currently in draft status for the RISC-V ISA 1.12.</note>

			<note place="foot" n="3"> Note that this assumption has to be made for any shielding system.</note>

			<note place="foot" n="1"> // Allocate domain-private memory 2 void* pmem = mmap(NULL, 4096, PROT_READ|PROT_WRITE...);</note>

			<note place="foot" n="4"> Note that Donky reuses Linux MPK support &quot;as is&quot; for allocating and assigning protection keys. The kernel is not aware of domains.</note>

			<note place="foot" n="5"> We interpose functions marked with in Table 1 via preloading (i.e., LD_PRELOAD, dlsym) or rewriting symbols with objcopy.</note>

			<note place="foot" n="6"> E.g., Donky Monitor could update the RISC-V tp register, which is otherwise protected by the monitor bit in DKRU.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank the anonymous reviewers, the artifact evaluators, and especially our shepherd, Nathan Dautenhahn, for their valuable suggestions and comments, which helped in improving the paper. This work has been supported by the Austrian Research Promotion Agency (FFG) via the competence center Know-Center (grant number 844595), which is funded in the context of COMET -Competence Centers for Excellent Technologies by BMVIT, BMWFW, and Styria, and via the project ESPRESSO, which is funded by the province of Styria and the Business Promotion Agencies of Styria and Carinthia. This project has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement No 681402). Additional funding was provided by generous gifts from Intel and from Cloudflare. Any opinions, findings, and conclusions or recommendations expressed in this paper are those of the authors and do not necessarily reflect the views of the funding parties.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A System Call Filter Example</head><p>Listing 2: DonkyLib user mode filters benefit from the full application context. Listing 2 shows how an application using Donky can constrain socket creation to the root domain (did=0) only (line 2). Furthermore, opening of files is bound to some login procedure via a global variable login and limited to the current directory (line 9).</p><p>Recent additions to the Linux kernel similarly allow such filters in userspace <ref type="bibr" target="#b22">[18]</ref>. However, unlike Donky, it requires kernel interaction and a separate thread or process.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Allocate (shared) protection key+memory 4 int key = pkey_alloc(0, 0)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prot_Read|prot_Write</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">* smem = mmap</title>
		<imprint>
			<biblScope unit="page">4096</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">6 pkey_mprotect(smem, 4096, PROT_READ|PROT_WRITE, key)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">12 dk_domain_allow_caller(child, current_did)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">// Do dcall 16 child_function(args)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Risc-V</forename><surname>Ariane</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cpu</surname></persName>
		</author>
		<ptr target="https://github.com/pulp-platform/ariane" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">A Collection of Chrome Sandbox Escape POCs/Exploits for learning</title>
		<ptr target="https://github.com/allpaca/chrome-sbx-db" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Language-independent sandboxing of just-in-time compilation and self-modifying code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Ansel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Petr</forename><surname>Marchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Úlfar</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elijah</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brad</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Derek</forename><forename type="middle">L</forename><surname>Schuff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Sehr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cliff</forename><surname>Biffle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bennet</forename><surname>Yee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="355" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
				<ptr target="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/BABBJAED.html" />
		<title level="m">ARM. ARM Developer Suite Developer Guide</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arm</forename><surname>Mbed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Benchmark</surname></persName>
		</author>
		<ptr target="https://github.com/ARMmbed/mbedtls/blob/master/programs/test/benchmark.c" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arm</forename><surname>Ssl Library Mbed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tls /</forename><surname>Polarssl</surname></persName>
		</author>
		<ptr target="https://tls.mbed.org/" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Dune: Safe User-level Access to Privileged CPU Features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Belay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Bittau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ali</forename><forename type="middle">José</forename><surname>Mashtizadeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Terei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Mazières</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christos</forename><surname>Kozyrakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="335" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Cache-Timing Attacks on AES</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bernstein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Guard&apos;s Dilemma: Efficient Code-Reuse Attacks Against Intel SGX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Biondo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mauro</forename><surname>Conti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lucas</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tommaso</forename><surname>Frassetto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Wedge: Splitting Applications into ReducedPrivilege Compartments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Bittau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Petr</forename><surname>Marchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brad</forename><surname>Karp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Privtrans: Automatically Partitioning Programs for Privilege Separation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><forename type="middle">Xiaodong</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Tale of Two Worlds: Assessing the Vulnerability of Enclave Shielding Runtimes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Oswald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eduard</forename><surname>Marin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abdulla</forename><surname>Aldoseri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Flavio</forename><forename type="middle">D</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Frank Piessens, Dmitry Evtyushkin, and Daniel Gruss. A Systematic Evaluation of Transient Execution Attacks and Defenses</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claudio</forename><surname>Canella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philipp</forename><surname>Benjamin Von Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ortner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fast byte-granularity software fault isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miguel</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Philippe</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Peinado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<meeting><address><addrLine>Austin Donnelly, Paul Barham, and Richard Black</addrLine></address></meeting>
		<imprint>
			<publisher>Periklis Akritidis</publisher>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Shreds: Fine-Grained Execution Units with Private Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yaohui</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhichuang</forename><surname>Sebassujeen Reymondjohnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Long</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">S&amp;P</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Introducing cloudflare workers: Run javascript service</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cloudflare</surname></persName>
		</author>
		<ptr target="https://blog.cloudflare.com/introducing-cloudflare-workers" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Practical Mitigations for TimingBased Side-Channel Attacks on Modern x86 Processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bart</forename><surname>Coppens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ingrid</forename><surname>Verbauwhede</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koen</forename><surname>De Bosschere</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bjorn</forename><forename type="middle">De</forename><surname>Sutter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">S&amp;P</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Deferring seccomp decisions to user space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Corbet</surname></persName>
		</author>
		<ptr target="https://lwn.net/Articles/756233/" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Intel 64 and IA-32 Architectures Software Developers Manual</title>
		<imprint>
			<date type="published" when="2019-10" />
		</imprint>
	</monogr>
	<note>Intel Corporation</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
				<ptr target="https://software.intel.com/en-us/sgx" />
		<title level="m">Intel Corporation. Intel Software Guard Extensions (Intel SGX</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
				<ptr target="https://software.intel.com/sgx-sdk" />
		<title level="m">Intel Corporation. Intel Software Guard Extensions</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Intel IA-64 architecture software developer&apos;s manual, revision 1</title>
		<imprint>
			<date type="published" when="2000-01" />
		</imprint>
	</monogr>
	<note>Intel Corporation</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Sanctum: Minimal Hardware Extensions for Strong Software Isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Victor Costan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ilia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinivas</forename><surname>Lebedev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">ISboxing: An Instruction Substitution Based Data Sandboxing for x86 Untrusted Libraries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qingkai</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yao</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information and Communication Technology</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="volume">455</biblScope>
		</imprint>
	</monogr>
	<note>SEC</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Will</forename><surname>Drewry</surname></persName>
		</author>
		<ptr target="https://lwn.net/Articles/475049/" />
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>RFC,PATCH 2/2] Documentation: prctl/seccomp_filter</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Vx32: Lightweight Userlevel Sandboxing on the x86</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bryan</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Russ</forename><surname>Cox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Risc-V</forename><surname>Foundation</surname></persName>
		</author>
		<ptr target="https://content.riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf" />
		<title level="m">The RISC-V Instruction Set Manual</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="volume">II</biblScope>
		</imprint>
	</monogr>
	<note>Privileged Architecture</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">The RISC-V Instruction Set Manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Risc-V</forename><surname>Foundation</surname></persName>
		</author>
		<ptr target="https://riscv.org/specifications/" />
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="volume">I</biblScope>
		</imprint>
	</monogr>
	<note>User-Level ISA, document version</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Privileged Architecture, document version 1.12-draft</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Risc-V</forename><surname>Foundation</surname></persName>
		</author>
		<ptr target="https://github.com/riscv/riscv-isa-manual/releases/download/draft-20200212-c3d1f07/riscv-privileged.pdf" />
	</analytic>
	<monogr>
		<title level="m">The RISC-V Instruction Set Manual</title>
		<imprint>
			<date type="published" when="2020" />
			<biblScope unit="volume">II</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">IMIX: In-Process Memory Isolation EXtension</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tommaso</forename><surname>Frassetto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Jauernig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Liebchen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Traps and Pitfalls: Practical Problems in System Call Interposition Based Security Tools</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tal</forename><surname>Garfinkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A survey of microarchitectural timing attacks and countermeasures on contemporary hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qian</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Cock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gernot</forename><surname>Heiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptographic Engineering</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Case Study of JavaScript Engine Vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">:</forename><surname>Github</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tunz</surname></persName>
		</author>
		<ptr target="https://github.com/tunz/js-vuln-db" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Clean Application Compartmentalization with SOAAP</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Khilan</forename><surname>Gudka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">M</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brooks</forename><surname>Chisnall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Davis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<meeting><address><addrLine>Ben Laurie, Ilias Marinos, Peter G. Neumann, and Alex Richardson</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Enforcing Least Privilege Memory Views for Multithreaded Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terry Ching-Hsiang</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><forename type="middle">J</forename><surname>Hoffman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Eugster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathias</forename><surname>Payer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Identifying Arbitrary Memory Access Vulnerabilities in Privilege-Separated Software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hong</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zheng</forename><surname>Leong Chua</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhenkai</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prateek</forename><surname>Saxena</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ES-ORICS</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="volume">9327</biblScope>
			<biblScope unit="page" from="312" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Power ISA version 3.0b</title>
	</analytic>
	<monogr>
		<title level="m">IBM Corporation</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Flipping bits in memory without accessing them: An experimental study of DRAM disturbance errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoongu</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ross</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremie</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Fallin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jihye</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donghyuk</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Wilkerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konrad</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Onur</forename><surname>Mutlu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">DAWG: A Defense Against Cache Timing Attacks in Speculative Execution Processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vladimir</forename><surname>Kiriansky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilia</forename><surname>Lebedev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saman</forename><surname>Amarasinghe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinivas</forename><surname>Devadas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><surname>Emer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018-05" />
		</imprint>
	</monogr>
	<note>ePrint 2018/418</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Spectre Attacks: Exploiting Speculative Execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Kocher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jann</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anders</forename><surname>Fogh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Werner</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Hamburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Prescher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">S&amp;P</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">No Need to Hide: Protecting Safe Regions on Commodity Hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koen</forename><surname>Koning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herbert</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristiano</forename><surname>Giuffrida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elias</forename><surname>Athanasopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROSYS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Code-Pointer Integrity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Volodymyr</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laszlo</forename><surname>Szekeres</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathias</forename><surname>Payer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Candea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Keystone: A Framework for Architecting TEEs. CoRR, abs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dayeol</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kohlbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shweta</forename><surname>Shinde</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krste</forename><surname>Asanovic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1907" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Lord of the x86 Rings: A Portable User Mode Privilege Separation Architecture on x86</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hojoon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chihyun</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brent Byunghoon</forename><surname>Kang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename><surname>Thomason</surname></persName>
		</author>
		<ptr target="https://github.com/leethomason/tinyxml2" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Linux kernel. Memory Protection Keys</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Linux kernel. SECure COMPuting with filters</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Meltdown: Reading Kernel Memory from User Space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Prescher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Werner</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anders</forename><surname>Fogh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jann</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<meeting><address><addrLine>Paul Kocher, Daniel Genkin, Yuval Yarom, and Mike Hamburg</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">A Linear Time Algorithm for Deciding Subject Security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Richard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lawrence</forename><surname>Lipton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Snyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Light-Weight Contexts: An OS Abstraction for Safety and Performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Litton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anjo</forename><surname>Vahldiek-Oberwagner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eslam</forename><surname>Elnikety</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deepak</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bobby</forename><surname>Bhattacharjee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Druschel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Thwarting Memory Disclosure with Efficient Hypervisor-enforced Intra-domain Isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yutao</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tianyu</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kexin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haibo</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yubin</forename><surname>Xia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">BOOMERANG: Exploiting the Semantic Gap in Trusted Execution Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aravind</forename><surname>Machiry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Gustafson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chad</forename><surname>Spensky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Salls</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Stephens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruoyu</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antonio</forename><surname>Bianchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yung</forename><forename type="middle">Ryn</forename><surname>Choe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giovanni</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Evaluating SFI for a CISC Architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Mccamant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Morrisett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">lmbench: Portable Tools for Performance Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Larry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carl</forename><surname>Mcvoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Staelin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcela</forename><forename type="middle">S</forename><surname>Melara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mic</forename><surname>Bowman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Enclavedom</surname></persName>
		</author>
		<title level="m">Privilege Separation for Large-TCB Applications in Trusted Execution Environments. CoRR, abs</title>
		<imprint>
			<date type="published" when="1907" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">MicroStache: A Lightweight Execution Context for In-Process Safe Region Isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lucian</forename><surname>Mogosanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashay</forename><surname>Rane</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Dautenhahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RAID, volume 11050 of LNCS</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Plundervolt: Software-based fault injection attacks against intel sgx</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kit</forename><surname>Murdock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Oswald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Flavio</forename><forename type="middle">D</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security and Privacy (S&amp;P)</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">FRAMER: a tagged-pointer capability system with memory safety applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Periklis</forename><surname>Myoung Jin Nam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">J</forename><surname>Akritidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Greaves</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACSAC</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m" type="main">Retrofitting Fine Grain Isolation in the Firefox Renderer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shravan</forename><surname>Narayan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Disselkoen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tal</forename><surname>Garfinkel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Froyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Rahm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sorin</forename><surname>Lerner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deian</forename><surname>Stefan</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Extended Version</note>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Corr</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">TrustZone Explained: Architectural Features and Use Cases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernard</forename><surname>Ngabonziza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anna</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haehyun</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sarah</forename><surname>Martin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIC</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Node</surname></persName>
		</author>
		<ptr target="https://nodejs.org/en/docs/es6/" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Sancus 2.0: A Low-Cost Security Architecture for IoT Devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Job</forename><surname>Noorman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><forename type="middle">Tobias</forename><surname>Mühlberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pieter</forename><surname>Maene</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bart</forename><surname>Preneel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ingrid</forename><surname>Verbauwhede</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johannes</forename><surname>Götzfried</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tilo</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Felix</forename><forename type="middle">C</forename><surname>Freiling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Priv. Secur</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title level="m" type="main">PA-RISC 1.1 architecture and instruction set reference manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hewlett</forename><surname>Packard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
	<note>third edition</note>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">libmpk: Software Abstraction for Intel Memory Protection Keys (Intel MPK)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soyeon</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sangho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wen</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hyungon</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">User mode interrupts: A must for securing embedded systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sandro</forename><surname>Pinto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cesare</forename><surname>Garlati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Embedded World Conference</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Preventing Privilege Escalation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Niels</forename><surname>Provos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Friedl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Honeyman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Site Isolation: Process Separation for Web Sites within the Browser</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Reis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Moshchuk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nasko</forename><surname>Oskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<monogr>
		<title level="m" type="main">Google Chrome 72.0.3626.121 / 74.0.3725.0 -&apos;NewFixedDoubleArray&apos; Integer Overflow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Google</forename><surname>Security Research</surname></persName>
		</author>
		<ptr target="https://github.com/riscv/riscv-isa-manual/releases/download/draft-20200212-c3d1f07/riscv-privileged.pdf" />
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">The protection of information in computer systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jerome</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">D</forename><surname>Saltzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="1975" />
			<biblScope unit="volume">63</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><surname>Gross</surname></persName>
		</author>
		<ptr target="http://www.phrack.org/papers/jit_exploitation.html" />
		<title level="m">Exploiting Logic Bugs in JavaScript JIT Engines</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Practical Enclave Malware with Intel SGX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><surname>Weiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DIMVA, volume 11543 of LNCS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Adapting Software Fault Isolation to Contemporary CPU Architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Sehr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cliff</forename><surname>Biffle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Victor</forename><surname>Khimenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Egor</forename><surname>Pasko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><surname>Schimpf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bennet</forename><surname>Yee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brad</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<monogr>
		<title level="m" type="main">Standard Performance Evaluation Corporation. SPEC CPU</title>
		<ptr target="https://www.spec.org/cpu2017" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Salus: Kernel Support for Secure Process Compartments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raoul</forename><surname>Strackx</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pieter</forename><surname>Agten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Niels</forename><surname>Avonds</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICST Trans. Security Safety</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">CLKSCREW: Exposing the Perils of SecurityOblivious Energy Management</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adrian</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simha</forename><surname>Sethumadhavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Salvatore</forename><forename type="middle">J</forename><surname>Stolfo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
				<ptr target="https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/nbody.html#nbody" />
		<title level="m">The Computer Language Benchmarks Game Team. Nbody C Benchmark</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<monogr>
		<title level="m" type="main">How can eBPF be compromised by vulnerabilities?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Teoh</surname></persName>
		</author>
		<ptr target="https://tthtlc.wordpress.com/2019/01/01/how-can-ebpf-be-compromised-by-vulnerabilities/" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<monogr>
				<ptr target="https://www.nytimes.com/2019/09/24/opinion/facebook-google-apps-data.html" />
		<title level="m">The New York Times. The Loophole That Turns Your Apps Into Spies</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<monogr>
		<title level="m" type="main">The official mirror of the V8 Git repository</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>V8</surname></persName>
		</author>
		<ptr target="https://github.com/v8/v8/blob/3fbeb93760bcf663dcf84b57597f49d7d3b29c02/src/flags/flag-definitions.h#L665" />
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<monogr>
				<ptr target="https://v8.dev/docs" />
		<title level="m">v8 developer blog</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">ERIM: Secure, Efficient In-process Isolation with Protection Keys (MPK)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anjo</forename><surname>Vahldiek-Oberwagner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eslam</forename><surname>Elnikety</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nuno</forename><forename type="middle">O</forename><surname>Duarte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Sammler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deepak</forename><surname>Garg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Towards Fine-grained, Automated Application Compartmentalization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikos</forename><surname>Vasilakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Karel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Roessler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Dautenhahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">André</forename><surname>Dehon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLOS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">BreakApp: Automated, Flexible Application Compartmentalization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikos</forename><surname>Vasilakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Karel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Roessler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Dautenhahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">André</forename><surname>Dehon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">M</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">CODOMs: Protecting software with Code-centric memory Domains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lluís</forename><surname>Vilanova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muli</forename><surname>Ben-Yehuda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nacho</forename><surname>Navarro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Etsion</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mateo</forename><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Efficient Software-Based Fault Isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Wahbe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Lucco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><forename type="middle">E</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Susan</forename><forename type="middle">L</forename><surname>Graham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<analytic>
		<title level="a" type="main">Between Mutual Trust and Mutual Distrust: Practical Fine-grained Privilege Separation in Multithreaded Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jun</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xi</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peng</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Fast Protection-Domain Crossing in the CHERI Capability-System Architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">M</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">M</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Norton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><forename type="middle">W</forename><surname>Woodruff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><forename type="middle">G</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brooks</forename><surname>Chisnall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Laurie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Roe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Nirav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Khilan</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Gudka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<editor>Alexandre Joannou, A. Theodore Markettos, Ed Maste, Steven J. Murdoch, Colin Rothwell, Stacey D. Son, and Munraj Vadera</editor>
		<imprint>
			<biblScope unit="page">36</biblScope>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">CHERI: A Hybrid Capability-System Architecture for Scalable Software Compartmentalization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">M</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><forename type="middle">G</forename><surname>Woodruff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><forename type="middle">W</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Chisnall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Nirav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brooks</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Khilan</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Gudka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><forename type="middle">J</forename><surname>Laurie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">M</forename><surname>Murdoch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Norton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stacey</forename><forename type="middle">D</forename><surname>Roe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Munraj</forename><surname>Son</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vadera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">S&amp;P</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">SGXJail: Defeating Enclave Malware via Confinement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><surname>Weiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luca</forename><surname>Mayr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RAID</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<monogr>
		<title level="m" type="main">Regaining Lost Cycles with HotCalls: A Fast Interface for SGX Secure Enclaves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ofir</forename><surname>Weisse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valeria</forename><surname>Bertacco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Todd</forename><forename type="middle">M</forename><surname>Austin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">ScatterCache: Thwarting Cache Attacks via Cache Set Randomization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mario</forename><surname>Werner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Unterluggauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lukas</forename><surname>Giner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Preventing Heartbleed</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">A</forename><surname>Wheeler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<analytic>
		<title level="a" type="main">Mondrian memory protection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmett</forename><surname>Witchel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Josh</forename><surname>Cates</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krste</forename><surname>Asanovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b99">
	<analytic>
		<title level="a" type="main">Native Client: A Sandbox for Portable, Untrusted x86 Native Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bennet</forename><surname>Yee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Sehr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><surname>Dardyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Bradley</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tavis</forename><surname>Ormandy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shiki</forename><surname>Okasaka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neha</forename><surname>Narula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Fullagar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">S&amp;P</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">The Cost of Application-Class Processing: Energy and Performance Analysis of a Linux-Ready 1.7-GHz 64-Bit RISC-V Core in 22-nm FDSOI Technology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Florian</forename><surname>Zaruba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luca</forename><surname>Benini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. VLSI Syst</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<monogr>
		<title level="m" type="main">executable-only-memory-switch (xom-switch): Hiding your code from advanced code reuse attacks in one shot</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mingwei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ravi</forename><surname>Sahita</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daiping</forename><surname>Liu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
			<pubPlace>Black Hat Asia</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">ARMor: fully verified software fault isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lu</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guodong</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bjorn</forename><forename type="middle">De</forename><surname>Sutter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Regehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EM-SOFT</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">ARMlock: Hardware-based Fault Isolation for ARM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yajin</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaoguang</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yue</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhi</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
