<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T01:58+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">CloudSense: Continuous Fine-Grain Cloud Monitoring With Compressive Sensing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">T</forename><surname>Kung</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Harvard University Cambridge</orgName>
								<address>
									<postCode>02138</postCode>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chit-Kwan</forename><surname>Lin</surname></persName>
							<email>cklin@eecs.harvard.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Harvard University Cambridge</orgName>
								<address>
									<postCode>02138</postCode>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dario</forename><surname>Vlah</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Harvard University Cambridge</orgName>
								<address>
									<postCode>02138</postCode>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">CloudSense: Continuous Fine-Grain Cloud Monitoring With Compressive Sensing</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Continuous fine-grain status monitoring of a cloud data center enables rapid response to anomalies, but handling the resulting torrent of data poses a significant challenge. As a solution, we propose CloudSense, a new switch design that performs in-network compression of status streams via compressive sensing. Using MapReduce straggler detection as an example of cloud monitoring, we give evidence that CloudSense allows earlier detection of stragglers, since finer-grain status can be reported for a given bandwidth budget. Furthermore, CloudSense showcases the advantage of an intrinsic property of com-pressive sensing decoding that enables detection of the slowest stragglers first. Finally, CloudSense achieves in-network compression via a low-complexity encoding scheme, which is easy and convenient to implement in a switch. We envision that CloudSense switches could form the foundation of a &quot;compressed status information plane&quot; that is useful for monitoring not only the cloud data center itself, but also the user applications that it hosts.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Status monitoring is an essential component to the smooth operation of today's cloud data centers, as quick responses to anomalies, failures or load have crucial business and performance ramifications. To be economical, clouds must strive for full utilization or high job throughput; thus, it pays to have the freshest server load information to avoid idling. Customer servicelevel agreements often stipulate system responsiveness requirements that must be met by rapid remediation of failures; this can only be achieved with quick notification via continuous fine-grain status reporting. Recent trends in cloud design and usage patterns further call for fine-grain and low-latency status reporting. For instance, frequent system-level status reports (heartbeats, temperature, network load) are crucial for better decision-making by automated data center management systems <ref type="bibr" target="#b6">[8]</ref> and for maintaining geographically distributed, container-based data centers <ref type="bibr" target="#b5">[7]</ref>, since more subsystem failures can occur as the total system scales up. At the application level, the increasing popularity of NoSQL systems has placed greater emphasis on interactive ad hoc querying, meaning that straggler tasks in the MapReduce jobs underlying NoSQL queries need to be quickly detected and mitigated in order to provide the user with a responsive system. In short, cloud data centers could greatly benefit from continuous, fine-grain and low-latency global status reports across many dimensions. But storing, transporting and processing the sheer volume of information poses a high data-rate sensing problem. Worse yet, anomaly detection mechanisms must often rely on collecting global status information in order to make global, relative comparisons. For example, straggler detection requires a relative metric since, by definition, straggling tasks are those that run slower than most others. This global information requirement means that data reduction solutions based on local comparisons and filtering are unsuitable. Existing solutions resort to reducing the data volume by either employing aggregation methods <ref type="bibr" target="#b12">[14]</ref> to lower the resolution of information or by sampling at a low rate <ref type="bibr" target="#b10">[12]</ref>. Unfortunately, neither strategy is amenable to continuous, fine-grain monitoring. This led us to consider an alternative: in-network compression of status messages.</p><p>We observe that the required bandwidth for each network link in a status collection tree <ref type="figure" target="#fig_0">(Figure 1</ref>), including the top link, depends mostly on the "sparsity" of the system, which in our case is the number of anomalies, rather than on a much larger quantity proportional to the total number of nodes. To exploit this, we rely on results in compressive sensing <ref type="bibr" target="#b2">[4]</ref> (CS), a technique in signal processing that enables simple encoding and exact reconstruction of a sparse signal given incomplete samples or measurements. In the literature, CS has been considered mainly as a compression technique for signal and imaging problem domains, since natural transforms into sparse domains (e.g., Fourier) are well-known. A major challenge in identifying other areas of applicability has been finding natural sparsity-inducing transforms for other kinds of signals. Here, we show that CS is also useful to discrete applications, such as status monitoring. This is possible because status anomalies are by definition sparse; in other words, the status signal itself directly exhibits sparsity, meaning we can simply use the identity transform.</p><p>CS is well-suited for in-network status message compression for two main reasons. First, it provides a simple encoding mechanism for switches at all levels of the network; fan-in at aggregation and core switches can be handled by simple addition operations. Second, it has a useful incremental decoding property-with just a few measurements, the largest anomaly can be recovered first; as more measurements are received, anomalies of smaller magnitude are recovered next. This "largest first" decoding property is perfectly suited for cloud monitoring, as large anomalies are typically revealed earlier to reporting nodes and need to be handled first.</p><p>We propose CloudSense, a compressive sensing switch design that enables continuous, low-overhead, innetwork compression of status reports. Using MapReduce straggler monitoring as an example, we give evidence of the benefits of CloudSense over conventional status reporting methods via analysis and emulation. Ultimately, we envision that CloudSense, together with software APIs, will comprise a compressed status information plane for the cloud data center, providing a simple platform for monitoring not only the cloud itself but also the user applications it hosts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Compressive Sensing</head><p>A full treatment of compressive sensing is beyond the scope of this paper; Candès and Wakin <ref type="bibr" target="#b3">[5]</ref> provide a good review for interested readers. Here, we aim to provide a high-level sketch of the mechanics of CS encoding and decoding and insights into how the technique can be useful in cloud monitoring.</p><p>Consider a real-valued, one-dimensional, length-N signal as a vector x = x 1 x 2 . . . x N . This signal can be represented as x = Ψs in a predetermined basis Ψ, and is called K-sparse if it is a linear combination of only K out of N basis vectors, i.e., only K coefficients in s are non-zero while the rest are zero, or if it can be approximated by such a linear combination. When K N , then the signal x is said to be compressible.</p><p>In CS, the signal x is sampled or encoded by a process that produces measurements y = Φx. Normally, when Φ is a full-rank N ×N matrix, the system of equations is complete and can be solved. However, the case of interest is when Φ is M × N , where M N , i.e., when the signal is compressed. This is a problem with infinitely many solutions, but compressive sensing theory states that a K-sparse signal x can be uniquely reconstructed with high probability when Φ is a random matrix and when M ≥ cK log(N/K), where c is a small constant. The reconstruction, or decoding, is usually performed</p><formula xml:id="formula_0">C E n j … n 2 n 1 T A x 1 x 2 x j . . . . . . yA = ΦAxA n N-1 n N . . .</formula><p>. . . via a linear programming optimization that solves the 1 -minimization problem:</p><formula xml:id="formula_1">min s∈R N s 1 subject to y = Φx, x = Ψs (1)</formula><p>An interesting property of the 1 -minimization is that the quality of the decoding is a function of M . In general, the larger the M , the more accurate the reconstruction. Furthermore, recovery is incremental: with small M , the largest components of s can be recovered, but as M grows, the remaining components are decoded.</p><p>The low complexity of encoding and the flexibility of incorporating any Ψ in decoding make CS a potential solution to cloud status monitoring. Indeed, CS has been proposed in monitoring data center temperature <ref type="bibr" target="#b9">[11]</ref>. In this paper, we extend the idea to new classes of applications related to data centers, including, e.g., CPU load monitoring for VM load spreading, per-flow bandwidth monitoring for heavy-hitter identification or even spam/DDoS detection. As mentioned earlier, we observe that CS is especially useful in scenarios where the notion of a "normal" status is relative and can only be determined by obtaining global information. One such example is in MapReduce straggler monitoring, which we will discuss in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">CloudSense Switch Design</head><p>The design of our CloudSense switch prototype dovetails with recent work on programmable switches, such as the SideCar <ref type="bibr" target="#b11">[13]</ref> and ServerSwitch <ref type="bibr" target="#b8">[10]</ref> projects. In fact, for our prototype implementation, we assume a hardware setup similar to SideCar: a CloudSense switch is comprised of a commodity switch connected to a general-purpose sidecar processor on a speciallydesignated port. <ref type="figure" target="#fig_0">Figure 1</ref> shows a typical data center topology with CloudSense switches and N rack nodes. Raw status messages (x i ) sent by rack nodes (n i ) are marked with a custom CloudSense IP protocol ID and a status type.</p><p>Each status type defines a reporting interval d and is user-specified. On arrival at a top-of-rack (TOR) switch (e.g., T A ), these packets are steered to the sidecar processor, which runs a CloudSense daemon that buffers messages of the same status type into epochs of duration d. Every epoch, the buffered messages in vector x A are encoded as y A = Φ A x A , where Φ A is an M × N A random matrix unique to T A with N A being the number of nodes under T A . (Recall that for status monitoring applications, Ψ can be the identity matrix. In this case, s is simply x.) y A , containing M coded measurements, is forwarded to an end-of-row/aggregation CloudSense switch E, which performs the same kind of packet steering as T A . Encoding at E, and subsequently at core switch C, is simple summing of y j . In a more optimized design, a CloudSense switch can perform summing operations with hardware, right at the Ethernet ports.</p><p>Note that CloudSense requires neither synchronization amongst switches or rack nodes, nor reliable delivery of measurements. While status may be reported in one epoch but not the next, CloudSense TOR switches always buffer the latest report and thus sends the freshest report available. This fundamental robustness against loss is another advantage of CS. Finally, CloudSense is able to achieve low-latency because CS encoding operations have such low complexity, meaning latency is just a function of the depth of the data center tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">MapReduce Straggler Monitoring</head><p>We use MapReduce straggler monitoring as an example scenario for CloudSense. Stragglers are often present in MapReduce jobs and can significantly prolong job completion times <ref type="bibr" target="#b0">[2]</ref>, reducing both job throughput and responsiveness. As jobs become even more parallelized and shorter (e.g., Hadoop plans to support &gt;200,000 cores <ref type="bibr">[1]</ref>) and as users expect ever-faster response, rapid straggler detection has become an increasingly important component of various mitigation methods (e.g., speculative pipelining <ref type="bibr" target="#b7">[9]</ref>). A conventional monitoring approach would need to gather O(N ) status reports to determine relative task progress and detect stragglers. In contrast, a CS approach would need just O(K log(N/K)) reports, where K is the number of anomalies. We expect K N .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Emulation Methodology and Results</head><p>We evaluated CS for MapReduce straggler monitoring using the following discrete-time emulation strategy. First, we generated traces of nominal task progress reports from an emulated MapReduce phase, split across N = 8000 nodes with one task per node. Each node's trace was generated by reading a large file (1GB) from its local disk and reporting its progress at each time step (100ms). This captures task progress jitter due to inde- The signal is the ground truth task duration of all 8,000 nodes in the emulated traces. There is an abrupt drop at 800 nodes because the traces were generated with K = 800 stragglers and all other nodes were considered normal. Signals such as this, which are sparse and have rapidly dropping tails, can have their largest components decoded early, with just a few measurements. pendent, random interrupts from other system processes on each node. Next, we designated K = 800 (10%) of the nodes to be stragglers and artificially dilated each of their progress traces by some factor S i , where K and the S i 's are drawn from distributions published by <ref type="bibr">Ananthanarayanan et al. ([2]</ref>, <ref type="figure" target="#fig_1">Figure 2</ref>). In practice, 1.5 ≤ S i ≤ 10 and we assume, for simplicity, that each straggler progresses at a constant rate before task completion. Finally, we emulated status messages arriving at a single TOR CloudSense switch by aligning the traces and considering each time step as a signal vector x. At each time step, the emulated CloudSense switch encoded y = Φx, resulting in M measurements. Below, we refer to the decoding of each such time step a separate "CS instance".</p><p>Here, it is instructive to note that CS decoding has three failure conditions. First, CS decoding is only successful with high probability. However, CS permits more frequent reporting, meaning a rare decoding failure can be quickly corrected by decoding a subsequent message. Second, CS decoding can fail if the magnitudes of the sparse signal components do not rise significantly above the signal noise (i.e., the measured signal is not sufficiently sparse). This can occur, e.g., when there are insufficient statistics at the beginning of a MapReduce phase to reliably report progress. Third, even if progress is reliably reported, the recovered solution may not identify all stragglers correctly when M is too small. Fortunately, CS may still recover large anomalies in this case. <ref type="figure" target="#fig_1">Figure 2</ref> illustrates a signal vector x, used in our evaluations below, involving 8,000 nodes and sorted according to each node's ground truth task duration. Since severe stragglers with long durations constitute a small percentage of the total population, the signal is sparse. Moreover, the signal tail drops rapidly, meaning the number of measurements required to accurately decode the largest magnitude anomalies is low <ref type="bibr" target="#b1">[3]</ref> and decoding can occur early, as soon as the first few measurements are received. In Evaluations 1 and 2 below, we are interested in knowing the effect of M on decoding accuracy for such signals, even when M is relatively small. That is, we want to characterize how the tail behavior of the straggler signal governs the accuracy of the decoded solution for a given M in order to give a sense of how useful this early decoding property is.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Evaluation 1: Decoding Accuracy</head><p>We first evaluate CS decoding accuracy. In any given CS instance, we compared the set of stragglers identified by CS to the known set of stragglers in the ground truth by computing two quantities: 1) false positives, i.e., the number of nodes incorrectly identified as stragglers by CS, and 2) false negatives, i.e., the number of nodes that were stragglers, but which CS failed to identify.</p><p>In <ref type="figure" target="#fig_2">Figure 3</ref>, we plotted these quantities for a range of values for M , at two representative points in time. There are two noteworthy observations; first, the number of false positives is relatively small regardless of the M value. Thus, when the number of measurements is insufficient for accurate decoding, CS errs conservatively by identifying just a few nodes as stragglers. Second, as M increases, we see that the number of false negatives decreases at a consistent rate, indicating that by tuning M , we can control the accuracy over a wide range.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Evaluation 2: Early Detection of Worst Stragglers</head><p>Decoding accuracy alone does not tell the whole story on the effectiveness of CS in straggler monitoring. A more relevant metric is the maximum duration of undetected stragglers; even if complete detection is not achieved, CS could be deemed successful if it can identify the most egregious stragglers. <ref type="figure" target="#fig_3">Figure 4</ref> shows the maximum durations of the undetected stragglers for the same set of CS instances as in the previous section.</p><p>Even though the decoding may not be exact, as M increases, CS tends to detect the more extreme stragglers first; as a result, the maximum duration of undetected stragglers drops off relatively early. This property, char- Figure 5: At t = 10s, the fraction of undetected stragglers (i.e., false negatives) whose durations are 2, 3, and 4 times greater than the median task duration, respectively.</p><p>acteristic of compressive sensing, is useful because it matches well the goal of our application. With fewer measurements, CS identifies just the largest-ostensibly most important-stragglers. With more measurements, CS can identify the remaining stragglers of progressively smaller magnitudes. This is behavior is clearly illustrated in <ref type="figure">Figure 5</ref>, where we have further broken down the undetected stragglers at CS instance t = 10s into those that have task durations greater than 2, 3 and 4 times the median task duration. With small M , most of the worst stragglers (4x) are successfully detected leaving the remainder to comprise a relatively small fraction of the undetected straggler population. As M increases, the fraction of worst stragglers (4x) declines to near zero earlier-at M ≈ 2, 500-as opposed to at M ≈ 3, 500 for less severe stragglers (2x). The largest-straggler-first property suggests that an iterative method might perform even better in straggler removal. In particular, one might use CS with small M at first to identify a few of the slowest stragglers, remove them from the input, and then have an easier time identifying the remainder in the subsequent iterations. Under a separate paper, we have developed a theory for this it- Figure 6: Number of measurements M needed over time to identify stragglers whose durations are larger than 2, 3, or 4 times the median duration, respectively. Only the first 5s of the emulated job is shown. Data points before 0.5s are artifacts related to task start time jitter and should be ignored.</p><p>erative decoding <ref type="bibr" target="#b4">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Evaluation 3: CS Signal Recovery Over Time</head><p>We next examine the performance of CS over time by reporting the number of measurements per time step needed to eliminate all stragglers which exceed a specified maximum duration. <ref type="figure">Figure 6</ref> shows the resulting M values for several maximum durations.</p><p>The main feature of the results are the peaks in M at t ≤ 1s. There are three major factors contributing to the observed shape:</p><p>1) Before the onset of the peak, M starts out small, indicating that the progress vector is sparse. This explained by jitter in task start times; in the beginning, a minority of the tasks start early, reporting a non-zero progress, while the majority of tasks have yet to start, and so report zero progress. This constitutes a sparse input to CS, although the detected anomalies are not stragglers at this point.</p><p>2) During the peak itself, M is large, indicating a lack of sparsity. This is explained by the fact that most tasks have started by now, reporting a small amount of progress. The stragglers' progress at this point is too small to stand out from the jitter noise; thus, the sparsity in the input vector is weak, requiring a large M to decode at the required level.</p><p>3) Finally, after the peak, M decreases again, indicating that inputs are again sparse. We can explain this by the fact that stragglers have grown enough to stand out.</p><p>It is evident that the earliest time we can detect most of the stragglers using a low number of measurements is at the end of the peak in <ref type="figure">Figure 6</ref>, when the stragglers "reveal" themselves. Given a higher reporting frequency of CS, on average we can find such points much earlier than with standard RPC reporting as in Apache Hadoop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Evaluation 4: Compression Ratio</head><p>Finally, we consider the compression performance of CS. Since the major advantage of CS lies in its unique ability to detect the largest magnitude anoma- lies early, we define the CloudSense compression ratio to be the number of messages needed to detect the worst (4x) stragglers relative to the M = 8, 000 required by Hadoop's RPC method. <ref type="figure" target="#fig_5">Figure 7</ref> (K = 800, red) shows the compression ratio of CS over the first 5s of our emulated MapReduce job, for the case where stragglers comprise 10% of nodes. Given the same bandwidth budget, CloudSense allows ∼2.7x more status messages to be sent, or a 60% shorter reporting interval. This compression ratio can be improved significantly when there are fewer stragglers, since the number of messages required by CS to decode is dependent on the sparsity K (i.e., the number of stragglers) of the signal. <ref type="figure" target="#fig_5">Figure 7</ref> illustrates the improved compression ratios when stragglers comprise only 5% (K = 400, green) and 1% (K = 80, blue) of nodes. In these cases, CloudSense can send ∼4.2x and ∼16.3x more status messages, respectively. For comparison, <ref type="figure" target="#fig_5">Figure 7</ref> also shows the compression lower bound (grey), as dictated by the entropy of the 1% straggler signal; CloudSense can approach the bound in this case.</p><p>Such compression ratios could also be achieved by conventional compression methods such as entropy coding. However, these methods suffer from several significant qualitative drawbacks. First, unlike CS, entropy coding requires correlation amongst messages near the sources in the routing topology to achieve low compression ratios; maximizing this would require jointly optimizing routing and compression. Second, standard algorithms such as Lempel-Ziv are more difficult to implement in switches than CS encoding, even on programmable ones <ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b8">10]</ref>. Third, at tree fan-in points, conventionally compressed messages must either be decompressed and recompressed in order to be combined (which introduces latency) or be simply forwarded (which wastes bandwidth). In contrast, CS encoding can be performed at all levels of the network tree quickly.</p><p>Finally, CS offers unique advantages, such as "largest first" partial decoding, that conventional methods do not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions</head><p>We have presented a novel use of compressive sensing: in-network compression of data center status messages. We argue that compressive sensing is a natural fit for this problem domain for two main reasons: (1) its low-complexity compression scheme enables continuous, fine-grain and low-latency cloud status monitoring; and (2) its "largest first" partial decoding property allows for early detection of the most severe anomalies. Additionally, the false positives that arise from such partial recovery do not severely impact the performance of cloud applications, such as MapReduce jobs. In the context of MapReduce straggler monitoring, we have developed a framework to analyze the tradeoff between communication costs (M ) and decoding accuracy/straggler improvement. Finally, our proposed CloudSense switch design illustrates that compressive sensing provides a convenient, low-complexity encoding method for innetwork compression that is simple to implement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Towards a Compressed Status Information Plane</head><p>We envision a general monitoring service, or compressed status information plane for the cloud data center, comprised of three components. First, a centralized registry would track each status message type (e.g., by allocating unique IDs), inform CloudSense switches of each type's requisite reporting interval and act as a lookup service for type discovery by monitoring applications ("monitors" for short). Second, CloudSense switches would encode multiple status streams of different types at the same time, with each stream possibly being tapped by multiple monitors simultaneously. Third, a software API would permit monitors to look up status types of interest in the centralized registry and to tap into those streams at any switch in the data center network. Different monitors tapping into the same status stream, but requiring different levels of status fidelity, can be supported naturally by exploiting CS's "largest first" decoding property: those requiring less fidelity could simply collect fewer measurements and decode earlier than those requiring higher fidelity. Within the rubric outlined above, standard status messages such as CPU or network load could be registered by the data center operator as default status streams. But, as we have illustrated using MapReduce, cloud software infrastructures and even user applications could be instrumented to report statuses (e.g., performance counter values) in a standard way via the compressed status information plane. We believe this general framework could open up new possibilities for performance monitoring of cloud-hosted applications in the future.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: A status information collection tree where nodes ni are reporting entities under CloudSense monitoring. TA, E and C are CloudSense switches. This represents a simplified data center network topology.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: A sorted straggler signal vector x. The signal is the ground truth task duration of all 8,000 nodes in the emulated traces. There is an abrupt drop at 800 nodes because the traces were generated with K = 800 stragglers and all other nodes were considered normal. Signals such as this, which are sparse and have rapidly dropping tails, can have their largest components decoded early, with just a few measurements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Decoding accuracy vs. number of measurements at two representative points in time. The performance at later times was not significantly different from that at t = 10s. The decoding accuracy is computed as the number of false positives and negatives, when compared to the ground truth.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Maximum duration of undetected stragglers vs. number of measurements M . The duration is calculated relative to the median; e.g., a value of 8 indicates a task which runs 8x as long as the median. Two representative time steps are shown; beyond t = 10s the error behavior does not change significantly. The flat portions of the curves at small M are due to the task duration distribution we used to generate the ground truth; the maximum duration present there was 10.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The CloudSense compression ratio improves as the percentage of straggling nodes decreases, i.e., as the sparsity of the straggler signal increases. For comparison, we show the lower bound on compression given by the entropy of the trace where only 1% of nodes are stragglers. In this case, CloudSense approaches the bound.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This material is based on research sponsored by Air Force Research Laboratory under agreement number FA8750-10-2-0180. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of Air Force Research Laboratory or the U.S. Government. The authors would like to thank the Office of the Secretary of Defense (OSD/ASD(R&amp;E)/RD/IS&amp;CS) for their guidance and support of this research.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Reining in the Outliers in Map-Reduce Clusters using Mantri</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ananthanarayanan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Stoica</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harris</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The restricted isometry property and its implications for compressed sensing. Comptes Rendus de l&apos;Acad˜AAcad˜ Acad˜A c mie des sciences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cand`escand` Cand`es</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Paris. Series I</title>
		<imprint>
			<biblScope unit="volume">346</biblScope>
			<biblScope unit="page">589</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Robust uncertainty principles: exact signal reconstruction from highly incomplete frequency information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cand`escand` Cand`es</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Romberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Info. Theory</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="489" to="509" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An Introduction To Compressive Sampling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cand`escand` Cand`es</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wakin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Sig. Proc. Mag</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="21" to="30" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Separation-based joint decided in compressive sensing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kung</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCCN</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The cost of a cloud: research problems in data center networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greenberg</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Maltz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patel</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. Rev</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="68" to="73" />
			<date type="published" when="2008" />
			<publisher>SIGCOMM Comp</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Autopilot: automatic data center management</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isard</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGOPS Op. Sys. Rev</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="60" to="67" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Speculative pipelining for compute cloud programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kung</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">T</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-K</forename><surname>Vlah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Scorza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MILCOM</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Serverswitch: A programmable and high performance platform for data center networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
		<idno>MSR-TR-2011-24</idno>
		<imprint>
			<date type="published" when="2011" />
			<pubPlace>Microsoft Research Asia</pubPlace>
		</imprint>
	</monogr>
<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Compressive data gathering for large-scale wireless sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luo</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">W</forename></persName>
		</author>
		<editor>MobiCom</editor>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The ganglia distributed monitoring system: design, implementation, and experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Massie</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Parallel Computing</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="817" to="840" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">SideCar: building programmable datacenter networks without programmable switches</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shieh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sirer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">G</forename></persName>
		</author>
		<editor>HotNets</editor>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Astrolabe: A robust and scalable technology for distributed system monitoring, management, and data mining</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Van Renesse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">P</forename><surname>Birman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vogels</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comp. Sys</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="164" to="206" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
