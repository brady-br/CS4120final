<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:20+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Touchstone: Generating Enormous Query-Aware Test Databases Touchstone: Generating Enormous Query-Aware Test Databases</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>July 11-13. 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuming</forename><surname>Li</surname></persName>
							<email>liyuming@stu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rong</forename><surname>Zhang</surname></persName>
							<email>rzhang@sei</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaoyan</forename><surname>Yang</surname></persName>
							<email>xiaoyan.yang@yitu-inc.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhenjie</forename><surname>Zhang</surname></persName>
							<email>zhenjie.zhang@yitu-inc.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuming</forename><surname>Li</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">East China Normal University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rong</forename><surname>Zhang</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">East China Normal University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaoyan</forename><surname>Yang</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Singapore R&amp;D</orgName>
								<orgName type="institution">Yitu Technology Ltd</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhenjie</forename><surname>Zhang</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Singapore R&amp;D</orgName>
								<orgName type="institution">Yitu Technology Ltd</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aoying</forename><surname>Zhou</surname></persName>
							<email>ayzhou@dase.ecnu.edu.cn</email>
							<affiliation key="aff2">
								<orgName type="institution">East China Normal University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">East China Normal University</orgName>
								<orgName type="institution" key="instit2">Singapore R&amp;D</orgName>
								<orgName type="institution" key="instit3">Yitu Technology Ltd</orgName>
								<address>
									<addrLine>Aoying Zhou</addrLine>
									<country>East China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Normal University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Touchstone: Generating Enormous Query-Aware Test Databases Touchstone: Generating Enormous Query-Aware Test Databases</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2018 USENIX Annual Technical Conference (USENIX ATC &apos;18)</title>
						<meeting>the 2018 USENIX Annual Technical Conference (USENIX ATC &apos;18) <address><addrLine>Boston, MA, USA</addrLine></address>
						</meeting>
						<imprint>
							<date type="published">July 11-13. 2018</date>
						</imprint>
					</monogr>
					<note>Open access to the Proceedings of the 2018 USENIX Annual Technical Conference is sponsored by USENIX. https://www.usenix.org/conference/atc18/presentation/li-yuming This paper is included in the</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Query-aware synthetic data generation is an essential and highly challenging task, important for database management system (DBMS) testing, database application testing and application-driven benchmarking. Prior studies on query-aware data generation suffer common problems of limited parallelization, poor scalability, and excessive memory consumption, making these systems unsatisfactory to terabyte scale data generation. In order to fill the gap between the existing data generation techniques and the emerging demands of enormous query-aware test databases, we design and implement our new data generator , called Touchstone. Touchstone adopts the random sampling algorithm instantiating the query parameters and the new data generation schema generating the test database, to achieve fully parallel data generation, linear scalability and austere memory consumption. Our experimental results show that Touchstone consistently outper-forms the state-of-the-art solution on TPC-H workload by a 1000× speedup without sacrificing accuracy.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The applications of query-aware data generators include DBMS testing, database application testing and application-driven benchmarking <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b14">15]</ref>. For example, during the database selection and performance optimization, the internal databases in production are hard to be shared for performance testing due to the privacy considerations, so we need to generate synthetic databases with the similar workload characteristics of the target queries. A bulk of existing data generators, e.g., <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b19">20]</ref>, generate test databases independent of the test queries, which only consider the data distribution of inter-and intra-attribute. They fail to guarantee the similar workload characteristics of the test queries, therefore it's difficult to match the overheads of the query execution engine for real world workloads. A number of other studies, e.g., <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b14">15]</ref>, attempt to build query-aware data generators. But the performance of the state-of-the-art solution MyBenchmark <ref type="bibr" target="#b14">[15]</ref> still remains far from satisfactory, due to the lack of parallelization, scalability and memory usage control, as well as the narrow support of non-equi-join workload. In order to generate the enormous query-aware test databases, we design and implement Touchstone, a new query-aware data generator, based on the following design principles: * Rong Zhang is the corresponding author.</p><p>Full Parallelization: With the explosive growth of data volume in the industrial applications, the database system is expected to support storage and access services for terabyte or even petabyte scale data. So the synthetic data generator must be fully parallel for generating such extremely large test databases. Linear Scalability: The single machine has been far from meeting the requirements of generating large test databases, and the data scales may be unbelievably big for the future applications, therefore the data generator needs to be well scalable to multiple nodes and data size. Austere Memory Consumption: When generating the synthetic database for multiple queries, memory could easily be the bottleneck, because massive information is maintained by the data generator in order to guarantee the dependencies among columns. The memory usage needs to be carefully controlled and minimized.</p><p>Since <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b14">15]</ref> are closest to the target of this work, we list the following key insufficiencies of these studies for elaborating the necessity of proposing Touchstone. In particular, all of these approaches do not support fully parallel data generation in a distributed environment due to the primitive data generation algorithms over the huge shared intermediate state, limiting the efficiency of data generation over target size at terabytes. Moreover, their memory consumptions, e.g., symbolic databases of QAGen <ref type="bibr" target="#b5">[6]</ref>, constrained bipartite graphs of WAGen <ref type="bibr" target="#b13">[14]</ref> and MyBenchmark <ref type="bibr" target="#b14">[15]</ref>, caching referenced tables for generating foreign keys of DCGen <ref type="bibr" target="#b4">[5]</ref>, strongly depend on the size of generation outputs. Once the memory is insufficient to host the complete intermediate state, vast computational resources are wasted on disk I/O operations. In addition, one key advantage of our work is the support of non-equi-join workload, which is important for real world applications but not supported by any of the existing approaches.</p><p>In query-aware data generation, we need to handle the extremely complicated dependencies among columns which are caused by the complex workload characteristics specified on the target test queries, as well as the data characteristics specified on the columns. Touchstone achieves fully parallel data generation, linear scalability and austere memory consumption for supporting the generation of enormous query-aware test databases. There are two core techniques employed by Touchstone beneath the accomplishments of all above enticing features. Firstly, Touchstone employs a completely new query instantiation scheme adopting the random sampling algorithm, which supports a large and useful class of queries. Secondly, Touchstone is equipped with a new data generation scheme using the constraint chain data structure, which easily enables thread-level parallelization on multiple nodes. In summary, Touchstone is a scalable query-aware data generator with a wide support to complex queries of analytical applications, and achieves a 1000× performance improvement against the state-ofthe-art work MyBenchmark <ref type="bibr" target="#b14">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries 2.1 Problem Formulation</head><p>The input of Touchstone includes database schema H, data characteristics D and workload characteristics W , as illustrated in <ref type="figure">Figure 1</ref>. H defines data types of columns, primary key and foreign key constraints. In <ref type="figure">Figure 1</ref>, there are three tables R, S, and T . For example, table S has 20 tuples and three columns. Data characteristics D of columns are defined in a meta table, in which the user defines the percentage of Null values, the domain of the column, the cardinality of unique values and the average length and maximum length for varchar typed columns. In our example, the user expects to see 5 unique values on column R.r 2 in the domain <ref type="bibr">[0,</ref><ref type="bibr" target="#b9">10]</ref>, and 8 different strings with an average length of 20 and a maximum length of 100 for column T.t 3 with 20% Null values. Workload characteristics W are represented by a set of parameterized queries which are annotated with several cardinality constraints. In <ref type="figure">Figure 1</ref>, our sample input consists of four parameterized queries, i.e., Q = {Q 1 , Q 2 , Q 3 , Q 4 }. These four queries contain 11 variable parameters, i.e., P = {P 1 , P 2 , ..., P 11 }. Each filter/join operator in the queries is associated with a size constraint, defining the expected cardinality of the processing outcomes. Therefore, there are 14 filter/join operators and corresponding 14 cardinality constraints in our example, i.e., C = {c 1 , c 2 , ..., c 14 }. Our target is to generate the three tables and instantiate all the variable query parameters. In the following, we formulate the definition of cardinality constraints.</p><p>Definition 1 Cardinality Constraint: Given a filter (σ ) or join () operator, a cardinality constraint c is denoted as a triplet c = <ref type="bibr">[Q, p, s]</ref>, where Q indicates the involving query, p gives the predicate on the incoming tuples, and s is the expected cardinality of operator outcomes.</p><p>The cardinality constraint c 1 in <ref type="figure">Figure 1</ref>, for example, is written as [Q 1 , R.r 2 &lt; P 1 , 4], indicating that the operator with predicate R.r 2 &lt; P 1 in query Q 1 is expected to output 4 tuples. For conjunctive and disjunctive operators, their cardinality constraints can be split to multiple cardinality constraints for each basic predicate using standard probability theory. These cardinality constraints generally characterize the computational workload of query processing engines, because the computational overhead mainly depends on the size of the data in processing. This hypothesis is verified in our experimental evaluations.</p><p>While the focus of cardinality constraints is on filter and join operators, Touchstone also supports complex queries with other operators, including aggregation, groupby and orderby. For example, the query Q 2 in Figure 1 applies groupby operator on T.t 3 and summation operator on S.s 3 over the grouped tuples. The cardinality of the output tuples from these operators, however, is mostly determined, if it does not contain a having clause. And such operators are usually engaged on the top of query execution tree, hence the output result cardinalities generally do not affect the total computational cost of query processing. Based on these observations, it is unnecessary to pose explicit cardinality constraints over these operators <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b4">5]</ref> in Touchstone.</p><p>Based on the target operators (filter or join) and the predicates with equality or non-equality conditional expressions, we divide the cardinality constraints into four types, i.e.,</p><formula xml:id="formula_0">C = C σ = ∪ C σ = ∪ C = ∪ C = .</formula><p>Accordingly, we classify the example constraints in <ref type="figure">Figure 1</ref> as</p><formula xml:id="formula_1">C σ = = {c 2 , c 5 , c 8 , c 10 } 1 , C σ = = {c 1 , c 4 , c 7 , c 12 , c 13 }, C = = {c 3 , c 6 , c 9 , c 11 } and C = = {c 14 }.</formula><p>Following the common practice in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b24">25]</ref>, the equi-join operator is always applied on the pair of primary and foreign keys.</p><p>Then we formulate the problem of query-aware data generation as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 2 Query-Aware Data Generation Problem:</head><p>Given the input database schema H, data characteristic D and workload characteristics W , the objective of data generation is to generate a database instance (DBI) and instantiated queries, such that 1) the data in the tables strictly follows the specified data characteristics D; 2) the variable parameters in the queries are appropriately instantiated; and 3) the executions of the instantiated queries on the generated DBI produce exactly the expected output cardinality specified by workload characteristics W on each operator.</p><p>While the general solution to query-aware data generation problem is NP-hard <ref type="bibr" target="#b20">[21]</ref>, we aim to design a data generator, by relaxing the third target in the definition above. Specifically, the output DBI is expected to perform as closely as the cardinality constraints in C. Given the actual/expected cardinalities of processing outputs, i.e., { ˆ s 1 , ˆ s 2 , . . . , ˆ s n }, corresponding to constraints on the queries in C = {c 1 , c 2 , . . . , c n }, we aim to minimize the global relative error Touchstone still attempts to generate a DBI with the best effort.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Overview of Touchstone</head><p>The infrastructure of Touchstone is divided into two components, which are responsible for query instantiation and data generation respectively, as shown in <ref type="figure">Figure 2</ref>. Query Instantiation: Given the inputs including database schema H, data characteristics D, Touchstone builds a group of random column generators for non-key columns, denoted by G, each G i in which corresponds to a column of the target tables. Given the input workload characteristics W , Touchstone instantiates the parameterized queries by adjusting the related column generators if necessary and choosing appropriate values for the variable parameters in the predicates of c ∈ C σ = ∪ C σ = ∪ C = . The instantiated queries ¯ Q are output to the users for reference, while the queries ¯ Q and the adjusted column generators ¯ G are fed into the data generation component. The technical details are available in Section 3. Data Generation: Given the inputs including instantiated queries ¯ Q and constraints over the equi-join operators C = specified in W , Touchstone decomposes the query trees annotated with constraints into constraint chains, in order to decouple the dependencies among columns, especially for primary-foreign-key pairs. Data generation component generally deploys the data generators over a distributed platform. The random column generators and constraint chains are distributed to all data generators for independent and parallel tuple generation. The technical details are available in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Random Column Generator</head><p>The basic elements of Touchstone system are a group of random column generators G = {G 1 , G 2 , . . . , G n }, which determine the data distributions of all non-key columns to be generated. A random column generator G i in G <ref type="figure">Figure 2</ref>: The overall architecture of Touchstone is capable of generating values for the specified column, while meeting the required data characteristics in expectation. In the following, we give the detailed description of the random column generator.</p><p>A random column generator G i contains two parts, a random index generator and a value transformer as shown in <ref type="figure" target="#fig_1">Figure 3</ref>. In the random index generator, the output index domain is the integers from 0 to n − 1 while n is the specified cardinality of unique values in corresponding column. Given an index, the transformer deterministically maps it to a value in the specified domain of the column. We adopt different transformers based on the type of the column. For numeric types, e.g., Integer, we simply pick up a linear function which uniformly maps the index to the value domain. For string types, e.g., Varchar, there are some seed strings pregenerated randomly, which satisfy the specified length requirements. We first select a seed string based on the input index as shown in <ref type="figure" target="#fig_1">Figure 3</ref>, and then concatenate the index and the selected seed string as the output value. This approach allows us to easily control the cardinality of string typed columns with tiny memory consumption.</p><p>To manipulate the distribution of the column values, there is a probability table in the random index generator. The probability table consists of a number of entries and each entry corresponds to an index. Specifically, each entry in the table (k i , p i , c i ) specifies an index k i , the probability p i of occurrence, and the cumulative probability c i for all indexes no larger than k i . In order to save the memory space, we compress the table by keeping only the entries with non-uniform probabilities. If an index does not appear in the probability table, its probability is automatically set by the uniform probability. The entries in the table are ordered by k i . In <ref type="figure" target="#fig_1">Figure 3</ref>, we present an example of random column generator designed for column T.t 3 from example inputs in <ref type="figure">Figure 1</ref>. The specified data characteristics request this column to contain 8 unique strings with average length 20 and maximum length 100. In the result generator, based on the indexes in <ref type="bibr">[0,</ref><ref type="bibr" target="#b6">7]</ref> generated by random index generator, the transformer outputs random strings with the desired lengths, at probabilities {p 0,2,3,5,7 = 0.1,</p><formula xml:id="formula_2">p 1 = 0.2, p 4,6 = 0.15}.</formula><p>The details of probability assignment will be discussed in Section 3. Value Generation: Given the random column generator, firstly, a Null value is output with the probability of the specified percentage. If Null value is not chosen, the index generator picks up an index based on the probabilities by running binary search over CDF (c i ) in the probability table with a random real number in <ref type="bibr">(0,</ref><ref type="bibr" target="#b0">1]</ref>, and the transformer outputs the corresponding column value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Query Instantiation</head><p>There are two general objectives in query instantiation, targeting to 1) construct the random column generators for each non-key column in the tables; and 2) find concrete values for the variable parameters in the queries.</p><p>Generally speaking, the query instantiation component is responsible for handling three types of constraints, i.e., C σ = , C σ = and C = . Note that the fourth type of constraints C = involves matching between primary and foreign keys, which is taken care of by the data generation process at runtime. In Algorithm 1, we list the general workflow of query instantiation. The algorithm iteratively adjusts the data distribution adopted by the random column generators and the concrete values of the variable parameters, in order to meet the constraints as much as possible. The distribution adjustment on the column generator is accomplished by inserting entries in its probability table. In each iteration, the algorithm reinitializes the column generators (line 3) such that there is no entry in the probability table, namely the probabilities of candidate values are uniform. The algorithm then attempts to adjust the column generators in ¯ G and the concrete values of the variable parameters in queries ¯ Q (lines 4-11). Specifically, it firstly adjusts the column generators and instantiates the variable parameters based on the equality constraints over filters (lines 4-6). It then follows to revise the variable parameters in the queries in order to meet the non-equality constraints on filter and join operators (lines 7-11). The details of the adjustment on column generators and the parameter instantiation are presented in the following subsections. The algorithm outputs the new (adjusted) generators ¯ G and the instantiated queries ¯ Q, when the global relative error for all constraints is within the specified threshold θ or the number of iterations reaches its maximum I.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Query instantiation</head><p>Input: Initial generators G, input queries Q, error threshold θ and maximum number of iterations I Output: New generators ¯ G and instantiated queries ¯</p><formula xml:id="formula_3">Q 1: Initialize ¯ Q ← Q 2: for all iteration i = 1 to I do 3: Initialize ¯ G ← G 4: for all constraint c ∈ C σ = do 5:</formula><p>Adjust the generator in ¯ G for the column within c 6:</p><p>Instantiate the corresponding parameter in ¯ Q</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7:</head><p>for all c ∈ C σ = do 8:</p><p>Instantiate the corresponding parameter in ¯ Q</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>9:</head><p>for all c ∈ C = do 10:</p><p>Obtain constraints from all descendant nodes 11:</p><p>Instantiate the corresponding parameter in ¯ Q</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>12:</head><p>Calculate the global relative error e</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>13:</head><p>if e ≤ θ then return ¯ G and ¯ Q 14: return ¯ G and ¯ Q (historical best solution with minimum e)</p><p>In the rest of the section, we discuss the processing strategies for these three types of constraints respectively.</p><p>Filters with Equality Constraint always involve a single non-key column at a time like the workloads of standard benchmarks. Given all these equality constraints on the filter operators, i.e., C σ = , the system groups the constraints according to the involved column. In our running example in <ref type="figure">Figure 1</ref>, there are four such constraints C σ = = {c 2 , c 5 , c 8 , c 10 }, among which, c 2 and c 8 target column S.s 3 , and c 5 and c 10 target column T.t 3 . Note that all relational operators in equality constraints are handled by treating them as '='. For example,</p><formula xml:id="formula_4">c 5 = [Q 2 , T.t 3 NOT LIKE P 4 , 32] ⇒ [Q 2 , T.t 3 LIKE P 4 , 8] ⇒ [Q 2 , T.t 3 = P 4 , 8].</formula><p>The processing strategy for equality constraints on filters runs in three steps. Firstly, the algorithm randomly selects an index and obtains the corresponding value from the transformer of the column generator, for instantiating each variable parameter in the equality con- <ref type="figure">Figure 4</ref>: An example of parameter searching procedure for constraint c 7 . Given the predicate in c 7 , our algorithm attempts to cut the space by revising the parameter P 5 . For a concrete P 5 , the expected number of tuples meeting the predicate is evaluated by the random sampling algorithm. The best value for P 5 is returned, after the binary search identifies the optimal value at desired precision or reaches the maximum iterations.</p><p>straints. Secondly, the algorithm updates the occurrence probability of the selected index in the column generator by inserting an entry in the probability table, in order to meet the required intermediate result cardinality. Whether the filter is the leaf node of the query execution tree or not, the probability of the inserted entry is calculated as s out s in , where s in is the size of input tuples and s out is the expected size of output tuples. After the above two steps for all equality constraints, the algorithm calculates the cumulative probabilities in the probability table of adjusted column generators. In <ref type="figure" target="#fig_1">Figure 3</ref>, there are three entries in the probability table for generating data with the distribution that satisfies the constraints c 5 and c 10 . For example, the entry with index 1 is inserted for instantiating parameter P 4 in the predicate of c 5 , while the two entries with indexes 4 and 6 are inserted for instantiating parameters P 7 and P 8 in the predicate of c 10 .</p><p>Suppose there are k variable parameters in the equality constraints over filters. The total complexity of the processing strategy is O(k log k), because the algorithm only needs to instantiate the parameters one by one, and accordingly it inserts an entry into the probability table in order of selected index for each parameter instantiation. Filters with Non-Equality Constraint could involve multiple non-key columns. In <ref type="figure">Figure 1</ref>, some constraints, e.g.,</p><formula xml:id="formula_5">c 1 = [Q 1 , R.r 2 &lt; P 1 , 4] and c 4 = [Q 2 , S.s 3 ≥ P 3 , 7]</formula><p>, apply on one column only, while other constraints, e.g., c 7 = [Q 3 , R.r 2 − R.r 3 &gt; P 5 , 6] and c 12 = [Q 4 , 2 × R.r 2 + R.r 3 &lt; P 9 , 7], involve more than one column with more complex mathematical operators. Our underlying strategy handling these non-equality constraints is to find the concrete parameters generating the best matching output cardinalities against the constraints, based on the data distributions adopted by the random column generators.</p><p>Since the cardinality of tuples satisfying the constraints is monotonic with the growth of the variable parameter, it suffices to run a binary search over the parameter domain to find the optimal concrete value for the variable parameter. In <ref type="figure">Figure 4</ref>, we present an example to illustrate the parameter searching procedure. The cutting line in the figure represents the parameter in the constraint, which decides the ratio of tuples in the shadow area, i.e., satisfying the constraint. By increasing or decreasing the parameter, the likelihood of tuples in the shadow area changes correspondingly. The technical challenge behind the search is the hardness of likelihood evaluation over the satisfying tuples, or equivalently the probability of tuples falling in the shadow area in our example. To tackle the problem, we adopt the random sampling algorithm, which is also suited for the non-uniform distribution of the involved columns. Note that the binary search may not be able to find a parameter with the desired precision, based on the determined data distribution of columns after processing equality constraints over filters. Therefore, in Algorithm 1, we try to instantiate the parameters for non-equality constraints upon different data distributions by iteration.</p><p>The complexity of the approach is the product of two components, the number of iterations in parameter value search and the computational cost of probability evaluation using random sampling algorithm in each iteration. The number of iterations for the binary search is logarithmic to the domain size of the parameter, decided by the minimal and maximal value that the expression with multiple columns could reach. The cost of random sampling depends on the complexity of the predicate, which usually only involves a few columns. Joins with Non-Equality Constraint are slightly different from the filters with non-equality constraints, because the columns involved in their predicates may overlap with the columns in the predicates of their child nodes as query Q 4 in <ref type="figure">Figure 1</ref>, which usually does not happen to filters in the query execution tree. Therefore, we must process the constraints in a bottom-up manner without the premise of probability independence, such that the precedent operators are settled before the join operator with non-equality constraint is handled. In <ref type="figure" target="#fig_2">Figure 5</ref>, we present the processing flow on query Q 4 . After Touchstone concretizes the parameters P 9 and P 10 in constraints c 12 and c 13 , the input data to the join operator with constraint c 14 is determined. Based on the characteristics of the inputs, we apply the same binary search strategy designed for filter operator to construct the optimal parameter, e.g., P 11 in <ref type="figure" target="#fig_2">Figure 5</ref>, for the desired result cardinality. Since the algorithm is identical to that for filter operator, we hereby skip detailed algorithm descriptions as well as the complexity analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Data Generation</head><p>Given the generators of all non-key columns and the instantiated queries, the data generation component is responsible for assembling tuples based on the outputs of the column generators. The key technical challenge here is to meet the equality constraints over the join operators, i.e., C = , which involve the dependencies among primary and foreign keys from multiple tables. To tackle the problem, we design a new tuple generation schema, which focuses on the manipulation of foreign keys only.</p><p>The tuple generation consists of two steps. In the first compilation step, Touchstone orders the tables as a generation sequence and decomposes the query trees into constraint chains for each target table. In the second assembling step, the working threads in Touchstone independently generate tuples for the tables based on the result order from compilation step. For each tuple, the working thread fills values in the columns by calling the random column generators independently and incrementally assigns a primary key, while leaving the foreign keys blank. By iterating the constraint chains associated with the table, the algorithm identifies the appropriate candidate keys for each foreign key based on the maintained join information of the referenced primary key, and randomly assigns one of the candidate keys to the tuple. Compilation Step: The generation order of the tables is supposed to be consistent with the dependencies between primary keys and foreign keys, because the primary key must be generated before the adoption of its join information for generating corresponding foreign keys of other tables. Since such primary-foreign-key dependencies form a directed acyclic graph (DAG), Touchstone easily constructs a topological order over the tables. In <ref type="figure">Figure 6</ref>, we illustrate the result order over three tables, R → S → T , based on the database schema H in <ref type="figure">Figure 1</ref>.</p><p>In order to decouple the dependencies among columns and facilitate parallelizing, Touchstone decomposes the query trees annotated with constraints into constraint chains. A constraint chain consists of a number of constraints corresponding to the cardinality constraints over the operators in query trees. There are three types of constraints included in the constraint chains, namely FIL-TER, PK and FK, which are associated with the types of related operators. The constraint chains with respect to a table are defined as the sequences of constraints with descendant relationship in the query trees. In <ref type="figure">Figure 6</ref>, we present all the constraint chains for tables R, S and T . For example, table R has two constraint chains extracted from queries Q 1 and Q 3 . And the constraint chains of table S are marked in <ref type="figure">Figure 1</ref> for easily understanding.</p><p>Each FILTER constraint keeps the predicate with the instantiated parameters. Each PK constraint in the chain records the column name of the primary key. Each FK constraint maintains a triplet, covering two column <ref type="figure">Figure 6</ref>: Results of constraint chain decomposition names of the foreign key and the referenced primary key, and the expected ratio of tuples satisfying the predicate on the join operator. The second constraint in the first chain for table S in <ref type="figure">Figure 6</ref>, for example, is FK[S.s 2 , R.r 1 , 2 3 ], indicating the foreign key is S.s 2 , the referenced primary key is R.r 1 and two out of three tuples in table S are expected to meet the predicate S.s 2 = R.r 1 of join operator in the case of satisfying the predicate S.s 3 = P 2 of previous filter. The expected ratios in FK constraints are calculated based on the cardinality requirements of the specified cardinality constraints. Assembling Step: For simplicity, we assume that there is a single-column primary key and one foreign key in the table. Note that our algorithm can be naturally extended to handle tables with composite primary key and multiple foreign keys. The result constraint chains are distributed to all working threads on multiple nodes for parallel tuple generation. When generating tuples for a specified table, each working thread maintains two bitmap data structures at runtime, i.e., φ f k and φ pk . They are used to keep track of the status of joinability, e.g., whether the generating tuple satisfies individual predicates over join operators, for primary key and foreign key, respectively. The length of the bitmap φ f k (resp. φ pk ) is equivalent to the number of FK (resp. PK) constraints in all chains of the target table. Each bit in the bitmap corresponds to a FK/PK constraint. It has three possible values, T , F and N, indicating if the join status is successful, unsuccessful or null. In <ref type="figure">Figure 6</ref>, for example, table S has two FK constraints and two PK constraints, resulting in 2-bit representations for both φ f k and φ pk .</p><p>Touchstone also maintains the join information table to track the status of joinability of primary keys based on the bitmap representation φ pk . In <ref type="figure" target="#fig_4">Figure 7</ref>, we show two join information tables of primary keys R.r 1 and S.s 1 respectively. The join information table of R.r 1 is maintained in the generation of table R, which is ready for generating the foreign key S.s 2 of table S. During the generation of table S, the join information table of S.s 1 is maintained for generating the foreign key T.t 2 of table T . There are two attributes in the entry of join information table, i.e., bitmap and keys, indicating the status of joinability and the corresponding satisfying primary key values. Note that the keys in the entry may be empty (such entries will not be stored in practice), which means there is no primary key with the desired joinability status.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 Tuple generation</head><p>Input: Column generators ¯ G, constraint chains of the target table Ω, join information tables of referenced primary key and current primary key t rpk and t pk Output: Tuple r and join information table t pk 1: r.pk ← a value assigned incrementally 2: r.columns ← values output by column generators ¯ G 3: φ f k ← N...N, φ pk ← N...N 4: for all constraint chain ω ∈ Ω do </p><formula xml:id="formula_6">φ f k [i] ← f lag // i</formula><p>is the bit index for c 14: r. f k ← a value selected from t rpk satisfying φ f k 15: Add r.pk in the entry of t pk with bitmap φ pk 16: return r and t pk</p><p>The tuple generation algorithm is listed in Algorithm 2. We present a running example of tuple generation in <ref type="figure" target="#fig_4">Figure 7</ref>. A new tuple for table S is initialized as (S.s 1 = 7, S.s 2 =?, S.s 3 = 16), φ f k = NN and φ pk = NN (lines 1-3). The f lag is set to True before traversing each constraint chain (line 5), which is used to track if the predicates from the precedent constraints of current chain are fully met. On the first constraint chain, since the predicate in the first FILTER constraint is S.s 3 = 4, f lag is then set to False (line 8), and algorithm does not need to handle the next FK constraint (line 11). On the second chain, the tuple satisfies the predicate S.s 3 ≥ 15, resulting in the update of bitmap representation as φ pk = NT (line 10). On the third chain, after passing the first FILTER constraint, the corresponding bit of next FK constraint in φ f k is randomly flipped to F at the probability of 2 5 (lines 12-13), because the expected ratio of satisfying tuples is <ref type="bibr" target="#b2">3</ref> 5 . The f lag is set to False (line 12) to reflect the failure of full matching of precedent constraints for later PK constraint. Then, the bit corresponding to next PK constraint in φ pk is set as F according to the value of f lag (line 10). Therefore, the two bitmaps are finalized as φ f k = FN and φ pk = FT . Then the algorithm identifies (line 14) two entries matching φ f k = FN, namely satisfying the T /F requirements on the corresponding bits of φ f k , with bitmaps FT and FF respectively, in the join information table of R.r 1 . Given these two entries, it randomly selects (line 14) a foreign key, e.g., 6, from four candidate referenced primary keys {2, 7, 6, 8}, which are all appropriate as the foreign key S.s 2 . That there is no entry in t rpk satisfying the T /F requirements of φ f k , which is called mismatch case, is dealt in the rest of the section. Finally, the algorithm updates (line 15) the join information table of S.s 1 by adding the primary key S.s 1 = 7 into the entry with bitmap FT .</p><p>For a table, suppose there are k non-key columns, m constraints in the related constraint chains and n entries in the join information table of referenced primary key. The complexity of tuple generation mainly consists of three parts, k times of calling random column generators for filling the values of non-key columns, the traversing over m constraints within chains for determining the joinability statuses of foreign key and primary key, and the comparing with n bitmaps in the join information table for searching the appropriate foreign key candidates. For practical workloads, k, m and n are all small numbers, e.g., k ≤ 12, m ≤ 20 and n ≤ 40 for TPC-H <ref type="bibr" target="#b2">[3]</ref> workload, so our tuple generation is highly efficient. Handling Mismatch Cases: For the data generation of big tables, if a joinability status of the primary key may occur, its occurrence can be considered as inevitable based on the probability theory. However, there are still some joinability statuses of the primary key that never occur. For example, in <ref type="figure" target="#fig_4">Figure 7</ref>, the bitmap φ pk for primary key S.s 1 can not be T F due to the constraints, i.e., Filter[S.s 3 = 16] and Filter[S.s <ref type="bibr">3 ≥ 15]</ref>. Therefore, in the tuple generation, it should be avoided to generate the bitmap φ f k that does not have any matching entry in the join information table of the referenced primary key. In order to achieve this objective, the main idea is to add rules to manipulate relevant FK constraints. <ref type="figure" target="#fig_5">Figure 8</ref> gives an example of adjustments to FK constraints for handling the mismatch case. There are three FK constraints with the serial numbers of 1, 2 and 3 in the three constraint chains, respectively. Since there are four bitmaps, i.e., FTT, TTT, TFT, FTF, that are not presented in the join information table of the referenced primary key rpk corresponding to the foreign key f k of the target table, three rules are added in two FK constraints to avoid  <ref type="bibr" target="#b1">[2]</ref>.</p><p>To reflect the adjustments to FK constraints in the tuple generation, minor modification is applied on the original tuple generation algorithm on lines 12-13 in Algorithm 2. Specifically, the updated algorithm first checks all existing rules in current FK constraint. If there is a rule which can be applied to the statuses of previous constraints, φ f k and f lag are updated according to the rule. Otherwise, the algorithm updates φ f k and f lag by the probability based on the adjusted ratio. Management of Join Information: For generation of a table, it can be completely parallel on multiple nodes with multiple working threads on each node. Each working thread maintains its own join information table of the primary key to avoid contention. But the join information table of referenced primary key can be shared among multiple working threads on each node. After the generation of the table, we merge the join information tables maintained by the multiple working threads in distributed controller as in <ref type="figure">Figure 2</ref>. But there are serious memory and network problems for the space complexity of the join information table is O(s) with s as the table size.</p><p>Since the relationship of foreign key and primary key can be many to one and the intermediate result cardinality is the main factor that affects the query performance, we design a compression method by storing less primary key values in the join information table but still promise the randomness of remaining values. Assuming the size of keys in an entry of join information table is N, which is hard to know in advance and may be very large. We aim to store only L (L &lt;&lt; N) values in the keys and promise the approximately uniform distribution of these L ones among all N values. The compression method is implemented as follows: we store the first L arriving values in the keys, if any; and for the i-th (i &gt; L) arriving value, we randomly replace a value stored previously in the keys with the probability of L/i. By such a method, the space complexity of the join information table is reduced to O(n * L), where n is the number of entries in the join information table and L is the maximum allowed size of keys in each entry. Since n is generally small, e.g., n ≤ 40 for TPC-H workload, and L usually can be set to thousands, the memory consumption and network transmission of the join information table are acceptable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head><p>Environment. Our experiments are conducted on a cluster with 8 nodes. Each node is equipped with 2 Intel Xeon E5-2620 @ 2.0 GHz CPUs, 64GB memory and 3 TB HDD disk configured in RAID-5. The cluster is connected using 1 Gigabit Ethernet. Workloads. The TPC-H <ref type="bibr" target="#b2">[3]</ref> is a decision support benchmark which contains the most representative queries of analytical applications, while the transactional benchmarks, e.g., TPC-C and TPC-W, do not contain queries for analytical processing. So we take the TPC-H workload for our experiments. We compare Touchstone with the state-of-the-art work MyBenchmark <ref type="bibr" target="#b14">[15]</ref> with source codes from the authors. <ref type="bibr" target="#b1">2</ref> The workloads for comparison consist of 6 queries from TPC-H, including Q 2,3,6,10,14,16 . Note that these queries are selected based on the performance of MyBenchmark, which drops significantly when other queries are included in the workloads. Touchstone, on the other hand, can easily handle all of the first 16 queries, i.e., Q 1 to Q 16 , in TPC-H with excellent performance. To the best of our knowledge, Touchstone provides the widest support to TPC-H workload, among all the existing studies <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b14">15]</ref>. Input Generation. To build valid inputs for experiments, we generate the DBI and queries of TPC-H using its tools dbgen and qgen, respectively. And the DBI of TPC-H is imported into the MySQL database. The database schema of TPC-H is used as the input H. We can easily obtain the input data characteristics D for all columns from the DBI in MySQL. Given the TPC-H queries, their physical query plans are obtained from MySQL query parser and optimizer over the DBI. The cardinality constraints corresponding to the operators in query plans are then identified by running the queries on the DBI in MySQL. The input workload characteristics W are constructed by the parameterized TPC-H queries and above cardinality constraints. Note that we can generate databases with different scale factors using the same input W by employing selectivities instead of the absolute cardinalities in our input constraints. Settings. As data is randomly generated according to the column generators in Touchstone, the distribution of generated data may be difficult to satisfy the expectation for small tables such as Region and Nation. We therefore revise the sizes of Region and Nation from 5 to 500, and from 25 to 2500 respectively. The cardinality constraints involving these two tables are updated proportionally. In addition, the small tables can also be pre-generated manually. The error threshold (desired precision) and maximal iterations in query instantiation are set to 10 −4 and 20 respectively. The default maximum allowed size L of keys in join information table is set to 10 4 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Comparison with MyBenchmark</head><p>We compare Touchstone with MyBenchmark from four aspects, including data generation throughput, scalability to multiple nodes, memory consumption and capability of complex workloads. <ref type="figure">Figure 9</ref> shows the data generation throughputs per node of Touchstone and MyBenchmark as we vary the number of nodes under different scale factors. Due to the unacceptably long processing time of MyBenchmark, we adopt smaller scale factors for it and large scale factors for Touchstone. Overall, the data generation throughput of Touchstone is at least 3 orders of magnitude higher than that of MyBenchmark. This is because MyBenchmark does not have a good parallelization or an efficient data generation schema. Furthermore, as the number of nodes increases from 1 to 5, the data generation throughput per node of MyBenchmark decreases dramatically for all three scale factors. Although the decline of data generation throughput per node of Touchstone is obvious too when SF = 1, Touchstone is linearly scalable (the throughput per node is stable) when SF = 100. This is because for small target database, e.g., SF = 1, the distributed maintenance rather than data generation dominates the computational cost in Touchstone, while its overhead comparatively diminishes by increasing the target database size. <ref type="figure" target="#fig_6">Figure 10</ref> reports the peak memory consumptions of Touchstone and MyBenchmark under different data scales. The experiment is conducted on 5 nodes with no restriction on memory usage. The memory usage of MyBenchmark mainly consists of two parts, namely, memory consumed by MyBenchmark Tool and memory consumed by PostgreSQL for managing intermediate states.</p><p>The memory usage of Touchstone mainly includes memory for JVM itself and memory for maintaining join information. As shown in <ref type="figure" target="#fig_6">Figure 10</ref>, the memory consumption of Touchstone is much lower than that of MyBenchmark under the same scale factors. It is worth noting that the memory consumption of Touchstone remains almost constant when SF &gt; 10. This is because for Touchstone, the JVM itself occupies most of the memory, while the join information maintenance only spends a tiny piece of memory. <ref type="figure">Figure 11</ref> and <ref type="figure">Figure 12</ref> present the data generation time (total running time) and global relative error separately of Touchstone and MyBenchmark as we vary the number of input queries with SF = 1. The input queries are loaded in order of their serial numbers. The experiment is carried out on 5 nodes. In <ref type="figure">Figure 11</ref>, it is obvious that the data generation time of MyBenchmark increases significantly as the number of queries increases. At the same time, the generation time of Touchstone grows very little when more queries are included, significantly outperforming MyBenchmark. In <ref type="figure">Figure 12</ref>, the error of Touchstone is much smaller than that of MyBenchmark. Moreover, as there are more input queries, the global relative error of Touchstone remains small with little change, while the error of MyBenchmark has an obvious rise. In summary, Touchstone is more capable of supporting complex workloads than MyBenchmark.</p><p>It can be seen from previous experiments that MyBenchmark can not be easily applied to generate the terabyte scale database for complex workloads due to its poor performance. In the following, we further demonstrate the advantages of Touchstone by a series of experiments using the workload of 16 queries, i.e., Q 1 to Q 16 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Performance Evaluation</head><p>In this section, we evaluate the impact of workload complexity on query instantiation time and total running time in Touchstone, as well as the scalability to data scale and multiple nodes of Touchstone. <ref type="figure" target="#fig_1">Figure 13</ref> shows the query instantiation time of Touchstone as we vary the number of queries with SF = 1 and SF = 100, respectively. The input queries are loaded in order of their serial numbers. The query instantiator is deployed on a single node. As shown in <ref type="figure" target="#fig_1">Figure 13</ref>, even when all 16 queries are used for input, query instantiation is finished within 0.2s. And there is a minimal difference in query instantiation time for SF = 1 and SF = 100, as the complexity of query instantiation is independent of data scale. Overall, the query instantiation time is only correlated to the complexity of input workloads. <ref type="figure">Figure 14</ref> shows the total running time of Touchstone as we vary the number of queries with SF = 500. Touchstone is deployed on 8 nodes. From the result, it can be seen that the running time increases slowly as the number of queries increases. For Q 7 and Q 8 , there are relatively more cardinality constraints over equi-join operators, so the time increment is larger when we change from 6 queries to 8 queries. But when the number of queries changed from 10 to 16, the time increment is almost indiscernible, for Q 11 to Q 16 are simple, among which Q 12 to Q 15 have no cardinality constraints on equi-join operators 3 . Overall, the total running time increased by only 16% from 2 queries to 16 queries for 500GB data generation task, so Touchstone is insensitive to the workload complexity. <ref type="figure" target="#fig_2">Figure 15</ref> presents the total running time of Touchstone under different scale factors with the input of 16 queries. Touchstone is deployed on 8 nodes. As shown in <ref type="figure" target="#fig_2">Figure 15</ref>, Touchstone is linearly scalable to data size. Because the generation of each tuple is independent and the generated tuples need not be stored in memory, the data generation throughput is stable for different data scales. Moreover, the total runtime of Touchstone is less than 25 minutes for SF = 1000 (1TB), so it is capable of supporting industrial scale database generation. <ref type="figure" target="#fig_7">Figure 16</ref> presents the data generation throughputs per node of Touchstone as we vary the number of nodes with SF = 500. The input workload includes 16 queries. The result shows that the data generation throughput per node <ref type="bibr" target="#b2">3</ref> Depending on the physical query plans of Q 12 to Q 15 , the primary keys in their equi-join operators are from the original tables, so all foreign keys must be joined and the sizes of output tuples are determined.</p><p>is approximatively unchanged as the number of nodes increases, validating the linear scalability of Touchstone. To the best of our knowledge, Touchstone is the first query-aware data generator which can support full parallel data generation on multiple nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Data Fidelity Evaluation</head><p>The data fidelity of synthetic database is evaluated by relative error on cardinality constraints and performance deviation on query latencies. We calculate the relative error for each query in the similar way with global relative error, which only involves its own cardinality constraints. We compare the latency of query processing on base database generated by dbgen against that on synthetic database generated by Touchstone to show the performance deviation. <ref type="figure" target="#fig_4">Figure 17</ref> shows the relative errors for Q 1 to Q 16 with different scale factors from 1 to 5. The maximum error among all 16 queries is less than 4%, and there are 14 queries with errors less than 1%. <ref type="figure" target="#fig_5">Figure 18</ref> shows the global relative error of all 16 queries as we vary the scale factor, which is less than 0.2% for all scale factors. And with the increase of scale factor, the global relative error has a sharp decrease. Since data is randomly generated by column generators, as expected by the probability theory, the larger the data size, the smaller the relative error. <ref type="figure">Figure 19</ref> presents the performance deviations of all 16 queries with SF = 1. We vary the maximum allowed size L of keys in the join information table from 10 3 to 10 5 . We can see that the performance deviation is inconspicuous for all 16 queries, and the size of L has no significant influence on query latencies. The result strongly illustrates the correctness and usefulness of our work. We are the first work to give such an experiment to verify the fidelity of the generated DBI. More experimental results are available in our online technical report <ref type="bibr" target="#b1">[2]</ref>, which demonstrate the effectiveness for data generation of non-equi-join workloads, handling mismatch cases, the compression method on join information table, and other benchmark workloads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>There are many data generators <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b8">9]</ref> which only consider the data characteristics of the target database. For example, Alexander et al. <ref type="bibr" target="#b3">[4]</ref> proposes pseudo-random number generators to realize the parallel  <ref type="figure">Figure 19</ref>: Performance deviation for each query data generation. Torlak <ref type="bibr" target="#b22">[23]</ref> supports the scalable generation of test data from a rich class of multidimensional models. However, all these data generators can not generate test databases with the specified workload characteristics on target queries.</p><p>There are query-aware data generators <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b14">15]</ref>, among which <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15]</ref> are a series of work. QAGen <ref type="bibr" target="#b5">[6]</ref> is the first query-aware data generator, but for each query it generates an individual DBI and its CSP (constraint satisfaction program) has the usability limitations as declared in experimental results. WAGen <ref type="bibr" target="#b13">[14]</ref> makes a great improvement that it generates m (≤ n) DBIs with n input queries, but WAGen can't guarantee that only one DBI is generated and still has CSP performance problem. Though MyBenchmark <ref type="bibr" target="#b14">[15]</ref> has done a lot of performance optimization, generating one DBI can not be promised for multiple queries and the performance is still unacceptable for the generation of terabyte scale database. DCGen <ref type="bibr" target="#b4">[5]</ref> uses a novel method to represent data distribution with ideas from the probabilistic graphical model. But DCGen is weak in support of foreign key constraint, and it cannot easily support parallel data generation in a distributed environment.</p><p>There are some interesting non-relational data generators <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b9">10]</ref>. For example, Olston et al. <ref type="bibr" target="#b17">[18]</ref> introduces how to generate example data for dataflow programs. Sara <ref type="bibr" target="#b7">[8]</ref> generates structural XML documents. <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b18">19]</ref> are synthetic graph generators. Chronos <ref type="bibr" target="#b9">[10]</ref> can generate stream data for real time applications. In addition, there are query generation works <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b15">16]</ref> which are partly similar to us, but they generate queries satisfying the specified cardinality constraints over an existing DBI. Moreover, the dataset scaling works <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b24">25]</ref> can serve part of our targets, which scale up/down a given DBI with similar column correlations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Discussion and Conclusion</head><p>Limitations. Touchstone aims to support the most common workloads in real world applications. Below we list the scenarios that we cannot support currently. <ref type="formula">(1)</ref> Touchstone does not support filters on key columns. Primary and foreign keys are identifiers of tuples and generally have no physical meaning, so the filters which are representations of business logics usually do not involve key columns. (2) Equality constraints over filters involving multiple columns are not supported in Touchstone. The equality predicate with multiple columns for filter is a very strict constraint, and has not been found in workloads of standard benchmarks. (3) Equi-joins on columns with no reference constraint are not supported in our work. This is because the equi-join is usually applied on the pair of primary and foreign keys in practical workloads, which is also the assumption of many works <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b24">25]</ref>. <ref type="formula">(4)</ref> Touchstone does not support the database schema with cyclic reference relationship. In our data generation process, generating foreign keys requires the join information tables of corresponding referenced primary keys, so the primary-foreign-key dependencies must form a direct acyclic graph (DAG), which is also the precondition of DCGen <ref type="bibr" target="#b4">[5]</ref>.</p><p>Privacy issue. Our work can help to protect privacy to some extend by removing query parameter values or using approximate query intermediate cardinalities. However, if the database statistics and workload characteristics are strictly related to privacy issues in some cases, it will not be a good way to use this kind of workloadaware data generators for performance testing.</p><p>In this paper we introduce Touchstone <ref type="bibr" target="#b1">[2]</ref>, a queryaware data generator with characteristics of completely parallelizable and bounded usage to memory. And Touchstone is linearly scalable to computing resource and data scale. Our future work is to support more operators, e.g., intersect and having, for covering the complex queries of TPC-DS, which has not be well supported by any existing query-aware data generation work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>∑</head><label></label><figDesc>Figure 1: Example inputs of database schema, data characteristics and workload characteristics to Touchstone</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: An example generator for column T.t 3 The probability table consists of a number of entries and each entry corresponds to an index. Specifically, each entry in the table (k i , p i , c i ) specifies an index k i , the probability p i of occurrence, and the cumulative probability c i for all indexes no larger than k i . In order to save the memory space, we compress the table by keeping only the entries with non-uniform probabilities. If an index does not appear in the probability table, its probability is automatically set by the uniform probability. The entries in the table are ordered by k i . In Figure 3, we present an example of random column generator designed for column T.t 3 from example inputs in Figure 1. The specified data characteristics request this column to contain 8 unique strings with average length 20 and maximum length 100. In the result generator, based on the indexes in [0, 7] generated by random index generator, the transformer outputs random strings with the desired lengths, at probabilities {p 0,2,3,5,7 = 0.1, p 1 = 0.2, p 4,6 = 0.15}. The details of probability assignment will be discussed in Section 3. Value Generation: Given the random column generator, firstly, a Null value is output with the probability of the specified percentage. If Null value is not chosen, the index generator picks up an index based on the probabilities by running binary search over CDF (c i ) in the probability table with a random real number in (0, 1], and the transformer outputs the corresponding column value.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: An example of parameter instantiation for nonequality constraints on join operator</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>for all constraint c ∈ ω do 7: if (c is FILTER) &amp;&amp; (c.predicate is False) then 8: f lag ← False 9: else if c is PK then 10: φ pk [i] ← f lag // i is the bit index for c 11: else if (c is FK) &amp;&amp; f lag then 12: if random[0, 1) ≥ c.ratio then f lag ← False 13:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Running example of tuple generation for table S</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: An example of adjustments to FK constraints producing any φ f k triggering the mismatch case. For example, there is a rule [FT ← T ] added in the second FK constraint, which indicates that the status of the second FK constraint must be F if the status of the first FK constraint is T in the tuple generation. Since there are extra F statuses forcibly generated by the added rule for the second FK constraint, the actual ratio of tuples satisfying the corresponding predicate could be lower than the expected ratio 0.6. Consequently, it is necessary to adjust the ratio in the second FK constraint for eliminating the impact of the added rule. In this example, we adjust the ratio as 0.65 = 0.6×0.4 0.4−0.1×0.3 , in which 0.4 is the ratio of tuples satisfying the predicate in the second FILTER constraint, 0.6 × 0.4 is the cumulative probability of the status T for the second FK constraint, 0.1 is the ratio of tuples satisfying the two predicates in the first two FIL-TER constraints, 0.3 is the ratio in the first FK constraint and 0.1 × 0.3 is the cumulative probability of the extra F status generated by the rule. The general algorithm of adjustments to FK constraints and the corresponding analyses are presented in our online technical report [2]. To reflect the adjustments to FK constraints in the tuple generation, minor modification is applied on the original tuple generation algorithm on lines 12-13 in Algorithm 2. Specifically, the updated algorithm first checks all existing rules in current FK constraint. If there is a rule which can be applied to the statuses of previous constraints, φ f k and f lag are updated according to the rule. Otherwise, the algorithm updates φ f k and f lag by the probability based on the adjusted ratio. Management of Join Information: For generation of a table, it can be completely parallel on multiple nodes with multiple working threads on each node. Each working thread maintains its own join information table of the primary key to avoid contention. But the join information table of referenced primary key can be shared among multiple working threads on each node. After the generation of the table, we merge the join information tables maintained by the multiple working threads in distributed controller as in Figure 2. But there are serious memory and network problems for the space complexity of the join information table is O(s) with s as the table size. Since the relationship of foreign key and primary key can be many to one and the intermediate result cardinality is the main factor that affects the query performance,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 10 :</head><label>10</label><figDesc>Figure 9: Comparison of data generation throughput</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 16 :</head><label>16</label><figDesc>Figure 13: Query instantiation time</figDesc></figure>

			<note place="foot" n="1"> If the relational operator in a selection predicate belongs to {=, !=, in, not in, like, not like}, then the corresponding cardinality constraint is classified to C σ = .</note>

			<note place="foot" n="2"> We would like to thank Eric Lo for providing us the source code of MyBenchmark.</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<ptr target="http://www.sqledit.com/dg/" />
		<title level="m">DTM data generator</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Technical report, running examples and source code of Touchstone</title>
		<ptr target="https://github.com/daseECNU/Touchstone" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tpc-H</forename><surname>Benchmark</surname></persName>
		</author>
		<ptr target="http://www.tpc.org/tpch/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Myriad: scalable and expressive data generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandrov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tzoumas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markl</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the VLDB Endowment</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1890" to="1893" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Data generation using declarative constraints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arasu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 ACM SIG-MOD International Conference on Management of data</title>
		<meeting>the 2011 ACM SIG-MOD International Conference on Management of data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="685" to="696" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Qagen: generating query-aware test databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Binnig</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kossmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And¨ozsuand¨ And¨ozsu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 ACM SIGMOD international conference on Management of data</title>
		<meeting>the 2007 ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="341" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Flexible database generators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruno</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chaudhuri</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st international conference on Very large data bases</title>
		<meeting>the 31st international conference on Very large data bases</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="1097" to="1107" />
		</imprint>
	</monogr>
	<note>VLDB Endowment</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Generating xml structure using examples and constraints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cohen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="490" to="501" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Quickly generating billion-record synthetic databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gray</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sundaresan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Englert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Baclawski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weinberger</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD Record</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1994" />
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="243" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Chronos: An elastic parallel framework for stream benchmark generation and simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Shan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-C</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Winslett</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 31st International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="101" to="112" />
		</imprint>
	</monogr>
	<note>Data Engineering (ICDE)</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A parallel generalpurpose synthetic data generator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hoag</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thompson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="19" to="24" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Simple and realistic data generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Houkjaer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Torp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wind</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd international conference on Very large data bases</title>
		<meeting>the 32nd international conference on Very large data bases</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="1243" to="1246" />
		</imprint>
	</monogr>
	<note>VLDB Endowment</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Mathematically tractable graph generation and evolution, using kronecker multiplication european conf. on principles and practice of know</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leskovec</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kleinberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And Re-Alistic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">F</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>dis. Databases (ECML/PKDD</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Generating databases for query workloads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">O</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hon</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="848" to="859" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Mybenchmark: generating databases for query workloads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">O</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">W</forename><surname>Hon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Choi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="895" to="913" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Interactive query refinement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mishra</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koudas</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Extending Database Technology: Advances in Database Technology</title>
		<meeting>the 12th International Conference on Extending Database Technology: Advances in Database Technology</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="862" to="873" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Generating targeted queries for database testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mishra</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zuzarte</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 ACM SIGMOD international conference on Management of data</title>
		<meeting>the 2008 ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="499" to="510" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Generating example data for dataflow programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olston</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srivastava</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 ACM SIGMOD International Conference on Management of data</title>
		<meeting>the 2009 ACM SIGMOD International Conference on Management of data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="245" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">S3g2: A scalable structure-correlated social graph generator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pham</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-D</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erling</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Technology Conference on Performance Evaluation and Benchmarking</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="156" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Reversing statistics for scalable test databases generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antova</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth International Workshop on Testing Database Systems</title>
		<meeting>the Sixth International Workshop on Testing Database Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Logic programs and cardinality constraintstheory and practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Syrj¨anensyrj¨</forename><surname>Syrj¨anen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Upsizer: Synthetically scaling an empirical relational database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tay</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">T</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">Y</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Systems</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="1168" to="1183" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Scalable test data generation from multidimensional models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Torlak</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGSOFT 20th International Symposium on the Foundations of Software Engineering</title>
		<meeting>the ACM SIGSOFT 20th International Symposium on the Foundations of Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page">36</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Locality-aware partitioning in parallel database systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zamanian</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Binnig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Salama</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2015 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="17" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tay</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Dscaler</surname></persName>
		</author>
		<title level="m">Synthetically scaling a given relational database. Proceedings of the VLDB Endowment</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1671" to="1682" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
