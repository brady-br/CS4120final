<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:10+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">MIRAGE: Succinct Arguments for Randomized Algorithms with Applications to Universal zk-SNARKs MIRAGE: Succinct Arguments for Randomized Algorithms with Applications to Universal zk-SNARKs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmed</forename><surname>Kosba</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmed</forename><surname>Kosba</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dimitrios</forename><surname>Papadopoulos</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charalampos</forename><surname>Papamanthou</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Alexandria University</orgName>
								<address>
									<addrLine>Dimitrios Papadopoulos</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Charalampos Papamanthou</orgName>
								<orgName type="department" key="dep2">Dawn Song</orgName>
								<orgName type="institution" key="instit1">Hong Kong University of Science and Technology</orgName>
								<orgName type="institution" key="instit2">University of Maryland</orgName>
								<address>
									<settlement>Berkeley</settlement>
									<country>UC</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">Alexandria University</orgName>
								<orgName type="institution" key="instit2">HKUST</orgName>
								<orgName type="institution" key="instit3">University of Maryland</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">MIRAGE: Succinct Arguments for Randomized Algorithms with Applications to Universal zk-SNARKs MIRAGE: Succinct Arguments for Randomized Algorithms with Applications to Universal zk-SNARKs</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. * A major part of this work was done while Ahmed Kosba was a post-doctoral scholar at UC Berkeley. † Part of this work was done while Charalampos Papamanthou was with Oasis Labs.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The last few years have witnessed increasing interest in the deployment of zero-knowledge proof systems, in particular ones with succinct proofs and efficient verification (zk-SNARKs). One of the main challenges facing the wide deployment of zk-SNARKs is the requirement of a trusted key generation phase per different computation to achieve practical proving performance. Existing zero-knowledge proof systems that do not require trusted setup or have a single trusted preprocess-ing phase suffer from increased proof size and/or additional verification overhead. On the other other hand, although universal circuit generators for zk-SNARKs (that can eliminate the need for per-computation preprocessing) have been introduced in the literature, the performance of the prover remains far from practical for real-world applications. In this paper, we first present a new zk-SNARK system that is well-suited for randomized algorithms-in particular it does not encode randomness generation within the arithmetic circuit allowing for more practical prover times. Then, we design a universal circuit that takes as input any arithmetic circuit of a bounded number of operations as well as a possible value assignment, and performs randomized checks to verify consistency. Our universal circuit is linear in the number of operations instead of quasi-linear like other universal circuits. By applying our new zk-SNARK system to our universal circuit, we build MIRAGE, a universal zk-SNARK with very succinct proofs-the proof contains just one additional element compared to the per-circuit preprocessing state-of-the-art zk-SNARK by Groth (Eurocrypt 2016). Finally , we implement MIRAGE and experimentally evaluate its performance for different circuits and in the context of privacy-preserving smart contracts.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Zero-knowledge proofs are a cryptographic primitive that enable an untrusted prover to prove the knowledge of a secret witness that satisfies certain properties to a skeptical verifier. This can be quite useful in many applications including authentication, privacy-preserving computations and others. Although the concept of zero-knowledge proofs was introduced multiple decades ago, it only started to get much attention in practice after recent advances in several aspects <ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref><ref type="bibr" target="#b7">[8]</ref>, which led to efficient implementations for a primitive called zk-SNARKs (zero-knowledge succinct non-interactive arguments of knowledge). zk-SNARKs provide constant-size proofs and verification that is only linear in the size of public statement being proven, regardless of how expensive the computation is. The promising performance properties of zk-SNARKs led to the development of various tools and improved back ends <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref>, and enabled different kinds of applications including privacy-preserving transactions, certificate validation, image authentication and others <ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref>.</p><p>However, using zk-SNARKs with constant-size proofs comes at a cost. For practicality reasons, such constructions typically resort to non-standard cryptographic assumptions and require a trusted key generation phase for each different computation. A compromised trusted setup process could lead to parties providing proofs for false statements while undetected. To avoid such problems in practice, distributed protocols are used for CRS generation <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b19">20]</ref>, which will be expensive to repeat for every type of computation. These drawbacks have led to different lines of work on zero-knowledge proofs attempting to solve some or all of these issues, while providing good performance, e.g., <ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref><ref type="bibr" target="#b22">[23]</ref><ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b24">[25]</ref><ref type="bibr" target="#b25">[26]</ref><ref type="bibr" target="#b26">[27]</ref><ref type="bibr" target="#b27">[28]</ref>. While these works manage to alleviate the drawbacks of zk-SNARKs, they are not as efficient as zk-SNARKs with respect to the verification overhead and proof size. For example, the proof size of these schemes can be tens or hundreds of kilobytes, while a typical zk-SNARK proof is only between 128 and 288 bytes depending on the assumptions <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b6">7]</ref>.</p><p>These issues led to another line of work on universal zk-SNARK systems <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b28">[29]</ref><ref type="bibr" target="#b29">[30]</ref><ref type="bibr" target="#b30">[31]</ref>, which aim to reach a middle ground to avoid the trusted setup per computation challenge, while maintaining the succinctness and efficient verification guarantees provided by efficient zk-SNARK constructions. These systems still require a trusted setup, but such setup is done once for computations of a particular class, e.g., computations that have a certain bound on the number of their operations. In the following section, we provide a brief discussion of the existing universal zk-SNARK systems.</p><p>Universal zk-SNARK systems. There are two flavors of universality in the context of zk-SNARK systems presented in literature. The first is universality with respect to the common reference string (CRS), meaning that a CRS can be adapted without fixing a circuit. The other is the universality of the circuit itself, in which a circuit receives the computation being verified as part of the input itself, and processes its logic. While the first approach sounds more flexible and does not require fixing any circuit, the existing approaches under that category have practical limitations. For example, the technique by Groth et al. <ref type="bibr" target="#b28">[29]</ref> requires a quadratic CRS for supporting universal SNARKs. In a more recent work, Sonic <ref type="bibr" target="#b30">[31]</ref> presented a more practical universal zk-SNARK with updatable CRS, however (in "unhelped" mode) it increases the proof size by a factor of 7×, the verification effort by a factor of 4× and the prover's effort by a factor of 50× (assuming Groth's zk-SNARK <ref type="bibr" target="#b6">[7]</ref> as a baseline). Note that Sonic also provides a helped mode that has less proof computation overhead and a shorter proof, but this mode requires adding an untrusted third party to help with the computations.</p><p>The advantages of the universal circuit approach is maintaining the succinct proof and the small number of pairings in the verification as enabled by zk-SNARKs, however, the most notable universal circuit approach, namely vnTinyRAM <ref type="bibr" target="#b3">[4]</ref> is not efficient enough to support applications in practice. vnTinyRAM's approach was shown to significantly increase the circuit size and prover's effort by multiple orders of magnitude <ref type="bibr" target="#b9">[10]</ref>.</p><p>In this paper, we aim to address such practical limitations by building MIRAGE, a new universal zk-SNARK. In contrast to common belief, we show that the concept of universal circuits can be brought to practicality, through a modified zk-SNARK protocol and careful design of the universal circuit. While there is a cost to be paid for being universal, we managed to apply our system to applications that could benefit from our construction, such as privacy-preserving auctions and crowdfunding for a small number of participants. MIRAGE can be further scaled up using recent systems like DIZK <ref type="bibr" target="#b11">[12]</ref>.</p><p>Technical Highlights. Next, we provide a brief overview of some technical aspects of MIRAGE.</p><p>Separated zk-SNARKs. We first explore how to enable efficient randomized checks in zk-SNARK circuits. Randomized checks can make the verification logic much faster than regular verification circuits in cases like permutation verification and others. Informally, while it is possible to ask the prover to generate randomness by committing to the witness, doing this naively would lead to having additional expensive commitment logic in the circuit. To avoid that, we introduce separated zk-SNARKs that separate the witness values into ones that do not depend on the randomness and ones that do. Then the randomness is produced by committing to the first set of values out of the circuit and using this randomness to produce the second set of values. Due to this separation of the witness, our approach only increases the proof by one group element, and the verification effort by one pairing and two hash function calls, when compared to Groth's zk-SNARK <ref type="bibr" target="#b6">[7]</ref>. Our protocol is not only useful in a universal-circuit context (as explained below), but also from a complexity theory perspective, comprising an efficient zk-SNARK for the MA complexity class.</p><p>Linear-Size Universal Circuits. A universal circuit is a circuit that receives the program to verify as input, besides the input values. One essential element of the verification of universal circuits is checking permutations to ensure that variables with the same labels have consistent values across the circuit. Previous approaches, e.g., vnTinyRAM <ref type="bibr" target="#b3">[4]</ref>, use permutation networks which has O(n log n) overhead. We build a linear-size universal circuit based on an O(n) permutation verification circuit. Informally, we use the fact that two vectors v and w of size n are a permutation of each other if and only if the polynomials ∏(x − v i ) and ∏(x − w i ) are equal, which can be verified by checking equality at a random point r. Furthermore, in order to further reduce the prover's effort, we address different circuit design issues, and present a circuit that has better utilization than previous work. Our final universal zk-SNARK, MIRAGE, is derived by applying our separated zk-SNARK on our randomized, linear-size, universal circuit.</p><p>Applications in Privacy-Preserving Smart Contracts. We utilize MIRAGE in applications that require very succinct proofs and efficient verification, such as blockchain applications. We evaluate MIRAGE in the context of privacy-preserving smart contracts (e.g., HAWK <ref type="bibr" target="#b15">[16]</ref>) to address the trusted key generation per contract issue. Using MIRAGE, a universal verification key will be hardcoded on the blockchain, and for every new computation, an untrusted computation specifier would only provide 32 bytes encoding the computation to be verified to a custom contract. Verifying MIRAGE's proof on the chain would be very similar to verifying zk-SNARK proofs, which has been already implemented on Ethereum (our verifier would only be 1.4× expensive). Besides the evaluation of this scenario, we present detailed evaluation for different kinds of circuits.</p><p>Our contributions. We now summarize our contributions:</p><p>• We introduce separated zk-SNARKs, a zk-SNARK protocol that allows using randomized checks efficiently in circuits, which can be useful for both universal and non-universal contexts. This only adds one group element to the proof in the generic group model, and adds one more pairing operation to the pairing operations done by the verifier in addition to other negligible operations in practice.</p><p>• We design a more efficient universal circuit that provides much better performance compared to the state-of-the-art by using random checks. Given a bound N on the number of operations (additions and multiplications), our universal circuit is linear O(N) instead of O(N log N).</p><p>• We build a new universal zk-SNARK, MIRAGE, by combining the above and we evaluate it in the context of privacypreserving smart contracts, e.g., HAWK <ref type="bibr" target="#b15">[16]</ref>, addressing the trusted setup per contract problem that limits its usage in practice while maintaining verification efficiency.</p><p>Limitations. While MIRAGE significantly reduces the universal circuit overhead in comparison with vnTinyRAM and enables a higher scale of applications, the proof computation overhead is notably more expensive than the non-universal SNARK approach (See Section 6). Additionally, although our system provides a more succinct proof and a more efficient verifier than Sonic, it does not provide updatable CRS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related work</head><p>Here, we discuss the existing zero-knowledge proof systems. In addition, since our system is evaluated in the context of privacy-preserving smart contracts, we provide a brief background on smart contracts and their challenges.</p><p>Zero-knowledge proof systems. <ref type="table">Table 1</ref> gives an overview of representative zero knowledge proof constructions in the space. The constructions can be classified into different categories with respect to the setup requirements:</p><p>• Trusted setup per computation: This most notably includes the construction proposed by Gennaro et al. using quadratic arithmetic programs <ref type="bibr" target="#b0">[1]</ref>. This construction was implemented, improved and extended in several later works <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b7">8]</ref>. A clear advantage of this approach is that the proof size is succinct/constant-size and the verification overhead depends only on the size of the statement being proven. This made this kind of zero knowledge proofs more inviting for blockchain applications <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>• Transparent setup: Several constructions were proposed to eliminate the trusted setup requirement of the previous constructions. These include 1) Discrete log-based techniques, such as Bulletproofs <ref type="bibr" target="#b21">[22]</ref> and the previous work by Bootle et al. <ref type="bibr" target="#b32">[33]</ref>. 2) Interactive oracle proofs techniques <ref type="bibr" target="#b33">[34]</ref>, such as Ligero <ref type="bibr" target="#b20">[21]</ref>, zk-STARKs <ref type="bibr" target="#b24">[25]</ref> Aurora <ref type="bibr" target="#b25">[26]</ref> and more recently Virgo <ref type="bibr" target="#b27">[28]</ref>. These techniques rely on symmetric cryptography and are plausibly conjectured to have post-quantum security. 3) Interactive proof-based techniques <ref type="bibr" target="#b34">[35]</ref>. Such techniques build upon several earlier works <ref type="bibr" target="#b35">[36]</ref><ref type="bibr" target="#b36">[37]</ref><ref type="bibr" target="#b37">[38]</ref>. An example is the Hyrax system by Wahby et al. <ref type="bibr" target="#b23">[24]</ref>. 4) Latticebased techniques, such as the work by Baum et al. <ref type="bibr" target="#b31">[32]</ref>.</p><p>• Universal trusted setup: This includes other interactive proofbased techniques, such as the techniques proposed by Zhang et al. <ref type="bibr" target="#b22">[23]</ref>, and Xie et al. <ref type="bibr" target="#b26">[27]</ref>. These techniques besides all techniques in the second category increase the verification overhead to an extent that might not be suitable for applications where proof size and verification overhead are a bottleneck. To avoid the trusted setup per computation problem while maintaining the verification efficiency, vnTinyRAM <ref type="bibr" target="#b3">[4]</ref> introduced a universal circuit that accepts the program to be verified besides the statement. This was shown to increase the proving cost by orders of magnitude compared to the non-universal approach <ref type="bibr" target="#b9">[10]</ref>. Groth et al. introduced a universal zk-SNARK with updatable common reference strings <ref type="bibr" target="#b28">[29]</ref>, however the size of the CRS in their setting is quadratic making it not practical. Recently, LegoUAC, a zk-SNARK with a linear universal CRS was introduced <ref type="bibr" target="#b29">[30]</ref>, but it has polylogarithmic proofs. On the other hand, Sonic provides an updatable zk-SNARK with constant size proofs <ref type="bibr" target="#b30">[31]</ref>. Sonic can run in two modes: helped and unhelped. In the helped mode, an additional untrusted party helps with making both proof computation and verification more efficient. <ref type="table" target="#tab_0">Table 2</ref> provides a more detailed comparison between systems under the universal trusted setup category with constant proof sizes. Comparison with vnTinyRAM <ref type="bibr" target="#b3">[4]</ref>. MIRAGE's circuit is linear in the number of supported operations, while vnTinyRAM's circuit is quasi-linear. Note that vnTinyRAM's construction accepts a program and a bound T on the number of execution steps, while our construction assumes that the desired computation is represented as an arithmetic circuit or a set of constraints. While the model is different, the same bound in the complexity comparison of the circuit sizes is used, assuming T = Θ(N). In <ref type="table" target="#tab_0">Table 2</ref>, the concrete complexity of our prover is measured in terms of the number of additions and multiplications, but for vnTinyRAM, measuring the concrete complexity is different as it depends on the executed branches during runtime. The cost is estimated conservatively based on the per-cycle gate count in vnTinyRAM <ref type="bibr" target="#b3">[4]</ref>, assuming the generic group model is used. More comparison details are in Section 5.3. Comparison with Sonic <ref type="bibr" target="#b30">[31]</ref>. We mainly consider the unhelped mode of Sonic, as the availability of additional helper parties is not applicable in all contexts, especially if the computation being verified is not the same across many parties. As <ref type="table" target="#tab_0">Table 2</ref> shows, our system is better with respect to the proof size and verification effort, and has competitive prover effort, when compared with Sonic in the unhelped case. If the universal circuit is highly utilized, i.e., N = n + + n * , the prover in our case could have fewer exponentiations. Note that the reported prover cost of our system in <ref type="table" target="#tab_0">Table 2</ref> uses a slightly modified version of the naive basic circuit presented in Section 4, that allows adding and multiplying constants cheaply. This is why the bound N does not consider addition or multiplication of constants. In Section 5, we also present <ref type="table">Table 1</ref>: A comparison of the existing zero-knowledge proof systems. A filled circle indicates no trusted setup, while a half filled circuit indicates a universal setup for a class of computations. n denotes the total number of gates, n * denotes the number of multiplications, n + denotes the number of additions, u is the size of the statement, w is the witness size, N is an upper bound on the number of additions and multiplications and U is an upper bound on the statement size. Assuming full circuit utilization for our construction in the naive case, N would be equal to n * + n + , and U would be equal to u. For Hyrax, Libra and Virgo, d is the circuit depth and g is the width of the circuit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scheme</head><p>Untrusted Setup Proof Computation Proof Size Verification Comparison between current approaches for universal zk-SNARKs with constant-size proofs with respect to the non-universal scheme of Groth16 <ref type="bibr" target="#b6">[7]</ref> as a baseline. Besides the notation used in <ref type="table">Table 1</ref>, m refers to the number of wires, d refers to the maximum size of committed polynomials in Sonic <ref type="bibr" target="#b30">[31]</ref>, EX refers to exponentiations, P refers to pairing operations and T refers to a bound on the number of computation steps in vnTinyRAM (T = Θ(N)). The second group of rows correspond to schemes with universal CRS, while the last group of rows correspond to systems with universal circuits. Assuming full circuit utilization for our construction in the naive case, N would be equal to n * + n + , and U would be equal to u. In all universal schemes, the custom portion of the CRS is not generated by a trusted party.</p><formula xml:id="formula_0">QAP-based [1, 2, 7] O(n * log n * ) O(1) O(u) Ligero [21] O(n * log n * ) O( √ n * ) O(n * ) zk-STARKs [25] O(n * log 2 n * ) O(log 2 n * ) O(log 2 n * ) Bulletproofs [22] O(n * ) O(log n * ) O(n * ) Hyrax [24] O(n + d · g log g) O( √ w + d log g) O( √ w + d log g) Aurora [26] O(n * log n * ) O(log 2 n * ) O(n * ) Baum et al. [32] O(n * log n * ) O( √ n * log n * ) O(n * ) Virgo [28] O(n + w log w) O(d log n + log 2 w) O(d log n + log 2 w) Libra [27] O(n) O(d log n) O(d log n) Groth et al. [29] O(n * log n * ) O(1) O(u) Sonic [31] O(n * log n * ) O(1) O(u) LegoUAC [30] O(n) O(log 2 n) O(u + log 2 n) vnTinyRAM [4] O(N log 2 N) O(1) O(u) This Work O(N log N) O(1) O(u)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scheme</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CRS Size</head><p>Uni. Circ. Size Prover's Overhead Proof Size Verification Assumptions Updatable?</p><p>Universal Custom</p><formula xml:id="formula_1">Non-universal [7] N/A O(n * + m) N/A 4n * + m − u EX 128 B 3 P + u EX GG Groth et al. [29] O(n 2 * ) O(n * + m − u) N/A O(n * + m − u) EX 128 B 5 P + u EX GG Sonic [31] O(d ) O(n * ) N/A 273n * EX 1152 B 13 P AGM, RO Sonic (Helped) O(d ) O(n * ) N/A 18n * EX 256 B 10 P AGM, RO vnTinyRAM [4] O(N log N) O(1) O(N log N) 5000T EX 128 B 3 P + u EX GG This work O(N) O(1) O(N) 90N + 25U EX (naive) 160 B 4 P + u EX GG, RO</formula><p>another circuit design that can reduce the reported prover cost further for many applications.</p><p>Comparison with concurrent work <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b39">40]</ref>: MARLIN provides a preprocessing zk-SNARK that has a universal and updatable CRS <ref type="bibr" target="#b38">[39]</ref>. MARLIN has faster prover and verifier than Sonic, however its proof size is still 1 KB, and the reported experiments showed that its verifier's performance is about 2.6× worse than the Groth16 baseline, despite having fewer pairings. Another work in the same line, PLONK <ref type="bibr" target="#b39">[40]</ref>, improves upon Sonic. PLONK has a proof size of 448 to 512 bytes and a more efficient prover. The estimated costs reported in PLONK <ref type="bibr" target="#b39">[40]</ref> could suggest that its performance is comparable to MARLIN's. In comparison, our proof size is 160 bytes, and the verifier's performance is only 1.4× worse than the Groth16 baseline, which makes MIRAGE's verifier more suitable for applications that require efficient verification. On the other hand, MIRAGE's CRS is not updatable.</p><p>Smart Contracts. The emerging success of cryptocurrencies, most notably Bitcoin <ref type="bibr" target="#b40">[41]</ref>, has motivated several other applications to utilize the decentralized blockchain setting for supporting other functionalities. This further lead to another generation of cryptocurrency systems that aimed at enabling users to customize the decentralized computation, by defining smart contracts. Smart contracts are executable objects that can run autonomously on top of a blockchain and are automatically enforced. Systems like Ethereum <ref type="bibr" target="#b41">[42]</ref> enable users to program smart contracts using high-level languages and post their contracts to the chain. Besides simple trans-action verification, the network in a smart contract system executes the user-specified code included in the smart contract. This clearly leads to a privacy issue, as all values used by the computation will be seen by all miners. HAWK <ref type="bibr" target="#b15">[16]</ref> aims to address the privacy problem by using zero knowledge proofs. For example, to support a privacypreserving decentralized auction, the involved parties and the auction manager interact through a protocol whose correct execution can be verified by a smart contract that does not learn anything about the users' bids or the winner. HAWK relies on QAP-based zk-SNARKs in their implementation as they provide succinct proofs and efficient verification. However, one implication of using this kind of zero-knowledge proofs is the trusted setup needed per computation. This limits the usage of HAWK's approach in practice. In our work, we show how to avoid this problem through our universal circuit and efficient zk-SNARK protocol for randomized verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>In this section, we provide a summary of the definitions and the protocols we use or modify.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Quadratic Arithmetic Programs</head><p>Definition 1 Quadratic Arithmetic Program (QAP) <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref> A QAP Q over field F q contains three sets of m + 1 polynomials V = {v i (x)}, W = {w i (x)},Y = {y i (x)}, for i = 0, . . . , m, and a target polynomial t(x). Let C be a circuit with m wires (a wire can be an input to the circuit or an output of a multiplication gate) out of which u wires are I/O wires (c 1 , . . . , c u ). Then we say that Q computes C if: (c 1 , . . . , c u ) ∈ F u q is a valid assignment of C's inputs and outputs, if and only if there exist coefficients (c u+1 , . . . , c m ) such that t(x) divides p(x), where p(x) is the polynomial</p><formula xml:id="formula_2">(v 0 (x)+ m ∑ i=1 c i v i (x))(w 0 (x)+ m ∑ i=1 c i w i (x))−y 0 (x)− m ∑ i=1 c i y i (x) .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">zk-SNARKs</head><p>zk-SNARKs (zero-knowledge succinct non-interactive arguments of knowledge) have algorithms (Setup, Prove, Verify). In summary Setup outputs prover and verification keys, on input a a circuit C. Algorithm Prove outputs a zero-knowledge proof of knowledge that circuit C is satisfiable for a fixed public statement (I/Os). Finally, Verify verifies that proof, given a public statement. For a zk-SNARK, we want perfect completeness, knowledge soundness and zero-knowledge to hold. Perfect completeness means that an honest prover that knows the witness to a satisfiable statement can provide a verifying proof. Knowledge soundness means that, given a verifying proof for a public statement provided by a PPT adversary A, there exists an extractor that can retrieve a valid witness by inspecting A's tape. Finally, zero-knowledge means that a proof provided by an honest prover leaks nothing more than the validity of the statement. The formal definitions of the above three properties (and the ones we use in our proofs) can be found in Definition 2 of Groth's zk-SNARK <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Groth16 protocol</head><p>We summarize the protocol proposed by Groth <ref type="bibr" target="#b6">[7]</ref> in the generic group model, using the notation we use in this paper.</p><p>Protocol 1 The Groth16 Protocol <ref type="bibr" target="#b6">[7]</ref> • {vrk C , prk C } ← Setup(C, 1 λ ): Let C be an arithmetic circuit with u public input and output values from F q , i.e., u is the statement size. Build a QAP Q = (t(x),V,W,Y ) of size m and let n be the degree of t(x). Let I mid = {u + 1, . . . , m}. Let e be a bilinear map e :</p><formula xml:id="formula_3">G 1 × G 2 → G T ,</formula><p>and let g 1 be a generator of G 1 and g 2 be a generator of</p><formula xml:id="formula_4">G 2 . Choose α, β, γ, δ, s ← F q .</formula><p>Construct the public proving key prk C as follows:</p><formula xml:id="formula_5">• g α 1 , g β 1 , g δ 1 , g β 2 , g δ 2 • {g s i 1 } n−1 i=0 , {g s i 2 } n−1 i=0</formula><p>• {g</p><formula xml:id="formula_6">(βv i (s)+αw i (s)+y i (s))/δ 1 } i∈I mid</formula><p>• {g</p><formula xml:id="formula_7">s i t(s)/δ 1 } n−2 i=0</formula><p>Construct the verification key vrk C as</p><formula xml:id="formula_8">• g α 1 , g β 2 , g γ 2 , g δ 2 , • {g (βv i (s)+αw i (s)+y i (s))/γ 1 } u i=0</formula><p>• π ← Prove(C, prk C , stmt): Given public statement stmt which includes the values {c i } u i=1 , the prover infers the values of the remaining wires in the circuit {c i } m i=u+1 and samples two random values κ 1 and κ 2 from F q . The prover then computes h(x) = p(x) t(x) , and computes the proof as</p><formula xml:id="formula_9">• π A = g α+v(s)+κ 1 δ 1 • π B = g β+w(s)+κ 2 δ 2 • π C = g (h(s)t(s)+I mid (s))/δ 1 .π κ 2 A .B κ 1 1 .g −κ 1 κ 2 δ 1 where • v(x) = ∑ m i=0 c i v i (x) • w(x) = ∑ m i=0 c i w i (x) • B 1 = g β+w(s)+κ 2 δ 1 • I mid (x) = ∑ i∈I mid c i (βv i (x) + αw i (x) + y i (x))</formula><p>Proof π contains π A , π B and π C .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association 29th USENIX Security Symposium 2133</head><p>• {0, 1} ← Verify(vrk C , stmt, π): Given the proof and the verification key, the verifier does the check</p><formula xml:id="formula_10">e(π A , π B ) = e(g α 1 , g β 2 ).e(g Ψ io (s)/γ 1 , g γ 2 ).e(π C , g δ 2 ) ,</formula><p>where</p><formula xml:id="formula_11">Ψ io (x) = ∑ u i=0 c i (βv i (x) + αw i (x) + y i (x)</formula><p>) and where c 0 = 1 and (c 1 , . . . , c u ) is the public statement stmt being proved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Arguments for MA complexity class</head><p>We consider the class of languages that can be efficiently verified given a randomized verifier with public coins. Concretely, assume the class of MA statements (from Merlin-Arthur) which can be viewed as the randomized analogue of N P. In particular it contains languages L that come with a probabilistic polynomial-time verification algorithm L(x,w), where x in the statement and w is the witness. The requirement is that if x ∈ L then there is a witness w such that the probability that L(x, w) accepts is at least 2/3. If x / ∈ L, for all witnesses w, L(x,w) accepts with probability at most 1/3. It is crucial that the coins of L(x,w) are chosen independently of wotherwise, a cheating prover can compute a witness w and related randomness that will make L(x,w) accept with probability &gt; 1/3. The above soundness bound can be replaced with one exponentially small in |x|, |w| (e.g., 2 −λ ) and the correctness bound can be made 1, without changing the class. Clearly, MA contains N P and P. Interestingly, there are problems both in MA and P whose MA verification procedure is much faster than the P verification procedure. For example, checking primality has a slow deterministic test <ref type="bibr" target="#b42">[43]</ref> but a fast randomized test <ref type="bibr" target="#b43">[44]</ref>. Similarly, checking that a vector is a permutation of another vector has an O(n log n) deterministic test but an O(n) randomized test (form polynomials where the elements of the vectors are roots and check equality at a random point). For practical purposes this is very important. In particular, our paper defines a language L that contains pairs (C, p) where C is an arbitrary arithmetic circuit of n * multiplication gates and n + addition gates, p is a value assignment on a subset of C's wires and (C, p) ∈ L iff there exist an assignment p on the rest of C's wires such that (p, p ) is a valid assignment for C. Clearly, L is in N P, but we also show that L has a much faster verification procedure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Baseline zk-argument for MA</head><p>Given a language L in MA with randomized verification procedure L(x,w), we can write down L(x,w) as a deterministic procedure L(x,w,r), where r ∈ {0, 1} λ are the random coins used in L(x,w). A baseline way to construct a zeroknowledge argument for MA from any zk-SNARK for NP, is as follows. First, we ask the prover to commit to witness w using a hiding and binding commitment com w . Then, the verifier chooses random coins r and sends them to the prover. Finally, the prover runs the SNARK proving algorithm for the composite statement "w is a valid opening for com w and L(x,w,r) accepts." Since the commitment scheme is hiding and the SNARK is zero-knowledge, the verifier learns nothing about w from the interaction. Assuming the commitment scheme has a "knowledge" property (enhancing it with a zeroknowledge proof-of-knowledge, if necessary), the soundness of the protocol can be proven in a straight-forward manner by extracting the pre-image of com w and the witness used in the circuit of L. If they are different, this can be used to break the commitment binding property. Else, since com w was computed before seeing r, the probability that the extracted witness is not a valid witness for x, is negligible by the soundness property of the MA argument.</p><p>If |r| is at most polylogarithmic in |w|, this protocol is a succinct zero-knowledge argument. The downside of this approach is that it required "opening" com w inside the circuit being argued with the SNARK, which may introduce a significant overhead in practice. In the rest of this section, we describe a more efficient way to build zero-knowledge arguments for MA by modifying the zk-SNARK of Groth <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Separated zk-SNARKs</head><p>Recall that in a typical zk-SNARK based on quadratic arithmetic programs, the wire indices of the circuit being verified are divided in two categories. The ones that correspond to the public statement being proved usually referred to as IOrelated indices and the ones that correspond to the non-IOrelated indices that we call I mid (these contain the witness indices too). A separated zk-SNARK is a zk-SNARK with the difference that it is parametrized by a set of indices J ⊂ I mid . More importantly, the proof π of a separated zk-SNARK can be written as [π , π J ] where π J can be computed with access only to the values of the indices in J and the public parameters. We now give a separated zk-SNARK implemented off Groth's original zk-SNARK <ref type="bibr" target="#b6">[7]</ref>. We highlight the changes with blue. We prove its knowledge soundness in the generic group model and its zero-knowledge (as per <ref type="bibr">[7, Def. 2]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Protocol 2 The separated Groth16 Protocol</head><p>• {vrk C(J) , prk C(J) } ← Setup(C(J), 1 λ ): Let C be an arithmetic circuit with u public input and output values from F q , i.e., u is the statement size. Build a QAP Q = (t(x),V,W,Y ) of size m and let n be the degree of t(x). Let I mid = {u + 1, . . . , m}, J ⊆ I mid and I = I mid − J.</p><p>Choose α, β, γ, δ, δ , s ← F q . Construct the public proving key prk C(J) as follows:</p><formula xml:id="formula_12">• g α 1 , g β 1 , g δ 1 , g δ 1 , g β 2 , g δ 2 • {g s i 1 } n−1 i=0 , {g s i 2 } n−1 i=0 • {g (βv i (s)+αw i (s)+y i (s))/δ 1 } i∈I • {g (βv i (s)+αw i (s)+y i (s))/δ 1 } i∈J • {g s i t(s)/δ 1 } n−2 i=0</formula><p>Construct the verification key vrk C(J) as</p><formula xml:id="formula_13">• g α 1 , g β 2 , g γ 2 , g δ 2 , g δ 2 • {g (βv i (s)+αw i (s)+y i (s))/γ 1 } u i=0</formula><p>• π ← Prove(C(J), prk C(J) , stmt): Given public statement stmt which includes the values {c i } u i=1 , the prover infers the values of the remaining wires in the circuit {c i } m i=u+1 and samples three random values κ 1 , κ 2 and κ 3 from F q . The prover then computes h(x) = p(x) t(x) , and computes the proof as</p><formula xml:id="formula_14">• π A = g α+v(s)+κ 1 δ 1 • π B = g β+w(s)+κ 2 δ 2 • π C = g (h(s)t(s)+I(s))/δ 1 .π κ 2 A .B κ 1 1 .g −κ 1 κ 2 δ−κ 3 δ 1 • π D = g κ 3 δ 1 g J(s)/δ 1 where • v(x) = ∑ m i=0 c i v i (x) • w(x) = ∑ m i=0 c i w i (x) • B 1 = g β+w(s)+κ 2 δ 1 • I(x) = ∑ i∈I c i (βv i (x) + αw i (x) + y i (x)) • J(x) = ∑ i∈J c i (βv i (x) + αw i (x) + y i (x))</formula><p>Write proof π as [π , π J ] where π contains π A , π B and π C and π J contains π D .</p><p>• {0, 1} ← Verify(vrk C(J) , stmt, π): Given the proof and the verification key, the verifier checks to see if e(π A , π B ) equals</p><formula xml:id="formula_15">e(g α 1 , g β 2 ).e(g Ψ io (s)/γ 1 , g γ 2 ).e(π C , g δ 2 ).e(π D , g δ 2 ) ,</formula><p>where</p><formula xml:id="formula_16">Ψ io (x) = ∑ u i=0 c i (βv i (x) + αw i (x) + y i (x)</formula><p>) and where c 0 = 1 and (c 1 , . . . , c u ) is the public statement stmt being proved.</p><p>Proof sketch for knowledge soundness. Knowledge soundness holds in the generic group model. <ref type="bibr" target="#b0">1</ref> Following the proof technique in <ref type="bibr" target="#b6">[7]</ref>, we express π A , π B , π C and π D as g A , g B , g C and g D , where A, B, C and D are 6-variate Laurent polynomials in α, β, γ, δ, δ and s and, due to the generic group model, can be expressed as linear combinations of the elements in vrk C(J) , prk C(J) . Substituting in the verification equation, we have that two Laurent polynomials should be equal. This gives rise to equations that relate to the coefficients of distinct monomials on both sides, allowing us to extract the QAP coefficients. The proof is in the full version of the paper.</p><p>Proof for zero-knowledge. The simulator can choose group elements for π A , π B and π C by randomly choosing their exponents and then set π D to be the element satisfying the verification equation. Since κ 1 , κ 2 , κ 3 are chosen uniformly at random in our construction and π D is the only group element satisfying the verification equation, zero-knowledge follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Efficient zk-SNARK for MA</head><p>Now we build an efficient zk-SNARK for a language L in MA using the above separated construction. Let L(x,w,r) be the de-randomized verifier algorithm for L, as introduced before. We view L as a circuit with IO-related indices being x and r and non-IO-related indices I mid being the rest of the wire indices. Define J ⊂ I mid to be the set of all wire indices of L(x,w,r) that do not depend on the randomness r-note that J includes the wires corresponding to the witness w. Let us call those wires deterministic wires.</p><p>To give an intuition about that, consider the MA language that contains pairs of n-sized vectors (a, b) such that</p><formula xml:id="formula_17">(a, b) ∈ L iff b is a sorted version of a. The MA verification</formula><p>procedure involves two checks (note that in this case there is no explicit witness that is given as input):</p><formula xml:id="formula_18">1. (deterministic comparison check) b i ≤ b i+1 for all i = 1, . . . , n − 1; 2. (randomized permutation check) ∏ n i=1 (a i + r) = ∏ n i=1 (b i + r)</formula><p>. In this case, the set of deterministic wires J will correspond only to the wires that are used to implement the comparisons (whose values only depend on the statement).</p><p>We are now ready to describe the protocol. The common input of the verifier and the prover is a statement x; the prover additionally has a corresponding witness w. The goal of the prover is to persuade the verifier, in zero-knowledge, that x ∈ L where L is an MA language with verification procedure L(x,w,r). Let J be the set of deterministic wires for L(x, w, r) and let {vrk L(J) , prk L(J) } ← Setup(L(J), 1 λ ) be the parameters generated from the Setup of the separated zk-SNARK. Our protocol is interactive and proceeds as follows. 1. Given x ∈ L and the respective witness w, the prover computes the values of the deterministic wires J with respect to L(x,w,r) and then computes π J using the public parameters prk L(J) . The prover sends π J to the verifier;</p><p>2. The verifier picks a random r and sends to the prover;</p><p>3. The prover computes the values for the wires in I mid −J using randomness r. At that point he knows all the wire values for L(x,w,r) and runs π ← Prove(L(J), prk L(J) , x||r).</p><p>Parse π as [π π J ] and send π to the verifier;</p><p>4. The verifier computes π = [π π j ] and runs {0, 1} ← Verify(vrk L , x||r, π), using the π J received in Step 1 and the randomness r sent at Step 2. As the randomness r is "public" since L is in MA (as opposed to secret randomness used locally by the verifier),</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association 29th USENIX Security Symposium 2135</head><p>the interaction can be removed with the Fiat-Shamir heuristic, assuming a collision-resistant hash function hash modelled as a random oracle.</p><p>• Given x and w, the prover computes the values of the deterministic wires J with respect to L and then computes π J using the public parameters prk L(J) . Then the prover computes r = hash(x||π J ). Then the prover computes the values for the wires in I mid − J using randomness r. At that point, the prover knows all the wire values for L(x,w,r) and runs π ← Prove(L, prk L(J) , x||r). Then the prover sends π to the verifier;</p><p>• The verifier parses π as [π π J ], computes r = hash(x||π J ) and runs {0, 1} ← Verify(vrk L , x||r, π).</p><p>As in Section 3.1, if r is of size only polylogarithmic in |w| (and polynomial in |x| and security parameter λ), then the resulting protocol is a succinct non-interactive argument. The prover's runtime is asymptotically the same as that of Groth's protocol˜Oprotocol˜ protocol˜O(|L|).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A Universal Circuit Protocol for zkSNARKs</head><p>In this section, we adapt the protocol described above in the context of universal circuits. We will use a simplified version of our universal circuit to make the representation less involved. (Section 5 presents the circuit design in detail). The goal is to define a simple universal language L univ that captures the operations of any circuit C that has at most n * multiplications and n + additions, and its statement size is bounded by n s . We use the following notation: Let l i and l i refer to an index (label) of a variable in our construction. Let z i and z i refer to the values of the variables with indices l i and l i respectively. An entry is a pair of label and value, e.g., (l i , z i ). Let spec be a vector that specifies the functionality of a custom circuit C, i.e., spec C = (l 1 , l 2 , . . . , l n s +3n * +3n + ). The first n s elements will correspond to the labels of the statement variables, then the following 3n * and 3n + elements will be the labels of the variables used in multiplication and addition constraints, respectively. Let stmt be a vector that includes the values of the statement variables, i.e., stmt = (z 1 , z 2 , . . . , z n s ). <ref type="figure" target="#fig_1">(Figure 1 illustrates an example)</ref> Define the language L univ as follows: An instance (spec C , stmt) ∈ L univ if and only if stmt is a satisfying assignment for the specification of C, i.e.,</p><p>• There exists a vector (z n s +1 , z n s +2 , . . . , z n s +3n * +3n + ) such that z i+2 = z i × z i+1 for all i ∈ {n s + 1, . . . , n s + 3n * − 2}, and z i+2 = z i +z i+1 for all i ∈ {n s +3n * +1, . . . , n s +3n * + 3n + − 2}.</p><p>• There exists a vector of (l i , z i ) entries where i ∈ {1, . . . ,</p><formula xml:id="formula_19">n s + 3n * + 3n + }, such that -It is a permutation of the entries {(l i , z i )} i∈{1,...,n s +3n * +3n + } . -(Consistency) For all i ∈ {1, . . . , n s + 3n * + 3n + − 1}, l i ≤ l i+1</formula><p>, and if l i = l i+1 , then z i must be equal to z i+1 . To check membership in L univ , a randomized verifier applies all the correctness and consistency constraints above, and checks the permutation constraint as follows. Given two uniformly selected random values r 1 and r 2 from F q , the following must hold:</p><formula xml:id="formula_20">n s +3n * +3n + ∏ i=1 ((l i + r 2 z i ) − r 1 ) = n s +3n * +3n + ∏ i=1 ((l i + r 2 z i ) − r 1 )</formula><p>To show that L univ ∈ MA 2 , we argue about the complexity of the verifier and the probability of failure. Let C univ be a circuit that encodes the verification logic above. Note that the size of the circuit will be linear in the size of the specification. A prover would send the circuit C univ to the verifier along with the values of all z i 's and (l i , z i ) entries. The verifier can then run the circuit given the prover's input, the specification spec C , and two independently generated random values r 1 , r 2 . It's easy to observe that the verifier runs in a polynomial time.</p><p>Completeness. If (spec C , stmt) ∈ L univ , i.e., the prover is honest, it is easy to see that verification will always succeed with probability 1.</p><formula xml:id="formula_21">Soundness. If (spec C , stmt) / ∈ L univ , i.e.</formula><p>, the prover is dishonest, to calculate the probability of successful verification, we can compute an upper bound based on the probability of the following two events:</p><p>• The prover could cheat if for any i ∈ {1, 2, . . . , n s + 3n * + 3n + } and j ∈ {1, 2, . . . , n s +3n * +3n + }, the random value r 2 was equal to the root of the polynomial</p><formula xml:id="formula_22">p i j (x) = l i − l j + x(z i − z j ), i.e., r 2 = l j −l i z i −z j when z i = z j .</formula><p>Let p 1 denote the probability of this event. It can be shown that p 1 ≤ (n s +3n * +3n + ) <ref type="bibr" target="#b1">2</ref> |F q | .</p><p>• The prover could cheat if the random value r 1 is a root of the polynomial p(    witnesses values). Appendix A illustrates how to apply our Protocol 2 for C univ in detail. The following points highlight few details about the mapping and the differences:</p><formula xml:id="formula_23">x) = ∏ n s +3n * +3n + i=1 ((l i + r 2 z i ) − x) − ∏ n s +3n * +3n + i=1 ((l i +r 2 z i )−x</formula><p>• The statement of C univ is changed to also include {l i } i∈{1,...,n s +3n + +3n * } besides {l i } i∈{1,...,n s +3n + +3n * } and {z i } i∈{1,...,n s } , as the values of {l i } are known during the specification of the custom circuit.</p><p>• The set J in Protocol 2 will include the set of indices corresponding to the wires carrying the witness values of {z i } i∈{n s ,...,n s +3n + +3n * } , {z i } i∈{1,...,n s +3n + +3n * } . Note that the prover will commit to both the values corresponding to the set J and the statement, which includes {z i } i∈{1,...,n s } .</p><p>• To minimize the verifier's effort, we introduce an untrusted derive phase for computing the encoding of {l i } and {l i } (or the circuit specification in the general case). This happens only once per a custom new circuit, and can be both computed and verified in linear time. The encoding of the specification is just one group element (32 bytes) in our setting (See vk spec in Appendix A).</p><p>• Finally, for efficiency purposes, when computing the hash of the statement and the witness commitment, instead of computing Hash(x||π j ) directly as described in Section 3, we use the encoding of the statement x that is computed during the zk-SNARK verification algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Universal Circuit Design</head><p>In this section, we describe the approaches we investigated for designing the universal circuit. In the rest of the discussion, we use the term opcode to denote the type of an instruction or operation. The cost of any component is measured in terms of the number of constraints (multiplication gates) needed to implement or verify its logic in the circuit. Note that the cost of verifying a single instruction equals the cost of verifying the operation itself (based on the logic corresponding to the opcode) plus the cost of verifying the consistency of the values of its entries with respect to the rest of the circuit (the permutation and consistency check logic). For example, for a multiplication or addition instruction as defined before, the cost of verifying operation correctness is one constraint, while the cost of verifying the consistency of the values of the entries equals 15 constraints (5 per entry).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Single-opcode version</head><p>The circuit design we considered in the previous sections included only two types of operations: addition and multiplication operations. This version can be slightly modified to be only a single-opcode circuit, with an additional binary input with each instruction to choose which operation should be activated (this additional input will belong to the spec C vector, and will be set during derivation). This will only add one more constraint to the instruction cost, while enabling more flexible ranges of addition or multiplication operations. Additionally, to avoid the cost of multiplying or adding constants, this opcode can also be extended using additional input that are specified during the derivation. More concretely, the spec C vector will also include additional values b j , c j,1 , c j,2 , c j,3 , c j,4 , for each instruction j besides the labels of the variables l i , l i+1 , l i+2 . For each instruction j, the circuit applies the following logic,</p><p>• If b j = 1, verify that z i+2 = (c j,1 + c j,2 z i )(c j,3 + c j,4 z i+1 ).</p><p>• If b j = 0, verify that z i+2 = c j,1 + c j,2 z i + c j,3 + c j,4 z i+1 .</p><p>We call the additional variables b j , c j,1 , c j,2 , c j,3 , c j,4 functionality selectors. Note that they will also be set at the time of specifying the computation like l i and l i . Although the single-opcode circuit can represent any set of arithmetic constraints, it would result into high overhead when representing different kinds of basic operations:</p><p>1) Cost of intermediate variables. In many circuits/programs, intermediate variables are used only once. Using the naive single-opcode version described earlier to compute a sum or product of n variables, or compute a dot product of two n-dimensional vectors for example will lead to repeated entries of intermediate variables (See l 9 and l 11 in <ref type="figure" target="#fig_1">Figure 1</ref> for an example). We will reduce the overhead of this by enabling instructions to consider the output of the previous operation that is specified in the circuit as an additional operand. For example, to compute a dot product of two n-elements vectors, nearly n instructions will be consumed instead of 2n instructions. Instead of specifying a computation c = a 1 b 1 + a 2 b 2 + a 3 b 3 , as a 1 b 1 = t 1 , a 2 b 2 = t 2 , a 3 b 3 = t 3 ,t 1 + t 2 = d 1 , d 1 + t 3 = c, we enable expressions to optionally include the last operand from the previous operation if needed a 1 b 1 = t 1 , a 2 b 2 + t 1 = t 2 , a 3 b 3 + t 2 = c (See opcode 1 in the next subsection).</p><p>2) Bit operations and binary constraints. In many zk-SNARK circuits in practice, unpacking or splitting a variable into bits is a necessary operation. It's used for range checking, comparisons, division/mod operations, bitwise operations, exponentiations and others. For example, verifying a bitwise XOR operation would involve decomposing or splitting values into bits. For a variable x, this would require checking equations of the form b i b i = b i and checking x = ∑ 2 i b i in the universal circuit, which will consume several instructions and several variable entries for each single bit, therefore using the single-opcode version described earlier will lead to a high amplification factor for such frequent checks. Instead, we combine all similar bit operations within other opcodes (See opcodes 2 and 3). Opcode 2 does not introduce entries for bits, and handles bit operations and checks within its circuit. Opcode 3 avoids the repeated entries for bit constraints, and is for explicit extraction of bits in the universal circuit.</p><p>3) Using randomness. As our approach enables the usage of random values in the circuit, these random values could be used to verify other functionalities that are cheaper to verify using a randomized check. In our circuit, we utilized this for implementing the verification of read/write memory accesses when the indices are not known during the specification time (See opcode 4 in the next subsection).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Multi-opcode version</head><p>When designing a multi-opcode circuit, there is a trade-off between the circuit utilization and the efficiency of individual basic operations. Adding an opcode per every possible basic function will lead to many unused constraints if the program being evaluated has a skewed opcode distribution. On the other hand, using a single opcode version will guarantee high utilization, but will be less effective in practice. Finding the optimal point is a problem of independent interest, as it will require careful workload characterization (See Section 7), depending on the application set being considered.</p><p>In our design, we used the following criteria: 1) We add a new opcode whenever any of the basic operations is significantly amplified using the already available opcodes. By basic operations, we mean the common operators provided by high-level programming languages. This includes arithmetic operations, bitwise operations (e.g., bitwise xor, shift, rotate, .. etc), bit extraction, integer comparison, load and write operations to random memory locations, .. etc. If a certain basic operation can be represented using few constant number of calls to existing opcodes, we do not add a new opcode for that operation. 2) We combine similar basic operations together in one opcode when they share computation, or if they have additional small overhead. For example, instead of having separate opcodes for basic bitwise operations like bitwise-and, bitwise-xor and bitwise-or as in previous work, we observe that these computations can share many of their intermediate computations using a minimized circuit, and therefore, we use only one opcode for them.</p><p>Figures 2 and 3 in Appendix B illustrate our design of the multi-opcode circuit. In the following list, we provide a high-level description for each opcode. Further details about the functionality that can be verified by each opcode can be found in <ref type="table" target="#tab_5">Table 6</ref> in Appendix B.</p><p>• Opcode 1: This is an enhanced version of the basic opcode in the single-opcode circuit. It aims to combine addition, multiplication constraints, individual bit operations (OR, AND, XOR), and equality testing. It can also include the result from the previous opcode instruction as an additional operand to reduce the cost of intermediate operations. Using a minimized circuit, our opcode 1 circuit would cost 26 constraints (11 constraints for verifying the operation, and 15 constraints for the consistency of entry values).</p><p>• Opcode 2 (Integer Bitwise Operations): Using opcode 1 to encode bitwise operations will have a high cost since each individual bit check and operation will have its own instruction. Therefore, we introduce another opcode. Given three n-bit integers a, b and c, this opcode verifies that c is either the bitwise-xor, bitwise-or or bitwise-and of a and b, or any of their bitwise-negations (12 possibilities in total). In our circuit, we set n to be 32 (Note that in the evaluation section, we will evaluate short and long-integer computations that do not align with 32-bit arithmetic). This opcode can also be used for range checking, e.g., verify that two operands a and b are bounded without introducing entries for the individual bits, which is useful for comparison, division, etc.</p><p>To illustrate the savings in the case of a bitwise-OR of two 32-bit values, using opcode 1 only would consume 96 instructions for splitting the first two operands into bits (64 instructions for booleanity checks and 32 for bits weighted sums), and 32 instructions for the OR operations, totalling 26 × (96 + 32) = 3328 constraints. On the other hand, using a single opcode 2 instruction will cost about 135 constraints. Note that the bit checks required by the splitting operations within this opcode are done within its circuit and does not rely on other opcodes.</p><p>• Opcode 3 (Split/Pack Operations, shift/rotation, weighted sums): This opcode can used to explicitly extract bit or byte values, or pack them into one value. It can also be used to support shifting/rotation operations, and weighted sums of native field elements. Note that using opcode 1 or opcode 2 for all bit extractions of a single element will not result into an efficient implementation. For example, to split a 32-bit value into bits, using opcode 1 will cost 48 instructions (1248 constraints), while using opcode 2 will require masking several times (32 instructions, costing 4320 constraints). Note that the circuit of opcode 2 does not introduce entries for the bits used within its circuit. On the other hand, the circuit of opcode 3 requires 330 constraints (while enabling other functionalities, like rotation, weighted sums, etc).</p><p>• Opcode 4 (Memory accesses): This opcode is used for accessing arrays during runtime when the index operand has an unknown value. Previous compilers use different approaches for implementing this functionality <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref>. In the general case, a permutation network approach is used to verify permutations in previous work, which costs O(n log n) constraints, where n denotes the number of accesses. In our circuit, we rely on the randomness values we have in the circuit to get an O(n) circuit instead (this uses a similar idea to the global permutation check). Representation of other basic operations. Compared to the universal circuit in vnTinyRAM's implementation <ref type="bibr">[46]</ref>, we do not have explicit opcodes for other basic operations like comparisons, divisions and others. These operations can be implemented using few calls to some of the opcodes above. For example, performing a 32-bit unsigned integer comparison can be implemented using opcodes 1 and 2. Note that in our evaluation setting, we consider computations that heavily rely on basic operations not explicitly expressed in our opcode system, or operations that do not align with 32-bit arithmetic, such as sorting 16-bit elements, RSA (2048-bit integers) and AES (8-bit integers). Opcode distribution. One remaining design decision is how many times an opcode type should appear in the circuit. Compared to previous work, we have more flexibility in choosing the distribution of the opcodes as instructions are not verified in order (See <ref type="figure" target="#fig_1">Figure 1</ref> and Section 5.3). We noticed that having the same number of instances per each opcode type will lead to high waste if the custom computation heavily relies on the cheapest opcode. As a heuristic way to balance these factors, we consider the cost of the individual instruction circuit corresponding to each opcode and the number of basic operation categories supported by it. For a given bound on the total number of constraints of the universal circuit B, an even share is given to each of the first three opcodes, while half of that share is given to the last opcode as it is only specific to a single category (memory operations) while the other opcodes can support different arithmetic and Boolean operations (See <ref type="table" target="#tab_5">Table 6</ref>). More concretely, if the circuit corresponding to each opcode costs x 1 , x 2 , x 3 , x 4 constraints respectively, each will appear around 2B</p><formula xml:id="formula_24">7x 1 , 2B 7x 2 , 2B 7x 3 , B 7x 4</formula><p>times. We believe that choosing the ideal distribution should be done based on application analysis, and is left to future work (Section 7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Comparison with vnTinyRAM Circuit</head><p>vnTinyRAM follows the von Neumann paradigm, where both the program and the data are stored in the same address space <ref type="bibr" target="#b3">[4]</ref>. In vnTinyRAM, the program instructions are loaded and verified in the circuit, and features like runtime code generation is supported. While we could integrate the techniques of MIRAGE directly to make vnTinyRAM's circuit linear, as improving the permutation check will make checking both instructions and data more efficient, we chose to focus on the circuit representation of computation and not to have explicit support or specific opcodes for loading/generating instructions during runtime. This is because of two main observations: 1) Loading instructions at runtime implies an ordered processing of instructions in the circuit, which can lead to high overhead and much less utilization of the available gates. This is because when loading unknown instructions during runtime, the circuit of each step would have to account for all possible operation types. 2) Looking into many applications involving zk-SNARKs, we are not aware of common use cases that heavily rely on runtime code generation. Furthermore, we believe there is a higher need to universal circuits that provide better performance in practice.</p><p>Our universal circuit targets the circuit representation of programs and differs in the following ways: 1) It uses a randomized check to verify the consistency across the circuit. This has a linear cost compared to the quasi-linear cost of vnTinyRAM. 2) It does not require verifying operations in the order they were executed. This implies a much better utilization of the circuit, as each computation step known at the specification time only pays for the opcode(s) it uses. 3) On the other hand, targeting the circuit representation of programs has implications. For example, mapping an if-else statement to our construction will consume instructions for both branches. Note that features like jump instructions and runtime code generation could be supported by specifying a vnTinyRAM-like circuit as input to our circuit. Although this would rely on more efficient randomized checks, instructions resolved during runtime will have a much higher cost compared to the instructions known at the specification time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>We implemented our protocol on top of libsnark <ref type="bibr">[46]</ref>, and developed a front-end java library that generates the universal circuit, and allows a programmer to specify a computation. In the following, we discuss the performance impact of using our construction for universal circuits in different settings.</p><p>Comparison with non-universal and universal circuits. First, we start by a comparison with vnTinyRAM in terms of <ref type="table">Table 3</ref>: Comparison between our work and earlier non-universal and universal circuits with respect to the scale of supported applications when the number of constraints (the total circuit size) is nearly the same  the scale of the applications that can be supported given the same circuit size. We use the results reported in the implementation of the vnTinyRAM specification by <ref type="bibr" target="#b9">[10]</ref> as a baseline.</p><p>For our circuits, we use the multi-opcode circuits, where the opcodes are distributed according to the criteria presented earlier. We consider two applications: matrix multiplication and merge sort which use different basic operations and random memory accesses. We also compare with non-universal circuit generation tools <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. As shown in <ref type="table">Table 3</ref>, our universal circuit supports largerscale problems than vnTinyRAM, while reducing the gap between the universal and the non-universal approaches. With respect to the number of basic operations supported under the same circuit sizes, our circuit enables orders of magnitude higher scale compared to the vnTinyRAM circuit. Note that part of our circuit is also still available to be used by other operations, as illustrated by the ratio of available instructions.</p><p>Cost of universality. Next, we report the amplification cost of certain primitives that use different kinds of operations and does not necessarily operate in the 32-bit integer space. For this part of the evaluation, the cost of the used instructions are only counted to calculate the exact amplification cost.</p><p>Besides matrix multiplication and merge sort, we consider three cryptographic primitives, and compare with the optimized non-universal circuits reported by xJsnark <ref type="bibr" target="#b10">[11]</ref>. Note that the chosen primitives span basic operations not directly covered by the opcodes described in Section 5. For example, the RSA-2048 modular exponentiation circuit performs mod operations in the circuit modulo a long integer. Also, the AES-128 circuit performs random memory accesses and operates on 8-bit words, while our universal circuit opcodes are for 32-bit words. This required effort to get a concise mapping from the AES operations to the instructions of our universal circuit. Note that the optimizations of previous compilers <ref type="bibr" target="#b10">[11]</ref> assume a cost model that is only relevant in the custom circuit scenario. <ref type="table" target="#tab_3">Table 4</ref> provides the comparison. While there is an amplification factor between 3 and 26× depending on the application, in comparison vnTinyRAM is expected to have 1 to 2 order of magnitude higher overhead as shown earlier.</p><p>Privacy-preserving Smart Contracts. Finally, we evaluate our system in the context of a practical application involving smart contracts. In particular, we address the trusted setup per contract challenge of the HAWK system <ref type="bibr" target="#b15">[16]</ref>. In HAWK, the users' circuits do not change depending on the computation, while the manager's circuit does change per computation. The manager's circuit in the HAWK system verifies the correct execution of a pre-specified contract code, but on private data. This circuit relies on commitment and symmetric encryption gadgets besides the function being supported.</p><p>We consider two applications from the HAWK paper in our evaluation, namely privacy-preserving auctions and crowdfunding in the case of six participants (In Section 7, we discuss how to scale the system up to more participants). For this evaluation, we fix our universal multi-opcode circuit size to 10 million constraints. We used libsnark's Groth16 implementation as the back end for the baseline. The experiments were conducted on an EC2 machine (c5d.9xlarge instance), using a single processor, and consuming 36 GB of memory at most during the keygen/prove stage. <ref type="table">Table 5</ref> illustrates the results. We observe the following:</p><p>• The untrusted key derivation phase that happens per contract in our construction just adds one group element to the verifier's storage (the contract in our scenario), while the non-universal approach will generate a separate larger verification key per contract in a trusted manner.</p><p>• Our universal approach only adds a small overhead to the verification time and the proof size. <ref type="table">Table 5</ref>: Comparison between our system and HAWK <ref type="bibr" target="#b15">[16]</ref> in the context of privacy-preserving auction and crowdfunding applications. The number of participants in each application is set to 6 (1 manager, and 5 bidders/participants • There is about 30× amplification factor in the proof generation time. The reason this factor is larger than the previously reported overhead in <ref type="table" target="#tab_3">Table 4</ref> is because nearly half of the instructions in the universal circuit were not used (mainly the opcode types that were not used heavily by the commitments or the applications being evaluated).</p><p>• Comparison with existing work: The proof size of Sonic <ref type="bibr" target="#b30">[31]</ref> is 1152 bytes in the unhelped mode (compared to 160 bytes in our case), and the verifier's effort is 3× worse than ours. For the prover, the amplification factor of the number of exponentiations in Sonic <ref type="bibr" target="#b30">[31]</ref> is more than 50× in the unhelped prover's case, compared to 30× in our case, when the circuit is highly utilized. In the future, we will also evaluate other applications that require trusted setup per user-defined computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion and Discussion</head><p>In this paper, we presented MIRAGE a zk-SNARK protocol that allows the verification of randomized algorithms efficiently. Compared to baseline zk-SNARKs, our protocol increases the verification overhead by one pairing, and increases the proof size by one group element in the generic group model. We used our protocol to build an efficient universal circuit, and illustrated savings in different contexts, including privacy-preserving smart contracts. However, our work leaves several open problems for future work, which we discuss next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Scalability</head><p>Although we significantly reduced the cost of universal circuits in this paper and illustrated the impact on different applications, there is still a cost that has to be paid for being universal. In this subsection, we discuss some directions that could be considered to alleviate the scalability challenges. Distributed systems for ZK proof computation. As large zk-SNARK circuits lead to high memory consumption at the prover's side, one way to avoid such practical limitation is to use a distributed system to compute the zk-SNARK proof using multiple instances. A recent system, DIZK <ref type="bibr" target="#b11">[12]</ref>, was shown to enable computations of zk-SNARK proofs for circuits that have hundreds of millions of constraints, which would fit for very large instantiations of our universal circuit. This could scale the number of participants in the application we evaluated by two orders of magnitude. Recursive SNARKs. Another approach to increase the scalability and efficiency of the prover, while also enabling lightweight clients, would be to divide the circuit into different parts, e.g., based on opcodes, prove the correctness of each separately, and then use one layer of recursive SNARKs <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b45">47]</ref> to compress the proofs into one and verify the global consistency. This will have the benefit of reducing the memory requirements of the prover, and also letting the prover only pay for the opcodes that are heavily used by the computation. Cryptographic opcodes. As most zk-SNARK circuits include cryptographic gadgets for verifying knowledge of secrets, or for computing commitments, etc., it could be useful to include opcodes for well-known cryptographic functions. For instance, in the context of HAWK privacy-preserving smart contract system <ref type="bibr" target="#b15">[16]</ref>, most of the manager's circuit does not depend on the computation being verified. If the universal circuit supports additional commitment opcodes, this would significantly reduce the cost of the cryptographic operations required by the protocol, and the universality cost will only include the cost of representing the custom user-defined logic. This would allow increasing the number of participants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">High-level tool for specifying computation</head><p>The library we developed to specify computations is currently a low-level library, which means that the programmer is expected to have knowledge of the opcodes when representing the computation in order to get an optimized performance and develop a secure representation. This is in some sense similar to the background requirements needed when developing zk-SNARK circuits using low-level gadget libraries, e.g, <ref type="bibr">[46]</ref>. We plan to develop a high-level tool that can compile high-level description of the computation to an optimized specification, given the opcodes. Some techniques from existing high-level frameworks <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11]</ref> could be used, however the cost model in our setting is different. Additionally, our modified zk-SNARK construction enables the usage of randomness in the circuit to check permutations and potentially many other types of computations more efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Workload characterization</head><p>In Section 5.2, we used a nearly uniform way to set the number of each opcode provided in the circuit. Although the opcodes we provide can represent most basic operations, their distribution might not always be the most optimal for all possible kinds of applications. A future direction would be to obtain a realistic distribution based on workload characterization of computations in different domains. If the universal circuit targets an application-specific domain like smart contracts, then studying existing smart contracts and analyzing the distributions of the basic operations could provide better insight.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A A zk-SNARK for C univ</head><p>In this section, we describe the zk-SNARK protocol for the simple universal circuit C univ that was presented in Section 4 in detail. Before describing the protocol, we introduce additional notations. Let φ l , φ l , φ z , φ z and φ r be mapping functions that map the variable types and indices in our universal circuit construction to the actual wire indices used in Protocol 2 in Section 3, e.g., φ l (i)gets the index of the wire carrying the value of l i . Define the following sets:</p><formula xml:id="formula_25">• I L = {φ l (i)} i∈{1,..,n s +3n * +3n + } • I L = {φ l (i)} i∈{1,..,n s +3n * +3n + } • I spec = I L ∪ I L (Note:</formula><p>in the general case of our multiopcode universal circuit (Section 5), this will also include the functionality selectors of the instructions).</p><p>• I Z io = {φ z (i)} i∈{1,..,n s }</p><p>• I Z w = {φ z (i)} i∈{n s +1,..,n s +3n * +3n + }</p><p>• I Z = {φ z (i)} i∈{1,..,n s +3n * +3n + }</p><p>• I R = {φ r (i)} i∈{1,2}</p><p>• I aux represents all other intermediate wire indices in the universal circuit, i.e.,</p><formula xml:id="formula_26">I aux = {k : k ∈ {1, .., m} ∧ k / ∈ I L ∪ I L ∪ I Z io ∪ I Z w ∪ I Z ∪ I R },</formula><p>where m is the total number of wires in the universal circuit.</p><p>The public statement of the universal circuit C univ itself includes the specification of the custom circuit, the custom statement, r 1 and r 2 . In other words, the statement of the universal circuit will be the following set of wires (I spec ∪ I Z io ∪ I R ). The set J in Protocol 2 will be equal to I Z w ∪ I Z .</p><formula xml:id="formula_27">Protocol 3 A zk-SNARK for C univ • Universal Circuit Setup: PARAMETERS ← PARAMGEN(C , 1 λ )</formula><p>This phase generates a universal circuit C univ that captures the operations of any circuit C ∈ C . The key generation phase PARAMGEN(C , 1 λ ) will call the setup algorithm in Protocol 2 {vrk C univ , prk C univ } ← Setup(C univ , 1 λ ), while setting J = I Z w ∪ I Z ,I = I aux , i.e., Choose α, β, γ, δ, δ , s ← F q . Construct the public proving key prk C univ as follows:</p><formula xml:id="formula_28">• g α 1 , g β 1 , g δ 1 , g δ 1 , g β 2 , g δ 2 • {g s i 1 } i∈{0,..,d−1} , {g s i 2 } i∈{0,..,d−1} • {g s i t(s)/δ 1 } i∈{0,..,d−2} • {g (βv k (s)+αw k (s)+y k (s))/δ 1 } k∈I Zw ∪I Z • {g (βv k (s)+αw k (s)+y k (s))/δ 1 } k∈I aux</formula><p>Construct the verification key vrk C univ as</p><formula xml:id="formula_29">• g α 1 , g β 1 , g β 2 , g γ 2 , g δ 2 , g δ 2 • {g (βv k (s)+αw k (s)+y k (s))/γ 1 } k∈I spec ∪I Z io ∪I R Set PARAMETERS = {vrk C univ , prk C univ }</formula><p>• Derive (Custom circuit Specification):</p><formula xml:id="formula_30">{VRK C , PRK C } ← DERIVE(C, PARAMETERS)</formula><p>A party sets the values of each l i and l i (besides any functionality selectors in the general case) according to the specification of the custom circuit C. The party then computes vrk C based on the items in vrk C univ . More specifically, vrk C will include the following, , where c k is the value of the wire k in the universal circuit.</p><p>The derivation of vrk C does not need to happen in a trusted manner. It will be straightforward to verify the computation of the first set in linear time. The proving key of the custom circuit C will be the same as the proving key of the universal circuit besides vk spec , i.e., prk C = prk C univ ∪ {vk spec }.</p><p>• Prove π ← PROVE(C, {z i } i∈{1,..,n s +3n * +3n + } , PRK C ):</p><p>-The prover samples three random values κ 1 , κ 2 and κ 3 from F q . κ 1 and κ 2 will be later used as in the original version of the protocol for zero-knowledge, and κ 3 will be used to make our commitment zero-knowledge.</p><p>-The prover commits to the values of {z i } and its permutation {z i }, via computing:</p><p>• cm 1 = ∏ • cm = g δκ 3 1 cm 1 cm 2 -The prover computes the random values r 1 and r 2 using the previous commitment, e.g., r 1 = Hash(0||vk spec ||cm) and r 2 = Hash(1||vk spec ||cm), and continues evaluating the circuit. The prover then computes h(x) = p(x) t(x) , and computes the proof as:</p><p>• π a = g -The verifier then does the following check:</p><formula xml:id="formula_31">e(π a , π b ) = e(g α 1 , g β 2 )e(vk spec .ν.ψ, g γ 2 )e(π c , g δ 2 )e(π d , g δ 2 )</formula><p>Note that e(g α 1 , g β 2 ) can be hardcoded in advance. The total number of pairings done by the verifier for each instance is 4 pairings, and the proof size is 3 elements in G 1 and 1 element in G 2 , i.e. our protocol adds 1 element to the proof and 1 pairing to the verification equation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Multi-opcode Circuit (Supplementary)</head><p>Figures 2 and 3 illustrates the detailed design of the multiopcode circuit presented in Section 5. <ref type="table" target="#tab_5">Table 6</ref> illustrates which basic operations each opcode can be used to verify.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Universal Circuit Detailed Description (2/2)</head><p>OpCode 3 (Split/Pack Operations) (repeated n 3 times, u 3 = 38)</p><p>• Operates on the following (for all i ∈ {n s + ∑ j&lt;3 n j u j + 1, n s + ∑ j&lt;3 n j u j + 39, .., n s + ∑ j≤3 n j u j − 37} ):</p><p>-Element (Bit) vector: e = ((l i , z i ), (l i+1 , z i+1 ), ..., (l i+31 , z i+31 ))</p><p>-Byte vector: ((l i+32 , z i+32 ), (l i+33 , z i+33 ), ..., (l i+35 , z i+35 ))</p><p>-Packed elements: ((l i+36 , z i+36 ), (l i+37 , z i+37 ))</p><p>• Functionality selectors for each instruction (instruction indices omitted for brevity)</p><p>-Force bit assertions: check b -Coefficient vector 1: s 1 = (c 1,1 , c 1,2 , ..., c 1,32 )</p><p>-Coefficient vector 2: s 2 = (c 2,1 , c 2,2 , ..., c 2,32 )</p><p>• Circuit:</p><formula xml:id="formula_32">-Assert z j (1 − z j )check b = 0 for all i ≤ j ≤ i + 31 -Assert z i+36 = e · s 1 , Assert z i+37 = e · s 2</formula><p>-Assert z i+32+ j = ∑ k∈{1+8 j,...,8+8 j} c 1,k .z i+k−1 for all j ∈ {0, 1, 2, 3}</p><p>• Usage notes: Packing or splitting into bits can be done by setting s 1 to contain powers of two, and setting check b = 1. Shifting and rotation (static parameters) can be done by setting s 2 to be a permutation of powers of two.</p><p>• Other modes: This opcode can be used to compute weighted sums of native field elements.</p><p>OpCode 4 (Runtime memory access) (repeated n 4 times, u 4 = 3)</p><p>• Operates on: ((l i , z i ), (l i+1 , z i+1 ), (l i+2 , z i+2 )) for all i ∈ {n s + ∑ j&lt;4 n j u j + 1, n s + ∑ j&lt;4 n j u j + 4, .., n s + ∑ j≤4 n j u j − 2}</p><p>• Circuit:</p><p>-Parse z i , z i+1 , z i+2 as isW rite k , index k , value k , for all k = (i − (n s + ∑ j&lt;4 n j u j + 1))/3 -Add the tuple rec k = (opCounter k = k, isW rite k , index k , value k ) to the memory consistency check circuit</p><p>Memory consistency check circuit</p><p>• The subcircuit operates on the tuples rec k for all k = {0, 1, .., n 4 − 1} defined in OpCode 4.</p><p>• The subcircuit accepts additional witness inputs from the prover rec k = (opCounter k , isW rite k , index k , value k ) for all k = {0, 1, .., n 4 − 1}. (Note that the prover will commit to this input in the first stage before knowing the randomness)</p><p>• Permutation Verification:</p><p>-Compute p 1 = ∏ k (r 2 − (1, r 1 , r 2 1 , r 3 1 ) · rec k ) -Compute p 2 = ∏ k (r 2 − (1, r 1 , r 2 1 , r 3 1 ) · rec k ) -Assert p 1 = p 2</p><p>• Consistency Verification: This applies the memory consistency checks similar to TinyRAM <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Global consistency checks across the universal circuit</head><p>• Permutation Verification:</p><p>-Compute p 1 = ∏ i (r 2 − (z i + l i r 1 )) for all i ∈ {1, 2, .., n s + ∑ j≤4 n j u j } -Compute p 2 = ∏ i (r 2 − (z i + l i r 1 )) for all i ∈ {1, 2, .., n s + ∑ j≤4 n j u j } -Assert p 1 = p 2</p><p>• Consistency Verification:</p><p>-Assert (1 − (l i − l i−1 ))(z i − z i−1 ) = 0 for all i ∈ {2, 3, .., n s + ∑ j≤4 n j u j } (Note since l i are set by the computation specifier, they will be sorted and increasing by steps of 1.) <ref type="figure">Figure 3</ref>: A detailed description of our universal circuit with multiple opcodes (Part 2). See Section 5 and <ref type="table" target="#tab_5">Table 6</ref> for an intuition and high-level description for each opcode circuit design. Note: Functionality selector inputs are added to the spec C vector (Section 4), and set at the computation specification stage.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Addition Labels: í µí± 16 = 1, í µí± 17 = 2, í µí± 18 = 5 í µí± 19 = 7, í µí± 20 = 4, í µí± 21 = 8 í µí± 22 = í µí± 23 = í µí± 24 = 0Addition Values: í µí± § 16 = 5, í µí± § 17 = 4, í µí± § 18 = 9 í µí± § 19 = 180, í µí± § 20 = 2, í µí± § 21 = 182 í µí± § 22 = í µí± § 23 = í µí± § 24 = 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: An example of a simple universal circuit and a specification of a custom circuit. # indicates a variable label. Unused entries are zeroed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>α+v(s)+κ 1 δ 1 • π b = g β+w(s)+κ 2 δ 2 • π c = g h(s)t(s)/δ 1 π κ 2 a B κ 1 1 g −κ 1 κ 2 δ−κ 3 δ 1 X • π d = g δκ 3 1 ∏ k∈I Zw ∪I Z g c k (βv k (s)+αw k (s)+y k (s))/δ 1 where • v(x) = ∑ k∈{0,..,m} c k v k (x) (m is the total number of wires in the circuit). • w(x) = ∑ k∈{0,..,m} c k w k (x) • B 1 = g β+w(s)+κ 2 δ 1 • X = ∏ k∈I aux g c k (βv k (s)+αw k (s)+y k (s))/δ 1 • Verify {0, 1} ← VERIFY({z i } i∈{1,..,n s } , π, VRK C ): -First, the verifier computes the IO component of the commitment: ψ = ∏ k∈I Z io g c k (βv k (s)+αw k (s)+y k (s))/γ 1 . -The verifier computes the commitment: cm = ψ.π d . -The verifier then computes the random values r 1 and r 2 using the previous commitments, i.e., r 1 = Hash(0||vk spec ||cm) and r 2 = Hash(1||vk spec ||cm), and computes ν = ∏ k∈I R g c k (βv k (s)+αw k (s)+y k (s))/γ 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 4 :</head><label>4</label><figDesc></figDesc><table>The cost of representing different primitives using 
the non-universal and our universal approaches in terms of the 
number of constraints. For the universal approach, we report 
the number of constraints used by the consumed instructions 
only for this table to study the exact amplification cost. Tables 
3 and 5 provide end-to-end results involving the upper bounds 
on the universal circuit. 

Application 
xJsnark [11] 
This work 
(non-universal) 
(universal) 
Cost of used 
instructions 

Matrix Mul. (m=10, Native field) 
1000 
26000 (26×) 
Merge Sort (m=64, 16-bit values) 
238835 
558680 (2.33×) 

SHA-256 (unpadded) 
25538 
308842 (12×) 
RSA-2048 ModExp (17-bit Exp.) 
88949 
1446638 (16×) 
AES-128 (Key expansion incl.) 
14240 
214284 (15×) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>). The table reports the setup cost on one machine. In practice, techniques for distributed trusted setup would be used.</head><label></label><figDesc></figDesc><table>System 
Univ. Trusted Setup (once) 
App. 
Trusted setup per app 
Untrusted Key Deriv. 
Proof 
Verify 
Time 
PK 
VK 
Time 
PK 
VK 
Time 
VK+ 3 
Time 
Size 
Time 

HAWK [16] 
N/A 
Auction 
22.78 sec 57.85 MB 3.93 KB 
N/A 
10.3 sec 128 B 1.5 ms 
Crowdfund 22.71 sec 
57.8 MB 
3.93 KB 
10.3 sec 128 B 1.5 ms 

This work 
610 sec 1.8 GB 473 KB 
Auction 
N/A 
7.9 sec 
32 B 
322 sec 
160 B 2.1 ms 
Crowdfund 
7.9 sec 
32 B 
319 sec 
160 B 2.1 ms 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><head>Table 6 : The functionalities corresponding to the opcodes described in Section 5, Figures 2 and 3</head><label>6</label><figDesc></figDesc><table>Opcode 
Supported Operations 

Opcode 1 
-Arithmetic and Boolean Operations: Multiplication (AND), Addition, Subtraction, XOR, OR. 
-Conditionals: Equality/non-equality testing. 

Opcode 2 
-Bitwise operations on 32-bit words (XOR, OR, AND). 
-Verifying constraints on ranges (Useful for comparisons, mod/division operations, etc). 

Opcode 3 
-Bit extraction, Packing bits into one 32-bit values, or bytes. 
-Weighted sums of bits or native elements (This supports bitwise rotation and shifting using static parameters). 

Opcode 4 -Random memory access: Reading from or writing to variable array indices. 

-g α 
1 , g 

β 

1 , g 

β 

2 , g 

γ 

2 , g δ 
2 , g δ 
2 (Copied directly from vrk C univ .) 
-{g 

(βv k (s)+αw k (s)+y k (s))/γ 

1 

} k∈I Z io ∪I R (Copied directly from 
vrk C univ .) 

-vk spec = ∏ 

k∈I spec 

g 

c k (βv k (s)+αw k (s)+y k (s))/γ 

1 

</table></figure>

			<note place="foot" n="1"> Our separated zk-SNARK can be proven secure in the algebraic group model (AGM), following the techniques of [45].</note>

			<note place="foot" n="2"> We could also show that L univ ∈ MA by showing that L univ ∈ N P via a quasi-linear deterministic verification procedure.</note>

			<note place="foot" n="3"> Refers to the additional part of verification key added per computation. Note that this can be verified by any party.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported in part by DARPA under grant N66001-15-C-4066 and the Center for Long-Term Cybersecurity (CLTC). Charalampos Papamanthou was supported by NSF awards #1514261 and #1652259 as well as by NIST. Dimitrios Papadopoulos was supported by Hong Kong RGC under grant ECS-26208318. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of NSF, NIST, DARPA, CLTC or Hong Kong RGC.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Quadratic span programs and succinct nizks without pcps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology-EUROCRYPT 2013</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="626" to="645" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Pinocchio: Nearly practical verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">S &amp; P</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Snarks for C: verifying program executions succinctly and in zero knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Virza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Succinct noninteractive zero knowledge for a von neumann architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Virza</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<pubPlace>USENIX Security</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Geppetto: Versatile verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Costello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kreuter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zahur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">S&amp;P</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Scalable zero knowledge via cycles of elliptic curves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Virza</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<publisher>CRYPTO</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On the size of pairing-based non-interactive arguments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT 2016</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="305" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Snarky signatures: Minimal signatures of knowledge from simulation-extractable snarks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Maller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Cryptology Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="581" to="612" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Verifying computations with state</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the TwentyFourth ACM Symposium on Operating Systems Principles</title>
		<meeting>the TwentyFourth ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="341" to="357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient RAM and control flow in verifiable outsourced computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Wahby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T V</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">xJsnark: a framework for efficient verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="944" to="961" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">DIZK: A distributed zero knowledge proof system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th USENIX Security Symposium (USENIX Security 18</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="675" to="692" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Pinocchio Coin: building Zerocoin from a succinct pairing-based proof system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Danezis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<editor>PETShop</editor>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Zerocash: Decentralized anonymous payments from bitcoin</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Garman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Miers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Virza</surname></persName>
		</author>
		<editor>S &amp; P</editor>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Cinderella: Turning shabby x.509 certificates into elegant anonymous credentials with the magic of verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Delignat-Lavaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<editor>S&amp; P</editor>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Hawk: The blockchain model of cryptography and privacy-preserving smart contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">The ring of gyges: Using smart contracts for crime</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Photoproof: Cryptographic image authentication for any set of permissible transformations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Naveh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 IEEE Symposium on Security and Privacy (SP)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="255" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Secure sampling of public parameters for succinct zero knowledge proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Virza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="287" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Scalable multi-party computation for zk-snark parameters in the random beacon model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bowe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gabizon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Miers</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Ligero: Lightweight sublinear arguments without a trusted setup</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ames</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hazay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Venkitasubramaniam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="2087" to="2104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Bulletproofs: Short proofs for confidential transactions and more</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bünz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bootle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Poelstra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Wuille</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Maxwell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE Symposium on Security and Privacy (SP)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="315" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A zero-knowledge version of vsql</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="volume">2017</biblScope>
			<biblScope unit="page">1146</biblScope>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Doublyefficient zksnarks without trusted setup</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Wahby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Tzialla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shelat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Thaler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE Symposium on Security and Privacy (SP)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="926" to="943" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Scalable, transparent, and post-quantum secure computational integrity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Bentov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Horesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Riabzev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Aurora: Transparent succinct arguments for r1cs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Riabzev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Spooner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Virza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">P</forename><surname>Ward</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2018/828" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Libra: Succinct zero-knowledge proofs with optimal prover computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2019/317" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Transparent polynomial delegation and its applications to zero knowledge proof</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2019/1482" />
	</analytic>
	<monogr>
		<title level="j">SSP</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Updatable and universal common reference strings with applications to zk-snarks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Maller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Meiklejohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Miers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Cryptology Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="698" to="728" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Legosnark: Modular design and composition of succinct zero-knowledge proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Campanelli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fiore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Querol</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2019/142" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Sonic: Zeroknowledge snarks from linear-size universal and updateable structured reference strings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Maller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bowe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Meiklejohn</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Sub-linear lattice-based zero-knowledge arguments for arithmetic circuits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Baum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bootle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cerulli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Lyubashevsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Cryptology Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="669" to="699" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Efficient zeroknowledge arguments for arithmetic circuits in the discrete log setting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bootle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cerulli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Chaidos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Petit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Conference on the Theory and Applications of Cryptographic Techniques</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="327" to="357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Interactive oracle proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Spooner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="31" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">The knowledge complexity of interactive proof systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="186" to="208" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Delegating computation: interactive proofs for muggles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">N</forename><surname>Rothblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">27</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Practical verified computation with streaming interactive proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Thaler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Innovations in Theoretical Computer Science Conference</title>
		<meeting>the 3rd Innovations in Theoretical Computer Science Conference</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="90" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Time-optimal interactive proofs for circuit evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Thaler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Cryptology Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="71" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Marlin: Preprocessing zksnarks with universal and updatable srs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Maller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Vesely</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Ward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="1047" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gabizon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">J</forename><surname>Williamson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Ciobotaru</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Bitcoin: A peer-to-peer electronic cash system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Nakamoto</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Ethereum: A secure decentralized transaction ledger</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wood</surname></persName>
		</author>
		<ptr target="http://gavwood.com/paper.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Primality testing with gaussian periods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">W</forename><surname>Lenstra</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd Conference Kanpur on Foundations of Software Technology and Theoretical Computer Science</title>
		<meeting>the 22nd Conference Kanpur on Foundations of Software Technology and Theoretical Computer Science</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Probabilistic algorithm for testing primality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Number Theory</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="128" to="138" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">The algebraic group model and its applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Fuchsbauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kiltz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Loss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2018</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Zexe: Enabling decentralized private computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bowe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Miers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wu</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2018/962" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
	<note>Universal Circuit Detailed Description (1/2</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Number of times each opcode j appears in the circuit, 1 ≤ j ≤ 4. • {u j }: Number of entries used by each opcode j, 1 ≤ j ≤ 4. Circuit input • Statement entries: (l i , z i ) for all i ∈ {1, 2, . . . , n s }. • Operation entries: (l i , z i ) for all i ∈ {n s + 1, n s + 2</title>
	</analytic>
	<monogr>
		<title level="m">Setup Parameters • n s : Number of entries (l i , z i ) representing the public statement. • {n j }</title>
		<imprint/>
	</monogr>
	<note>n s + ∑ j≤4 n j u j }. • Permuted entries: (l i , z i ) for all i ∈ {1, 2, ..., n s + ∑ j≤4 n j u j }</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">(l i+2 , z i+2 )) for all i ∈ {n s + 1, n s + 4</title>
	</analytic>
	<monogr>
		<title level="m">• Operates on: ((l i , z i ), (l i+1 , z i+1 )</title>
		<imprint/>
	</monogr>
	<note>n s + n 1 u 1 − 2}</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">where c j ∈ F q for all j -Operation bit selectors: {op eq , op 1 , op 2 , usePrev} • Circuit: -Compute t 1 = (c 1 + c 2 z i )(c 3 + c 4 z i+1 ) + c 5 -Compute t 2 = (c 1 + c 2 z i ) + (c 3 + c 4 z i+1</title>
	</analytic>
	<monogr>
		<title level="m">• Functionality selectors for each instruction (instruction indices omitted for brevity) : -Coefficient vector</title>
		<imprint/>
	</monogr>
	<note>c 5 -Compute t 3 = (z i == ? z i+1 ), t 4 = 1 − t 3</note>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">The coefficient set can be chosen to support various operations, e.g., for multiplication, op 1 = c 2 = c 4 = 1, the rest are zeros; for xor (assuming that z i are bits)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">•</forename><surname>Usage</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>op 1 = c 2 = c 3 = 1, c 4 = −2, c 1 = −2 −1 , c 5 = 2 −1 , the rest are zeros</note>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">OpCode 2 (Bitwise Operations</title>
		<imprint/>
	</monogr>
	<note>repeated n 2 times, u 2 = 3</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">(l i+2 , z i+2 )) for all i ∈ {n s + ∑ j&lt;2 n j u j + 1, n s + ∑ j&lt;2 n j u j + 4</title>
	</analytic>
	<monogr>
		<title level="m">• Operates on: ((l i , z i ), (l i+1 , z i+1 )</title>
		<imprint/>
	</monogr>
	<note>n s + ∑ j≤2 n j u j − 2}</note>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">• Functionality selectors for each instruction (instruction indices omitted for brevity) -Operation selectors: op a vector of 12 bits. (Only one of them will be active during run time</title>
		<imprint/>
	</monogr>
	<note>See Section 5.2)</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Compute b = b 1 b 2 ( refers to the Hadamard product) -(AND-bitwise cases) Compute a 1 = pack32(b), a 2 = pack32(b 2 − b), a 3 = pack32(b 1 − b), a 4 = pack32(1 − b 1 − b 2 + b) -(XOR-bitwise cases) Compute x 1 = pack32(b 1 + b 2 − 2b), x 2 = pack32(1 − b 1 − b 2 + 2b), x 3 = x 2 , x 4 = x 1 -(OR-bitwise cases) Compute o 1 = pack32(b 1 + b 2 − b), o 2 = pack32(1 − b 1 + b), o 2 = pack32(1 − b 2 + b), o 4 = pack32(1 − b) -Assert z i+2 = op</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">•</forename><surname>Circuit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Extract bit vectors b 1 , b 2 from z i and z i+1 (assuming 32 is the bit length</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">• Other modes: This opcode also behaves similar to opcode 1 supporting native operations when needed</title>
		<imprint/>
	</monogr>
	<note>details omitted</note>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Figure 2: A detailed description of our universal circuit with multiple opcodes (Part 1). See Section 5 and Table 6 for an intuition and high-level description for each opcode circuit design. Note: Functionality selector inputs are added to the spec C vector (Section 4), and set at the computation specification stage</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
