<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:53+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Recommendations for Randomness in the Operating System or, How to Keep Evil Children out of Your Pool and Other Random Facts</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><surname>Corrigan-Gibbs</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Suman</forename><surname>Jana</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Recommendations for Randomness in the Operating System or, How to Keep Evil Children out of Your Pool and Other Random Facts</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Common misconceptions about randomness underlie the design and implementation of randomness sources in popular operating systems. We debunk these fallacies with a survey of the &quot;realities of randomness&quot; and derive a number of new architectural principles for OS random-ness subsystems.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Randomness is at the heart of the security of a modern operating system: cryptographic keys, TLS nonces, ASLR offsets, password salts, TCP sequence numbers, and DNS source port numbers all rely on a source of hardto-predict random bits. Unfortunately, misuse and abuse of random numbers and random number generators has led to a jaw-dropping number of bugs and security holes of late <ref type="bibr">[9-32, 44, 55]</ref>.</p><p>The blame for many such failures lies not with application developers, but with the faulty designs and error-prone interfaces for randomness common in popular OSes. The documentation of OS randomness sources is often misleading or incorrect and serves to spread myths about randomness (e.g., that a well-seeded randomness pool can "run out" of random bits), rather than dispel them. In addition, the special-file interface to the OS randomness subsystem (i.e., /dev/random) makes it difficult, if not impossible, for applications to safely use randomness under adversarial conditions. Given the state of randomness sources in popular OSes, it is no surprise that developers often misunderstand and misuse randomness.</p><p>In the first part of this paper, we identify and debunk a number of common misconceptions about OS randomness. Along the way, we point out weaknesses in and attacks against the randomness sources of existing OSes. In the second part, we outline a new architecture for OS randomness that solves many of the problems with existing designs. In sum, we attempt to "set the record straight" on randomness for designers of future OSes, with the hope that new systems will take a more principled view towards this important but counter-intuitive piece of the OS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We first define a few key terms and concepts.</p><p>Entropy. For our purposes, entropy is a measure of an adversary's uncertainty about the state of a particular value. To make this notion precise, let S be a discrete random variable representing, for example, the state of a cryptographic random number generator. Let G(S | A's knowledge) be a random variable representing the number of guesses required to recover the value of S given an adversary A's knowledge of the distribution of S, following an optimal strategy <ref type="bibr" target="#b47">[48]</ref>. We say that the distribution of the state S has k bits of guessing entropy ("entropy") with respect to an adversary A if the expected number of guesses E[ G(S | A's knowledge) ] is greater than or equal to 2 k [7, Section 3.2.4]. A value S sampled uniformly at random from a set of 2 k values has just over k − 1 bits of guessing entropy, since E[G(S)] is equal to (2 k + 1)/2. 1 When we say that a particular value "has k bits of entropy," we mean that the value is sampled from a distribution with k bits of entropy from the perspective of some adversary.</p><p>Pseudo-random Bit Generator. A pseudo-random bit generator (PRG) is a family of deterministic algorithms mapping short bitstrings ("seeds") to long bitstrings ("outputs") <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b48">49]</ref>. To be useful in a cryptographic setting, the output of a PRG must be indistinguishable from random, as long as the seed is sampled from a distribution over the seed space with "enough" entropy. <ref type="bibr" target="#b1">2</ref> One suitable PRG is the AES block cipher instantiated in counter mode <ref type="bibr" target="#b2">[3]</ref>. The seed for the PRG is the AES key k and the output of the PRG is the concatenation of the AES encryptions of the bitstrings representing "0," "1," "2," and so on. As long as the seed for this PRG is sampled from a distribution with many bits of entropy (e.g., 128 bits) it appears infeasible to distinguish the output of this PRG from random.</p><p>OS Randomness Subsystem. All modern operating systems implement some sort of randomness pool. The pool contains a bitstring derived from other values in the system that are ostensibly difficult for user-level processes to guess. These values typically include the CPU's cycle counter, disk seek times, outputs from a hardware randomness source (e.g., Intel's RdRand instruction), network packet arrival times, and other fast-changing values known to the operating system. The operating system periodically updates this pool with fresh values.</p><p>In Unix-like operating systems, user processes interact with the randomness subsystem through a special file named /dev/random. <ref type="bibr" target="#b2">3</ref> The CryptGenRandom function serves a similar purpose in recent versions of Windows. When we say that a process reads random bytes from the OS, we mean that it requests bytes from /dev/random or CryptGenRandom. Applications and kernel threads use randomness to generate cryptographic secrets, run randomized algorithms, and derive unpredictable values for other purposes (e.g., DNS source port numbers).</p><p>All common flavors of Unix also allow user-space processes to write random bytes to the OS by writing to /dev/random, which mixes the user-provided bits into the OS randomness pool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Realities of Randomness</head><p>We review a number of realities of randomness, which inform the randomness architecture introduced in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Your Randomness Won't Run Out</head><p>A common misconception is that randomness in the entropy pool can somehow be "used up"-that the OS must constantly add new hard-to-predict bits to the pool for its output to remain unpredictable. For example, a post on the CloudFlare Security Blog about the Linux randomness pool states:</p><p>When random numbers are generated from the pool the entropy of the pool is diminished (because the person receiving the random number has some information about the pool itself). <ref type="bibr" target="#b52">[53]</ref> This statement is false as long as widespread cryptographic assumptions hold. Once there is enough randomness in the pool to seed a pseudo-random generator, the OS can produce an endless string of random-looking bits. <ref type="bibr" target="#b3">4</ref> Deriving an endless stream of bits from a randomenough randomness pool is straightforward: use a cryptographic hash function (e.g., SHA-256) to hash the pool's contents into the space of PRG seeds (e.g., AES keys). Then, use the PRG (e.g., AES in counter mode) to expand the short seed into a long bitstring. Application of the random-oracle model <ref type="bibr" target="#b3">[4]</ref> allows a rigorous analysis of the security of this extract-then-expand technique <ref type="bibr" target="#b44">[45]</ref>. This procedure leads to the following finding: <ref type="figure">Figure 1</ref>: Under unfavorable conditions, the system will never accumulate enough entropy to generate strong cryptographic keys (using the 128-bit security level).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reality 1.</head><p>Once the randomness pool has accumulated enough entropy to seed a PRG, the pool can never "run out" of random bits (if the pool implementation is sane).</p><p>As we note, Reality 1 is only true as long as the randomness pool uses a "sane" implementation. The extractthan-expand technique outlined above is an example of a "sane" implementation <ref type="bibr" target="#b44">[45]</ref>. An example of an "insane" implementation is any one that returns bits of the randomness pool state to a user-space processes without running it through a hash function and cryptographic PRG. Implementations like these may reveal the entire state of the randomness pool to an adversarial user-space process and can thus "run out" of entropy. Corollary. The only time that the randomness pool is vulnerable to compromise is in the period before it has accumulated enough entropy to seed a PRG.</p><p>Before the randomness pool has enough entropy to seed a PRG, an adversary who can read random bytes from OS can learn the internal state of the OS's randomness pool. To mount this attack, the adversary first reads a random bitstring b from the OS, and guesses the state of the randomness pool that would have produced the string b. The average number of guesses required is bounded above by 2 k , where k is the number of bits of entropy in the randomness pool. <ref type="figure">Figure 1</ref> graphically depicts this process: the pool starts out with zero bits of entropy (e.g., after the machine's first boot) and the OS harvests 32 bits of entropy from hardware sources in every time unit. If a malicious process can read several bytes from /dev/random at every time unit and brute-force through the 2 32 possible pool states, the malicious process can always recover the state of the randomness pool and the system will never accumulate enough entropy to seed a PRG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Entropy Estimation is Hopeless</head><p>A tempting way to address the problem depicted in <ref type="figure">Fig- ure 1</ref> is to just disallow reads from the OS randomness source until the pool accumulates enough entropy to seed a PRG (e.g., 128 bits). Several operating systemsincluding Linux, NetBSD, and Solaris-try to estimate how many bits of entropy are in the randomness pool and will block /dev/random until there is enough entropy to prevent the attack of <ref type="figure">Figure 1</ref>. Unfortunately, this strategy is misguided.</p><p>Reality 2. Building an accurate entropy estimator is infeasible.</p><p>To see why entropy estimation is infeasible, recall the definition of entropy: it is a measure of the adversary's uncertainty about the value of a certain variable. The OS generally has no way of knowing what the adversary knows about the system and thus has no hope of estimating how many bits of entropy are in the randomness pool <ref type="bibr" target="#b0">[1]</ref>. (Of course, in the degenerate case in which no string has ever been added to the pool, it is clear that there are zero bits of entropy in the pool.)</p><p>For example, OS designers might reason that the loworder bit of the arrival time of every network packet is a good source of randomness. An entropy estimator might then increase the entropy count by one bit upon receipt of every packet. If an adversary can monitor the machine's network connection, however, the packet arrival times would be a poor source of randomness with respect to this adversary. Real-world entropy estimators have similar weaknesses [33, <ref type="bibr">Lemma 3]</ref>.</p><p>Since the OS cannot ever accurately estimate how many bits are in the pool, and since the OS should only block reads to the randomness source when there are "too few" bits of entropy in the randomness pool, we conclude:</p><p>Corollary. Reads to the OS randomness source should never block.</p><p>After booting, the OS should initialize the randomness subsystem with values from I/O sources as best it can and then make /dev/random available to user-space processes. If the system's design is sound, the OS's randomness pools will eventually accumulate entropy, even if they were not well-seeded initially. FreeBSD and Mac OS use this strategy to avoid entropy estimation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">All Bits Should Be Treated Equally</head><p>The widespread use of entropy estimation techniques has given rise to the misconception that the OS should differentiate between "trusted" and "untrusted" inputs to the randomness pool. In Linux, for example, only kernel threads and administrators can write to the randomness pools in a way that increases the entropy estimate.</p><p>The intuition behind this design is clear: internal entropy sources, like the cycle counter and disk seek times, are considered "more random" than user-provided bitstrings, which might be adversarially crafted. However, there is no need to make such a distinction, since adding data to the randomness pool should never decrease the amount of entropy in the pool: Reality 3. Adding bits to the randomness pool will never decrease the amount of entropy in the pool, as long as the implementation is sane.</p><p>For an example of a "sane" implementation: let the state of the randomness pool be an -bit string and let E k (m) be an ideal cipher that encrypts a message m with a key k, such that m and k are both -bit strings <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b51">52]</ref>. We can calculate the new state s i+1 of the pool by hashing the (possibly long) input string into a short cipher key k and computing s i+1 ← E k (s i ) <ref type="bibr" target="#b44">[45]</ref>. Since E defines a family of permutations (indexed by k), the adversary's uncertainty about the value of s i+1 is at least as large as the adversary's uncertainty about the value of s i , no matter whether the input string is adversarially chosen. Corollary. The OS should allow any user and any process to contribute to the randomness pool.</p><p>Adding bits to the randomness pool can only increase the adversary's uncertainty about the pool contents, so it can never hurt to allow writes into the pool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">User-Space is a Danger Zone</head><p>Cryptographic folklore, as well as the OpenBSD and Linux randomness manpages, suggests that applications needing many random bytes should maintain their own user-space randomness pools. Many popular cryptography libraries (including OpenSSL) follow this advice and implement their own user-space pools and PRGs. Reality 4. User-space randomness pools are often unsafe.</p><p>Maintaining a randomness pool in user-space entails a number of risks:</p><p>Fork (un)safety. The implementation must be sure to reseed the child of a fork() call with fresh randomness to make sure that the child's pool differs from its parent's. Neglecting to reseed after forking is easy to do and can lead to dangerous security vulnerabilities <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b30">31]</ref>.</p><p>Pool leakage. It is more difficult to maintain the privacy of the randomness pool state in user-space than it is in kernel-space. Chow et al. <ref type="bibr" target="#b7">[8]</ref> showed that user-space secrets can leak through swap and other unexpected sources.</p><p>Reseeding required. If the user-space randomness pool seeds itself from /dev/random soon after boot, the OS's pool may not yet have enough entropy to provide a strong seed. Even if the amount of entropy in the kernel pool eventually increases, the amount of entropy in the user-space pool will not increase unless the userspace implementation periodically reseeds itself from /dev/random. Many libraries, including OpenSSL, do not reseed themselves automatically.</p><p>There are legitimate reasons for maintaining a userspace randomness pool: it avoids the system-call overhead of reading a special file and it allows an application  to use a different PRG than the one the kernel supports. Even so, the risks of maintaining a user-space pool are much greater than the benefits in many cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Use a System Call, Not a Special File</head><p>Most OSes limit the number of open file descriptors, so if either the per-user or global file descriptor limit is reached, no process can access system randomness via /dev/random. In this case, applications have to choose between two bad alternatives: (a) fail and halt, or (b) proceed without randomness from the OS.</p><p>An attack. Most applications we have inspected choose option (b) above, which opens them up to a file descriptor denial-of-service attack: a coalition of malicious users opens enough files to exceed the system's global file descriptor limit. When an honest user subsequently tries to generate a cryptographic secret key, the cryptography library may produce a non-random (and thus vulnerable) key <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b27">28]</ref>. Many components of OpenSSL, including SSL/TLS pre-master secret generation and RSA key generation, are vulnerable to this attack, as is the arc4random function used for cryptographic randomness in FreeBSD, OpenBSD, and Mac OS. Reality 5. Special-file interfaces for randomness are often unsafe.</p><p>The special-file interface for randomness allows malicious processes to starve honest processes of randomness under certain circumstances. To prevent these attacks, OSes should provide a system-call interface to the OS randomness subsystem and security-critical applications running on OSes without a system-call interface should "fail closed" when they cannot read /dev/random. The latest versions of Windows, Linux, and OpenBSD offer a system call for randomness, but FreeBSD, Mac OS X, and Solaris do not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Improving OS Randomness</head><p>Our proposed architecture for OS randomness uses perprocess randomness pools to ensure entropy accumulation, even under adversarial conditions. The design does not require entropy estimation and eliminates the distinction between "trusted" and "untrusted" inputs to the pools.</p><p>The corollary to Reality 1 indicates that the system's randomness pool is vulnerable only in the time before the pool has accumulated enough entropy to seed a PRG. The focus of the randomness subsystem, then, is to ensure that eventually there is enough entropy in the pool to seed a PRG, even in the presence of many adversarial processes.</p><p>To our knowledge, no current OS provides this property. Existing OSes use a single common entropy pool shared amongst all processes, as shown in <ref type="figure" target="#fig_1">Figure 2</ref>. If the system starts out in a known state (e.g., after first boot), the hardware supplies only a few bits of entropy per time unit, and an adversarial process can read a few bits of OSsupplied randomness in every time unit, then the adversary will always know the contents of the entropy pool via a brute-force guessing attack <ref type="figure">(Figure 1</ref>) <ref type="bibr" target="#b31">[32]</ref><ref type="bibr" target="#b32">[33]</ref><ref type="bibr" target="#b33">[34]</ref>. In these conditions, benign processes will not ever be able to generate strong cryptographic secrets.</p><p>To prevent this failure case, our design allocates separate entropy pools to each process in the system. By limiting the number of pools from which an adversarial process can read, we minimize the number of pools that an adversary can attack. This ensures that benign processes eventually accumulate enough entropy to generate strong cryptographic keys (though, by Reality 2 we will never know precisely when this has happened).</p><p>In our architecture <ref type="figure">(Figure 3)</ref>, the OS maintains two randomness pools for each process in the system: one for generating random values for the process itself and another for initializing the pools of forked child processes. When a process asks the OS for random bits, the OS derives these bits from the first pool, the "self" pool. When a process forks a child process, the OS initializes the child's two randomness pools using bits derived from the parent's "fork" pool. The OS feeds new input bits into all active pools in the system on a round-robin schedule. Under the minimal assumption that the random input bits are not perfectly correlated with each other, all non-adversarial pools in the system will eventually accumulate enough entropy to seed a PRG.</p><p>The use of two separate pools per process provides protection in scenarios in which the pool of a parent process contains few bits of entropy and an adversary can repeatedly read from the randomness pools of the parent's recently forked child processes. For example, if the parent is an (honest) forking TLS server, an adversarial client can learn the state of the parent's randomness pool by connecting to a forked child server process and inspecting the nonces in the child process' TLS messages. If the parent's pool started out with few bits of entropy, the adversary will be able to learn the state of the parent's pool and will keep the parent's pool from ever accumulating entropy.</p><p>(a) Children of fork()s have pools seeded from the parent's fork pool.</p><p>(b) The OS replenishes all pools in the system in a roundrobin fashion.</p><p>(c) An evil child might initially be able to learn the state of other pools.</p><p>(d) However, the parent's other children can eventually accumulate entropy (recover).</p><p>Figure 3: A system using our pool-per-process design can accumulate entropy in the presence of a malicious process.</p><p>By having a separate forking pool, we ensure that the child processes cannot read from the parent's "self" pool and thus the child cannot recover the state of the parent's "self" pool. This allows the parent's "self" pool to eventually accumulate entropy with respect to the adversarial client, even though the parent's "fork" pool never will.</p><p>Instead of having a separate "fork" pool, we could just initialize the child's randomness pools to all zeros and let the child's pool accumulate entropy over time from input sources. This addresses the forking attack above, but introduces a more serious problem: a child will not have any access to randomness immediately after forking, even if the parent's pool has many bits of entropy. In the case of a forking TLS server, in which a child needs to generate cryptographic secrets immediately after forking, zeroinitializing the child's pool is unsatisfactory.</p><p>The downside of having separate randomness pools is that the system as a whole will accumulate entropy more slowly than today's systems do-2P times more slowly, where P is the number of active processes.</p><p>To increase the rate of accumulation, the system could have a single global randomness pool in addition to the per-process pools described above. The OS would insert half of the input bits into the global pool and the other half into the hierarchy of per-process pools. When a process requests random bits, the OS would derive these bits from both the process' "self" pool and from the global pool. In the absence of a malicious process, the system would accumulate entropy almost as quickly as it would with today's designs. In the presence of many malicious processes, the honest processes' pools would be still able to accumulate entropy eventually (albeit at a slower rate). There are many possible combinations of global, local, and intermediate pools, but we leave a full investigation of these ideas to future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related Work</head><p>There is a long and fruitful line of work investigating randomness failures in Debian <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b54">55]</ref>, Java <ref type="bibr" target="#b39">[40]</ref>, Linux <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b40">41]</ref>, Netscape <ref type="bibr" target="#b37">[38]</ref>, Windows <ref type="bibr" target="#b34">[35]</ref>. Weak hardware entropy sources <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b46">47]</ref> and use of virtual machine snapshotting <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b50">51]</ref> have also led to randomness failures in the past. Lazar et al. investigate the source of bugs in cryptographic software, including cases involving misuse of randomness <ref type="bibr" target="#b45">[46]</ref>.</p><p>Another line of work has proposed techniques to protect against weak randomness. Barak and Halevi <ref type="bibr" target="#b0">[1]</ref> and Dodis et al. <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref> rigorously analyze random number generators as used in operating systems and offer improved constructions. Mowery et al. conjecture that even embedded devices have potentially rich sources of entropy at boot time <ref type="bibr" target="#b49">[50]</ref>. Hedged public-key cryptography, developed by Bellare et al. <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b50">51]</ref>, allow for a graceful degradation of security in the face of bad randomness.</p><p>Many of the arguments of Section 3 are in the folklore and some have been discussed in prior work <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b53">54]</ref>. To our knowledge, no one has proposed using per-process randomness pools as we do in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We have debunked a number of common misconceptions about randomness in the OS. From the counter-intuitive realities of randomness, we derive a number of straightforward design principles for the OS's randomness subsystem. We also make the unorthodox recommendation that OSes maintain two separate randomness pools for every process. We hope that our paper will encourage OS designers to question common myths about randomness and to rethink how they provide randomness to users.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Today's OS randomness subsystems.</figDesc></figure>

			<note place="foot" n="1"> The guessing entropy of this distribution is not equal to its Shannon entropy or min entropy [7, Section 3.4]. 2 To be precise, the seed must be sampled from a distribution with k bits of entropy such that k has size polynomial in the security parameter.</note>

			<note place="foot" n="3"> In Linux and Solaris, /dev/random can block, so there is also a similar, but non-blocking, file called /dev/urandom. 4 Well, &quot;endless&quot; at least from the perspective of all polynomial-time adversaries.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Dan Boneh encouraged us to gather our random thoughts into this paper and offered comments on an early draft. Bryan Ford, David Terei, Tal Garfinkel, and the anonymous reviewers gave useful tips on how to improve the presentation. Bryan also suggested the idea, discussed in Section 4, of using a combination of global and perprocess randomness pools. An NDSEG Fellowship and the National Science Foundation funded this work in part.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A model and architecture for pseudo-random generation with applications to /dev/random</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boaz</forename><surname>Barak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shai</forename><surname>Halevi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="203" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Hedged public-key encryption: How to protect against bad randomness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zvika</forename><surname>Brakerski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moni</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gil</forename><surname>Segev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Yilek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="232" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A concrete security treatment of symmetric encryption</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anand</forename><surname>Desai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eron</forename><surname>Jokipii</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phillip</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Foundations of Computer Science</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="394" to="403" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Random oracles are practical: A paradigm for designing efficient protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phillip</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="62" to="73" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The ideal-cipher model, revisited: An uninstantiable blockcipher-based hash function</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Black</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fast Software Encryption</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="328" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A simple pnpredictable pseudo-random number generator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lenore</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Shub</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="364" to="383" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Entropy Measures and Unconditional Security in Cryptography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Cachin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<pubPlace>ETH Zürich</pubPlace>
		</imprint>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Shredding your garbage: Reducing data lifetime through secure deallocation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tal</forename><surname>Garfinkel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mendel</forename><surname>Rosenblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="22" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">ORBit and esound in Red Hat Linux do not use sufficiently random numbers</title>
		<idno>CVE-2000-0357</idno>
		<imprint>
			<date type="published" when="1999" />
			<publisher>December</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
				<idno>CVE-2001-0950</idno>
		<title level="m">ValiCert Enterprise Validation Authority uses insufficiently random data</title>
		<imprint>
			<date type="published" when="2001-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">CVE-2001-1141: PRNG in SSLeay and OpenSSL could be used by attackers to predict future pseudorandom numbers</title>
		<imprint>
			<date type="published" when="2001-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">mkpasswd, as used by Red Hat Linux, seeds its random number generator with its process ID</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cve-</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1467-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cve-</forename></persName>
		</author>
		<title level="m">WinZip uses weak random number generation for password protected ZIP files</title>
		<imprint>
			<publisher>December</publisher>
			<date type="published" when="1376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">CVE-2005-3087: SecureW2 TLS implementation uses weak random number generators during generation of the pre-master secret</title>
		<imprint>
			<date type="published" when="2005-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cve-</forename></persName>
		</author>
		<title level="m">PasswordSafe uses a weak random number generator</title>
		<imprint>
			<date type="published" when="1378-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<title level="m">CVE-2006-1833: Intel RNG Driver in NetBSD may always generate the same random number</title>
		<imprint>
			<date type="published" when="2006-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Random number feature in Linux kernel does not properly seed pools when there is no entropy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cve-</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">WebPortal CMS generates predictable passwords containing only the time of day</title>
		<idno>CVE-2008-0141</idno>
		<imprint>
			<date type="published" when="2008-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">OpenSSL on Debian-based operating systems uses a random number generator that generates predictable numbers</title>
		<idno>CVE-2008-0166</idno>
		<imprint>
			<date type="published" when="2008-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">GENERATE SEED macro in php produces 24 bits of entropy and simplifies brute force attacks against the rand and mt rand functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cve-</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">The arc4random function in FreeBSD does not have a proper entropy source for a short time period immediately after boot</title>
		<idno>CVE-2008-5162</idno>
		<imprint>
			<date type="published" when="2008-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">CVE-2009-0255: TYPO3 creates the encryption key with an insufficiently random seed</title>
		<imprint>
			<date type="published" when="2009-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
				<idno>CVE-2009-3238</idno>
		<title level="m">Linux kernel produces insufficiently random numbers</title>
		<imprint>
			<date type="published" when="2009-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">CVE-2009-3278: QNAP uses rand library function to generate a certain recovery key</title>
		<imprint>
			<date type="published" when="2009-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
				<title level="m">CVE-2011-3599: Crypt::DSA for Perl, when /dev/random is absent, uses the data::random module</title>
		<imprint>
			<date type="published" when="2011-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">The crypto.random.atfork function in PyCrypto before 2.6.1 does not properly reseed the pseudo-random number generator (PRNG) before allowing a child process to access it</title>
		<imprint>
			<date type="published" when="2013-10" />
			<biblScope unit="page" from="2013" to="1445" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Password generator (aka Pwgen) before 2.07 uses weak pseudo generated numbers when /dev/urandom is unavailable</title>
		<idno>CVE-2013-4442</idno>
		<imprint>
			<date type="published" when="2013-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
				<title level="m">CVE-2013-5180: The srandomdev function in Libc in Apple Mac OS X before 10.9, when the kernel random-number generator is unavailable, produces predictable values instead of the intended random values</title>
		<imprint>
			<date type="published" when="2013-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Android before 4.4 does not properly arrange for seeding of the OpenSSL PRNG</title>
		<idno>CVE-2013-7373</idno>
		<imprint>
			<date type="published" when="2013-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">when using fork threading, does not properly update the state of the OpenSSL pseudo-random number generator</title>
		<idno>CVE-2014-0016: tunnel before 5.00</idno>
		<imprint>
			<date type="published" when="2014-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">The rand bytes function in libssh before 0.6.3, when forking is enabled, does not properly reset the state of the OpenSSL pseudorandom number generator</title>
		<idno>CVE-2014-0017</idno>
		<imprint>
			<date type="published" when="2014-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
				<idno>CVE-2014-4422</idno>
		<title level="m">The kernel in Apple iOS before 8 and Apple TV before 7 uses a predictable random number generator during the early portion of the boot process</title>
		<imprint>
			<date type="published" when="2014-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Security analysis of pseudo-random number generators with input: /dev/random is not robust</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yevgeniy</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Pointcheval</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sylvain</forename><surname>Ruhault</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Damien</forename><surname>Vergniaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="647" to="658" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">How to eat your entropy and have it too-optimal recovery strategies for compromised rngs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yevgeniy</forename><surname>Dodis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adi</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noah</forename><surname>Stephensdavidowitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Wichs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Cryptanalysis of the Windows random number generator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leo</forename><surname>Dorrendorf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zvi</forename><surname>Gutterman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benny</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="476" to="485" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Not-sorandom numbers in virtualized Linux and the Whirlwind RNG</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Everspaugh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yan</forename><surname>Zhai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Jellinek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Security and Privacy</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">When virtual is harder than real: Security challenges in virtual machine based computing environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tal</forename><surname>Garfinkel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mendel</forename><surname>Rosenblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotOS</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Randomness and the Netscape browser. Dr. Dobb&apos;s Journal-Software Tools for the Professional Programmer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ian</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Wagner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="66" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Random number generation. Cryptographic Security Architecture: Design and Verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Gutmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="215" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Hold your sessions: An attack on Java session-id generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zvi</forename><surname>Gutterman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dahlia</forename><surname>Malkhi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="44" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">and Tzachy Reinman. Analysis of the Linux random number generator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zvi</forename><surname>Gutterman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benny</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Security and Privacy</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="371" to="385" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Mining your Ps and Qs: Detection of widespread weak keys in network devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadia</forename><surname>Heninger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zakir</forename><surname>Durumeric</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Wustrow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Alex</forename><surname>Halderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="205" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Myths about /dev</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Hühn</surname></persName>
		</author>
		<ptr target="http://www.2uo.de/myths-about-urandom/" />
		<imprint>
			<date type="published" when="2014-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Some SecureRandom thoughts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Klyubin</surname></persName>
		</author>
		<ptr target="http://android-developers.blogspot.com/2013/08/some-securerandom-thoughts.html" />
		<imprint>
			<date type="published" when="2013-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Cryptographic extraction and key derivation: The HKDF scheme</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugo</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="631" to="648" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Why does cryptographic software fail?: A case study and open problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Lazar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haogang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nickolai</forename><surname>Zeldovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">APSys</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Arjen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">P</forename><surname>Lenstra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maxime</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Augier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Joppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thorsten</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christophe</forename><surname>Kleinjung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wachter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Whit is right. IACR ePrint archive</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>Ron was wrong</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Guessing and entropy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">L</forename><surname>Massey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Information Theory</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page">204</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Handbook of Applied Cryptography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><forename type="middle">J</forename><surname>Menezes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><forename type="middle">C</forename><surname>Van Oorschot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><forename type="middle">A</forename><surname>Vanstone</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<publisher>CRC press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Welcome to the Entropics: Boot-time entropy in embedded devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keaton</forename><surname>Mowery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kohlbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Swanson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Security and Privacy</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">When good randomness goes bad: Virtual machine reset vulnerabilities and hedging deployed cryptography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Yilek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Communication theory of secrecy systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claude</forename><forename type="middle">E</forename><surname>Shannon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell System Technical Journal</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="656" to="715" />
			<date type="published" when="1949" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">Ensuring randomness with Linux&apos;s random number generator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Sullivan</surname></persName>
		</author>
		<ptr target="http://blog.cloudflare.com/ensuring-randomness-with-linuxs-random-number-generator/" />
		<imprint>
			<date type="published" when="2014-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Practical random number generation in software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Viega</surname></persName>
		</author>
		<editor>ACSAC. IEEE</editor>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">When private keys are public: Results from the 2008 Debian OpenSSL vulnerability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Yilek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Rescorla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brandon</forename><surname>Enright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Savage</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IMC</title>
		<imprint>
			<date type="published" when="2009-11" />
			<biblScope unit="page" from="15" to="27" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
