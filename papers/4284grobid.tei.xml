<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:09+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. Fuzzing Error Handling Code using Context-Sensitive Software Fault Injection Fuzzing Error Handling Code using Context-Sensitive Software Fault Injection</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zu-Ming</forename><surname>Jiang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jia-Ju</forename><surname>Bai</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zu-Ming</forename><surname>Jiang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jia-Ju</forename><surname>Bai</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kangjie</forename><surname>Lu</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shi-Min</forename><surname>Hu</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Kangjie Lu</orgName>
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">University of Minnesota</orgName>
								<address>
									<addrLine>Shi-Min Hu</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
								<orgName type="institution" key="instit3">University of Minnesota</orgName>
								<orgName type="institution" key="instit4">Tsinghua University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. Fuzzing Error Handling Code using Context-Sensitive Software Fault Injection Fuzzing Error Handling Code using Context-Sensitive Software Fault Injection</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the 978-1-939133-17-5</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Error handling code is often critical but difficult to test in reality. As a result, many hard-to-find bugs exist in error handling code and may cause serious security problems once triggered. Fuzzing has become a widely used technique for finding software bugs nowadays. Fuzzing approaches mutate and/or generate various inputs to cover infrequently-executed code. However, existing fuzzing approaches are very limited in testing error handling code, because some of this code can be only triggered by occasional errors (such as insufficient memory and network-connection failures), but not specific inputs. Therefore, existing fuzzing approaches in general cannot effectively test such error handling code. In this paper, we propose a new fuzzing framework named FIFUZZ, to effectively test error handling code and detect bugs. The core of FIFUZZ is a context-sensitive software fault injection (SFI) approach, which can effectively cover error handling code in different calling contexts to find deep bugs hidden in error handling code with complicated contexts. We have implemented FIFUZZ and evaluated it on 9 widely-used C programs. It reports 317 alerts which are caused by 50 unique bugs in terms of the root causes. 32 of these bugs have been confirmed by related developers. We also compare FIFUZZ to existing fuzzing tools (including AFL, AFLFast, AFLSmart and FairFuzz), and find that FIFUZZ finds many bugs missed by these tools. We believe that FIFUZZ can effectively augment existing fuzzing approaches to find many real bugs that have been otherwise missed.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A program may encounter various errors and needs to handle these errors at runtime. Otherwise, the program may suffer from security or reliability issues. While error handing is critical, itself is error-prone. Firstly, error handling code is difficult to correctly implement <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b19">23,</ref><ref type="bibr" target="#b30">34,</ref><ref type="bibr" target="#b50">54]</ref> because it often involves special and complicated semantics. Secondly, error handling code is also challenging to test <ref type="bibr" target="#b21">[25,</ref><ref type="bibr" target="#b24">28,</ref><ref type="bibr" target="#b49">53,</ref><ref type="bibr" target="#b57">61]</ref>, because such code is infrequently executed and often receives insufficient attention. For these reasons, many bugs may exist in error handling code, and they are often difficult to find in real execution. Some recent works <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b28">32,</ref><ref type="bibr" target="#b33">37,</ref><ref type="bibr" target="#b64">68]</ref> have shown that many bugs in error handling code can cause serious security problems, such as denial of service (DoS) and information disclosure. In fact, many CVE-assigned vulnerabilities (such as CVE-2019-7846 <ref type="bibr">[19]</ref>, CVE-2019-2240 <ref type="bibr">[20]</ref>, CVE-2019-1750 <ref type="bibr">[21]</ref> and CVE-2019-1785 <ref type="bibr">[22]</ref>) stem from bugs in error handling code.</p><p>Considering that error handling code is critical but buggy, various tools have been proposed to detect bugs in error handling code. Some approaches <ref type="bibr" target="#b24">[28,</ref><ref type="bibr" target="#b28">32,</ref><ref type="bibr" target="#b29">33,</ref><ref type="bibr" target="#b33">37,</ref><ref type="bibr" target="#b49">53]</ref> use static analysis, but they often introduce many false positives, due to the lack of runtime information and inherent limitations with static analysis. To reduce false positives, recent approaches <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b22">26,</ref><ref type="bibr" target="#b23">27,</ref><ref type="bibr" target="#b25">29,</ref><ref type="bibr" target="#b26">30,</ref><ref type="bibr" target="#b35">38,</ref><ref type="bibr" target="#b42">45,</ref><ref type="bibr" target="#b46">50,</ref><ref type="bibr" target="#b46">50,</ref><ref type="bibr" target="#b47">51,</ref><ref type="bibr" target="#b55">59,</ref><ref type="bibr" target="#b56">60,</ref><ref type="bibr" target="#b60">64,</ref><ref type="bibr" target="#b61">65]</ref> instead use fuzzing to test infrequently executed code. They generate effective program inputs to cover infrequently executed code, according to the input specification or the feedback of program execution. However, the input-driven fuzzing cannot effectively cover error handling code, as some of this code can be only triggered by non-input occasional errors, such as insufficient memory and network-connection failures. As a result, existing fuzzing approaches cannot effectively test error handling code.</p><p>Testing error handing code is challenging by nature, as errors are often hard to deterministically produce. An intuitive solution to triggering error handling code is to use software fault injection (SFI) <ref type="bibr" target="#b48">[52]</ref>. SFI intentionally injects faults or errors into the code of the tested program, and then executes the program to test whether it can correctly handle the injected faults or errors at runtime. Specifically, the faults are injected into the sites that can fail and trigger error handling code, and we call each such site an error site. In this way, SFI can intentionally cover error handling code at runtime. Existing SFI-based approaches <ref type="bibr">[9-11, 18, 25, 39, 40, 55, 67]</ref> have shown encouraging results in testing error handling code and detecting hard-to-find bugs.</p><p>However, existing SFI-based approaches suffer from a critical limitation: to our knowledge, they perform only contextinsensitive fault injection, which often stops testing from going deep. Specifically, they inject faults according to the locations of error sites in source code, without considering the execution contexts of these error sites, i.e., the execution paths reaching to the error sites. Thus, if a fault is constantly injected into an error site, this error site will always fail when being executed at runtime. However, an error site is typically executed in different calling contexts, and real bugs can be only triggered when this error site fails in a specific calling context but succeeds in other calling contexts. In this case, existing SFI-based approaches may miss these real bugs. <ref type="figure" target="#fig_0">Figure 1</ref> shows a simple example of this case. In the function main, the objects x and y are allocated, and then the functions FuncA and FuncB are called. FuncA and FuncB both call FuncP, but FuncB frees the argument object before calling FuncP. In FuncP, the object z is allocated by calling malloc; if this function call fails, the argument object is freed, and the program exits abnormally by calling exit. If we perform context-insensitive fault injection by just statically injecting a fault into malloc in FuncP, the program will always exit when FuncA is executed, without finding any bug. If we consider calling context, and inject a fault into malloc in FuncP only when FuncB calls FuncP, a double-free bug of the object y can be triggered at runtime. Since such a case is fairly common, it may incur a significant impact on detecting bugs in error handling code. In this paper, to effectively detect bugs in error handling code, we design a novel context-sensitive SFI-based fuzzing approach. The approach takes execution contexts into account to effectively guide SFI to maximize bug finding. It consists of six steps: 1) statically identifying the error sites in the source code of the tested program; 2) running the tested program and collecting runtime information about calling contexts of each executed error site and code coverage; 3) creating error sequences about executed error sites according to runtime information, and each element of such a sequence is differentiated by the location of the executed error site and the information about its calling context; 4) after running the program, mutating each created error sequence to generate new sequences; 5) running the tested program and injecting faults according to the mutated error sequences; 6) collecting runtime information, creating new error sequences and performing mutation of these error sequences again, which constructs a fuzzing loop.</p><p>Based on our approach, we propose a new fuzzing framework named FIFUZZ. At compile time, to reduce manual work of identifying error sites, FIFUZZ performs a static analysis of the source code of tested programs, to identify possible error sites. The user can select realistic error sites that can actually fail and trigger error handling code. Then, FIFUZZ uses our context-sensitive SFI-based fuzzing approach in runtime testing. To be compatible with traditional fuzzing process for program inputs, FIFUZZ mutates the error sequences and program inputs together by analyzing runtime information of the tested program.</p><p>Overall, we make the following technical contributions:</p><p>• We perform two studies of error handling code in widelyused applications and vulnerabilities found by existing fuzzing tools, and find that: nearly 42% of sites that can trigger error handling code are related to occasional errors, but only few vulnerabilities found by existing fuzzing tools are related to error handling code triggered by occasional errors. Thus, it is important to improve fuzzing to support the testing of error handling code.</p><p>• We propose a novel context-sensitive SFI-based fuzzing approach, which can dynamically inject faults based on both locations of error sites and their calling contexts, to cover hard-to-trigger error handling code.</p><p>• Based on this approach, we develop a new fuzzing framework named FIFUZZ, to effectively test error handling code. To our knowledge, FIFUZZ is the first systematic fuzzing framework that can test error handling code in different calling contexts.</p><p>• We evaluate FIFUZZ on 9 well-tested and widely-used C applications of the latest versions as of our evaluation. It reports 317 alerts which are caused by 50 unique bugs in terms of the root causes. 32 of these bugs have been confirmed by related developers. We also compare FIFUZZ to existing fuzzing tools (including AFL, AFLFast, AFLSmart and FairFuzz) on 5 common programs in the Binutils toolset, and find that FIFUZZ finds many bugs missed by these tools.</p><p>The rest of this paper is organized as follows. Section 2 introduces background and our two studies. Section 3 introduces basic idea and our context-sensitive SFI-based fuzzing approach. Section 4 introduces FIFUZZ in detail. Section 5 shows our evaluation. Section 6 makes a discussion about FIFUZZ and its found bugs. Section 7 presents related work, and Section 8 concludes this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>In this section, we first introduce error handling code with related bug examples, and then show our studies of error handling code in widely-used applications and CVEs found by existing fuzzing tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Error Handling Code</head><p>A program may encounter exceptional situations at runtime, due to special execution conditions such as invalid inputs from users, insufficient memory and network-connection failures. We refer to such exceptional situations as errors, and the code used to handle an error is called error handling code.</p><p>In fact, errors can be classified into two categories: inputrelated errors and occasional errors. An input-related error is caused by invalid inputs, such as abnormal commands and bad data. Such an error can be triggered by providing specific inputs. An occasional error is caused by an exceptional event that occasionally occurs, such as insufficient memory or network-connection failure. Such an error is related to the state of execution environment and system resources (such as memory and network connection), but unrelated to inputs, so it typically cannot be triggered by existing fuzzing that focuses on inputs. While this error occurs occasionally, they can be reliably triggered in an adversarial setting. For example, by exhaustively consuming memory, an attacker can reliably result a function call to malloc() in returning a null pointer. As such, bugs in error handing code can be as critical as the ones in normal code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Bug Examples in Error Handling Code</head><p>Figures 2 and 3 show two patches fixing bugs in error handling code of the libav library in ffmpeg <ref type="bibr" target="#b20">[24]</ref>. In <ref type="figure">Figure 2</ref>, the variable sbr-&gt;sample_rate could be zero, but it is divided in the code, causing a divide-by-zero bug. This bug is also reported as CVE-2016-7499 <ref type="bibr">[48]</ref>. To fix this bug, Patch A [46] checks whether sbr-&gt;sample_rate is zero before this variable is divided, and returns abnormally if so. The report of this bug <ref type="bibr" target="#b44">[47]</ref> mentions that this bug was found by AFL. On the other hand, in <ref type="figure">Figure 3</ref>, the function av_frame_new_side_data is used to allocate memory for new data, and it can fail and return a null pointer when memory is insufficient. In this case, the variable dst-&gt;side_data[i]-&gt;metadata is freed after dst-&gt;side_data <ref type="bibr">[i]</ref> is freed, which causes a use-after-free bug. To fix this bug, PatchB <ref type="bibr" target="#b45">[49]</ref> frees the variable dst-&gt;side_data[i]-&gt;metadata before freeing dst-&gt;side_data <ref type="bibr">[i]</ref>. Because the report of this bug or the patch does not mention any tool, the bug might be found by manual inspection or real execution.</p><p>The bug in <ref type="figure">Figure 2</ref> is caused by missing handling of an input-related error, because the variable sbr-&gt;sample_rate is related to the function argument sbr affected by inputs. The bug in <ref type="figure">Figure 3</ref> is instead caused by incorrect handling of an occasional error, because av_frame_new_side_data fails only when memory is insufficient, which occasionally occurs at runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Study of Error Handling Code</head><p>To understand the proportion of input-related errors and occasional errors that can trigger error handling code in software, we perform a manual study of the source files (.c and .h) of 9 widely-used applications <ref type="bibr">(vim, bison, ffmpeg, nasm, catdoc, clamav, cflow, gif2png+libpng, and openssl)</ref>. Due to time constraints, if an application contains over 100 source files, we randomly select 100 source files of this application to study. Otherwise, we study all the source files of this application. Specifically, we first manually identify the sites that can fail and trigger error handling code by looking for if or goto statements, which are often used as entries of error handling code in C applications <ref type="bibr" target="#b29">[33]</ref>. Then, we manually check whether the identified sites are related to input-related errors or occasional errors. <ref type="table">Table 1</ref> shows the study results.</p><p>We find that 42% of the sites that can fail and trigger error handling code are related to occasional errors. Besides, in the study, we also observe that about 70% of the identified error sites are related to checking error-indicating return values of function calls (such as the example in <ref type="figure">Figure 3</ref>). This observation indicates that manipulating the return values of specific function calls can cover most error handling code, which has been adopted by some existing SFI-based approaches <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b18">18]</ref>. <ref type="table" target="#tab_1">Studied file  Error site  Input-related  Occasional  vim  100  1163  530 (46%)  633 (54%)  bison  100  184  96 (52%)  88 (48%)  ffmpeg  100  881</ref>   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Application</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Study of CVEs Found by Existing Fuzzing</head><p>To understand how existing fuzzing tools perform in detecting bugs in error handling code, we further study the CVEs found by some start-of-the-art fuzzing tools, including AFL <ref type="bibr" target="#b0">[1]</ref>, Honggfuzz <ref type="bibr" target="#b26">[30]</ref>, AFLFast <ref type="bibr" target="#b12">[13]</ref>, CollAFL <ref type="bibr" target="#b22">[26]</ref>, QSYM <ref type="bibr" target="#b61">[65]</ref> and REDQUEEN <ref type="bibr" target="#b6">[7]</ref>. We select these fuzzing tools because CVEs found by them are publicly available. Specifically, for AFL, a website <ref type="bibr" target="#b1">[2]</ref> collects its found CVEs; for Honggfuzz, the found CVEs are listed in its homepage; for AFLFast, CollAFL, QSYM and REDQUEEN, the found CVEs are listed in their papers as well. We manually read these CVEs and identify the ones related to error handling code, and also check whether the identified CVEs are related to occasional errors. <ref type="table" target="#tab_1">Table 2</ref> shows the study results. We find that 31% of CVEs found by these fuzzing tools are caused by incorrect error handling code, such as the bug shown in <ref type="figure">Figure 2</ref>. Only 9% of these CVEs are related to occasional errors. This proportion is far less than the proportion (42%) of occasional error sites among all error sites (found in Section 2.3). The results indicate that existing fuzzing tools may have missed many real bugs in error handling code triggered by occasional errors. Thus, it is important to improve fuzzing to support the testing of error handling code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Basic Idea and Approach</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Basic Idea</head><p>To effectively test error handling code, we introduce SFI in fuzz testing by "fuzzing" injected faults according to the runtime information of the tested program. To achieve this idea, we build an error sequence that contains multiple error points. An error point represents an execution point where an error can occur and trigger error handling code. When performing fault injection, each error point in an error sequence can normally run (indicated as 0) or fail by injecting a fault (indicated as 1). Thus, an error sequence is actually as 0-1 sequence that describes the failure situation of error points at runtime:</p><formula xml:id="formula_0">ErrSeq = [ErrPt 1 , ErrPt 2 , ..., ErrPt x ], ErrPt i = {0, 1} (1)</formula><p>Similar to program inputs, an error sequence also affects program execution. This sequence can be regarded as the "input" of possibly triggered errors. A key problem here is which error points in an error sequence should be injected with faults to cover as much error handling code as possible. Inspired by existing fuzzing that fuzz program inputs using the feedback of program execution, our basic idea is to fuzz error sequence for fault injection to test error handling code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Error Sequence Model</head><p>Existing SFI-based approaches often use context-insensitive fault injection. Specifically, they only use the location of each error site in source code to describe an error point, namely ErrPt = &lt;ErrLoc&gt;, without considering the execution context of this error site. In this way, if an fault is injected into an error site, this error site will always fail when being executed at runtime. However, an error site can be executed in different calling contexts, and some real bugs (such as the double-free bug shown in <ref type="figure" target="#fig_0">Figure 1</ref>) can be triggered only when this error site only fails in specific calling context and succeeds in other calling contexts. Thus, existing SFI-based approaches may miss these real bugs.</p><p>To solve this problem, we propose a context-sensitive software fault injection (SFI) method. Besides the location of each error site, our method also considers the calling context of the error site to describe error points, namely:</p><formula xml:id="formula_1">ErrPt =&lt; ErrLoc,CallCtx &gt;<label>(2)</label></formula><p>To describe calling context of an error site, we consider the runtime call stack when the error site is executed. This runtime call stack includes the information of each function call at the call stack (in order from caller to callee), including the locations of this function call and called function. In this way, a calling context is described as:</p><formula xml:id="formula_2">CallCtx = [CallIn f o 1 ,CallIn f o 2 , ...,CallIn f o x ] (3) CallIn f o =&lt; CallLoc, FuncLoc &gt;<label>(4)</label></formula><p>Based on the above description, the information about each error point can be hashed as a key, and whether this error point should fail can be represented as a 0-1 value. Thus, an error sequence can be stored as a key-value pair in a hash Note that the runtime call stack of an executed error site is related to program execution. Thus, error points cannot be statically determined, and they should be dynamically identified during program execution. Accordingly, when performing fault injection using error sequences, the faults should be injected into error points during program execution.</p><p>According to our method, when an error site is executed in N different calling contexts, there will be N different error points for fault injection, instead of just one error point identified by context-insensitive fault injection. Thus, our method can perform finer-grained fault injection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Context-Sensitive SFI-based Fuzzing</head><p>To effectively cover as much error handling code as possible, based on our context-sensitive SFI method, we propose a novel context-sensitive SFI-based fuzzing approach to perform fault injection using the feedback of program execution.</p><p>As shown in <ref type="figure">Figure 4</ref>, our approach has six steps: 1) statically identifying the error sites in the source code of the tested program; 2) running the tested program and collecting runtime information about calling contexts of each executed error site and code coverage; 3) creating error sequences about executed error sites according to runtime information; 4) after running the program, mutating each created error sequence to generate new sequences; 5) running the tested program and injecting faults into error sites in specific calling contexts according to the mutated error sequences; 6) collecting runtime information, creating new error sequences and performing mutation of these error sequences again, which constructs a fuzzing loop. When no new error sequences are generated or the time limit is reached, the fuzzing loop ends. In our approach, mutating and generating error sequences are important operations. Given a program input, our approach considers code coverage in these operations and drops repeated error sequences. Initially such information is unavailable, and thus our approach performs a special initial mutation for the first execution of the tested program. For subsequent executions, it performs the subsequent generation and mutation of error sequences. All the generated error sequences that increase code coverage are stored in a pool, and they are ranked by contribution to code coverage. Our approach preferentially selects error sequences for mutation.</p><p>Initial mutation.</p><p>Our approach first executes the tested program normally, and creates an initial error sequence according to runtime information. This error sequence contains executed error points, and it is all-zero and used for the initial mutation. The mutation generates each new error sequence by making just one executed error point fail (0→1), as each error point may trigger uncovered error handling code in related calling context. <ref type="figure" target="#fig_3">Figure 5</ref> shows an example of the initial mutation for an error sequence, which generates four new error sequences. Subsequent generation and mutation. After executing the tested program by injecting faults according to an original error sequence, some new error points may be executed, making a new error sequence created. Our approach checks whether the code coverage is increased (namely new basic blocks or code branches are covered) during this execution. If not, the original error sequence and the created error sequence (if it exists) are dropped; if so, our approach separately mutates the original error sequence and the created error sequence (if it exists) to generate each new error sequence by changing the value of just one error point (0→1 or 1→0). Then, our approach compares these generated error sequences with existing error sequences, to drop repeated ones. <ref type="figure" target="#fig_4">Figure 6</ref> shows an example of this procedure for two error sequences, For the first error sequence ErrSeq 1 , a new error point ErrPt x is executed, and thus our approach creates an error sequence containing ErrPt x . As the code coverage is increased, our approach mutates the two error sequences and generates nine new error sequences. However, one of them is the same with existing error sequence ErrSeq 2 , thus this new error sequence is dropped. For the second error sequence ErrSeq 2 , a new error point ErrPt y is executed, and thus our approach creates an error sequence containing ErrPt y . As the code coverage is not increased, our approach drops the two error sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initial error sequence</head><p>Note that each error point in an error sequence is related to runtime calling context, thus when injecting faults into this error point during program execution, our approach needs to dynamically check whether the current runtime calling context and error sites match the target error point. If this error point is not executed during program execution, our approach will ignore this error point.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association 29th USENIX Security Symposium 2599</head><p>Original error sequence </p><note type="other">Mutation Generated error sequences ErrPta 1 ErrPtb 1 ErrPtc 0 ErrPtd 0 ErrPta 0 ErrPtb 1 ErrPtc 0 ErrPtd 0 ErrPta 1 ErrPtb 0 ErrPtc 0 ErrPtd 0 ErrPta 1 ErrPtb 1 ErrPtc 1 ErrPtd 0 ErrPta 1 ErrPtb 1 ErrPtc 0 ErrPtd</note></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">FIFUZZ Framework</head><p>Based on our context-sensitive SFI-based fuzzing approach, we design a new fuzzing framework named FIFUZZ, to effectively test error handling code. We have implemented FIFUZZ using Clang <ref type="bibr" target="#b16">[16]</ref>. • Error-site extractor. It performs an automated static analysis of the source code of the tested program, to idenfity possible error sites.</p><p>• Program generator. It performs code instrumention on the program code, including identified error sites, function calls, function entries and exits, code branches, etc. It generates an executable tested program.</p><p>• Runtime monitor. It runs the tested program with generated inputs, collects runtime information of the tested program, and performs fault injection according to generated error sequences.</p><p>• Error-sequence generator. It creates error sequences, and mutates error sequences to generate new error sequences, according to collected runtime information.</p><p>• Input generator. It performs traditional fuzzing process to mutate and generate new inputs, according to collected runtime information.</p><p>• Bug checkers. They check the collected runtime information to detect bugs and generate bug reports.</p><p>Based on the above architecture, FIFUZZ consists of two phases, which are introduced as follows. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Compile-Time Analysis</head><p>In this phase, FIFUZZ performs two main tasks:</p><p>Error-site extraction. For SFI-based approaches, the injected errors should be realistic. Otherwise, the found bugs might be false positives. To ensure that injected errors are realistic, many SFI-based approaches <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b37">40,</ref><ref type="bibr" target="#b51">55]</ref> require the user to manually provide error sites, which requires much manual work and cannot scale to large programs. To reduce manual work, the error-site extractor uses a static analysis against the source code of the tested program, to identify possible error sites, from which the user can select realistic ones.</p><p>Our analysis focuses on extracting specific function calls as error sites, because our study in Section 2.3 reveals that most of error sites are related to checking error-indicating return values of function calls. Our analysis has three steps: S1: Identifying candidate error sites. In many cases, a function call returns a null pointer or negative integer to indicate a failure. Thus, our analysis identifies a function call as a candidate error site if: 1) it returns a pointer or integer; and 2) the return value is checked by an if statement with NULL or zero. The function call to av_frame_new_side_data in <ref type="figure">Figure 3</ref> is an example that satisfies the two requirements.</p><p>S2: Selecting library functions. A called function can be defined in the tested program or an external library. In most cases, a function defined in the tested program can fail, as it calls specific library functions that can fail. If this function and its called library functions are both considered for fault injection, repeated faults may be injected. To avoid repetition, from all the identified function calls, our analysis only selects those whose called functions are library functions.</p><p>S3: Performing statistical analysis. In some cases, a function can actually fail and trigger error handling, but the return values of several calls to this function are not checked by if statements. To handle such cases, our analysis use a statistical method to extract functions that can fail from the identified function calls, and we refer to such a function as an error function. At first, this method classifies the selected function calls by called function, and collects all function calls to each called function in the tested program code. Then, for the function calls to a given function, this method calculates the percent of them whose return values are checked by if statements. If this percent is larger than a threshold R, this method identifies this function as an error function. Finally, this method extracts all function calls to this function are identified error sites. For accuracy and generality, if there are multiple tested programs, this method analyzes the source code of all the tested programs together.</p><p>In our analysis, the value of the threshold R in the third step heavily affects the identified error functions and identified error sites (function calls). For example, less error functions and error sites can be identified, as R becomes larger. In this case, more unrealistic error functions and error sites can be dropped, but more realistic ones may be also missed. We study the impact of the value of R in Section 5.2. Code instrumentation. The code instrumentation serves for two purposes: collecting runtime information about error sites and injecting faults. To collect the information about runtime calling context of each error site, the program generator instruments code before and after each function call to each function defined in the tested program code, and at the entry and exit in each function definition. Besides, on the other hand, to monitor the execution of error sites and perform fault injection into them, the program generator instruments code before each error site. During program execution, the runtime calling context of this error site and its location are collected to create an error point. Then, if this error point can be found in the current error sequence, and its value is 1 (indicating this error point should fail for fault injection) a fault is injected into the error point. In this case, the function call of related error site is not executed, and its return values is assigned to a null pointer or a random negative integer. If the value of this error point in the error sequence is 0, the function call of related error site is normally executed. <ref type="figure" target="#fig_7">Figure 8</ref> shows an example of instrumented code in the C code. Note that code instrumentation is actually performed on the LLVM bytecode.  <ref type="table">Table 3</ref>: Basic information of the tested applications.</p><formula xml:id="formula_3">int *FuncA() { int *p; p = FuncB(); (*p)++; return p; } int *FuncB() { int *q; q = malloc(...); if (!q) { return NULL; } *q = 100; return q; } int *FuncA() { + FuncEntry(FuncA); int *p; + CallEntry(FuncB); p = FuncB(); + CallExit(FuncB); (*p)++; + FuncExit(FuncA); return p; } int *FuncB() { + FuncEntry(FuncB); int *q; + ErrorPointCollect(...); + if (ErrorPointFail(...) ==</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Runtime Fuzzing</head><p>In this phase, with the identified error sites and instrumented code, FIFUZZ performs our context-sensitive SFI-based fuzzing approach, and uses traditional fuzzing process of program inputs referring to AFL <ref type="bibr" target="#b0">[1]</ref>.</p><p>The runtime fuzzer executes the tested program using the program inputs generated by traditional fuzzing process, and injects faults into the program using the error sequences generated by our SFI-based fuzzing approach. It also collects runtime information about executed error points, code branches, etc. According to the collected runtime information, the errorsequence generator creates error sequences and performs mutation to generate new error sequences; the input generator performs coverage-guided mutation to generate new inputs. Then, FIFUZZ combines these generated error sequences and inputs together, and use them in runtime fuzzer to execute the tested program again. To detect bugs, the bug checkers analyze the collected runtime information. These bug checkers can be third-party sanitizers, such as ASan <ref type="bibr" target="#b3">[4]</ref> and MSan <ref type="bibr" target="#b38">[41]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Setup</head><p>To validate the effectiveness of FIFUZZ, we evaluate it on 9 extensively-tested and widely-used C applications of the latest versions as of our evaluation. These applications are used for different purposes, such as text editor (vim), media processing (ffmpeg), virus scan (clamav) and so on. The information of these applications are listed in <ref type="table">Table 3</ref> (the lines of source code are counted by CLOC <ref type="bibr" target="#b17">[17]</ref>). The experiment runs on a regular desktop with eight Intel i7-3770@3.40G processors and 16GB physical memory. The used compiler is Clang 6.0 <ref type="bibr" target="#b16">[16]</ref>, and the operating system is Ubuntu 18.04.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Error-Site Extraction</head><p>Before testing programs, FIFUZZ first performs a static analysis of their source code to first identify error functions that can fail, and then to identify error sites. We set R = 0.6 in this analysis, and perform the third step of this analysis for the source code of all the tested programs. After FIFUZZ produces identified error sites, we manually select realistic  <ref type="table">Table 4</ref>: Results of error-site extraction.</p><p>ones that can actually fail and trigger error handling code, by reading related source code. <ref type="table">Table 4</ref> shows the results. The first column presents the application name; the second column presents the number of all function calls in the application; the third column presents the number of error sites identified by FIFUZZ; the last column presents the number of realistic error sites that we manually select. In total, FIFUZZ identifies 287 error functions, and identifies 9,795 function calls to these error functions as possible error sites. Among them, we manually select 150 error functions as realistic ones, and 1,822 function calls to these error functions that are considered as realistic error sites are automatically extracted from the source code. Thus, the accuracy rates of FIFUZZ for identifying realistic error functions and error sites are 52.3% and 18.6%. The manual confirmation is easily manageable and not hard. The user only needs to scan the definition of each error function, to check whether it can trigger an error by returning an error number or a null pointer. One master student spent only 2 hours on the manual selection of error functions for the 9 tested applications. Considering there are over 600K function calls in the tested programs, FI-FUZZ is able to drop 99% of them, as they are considered not to be fail and trigger error handling code according to their contexts in source code. We find that many of the selected error functions and error sites are related to memory allocation that can indeed fail at runtime, and nearly half of the selected error functions and error sites are related to occasional errors. The results show that FIFUZZ can dramatically help reduce the manual work of identifying realistic error sites. As described in Section 4.1, the value of R = 0.6 in the static analysis heavily affects the identified error functions. The above results are obtained with R = 0.6. To understand the variation caused by R, we test R from 0.5 to 1 with 0.05 step. <ref type="figure" target="#fig_8">Figure 9</ref> shows the results. We find that the number of identified error functions and realistic error functions are both decreased when R becomes larger. In this case, more unrealistic error functions are dropped, but more realistic ones are also missed. Thus, if R is too small, many unrealistic error functions will be identified, which may introduce many false positives in bug detection; if R is too large, many realistic error functions will be missed, which may introduce many false negatives in bug detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Runtime Testing</head><p>Using the 1,822 realistic error sites identified with R = 0.6, we test the 9 target applications. We fuzz each application with a well-know sanitizer ASan <ref type="bibr" target="#b3">[4]</ref> and then without ASan (because it often introduces much runtime overhead), for three times. The time limit of each fuzzing is 24 hours. For the alerts found by fault injection, we count them by trigger location and error point (not error site). <ref type="table" target="#tab_6">Table 5</ref> shows the fuzzing results with ASan and without ASan. The columns "Error sequence" and "Input" show the results about generated error sequences and inputs; in these columns, the columns "Gen" show the number of generated ones, and the columns "Useful" show the number of ones that increase code coverage. From the results, we find that:</p><p>Error sequence. FIFUZZ generates many useful error sequences for fault injection to cover error handling code. In total, 3% and 2% of generated error sequences increase code coverage by covering new code branches, with and without ASan, respectively. These proportions are larger than those (0.02% with ASan and 0.007% without ASan) for generated program inputs. To know about the variation of useful error sequences and program inputs increasing code coverage, we select vim as an example to study. <ref type="figure" target="#fig_0">Figure 10</ref> shows the results. We find that the number of useful error sequences increases quickly during earlier tests, and then tends to be stable in the later tests. This trend is quite similar to program inputs.   <ref type="table" target="#tab_1">Error sequence  Input  Reported alert  Error sequence  Input  Reported alert  Gen  Useful  Gen  Useful  Null  MemErr  Assert  All  Gen  Useful  Gen  Useful  Null  MemErr  Assert  All  vim  9,199  772  504,736  338  27  5  0  32  44,322  1,664  2,355,965  451  55  3  0  58  bison  1,450  221  1,995,831  1,168  11  0  0  11  8,692  289  14,602,760  1,207  11  0  0  11  ffmpeg  591  311  139,543  758  13  13  3  29  3,060  516  4,817,284  1,766  14  18  3  35  nasm  5,316  65  2,571,</ref>   Reported alerts. With ASan, FIFUZZ reports 255 alerts, including 126 null-pointer dereferences, 126 memory errors (such as use-after-free and buffer-overflow alerts) and 3 assertion failures. Among these alerts, 114 are reported by ASan, and 82 are found due to causing crashes. Without ASan, FIFUZZ reports 298 alerts, including 178 null-pointer dereferences, 117 memory errors and 3 assertion failures. All these alerts are found due to causing crashes. Indeed, ASan can find memory errors that do not cause crashes. Thus, with ASan, FIFUZZ finds more memory errors. However, due to monitoring memory accesses, ASan often introduces over 2x runtime overhead <ref type="bibr" target="#b4">[5]</ref>. Thus, with ASan, FIFUZZ executes less test cases within given time and some null-pointer dereferences causing crashes are missed.</p><p>Alert summary. In <ref type="table" target="#tab_7">Table 6</ref>, we summarize the alerts found by FIFUZZ with and without ASan, and identify 317 unique alerts, including 182 null-pointer dereferences, 132 memory errors and 3 assertion failures. 313 of them are related to incorrect error handling caused by occasional errors, and only 4 alerts are caused by program inputs. Section Appendix shows 50 randomly-selected alerts.</p><p>Found bugs. In <ref type="table" target="#tab_7">Table 6</ref>, we check the root causes of the 317 reported alerts, and identify 50 new and unique bugs in terms of their root causes. Specifically, 313 alerts are related to incorrect error handling, which are caused by 46 bugs. The remaining 4 alerts are caused by four bugs that are not in error handling code. We have reported all these bugs to related developers. 32 of them have been confirmed, and we are still waiting for the response of remaining ones.</p><p>Error handling bugs. The 46 found bugs related to incorrect error handling are caused by only 18 error sites but in different calling contexts. Most of the error sites are related to occasional errors of memory allocation. <ref type="figure" target="#fig_0">Figure 11</ref> shows such examples of four bugs found in bison, and these bugs have different root causes according to our manual checking. Additionally, the developer fixes each of these bugs by    Bug features. Reviewing the bugs found by FIFUZZ, we find two interesting features. Firstly, among the 46 found bugs related to incorrect error handling, only 4 are triggered by two or more error points' failures, and the remaining 42 bugs are triggered by only one error point's failure. The results indicate that error-handling bugs are often triggered by just one error. Secondly, most of found bugs are caused by the case that an error is correctly handled in the function containing related error site but incorrectly handled in this function's ancestors in the call stack. For example in <ref type="figure" target="#fig_0">Figure 11</ref>, the failure of the function call to calloc is correctly handled in hash_initialize, and hash_initialize returns a null pointer. In this case, the functions calling hash_initialize make some global variables become NULL, but these global variables are still dereferenced in subsequent execution. Indeed, developers can often implement correct error handling code in current functions, but often make mistakes in error propagation due to complex calling contexts of error sites.   <ref type="figure" target="#fig_0">Figure 12</ref>: Two use-after-free bugs found in clamav.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Security Impact of Found Bugs</head><p>We manually review the 50 found bugs to estimate their security impact. The results are shown in <ref type="table" target="#tab_11">Table 7</ref>, classified by bug type, including double-free, use-after-free, buffer-overflow and free-invalid-pointer bugs. The results show that many found bugs can cause serious security problems, such as memory corruption and arbitrary read. <ref type="figure" target="#fig_0">Figure 12</ref> shows two use-after-free bugs reported in clamav. When the program starts, the function cli_ac_addsig is executed, and it calls cli_ac_addpatt that can fail and trigger error handling code. In this code, mpool_free is called to free the pointer new. When the program exits, the function cli_ac_free is called, and it executes a loop to handle each element patt in the pointer array root-&gt;ac_pattable. When i is a specific value, patt is an alias of new which has been freed in cli_ac_addsig, and then patt is used to access patt-&gt;virname (a pointer) and patt-&gt;special (a condition variable), causing two use-after-free bugs. Once these bugs are triggered, the attacker can exploit them to control the values of patt-&gt;virname and patt-&gt;special, and thus to corrupt memory and switch the control flow between the branches of the if statement in line 581.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Comparison to Context-Insensitive SFI</head><p>In FIFUZZ, our context-sensitive SFI method is an important technique of covering error handling code in different calling contexts. To show the value of this technique, we modify FIFUZZ by replacing it with a context-insensitive SFI method, which builds error sequences using error sites,  <ref type="table" target="#tab_1">vim  689  1  1  1,664  58  12  bison  108  3  3  289  11  6  ffmpeg  5  0  0  516  35  12  nasm  7  2  1  78  8  1  catdoc  29  2  2  38  2  3  clamav  29  1  1  325  103  6  cflow  105  1  1  217  1  1  gif2png+libpng  4  0  0  6  0  1  openssl  18  0  0  671  80  8  Total  994  10  9  3,804  298  50   Table 8</ref>: Results of sensitivity analysis.</p><p>without considering their calling contexts. We evaluate the resulting tool on the 9 tested applications in <ref type="table">Table 3</ref>, without using any sanitizer. Each application is also tested for three times, and the time limit of each testing is 24 hours. <ref type="table">Table 8</ref> shows the results of the resulting tool (FIFUZZ_insensitive) and FIFUZZ. Compared to FIFUZZ, the resulting tool generates less useful error sequences that increase code coverage. Indeed, some error handling code is only triggered when related error sites fail in specific calling contexts and succeed in other calling contexts, but the resulting tool always makes these error sites fail and cannot cover such code. The results indicate that our context-sensitive SFI method is effective in covering hard-to-trigger error handling code.</p><p>Besides, the resulting tool finds 9 bugs (including 8 nullpointer dereferences and 1 memory error). All these bugs are also reported by FIFUZZ, but 41 bugs found by FIFUZZ are missed by this tool, because it does not consider calling contexts of error sites. The results indicate that our contextsensitive SFI method is effective in finding deep bugs in different calling contexts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Comparison to Existing Fuzzing Tools</head><p>Many fuzzing approaches have proposed to test infrequently executed code and shown promising results in bug detection. Among them, we select four state-of-the-art and open-source fuzzing tools to make detailed comparison, including AFL <ref type="bibr" target="#b0">[1]</ref>, AFLFast <ref type="bibr" target="#b12">[13]</ref>, AFLSmart <ref type="bibr" target="#b46">[50]</ref> and FairFuzz <ref type="bibr" target="#b35">[38]</ref>. Meanwhile, to validate the generality of FIFUZZ, we select 5 common programs (including nm, objdump, size, ar and readelf) in the Binutils toolset <ref type="bibr" target="#b11">[12]</ref> of an old version 2.26 (release in January 2016) as tested programs, instead of the 8 applications of the lasted versions in the above experiments. We use FIFUZZ and the four fuzzing tools to fuzz each program without using any sanitizer for three times, and the time limit of each fuzzing is 24 hours. For the alerts or crashes reported by these tools, we also check their root causes to count unique bugs.    AFLSmart and FairFuzz, FIFUZZ covers more code branches in nm, size and ar, but covers less code branches in objdump and readelf. The main reason is that the fuzzing process of program inputs in FIFUZZ is implemented by referring to AFL, while AFLSmart and FairFuzz use some techniques to improve mutation and seed selection of fuzzing program inputs compared to AFL. For this reason, AFLSmart and FairFuzz can cover more infrequently executed code related to inputs than FIFUZZ, though they still miss much error handling code covered by FIFUZZ. We believe that if we implement their fuzzing process of program inputs in FIFUZZ, it can cover more code branches than AFLSmart and FairFuzz in all the tested programs. <ref type="table" target="#tab_15">Table 9</ref> shows the results of bug detection. Firstly, the two bugs found by AFL and AFLFast are also found by AFLSmart, FairFuzz and FIFUZZ. Secondly, AFLSmart and FairFuzz respectively find one bug missed by AFL, AFLFast and FIFUZZ. The one extra bug found by AFLSmart is different from that found by FairFuzz, as they improve mutation and seed selection for program inputs in different ways. Finally, FIFUZZ finds 14 bugs, and 12 of them related to error handling code are missed by AFL, AFLFast, AFLSmart and FairFuzz.</p><formula xml:id="formula_4">0 0 0 0 0 0 0 0 0 0 1 1 2 0 2 ar 0 0 0 0 0 0 0 0 0 0 0 0 4 0 4 readelf 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Total 0 2 2</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">False Positives of Error-Site Extraction</head><p>Our static analysis in Section 4.1 describes how to identify possible error sites from the tested program code. However, as shown in Section 5.2, our static analysis still has some false positives in identifying error sites, due to two main reasons:</p><p>Firstly, some functions that return pointers or integers never cause errors, even though their return values are often checked in the code. The functions strcmp and strstr are examples. However, our static analysis still considers that such functions can cause error, and identifies the function calls to them as possible error sites, causing false positives. To solve this problem, we plan to analyze the definition and call graph of each such function, to check whether it can indeed return an erroneous value that represents an error.</p><p>Secondly, a function can indeed fail and trigger error handling code, but some function calls to this function never fail considering their code contexts. This case can occur for some function calls that can cause input-related errors, when all possible inputs may have been changed into valid data before these function calls are used. However, our static analysis still identifies these function calls as possible error sites, causing false positives. To solve this problem, we plan to use symbolic execution <ref type="bibr" target="#b32">[36]</ref> to analyze code context and calculate the constraints for each identified function call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">False Negatives of Bug Detection</head><p>FIFUZZ may miss real bugs in error handling code due to three possible reasons:</p><p>Firstly, as described in Section 4.1, to avoid injecting repeated faults, we only consider library functions for fault injection. However, some functions defined in the tested program can also fail, and they do not call any library function. Thus, FIFUZZ does not cover the error handling code caused by the failures of the calls to such functions.</p><p>Secondly, some error sites are executed only when specific program inputs and configuration are provided. In the evaluation, FIFUZZ cannot provide all possible program inputs and configuration. As a result, some error sites may not be executed, and thus their error handling code cannot be covered.</p><p>Thirdly, we only detect the bugs causing crashes and those reported by ASan. We can use other checkers to detect other kinds of bugs, such as MSan <ref type="bibr" target="#b38">[41]</ref> which detects uninitialized uses, UBSan <ref type="bibr" target="#b53">[57]</ref> which detects undefined behaviors, and TSan <ref type="bibr" target="#b52">[56]</ref> which detects concurrency bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Manual Analyses</head><p>FIFUZZ requires two manual analyses in this paper. Firstly, we perform a manual study in Section 2.3. This manual study is required for gaining the insights into building the automated static analysis, and we believe that the manual study provides the most representative and comprehensive results that help estimate the causes of errors. Secondly, in Section 5.2, we manually select realistic error sites from the possible error sites identified by FIFUZZ. This manual selection is required, as the static analysis of identifying possible error sites still has many false positives. For example, as shown in <ref type="table">Table 4</ref>, we manually check the possible error sites identified by the static analysis, and find that only 18.6% of them are real. We believe that improving the accuracy of this static analysis can help reduce such manual work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Performance Improvement</head><p>The performance of FIFUZZ can be improved in several ways:</p><p>Dropping useless error sequences. As shown in <ref type="table" target="#tab_6">Table 5</ref>, FIFUZZ generates many useless error sequences that fail to increase code coverage. However, they are still used in fault injection to execute the tested program, reducing the fuzzing efficiency. We believe that static analysis can be helpful to dropping these useless error sequences. For example, after an original error sequence mutates and generates new error sequences, a static analysis can be used to analyze the code of the tested program, and infer whether each new error sequence can increase code coverage compared to the original error sequence. If not, this error sequence will be dropped, before being used in fault injection to execute the tested program.</p><p>Lightweight runtime monitoring. As shown in <ref type="figure" target="#fig_7">Figure 8</ref>, to collect runtime calling context, FIFUZZ instruments each function call to the function defined in the tested program code and each function definition. Thus, obvious runtime overhead may be introduced. To reduce runtime overhead, FIFUZZ can use some existing techniques of lightweight runtime monitoring, such as hardware-based tracing <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b27">31]</ref> and call-path inferring <ref type="bibr" target="#b39">[42]</ref>.</p><p>Multi-threading. At present, FIFUZZ works on simple thread. Referring to AFL, to improve efficiency, FIFUZZ can work on multiple threads. Specifically, after an original error sequence mutates and generates new error sequences, FIFUZZ can use each new error sequence for fault injection and execute the tested program on a separate thread. When synchronization is required, all the execution results and generated error sequences can be managed in a specific thread.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Exploitability of Error Handling Bugs</head><p>To detect bugs in error handling code, FIFUZZ injects errors in specific orders according to calling context. Thus, to actually reproduce and exploit a bug found by FIFUZZ, two requirements should be satisfied: (1) being able to actually produce related errors: (2) controlling the occurrence order and time of related errors.</p><p>For the first requirement, different kinds of errors can be produced in different ways. We have to manually look into the error-site function to understand its semantics. However, most of the bugs found in our experiments are related to failures of heap-memory allocations. Thus, an intuitive exploitation way is to exhaustively consume the heap memory, which has been used in some approaches <ref type="bibr" target="#b54">[58,</ref><ref type="bibr" target="#b62">66]</ref> to perform attacks.</p><p>For the second requirement, as we have the error sequence of the bug, we can know when to and when not to produce the errors. A key challenge here is, when errors are dependent to each other, we must timely produce an error in a specific time window. Similar to exploiting use-after-free bugs <ref type="bibr" target="#b58">[62,</ref><ref type="bibr" target="#b59">63]</ref>, if the window is too small, the exploitation may not be feasible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Fuzzing</head><p>Fuzzing is a promising technique of runtime testing to detect bugs and discover vulnerabilities. It generates lots of program inputs in a specific way to cover infrequently executed code. A typical fuzzing approach can be generation-based, mutationbased, or the hybrid of them.</p><p>Generation-based fuzzing approaches <ref type="bibr" target="#b15">[15,</ref><ref type="bibr" target="#b23">27,</ref><ref type="bibr" target="#b55">59,</ref><ref type="bibr" target="#b60">64]</ref> generate inputs according to the specific input format or grammer. Csmith <ref type="bibr" target="#b60">[64]</ref> is a randomized test-case generator to fuzz Clanguage compilers. According to C99 standard, Csmith randomly generates a large number of C programs as inputs for the tested compiler. These generated programs contain complex code using different kinds of C-language features free of undefined behaviors. LangFuzz <ref type="bibr" target="#b25">[29]</ref> is a black-box fuzzing framework for programming-language (PL) interpreters based on a context-free grammar. Given a specific language grammer, LangFuzz generates many programs in this language as inputs for the tested language interpreter. To improve possibility of finding bugs, LangFuzz uses the language grammer to learn code fragments from a given code base.</p><p>Mutation-based fuzzing approaches <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b22">26,</ref><ref type="bibr" target="#b26">30,</ref><ref type="bibr" target="#b35">38,</ref><ref type="bibr" target="#b47">51,</ref><ref type="bibr" target="#b61">65]</ref> start from some original seeds, and perform mutation of the selected seeds, to generate new inputs, without requirement of specific format or grammer. To improve code coverage, these approaches often mutate existing inputs according to the feedback of program execution, such as code coverage and bug-detection results. AFL <ref type="bibr" target="#b0">[1]</ref> is a well-known coverage-guided fuzzing framework, which has been widelyused in industry and research. It uses many effective fuzzing strategies and technical tricks to reduce runtime overhead and improve fuzzing efficiency. To improve mutation for inputs, FairFuzz <ref type="bibr" target="#b35">[38]</ref> first identifies the code branches that are rarely hit by previously-generated inputs, and then uses a new lightweight mutation method to increase the probability of hitting the identified branches. Specifically, this method analyzes the input hitting a rarely hit branch, to identify the parts of this input that are crucial to satisfy the conditions of hitting that branch; this method never changes the identified parts of the input during mutation.</p><p>Some approaches <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b42">45,</ref><ref type="bibr" target="#b46">50,</ref><ref type="bibr" target="#b56">60]</ref> combine generation-based and mutation-based fuzzing to efficiently find deep bugs. AFLSmart <ref type="bibr" target="#b46">[50]</ref> uses a high-level structural representation of the seed file to generate new files. It mutates on the filestructure level instead of on the bit level, which can completely explores new input domains without breaking file validity. Superion <ref type="bibr" target="#b56">[60]</ref> is a grammar-aware and coverage-based fuzzing approach to test programs that process structured inputs. Given the grammar of inputs, it uses a grammar-aware trimming strategy to trim test inputs using the abstract syntax trees of parsed inputs. It also uses two grammar-aware mutation strategies to quickly carry the fuzzing exploration.</p><p>Existing fuzzing approaches focus on generating inputs to cover infrequently executed code. However, this way cannot effectively cover error handling code triggered by non-input occasional errors. To solve this problem, FIFUZZ introduces software fault injection in fuzzing, and fuzzes injected faults according to the feedback of program execution. In this way, it can effectively cover error handling code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Software Fault Injection</head><p>Software fault injection (SFI) <ref type="bibr" target="#b48">[52]</ref> is a classical and widelyused technique of runtime testing. SFI intentionally injects faults or errors into the code of the tested program, and then executes the program to test whether it can correctly handle the injected faults or errors during execution. Many existing SFI-based approaches <ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref><ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b21">25,</ref><ref type="bibr" target="#b36">39,</ref><ref type="bibr" target="#b37">40,</ref><ref type="bibr" target="#b51">55,</ref><ref type="bibr" target="#b63">67]</ref> have shown promising results in testing error handling code.</p><p>Some approaches <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b51">55]</ref> inject single fault in each test case to efficiently cover error handling code triggered by just one error. PairCheck <ref type="bibr" target="#b8">[9]</ref> first injects single fault by corrupting the return values of specific function calls that can fail and trigger error handling code, to collect runtime information about error handling code. Then, it performs a statistical analysis of the collected runtime information to mine pairs of resource-acquire and resouce-release functions. Finally, based on the mined function pairs, it detects resource-release omissions in error handling code.</p><p>To cover more error handling code, some approaches <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b21">25,</ref><ref type="bibr" target="#b36">39,</ref><ref type="bibr" target="#b37">40,</ref><ref type="bibr" target="#b63">67]</ref> inject multiple faults in each test case. Some of them <ref type="bibr" target="#b21">[25,</ref><ref type="bibr" target="#b36">39,</ref><ref type="bibr" target="#b37">40]</ref> inject random faults, namely they inject faults on random sites or randomly change program data. However, some studies <ref type="bibr" target="#b31">[35,</ref><ref type="bibr" target="#b40">43,</ref><ref type="bibr" target="#b41">44]</ref> have shown that random fault injection introduces much uncertainty, causing that the code coverage is low and many detected bugs are false. To solve this problem, some approaches <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b63">67]</ref> analyze program information to guide fault injection, which can achieve higher code coverage and detect more bugs. ADFI <ref type="bibr" target="#b18">[18]</ref> uses a bounded trace-based iterative generation strategy to reduce fault scenario searching, and uses a permutation-based replay mechanism to ensure the fidelity of runtime fault injection.</p><p>To our knowledge, existing SFI-based approaches perform only context-insensitive fault injection. Specifically, they inject faults based on the locations of error sites in source code, without considering the execution contexts of these error sites. Thus, if an fault is constantly injected into an error site, this error site will always fail when being executed at runtime. However, some error handling code is only triggered when related error site fails in a specific calling context but succeeds in other calling contexts. In this case, existing SFI-based approaches cannot effectively cover such error handling code, and thus often miss related bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Static Analysis of Error Handling Code</head><p>Static analysis can conveniently analyze the source code of the target program without actually executing the program. Thus, some existing approaches <ref type="bibr" target="#b24">[28,</ref><ref type="bibr" target="#b28">32,</ref><ref type="bibr" target="#b29">33,</ref><ref type="bibr" target="#b33">37,</ref><ref type="bibr" target="#b49">53]</ref> use static analysis to detect bugs in error handling code. EDP <ref type="bibr" target="#b24">[28]</ref> statically validates the error propagation through file systems and storage device drivers. It builds a function-call graph that shows how error codes propagate through return values and function parameters. By analyzing this call graph, EDP detects bugs about incorrect operations on error codes. <ref type="bibr">APEx [33]</ref> infers API error specifications from their usage patterns, based on a key insight that error paths tend to have fewer code branches and program statements than regular code.</p><p>Due to lacking exact runtime information, static analysis often reports many false positives (for example, the false positive rate of EPEx is 22%). However, static analysis could be introduced in FIFUZZ to drop useless error sequences, which can improve its fuzzing efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>Error handling code is error-prone and hard-to-test, and existing fuzzing approaches cannot effectively test such code especially triggered by occasional errors. To solve this problem, we propose a new fuzzing framework named FIFUZZ, to effectively test error handling code and detect bugs. The core of FIFUZZ is a context-sensitive software fault injection (SFI) approach, which can effectively cover error handling code in different calling contexts to find deep bugs hidden in error handling code with complicated contexts. We have evaluated FIFUZZ on 9 widely-used C applications. It reports 317 alerts, which are caused by 50 new and unique bugs in terms of their root causes. 32 of these bugs have been confirmed by related developers. The comparison to existing fuzzing tools shows that, FIFUZZ can find many bugs missed by these tools.</p><p>FIFUZZ can be still improved in some aspects. Firstly, the static analysis of identifying possible error sites still has many false positives. We plan to reduce these false positives using the ways mentioned in Section 6.1. Secondly, we plan to improve FIFUZZ's performance in some ways, such as dropping useless error sequences, performing lightweight runtime monitoring and exploiting multi-threading mentioned in Section 6.4. Finally, we only use FIFUZZ to test C programs at present, and we plan to test the program in other programming languages (such as C++ and Java).</p><p>We randomly select 50 of the 317 alerts reported by FIFUZZ in the 9 tested applications, and show their information in the table. These 50 alerts are caused by 36 bugs in terms of their root causes. The column "Error points" shows the call stacks of error points (ErrPt x ) that trigger the alert. A call stack presents the information of each function call in the stack, including the name of the called function and code line number of this function call.</p><p>The columns "Source file" and "Line" respectively show the source file name and code line number where the alert occurs. The column "State" shows the current state of our bug report. "F" means that the bug has been confirmed and fixed; "C" means that the bug has been confirmed but not fixed yet; "R" means that the bug report has not been replied. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Program</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fault 1 :</head><label>1</label><figDesc>Figure 1: Examples of function calls that can fail.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>---a/libavcodec/aacsbr.c +++ b/libavcodec/aacsbr.c @@ - 334 , 6 +334, 9 static int sbr_make_f_master(AACContext * ac, SpectralBandReplication * sbr, ...) { ... + if (!sbr-&gt;sample_rate) + return - 1 ; // BUG: sbr-&gt;sample_rate may be zero start_min = ... / sbr-&gt;sample_rate; ... } Figure 2 :---a/libavutil/frame.c +++ b/libavutil/frame.c @@ - 383 , 8 +383, 8 int av_frame_copy_props(...) { ... AVFrameSideData * sd_dst = av_frame_new_side_data(...); if (!sd_dst) { for (i = 0 ; i &lt; dst-&gt;nb_side_data; i++) { av_freep(&amp;dst-&gt;side_data[i]-&gt;data); - av_freep(&amp;dst-&gt;side_data[i]); av_dict_free(&amp;dst-&gt;side_data[i]-&gt;metadata); + av_freep(&amp;dst-&gt;side_data[i]Figure 3 :</head><label>334691}23838803</label><figDesc>Figure 2: Patch A: fixing a divide-by-zero bug.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Figure 4: Procedure of our SFI-based fuzzing approach.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Example of the initial mutation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Example of the normal mutation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>FIFUZZ performs code analysis and code instrumentation on the LLVM bytecode of the tested program. To be compatible with traditional fuzzing process, FIFUZZ mutates the error sequences and program inputs together. Fig- ure 7 shows its architecture, consisting of six parts:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Overall architecture of FIFUZZ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Example of code instrumentation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Identified error functions Realistic error functions Value of the threshold R Number of error functionsFigure 9 :</head><label>9</label><figDesc>Figure 9: Variation of results affected by the value of R.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Variation of error sequences and inputs for vim.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>main -&gt; reader(104) -&gt; symbols_new(714) -&gt; hash_initialize(776) -&gt; calloc(626) Bug4: main -&gt; reader(104) -&gt; symbols_new(714) -&gt; hash_initialize(781) -&gt; calloc(626) Bug2: main -&gt; muscle_init(87) -&gt; hash_initialize(129) -&gt; calloc(626) Bug1: main -&gt; uniqstrs_new(86) -&gt; hash_initialize(160) -&gt; calloc(626) Bug4 FILE: bison/lib/hash.c 597. Hash_table *hash_initialize(...) { ...... 626.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Example bugs caused by the same error site.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 13 Figure 13 :</head><label>1313</label><figDesc>Figure 13: Code coverage of FIFUZZ and the four fuzzing tools.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Error points Source file Line Alert</head><label></label><figDesc>type State vim ErrPt1: main -&gt; common_init(173) -&gt; alloc(934) -&gt; lalloc(827) -&gt; malloc(924) message.c 4334 null-pointer dereference F vim ErrPt1: main -&gt; mch_early_init(115) -&gt; alloc(3212) -&gt; lalloc(827) -&gt; malloc(924) message.c 4334 null-pointer dereference F vim ErrPt1: main -&gt; termcapinit(384) -&gt; set_termname(2571) -&gt; set_shellsize(2069) -&gt; screenclear(3466) -&gt; screenalloc(8744) -&gt; lalloc(8495) -&gt; malloc(924) screen.c 8664 null-pointer dereference F vim ErrPt1: main -&gt; termcapinit(384) -&gt; set_termname(2571) -&gt; set_shellsize(2069) -&gt; screenclear(3466) -&gt; screenalloc(8744) -&gt; win_alloc_lines(8507) -&gt; alloc_clear(5085) -&gt; lalloc(851) -&gt; malloc(924) screen.c 8664 null-pointer dereference F vim ErrPt1: main -&gt; vim_main2(444) -&gt; create_windows(728) -&gt; open_buffer(2750) -&gt; ml_open(167) -&gt; ml_new_data(392) -&gt; mf_new(4015) -&gt; mf_alloc_bhdr(379) -&gt; alloc(898) -&gt; lalloc(827) -&gt; malloc(924) misc2.c 4446 null-pointer dereference F vim ErrPt1: main -&gt; common_init(173) -&gt; set_init_1(1010) -&gt; set_options_default(3522) -&gt; set_option_default(3847) -&gt; set_string_option_direct(3769) -&gt; vim_strsave(5976) -&gt; alloc(1279) -&gt; lalloc(827) -&gt; malloc(924) charset.c 1456 null-pointer dereference F vim ErrPt1: main -&gt; common_init(173) -&gt; set_init_1(1010) -&gt; set_options_default(3522) -&gt; set_option_default(3847) -&gt; set_string_option_direct(3769) -&gt; set_string_option_global(5987) -&gt; vim_strsave(6083) -&gt; alloc(1279) -&gt; lalloc(827) -&gt; malloc(924) charset.c 1456 null-pointer dereference F vim ErrPt1: main -&gt; command_line_scan(200) -&gt; alist_add(2495) -&gt; buflist_add(6688) -&gt; buflist_new(3309) -&gt; buf_copy_options(2036) -&gt; vim_strsave(11649) -&gt; alloc(1279) -&gt; lalloc(827) -&gt; malloc(924) option.c 8422 null-pointer dereference F vim ErrPt1: main -&gt; command_line_scan(200) -&gt; save_typebuf(2365) -&gt; alloc_typebuf(1332) -&gt; alloc(1286) -&gt; lalloc(827) -&gt; malloc(924) getchar.c 1313 double free F vim ErrPt1: main -&gt; command_line_scan(200) -&gt; save_typebuf(2365) -&gt; alloc_typebuf(1332) -&gt; alloc(1287) -&gt; lalloc(827) -&gt; malloc(924) getchar.c 1317 double free F vim ErrPt1: main -&gt; init_highlight(413) -&gt; do_highlight(415) -&gt; syn_check_group(859) -&gt; vim_strsave_up(3066) -&gt; lalloc(827) -&gt; malloc(924) highlight.c 871 null-pointer dereference F vim ErrPt1: main -&gt; vim_main2(444) -&gt; create_windows(728) -&gt; open_buffer(2750) -&gt; readfile(233) -&gt; next_fenc(893) -&gt; enc_canonize(2789) -&gt; alloc(4323) -&gt; lalloc(827) -&gt; malloc(924) fileio.c 2320 freeing invalid pointer F vim ErrPt1: main -&gt; vim_main2(444) -&gt; main_loop(903) -&gt; msg_attr(1286) -&gt; msg_attr_keep(122) -&gt; set_vim_var_string(142) -&gt; vim_strsave(7119) -&gt; alloc(1279) -&gt; lalloc(827) -&gt; malloc(924) message.c 1437 use after free F vim ErrPt1: main -&gt; vim_main2(444) -&gt; main_loop(903) -&gt; normal_cmd(1370) -&gt; do_pending_operator(1133) -&gt; op_delete(1816) -&gt; do_join(2079) -&gt; alloc(4557) -&gt; lalloc(827) -&gt; malloc(924) ops.c 4559 null-pointer dereference F vim ErrPt1: main -&gt; vim_main2(444) -&gt; load_start_packages(492) -&gt; do_in_path(2317) -&gt; alloc(1864) -&gt; lalloc(827) -&gt; malloc(924) ErrPt2: main -&gt; vim_main2(444) -&gt; wait_return(680) -&gt; hit_return_msg(1078) -&gt; msg_puts_attr_len(1961) -&gt; alloc(2588) -&gt; lalloc(827) -&gt; malloc(924) message.c 2589 null-pointer dereference F vim ErrPt1: main -&gt; source_startup_scripts(432) -&gt; do_source(3051) -&gt; fix_fname(2759) -&gt; FullName_save(4817) -&gt; vim_FullName(3082) -&gt; mch_FullName(4479) -&gt; fchdir(2589) ErrPt2: main -&gt; vim_main2(444) -&gt; wait_return(680) -&gt; hit_return_msg(1078) -&gt; msg_putchar(1267) -&gt; msg_putchar_attr(1369) -&gt; msg_puts_attr(1386) -&gt; msg_puts_attr_len(1961) -&gt; msg_puts_printf(2008) -&gt; alloc(2588) -&gt; lalloc(827) -&gt; malloc(924) message.c 2589 null-pointer dereference F bison ErrPt1: main -&gt; uniqstrs_new(86) -&gt; hash_initialize(160) -&gt; malloc(605) hash.c 251 null-pointer dereference F bison ErrPt1: main -&gt; reader(104) -&gt; symbols_new(714) -&gt; hash_initialize(776) -&gt; malloc(605) hash.c 251 null-pointer dereference F bison ErrPt1: main -&gt; muscle_init(87) -&gt; hash_initialize(129) -&gt; calloc(626) hash.c 251 null-pointer dereference F bison ErrPt1: main -&gt; generate_states(124) -&gt; allocate_storage(358) -&gt; state_hash_new(168) -&gt; hash_initialize(362) -&gt; calloc(626) hash.c 251 null-pointer dereference F bison ErrPt1: main -&gt; tables_generate(152) -&gt; pack_table(802) -&gt; bitset_create(727) -&gt; bitset_alloc(163) -&gt; bitset_init(138) -&gt; vbitset_init(88) -&gt; vbitset_resize(989) -&gt; realloc(77) vector.c 81 null-pointer dereference F ffmpeg ErrPt1: main -&gt; ffmpeg_parse_options(4872) -&gt; open_files(3317) -&gt; open_input_file(3277) -&gt; avformat_alloc_context(1041) -&gt; av_mallocz(151) -&gt; av_malloc(238) -&gt; posix_memalign(87) dict.c 205 null-pointer dereference R ffmpeg ErrPt1: main -&gt; ffmpeg_parse_options(4872) -&gt; open_files(3331) -&gt; open_output_file(3277) -&gt; avformat_alloc_output_context2(2152) -&gt; avformat_alloc_context(151) -&gt; av_mallocz(151) -&gt; av_malloc(238) -&gt; posix_memalign(87) dict.c 205 null-pointer dereference R ffmpeg ErrPt1: main -&gt; ffmpeg_parse_options(4872) -&gt; open_files(3331) -&gt; open_output_file(3277) -&gt; new_audio_stream(2236) -&gt; new_output_stream(1859) -&gt; avcodec_alloc_context3(1387) -&gt; init_context_defaults(163) -&gt; av_opt_set(141) -&gt; set_string_number(484) -&gt; av_expr_parse_and_eval(292) -&gt; av_expr_parse(751) -&gt; av_malloc(687) -&gt; posix_memalign(87) options.c 141 assertion failure R ffmpeg ErrPt1: main -&gt; transcode(4894) -&gt; transcode_step(4692) -&gt; process_input(4638) -&gt; process_input_packet(4518) -&gt; decode_audio(2619) -&gt; send_frame_to_filters(2337) -&gt; ifilter_send_frame(2270) -&gt; configure_filtergraph(2189) -&gt; avfilter_graph_parse2(1056) -&gt; parse_filter(427) -&gt; av_get_token(184) -&gt; av_malloc(151) -&gt; posix_memalign(87) avstrings.c 87 null-pointer dereference R ffmpeg ErrPt1: main -&gt; ffmpeg_parse_options(4872) -&gt; open_files(3317) -&gt; open_input_file(3277) -&gt; avformat_find_stream_info(1126) -&gt; avcodec_open2(3674) -&gt; av_mallocz(624) -&gt; av_malloc(238) -&gt; posix_memalign(87) utils.c 491 null-pointer dereference R ffmpeg ErrPt1: main -&gt; transcode(4894) -&gt; transcode_step(4692) -&gt; reap_filters(4648) -&gt; init_output_stream(1442) -&gt; avcodec_open2(3517) -&gt; ff_ac3_float_encode_init(935) -&gt; ff_ac3_encode_init(138) -&gt; allocate_buffers(2481) -&gt; ff_ac3_float_allocate_sample_buffers(2331) -&gt; av_mallocz(49) -&gt; av_malloc(238) -&gt; posix_memalign(87) mem.c 223 null-pointer dereference R Program Error points File name Line Bug type State ffmpeg ErrPt1: main -&gt; transcode(4894) -&gt; transcode_step(4692) -&gt; process_input(4638) -&gt; process_input_packet(4518) -&gt; decode_audio(2619) -&gt; send_frame_to_filters(2337) -&gt; ifilter_send_frame(2270) -&gt; configure_filtergraph(2189) -&gt; avfilter_graph_config(1109) -&gt; graph_config_formats(1275) -&gt; query_formats(1164) -&gt; ff_merge_channel_layouts(499) -&gt; av_realloc_array(242) -&gt; av_realloc(202) -&gt; realloc(144) avfiltergraph.c 583 use after free R ffmpeg ErrPt1: main -&gt; transcode(4894) -&gt; transcode_step(4692) -&gt; process_input(4638) -&gt; process_input_packet(4518) -&gt; decode_audio(2619) -&gt; send_frame_to_filters(2337) -&gt; ifilter_send_frame(2270) -&gt; configure_filtergraph(2189) -&gt; configure_output_filter(1106) -&gt; configure_output_audio_filter(685) -&gt; choose_channel_layouts(606) -&gt; avio_close_dyn_buf(194) -&gt; avio_flush(1431) -&gt; flush_buffer(241) -&gt; writeout(184) -&gt; dyn_buf_write(163) -&gt; av_reallocp(1319) -&gt; av_realloc(173) -&gt; realloc(144) ffmpeg_filter.c 179 null-pointer dereference R ffmpeg ErrPt1: main -&gt; ffmpeg_parse_options(4872) -&gt; open_files(3331) -&gt; open_output_file(3277) -&gt; avio_open2(2558) -&gt; ffio_open_whitelist(1180) -&gt; ffio_fdopen(1169) -&gt; av_strdup(1007) -&gt; av_realloc(256) -&gt; realloc(144) mem.c 233 double free R ffmpeg ErrPt1: main -&gt; ffmpeg_parse_options(4872) -&gt; open_files(3317) -&gt; open_input_file(3277) -&gt; avformat_open_input(1104) -&gt; init_input(573) -&gt; io_open_default(438) -&gt; ffio_open_whitelist(124) -&gt; ffio_fdopen(1169) -&gt; av_strdup(1007) -&gt; av_realloc(256) -&gt; realloc(144) mem.c 233 double free R ffmpeg ErrPt1: main -&gt; ffmpeg_parse_options(4872) -&gt; open_files(3317) -&gt; open_input_file(3277) -&gt; avformat_find_stream_info(1126) -&gt; avcodec_open2(3674) -&gt; av_opt_set_dict(634) -&gt; av_opt_set_dict2(1605) -&gt; av_dict_set(1590) -&gt; av_strdup(87) -&gt; av_realloc(256) -&gt; realloc(144) ErrPt2: main -&gt; ffmpeg_parse_options(4872) -&gt; open_files(3317) -&gt; open_input_file(3277) -&gt; avformat_find_stream_info(1126) -&gt; try_decode_frame(3903) -&gt; avcodec_open2(3050) -&gt; ff_decode_bsfs_init(736) -&gt; av_bsf_alloc(232) -&gt; av_mallocz(86) -&gt; av_malloc(238) -&gt; posix_memalign(87) decode.c 2059 freeing dangling pointer R ffmpeg ErrPt1: main -&gt; ffmpeg_parse_options(4872) -&gt; open_files(3317) -&gt; open_input_file(3277) -&gt; avformat_find_stream_info(1126) -&gt; avcodec_open2(3674) -&gt; av_opt_set_dict(634) -&gt; av_opt_set_dict2(1605) -&gt; av_dict_set(1590) -&gt; av_strdup(87) -&gt; av_realloc(256) -&gt; realloc(144) ErrPt2: main -&gt; ffmpeg_parse_options(4872) -&gt; open_files(3317) -&gt; open_input_file(3277) -&gt; avformat_find_stream_info(1126) -&gt; try_decode_frame(3903) -&gt; avcodec_open2(3050) -&gt; aac_decode_init(935) -&gt; ff_mdct_init(1226) -&gt; ff_fft_init(61) -&gt; av_malloc(224) -&gt; posix_memalign(87) aacdec_template.c 2659 null-pointer dereference R ffmpeg ErrPt1: main -&gt; ffmpeg_parse_options(4872) -&gt; open_files(3317) -&gt; open_input_file(3277) -&gt; avformat_find_stream_info(1126) -&gt; avcodec_open2(3674) -&gt; av_opt_set_dict(634) -&gt; av_opt_set_dict2(1605) -&gt; av_dict_set(1590) -&gt; av_strdup(87) -&gt; av_realloc(256) -&gt; realloc(144) ErrPt2: main -&gt; ffmpeg_parse_options(4872) -&gt; open_files(3317) -&gt; open_input_file(3277) -&gt; avformat_find_stream_info(1126) -&gt; try_decode_frame(3903) -&gt; avcodec_open2(3050) -&gt; aac_decode_init(935) -&gt; ff_mdct_init(1226) -&gt; av_malloc_array(64) -&gt; av_malloc(188) -&gt; posix_memalign(87) aacdec_template.c 2659 null-pointer dereference R nasm ErrPt1: main -&gt; saa_init(479) -&gt; nasm_malloc(56) -&gt; malloc(75) nasm.c 1909 null-pointer dereference F nasm ErrPt1: main -&gt; init_labels(476) -&gt; nasm_malloc(563) -&gt; malloc(75) nasm.c 1909 null-pointer dereference F nasm ErrPt1: main -&gt; saa_init(479) -&gt; nasm_zalloc(47) -&gt; calloc(85) nasm.c 1909 null-pointer dereference F nasm ErrPt1: main -&gt; init_labels(476) -&gt; hash_init(561) -&gt; alloc_table(66) -&gt; nasm_zalloc(60) -&gt; calloc(85) nasm.c 1909 null-pointer dereference F catdoc ErrPt1: main -&gt; read_charset(112) -&gt; calloc(93) charsets.c 95 null-pointer dereference R clamav ErrPt1: main -&gt; scanmanager(161) -&gt; cl_engine_compile(861) -&gt; cli_loadftm(5184) -&gt; cli_parse_add(2156) -&gt; cli_ac_addsig(497) -&gt; cli_ac_addpatt(2835) -&gt; cli_ac_addpatt_recursive(340) -&gt; add_new_node(299) -&gt; cli_calloc(236) -&gt; calloc(216) matcher-ac.c 578 use after free C clamav ErrPt1: main -&gt; scanmanager(161) -&gt; cl_engine_compile(861) -&gt; cli_loadftm(5184) -&gt; cli_parse_add(2156) -&gt; cli_ac_addsig(608) -&gt; cli_ac_addpatt(2835) -&gt; cli_ac_addpatt_recursive(340) -&gt; cli_ac_addpatt_recursive(305) -&gt; add_new_node(299) -&gt; cli_calloc(229) -&gt; calloc(216) matcher-ac.c 578 use after free C clamav ErrPt1: main -&gt; scanmanager(161) -&gt; cl_load(833) -&gt; cli_loaddbdir(4726) -&gt; cli_load(4581) -&gt; cli_cvdload(4341) -&gt; cli_tgzload(706) -&gt; cli_load(345) -&gt; cli_loadcbc(4392) -&gt; load_oneldb(2020) -&gt; cli_parse_add(1876) -&gt; cli_ac_addsig(497) -&gt; cli_ac_addpatt(2835) -&gt; cli_ac_addpatt_recursive(340) -&gt; add_new_node(299) -&gt; cli_calloc(236) -&gt; calloc(216) matcher-ac.c 578 use after free C clamav ErrPt1: main -&gt; scanmanager(161) -&gt; cl_load(833) -&gt; cli_loaddbdir(4726) -&gt; cli_load(4581) -&gt; cli_cvdload(4341) -&gt; cli_tgzload(706) -&gt; cli_load(345) -&gt; cli_loadcbc(4392) -&gt; cli_initroots(1961) -&gt; cli_bm_init(678) -&gt; cli_calloc(147) -&gt; calloc(216) matcher-bm.c 224 double free C clamav ErrPt1: main -&gt; scanmanager(161) -&gt; cl_engine_compile(861) -&gt; cli_bytecode_prepare2(5250) -&gt; selfcheck(2683) -&gt; add_selfcheck(2479) -&gt; cli_calloc(2397) -&gt; calloc(216) bytecode.c 1931 null-pointer dereference C clamav ErrPt1: main -&gt; scanmanager(161) -&gt; cl_load(833) -&gt; cli_loaddbdir(4726) -&gt; cli_load(4581) -&gt; cli_cvdload(4341) -&gt; cli_cvdverify(625) -&gt; cli_versig(566) -&gt; cli_str2hex(131) -&gt; cli_calloc(242) -&gt; calloc(216) dsig.c 136 null-pointer dereference C clamav ErrPt1: main -&gt; scanmanager(161) -&gt; cl_engine_compile(861) -&gt; cli_loadftm(5184) -&gt; cli_parse_add(2156) -&gt; cli_ac_addsig(608) -&gt; cli_ac_addpatt(2835) -&gt; cli_ac_addpatt_recursive(340) -&gt; add_new_node(299) -&gt; cli_realloc(245) -&gt; realloc(235) matcher-ac.c 578 use after free C clamav ErrPt1: main -&gt; scanmanager(161) -&gt; cl_engine_compile(861) -&gt; cli_loadftm(5184) -&gt; cli_parse_add(2156) -&gt; cli_ac_addsig(497) -&gt; cli_ac_addpatt(2835) -&gt; cli_ac_addpatt_recursive(340) -&gt; cli_ac_addpatt_recursive(305) -&gt; cli_ac_addpatt_recursive(305) -&gt; insert_list(268) -&gt; cli_realloc(106) -&gt; realloc(235) matcher-ac.c 578 use after free C clamav ErrPt1: main -&gt; scanmanager(161) -&gt; cl_engine_compile(861) -&gt; cli_bytecode_prepare2(5250) -&gt; selfcheck(2683) -&gt; add_selfcheck(2479) -&gt; cli_realloc2(2348) -&gt; realloc(254) bytecode.c 1919 null-pointer dereference C clamav ErrPt1: main -&gt; scanmanager(161) -&gt; cl_load(833) -&gt; cli_loaddbdir(4726) -&gt; cli_load(4581) -&gt; cli_cvdload(4341) -&gt; cli_tgzload(706) -&gt; cli_load(345) -&gt; cli_loadcbc(4392) -&gt; cli_initroots(1961) -&gt; cli_ac_init(670) -&gt; cli_malloc(521) -&gt; malloc(197) matcher-ac.c 614 use after free C clamav ErrPt1: main -&gt; scanmanager(161) -&gt; scanfile(205) -&gt; cl_scandesc_callback(391) -&gt; scan_common(4324) -&gt; malloc(4128) scanners.c 4129 null-pointer dereference R</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 2 :</head><label>2</label><figDesc>Study results of existing fuzzing tools.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>table :</head><label>:</label><figDesc></figDesc><table>KEY 
VALUE 

Hash(ErrPt 1 ) 
0 or 1 

Hash(ErrPt 2 ) 
0 or 1 

...... 
...... 

Hash(ErrPt x ) 
0 or 1 </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Table 5 : Fuzzing results.</head><label>5</label><figDesc></figDesc><table>Type 
Null 
MemErr 
Assert 
All / Error handling 
Unique alert 
182 
132 
3 
317 / 313 
Found bug 
36 
13 
1 
50 / 46 
Confirmed bug 
26 
6 
0 
32 / 32 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>Table 6 :</head><label>6</label><figDesc>Summary of reported alerts and found bugs.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>table - &gt;bucket</head><label>-</label><figDesc></figDesc><table>= calloc(...); 
627. if (table-&gt;bucket == NULL) 
628. 
goto fail; 
...... 
646. } 

FILE: bison/src/symtab.c 
775. void symbol_new(void) { 
776. symbol_table = hash_initialize(...); 
...... 
781. type_table = hash_initialize(...); 
...... 
786. } 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>Table 7 :</head><label>7</label><figDesc></figDesc><table>Security impact classified by bug type. 

FILE: clamav/libclamav/matcher-ac.c 
572. void cli_ac_free(struct cli_matcher *root) { 
...... 
577. for (i = 0; i &lt; root-&gt;ac_patterns; i++) { 
// ''patt'' can be ''new'' given specific ''i'' 
578. 
patt = root-&gt;ac_pattable[i]; 
...... 
580. 
mpool_free(root-&gt;mempool, patt-&gt;virname) // use after free 
581. 
if (patt-&gt;special) // use after free 
...... 
620. } 

2413. int cli_ac_addsig(struct cli_matcher *root, ...) { 
...... 
2835. if ((ret = cli_ac_addpatt(root, new))) { 
...... 
2839. 
mpool_free(root-&gt;mempool, new); // free ''new'' 
2840. 
return ret; 
2841. } 
...... 
2857. } 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15" validated="false"><head>Table 9 :</head><label>9</label><figDesc>Results of bug detection for comparison.</figDesc><table></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>We thank our shepherd, Deian Stefan, and anonymous reviewers for their helpful advice on the paper. This work was mainly supported by the China Postdoctoral Science Foundation under Project 2019T120093. Kangjie Lu was supported in part by the NSF award CNS-1931208. Any opinions, findings, conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of NSF. Jia-Ju Bai is the corresponding author.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>American Fuzzy Lop</surname></persName>
		</author>
		<ptr target="http://lcamtuf.coredump.cx/afl/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">A collection of vulnerabilities discovered by the AFL fuzzer</title>
		<ptr target="https://github.com/mrash/afl-cve" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<ptr target="https://commu-nity.arm.com/tools/b/blog/posts/introduction-to-arm-s-system-trace-macrocell" />
		<title level="m">ARM System Trace Macrocell (STM</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">ASan: address sanitizer</title>
		<ptr target="https://github.com/google/san-itizers/wiki/AddressSanitizer" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">ASan performance</title>
		<ptr target="https://github.com/google/sanitizers/wiki/AddressSanitizerPerformanceNumbers" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">NAUTILUS: fishing for deep bugs with grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aschermann</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Frassetto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Holz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jauernig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Teuchert</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th Network and Distributed Systems Security Symposium (NDSS)</title>
		<meeting>the 26th Network and Distributed Systems Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">REDQUEEN: fuzzing with input-to-state correspondence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aschermann</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Schumilo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Blazytko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gawlik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Holz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th Network and Distributed Systems Security Symposium (NDSS)</title>
		<meeting>the 26th Network and Distributed Systems Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Catch me if you can: permissive yet secure error handling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Askarov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sabelfeld</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Workshop on Programming Languages and Analysis for Security</title>
		<meeting>the 4th International Workshop on Programming Languages and Analysis for Security</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="45" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Mining and checking paired functions in device drivers using characteristic fault injection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bai</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-P</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-Q</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Software Technology (IST)</title>
		<imprint>
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="page" from="122" to="133" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Testing error handling code in device drivers using characteristic fault injection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bai</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-P</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 USENIX Annual Technical Conference</title>
		<meeting>the 2016 USENIX Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="635" to="647" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Fast black-box testing of system recovery code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Banabic</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Candea</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th European Conference on Computer Systems (EuroSys) (2012)</title>
		<meeting>the 7th European Conference on Computer Systems (EuroSys) (2012)</meeting>
		<imprint>
			<biblScope unit="page" from="281" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gnu</forename><surname>Binutils</surname></persName>
		</author>
		<ptr target="http://www.gnu.org/software/binutils/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Coverage-based greybox fuzzing as markov chain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Böhme</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V.-T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roychoudhury</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Computer and Communications Security (CCS</title>
		<meeting>the 23rd International Conference on Computer and Communications Security (CCS</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1032" to="1043" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Exception handling: A field study in java and. net</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cabral</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marques</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the</title>
		<meeting>the</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
				<title level="m">European Conference on Object-Oriented Programming</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="151" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Taming compiler fuzzers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Groce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-K</forename><surname>Fern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Eide</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Regehr</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th International Conference on Programming Language Design and Implementation (PLDI</title>
		<meeting>the 34th International Conference on Programming Language Design and Implementation (PLDI</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="197" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Clang: a LLVM-based compiler for C/C++ program</title>
		<ptr target="https://clang.llvm.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">CLOC: count lines of code</title>
		<ptr target="https://cloc.sourceforge.net" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Automatic fault injection for driver robustness testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cong</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Lei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xie</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 International Symposium on Software Testing and Analysis (ISSTA) (2015)</title>
		<meeting>the 2015 International Symposium on Software Testing and Analysis (ISSTA) (2015)</meeting>
		<imprint>
			<biblScope unit="page" from="361" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A study on developers&apos; perceptions about exception handling bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ebert</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Castor</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 International Conference on Software Maintenance (ICSM) (2013)</title>
		<meeting>the 2013 International Conference on Software Maintenance (ICSM) (2013)</meeting>
		<imprint>
			<biblScope unit="page" from="448" to="451" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">FFmpeg: a complete, cross-platform solution to record</title>
		<ptr target="https://ffmpeg.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Testing of Java web services for robustness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ryder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">G</forename><surname>Milanova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wonna-Cott</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 International Symposium on Software Testing and Analysis (ISSTA)</title>
		<meeting>the 2004 International Symposium on Software Testing and Analysis (ISSTA)</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="23" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">CollAFL: path sensitive fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pei</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th IEEE Symposium on Security and Privacy</title>
		<meeting>the 39th IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="679" to="696" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Grammar-based whitebox fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Godefroid</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kiezun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Levin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Conference on Programming Language Design and Implementation (PLDI</title>
		<meeting>the 29th International Conference on Programming Language Design and Implementation (PLDI</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="206" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">EIO: error handling is occasionally correct</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gunawi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S</forename><surname>Rubio-González</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li-Blit</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Conference on File and Storage Technologies (FAST)</title>
		<meeting>the 6th International Conference on File and Storage Technologies (FAST)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="207" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Fuzzing with code fragments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Holler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Herzig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zeller</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st USENIX Security Symposium</title>
		<meeting>the 21st USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="445" to="458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Honggfuzz: security oriented fuzzer with powerful analysis options</title>
		<ptr target="https://github.com/google/honggfuzz" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
				<ptr target="https://software.intel.com/en-us/blogs/2013/09/18/processor-tracing" />
		<title level="m">Intel Processor Tracing (PT</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Automatically detecting error handling bugs using error specifications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jana</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">J</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ray</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th USENIX Security Symposium</title>
		<meeting>the 25th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="345" to="362" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">APEx: automated inference of error specifications for C APIs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jana</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st International Conference on Automated Software Engineering (ASE)</title>
		<meeting>the 31st International Conference on Automated Software Engineering (ASE)</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="472" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Examining programmer practices for locally handling exceptions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kery</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Le Goues</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Myers</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Working Conference on Mining Software Repositories (MSR)</title>
		<meeting>the 13th International Working Conference on Mining Software Repositories (MSR)</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="484" to="487" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Do injected faults cause real failures? a case study of Linux</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kikuchi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Yoshimura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sakuma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kono</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Symposium on Software Reliability Engineering Workshops</title>
		<meeting>the 25th International Symposium on Software Reliability Engineering Workshops</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="174" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Symbolic execution and program testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">King</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="385" to="394" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Finding error handling bugs in openssl using Coccinelle</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lawall</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laurie</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Palix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muller</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010</title>
		<meeting>the 2010</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
				<title level="m">European Dependable Computing Conference (EDCC) (2010)</title>
		<imprint>
			<biblScope unit="page" from="191" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">FairFuzz: a targeted mutation strategy for increasing greybox fuzz testing coverage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lemieux</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd International Conference on Automated Software Engineering (ASE</title>
		<meeting>the 33rd International Conference on Automated Software Engineering (ASE</meeting>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="475" to="485" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">LFI: a practical and general library-level fault injector</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marinescu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Candea</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th International Conference on Dependable Systems and Networks (DSN</title>
		<meeting>the 39th International Conference on Dependable Systems and Networks (DSN</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="379" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Robustness testing of the Windows DDK</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mendonca</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neves</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th International Conference on Dependable Systems and Networks (DSN</title>
		<meeting>the 37th International Conference on Dependable Systems and Networks (DSN</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="554" to="564" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">MSan: memory sanitizer</title>
		<ptr target="https://github.com/google/san-itizers/wiki/MemorySanitizer" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Inferred call path profiling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mytkowicz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Coughlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Diwan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA</title>
		<meeting>the 24th International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="175" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Representativeness analysis of injected software faults in complex software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Natella</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cotroneo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Duraes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madeira</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th International Conference on Dependable Systems and Networks (DSN) (2010)</title>
		<meeting>the 40th International Conference on Dependable Systems and Networks (DSN) (2010)</meeting>
		<imprint>
			<biblScope unit="page" from="437" to="446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">On fault representativeness of software fault injection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Natella</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cotroneo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Duraes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madeira</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering (TSE)</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="80" to="96" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Semantic fuzzing with Zest</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Padhye</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lemieux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Papadakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">E</forename><surname>Traon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Symposium on Software Testing and Analysis (ISSTA) (2019)</title>
		<meeting>the 2019 International Symposium on Software Testing and Analysis (ISSTA) (2019)</meeting>
		<imprint>
			<biblScope unit="page" from="329" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Aacsbr: check that sample_rate is not 0 before division</title>
		<ptr target="http://github.com/ffmpeg/ffmpeg/commit/a50a5ff29e" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Found bug: libav: divide-by-zero in sbr_make_f_master</title>
		<ptr target="https://blogs.gentoo.org/ago/2016/09/21/libav-divide-by-zero-in-sbr_make_f_master-aacsbr-c/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Frame: fix the error path in av_frame_copy_props</title>
		<ptr target="http://github.com/ffmpeg/ffmpeg/commit/a53551cba8" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Smart greybox fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pham</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V.-T</forename><surname>Böhme</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Santosa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Caci-Ulescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roychoudhury</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<date type="published" when="2019" />
			<publisher>TSE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">VUzzer: applicationaware evolutionary fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rawat</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cojocar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Giuffrida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Network and Distributed Systems Security Symposium (NDSS</title>
		<meeting>the 24th Network and Distributed Systems Security Symposium (NDSS</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Software fault injection and its application in distributed systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rosenberg</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Symposium on Fault-Tolerant Computing (FTCS) (1993)</title>
		<meeting>the 23rd International Symposium on Fault-Tolerant Computing (FTCS) (1993)</meeting>
		<imprint>
			<biblScope unit="page" from="208" to="217" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Hector: detecting resource-release omission faults in error-handling code for systems software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saha</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lozi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muller</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd International Conference on Dependable Systems and Networks (DSN) (2013)</title>
		<meeting>the 43rd International Conference on Dependable Systems and Networks (DSN) (2013)</meeting>
		<imprint>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Why do developers neglect exception handling?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shah</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Görg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harrold</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Workshop on Exception Handling (WEH)</title>
		<meeting>the 4th International Workshop on Exception Handling (WEH)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="62" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Automatically finding and patching bad error handling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Susskraut</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fetzer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 European Dependable Computing Conference (EDCC</title>
		<meeting>the 2006 European Dependable Computing Conference (EDCC</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tsan</surname></persName>
		</author>
		<ptr target="https://github.com/google/san-itizers/wiki/ThreadSanitizerCppManual" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">UBSan: undefined behavior sanitizer</title>
		<ptr target="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Drammer: deterministic rowhammer attacks on mobile platforms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Van Der</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Veen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Fratantonio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lindorfer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Maurice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Razavi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giuffrida</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Computer and Communications Security (CCS</title>
		<meeting>the 23rd International Conference on Computer and Communications Security (CCS</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1675" to="1689" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Skyfire: data-driven seed generation for fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th IEEE Symposium on Security and Privacy</title>
		<meeting>the 38th IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="579" to="594" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Superion: grammar-aware greybox fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st International Conference on Software Engineering (ICSE) (2019)</title>
		<meeting>the 41st International Conference on Software Engineering (ICSE) (2019)</meeting>
		<imprint>
			<biblScope unit="page" from="724" to="735" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Finding and preventing run-time error handling mistakes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weimer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Necula</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on ObjectOriented Programming Systems, Languages and Applications (OOPSLA</title>
		<meeting>the 19th International Conference on ObjectOriented Programming Systems, Languages and Applications (OOPSLA</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="419" to="431" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">FUZE: towards facilitating exploit generation for kernel use-after-free vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Security Symposium</title>
		<meeting>the 27th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="781" to="797" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">From collision to exploitation: unleashing use-after-free vulnerabilities in Linux kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Conference on Computer and Communications Security (CCS</title>
		<meeting>the 22nd International Conference on Computer and Communications Security (CCS</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="414" to="425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Finding and understanding bugs in C compilers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Eide</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Regehr</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd International Conference on Programming Language Design and Implementation (PLDI</title>
		<meeting>the 32nd International Conference on Programming Language Design and Implementation (PLDI</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="283" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">QSYM: a practical concolic execution engine tailored for hybrid fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yun</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Security Symposium</title>
		<meeting>the 27th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="745" to="761" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Android ion hazard: The curse of customizable memory management system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>She</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qian</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 23rd International Conference on Computer and Communications Security (CCS)</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1663" to="1674" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Amplifying tests to validate exception handling code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elbaum</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th International Conference on Software Engineering (ICSE</title>
		<meeting>the 34th International Conference on Software Engineering (ICSE</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="595" to="605" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Automatically detecting SSL error-handling vulnerabilities in hybrid mobile web apps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zuo</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guo</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th ACM Symposium on Information, Computer and Communications Security</title>
		<meeting>the 10th ACM Symposium on Information, Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="591" to="596" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
