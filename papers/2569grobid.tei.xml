<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:47+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">USENIX Association 7th USENIX Conference on File and Storage Technologies PARDA: Proportional Allocation of Resources for Distributed Storage Access</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ajay</forename><surname>Gulati</surname></persName>
							<email>agulati@vmware.com</email>
							<affiliation key="aff0">
								<orgName type="institution">VMware Inc</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Irfan</forename><surname>Ahmad</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">VMware Inc</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carl</forename><forename type="middle">A</forename><surname>Waldspurger</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">VMware Inc</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">USENIX Association 7th USENIX Conference on File and Storage Technologies PARDA: Proportional Allocation of Resources for Distributed Storage Access</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>85</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Rapid adoption of virtualization technologies has led to increased utilization of physical resources, which are mul-tiplexed among numerous workloads with varying demands and importance. Virtualization has also accelerated the deployment of shared storage systems, which offer many advantages in such environments. Effective resource management for shared storage systems is challenging, even in research systems with complete end-to-end control over all system components. Commercially-available storage arrays typically offer only limited, proprietary support for controlling service rates, which is insufficient for isolating work-loads sharing the same storage volume or LUN. To address these issues, we introduce PARDA, a novel software system that enforces proportional-share fairness among distributed hosts accessing a storage array, without assuming any support from the array itself. PARDA uses latency measurements to detect overload, and adjusts issue queue lengths to provide fairness, similar to aspects of flow control in FAST TCP. We present the design and implementation of PARDA in the context of VMware ESX Server, a hypervisor-based virtualization system, and show how it can be used to provide differential quality of service for unmodified virtual machines while maintaining high efficiency. We evaluate the effectiveness of our implementation using quantitative experiments, demonstrating that this approach is practical.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Storage arrays form the backbone of modern data centers by providing consolidated data access to multiple applications simultaneously. Deployments of consolidated storage using Storage Area Network (SAN) or Network-Attached Storage (NAS) hardware are increasing, motivated by easy access to data from anywhere at any time, ease of backup, flexibility in provisioning, and centralized administration. This trend is further fueled by the proliferation of virtualization technologies, which rely on shared storage to support features such as live migration of workloads across hosts.</p><p>A typical virtualized data center consists of multiple physical hosts, each running several virtual machines (VMs). Many VMs may compete for access to one or more logical units (LUNs) on a single storage array. The resulting contention at the array for resources such as controllers, caches, and disk arms leads to unpredictable IO completion times. Resource management mechanisms and policies are required to enable performance isolation, control service rates, and enforce service-level agreements.</p><p>In this paper, we target the problem of providing coarsegrained fairness to VMs, without assuming any support from the storage array itself. We also strive to remain workconserving, so that the array is utilized efficiently. We focus on proportionate allocation of IO resources as a flexible building block for constructing higher-level policies. This problem is challenging for several reasons, including the need to treat the array as an unmodifiable black box, unpredictable array performance, uncertain available bandwidth, and the desire for a scalable decentralized solution.</p><p>Many existing approaches <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b27">28]</ref> allocate bandwidth among multiple applications running on a single host. In such systems, one centralized scheduler has complete control over all requests to the storage system. Other centralized schemes <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b29">30]</ref> attempt to control the queue length at the device to provide tight latency bounds. Although centralized schedulers are useful for host-level IO scheduling, in our virtualized environment we need an approach for coordinating IO scheduling across multiple independent hosts accessing a shared storage array.</p><p>More decentralized approaches, such as Triage <ref type="bibr" target="#b17">[18]</ref>, have been proposed, but still rely on centralized measurement and control. A central agent adjusts per-host bandwidth caps over successive time periods and communicates them to hosts. Throttling hosts using caps can lead to substantial inefficiency by under-utilizing array resources. In addition, host-level changes such as VMs becoming idle need to propagate to the central controller, which may cause a prohibitive increase in communication costs.</p><p>We instead map the problem of distributed storage access from multiple hosts to the problem of flow control in networks. In principle, fairly allocating storage bandwidth with high utilization is analogous to distributed hosts trying to estimate available network bandwidth and consuming it in a fair manner. The network is effectively a black box to the hosts, providing little or no information about its current 7th USENIX Conference on File and Storage Technologies USENIX Association state and the number of participants. Starting with this loose analogy, we designed PARDA, a new software system that enforces coarse-grained proportional-share fairness among hosts accessing a storage array, while still maintaining high array utilization. PARDA uses the IO latency observed by each host as an indicator of load at the array, and uses a control equation to adjust the number of IOs issued per host, i.e., the host window size. We found that variability in IO latency, due to both request characteristics (e.g., degree of sequentiality, reads vs. writes, and IO size) and array internals (e.g., request scheduling, caching and block placement) could be magnified by the independent control loops running at each host, resulting in undesirable divergent behavior.</p><p>To handle such variability, we found that using the average latency observed across all hosts as an indicator of overall load produced stable results. Although this approach does require communication between hosts, we need only compute a simple average for a single metric, which can be accomplished using a lightweight, decentralized aggregation mechanism. PARDA also handles idle VMs and bursty workloads by adapting per-host weights based on long-term idling behavior, and by using a local scheduler at the host to handle short-term bursts. Integrating with a local proportional-share scheduler <ref type="bibr" target="#b9">[10]</ref> enables fair end-toend access to VMs in a distributed environment.</p><p>We implemented a complete PARDA prototype in the VMware ESX Server hypervisor <ref type="bibr" target="#b23">[24]</ref>. For simplicity, we assume all hosts use the same PARDA protocol to ensure fairness, a reasonable assumption in most virtualized clusters. Since hosts run compatible hypervisors, PARDA can be incorporated into the virtualization layer, and remain transparent to the operating systems and applications running within VMs. We show that PARDA can maintain cluster-level latency close to a specified threshold, provide coarse-grained fairness to hosts in proportion to per-host weights, and provide end-to-end storage IO isolation to VMs or applications while handling diverse workloads.</p><p>The next section presents our system model and goals in more detail. Section 3 develops the analogy to network flow control, and introduces our core algorithm, along with extensions for handling bursty workloads. Storage-specific challenges that required extensions beyond network flow control are examined in Section 4. Section 5 evaluates our implementation using a variety of quantitative experiments. Related work is discussed in section 6, while conclusions and directions for future work are presented in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">System Model</head><p>PARDA was designed for distributed systems such as the one shown in <ref type="figure" target="#fig_0">Figure 1</ref>. Multiple hosts access one or more storage arrays connected over a SAN. Disks in storage arrays are partitioned into RAID groups, which are used to construct LUNs. Each LUN is visible as a storage device to hosts and exports a cluster filesystem for distributed access. A VM disk is represented by a file on one of the shared LUNs, accessible from multiple hosts. This facilitates migration of VMs between hosts, avoiding the need to transfer disk state.</p><p>Since each host runs multiple virtual machines, the IO traffic issued by a host is the aggregated traffic of all its VMs that are currently performing IO. Each host maintains a set of pending IOs at the array, represented by an issue queue. This queue represents the IOs scheduled by the host and currently pending at the array; additional requests may be pending at the host, waiting to be issued to the storage array. Issue queues are typically per-LUN and have a fixed maximum issue queue length 1 (e.g., 64 IOs per LUN). IO requests from multiple hosts compete for shared resources at the storage array, such as controllers, cache, interconnects, and disks. As a result, workloads running on one host can adversely impact the performance of workloads on other hosts. To support performance isolation, resource management mechanisms are required to specify and control service rates under contention.</p><p>Resource allocations are specified by numeric shares, which are assigned to VMs that consume IO resources. <ref type="bibr" target="#b1">2</ref> A VM is entitled to consume storage array resources proportional to its share allocation, which specifies the relative importance of its IO requests compared to other VMs. The IO shares associated with a host is simply the total number of per-VM shares summed across all of its VMs. Proportionalshare fairness is defined as providing storage array service to hosts in proportion to their shares.</p><p>In order to motivate the problem of IO scheduling across multiple hosts, consider a simple example with four hosts running a total of six VMs, all accessing a common shared LUN over a SAN. Hosts 1 and 2 each run two Linux VMs configured with OLTP workloads using Filebench <ref type="bibr" target="#b19">[20]</ref>. <ref type="table" target="#tab_0">T h  1  2×OLTP  20, 10  823 Ops/s  413 Ops/s  1240  2  2×OLTP  10, 10  635 Ops/s  635 Ops/s  1250  3  1×Micro  20  710 IOPS  n/a  710  4  1×Micro  10</ref> 730 IOPS n/a 730  <ref type="bibr" target="#b15">[16]</ref> does provide proportionate fairness within each individual host, per-host local schedulers alone are insufficient to provide isolation and proportionate fairness across hosts. For example, note that the aggregate throughput (in IOPS) for hosts 1 and 2 is quite similar, despite their different aggregate share allocations. Similarly, the Iometer VMs on hosts 3 and 4 achieve almost equal performance, violating their specified 2 : 1 share ratio. Many units of allocation have been proposed for sharing IO resources, such as Bytes/s, IOPS, and disk service time. Using Bytes/s or IOPS can unfairly penalize workloads with large or sequential IOs, since the cost of servicing an IO depends on its size and location. Service times are difficult to measure for large storage arrays that service hundreds of IOs concurrently.</p><formula xml:id="formula_0">Host VM Types s 1 , s 2 V M1 V M2</formula><p>In our approach, we conceptually partition the array queue among hosts in proportion to their shares. Thus two hosts with equal shares will have equal queue lengths, but may observe different throughput in terms of Bytes/s or IOPS. This is due to differences in per-IO cost and scheduling decisions made within the array, which may process requests in the order it deems most efficient to maximize aggregate throughput. Conceptually, this effect is similar to that encountered when time-multiplexing a CPU among various workloads. Although workloads may receive equal time slices, they will retire different numbers of instructions due to differences in cache locality and instructionlevel parallelism. The same applies to memory and other resources, where equal hardware-level allocations do not necessarily imply equal application-level progress.</p><p>Although we focus on issue queue slots as our primary fairness metric, each queue slot could alternatively represent a fixed-size IO operation (e.g., 16 KB), thereby providing throughput fairness expressed in Bytes/s. However, a key benefit of managing queue length instead of throughput is that it automatically compensates workloads with lower per-IO costs at the array by allowing them to issue more requests. By considering the actual cost of the work performed by the array, overall efficiency remains higher.</p><p>Since there is no central server or proxy performing IO scheduling, and no support for fairness in the array, a perhost flow control mechanism is needed to enforce specified resource allocations. Ideally, this mechanism should achieve the following goals: (1) provide coarse-grained proportional-share fairness among hosts, (2) maintain high utilization, (3) exhibit low overhead in terms of per-host computation and inter-host communication, and (4) control the overall latency observed by the hosts in the cluster.</p><p>To meet these goals, the flow control mechanism must determine the maximum number of IOs that a host can keep pending at the array. A naive method, such as using static per-host issue queue lengths proportional to each host's IO shares, may provide reasonable isolation, but would not be work-conserving, leading to poor utilization in underloaded scenarios. Using larger static issue queues could improve utilization, but would increase latency and degrade fairness in overloaded scenarios.</p><p>This tradeoff between fairness and utilization suggests the need for a more dynamic approach, where issue queue lengths are varied based on the current level of contention at the array. In general, queue lengths should be increased under low contention for work conservation, and decreased under high contention for fairness. In an equilibrium state, the queue lengths should converge to different values for each host based on their share allocations, so that hosts achieve proportional fairness in the presence of contention.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">IO Resource Management</head><p>In this section we first present the analogy between flow control in networks and distributed storage access. We then explain our control algorithm for providing host-level fairness, and discuss VM-level fairness by combining clusterlevel PARDA flow control with local IO scheduling at hosts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Analogy to TCP</head><p>Our general approach maps the problem of distributed storage management to flow control in networks. TCP running at a host implements flow control based on two signals from the network: round trip time (RTT) and packet loss probability. RTT is essentially the same as IO request latency observed by the IO scheduler, so this signal can be used without modification.</p><p>However, there is no useful analog of network packet loss in storage systems. While networking applications expect dropped packets and handle them using retransmission, typical storage applications do not expect dropped IO requests, which are rare enough to be treated as hard failures.</p><p>Thus, we use IO latency as our only indicator of congestion at the array. To detect congestion, we must be able to distinguish underloaded and overloaded states. This is accomplished by introducing a latency threshold parameter, denoted by L . Observed latencies greater than L may trigger a reduction in queue length. FAST TCP, a recently-proposed variant of TCP, uses packet latency instead of packet loss probability, because loss probability is difficult to estimate accurately in networks with high bandwidth-delay products <ref type="bibr" target="#b14">[15]</ref>. This feature also helps in high-bandwidth SANs, where packet loss is unlikely and TCP-like AIMD (additive increase multiplicative decrease) mechanisms can cause inefficiencies. We use a similar adaptive approach based on average latency to detect congestion at the array.</p><p>Other networking proposals such as RED <ref type="bibr" target="#b8">[9]</ref> are based on early detection of congestion using information from routers, before a packet is lost. In networks, this has the added advantage of avoiding retransmissions. However, most proposed networking techniques that require router support have not been adopted widely, due to overhead and complexity concerns; this is analogous to the limited QoS support in current storage arrays.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">PARDA Control Algorithm</head><p>The PARDA algorithm detects overload at the array based on average IO latency measured over a fixed time period, and adjusts the host's issue queue length (i.e., window size) in response. A separate instance of the PARDA control algorithm executes on each host.</p><p>There are two main components: latency estimation and window size computation. For latency estimation, each host maintains an exponentially-weighted moving average of IO latency at time t, denoted by L(t), to smooth out short-term variations. The weight given to past values is determined by a smoothing parameter α ∈ <ref type="bibr">[0,</ref><ref type="bibr" target="#b0">1]</ref>. Given a new latency observation l,</p><formula xml:id="formula_1">L(t) = (1 − α) × l + α × L(t − 1) (1)</formula><p>The window size computation uses a control mechanism shown to exhibit stable behavior for FAST TCP:</p><formula xml:id="formula_2">w(t + 1) = (1 − γ)w(t) + γ � L L(t) w(t) + β � (2)</formula><p>Here w(t) denotes the window size at time t, γ ∈ [0, 1] is a smoothing parameter, L is the system-wide latency threshold, and β is a per-host parameter that reflects its IO shares allocation.</p><p>Whenever the average latency L &gt; L , PARDA decreases the window size. When the overload subsides and L &lt; L , PARDA increases the window size. Window size adjustments are based on latency measurements, which indicate load at the array, as well as per-host β values, which specify relative host IO share allocations.</p><p>To avoid extreme behavior from the control algorithm, w(t) is bounded by [w min , w max ]. The lower bound w min prevents starvation for hosts with very few IO shares. The upper bound w max avoids very long queues at the array, limiting the latency seen by hosts that start issuing requests after a period of inactivity. A reasonable upper bound can be based on typical queue length values in uncontrolled systems, as well as the array configuration and number of hosts.</p><p>The latency threshold L corresponds to the response time that is considered acceptable in the system, and the control algorithm tries to maintain the overall cluster-wide latency close to this value. Testing confirmed our expectation that increasing the array queue length beyond a certain value doesn't lead to increased throughput. Thus, L can be set to a value which is high enough to ensure that a sufficiently large number of requests can always be pending at the array. We are also exploring automatic techniques for setting this parameter based on long-term observations of latency and throughput. Administrators may alternatively specify L explicitly, based on cluster-wide requirements, such as supporting latency-sensitive applications, perhaps at the cost of under-utilizing the array in some cases.</p><p>Finally, β is set based on the IO shares associated with the host, proportional to the sum of its per-VM shares. It has been shown theoretically in the context of FAST TCP that the equilibrium window size value for different hosts will be proportional to their β parameters <ref type="bibr" target="#b14">[15]</ref>.</p><p>We highlight two properties of the control equation, again relying on formal models and proofs from FAST TCP. First, at equilibrium, the throughput of host i is proportional to β i /q i , where β i is the per-host allocation parameter, and q i is the queuing delay observed by the host. Second, for a single array with capacity C and latency threshold L , the window size at equilibrium will be:</p><formula xml:id="formula_3">w i = β i + β i CL ∑ ∀ j β j (3)</formula><p>To illustrate the behavior of the control algorithm, we simulated a simple distributed system consisting of a single array and multiple hosts using Yacsim <ref type="bibr" target="#b16">[17]</ref>. Each host runs an instance of the algorithm in a distributed manner, and the array services requests with latency based on an exponential distribution with a mean of 1/C. We conducted a series of experiments with various capacities, workloads, and parameter values.</p><p>To test the algorithm's adaptability, we experimented with three hosts using a 1 : 2 : 3 share ratio, L = 200 ms, and an array capacity that changes from 400 req/s to 100 req/s halfway through the experiment. <ref type="figure" target="#fig_1">Figure 2</ref> plots the throughput, window size and average latency observed by the hosts for a period of 200 seconds. As expected, the control algorithm drives the system to operate close to the desired latency threshold L . We also used the simulator to verify that as L is varied (100 ms, 200 ms and 300 ms), the system latencies operate close to L , and that windows sizes increase while maintaining their proportional ratio.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">End-to-End Support</head><p>PARDA flow control ensures that each host obtains a fair share of storage array capacity proportional to its IO shares. However, our ultimate goal for storage resource management is to provide control over service rates for the applications running in VMs on each host. We use a fair queuing mechanism based on SFQ <ref type="bibr" target="#b9">[10]</ref> for our host-level scheduler. SFQ implements proportional-sharing of the host's issue queue, dividing it among VMs based on their IO shares when there is contention for the host-level queue.</p><p>Two key features of the local scheduler are worth noting. First, the scheduler doesn't strictly partition the host-level queue among VMs based on their shares, allowing them to consume additional slots that are left idle by other VMs which didn't consume their full allocation. This handles short-term fluctuations in the VM workloads, and provide some statistical multiplexing benefits. Second, the scheduler doesn't switch between VMs after every IO, instead scheduling a group of IOs per VM as long as they exhibit some spatial locality (within a few MB). These techniques have been shown to improve overall IO performance <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b12">13]</ref>.</p><p>Combining a distributed flow control mechanism with a fair local scheduler allows us to provide end-to-end IO allocations to VMs. However, an interesting alternative is to apply PARDA flow control at the VM level, using per-VM latency measurements to control per-VM window sizes directly, independent of how VMs are mapped to hosts. This approach is appealing, but it also introduces new challenges that we are currently investigating. For example, per-VM allocations may be very small, requiring new techniques to support fractional window sizes, as well as efficient distributed methods to compensate for short-term burstiness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Handling Bursts</head><p>A well-known characteristic of many IO workloads is a bursty arrival pattern-fluctuating resource demand due to device and application characteristics, access locality, and other factors. A high degree of burstiness makes it difficult to provide low latency and achieve proportionate allocation.</p><p>In our environment, bursty arrivals generally occur at two distinct time scales: systematic long-term ON-OFF behavior of VMs, and sudden short-term spikes in IO workloads. To handle long-term bursts, we modify the β value for a host based on the utilization of queue slots by its resident VMs. Recall that the host-level parameter β is proportional to the sum of shares of all VMs (if s i are the shares assigned to VM i, then for host h, β h = K × ∑ i s i , where K is a normalization constant).</p><p>To adjust β , we measure the average number of outstanding IOs per VM, n k , and each VM's share of its host window size as w k , expressed as:</p><formula xml:id="formula_4">w k = s k ∑ i s i w(t)<label>(4)</label></formula><p>If (n k &lt; w k ), we scale the shares of the VM to be s ′ i = n k × s k /w k and use this to calculate β for the host. Thus if a VM is not fully utilizing its window size, we reduce the β value of its host, so other VMs on the same host do not benefit disproportionately due to the under-utilized shares of a colocated idle VM. In general, when one or more VMs become idle, the control mechanism will allow all hosts (and thus all VMs) to proportionally increase their window sizes and exploit the spare capacity. For short-term fluctuations, we use a burst-aware local scheduler. This scheduler allows VMs to accumulate a bounded number of credits while idle, and then schedule requests in bursts once the VM becomes active. This also improves overall IO efficiency, since requests from a single VM typically exhibit some locality. A number of schedulers support bursty allocations <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b21">22]</ref>. Our implementation uses SFQ as the local scheduler, but allows a bounded number of IOs to be batched from each VM instead of switching among VMs purely based on their SFQ request tags.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Storage-Specific Challenges</head><p>Storage devices are stateful and their throughput can be quite variable, making it challenging to apply the latencybased flow control approaches used in networks. Equilibrium may not be reached if different hosts observe very different latencies during overload. Next we discuss three key issues to highlight the differences between storage and network service times.</p><p>Request Location. It is well known that the latency of a request can vary from a fraction of a millisecond to tens of milliseconds, based on its location compared to previous requests, as well as caching policies at the array. Variability in seek and rotational delays can cause an order of magnitude difference in service times. This makes it difficult to estimate the baseline IO latency corresponding to the latency with no queuing delay. Thus a sudden change in average latency or in the ratio of current values to the previous average may or may not be a signal for overload. Instead, we look at average latency values in comparison to a latency threshold L to predict congestion. The assumption is that latencies observed during congestion will have a large queuing delay component, outweighing increases due to workload changes (e.g., sequential to random).</p><p>Request Type. Write IOs are often returned to the host once the block is written in the controller's NVRAM. Later, they are flushed to disk during the destage process. However, read IOs may need to go to disk more often. Similarly, two requests from a single stream may have widely varying latencies if one hits in the cache and the other misses. In certain RAID systems <ref type="bibr" target="#b4">[5]</ref>, writes may take four times longer than reads due to parity reads and updates. In general, IOs from a single stream may have widely-varying response times, affecting the latency estimate. Fortunately, a moving average over a sufficiently long period can absorb such variations and provide a more consistent estimate. IO Size. Typical storage IO sizes range from 512 bytes to 256 KB, or even 1 MB for more recent devices. The estimator needs to be aware of changing IO size in the workload. This can be done by computing latency per 8 KB instead of latency per IO using a linear model with certain fixed costs. Size variance is less of an issue in networks since most packets are broken into MTU-size chunks (typically 1500 bytes) before transmission.</p><p>All of these issues essentially boil down to the problem of estimating highly-variable latency and using it as an indicator of array overload. We may need to distinguish between latency changes caused by workload versus those due to the overload at the array. Some of the variation in IO latency can be absorbed by long-term averaging, and by considering latency per fixed IO size instead of per IO request. Also, a sufficiently high baseline latency (the desired operating point for the control algorithm, L ) will be insensitive to workload-based variations in under-utilized cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Distributed Implementation Issues</head><p>We initially implemented PARDA in a completely distributed manner, where each host monitored only its own IO latency to calculate L(t) for Equation 2 (referred to as local latency estimation). However, despite the use of averaging, we found that latencies observed at different hosts were dependent on block-level placement.</p><p>We experimented with four hosts, each running one Windows Server 2003 VM configured with a 16 GB data disk created as a contiguous file on the shared LUN. Each VM also has a separate 4 GB system disk. The storage array was an EMC CLARiiON CX3-40 (same hardware setup as in Section 5). Each VM executed a 16 KB random read IO workload. Running without any control algorithm, we noticed that the hosts observed average latencies of 40.0, 34.5, 35.0 and 39.5 ms, respectively. Similarly, the throughput observed by the hosts were 780, 910, 920 and 800 IOPS respectively. Notice that hosts two and three achieved better IOPS and lower latency, even though all hosts were issuing exactly the same IO pattern.</p><p>We verified that this discrepancy is explained by placement: the VM disks (files) were created and placed in order on the underlying device/LUN, and the middle two virtual disks exhibited better performance compared to the two outer disks. We then ran the control algorithm with latency threshold L = 30 ms and equal β for all hosts. <ref type="figure">Figure 3</ref> plots the computed window size, latency and throughput over a period of time. The discrepancy in latencies observed across hosts leads to divergence in the system. When hosts two and three observe latencies smaller than L , they increase their window size, whereas the other two hosts still see latencies higher than L , causing further window size decreases. This undesirable positive feedback loop leads to a persistent performance gap.</p><p>To validate that this effect is due to block placement of VM disks and array level scheduling, we repeated the same experiment using a single 60 GB shared disk. This disk file was opened by all VMs using a "multi-writer" mode. Without any control, all hosts observed a throughput of ∼ 790 IOPS and latency of 39 ms. Next we ran with PARDA on the shared disk, again using equal β and L = 30 ms. <ref type="figure">Figure 4</ref> shows that the window sizes of all hosts are reduced, and the cluster-wide latency stays close to 30 ms.</p><p>This led us to conclude that, at least for some disk subsystems, latency observations obtained individually at each host for its IOs are a fragile metric that can lead to divergences. To avoid this problem, we instead implemented a robust mechanism that generates a consistent signal for contention in the entire cluster, as discussed in the next section. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Latency Aggregation</head><p>After experimenting with completely decentralized approaches and encountering the divergence problem detailed above, we implemented a more centralized technique to compute cluster-wide latency as a consistent signal. The aggregation doesn't need to be very accurate, but it should be reasonably consistent across hosts. There are many ways to perform this aggregation, including approximations based on statistical sampling. We discuss two different techniques that we implemented for our prototype.</p><p>Network-Based Aggregation. Each host uses a UDP socket to listen for statistics advertised by other hosts. The statistics include the average latency and number of IOs per LUN. Each host either broadcasts its data on a common subnet, or sends it to every other host individually. This is an instance of the general average-and sum-aggregation problem for which multicast-based solutions also exist <ref type="bibr" target="#b28">[29]</ref>.</p><p>Filesystem-Based Aggregation. Since we are trying to control access to a shared filesystem volume (LUN), it is convenient to use the same medium to share the latency statistics among the hosts. We implement a shared file per volume, which can be accessed by multiple hosts simultaneously. Each host owns a single block in the file and periodically writes its average latency and number of IOs for the LUN into that block. Each host reads that file periodically using a single large IO and locally computes the clusterwide average to use for window size estimation.</p><p>In our experiments, we have not observed extremely high variance across per-host latency values, although this seems possible if some workloads are served primarily from the storage array's cache. In any case, we do not anticipate that this would affect PARDA stability or convergence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Evaluation</head><p>In this section, we present the results from a detailed evaluation of PARDA in a real system consisting of up to eight hosts accessing a shared storage array. Each host is a Dell Poweredge 2950 server with 2 Intel Xeon 3.0 GHz dual-core processors, 8 GB of RAM and two Qlogic HBAs connected to an EMC CLARiiON CX3-40 storage array over a Fibre Channel SAN. The storage volume is hosted on a 10-disk RAID-5 disk group on the array.</p><p>Each host runs the VMware ESX Server hypervisor <ref type="bibr" target="#b23">[24]</ref> with a local instance of the distributed flow control algorithm. The aggregation of average latency uses the filesystem-based implementation described in Section 4.2, with a two-second update period. All PARDA experiments used the smoothing parameters α = 0.002 and γ = 0.8.</p><p>Our evaluation consists of experiments that examine five key questions: (1) How does average latency vary with changes in workload? (2) How does average latency vary with load at the array? (3) Can the PARDA algorithm adjust issue queue lengths based on per-host latencies to provide differentiated service? (4) How well can this mechanism 7th USENIX Conference on File and Storage Technologies USENIX Association handle bursts and idle hosts? (5) Can we provide endto-end IO differentiation using distributed flow control together with a local scheduler at each host? Our first two experiments determine whether average latency can be used as a reliable indicator to detect overload at the storage array, in the presence of widely-varying workloads. The third explores how effectively our control module can adjust host queue lengths to provide coarse-grained fairness. The remaining experiments examine how well PARDA can deal with realistic scenarios that include workload fluctuations and idling, to provide end-to-end fairness to VMs. Throughout this section, we will provide data using a variety of parameter settings to illustrate the adaptability and robustness of our algorithm. We first consider a single host running one VM executing different workloads, to examine the variation in average latency measured at the host. A Windows Server 2003 VM running Iometer <ref type="bibr" target="#b0">[1]</ref> is used to generate each workload, configured to keep 8 IOs pending at all times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Latency vs. Workload</head><p>We varied three workload parameters: reads -0 to 100%, IO size -4, 32, 64, and 128 KB, and sequentiality -0 to 100%. For each combination, we measured throughput, bandwidth, and the average, min and max latencies.</p><p>Over all settings, the minimum latency was observed for the workload consisting of 100% sequential 4 KB reads, while the maximum occurred for 100% random 128 KB writes. Bandwidth varied from 8 MB/s to 177 MB/s. These results show that bandwidth and latency can vary by more than a factor of 20 due solely to workload variation. <ref type="figure" target="#fig_3">Figure 5</ref> plots the average latency (in ms) measured for a VM while varying IO size and degree of sequentiality. Due to space limitations, plots for other parameters have been omitted; additional results and details are available in <ref type="bibr" target="#b10">[11]</ref>.</p><p>There are two main observations: (1) the absolute latency value is not very high for any configuration, and (2) latency usually increases with IO size, but the slope is small because transfer time is usually dominated by seek and ro-  tational delays. This suggests that array overload can be detected by using a fairly high latency threshold value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Latency vs. Queue Length</head><p>Next we examine how IO latency varies with increases in overall load (queue length) at the array. We experimented with one to five hosts accessing the same array. Each host generates a uniform workload of 16 KB IOs, 67% reads and 70% random, keeping 32 IOs outstanding. <ref type="figure">Figure 6</ref> shows the aggregate throughput and average latency observed in the system, with increasing contention at the array. Throughput peaks at three hosts, but overall latency continues to increase with load. Ideally, we would like to operate at the lowest latency where bandwidth is high, in order to fully utilize the array without excessive queuing delay.</p><p>For uniform workloads, we also expect a good correlation between queue size and overall throughput. To verify this, we configured seven hosts to access a 400 GB volume on a 5-disk RAID-5 disk group. Each host runs one VM with an 8 GB virtual disk. We report data for a workload of 32 KB IOs with 67% reads, 70% random and 32 IOs pending. <ref type="figure" target="#fig_4">Figure 7</ref> presents results for two different static host-level window size settings: (a) 32 for all hosts and (b) 16 for hosts 5, 6 and 7.</p><p>We observe that the VMs on the throttled hosts receive approximately half the throughput (∼ 42 IOPS) compared to other hosts (∼ 85 IOPS) and their latency (∼ 780 ms) is doubled compared to others (∼ 360 ms). Their reduced performance is a direct result of throttling, and the increased latency arises from the fact that a VM's IOs were queued at its host. The device latency measured at the hosts (as opposed to in the VM, which would include time spent in host queues) is similar for all hosts in both experiments. The overall latency decreases when one or more hosts are throttled, since there is less load on the array. For example, in the second experiment, the overall average latency changes from ∼ 470 ms at each host to ∼ 375 ms at each host when the window size is 16 for hosts 5, 6, and 7. We also experimented with four hosts sending different workloads to the array while we varied their queue lengths in two phases. <ref type="table" target="#tab_2">Table 2</ref> reports the workload description and corresponding throughput and latency values observed at the hosts. In phase 1, each host has a queue length of 32 while in phase 2, we lowered the queue length for two of the hosts to 16. This experiment demonstrates two important properties. First, overall throughput reduces roughly in proportion to queue length. Second, if a host is receiving higher throughput at some queue length Q due to its workload being treated preferentially, then even for a smaller queue length Q/2, the host still obtains preferential treatment from the array. This is desirable because overall efficiency is improved by giving higher throughput to request streams that are less expensive for the array to process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">PARDA Control Method</head><p>In this section, we evaluate PARDA by examining fairness, latency threshold effects, robustness with non-uniform workloads, and adaptation to capacity changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Fairness</head><p>We experimented with identical workloads accessing 16 GB virtual disks from four hosts with equal β values. This is similar to the setup that led to divergent behavior in <ref type="figure">Fig- ure 3</ref>. Using our filesystem-based aggregation, PARDA converges as desired, even in the presence of different latency values observed by hosts. <ref type="table" target="#tab_4">Table 3</ref> presents results for this workload without any control, and with PARDA using equal shares for each host; plots are omitted due to space constraints. With PARDA, latencies drop, making the overall average close to the target L . The aggregate throughput achieved by all hosts is similar with and without PARDA, exhibiting good work-conserving behavior. This demonstrates that the algorithm works correctly in the simple case of equal shares and uniform workloads.  Next, we experimented with a share ratio of 1 : 1 : 2 : 2 for four hosts, setting L = 25 ms, shown in <ref type="figure">Figure 8</ref>. PARDA converges on windows sizes for hosts 1 and 2 that are roughly half those for hosts 3 and 4, demonstrating good fairness. The algorithm also successfully converges latencies to L . Finally, the per-host throughput levels achieved while running this uniform workload also roughly match the specified share ratio. The remaining differences are due to some hosts obtaining better throughput from the array, even with the same window size. This reflects the true IO costs as seen by the array scheduler; since PARDA operates on window sizes, it maintains high efficiency at the array.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Effect of Latency Threshold</head><p>Recall that L is the desired latency value at which the array provides high throughput but small queuing delay. Since PARDA tries to operate close to L , an administrator can control the overall latencies in a cluster, bounding IO times for latency-sensitive workloads such as OLTP. We investigated the effect of the threshold setting by running PARDA with different L values. Six hosts access the array concurrently, each running a VM with a 16 GB disk performing 16 KB random reads with 32 outstanding IOs. We first examine the throughput and latency observed in the uncontrolled case, presented in <ref type="table">Table 4</ref>. In <ref type="figure">Figure 9</ref> These results demonstrate that PARDA is able to control latencies by throttling IO from hosts. Note the different window sizes at which hosts operate for different values of L . <ref type="figure">Figure 9</ref>(a) also highlights the adaptation of window sizes, as more capacity becomes available at the array when VMs are turned off at various points in the experiment. The ability to detect capacity changes through changes in latency is an important dynamic property of the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.3">Non-Uniform Workloads</head><p>To test PARDA and its robustness with mixed workloads, we ran very different workload patterns at the same time from our six hosts. <ref type="table">Table 5 presents the uncontrolled case.</ref> Next, we enable PARDA with L = 40 ms, and assign shares in a 2 : 1 : 2 : 1 : 2 : 1 ratio for hosts 1 through 6 respectively, plotted in <ref type="figure" target="#fig_0">Figure 10</ref>. shares reach a window size of 32 (the upper bound, w max ) and remain there. Other hosts have window sizes close to 19. The average latency observed by the hosts remains close to L , as shown in <ref type="figure" target="#fig_0">Figure 10</ref>(b). The throughput observed by hosts follows roughly the same pattern as window sizes, but is not always proportional because of array scheduling and block placement issues. We saw similar adaptation in window sizes and latency when we repeated this experiment using L = 30 ms (plots omitted due to space constraints).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.4">Capacity Changes</head><p>Storage capacity can change dramatically due to workload changes or array accesses by uncontrolled hosts external to PARDA. We have already demonstrated in Section 5.3.2 that our approach is able to absorb any spare capacity that becomes available. To test the ability of the control algorithm to handle decreases in capacity, we conducted an experiment starting with the first five hosts from the previous  With L = 30 ms and a share ratio of 2 : 2 : 1 : 1 : 1 for the PARDA-managed hosts, <ref type="figure" target="#fig_0">Figure 11</ref> plots the usual metrics over time. At t = 230 s, the uncontrolled external host starts, thereby reducing available capacity for the five controlled hosts. The results indicate that as capacity changes, the hosts under control adjust their window sizes in proportion to their shares, and observe latencies close to L .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">End-to-End Control</head><p>We now present an end-to-end test where multiple VMs run a mix of realistic workloads with different shares. We use Filebench <ref type="bibr" target="#b19">[20]</ref>, a well-known IO modeling tool, to generate an OLTP workload similar to TPC-C. We employ four VMs running Filebench, and two generating 16 KB random reads. A pair of Filebench VMs are placed on each of two hosts, whereas the micro-benchmark VMs occupy one host each. This is exactly the same experiment discussed in Section 2; data for the uncontrolled baseline case is presented in <ref type="table" target="#tab_0">Table 1</ref>. Recall that without PARDA, hosts 1 and 2 obtain similar throughput even though the overall sum of their VM shares is different.  We run PARDA (L = 25 ms) with host weights (β h ) set according to shares of their VMs (β h = 6 : 4 : 4 : 2 for hosts 1 to 4). The maximum window size w max is 64 for all hosts. The OLTP VMs on host 1 receive 1266 and 591 Ops/s, matching their 2 : 1 share ratio. Similarly, OLTP VMs on host 2 obtain 681 and 673 Ops/s, close to their 1 : 1 share ratio. Note that the overall Ops/s for hosts 1 and 2 have a 3 : 2 ratio, which is not possible in an uncontrolled scenario. <ref type="figure" target="#fig_0">Figure 12</ref> plots the window size, latency and throughput observed by the hosts. We note two key properties: (1) window sizes are in proportion to the overall β values and (2) each VM receives throughput in proportion to its shares. This shows that PARDA provides the strong property of enforcing VM shares, independent of their placement on hosts. The local SFQ scheduler divides host-level capacity across VMs in a fair manner, and together with PARDA, is able to provide effective end-to-end isolation among VMs. to test our burst-handling mechanism, which we discuss in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Handling Bursts</head><p>Earlier we showed that PARDA maintains high utilization of the array even when some hosts idle, by allowing other hosts to increase their window sizes. However, if one or more VMs become idle, the overall β of the host must be adjusted, so that backlogged VMs on the same host don't obtain an unfair share of the current capacity. Our implementation employs the technique described in Section 3.4.</p><p>We experimented with dynamically idling one of the OLTP VM workloads running on host 1 from the previous experiment presented in <ref type="figure" target="#fig_0">Figure 12</ref>. The VM workload is stopped at t = 140 s and resumed at t = 310 s. <ref type="figure" target="#fig_0">Figure 13</ref> shows that the β value for host 1 adapts quickly to the change in the VM workload. <ref type="figure" target="#fig_0">Figure 12(a)</ref> shows that the window size begins to decrease according to the modified lower value of β = 4 starting from t = 140 s. By t = 300 s, window sizes have converged to a 1 : 2 ratio, in line with aggregate host shares. As the OLTP workload becomes active again, the dynamic increase in the β of host 1 causes its window size to grow. This demonstrates that PARDA ensures fairness even in the presence of non-backlogged workloads, a highly-desirable property for shared storage access.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Enterprise Workloads</head><p>To test PARDA with more realistic enterprise workloads, we experimented with two Windows Server 2003 VMs, each running a Microsoft SQL Server 2005 Enterprise Edition database. Each VM is configured with 4 virtual CPUs, 6.4 GB of RAM, a 10 GB system disk, a 250 GB database disk, and a 50 GB log disk. The database virtual disks are hosted on an 800 GB RAID-0 LUN with 6 disks; log virtual disks are placed on a 100 GB RAID-0 LUN with 10 disks. We used the Dell DVD store (DS2) database test suite, which implements a complete online e-commerce application, to stress the SQL databases <ref type="bibr" target="#b6">[7]</ref>. We configured a 15 ms latency threshold, and ran one VM per host, assigning shares in a 1 : 4 ratio. <ref type="table" target="#tab_11">Table 7</ref> reports the parameters and the overall application performance for the two SQL Server VMs. Without PARDA, both VMs have similar performance in terms of both orders per minute (OPM) and average latency. When running with PARDA, the VM with higher shares obtains roughly twice the OPM throughput and half the average latency. The ratio isn't 1 : 4 because the workloads are not always backlogged, and the VM with higher shares can't keep its window completely full. <ref type="figure" target="#fig_0">Figure 14</ref> plots the window size, latency and throughput observed by the hosts. As the overall latency decreases, PARDA is able to assign high window sizes to both hosts. When latency increases, the window sizes converge to be approximately proportional to the β values. <ref type="figure" target="#fig_0">Figure 15</ref> shows the β values for the hosts while the workload is running, and highlights the fact that the SQL Server VM on host 2 cannot always maintain enough pending IOs to fill its window. This causes the other VM on host 1 to pick up the slack and benefit from increased IO throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>The research literature contains a large body of work related to providing quality of service in both networks and storage systems, stretching over several decades. Numerous algorithms for network QoS have been proposed, including many variants of fair queuing <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b9">10]</ref>. However, these approaches are suitable only in centralized settings where a single controller manages all requests for resources. Stoica proposed QoS mechanisms based on a stateless core <ref type="bibr" target="#b22">[23]</ref>, where only edge routers need to maintain per-flow state, but some minimal support is still required from core routers.</p><p>In the absence of such mechanisms, TCP has been serving us quite well for both flow control and congestion avoidance. Commonly-deployed TCP variants use per-flow information such as estimated round trip time and packet loss at each host to adapt per-flow window sizes to network conditions. Other proposed variants <ref type="bibr" target="#b8">[9]</ref> require support from routers to provide congestion signals, inhibiting adoption.</p><p>FAST-TCP <ref type="bibr" target="#b14">[15]</ref> provides a purely latency-based approach to improving TCP's throughput in high bandwidthdelay product networks. In this paper we adapt some of the techniques used by TCP and its variants to perform flow control in distributed storage systems. In so doing, we have addressed some of the challenges that make it non-trivial to employ TCP-like solutions for managing storage IO.</p><p>Many storage QoS schemes have also been proposed to provide differentiated service to workloads accessing a single disk or storage array <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b29">30]</ref>. Unfortunately, these techniques are centralized, and generally require full control over all IO. Proportionate bandwidth allocation algorithms have also been developed for distributed storage systems <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b25">26]</ref>. However, these mechanisms were designed for brick-based storage, and require each storage device to run an instance of the scheduling algorithm.</p><p>Deployments of virtualized systems typically have no control over storage array firmware, and don't use a central IO proxy. Most commercial storage arrays offer only limited, proprietary quality-of-service controls, and are treated as black boxes by the virtualization layer. Triage <ref type="bibr" target="#b17">[18]</ref> is one control-theoretic approach that has been proposed for managing such systems. Triage periodically observes the utilization of the system and throttles hosts using bandwidth caps to achieve a specified share of available capacity. This technique may underutilize array resources, and relies on a central controller to gather statistics, compute an online system model, and re-assign bandwidth caps to hosts. Host-level changes must be communicated to the controller to handle bursty workloads. In contrast, PARDA only requires very light-weight aggregation and per-host measurement and control to provide fairness with high utilization.</p><p>Friendly VMs <ref type="bibr" target="#b30">[31]</ref> propose cooperative fair sharing of CPU and memory in virtualized systems leveraging feedback-control models. Without relying on a centralized controller, each "friendly" VM adapts its own resource consumption based on congestion signals, such as the relative progress of its virtual time compared to elapsed real time, using TCP-like AIMD adaptation. PARDA applies similar ideas to distributed storage resource management.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>In this paper, we studied the problem of providing coarse-grained fairness to multiple hosts sharing a single storage system in a distributed manner. We propose a novel software system, PARDA, which uses average latency as an indicator for array overload and adjusts per-host issue queue lengths in a decentralized manner using flow control.</p><p>Our evaluation of PARDA in a hypervisor shows that it is able to provide fair access to the array queue, control overall latency close to a threshold parameter and provide high throughput in most cases. Moreover, combined with a local scheduler, PARDA is able to provide end-to-end prioritization of VM IOs, even in presence of variable workloads.</p><p>As future work, we are trying to integrate soft limits and reservations to provide a complete IO management framework. We would also like to investigate applications of PARDA to other non-storage systems where resource management must be implemented in a distributed fashion.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Storage array accessed by distributed hosts/VMs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Simulation of three hosts with 1 : 2 : 3 share ratio. Array capacity is reduced from 400 to 100 req/s at t = 100 s.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :Figure 4 :</head><label>34</label><figDesc>Figure 3: Local L(t) Estimation. Separate VM disks cause window size divergence due to block placement and unfair array scheduling.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Latency as a function of IO size and sequentiality.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: VM bandwidth and latency observed when queue length Q = 32 for all hosts, and when Q = 16 for some hosts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :Figure 9 :</head><label>89</label><figDesc>Figure 8: PARDA Fairness. Four hosts each run a 16 KB random read workload with β values of 1 : 1 : 2 : 2. Window sizes allocated by PARDA are in proportion to β values, and latency is close to the specified threshold L = 25 ms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 10 :Figure 11 :</head><label>1011</label><figDesc>Figure 10: Non-Uniform Workloads. PARDA control with L = 40 ms. Six hosts run mixed workloads, with β values 2 : 1 : 2 : 1 : 2 : 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 12 :Figure 13 :</head><label>1213</label><figDesc>Figure 12: PARDA End-to-End Control. VM IOPS are proportional to shares. Host window sizes are proportional to overall β values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 14 :Figure 15 :</head><label>1415</label><figDesc>Figure 14: Enterprise Workload. Host window sizes and IOPS for SQL Server VMs are proportional to their overall β values whenever the array resources are contended. Between t = 300 s and t = 380 s, hosts get larger window sizes since the array is not contended.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Local scheduling does not achieve inter-host fairness. 
Four hosts running six VMs without PARDA. Hosts 1 and 2 each 
run two OLTP VMs, and hosts 3 and 4 each run one micro-
benchmark VM issuing 16 KB random reads. Configured shares 
(s i ), Filebench operations per second (Ops/s), and IOPS (T h for 
hosts) are respected within each host, but not across hosts. 

Hosts 3 and 4 each run a Windows Server 2003 VM with 
Iometer [1], configured to generate 16 KB random reads. 
Table 1 shows that the VMs are configured with different 
share values, entitling them to consume different amounts 
of IO resources. Although a local start-time fair queuing 
(SFQ) scheduler </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 2 :</head><label>2</label><figDesc>Throughput (T IOPS) and latencies (L ms) observed by four hosts for different workloads and queue lengths (Q).</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 3 :</head><label>3</label><figDesc>Fairness with 16 KB random reads from four hosts.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head></head><label></label><figDesc>Window sizes are differen- tiated between hosts with different shares. Hosts with more</figDesc><table>Host Size 
Read Random IOPS Latency (ms) 
1 
4K 100% 
100% 
610 
51 
2 
8K 
50% 
0% 
660 
48 
3 
8K 100% 
100% 
630 
50 
4 
8K 
67% 
60% 
670 
47 
5 
16K 100% 
100% 
490 
65 
6 
16K 
75% 
70% 
520 
60 
Table 5: Uncontrolled access by mixed workloads from six hosts. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="true"><head>Table 6 provides</head><label>6</label><figDesc>setup details and reports data using PARDA control. Results for the OLTP VMs are presented as Filebench operations per second (Ops/s).</figDesc><table>Host VM Type 
s 1 , s 2 

β h 

VM1 
VM2 
T h 
1 
2×OLTP 
20, 10 
6 
1266 Ops/s 591 Ops/s 
1857 
2 
2×OLTP 
10, 10 
4 
681 Ops/s 673 Ops/s 
1316 
3 
1×Micro 
20 
4 
740 IOPS 
n/a 
740 
4 
1×Micro 
10 
2 
400 IOPS 
n/a 
400 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>Table 6 :), host weights (β h ), Ops/s for Filebench VMs and IOPS (T h for hosts) are respected across hosts. L = 25 ms, w max = 64.</head><label>6</label><figDesc></figDesc><table>PARDA end-to-end control for Filebench OLTP and 
micro-benchmark VMs issuing 16 KB random reads. Configured 
shares (s i </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>Table 7 :T h for hosts) and latencies (Avg Lat for database operations, L h for hosts, in ms). L = 15 ms, w max = 32.</head><label>7</label><figDesc></figDesc><table>Two SQL Server VMs with 1 : 4 share ratio, run-
ning with and without PARDA. Host weights (β h ) and OPM (or-
ders/min), IOPS (</table></figure>

			<note place="foot" n="1"> The terms queue length, queue depth, and queue size are used interchangeably in the literature. In this paper, we will also use the term window size, which is common in the networking literature. 2 Shares are alternatively referred to as weights in the literature. Although we use the term VM to be concrete, the same proportional-share framework can accommodate other abstractions of resource consumers, such as applications, processes, users, or groups.</note>

			<note place="foot" n="7">th USENIX Conference on File and Storage Technologies USENIX Association</note>

			<note place="foot" n="7">th USENIX Conference on File and Storage Technologies USENIX Association</note>

			<note place="foot" n="7">th USENIX Conference on File and Storage Technologies USENIX Association</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Thanks to Tim Mann, Minwen Ji, Anne Holler, Neeraj Goyal, Narasimha Raghunandana and our shepherd Jiri Schindler for valuable discussions and feedback. Thanks also to Chethan Kumar for help with experimental setup.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Iometer</surname></persName>
		</author>
		<ptr target="http://www.iometer.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">W F 2 Q: Worst-case fair weighted fair queueing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bennett</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE INFOCOM &apos;96</title>
		<meeting>of IEEE INFOCOM &apos;96</meeting>
		<imprint>
			<date type="published" when="1996-03" />
			<biblScope unit="page" from="120" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Disk scheduling with quality of service guarantees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruno</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Brustoloni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gabber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ozden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sil-Berschatz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IEEE Int&apos;l Conf. on Multimedia Computing and Systems</title>
		<meeting>of the IEEE Int&apos;l Conf. on Multimedia Computing and Systems</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1999" />
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Performance virtualization for large-scale storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chambliss</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">D</forename><surname>Alvarez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">A</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Jadav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Reliable Distributed Systems</title>
		<imprint>
			<date type="published" when="2003-10" />
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">RAID: High-performance, reliable secondary storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">K</forename><surname>Gibson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">A</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patterson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Quality of service guarantees in virtual circuit switched networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cruz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="1048" to="1056" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dell</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Inc</forename><surname>Store</surname></persName>
		</author>
		<ptr target="http://delltechcenter.com/page/DVD+store" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Analysis and simulation of a fair queuing algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Demers</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Keshav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shenker</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Internetworking Research and Experience</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="26" />
			<date type="published" when="1990-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Random early detection gateways for congestion avoidance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Floyd</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacobson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="397" to="413" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Start-time fair queueing: a scheduling algorithm for integrated services packet switching networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Goyal</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cheng</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Towards distributed storage resource management using flow control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gulati</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of First International Workshop on Storage and I/O Virtualization, Performance, Energy, Evaluation and Dependability</title>
		<meeting>of First International Workshop on Storage and I/O Virtualization, Performance, Energy, Evaluation and Dependability</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Distributed QoS in heterogeneous resource environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gulati</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Merchant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Varman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dclock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM PODC</title>
		<meeting>of ACM PODC</meeting>
		<imprint>
			<date type="published" when="2007-08" />
		</imprint>
	</monogr>
	<note>short paper</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">pClock: An arrival curve based approach for QoS in shared storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gulati</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Merchant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Varman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGMETRICS</title>
		<meeting>of ACM SIGMETRICS</meeting>
		<imprint>
			<date type="published" when="2007-06" />
			<biblScope unit="page" from="13" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multi-dimensional storage virtualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Huang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chiueh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIGMETRICS</title>
		<meeting>of ACM SIGMETRICS</meeting>
		<imprint>
			<date type="published" when="2004-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And Low</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Fast</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tcp</surname></persName>
		</author>
		<title level="m">Motivation, Architecture, Algorithms, Performance. Proceedings of IEEE INFOCOM &apos;04</title>
		<imprint>
			<date type="published" when="2004-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Interposed proportional sharing for a storage service utility</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Chase</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaur</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMETRICS</title>
		<imprint>
			<date type="published" when="2004-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Yacsim reference manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jump</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename></persName>
		</author>
		<ptr target="http://www.owlnet.rice.edu/∼elec428/yacsim/yacsim.man.ps" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Triage: Performance differentiation for storage systems using adaptive control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karlsson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Karamanolis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Storage</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="457" to="480" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Façade: Virtual storage devices with performance guarantees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lumb</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Merchant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alvarez</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of File and Storage Technologies (FAST)</title>
		<meeting>of File and Storage Technologies (FAST)</meeting>
		<imprint>
			<date type="published" when="2003-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">A prototype model based workload for file systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mcdougall</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Filebench</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>work in progress</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Efficient guaranteed disk request scheduling with Fahrrad</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Povzner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaldewey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Golding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maltzahn</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="13" to="25" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Scheduling for quality of service guarantees via service curves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sariowan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Cruz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Polyzos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Computer Communications and Networks</title>
		<meeting>the International Conference on Computer Communications and Networks</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="512" to="520" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Core-stateless fair queueing: A scalable architecture to approximate fair bandwidth allocations in high speed networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stoica</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="33" to="46" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Introduction to VMware Infrastructure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vmware</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Inc</forename></persName>
		</author>
		<ptr target="http://www.vmware.com/support/pubs/" />
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Argon: performance insulation for shared storage servers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wachs</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abd-El-Malek</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Thereska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ganger</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of File and Storage Technologies (FAST)</title>
		<meeting>of File and Storage Technologies (FAST)</meeting>
		<imprint>
			<date type="published" when="2007-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Proportional-share scheduling for distributed storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And Merchant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of File and Storage Technologies (FAST)</title>
		<meeting>of File and Storage Technologies (FAST)</meeting>
		<imprint>
			<date type="published" when="2007-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Storage performance as a managed resource</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wong</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename><surname>Golding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And Becker-Szendy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Zygaria</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Real-Time and Embedded Technology and Applications Symposium</title>
		<meeting>of Real-Time and Embedded Technology and Applications Symposium</meeting>
		<imprint>
			<date type="published" when="2006-04" />
			<biblScope unit="page" from="125" to="159" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The design and implementation of Aqua: an adaptive quality of service aware object-based storage device</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>And Brandt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of MSST</title>
		<meeting>of MSST</meeting>
		<imprint>
			<date type="published" when="2006-05" />
			<biblScope unit="page" from="209" to="227" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A scalable distributed information management system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yalagandula</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SIGCOMM</title>
		<meeting>of SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="379" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Storage performance virtualization via throughput and latency control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sivasubramaniam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Riska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Riedel</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of MASCOTS</title>
		<meeting>of MASCOTS</meeting>
		<imprint>
			<date type="published" when="2005-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Friendly virtual machines: leveraging a feedback-control model for application adaptation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bestavros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Guirguis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Matta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">West</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Intl. Conference on Virtual Execution Environments (VEE)</title>
		<meeting>of Intl. Conference on Virtual Execution Environments (VEE)</meeting>
		<imprint>
			<date type="published" when="2005-06" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
