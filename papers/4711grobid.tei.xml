<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:29+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Exploiting Uses of Uninitialized Stack Variables in Linux Kernels to Leak Kernel Pointers</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haehyun</forename><surname>Cho</surname></persName>
							<email>haehyun@asu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Arizona State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jinbum</forename><surname>Park</surname></persName>
							<email>jinb.park@samsung.com</email>
							<affiliation key="aff1">
								<orgName type="department">Samsung Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joonwon</forename><surname>Kang</surname></persName>
							<email>joonwon.kang@samsung.com</email>
							<affiliation key="aff1">
								<orgName type="department">Samsung Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tiffany</forename><surname>Bao</surname></persName>
							<email>tbao@asu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Arizona State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruoyu</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Arizona State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yan</forename><surname>Shoshitaishvili</surname></persName>
							<email>yans@asu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Arizona State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Doupé</surname></persName>
							<email>doupe@asu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Arizona State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gail-Joon</forename><surname>Ahn</surname></persName>
							<email>gahn@asu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">Arizona State University</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Samsung Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Exploiting Uses of Uninitialized Stack Variables in Linux Kernels to Leak Kernel Pointers</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Information leaks are the most prevalent type of vulnerabili-ties among all known vulnerabilities in Linux kernel. Many of them are caused by the use of uninitialized variables or data structures. It is generally believed that the majority of information leaks in Linux kernel are low-risk and do not have severe impact due to the difficulty (or even the impossibility) of exploitation. As a result, developers and security analysts do not pay enough attention to mitigating these vul-nerabilities. Consequently, these vulnerabilities are usually assigned low CVSS scores or without any CVEs assigned. Moreover, many patches that address uninitialized data use bugs in Linux kernel are not accepted, leaving billions of Linux systems vulnerable. Nonetheless, information leak vulnerabilities in Linux kernel are not as low-risk as people believe. In this paper, we present a generic approach that converts stack-based information leaks in Linux kernel into kernel-pointer leaks, which can be used to defeat modern security defenses such as KASLR. Taking an exploit that triggers an information leak in Linux kernel, our approach automatically converts it into a highly impactful exploit that leaks pointers to either kernel functions or the kernel stack. We evaluate our approach on four known CVEs and one security patch in Linux kernel and demonstrate its effectiveness. Our findings provide solid evidence for Linux kernel developers and security analysts to treat information leaks in Linux kernel more seriously.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>For performance concerns, unsafe programming languages, such as C and C++, are still prevalently used in the implementation of operating system (OS) kernels and embedded systems. While these unsafe languages may allocate memory on stack or in the heap for variables, these variables may not be initialized before being used. When a variable is used without proper initialization (which can be caused by either a programming mistake or padding bytes in a struct inserted by compilers <ref type="bibr" target="#b21">[22]</ref>), the memory values that were present at the same location of the variable before it was allocatedcalled stale values-will be read and used. When these stale values are copied from the kernel space to the user space, userspace programs will be able to access them, which causes an information-leak vulnerability if the information contained in the stale values is important.</p><p>The use of stale values in Linux kernels can lead to severe security problems, which have been studied in the past <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b20">21]</ref>. Moreover, these stale values can pose severe security threats without being directly used in the kernel. For example, modern kernel security defenses, such as Kernel Address Space Layout Randomization (KASLR), depend on keeping kernel addresses secret from user-space programs. When attackers get lucky and recover kernel pointer values through leaked information (stale values) from the kernel space, they can defeat KASLR <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b24">25]</ref>. Likewise, attackers may leak cryptographic keys that are stored in the kernel space.</p><p>Unfortunately, in Linux kernel, information leaks that are caused by uninitialized data are common. A study shows that information leak vulnerabilities that are caused by the use of uninitialized data are the most prevalent type of vulnerabilities among the four major types of vulnerabilities in Linux kernel <ref type="bibr" target="#b7">[8]</ref>. Within the past two years, KernelMemorySanitizer (KMSAN) discovered over 100 uninitialized data use bugs in Linux kernel through fuzzing <ref type="bibr" target="#b4">[5]</ref>. Worse, due to the difficulty (or the impossibility) of exploiting the majority of information leak vulnerabilities or using them in high-risk exploits (such as remote code execution or local privilege escalation), these vulnerabilities are commonly believed to be of low risks. As a result, many uninitialized data uses do not get sufficient attention from developers or security researchers, are not assigned any CVE entries 1 , and in some cases their corresponding patches are not merged into Linux kernel for a long time <ref type="bibr" target="#b15">[16]</ref>.</p><p>Total Stack-based Heap-based # of exploits # of CVEs 87 76 (87%) 11 (13%) 0 <ref type="table">Table 1</ref>: The number of information leak CVEs that are related to uses of uninitialized data between 2010 and 2019. The majority of these CVEs are stack-based information leaks. There are no publicly available exploits for these CVEs. Only one out of these 87 CVEs warns about possible leaks of kernel pointers and potential KASLR bypasses. <ref type="table">Table 1</ref> shows the statistics of 87 Linux kernel CVEs that are related to uninitialized data uses and are reported between 2010 and 2019 <ref type="bibr" target="#b5">[6]</ref>. The majority of these CVEs are stack-based information leaks. Evaluating the severity of these CVEs is extremely difficult since no public exploit is available for any of them. Even if a public exploit is available, using these vulnerabilities to leak key information usually requires manual and complicated manipulation of the kernel layout, which is costly and time-consuming. Therefore, all but one CVE <ref type="bibr">(CVE-2017-1000410</ref>) mentions anything about the potential of leaking kernel pointers and bypassing KASLR, which leaves an impression to the general public that these vulnerabilities are of low security impact.</p><p>The situation about information leaks in Linux kernel is extremely concerning. In this paper, we demonstrate the actual exploitability and severity of information leak bugs in Linux kernels by proposing a generic and automated approach that converts stack-based information leaks in Linux kernels into vulnerabilities that leak kernel pointer values. Specifically, we focus on leaking pointer values that point to kernel functions or the kernel stack. These leaked kernel pointer values can be used to bypass kernel defenses such as KASLR, which is an essential step in modern Linux kernel exploits <ref type="bibr" target="#b12">[13]</ref>.</p><p>Our proposed approach takes as input an exploit that triggers a stack-based information leak bug, analyzes the exploit to identify locations where stale values are coming from, and reasons about an attack vector that places kernel pointer values at these locations. It is worth mentioning that our approach supports leaking kernel pointers when the size of the leaked stale value is less than a full 64-bit pointer (8 bytes). We evaluate our approach on five real-world Linux kernel vulnerabilities (including four CVEs and one bug that was reported by KMSAN) and demonstrate its generality and effectiveness. The existing Common Vulnerability Scoring System (CVSS) scores of three of the above CVEs are 2.1 (on a scale of 0 to 10, higher is more severe), which imply that "specialized access conditions or extenuating circumstances do not exist, even though there is considerable informational disclosure" <ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref>. Our findings can be used to assist CVSS in correcting the scoring and assessment of information leak vulnerabilities in Linux kernels, and raise awareness in the security community of these vulnerabilities. Contributions. This paper makes the following contributions:</p><p>• We disclose the actual severity of information leak vulnerabilities in Linux kernel. These vulnerabilities are easier to exploit and are more severe than what is generally believed.</p><p>• We identify common challenges in exploiting information-leak vulnerabilities. We then propose a generic and automated approach that converts a stack-based information leak vulnerability in Linux kernel to an exploit that leaks kernel pointer values.</p><p>• We implement our approach and evaluate it on five realworld vulnerabilities (four CVEs and one fixed bug in the upstream Linux kernel). The evaluation results show that our proposed approach is effective.</p><p>In the spirit of open science, we have released the source code of our tool and the exploits that we developed as part of our research. The repository is at https://github.com/ sefcom/leak-kptr.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>In this section, we provide a technical overview of stack-based information leaks in Linux kernel, and how leaked kernel pointer values can be used in more severe types of kernel exploits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Information Leaks from the Kernel Stack</head><p>Each thread in the Linux has a kernel stack, which is a memory area that is allocated in kernel space. Depending on the specific Linux version and configuration, the sizes of the kernel stack differ. To maximize the locality, the kernel stacks are usually small in size (8KB or 16KB on x86-64). Therefore, the memory space for the kernel stack is very frequently reused between different kernel stack frames. <ref type="bibr">Lu, et al.</ref> showed that 90% syscalls only use less than 1,260 bytes of the kernel stack space, and the average stack usage is less than 1,000 bytes <ref type="bibr" target="#b15">[16]</ref>. This reusability of the kernel stack has resulted in good performance and high efficiency but also has contributed to unexpected leaks of stale values that are left on the kernel stack.</p><p>We use two real-world vulnerabilities to demonstrate a kernel information leak vulnerability through uses of uninitialized variables on the stack. Listing 1 shows an example of a kernel information leak caused by a use of uninitialized stack memory. In the adjtimex syscall, the txc-&gt;tai field is not initialized and is later used as an argument of compat_put_timex. Thus, the compat_put_timex function copies the tai field of the txc object to a local variable (tx32 object), which is eventually copied to the user space and causes a kernel data leak. <ref type="bibr">Listing</ref>  Listing 1: A real-world vulnerability <ref type="bibr">(CVE-2018-11508</ref>) in which an uninitialized field of the time struct in the stack caused the information leak. the object still contains uninitialized 4 bytes padding generated by a compiler. Therefore, an unintended kernel data leak occurs when the stack object is copied to the user space by calling the nla_put function (on Line 14).</p><p>In both examples, the size of leaked data is 4 bytes, which is not enough to fully accommodate an 8-byte pointer value in 64-bit Linux. However, we will show in Section 5.4 that even a 4-byte leak is sufficient for leaking randomized kernel addresses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Uninitialized Data in Linux Kernel Exploitation</head><p>As shown in <ref type="table">Table 2</ref>, prior research work mostly focuses on controlled uses of uninitialized data in Linux kernels <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b24">25]</ref>. Our paper has a totally different goal: We focus on exploiting existing stack-based information leak vulnerabilities and converting them into high-impact vulnerabilities that leak sensitive data from the kernel. To the best of our knowledge, there is no prior research on the exploitation of stack-based </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Abusing Kernel Pointer Values</head><p>Bypassing KASLR. Commonly used in OS kernels, KASLR is a defense mechanism that randomizes the base address of the kernel (where the kernel code is loaded) at boot time. This technique was introduced to raise the bar of kernel memory corruption attacks (e.g., buffer overflows and use-after-free attacks) and is one of the most effective defenses in modern OS kernels. Systems with KASLR enabled can successfully mitigate memory corruption attacks as long as the attacker cannot learn randomized kernel addresses through information disclosure or side channel leaks <ref type="bibr" target="#b12">[13]</ref>. A kernel pointer leak will naturally lead to the bypass of KASLR, which we will detail next.</p><p>The Linux kernel on x86-64 architecture implements 6 bits of entropy for the kernel code. The address range of kernel text section is 1 GB (0xffffffff80000000 -0xffffffffc0000000) and the base address of kernel text is aligned by 16 MB. Hence, there are 64 virtual memory addresses (1 GB ÷ 16 MB) where the kernel .text section can be loaded. Consequently, on a condition that we can leak a kernel pointer value pointing to a kernel function, we will be able to calculate the KASLR slide-byte by simply subtracting the 5th byte of the leaked pointer value from the 5th byte of kernel text section's start address. As an example, if the leaked kernel pointer value is 0xffffffffa9a72cc0, the KASLR slide-byte is 0xa9−0x80=0x29. Attackers can compute randomized addresses of all kernel functions by using the slide-byte.  <ref type="table">Table 2</ref>: Comparison of our proposed approach for uninitialized memory uses with the other approaches. Although there are several prior research works that focused on exploiting uninitialized data uses (such as uninitialized pointer dereferences), there has been no research effort on exploitations of stack-based information-leak bugs for leaking kernel pointer values.</p><p>Attacking the kernel stack. Another type of kernel pointer values that we attempt to leak are pointer values that point to the kernel stack. These kernel pointers can be used to identify where the kernel stack is. The location of the kernel stack must not be discovered by attackers because it is critical information that the attackers can use in their exploits to defeat KASLR and achieve arbitrary kernel code execution. For example, the kernel stack contains return addresses of kernel functions and values of the stack canary on which the entire stack overflow protection mechanism relies. Additionally, at the bottom of the kernel stack, the thread_info structure is stored (when CONFIG_THREAD_INFO_IN_TASK is disabled). This data structure includes architecture-specific thread-related information and a pointer to the task_struct that holds process-related information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Attack Model</head><p>We assume that the attacker targets an x86-64 Linux system and tries to leak kernel pointer values that point to either kernel functions or the kernel stack. As previously discussed in Section 2.3, this step is very important for defeating modern kernel defenses, such as KASLR, before mounting future attacks.</p><p>To exploit information-leak bugs for leaking kernel pointer values, an in-depth analysis on the target kernel and the information-leaking bug is essential. Through this analysis, the attacker obtains critical information for exploiting the vulnerability, such as what types of kernel pointer values can be leaked, and where to place the kernel pointer values. We assume that the attacker has access to a local machine with the same Linux kernel and configuration as the target system, which the attacker can use to conduct the analysis and perform the attack before launching it on the target system. The attack should have full access to the local machine. We also assume that the attacker possesses the required exploit that triggers the information leak, which, at this moment, is likely to not leak any sensitive information on the kernel stack. With the analysis results, the attacker will generate exploits that can execute on the target system without the root privilege and reliably leak kernel pointer values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Challenges in Exploitation</head><p>We demonstrated how kernel information leaks can occur via uninitialized stack uses with Listing 1 and Listing 2. However, simply triggering the vulnerabilities will most likely not copy any sensitive data from the kernel stack to the user space. Therefore, we must be able to manipulate data on the kernel stack and ensure kernel pointer values (or part of a kernel pointer value) are put in uninitialized variables on the stack. To this end, we must analyze each vulnerability and generate a proper exploit for it, which involves tackling the challenges that Lu, et al. previously discussed <ref type="bibr" target="#b15">[16]</ref>. It is worth mentioning that our goal is different from theirs, and thus, we define a series of challenges that we must overcome to successfully leak kernel pointer values as follows.</p><p>C1: Computing the offset to uninitialized data from the kernel stack base.</p><p>The first challenge to leaking kernel pointer values is identifying the distance to an uninitialized memory cell from the base address of the kernel stack, which we term leak offset. Computing the leak offset allows us to find the exact location where kernel pointer values should be stored. We identify the leak offset through applying a new technique, called footprinting, on the kernel stack in Section 5.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C2: Storing kernel pointer values at a leak offset.</head><p>The next challenge is finding a way to place kernel pointer values at the specific leak offset. To achieve this goal, we propose two methods: (1) syscall enumeration with the help of the Linux Test Project (LTP) to find syscalls that can be used to store kernel pointer values at the leak offset (see Section 5.2), and (2) kernel stack spraying using the extended Berkeley Packet Filter (BPF) (see Section 5.3).</p><p>C3: Handling data leaks that are less than 8 bytes.</p><p>On a 64-bit Linux kernel, when a kernel data leak is larger than 8 bytes, we can obtain the value of the whole pointer. However, in many vulnerabilities, the size of memory leak is smaller than 8 bytes-we cannot obtain a complete pointer value. For handing such small leaks, we reason a possible range of the unleaked value through the guess and check method, by which we can identify the base address of the stack kernel. We discuss about the small leaks in Section 5.4.</p><p>Ideally, in addition to the above challenges, we should also prevent any future overwriting to kernel pointer values that we stored in the stack before the data is copied to the user space. This is to guarantee the successful exploitation of information-leak bugs. Unfortunately, there is no practical method to prevent such unexpected data overwriting without hijacking the control flow of the kernel on the target system. Thus, in this paper, we consider such cases where stored stack values are later overwritten before returning to user space to be unexploitable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Exploiting Uninitialized Stack Variables</head><p>Our goal is to design a generic approach to exploit stack-based information-leak vulnerabilities for leaking kernel pointer values. In the rest of this section, we describe how we tackle the challenges that are represented in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Computing the Leak Offset</head><p>We propose a novel technique, called byte-level stack footprinting, to identify the distance to an uninitialized memory address from the base address of the kernel stack. The mechanism is illustrated in <ref type="figure">Figure 1</ref>. First, we write offset information to each byte of the stack from the base address by hooking a syscall. In 64-bit kernels, the kernel stack is 16-byte or 8-byte aligned at a new frame of a function starts and every pointer in the stack is stored at 8-byte aligned addresses. We store 1-byte offset information which starts from 0x0 to 0xff in each byte for every 8 bytes. Therefore, even though with 1-byte information leak, we can identify exact offsets at which kernel pointer values should be stored to leak them. This mechanism allows us to footprint 2,024 bytes of the kernel stack. Even though we cannot footprint the entire kernel stack, 2,024 bytes are enough to deal with most syscalls (roughly 90% of syscalls only use less than 1,260 bytes of the stack).</p><p>Then we trigger an information-leak vulnerability. Because the offset information has been filled into the stack, we can directly check the offset. Lastly, we compute a leak offset by using the offset information from the kernel. For example, in <ref type="figure">Figure 1</ref>, the offset information copied from the kernel is 04, and thus, we need to find kernel pointer values that can be stored at an offset (Base − 24).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Extensive Syscall Testing with the LTP</head><p>Once the leak offset has been identified, we need to find a syscall and its arguments that can be used to store a kernel  <ref type="bibr" target="#b13">[14]</ref>. We supplement three additional steps onto each syscall test case in LTP: (1) spraying the stack with a magic value; (2) finding kernel pointer values stored in the stack; and (3) recording context information. <ref type="figure">Figure 2</ref> shows how our syscall testing framework finds proper syscalls and arguments. Before executing a syscall, we fill the kernel stack with a magic value to detect data changes that are made by the execution of the syscall. Then we inspect the kernel stack from the base address to find kernel pointer values. To this end, we check every 8-byte from the stack base whether each 8-byte value is in the address range of the kernel stack or the kernel code region (the .text section). If we find any kernel pointer value that points to the kernel stack or kernel code, we record the name of the syscall with its arguments and pointer type. From the recorded information, we select proper context data (a syscall and arguments) that can store a kernel pointer value at a specific leak offset. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Stack Spraying via BPF</head><p>Designed to support filtering packets as requested by userspace applications, the extended Berkeley Packet Filter (BPF) is a virtual machine that resides inside the kernel <ref type="bibr" target="#b16">[17]</ref>. The BPF virtual machine takes as input BPF programs (that use a special instruction set) when a user-space application attaches the BPF program onto any socket. Then, the BPF program executes when data passes through its attached socket and filters data as programmed.</p><p>BPF programs can use stack memory, which is allocated inside the kernel stack. Listing 3 shows the first part of the bpf_prog_run function, which shows that the stack of any BPF program is limited to 512 bytes. In the BPF virtual machine, there is a special register, R10, called the frame pointer. This register points to the top of the stack (the stack base) that a BPF program uses. Therefore, the frame pointer always points to a location on the kernel stack. We use this frame pointer and the location of the stack of a BPF program to spray the stack kernel.</p><p>With a carefully crafted BPF program, we can store the frame pointer value to the stack of a BPF program until the stack is full. In other words, we can store an address of the kernel stack up to 512 bytes inside the kernel stack. Additionally, the location of the stack local variable of the bpf_prog_run function changes depending on functions previously executed. Therefore, different execution paths from various syscalls transmitting data using a socket to the bpf_prog_run function can change the stack spraying range (discussed in Section 6.3 with a case study).</p><p>Listing 4 shows a part of a BPF program that sprays the kernel stack with the frame pointer. On Line 20, we copy the frame pointer (R10) to the R3. From Line 21, we spray the stack of a BPF program (kernel stack) with the frame pointer. It is worth noting that BPF virtual machine strictly restricts behaviors of a BPF program for preventing security issues by using the static verifier <ref type="bibr" target="#b6">[7]</ref>. As examples of the restrictions for every BPF program, all memory access is bounded, there cannot be unreachable instructions, the frame pointer (R10) is a read-only register and so forth. However, the static verifier allows our BPF program to execute stack spraying. We manually inspected the verifier and could not find a rule for preventing spraying the frame pointer. ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>26</head><p>};</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>27</head><p>...</p><p>Listing 4: A code snippet to perform kernel stack spraying using BPF. We can spray the frame pointer of a BPF program for 512 bytes on the kernel stack.</p><p>If we can store the frame pointer at a leak offset through the stack spraying, we will be able to figure out where the kernel stack is. Moreover, we can learn the memory layout of the kernel stack when a syscall executes based on the location of the kernel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Handling Small Data Leaks</head><p>If an information-leak vulnerability leaks 8 bytes or more than 8 bytes of data, and we can store a kernel stack address at a leak offset through spraying the stack with a BPF program, it is possible to fully recover a kernel stack address. Unfortunately, the sizes of leaks of many stack-based informationleak vulnerabilities (roughly 60% of them) are smaller than 8 bytes <ref type="bibr" target="#b5">[6]</ref>. Because the kernel stack is aligned by the size of a page (e.g., 4KB by default), we need the most significant 52 bits of a kernel stack address (a 7-byte leak) to get the base of the kernel stack. Therefore, leaks that are smaller than 7 bytes cannot be directly used to reveal the kernel stack base.</p><p>To handle this problem, we investigated the static verifier of the BPF virtual machine to check if arithmetic operations on the frame pointer is possible. We found that some arithmetic operations (such as bitwise shift) are not possible, but add and sub can be used with arbitrary immediate values. If the BPF allowed bit shifting operations on the frame pointer value, we would simply shift the frame pointer value so that unleaked data can be placed at leak offset. We can only execute add and sub operations on the frame pointer. However, these operations can be executed even if the result is beyond the range of the kernel stack. We also found that, after executing these arithmetic operations, the modified frame pointer value can be stored at the kernel stack.</p><p>By using this unrestricted behavior of a BPF program, we deal with such small leaks using the guess and check method to identify unleaked data of a kernel stack address, and, eventually, to reveal the layout of the kernel stack. This strategy requires manipulating the frame pointer value and check how known (leaked) data changes. <ref type="figure" target="#fig_2">Figure 3</ref> illustrates how a 4-byte information leak vulnerability can be used to identify the base of the kernel stack by reasoning it. We first trigger a vulnerability after spraying the kernel stack with the frame pointer. Next, we execute an arithmetic operation (add or sub) on the frame pointer with an arbitrary immediate value. This modified frame pointer value is sprayed and we check the leaked data by triggering the vulnerability. As shown in <ref type="figure" target="#fig_2">Fig- ure 3</ref>, when we sprayed (FP−0x30000000), the leaked data has changed from 0xffffff04 to 0xffffff03, by which we can notice that the frame pointer value is smaller than 0xffffff0430000000). We repeat this reasoning procedure until we can obtain the kernel stack base address: until the most important 52 bits of a kernel stack address is revealed.</p><p>We note that, a security patch was applied to the upstream Linux kernel at April 18th 2019 from the version 4.14.113 2 to restrict arithmetic operations on the frame pointer for unprivileged users so that the frame pointer value cannot go out of the stack region. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>We evaluate our proposed approach against real-world information leak vulnerabilities in Linux kernels that involve uses of uninitialized stack variables. In this section, we first present the implementation of our tool in Section 6.1, then present the evaluation results of our syscall-enumeration-based pointer finding approach (in Section 6.2), and finally present case studies of all five vulnerabilities that we evaluated against (in Section 6.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Implementation</head><p>We implemented an analysis tool, which consists of a shared library (KptrLib) and a loadable kernel module (KptrMod), to automatically find leak offsets (as described in Section 5.1). Then, we modified the Linux Test Project (LTP) to perform the three additional steps using KptrMod, as discussed in Section 5.2. We also implemented a tool for automatically spraying the kernel stack and handling small leaks with a BPF program (as described in Section 5.3 and Section 5.4).</p><p>Our tools can be easily used to analyze any given exploit that triggers a information-leak vulnerability to evaluate its exploitability regarding identifying the location of the kernel stack, leaking kernel pointers, and finally bypassing KASLR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Finding pointers with the LTP framework</head><p>First, we evaluate the effectiveness of our syscall enumeration framework. To this end, we ran the modified LTP on Ubuntu 18.04 (with Linux kernel v4.15.0). For each kernel, we need to run the LTP framework once to record context information. Then, we can simply pick a context (a syscall and its argument) from the recorded data for storing a kernel pointer value at the identified leak offset. <ref type="figure" target="#fig_4">Figure 4</ref> illustrates that how many contexts (combinations of a syscall and its arguments) can store sensitive pointer values (pointing to the kernel code or stack) for each stack memory offset less than 2,298. The experimental results show that our modified LTP framework can find syscalls to store kernel pointer values at almost every stack offset when offsets are larger than the stack base + 440.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Case studies</head><p>To evaluate our approach, we select four CVEs and one fixed bug (which a CVE entry has not been assigned) in the Linux kernel and generate an exploit for each vulnerability according to our analysis results.</p><p>Why not analyze more CVEs? While we agree that analyzing more CVEs will help better demonstrate the generality and applicability of our proposed approach, during the evaluation of our approach, we realized that it is extremely <ref type="table" target="#tab_5">0   64  128  192  256  320  384  448  512  576  640  704  768  832  896  960  1024  1088  Stack offsets   0   10   20   30   40   50   60   70   Number of possible cases   Pointing to the kernel stack  Pointing to the kernel code   1160  1224  1288  1352  1416  1480  1544  1608  1672  1736  1800  1864  1928  1992  2056  2120  2184</ref>  time-consuming to develop exploits for these CVEs to reliably trigger the intended information-leaking bugs. Thus, we deem it infeasible to evaluate our approach on more CVEs for which no public exploits are available. We believe that these randomly selected CVEs are covering all scenarios that an attacker may face and are sufficient for demonstrating the generality of our proposed approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">CVE-2018-11508</head><p>As we have shown in Section 2.1, this vulnerability is caused by an uninitialized stack variable (tai field of the txc struct). The CVSS score of this vulnerability is 2.1 <ref type="bibr" target="#b3">[4]</ref>. We speculate that the impact of this vulnerability is deemed low because the size of information leak is only 4 bytes, which are not enough to host an entire pointer on 64-bit Linux systems.</p><p>After checking a leak offset through KptrLib and KptrMod, we found that this vulnerability leaks 5th byte to 8th byte of a pointer value. Also, we confirmed that a pointer value that points to the kernel text can be stored at the leak offset from the dataset recorded by the modified LTP in Section 6.2. Consequently, we can successfully get the KASLR slide from this vulnerability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2">CVE-2016-4569 and fix 372f525</head><p>The CVSS score of CVE-2016-4569 is also 2.1. Our proposed approach successfully exploits this bug and identifies the KASLR slide.</p><p>The patch (fix 372f525) did not become an official CVE entry. In the commit message of the patch, a kernel developer mentioned that "There should be no danger of breaking userspace as the stack leak guaranteed that previously meaningless random data was being returned. 3 " Unfortunately, our proposed approach works against this bug and successfully identifies the KASLR slide. This demonstrates the necessity of our approach for proving the severity of information leak bugs in Linux kernels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.3">CVE-2016-4486</head><p>With this CVE (CVSS score 2.1), we show that how a 4-byte leak vulnerability can be exploited to identify the kernel stack base.</p><p>For spraying the kernel stack using the BPF program as in Listing 4, we first checked a leak offset of this vulnerability: the leak offset is 1,568. We, then, executed the BPF program by calling the sendmsg() syscall. However, we could not clobber the offset because the BPF program sprays the kernel stack from offset 1,032 to 1,544 when we use the sendmsg() syscall. As we discussed in Section 5.3, there are various syscalls that can trigger the bpf_prog_run() function and each of them uses a different execution path to the BPF program runner-the stack spraying range is different based on the execution path. In this case, we found that we can clobber the leak offset through the compat_sendmsg() syscall by which we can spray the kernel stack from 1,064 to 1,576. Consequently, we could identify the kernel stack base with the guess and check method introduced in Section 5.4. Listing 5: The vulnerable function of CVE-2016-5244. The rds_info_copy function copies the minfo struct with flag field uninitialized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.4">CVE-2016-5244</head><p>The CVSS score of this vulnerability is 5.0, which is significantly higher than the other CVEs that we evaluate in this paper. Interestingly, we found that this one-byte leak vulnerability cannot be exploited through our analysis. Listing 5 shows the vulnerable function where the minfo struct with the uninitialized flag field is copied to the userspace through the rds_info_copy function at Line 22. However, the leak offset of the uninitialized field (1 byte) always becomes 0 before the vulnerable function executes. Therefore, the vulnerability always leaks 0, even though we can successfully store kernel pointer values at the leak offset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.5">Summary</head><p>In our evaluation, we analyzed four CVEs and one patch in the upstream Linux kernel as summarized in <ref type="table" target="#tab_5">Table 3</ref>. We showed that our approach can effectively generate exploits. Additionally, the experimental results imply that our community is in need of a more accurate exploitability evaluation system for information leak bugs in Linux kernel so that security implications of bugs can be estimated more correctly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Discussion</head><p>We discuss about limitations of this paper and possible mitigations against stack-based information-leak vulnerabilities.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Limitations</head><p>We showed that small leaks can be exploited to identify the KASLR slide <ref type="bibr">(CVE-2018-11580</ref>) and the kernel stack base <ref type="bibr">(CVE-2016-4486)</ref>. Even though our approach to identifying the KASLR slide currently has no limitation in its usage, the BPF-based approach to reveal the stack base cannot be used in the Linux kernel from v.4.14.113 as in Section 5.4 (stack spraying is still possible). Therefore, we need a more general method to handle small leaks especially for revealing the stack base. To overcome this limitation, one possible strategy is to analyze the Linux kernel statically to find code gadgets which can modify the kernel stack with user-controlled data. We leave this limitation for future work. Next, our approach analyzes information-leak vulnerabilities using programs that can trigger a vulnerability. Hence, we could not evaluate our approach in a large scale; Instead, we show the effectiveness of our approach against a limited number of vulnerabilities. This is mainly because generating such exploits manually is a time-consuming and complicated task. Even though we know which function has a vulnerability, we should find a proper context and create exploits to trigger it by manually analyzing the kernel source code. To enable largescale experiments, our approach needs to be incorporated with emerging automatic exploit generation technologies such as FUSE <ref type="bibr" target="#b23">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Mitigating Uses of Uninitialized Memory</head><p>There are a couple of security features for uninitialized memory uses in the Linux kernel. STACKLEAK clears the kernel stack when syscalls return to the user-space, which was integrated into the Linux kernel upstream from v4.20 <ref type="bibr" target="#b19">[20]</ref>. Recently, new configuration options, CONFIG_INIT_ALL_MEMORY and CONFIG_INIT_ALL_STACK, were introduced to force initialization of stack and heap variables <ref type="bibr" target="#b0">[1]</ref>. In addition, many mitigation approaches have been proposed to prevent uninitialized memory uses. Peiró, et al. proposed a mechanism for detecting stack-based informationleak bugs of the Linux kernel through static data flow analysis <ref type="bibr" target="#b18">[19]</ref>. Garmany, et al. have proposed another static data flow analysis framework that finds uninitialized stack memory uses after lifting binaries into an intermediate representation <ref type="bibr" target="#b11">[12]</ref>. UniSan is a compiler-based approach to prevent information leaks caused by uninitialized read <ref type="bibr" target="#b14">[15]</ref>. UniSan performs byte-level data flow analysis statically for OS kernels and instruments code to initialize data if it leaves kernel without initialization. The kernel memory sanitizer (KM-SAN) is a tool to track uninitialized data to check whether the data leaves OS kernels or not, which can be utilized with fuzzers such as the syzkaller <ref type="bibr" target="#b4">[5]</ref>. On the other hand, as a runtime defense system for OS kernels, kMVX has been proposed against information-leak vulnerabilities by leveraging the multi-variant execution <ref type="bibr" target="#b17">[18]</ref> 8 Related work</p><p>Exploiting uninitialized memory uses. Albeit there have been research efforts on controlling uninitialized data to leverage it in other types of vulnerabilities, exploiting stack-based information-leak vulnerability to leak sensitive information such as pointer values pointing to the kernel stack or kernel code has not been explored yet <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b24">25]</ref>.</p><p>Thomas Dullien (also known as Halvar Flake) proposed a search algorithm using call graphs for finding a function that can have a stack frame overlapping with the target memory address <ref type="bibr" target="#b10">[11]</ref>. Lu, et al. proposed an automated method for writing arbitrary data to uninitialized stack variables through targeted stack spraying <ref type="bibr" target="#b15">[16]</ref>. Xu, et al. showed common types of uninitialized uses and their potential threats by exploiting two uninitialized use vulnerabilities which can lead attackers to gain arbitrary kernel code executions in the macOS <ref type="bibr" target="#b24">[25]</ref>. Automating kernel exploitation. Automated kernel exploit generation is a demanding task. In addition, even determining the exploitability of bugs requires significant manual efforts. Security researchers have been attempting to address these problems. FUZE <ref type="bibr" target="#b23">[24]</ref> proposed to identify useful system calls for kernel use-after-free exploitations by leveraging fuzzing and symbolic execution techniques. KEPLER <ref type="bibr" target="#b22">[23]</ref> showed a code-reuse exploit approach that converts a user-provided control-flow hijacking primitives into arbitrary stack overflows, and thus, it bootstraps return-oriented programming (ROP) payload. Chen et al. <ref type="bibr" target="#b8">[9]</ref> proposed static and dynamic analysis methods to find useful data structures for use-afterfree exploitations in the Linux kernel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion</head><p>In this paper, we proposed a generic approach to exploit uses of uninitialized stack data in Linux kernels to leak pointer values that are pointing to either kernel functions or to the kernel stack. These leaked pointer values can then be used to defeat KASLR and mount future attacks against Linux kernels. Our evaluation results show that we can effectively analyze and exploit stack-based information-leak vulnerabilities through the proposed approach. Our proposed approach exposes the actual exploitability and severity of information disclosure bugs in Linux kernels and will raise awareness of the community on the security impact of these bugs. We expect our findings will help adjust CVSS scoring for information leak bugs inside Linux kernels.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Listing 3: The main function for executing a BPF program. It allocates the stack for BPF programs and execute them.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The procedure for identifying a kernel stack address using the kernel stack spraying via a BPF program. By checking changes of the leaked data, we figure out possible ranges of the unleaked data until the stack base address is revealed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>2</head><label></label><figDesc>https://lore.kernel.org/patchwork/patch/1063913/</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Number of possible cases Pointing to the kernel stack Pointing to the kernel codeFigure 4 :</head><label>4</label><figDesc>Figure 4: The experimental result of the modified LTP framework. We can find syscalls to store kernel pointer values at almost every stack offset, when offsets are larger than 440 bytes and smaller than 2,298 bytes, through the LTP framework.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1</head><label></label><figDesc>/ * file: net/rds/recv.c * / 2 void rds_inc_info_copy ( struct rds_incoming *inc , struct rds_info_iterator * iter , __be32 saddr , __be32 daddr , int flip ) 3 { 4 struct rds_info_message minfo ; 5 minfo . seq = be64_to_cpu (inc -&gt; i_hdr . h_sequence ); 6 minfo . len = be32_to_cpu (inc -&gt; i_hdr . h_len ); 7 minfo . tos = inc -&gt; i_conn -&gt; c_tos ; 8 if ( flip ) { 9 minfo . laddr = daddr ; 10 minfo . faddr = saddr ; 11 minfo . lport = inc -&gt; i_hdr . h_dport ; 12 minfo . fport = inc -&gt; i_hdr . h_sport ; 13 } else { 14 minfo . laddr = saddr ; 15 minfo . faddr = daddr ; 16 minfo . lport = inc -&gt; i_hdr . h_sport ; 17 minfo . fport = inc -&gt; i_hdr . h_dport ; 18 } 19 rds_info_copy ( iter , * minfo , sizeof ( minfo )); 20 // The minfo struct is copied to the user-space with the uninitialized 'flag' field</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Criteria Our approach Lu et al. [16] Xu et al. [25] Halvar Flake [11]</head><label>Criteria</label><figDesc></figDesc><table>Types of unused memory targeted for generating exploits 
Stack 
Stack 
Stack, Heap 
Stack 
Generating exploits for leaking sensitive data 




Finding locations of uninitialized data 




Reasoning about storing sensitive data at a given location 





</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Summary of exploitation results of vulnerabilities. 
We analyzed 4 CVEs and 1 security patch which could not 
become a CVE entry. 

</table></figure>

			<note place="foot" n="1"> Here is an example of a security patch that fixes a stack-based information leak vulnerability: https://github.com/torvalds/linux/commit/ 7c8a61d9ee. No CVE was ever assigned for the vulnerability.</note>

			<note place="foot" n="3"> https://github.com/torvalds/linux/commit/7c8a61d9ee</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>We would like to express our gratitude to the anonymous reviewers for their thoughtful reviews.</p><p>This material is based upon work supported in part by Samsung Research, Samsung Electronics, the National Science </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Automatic variable initialization</title>
		<ptr target="https://reviews.llvm.org/D54604" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
				<ptr target="https://www.cvedetails.com/cve/CVE-2016-4486" />
		<title level="m">CVE (Vulnerability) Details: CVE-2016-4486</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<ptr target="https://www.cvedetails.com/cve/CVE-2016-4569" />
		<title level="m">CVE (Vulnerability) Details: CVE-2016-4569</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
				<ptr target="https://www.cvedetails.com/cve/CVE-2018-11508" />
		<title level="m">CVE (Vulnerability) Details: CVE-2018-11508</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">KernelMemorySanitizer, a detector of uses of uninitialized memory in the Linux kernel</title>
		<ptr target="https://github.com/google/kmsan" />
		<imprint>
			<date type="published" when="2020-02-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
				<ptr target="https://www.cvedetails.com/product/47/Linux-Linux-Kernel.html?vendor_id=33" />
		<title level="m">Linux Kernel: Vulnerability Statistics</title>
		<imprint>
			<date type="published" when="2020-02-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<ptr target="https://www.kernel.org/doc/Documentation/networking/filter.txt" />
		<title level="m">Linux Socket Filtering aka Berkeley Packet Filter (BPF)</title>
		<imprint>
			<date type="published" when="2020-02-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Linux kernel vulnerabilities: State-of-the-art defenses and open problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haogang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yandong</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dong</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nickolai</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M Frans</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd Asia-Pacific Workshop on Systems (APSys)</title>
		<meeting>the 2nd Asia-Pacific Workshop on Systems (APSys)<address><addrLine>Shanghai, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">SLAKE: Facilitating Slab Manipulation for Exploiting Vulnerabilities in the Linux Kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yueqi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xinyu</forename><surname>Xing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 23rd ACM Conference on Computer and Communications Security (CCS)<address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-10" />
			<biblScope unit="page" from="1707" to="1722" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Kernel exploitation via uninitialized stack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kees</forename><surname>Cook</surname></persName>
		</author>
		<ptr target="https://www.defcon.org/images/defcon-19/dc-19-presentations/Cook/DEFCON-19-Cook-Kernel-Exploitation.pdf" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Attacks on uninitialized local variables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Halvar</forename><surname>Flake</surname></persName>
		</author>
		<ptr target="https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Flake.pdf" />
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Static Detection of Uninitialized Stack Variables in Binary Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Behrad</forename><surname>Garmany</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Stoffel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Gawlik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thorsten</forename><surname>Holz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th European Symposium on Research in Computer Security (ESORICS)</title>
		<meeting>the 24th European Symposium on Research in Computer Security (ESORICS)<address><addrLine>Luxembourg</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-09" />
			<biblScope unit="page" from="68" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Breaking kernel address space layout randomization with intel tsx</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yeongjin</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sangho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 23rd ACM Conference on Computer and Communications Security (CCS)<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-10" />
			<biblScope unit="page" from="380" to="392" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Testing linux with the linux test project</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Larson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Linux Symposium (OLS) 2002</title>
		<meeting>the Linux Symposium (OLS) 2002<address><addrLine>Ottawa, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Unisan: Proactive kernel memory initialization to eliminate data leakages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kangjie</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengyu</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenke</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 23rd ACM Conference on Computer and Communications Security (CCS)<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-10" />
			<biblScope unit="page" from="920" to="932" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Unleashing Use-Before-Initialization Vulnerabilities in the Linux Kernel Using Targeted Stack Spraying</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kangjie</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marie-Therese</forename><surname>Walter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Nümberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenke</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Backes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the 2017 Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The BSD Packet Filter: A New Architecture for User-level Packet Capture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Van Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Winter</title>
		<meeting>the USENIX Winter<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-01" />
			<biblScope unit="page" from="259" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">kMVX: Detecting Kernel Information Leaks with Multivariant Execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Österlund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koen</forename><surname>Koning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierre</forename><surname>Olivier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antonio</forename><surname>Barbalace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herbert</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristiano</forename><surname>Giuffrida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the 24th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)<address><addrLine>Providence, RI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-04" />
			<biblScope unit="page" from="559" to="572" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Detecting stack based kernel information leaks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Salva Peiró</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miguel</forename><surname>Muñoz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfons</forename><surname>Masmano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Crespo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Joint Conference SOCO&apos;14-CISIS&apos;14-ICEUTE&apos;14</title>
		<meeting>the International Joint Conference SOCO&apos;14-CISIS&apos;14-ICEUTE&apos;14<address><addrLine>Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-06" />
			<biblScope unit="page" from="321" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">STACKLEAK: A Long Way to the Linux Kernel Mainline</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Popov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Linux Security Summit</title>
		<meeting><address><addrLine>Vancouber, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Dealing with Uninitialized Memory in the Kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Potapenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Linux Security Summit Europe</title>
		<meeting><address><addrLine>Lyon, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Undefined behavior: what happened to my code?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haogang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alvin</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhihao</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nickolai</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M Frans</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Asia-Pacific Workshop on Systems (APSys)</title>
		<meeting>the 3rd Asia-Pacific Workshop on Systems (APSys)<address><addrLine>Seoul, South Korea</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">KE-PLER: Facilitating Control-flow Hijacking Primitive Evaluation for Linux Kernel Vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yueqi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xinyu</forename><surname>Xing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Zou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th USENIX Security Symposium (Security)</title>
		<meeting>the 28th USENIX Security Symposium (Security)<address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-08" />
			<biblScope unit="page" from="1187" to="1204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">FUZE: Towards Facilitating Exploit Generation for Kernel Use-After-Free Vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yueqi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jun</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xinyu</forename><surname>Xing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaorui</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Zou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Security Symposium (Security)</title>
		<meeting>the 27th USENIX Security Symposium (Security)<address><addrLine>Baltimore, MD</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-08" />
			<biblScope unit="page" from="781" to="797" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Exploitations of uninitialized uses on macos sierra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhenquan</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gongshen</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tielei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hao</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Workshop on Offensive Technologies (WOOT)</title>
		<meeting>the 11th USENIX Workshop on Offensive Technologies (WOOT)<address><addrLine>Vancouver, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-08" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
