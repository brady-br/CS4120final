<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:29+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">AFL ++ : Combining Incremental Steps of Fuzzing Research</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Fioraldi</surname></persName>
							<email>andrea@aflplus.plus</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dominik</forename><surname>Maier</surname></persName>
							<email>dominik@aflplus.plus</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heiko</forename><surname>Eißfeldt</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Heuse</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">The Hacker&apos;s Choice</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">†Sapienza University of Rome</orgName>
								<address>
									<addrLine>‡TU Berlin</addrLine>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">AFL ++ : Combining Incremental Steps of Fuzzing Research</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>In this paper, we present AFL ++ , a community-driven open-source tool that incorporates state-of-the-art fuzzing research, to make the research comparable, reproducible, combinable and-most importantly-useable. It offers a variety of novel features, for example its Custom Mutator API, able to extend the fuzzing process at many stages. With it, mutators for specific targets can also be written by experienced security testers. We hope for AFL ++ to become a new baseline tool not only for current, but also for future research, as it allows to test new techniques quickly, and evaluate not only the effectiveness of the single technique versus the state-of-the-art, but also in combination with other techniques. The paper gives an evaluation of hand-picked fuzzing technologies-shining light on the fact that while each novel fuzzing method can increase performance in some targets-it decreases performance for other targets. This is an insight future fuzzing research should consider in their evaluations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The research on Fuzzing is a flourishing field. Fuzzing uncovers a variety of bugs in a fully automated fashion. Fuzztesting has seen a big interest in the information security community in recent years and has sparked advancements in different fields. In tests performed by Shoshitaishvili et al., symbolically-assisted fuzzing identified almost three times more vulnerabilities than symbolic execution <ref type="bibr" target="#b37">[39]</ref>.</p><p>The number of developed techniques aiming to improve fuzzing grows <ref type="bibr" target="#b26">[28]</ref> -sometimes without fully-functioning code, if at all. In addition, fuzzing techniques are often developed orthogonally and independently, so combining them can be a long process. It can be difficult for industry and the OSS community to decide which research is worth the attention. Instead, they may stick with a basic setup, even though modern research would find more bugs for their target, faster. On the other hand, researchers themselves can have a hard time evaluating their novel tools, and may find themselves unable to combine functionality with the compatible techniques that address different, but related problems in fuzzing -for example picking a recent seed scheduling for their mutator. A new feedback concept may not live up to its full potential if it cannot be combined with existing techniques solving other problems -like overcoming hard comparison instructionsreducing the impact of the research on paper due to lackluster statistics.</p><p>In this paper, we try to solve these problems by raising the bar of broadly available, research-backed, fuzzing, and by giving researchers an extensible API to build upon. We propose a novel fuzzing framework, AFL ++ . Future research can use AFL ++ as a new baseline. It gives researchers the possibility to evaluate combinations of their proposals with state-of-the-art orthogonal features already implemented in AFL ++ -with a highly reduced implementation effort. At the same time, it offers industry professionals a large range of easy-to-use features adapted from cutting-edge research, that can greatly improve the outcome of a fuzzing campaign. AFL ++ is a reengineered fork of the popular coverage-guided fuzzer AFL by <ref type="bibr">Zalewski [47]</ref> which has proven to be a solid base for works in academia and industry alike.</p><p>AFL was chosen as the base because at the time of the start of this project it was already unmaintained for 18 months while at the same time a lot of community patches and academic forks were available. Hence this provided a perfect start. This would not have been possible with LIBFUZZER and HONGGFUZZ as they were and still are actively maintained and still do not enjoy major forks and enhancements in comparison (with notable exceptions for ENTROPIC <ref type="bibr" target="#b7">[9]</ref> and Vranken's enhancements <ref type="bibr" target="#b39">[41]</ref>).</p><p>While AFL ++ started off as collection of patches and forks to AFL, over time we reimplemented non-afl-based research like REDQUEEN <ref type="bibr" target="#b3">[5]</ref>, as well as research-grade extensions to AFL to make them production ready, for AFL ++ . We then added novel features on top of this state-of-the-art, that will also be discussed in this paper.</p><p>All in all, this paper will give insights into a year of active, open-source, fuzzing research, discuss lessons-learned, and 2 State-of-the-Art American Fuzzy Lop (AFL) <ref type="bibr" target="#b45">[47]</ref> is one of the most widely used and most successful coverage-guided fuzzers of all time. It is the current baseline for a wide variety of fuzzing-related publications. In this section, we discuss American Fuzzy Lop and the research done over the past years to improve specific aspects of this fuzzer in-depth, yet as concise as possible. The concepts explained in this section are directly relevant for AFL ++ , which will be presented in Sect. 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">American Fuzzy Lop</head><p>AFL is a mutational, coverage guided fuzzer. It mutates a set of test cases to reach previously unexplored points in the program. When this happens, the test case triggering new coverage is saved as part of the test case queue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Coverage Guided Feedback</head><p>The coverage feedback of AFL is a hybrid metric, combining edge coverage with the count of how many times the respective edge was executed in one run. This count is bucketed to a power of two to avoid path explosion. An input is considered interesting (i.e. saved to the queue) if it explores at least one new bucket for an edge. These buckets, or hitcounts, are logged to a shared bitmap during execution, in which each byte represents an edge. The size of this map is limited, so collisions are possible. AFL employs an approximation of weighted minimum set cover to maintain a set of favored test cases -in terms of coverage -with speed and size as weights.</p><p>Using the coverage feedback AFL also tries, for each test case in the queue, to reduce the size of the test case and improve the speed of the target while maintaining intact the coverage in a stage called trimming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Mutations</head><p>The mutations of AFL are divided into two categories: deterministic and havoc. Deterministic stages include single deterministic mutations on contents of the test cases, like bit flips, additions, substitution with integers from a set of common interesting values (e.g -1, INT_MAX, ...), and others. In havoc, mutations are randomly stacked and include also changes to the size of the test case (e.g. adds or deletes portions of the input). Additionally, at a later stage, AFL may merge two test cases into one and apply havoc, in the so-called splicing stage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.3">Forkserver</head><p>To avoid the overhead of execve(), AFL uses the so-called forkserver. The fuzzer injects a forkserver, controlled through an IPC mechanism, into the target. Whenever AFL needs to execute a test case, it writes the input, then tells the target to fork itself. The child will execute the test case, the parent process waits for this time. The forkserver can also fork later in the target. In this case, the fuzzer does not pay the cost of running the expensive initialization and startup routines each time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.4">Persistent Mode</head><p>Persistent mode greatly improves performance. Because fork() is known to be a bottleneck, for the Persistent Mode, the target does not fork for each test case. Instead, a loop can be patched into the target, executing one test case per iteration. To work, each iteration needs to leave cause minimal state changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Smart Scheduling</head><p>A modern coverage-guided fuzzer may implement different prioritization algorithms to schedule various elements in the fuzzing pipeline. The goal of schedulers is usually to improve overall coverage and bug detections through smart test case selection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">AFLFast</head><p>AFLFAST <ref type="bibr" target="#b9">[11]</ref> by <ref type="bibr">Böhme et al.</ref> shows the need to stress low-frequency paths to explore more branches and find more bugs. They developed several improvements to AFL to not only stress common paths, with the goal to expose additional program behavior. They highlight two problems:</p><p>1. In which order should the fuzzer pick the seeds, in order to stress low-frequency paths?</p><p>2. Can we tune the amount of generated inputs from each seed (the energy)?</p><p>The authors address the first issue with a set of novel search strategies and the second by introducing six power schedules to compute the energy from parameters collected during the fuzzing process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">MOpt</head><p>As a horizontal problem to seed scheduling, MOPT <ref type="bibr" target="#b23">[25]</ref> introduced mutation scheduling. In the work, Lyu et al., explore the possibility to give different probabilities to the mutation operators, using a custom Particle Swarm Optimization algorithm. This optimization improves the capabilities of a fuzzer to discover coverage quickly. In their patch to AFL, the authors divide the fuzzing stages into the following two modules. Pilot, a module that evaluates the operators, assigning probabilities based on the effectiveness. The Code module generates mutations, taking the probabilities found during Pilot into account.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Bypassing Roadblocks</head><p>Traditionally, coverage guided fuzzers suffer from roadblocks that prevent to explore code behind them. Typical roadblocks are larger comparisons, like a string, and checksum checks. A range of research was derived to tackle this problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">LAF-Intel</head><formula xml:id="formula_0">LAF-INTEL [2]</formula><p>is a work that aims to bypass hard multibyte comparisons, by splitting them into multiple single-byte comparisons. That way, these comparisons can be passed, byte by byte, with the coverage guided fuzzer receiving feedback for each part. The original implementation is a set of LLVM passes, splitting up integer comparisons, but also calls to string comparisons functions like strcmp when one of the arguments is known at compile time. In the details, LAFIntel:</p><p>1. Simplifies the &gt;= (and &lt;=) operators into chains of &gt; (&lt;) and == comparisons;</p><p>2. Changes signed integer comparisons to a chain of signonly comparison and unsigned comparisons;</p><p>3. Splits all unsigned integer comparisons with bit widths of 64, 32 or 16 bits to chains of multiple comparisons of 8 bit;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">RedQueen</head><p>Recently, REDQUEEN <ref type="bibr" target="#b3">[5]</ref>, based on KAFL <ref type="bibr" target="#b34">[36]</ref>, explored the possibility to bypass hard comparisons and checksum checks, like other previous works in literature <ref type="bibr" target="#b33">[35]</ref> [12] <ref type="bibr" target="#b31">[33]</ref> [44], but without the use of expensive techniques like taint tracking <ref type="bibr" target="#b44">[46]</ref> or symbolic execution <ref type="bibr" target="#b4">[6,</ref><ref type="bibr" target="#b35">37]</ref>. This fuzzer focuses on the comparisons that are defined as Input-To-State (I2S), a type of comparison that has a direct dependency with the input in at least one of its operands. The authors showed that many of the roadblocks comparisons are of this type and developed a technique to locate and bypass them. REDQUEEN firstly increases the entropy in the input in its colorization stage, replacing bytes with random data while maintaining the coverage of the test case. In this way, observing an operand of an I2S comparison, the fuzzer can reduce the number of guesses to locate its position in the input. REDQUEEN then mutates the input replacing the I2S tokens extracted from comparisons and use again this information to locate checksum checks and patch them out. At the end of each fuzzing stage, REDQUEEN use again I2S replacement to repair checksums of the newly generated interesting inputs. If it fails, the patched checksum is detected as a false positive the patch removed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Mutate Structured Inputs</head><p>A common issue for fuzzers is that they may generate mostly invalid inputs, making the state of the program after the parsing stages inaccessible. A solution to this is the usage of an input model, effectively reducing the space of generated inputs. This allows a feedback-based fuzzer to explore deep paths in a program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.1">AFLSmart</head><p>Pham et al. introduced structured fuzzing to AFL: AFLS-MART <ref type="bibr" target="#b32">[34]</ref>. AFLSMART uses PEACH <ref type="bibr" target="#b12">[14]</ref> pits as input model format, a widely used specification for structured black-box fuzzing. This choice makes it possible to re-use specifications for protocols written for PEACH. AFLSMART parses a test case the first time that it is extracted from the queue. It does so in a lazy way, with deferred cracking, that allows AFLSMART to fallback to AFL if it is good enough at exploring coverage without wasting time with parsing. The result of the parsing step is a virtual structure that represents an AST. AFLSMART introduces higher-order structural mutations, mutating the virtual structure instead of raw bytes. It can be configured to use only these structural mutations or stack them alongside the others in Havoc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A New Baseline for Fuzzing</head><p>In this section, we will explain the engineering background of AFL ++ . The core of AFL ++ is a forked version of AFL, a fuzzer on which a part of the academical fuzzing research is based upon, and which is also used extensively in the industry.</p><p>This section describes what AFL ++ adds on top, including many of the features discussed in Sect. 2. AFL ++ is not limited to the features discussed here. The amount of smaller advancements in usability and engineering go beyond the scope of this paper. For a deep dive in this small but effective improvements, refer to the AFL ++ documentation <ref type="bibr" target="#b16">[18]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Seed Scheduling</head><p>AFL ++ incorporates AFLFAST and extends it with additional power schedules. This included all schedules from AFLFAST: fast, coe, explore, quad, lin, exploit. These schedules are functions of the following variables:</p><p>1. The times that seed is chosen from the queue;</p><p>2. The number of generated inputs with the same coverage of the seed;</p><p>3. The average number of generated test cases with the same coverage in general;</p><p>The default schedule is explore. In addition to this, AFL ++ adds the mmopt and the rare schedules. Mmopt increases the score for the newest seeds to help delving deeper into newly discovered paths. Rare ignores the runtime of the seed -unlike all other schedules -and additionally puts a focus on seeds with edges that are rarely covered by other seeds, an effective metric as shown in <ref type="bibr" target="#b22">[24]</ref> [10].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Mutators</head><p>AFL ++ incorporates more mutators than the traditional Deterministic and Havoc pipeline of AFL. The mutators can be used in combination with others.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Custom Mutator API</head><p>AFL ++ can be easily extended for new research in academia and be adapted to specific targets for vulnerability discovery. For this, it offers an ever-growing API. The current state is as follows.</p><p>Custom mutators allow fuzzing research to build novel scheduling, mutation, and minimizations on top of AFL ++ , without forking and patching AFL, as is the case with a lot of current tooling. Initial support to this was first independently developed in the Holler's AFL fork <ref type="bibr" target="#b17">[19]</ref>, but got extended with a lot of new functionality. Plugins can be written in C ABI compatible languages, and even prototyped in Python. With the current API, for instance, AFLSMART can be rewritten completely as an AFL ++ plugin. The following functions can currently be implemented: afl_custom_(de)init Each custom mutator can use these self-explaining functions to initialize or deinitialize the module, afl_custom_init and afl_custom_deinit. The AFL ++ 's pseudo-random generator seed is passed to init. The custom mutator should then make sure that fuzzing results are reproducible given the same seed.</p><p>afl_custom_queue_get is a callback that determines whether the custom fuzzer should fuzz the current queue entry or not. In this routine, the user can also perform the initialization of associated metadata for an input, for instance, the virtual structure for structured fuzzing.</p><p>afl_custom_fuzz performs custom mutations on a given input. It accepts an additional test case.</p><p>afl_custom_havoc_mutation performs a single custom mutation on a given input. This mutation is stacked with the other mutations in the havoc stage. The afl_custom_havoc_mutation_probability returns the probability that the custom mutation is called in havoc enabling tuning (defaults to 6%, inspired by AFLSMART).</p><p>afl_custom_post_process In some cases, the format of the mutated data returned from the custom mutator is not suitable to directly execute the target with this input. For example, when using libprotobuf-mutator, the data returned is in a protobuf format which corresponds to a given grammar, that first need to be converted to the target's plain-text format. In such scenarios, or to fix checksums and sizes, the user can define the afl_custom_post_process function.</p><p>afl_custom_queue_new_entry is called after adding a new test case to the queue, a useful hook to store metadata on disk.</p><p>Trimming Support The generic trimming routines implemented in AFL ++ (Sec. 2.1.1) may destroy the structure of complex formats. This is especially the case when your target can process a part of the input (causing coverage) and then errors out on the remaining input. In such cases, it makes sense to implement a custom trimming routine. The API consists of multiple methods because after each trimming step, the coverage bitmap has to be against the map before trim.</p><p>afl_custom_init_trim is called at the start of each trimming operation and receives the initial buffer. It should return the number of iteration steps possible on this input (e.g. if the input has n elements of which one should be removed, returning n-1). If the implemented trimming algorithm doesn't allow for determining the amount of (remaining) steps, then it can return 1 to indicate that further trimming could be performed, which will be performed while afl_custom_post_trim returns 0.</p><p>afl_custom_trim is called for each trimming operation. It memorizes the current state and hence can save reparsing steps for each iteration. It should return the trimmed input buffer, where the returned data must not exceed the initial input data in length.</p><p>afl_custom_post_trim is called after each trim operation to inform if the trimming step was successful or not (in terms of the same coverage). This method must return the next trim iteration index (from 0 to the maximum amount of steps returned in afl_custom_init_trim).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Input-To-State Mutator</head><p>AFL ++ implements a mutator based on REDQUEEN's InputTo-State (I2S) replacement. In addition to what is described above, we made a few optimizations to improve upon the original implementation.</p><p>Firstly, colorization seems to be very effective in increasing the entropy of the bytes in the input but can slow down the fuzzer a lot, if, for instance, a critical field, such as a size field, is randomly mutated. We extended colorization to keep the mutated regions not simply when the hash of the coverage bitmap remains the same, but also when the execution speed remains in the bounds of a 2x slowdown from the original. This improvement seems to make the difference in pathological targets for REDQUEEN.</p><p>Another extension is a probabilistic fuzzing of each comparison. If the fuzzer fails to generate an interesting input when trying to bypass a comparison, the next time this comparison will be fuzzed with a lower probability. This avoids spending too much time on unsolvable comparisons that seem I2S but that are not.</p><p>CmpLog Instrumentation This mutator does not log comparisons operands using breakpoints, like in the original REDQUEEN implementation, but uses a shared table similar to the one used by Fioraldi et al. for WEIZZ <ref type="bibr" target="#b13">[15]</ref>. Each comparison logs the operands of its last 256 executions in a 256 MB table shared between fuzzer and target.</p><p>The first part of the table maintains metadata for each comparison, like the size, the ID, and the real number of executions. The total size of 512 KB can be traversed in an efficient way in terms of cache locality. The metadata suffices to register if a comparison is not used, and the memory corresponding to the operand is never accessed. This instrumentation is available for the LLVM and QEMU instrumentations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">MOpt Mutator</head><p>AFL ++ implements the Core and the Pilot mode of MOPT. In addition to this, MOPT was patched for AFL ++ , so that it can be combined with the Input-To-State mutator. On top, AFL ++ supports interleaving of MOPT with the standard mutation modes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Instrumentations</head><p>AFL ++ supports several backends for instrumentation: LLVM, GCC, QEMU, Unicorn and QBDI. On top, it provides a proxy module that can be adapted to forward test cases to targets and give any kind of coverage to afl-fuzz, even remote and noncoverage, such as ampere consumption or branch addresses of JTAG. <ref type="table">Table 1</ref> resumes the state of the implementation of the most important features discussed in Section 3 for each instrumentation backend.</p><p>NeverZero Orthogonally to the backend used for instrumentation, we developed an optimization to the hitcount mechanism of AFL. One problem of using a byte for the bitmap entries is, that the count of the edge executions can overflow. When this happens, we observed that if an edge is hit in multiples of 256 -overflowing the corresponding bitmap entry to 0 -the fuzzer is in an inconsistent state. We tried to solve this problem with two solutions, NeverZero, and Saturated Counters. The first avoids the overflow to 0 always adding the carry flag to the bitmap entry and so, if an edge is executed at least one time, the entry is never 0. The second freezes the counter when it reaches the value of 255. In a range of experiments, we observed that NeverZero is very effective and improves AFL in terms of coverage and speed (the seed selection now takes into account edges that were hidden before). Saturated Counters, however, decreases AFL's overall performance. We opted to make NeverZero the default for AFL ++ on most of the available instrumentations. Saturated Counters are still available in a branch of the AFL ++ repository for further research or reproduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">LLVM</head><p>We support from LLVM <ref type="bibr" target="#b21">[23]</ref> 3.4 up to LLVM 11, which is in beta at the time of writing. In LLVM mode, AFL ++ supports a range of coverage metrics in addition to edge coverage <ref type="bibr" target="#b41">[43]</ref>:</p><p>Context-sensitive Edge Coverage edge coverage is XORing the assigned ID of each block with the unique ID of the callee. This solution was firstly explored in <ref type="bibr" target="#b10">[12]</ref> and seems effective in terms of code coverage, with the penalty to have more collisions and less speed.</p><p>Ngram instead of considering the previous block and the destination block when logging an edge, the fuzzer considers the destination block and the N-1 previous blocks where N is a number between 2 and 16.</p><p>In addition to the LLVM pass that instruments for coverage feedback, AFL ++ ships several additional passes. All LAF-INTEL passes are included, with an experimental mode to split also floating-point comparisons that are abundant in software like video decoders or Javascript interpreters. Additionally the string comparison function analysis was improved to be able to process global and local variables when assigned a fixed string. The CmpLog passes are available, too, as discussed in the previous sections. A widely used feature, for example by Fratrik <ref type="bibr" target="#b27">[29]</ref>, is the list of files to instrument, firstly introduced by <ref type="bibr" target="#b17">[19]</ref>. In LLVM mode the user can specify specific source modules to instruments. This is very useful, for instance, with It reduces the number of instrumented locations to at least half of the standard instrumentation on most targets and so improves the fuzzer in terms of performance in speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">GCC</head><p>Alongside the old afl-gcc wrapper, AFL ++ ships a GCC plugin. It includes support to deferred initialization and persistent mode, like AFL LLVM mode. The supported features are not on par with LLVM, but additional features are planned in AFL ++ , with the goal of reaching feature parity eventually.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">QEMU</head><p>The AFL QEMU patches for version 2.1 for binary-only fuzzing are almost completely replaced in AFL ++ with a better set of patches based on QEMU 3.1.1. In comparison to other binary-only instrumentations, such as retrowrite based on binary patching <ref type="bibr" target="#b11">[13]</ref>, QEMU mode adds instrumentation at emulation time. The basic blocks transitions are now not anymore logged in the context of the emulator when selecting a block in QEMU but the call to the logging routine is inlined using a helper. In this way, we can re-enable the blocks linking that AFL disabled (as firstly shown in a thread-unsafe way by <ref type="bibr" target="#b6">[8]</ref>) with an average speedup of 2-3x. The use of a helper enables also the use of Thread Local Storage, a concept not supported in TCG <ref type="bibr" target="#b1">[3]</ref>. Recently, our QEMU mode was extended by Fioraldi, with QAsan <ref type="bibr" target="#b14">[16]</ref>, to support sanitization against heap violations incorporating a Dynamic Binary Translation based implementation of AddressSanitizer <ref type="bibr" target="#b36">[38]</ref>.</p><p>CompareCoverage In order to decrease the gap of features between source-level and binary-level fuzzing, AFL ++ QEMU mode can split comparisons in a similar way to LAF-INTEL using CompareCoverage <ref type="bibr" target="#b29">[31]</ref>. Unlike the LLVM pass, the code is not modified, but all comparisons are hooked and each byte of each operand is compared, increasing a different bitmap entry if equal. This instrumentation is similar to the popcnt based instrumentation of LIBFUZZER, but at a byte level, produceing so fewer inputs to avoid path explosion, an issue that makes the value-profile mode of LIBFUZZER less effective than normal mode on some targets. It can be configured to split only integer comparisons with immediate operands, all integer comparisons, or all integer and floatingpoint comparisons.</p><p>Persistent Mode Unlike the old QEMU mode, AFL ++ 's QEMU-mode supports persistent mode. There are two main ways to achieve this:</p><p>1. Looping around a function: like WINAFL <ref type="bibr" target="#b15">[17]</ref>, the user can specify the address of a function, and automatically the fuzzer will use it in a persistent loop patching the return address. The address can be also not the first instruction of a function, but in this configuration, the user has to provide the offset on the stack to correctly locate the return address to patch;</p><p>2. Specify entry and exit points: a user can specify the address of the first and the last instruction of the loop and QEMU will emit code a runtime to generate a loop between those addresses;</p><p>This mode can even reach a 10x speedup and is recommended when possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.4">Unicornafl</head><p>For fuzzing blob binaries like firmware, AFL ++ incorporates a fork of afl-unicorn by Voss <ref type="bibr" target="#b38">[40]</ref>, which adds AFL support to the Unicorn Engine <ref type="bibr" target="#b28">[30]</ref>, called unicornafl. While the original version by Voss started the forkserver on the initial basic block, and was only available through the garbage-collected python, AFL ++ 's unicornafl adds a low-level C API, Rust and Python bindings, to interact with AFL ++ directly. Unicorn already includes APIs to set page mappings, read and write memory and registers, add hooks, as well as start and stop execution with different conditions. AFL ++ -specific APIs allow the harness to kick off the fast persistent mode at any time, as well as to set multiple exits and post-fuzzing handlers to detect crashes.</p><p>The API offers uc_afl_forkserver_start, a specific call to kick off the fork server at a certain point in time, effectively freezing the current state prior to a fuzzing run and telling AFL ++ to start generating inputs.</p><p>A special uc_afl_fuzz function serves as a one-stop-shop, directly reading input for each test case -with support for persistent mode. The target firmware is kept in the same state in the parent process, each fuzz test case is executed against a forked copy of the emulator. Furthermore, the forkserver contains a caching mechanism for Unicorn's JIT, inspired by the AFL QEMU mode. Unicornafl patches instrumentation into the translated blocks directly, reducing the need for indirect jumps, re-enabling the optimized blocks linking like already discussed for QEMU mode. The function uc_afl_fuzz:</p><p>1. Loads the current input.</p><p>2. Calls the place_input_callback. Here, the harness should write the input into the emulator memory at the appropriate position. For persistent mode, the emulator has to reset additional state changes in this step.</p><p>3. Emulates until one of the exits is reached, execution is cancelled by a hook, or an illegal state occurs.</p><p>4. Checks the Unicorn return and (optionally) calls the crash_validation_callback, where additional postprocessing can be done to spot crashes.</p><p>5. For persistent mode, loops back to step 3.</p><p>The fuzz function also takes a list of exits at which emulation will stop, a flag whether the validation callback should also be called without a Unicorn error condition and an additional integer counter, indicating if-and how oftenpersistent mode should loop before forking again. Maier et al. were able to use it, on top of AFL ++ , to fuzz kernels <ref type="bibr" target="#b24">[26]</ref> and even a cellular baseband rtos <ref type="bibr" target="#b25">[27]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.5">QBDI</head><p>AFL ++ can fuzz Android libraries with compiler instrumentation using LLVM, but can also instrument closed-source libraries. It supports harnessing with QuarksLab's QBDI Dynamic Binary Instrumentation <ref type="bibr" target="#b19">[21]</ref> framework for Android native libraries. An example is shipped with the source distribution of AFL ++ , making the usage and the extension very simple.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Platform Support</head><p>The support to several Operating Systems and distribution is maintained in AFL ++ . Besides GNU/Linux, the fuzzer runs on Android, iOS, macOS, FreeBSD, OpenBSD, NetBSD and is packaged in several popular distributions like Debian, Ubuntu, NixOS, Arch Linux, FreeBSD, Kali Linux and more. For this broad range of support, many features, like libdislocator, the AFL allocator to catch memory errors, had to be ported to several different Operating Systems and extended with previously unsupported allocation routines, like posix_memalign(). On top, AFL ++ 's QEMU <ref type="bibr" target="#b5">[7]</ref> mode, has a Wine <ref type="bibr">[1]</ref> mode, that can fuzz compatible Win32 binaries on GNU/Linux.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Snapshot LKM</head><p>The AFL state-restore mechanism based on fork() is wellknown to be a performance bottleneck for a large number of targets. Hence, AFL ++ integrates a Linux Kernel Module 1 , inspired by Perffuzz by Xu <ref type="bibr" target="#b43">[45]</ref>. Perffuzz implements a lightweight mechanism for process snapshot and restore. The average gain in performance on a single core with our module, compared to fork, is up to 2x, but the difference increases when running parallel fuzzing on many cores due to the locks in the kernel implementation of fork(). The use of snapshots, instead of fork, does not require a recompilation of the target program. Instead, once the driver is loaded, the module's presence is automatically detected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Evaluation Use Cases</head><p>This section gives an insight into the fuzzing performance of some of the technologies discussed in Sect. 3 that are published research, and a usable part of AFL ++ . To show AFL ++ in action, we also discuss combinations that were not possible otherwise, in their respective forked tools, such as the powerful combination of RedQueen and MOpt.</p><p>For the evaluation in this section, we use AFL ++ together with FuzzBench <ref type="bibr" target="#b20">[22]</ref> to reproduce and evaluate the state of the art (Evaluation of FuzzBench). AFL ++ can be used to compare a wide range of fuzzing concepts against each other. In the following, we highlight a few interesting insights gathered over the last months in various tests. These are example runs, combinations, and evaluations that a new tool using AFL ++ as baseline can do, with the help of FuzzBench.</p><p>As the range of features incorporated into AFL ++ would exceed the scope of this paper, we picked 6 specific configurations:</p><p>1.</p><p>[Default] the default AFL setup, with some specific fixes and improvements 2. MOpt A very effective mutator, discussed in Sect. 3.2.3. The final data, discussed here, was collected using the FuzzBench service <ref type="bibr" target="#b20">[22]</ref>. FuzzBench is a novel service by Google, offering fuzzing evaluations on a fixed set of 21 targets for originally 24 and now 23 hours each to all interested projects. Each run is redone about 20 times to get to a meaningful median of the Edge Coverage, as randomness in fuzz tests can produce accidental strong single runs, yet a good fuzzer should produce good results consistently.</p><p>From the total of 21 FuzzBench targets, we selected the following 9 due to their specific characteristics, showing visible outlier behavior. We selected 6 stand-out combinations we will discuss as part of this evaluation, from the larger number of AFL ++ features we tested and looked at during the evaluation. All other test cases and targets not discussed here are available on FuzzBench for the avid reader in AFL ++ specific and general FuzzBench runs. The final data for this evaluation was taken from FuzzBench run 2020-04-21-and-20-aflplusplus 2 .</p><p>With the selected 6 combinations, we try to show that:</p><p>• If we consider MOPT and Ngram4 as an example of possible novel techniques, we can get useful insights combining them with other orthogonal techniques like other mutators (REDQUEEN) and power schedules (rare);</p><p>• During this run, it becomes apparent, that all fuzzing behavior is highly target-specific so the importance of a good choice of a suitable configuration is crucial;</p><p>RedQueen In many areas, RedQueen is able to pass roadblocks no other configuration can, however not all targets have instructions where this method can help. One of these is the libpcap example, see <ref type="figure">Fig. 1g</ref>. Here, only RedQueen is able to reach any sorts of depth, as the I2S replacement allowed this configuration to bypass roadblocks the other configurations are unable to randomly guess. The MOpt mutator helps to further increase the coverage in this case. For OpenThread RedQueen also performs extremely well, fast, see <ref type="figure">Fig. 1a</ref>, but interestingly only if not paired with MOpt.</p><p>MOpt MOpt shows to either be a hit or miss -often it is highly effective, however when it is not, the performance is often very bad, with little middle ground. For mbedtls, see <ref type="figure">Fig. 1h</ref>, MOpt suddenly starts gaining a massive amount of new coverage. Mopt is able to find new paths in the middle of the run and outperform any other configuration by far. As this happens for multiple runs in the median, this is not a one-time event, but appears to be target-specific. The combination RedQueen and MOpt in the harfbuzz target is the clear winner, see <ref type="figure">Fig. 1e</ref>, just as in the libpcap target, <ref type="figure">Fig. 1g</ref>, where only RedQueen reaches any sort of depth, and MOpt adds to the positive results. In the bloaty fuzz target, where RedQueen takes some time to catch up, MOpt proves very helpful, see <ref type="figure">Fig. 1b</ref> For libjpeg-turbo MOpt has a high impact on the behavior of RedQueen, changing the median coverage graph almost completely, see <ref type="figure">Fig. 1d</ref>.</p><p>However, one very interesting observation can be made for the lcms target, where positive effects of RedQueen counters negative effects of MOpt in lcms, see <ref type="figure">Fig. 1i</ref>.</p><p>Ngram Ngram (of length 4 in our tests) can be an effective instrumentation method to reach more depth, as branch instrumentation depends on prior branches, effectively adding a bit of state feedback. The zlib example is such a case, see <ref type="figure">Fig. 1i</ref>. As is the case with almost all combinations, Rare scheduling sometimes improves, sometimes fares worse than the default AFL ++ scheduling. Another target is libxml2, where MOpt performs badly, RedQueen has close to no effect, but Ngram4 shines 1c.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">AFL++ Optimal</head><p>In the previous section we assessed the effectiveness of a range of fuzzing technologies implemented in AFL ++ and how they interact when combined.</p><p>Typically, in real-word fuzzing campaigns, this is just the first step, and after a first evaluation of different configurations is carried out by a security researcher, the fine-tuning starts.</p><p>Based on our evaluations on FuzzBench, we performed hand-picked setups of AFL ++ for a given target, in runs we call AFL ++ Optimal. This is an ongoing process, and will improve even further over time. The learning will, in turn, lead to better defaults in the fuzzer. For instance, SanitizerCoverage was found to be the best instrumentation option for most cases and therefore made the default.</p><p>We hand-crafted and enabled AFL++ Optimal for 13 of the 21 available targets. With this, the average normalized score of the percentage of the highest reached median coverage for each target increased by 7% and AFL ++ Optimal generally outperforms all other fuzzers on FuzzBench 3 .   Median edge coverage growth with 66% confidence interval produced by each fuzzer over 20 trials at 24 hours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">m 3 h :1 m 6 h :1 m 9 h :1 m 1 2 h :1 m 1 h :1 m 1 8 h :1 m 2 1 h :1 m 2 4 h Time</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>m 6 h :1 5 m 9 h :1 5 m 1 2 h :1 5 m 1 5 h :1 5 m 1 8 h :1 5 m 2 1 h :1 5 m 2 4 h Time</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Future Work</head><p>While the AFL ++ project has reached good progress over the past year, there are bigger research and engineering problems yet to be addressed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Scaling</head><p>Currently, AFL ++ 's scaling to multiple threads is less than ideal. Due to its decision to use the file system for test case delivery, at least for the backends that are not LLVM, and due to the reliance on the fork() syscall for certain targets, a larger part of the time is spent in the kernel. The development of the Linux Kernel Mode for snapshots is the first step in this direction. We made the AFL ++ code fully thread-safe. The logical next step will multi-threading support, minimizing the overhead for synchronization between parallel fuzzers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Collision-Free instrumentation</head><p>The original instrumentation offered by AFL hashes the current jump from and to addresses, in a way that potentially collides. This is seen as a trade-off between speed and accuracy, a problem that we strife to solve in the near future for both instrumentations based on source code and on emulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Static Analysis for Optimal Fuzz Settings</head><p>We do the research presented in this paper to optimize the presets of AFL ++ . The current goal is to use the most commonly best instrumentation, mutation and scheduling as the default configuration. However, as we showed in Sect. 4, the optimum depends heavily on the target. For future work, finding indications for these through prior static analysis of the target could suggest a best-effort optimum solution -for example a lot of strcmp could be an indication to use RedQueen and others. This work will be based on the results of AFL ++ Optimal, discussed in Sect 4.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Plug-in System</head><p>While Custom Mutator already grants large flexibility to researchers, the goal is to add additional plug-in functionality to replace or add functionality to building blocks such as schedulers, executors and queues.</p><p>Additional feedbacks in addition to hitcounts coverage will be supported, reimplementing from scratch the ideas shown in <ref type="bibr" target="#b40">[42]</ref> [32] <ref type="bibr" target="#b2">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>The tool discussed in this paper, AFL ++ , tries to integrate many of the major fuzzing research of late, where this is feasible to integrate in the current AFL ++ architecture and our own benchmark show that there is a real-world improvement of the technique -at the least for corner cases.</p><p>After benchmarking all implemented functionality on a clear playing field, as laid out in Sect. 4, it becomes apparent that this is an important step for fuzzing research and development. Each proposed optimization shines for specific targets while it may perform less than ideal for others. the evaluation shows this is a clear benefit, for performance, as well as for comparability of research.</p><p>On top, AFL ++ bridges the gap between academia and industry, making academic advancements available to everybody in an easy-to-use fashion. With the help of AFL ++ , a wide variety of real-world bugs could already be uncovered and patched, such as the bugs found by the community and listed in <ref type="table">Table 2</ref>.</p><p>Over the course of more than a year, we were able to gain further insights into fuzzing thanks to the work put into AFL ++ . This provided us with the opportunity to fine-tune the An excerpt of public bugs found by the community using AFL++</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Program</head><p>Bugs Discovered by <ref type="bibr">CVE-2019</ref><ref type="bibr">-14437 CVE-2019</ref><ref type="bibr">-14438 CVE-2019</ref><ref type="bibr">-14498 CVE-2019</ref><ref type="bibr">-14533 CVE-2019</ref><ref type="bibr">-14534 CVE-2019</ref><ref type="bibr">-14535 CVE-2019</ref><ref type="bibr">-14776 CVE-2019</ref><ref type="bibr">-14777 CVE-2019</ref><ref type="bibr">-14778 CVE-2019</ref><ref type="bibr">-14779 CVE-2019</ref> Antonio With AFL ++ as a platform, we hope to give researchers a quick and easy start to prototype and implement new ideas and strategies. The Custom Mutator API plug-in system makes it easy to prototype new research ideas and offers industry professionals an easy way to tailor test cases to their target, while still profiting from academic research and features. Using its proxy, it can even be adapted to completely new targets, servers, embedded targets, and more. Hopefully, future research can directly be based on AFL ++ 's APIs, further improving the state-of-the-art.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VLC</head><p>In conclusion, we invite researchers to contribute to the growth of AFL ++ itself as a tool of interest for the community. AFL ++ is -and always will be -Free and Open Source Software.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>1</head><label></label><figDesc>https://github.com/AFLplusplus/AFL-Snapshot-LKM 3. Ngram4 A different instrumentation, interpreting the 4 following basic blocks as a unique path. 4. RedQueen Cmplog/RedQueen, an additional feedback channel to the fuzzer to reach greather depth, see Sect. 3.2.2 5. Ngram4, Rare The Ngram4 instrumentation, paired with Rare scheduling 3.1, a unique combination in AFL ++ . 6. MOpt, RedQueen The MOpt mutation, paired with RedQueen -another unique combination in AFL ++ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table with supported features for each instrumentation backend afl-gcc LLVM mode GCC plugin QEMU mode UNICORN mode QBDI mode</head><label>with</label><figDesc>targets that process many input formats and the user wants to focus only on one of them. In persistent mode, in addition to the standard ways to pass the input to the target in AFL (stdin or file), AFL ++ can also pass in new test cases through shared memory. This configuration brings an additional speedup of 2x to persistent mode, resulting in an overall speedup of up to 10-20x in respect to fork mode, in our initial tests. AFL ++ LLVM mode also implements the INSTRIM [20] patches, combined with all the previously exposed features. INSTRIM is an efficient way to select basic blocks when instrumenting in LLVM. It avoids to place useless instru- mentation thanks to an analysis based on Dominator Tree.</figDesc><table>NeverZero 




Persistent mode 





LAF-INTEL/ CompCov 



CmpLog 


Instrument filelist 


partial 
InsTrim 

Ngram/Ctx coverage 

Snapshot LKM 


</table></figure>

			<note place="foot" n="2"> https://www.fuzzbench.com/reports/2020-04-21-and-20-aflplusplus/index.html</note>

			<note place="foot" n="3"> https://www.fuzzbench.com/reports/2020-06-30/index.html</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Circumventing Fuzzing Roadblocks with Compiler Transformations</title>
		<ptr target="https://lafintel.wordpress" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tiny Code Generator</surname></persName>
		</author>
		<ptr target="https://wiki.qemu.org/Documentation/TCG" />
		<imprint>
			<date type="published" when="2019" />
			<publisher>TCG</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Ijon: Exploring deep state spaces via fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cornelius</forename><surname>Aschermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergej</forename><surname>Schumilo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ali</forename><surname>Abbasi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thorsten</forename><surname>Holz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<meeting><address><addrLine>Oakland</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page">2020</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">REDQUEEN: fuzzing with input-to-state correspondence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cornelius</forename><surname>Aschermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergej</forename><surname>Schumilo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Blazytko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Gawlik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thorsten</forename><surname>Holz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th Annual Network and Distributed System Security Symposium, NDSS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A survey of symbolic execution techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Baldoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emilio</forename><surname>Coppa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniele</forename><surname>Cono D&amp;apos;elia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Camil</forename><surname>Demetrescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Irene</forename><surname>Finocchi</surname></persName>
		</author>
		<idno>50:1-50:39</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Qemu, a fast and portable dynamic translator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabrice</forename><surname>Bellard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual Conference on USENIX Annual Technical Conference, ATEC &apos;05</title>
		<meeting>the Annual Conference on USENIX Annual Technical Conference, ATEC &apos;05<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="41" to="41" />
		</imprint>
	</monogr>
<note type="report_type">USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Improving AFL&apos;s QEMU mode performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Biondo</surname></persName>
		</author>
		<ptr target="https://abiondo.me/2018/09/21/improving-afl-qemu-mode" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Entropic: Boosting LibFuzzer Performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcel</forename><surname>Böhme</surname></persName>
		</author>
		<ptr target="https://reviews.llvm.org/D73776" />
		<imprint>
			<biblScope unit="page">2020</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Boosting fuzzer efficiency: An information theoretic perspective</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcel</forename><surname>Böhme</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valentin</forename><surname>Manès</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sang</forename><forename type="middle">Kil</forename><surname>Cha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th Joint meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering, ESEC/FSE</title>
		<meeting>the 14th Joint meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering, ESEC/FSE</meeting>
		<imprint>
			<date type="published" when="2020" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Coverage-based greybox fuzzing as markov chain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcel</forename><surname>Böhme</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Van-Thuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abhik</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Roychoudhury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;16</title>
		<meeting>the 2016 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1032" to="1043" />
		</imprint>
	</monogr>
	<note>Association for Computing Machinery</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Angora: Efficient fuzzing by principled search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peng</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hao</forename><surname>Chen</surname></persName>
		</author>
		<idno>abs/1803.01307</idno>
		<imprint>
			<date type="published" when="2018" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Retrowrite: Statically instrumenting cots binaries for fuzzing and sanitization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dinesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Burow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongyan</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathias</forename><surname>Payer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P 2020</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Peach fuzzing platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Eddington</surname></persName>
		</author>
		<ptr target="http://community.peachfuzzer.com/WhatIsPeach.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">WEIZZ: Automatic grey-box fuzzing for structured binary formats</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Fioraldi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniele</forename><surname>Cono D&amp;apos;elia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emilio</forename><surname>Coppa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis</title>
		<meeting>the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2020" />
			<biblScope unit="volume">2020</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Fuzzing binaries for memory safety errors with QASan</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Fioraldi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniele</forename><surname>Cono D&amp;apos;elia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leonardo</forename><surname>Querzoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 IEEE Secure Development Conference (SecDev)</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ivan</forename><surname>Fratric</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Winafl</surname></persName>
		</author>
		<ptr target="https://github.com/googleprojectzero/winafl" />
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Heuse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heiko</forename><surname>Eißfeldt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Fioraldi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dominik</forename><surname>Maier</surname></persName>
		</author>
		<ptr target="https://aflplus.plus/docs/" />
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Holler&apos;s AFL fork</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Holler</surname></persName>
		</author>
		<ptr target="https://github.com/choller/afl" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Instrim: Lightweight instrumentation for coverage-guided fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chin-Chia</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Che-Yu</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hsu-Chun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shihkun</forename><surname>Hsiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Huang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Implementing an LLVM based dynamic binary instrumentation framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Tessier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hubain</surname></persName>
		</author>
		<ptr target="https://qbdi.quarkslab.com/QBDI_34c3.pdf" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">FuzzBench: Fuzzer benchmarking as a service</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">László</forename><surname>Szekeres</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Metzman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abhishek</forename><surname>Arya</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020-03" />
			<publisher>Google Security Blog</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">LLVM: An Infrastructure for Multi-Stage Optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Lattner</surname></persName>
		</author>
		<ptr target="http://llvm.cs.uiuc.edu" />
		<imprint>
			<date type="published" when="2002-12" />
			<pubPlace>Urbana, IL</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science Dept., University of Illinois at Urbana-Champaign</orgName>
		</respStmt>
	</monogr>
	<note>Master&apos;s thesis</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Fairfuzz: A targeted mutation strategy for increasing greybox fuzz testing coverage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Caroline</forename><surname>Lemieux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering, ASE 2018</title>
		<meeting>the 33rd ACM/IEEE International Conference on Automated Software Engineering, ASE 2018<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="475" to="485" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">MOPT: Optimized mutation scheduling for fuzzers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chenyang</forename><surname>Lyu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shouling</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chao</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuwei</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weihan</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raheem</forename><surname>Beyah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28th USENIX Security Symposium (USENIX Security 19)</title>
		<meeting><address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-08" />
			<biblScope unit="page" from="1949" to="1966" />
		</imprint>
	</monogr>
<note type="report_type">USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Unicorefuzz: on the viability of emulation for kernelspace fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dominik</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benedikt</forename><surname>Radtke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bastian</forename><surname>Harren</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th USENIX Workshop on Offensive Technologies (WOOT 19)</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">BaseSAFE: BasebandSAnitized Fuzzing through Emulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dominik</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lukas</forename><surname>Seidel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shinjo</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th ACM Conference on Security and Privacy in Wireless and Mobile Networks</title>
		<meeting><address><addrLine>Linz; Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020-07-20" />
		</imprint>
	</monogr>
	<note>Virtual Event</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Valentin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hyungseok</forename><surname>Manès</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Choongwoo</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sang</forename><forename type="middle">Kil</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><forename type="middle">J</forename><surname>Egele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maverick</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Woo</surname></persName>
		</author>
		<title level="m">The art, science, and engineering of fuzzing: A survey. arXiv: Cryptography and Security</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Fuzzing software: common challenges and potential solutions (Part 1) -GitHub Security Lab</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antonio</forename><surname>Morales</surname></persName>
		</author>
		<ptr target="https://securitylab.github.com/research/vlc-vulnerability-heap-overflow" />
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Unicorn: Next generation cpu emulator framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anh</forename><surname>Quynh Ngyuen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hoang</forename><surname>Vu Dang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Making Software Dumberer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tavis</forename><surname>Ormandy</surname></persName>
		</author>
		<ptr target="http://taviso.decsystem.org/making_software_dumber.pdf" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Fuzzfactory: Domain-specific fuzzing with waypoints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rohan</forename><surname>Padhye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Caroline</forename><surname>Lemieux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laurent</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hayawardh</forename><surname>Vijayakumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. ACM Program. Lang</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<date type="published" when="2019-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">T-fuzz: Fuzzing by program transformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Payer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE Symposium on Security and Privacy (SP)</title>
		<imprint>
			<date type="published" when="2018-05" />
			<biblScope unit="page" from="697" to="710" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Boehme</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Santosa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">R</forename><surname>Caciulescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
		<title level="m">Smart greybox fuzzing. IEEE Transactions on Software Engineering</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Vuzzer: Application-aware evolutionary fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vivek</forename><surname>Sanjay Rawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lucian</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristiano</forename><surname>Cojocar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herbert</forename><surname>Giuffrida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th Annual Network and Distributed System Security Symposium, NDSS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Kafl: Hardware-assisted feedback fuzzing for os kernels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergej</forename><surname>Schumilo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cornelius</forename><surname>Aschermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Gawlik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Schinzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thorsten</forename><surname>Holz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th USENIX Conference on Security Symposium, SEC&apos;17</title>
		<meeting>the 26th USENIX Conference on Security Symposium, SEC&apos;17<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="167" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">All you ever wanted to know about dynamic taint analysis and forward symbolic execution (but might have been afraid to ask)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><forename type="middle">J</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thanassis</forename><surname>Avgerinos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 IEEE Symposium on Security and Privacy, SP 2010</title>
		<meeting>the 2010 IEEE Symposium on Security and Privacy, SP 2010</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="317" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Addresssanitizer: A fast address sanity checker</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konstantin</forename><surname>Serebryany</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Derek</forename><surname>Bruening</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Potapenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dmitry</forename><surname>Vyukov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 USENIX Conference on Annual Technical Conference, USENIX ATC&apos;12, page 28. USENIX Association</title>
		<meeting>the 2012 USENIX Conference on Annual Technical Conference, USENIX ATC&apos;12, page 28. USENIX Association</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yan</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruoyu</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Salls</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Stephens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mario</forename><surname>Polino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Audrey</forename><surname>Dutcher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Grosen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Siji</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christophe</forename><surname>Hauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giovanni</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">afl-unicorn: Fuzzing arbitrary binary code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Voss</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">libfuzzer-ng: enhanced fork of libFuzzer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guido</forename><surname>Vranken</surname></persName>
		</author>
		<ptr target="https://github.com/guidovranken/libfuzzer-gv" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">VrankenFuzz a multi-sensor, multi-generator mutational fuzz testing engine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guido</forename><surname>Vranken</surname></persName>
		</author>
		<ptr target="https://guidovranken.files.wordpress.com/2018/07/vrankenfuzz.pdf" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Be sensitive and collaborative: Analyzing impact of coverage metrics in greybox fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jinghan</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yue</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengyu</forename><surname>Heng Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">22nd International Symposium on Research in Attacks, Intrusions and Defenses (RAID 2019)</title>
		<meeting><address><addrLine>Chaoyang District, Beijing</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2019-09" />
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Taintscope: A checksum-aware directed fuzzing tool for automatic software vulnerability detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2010-05" />
			<biblScope unit="page" from="497" to="512" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Designing new operating primitives to improve fuzzing performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wen</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanidhya</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Changwoo</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;17</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;17<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="2313" to="2328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Bit-level taint analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Yadegari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Debray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 14th International Working Conference on Source Code Analysis and Manipulation (SCAM)</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="255" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">American Fuzzy LopWhitepaper</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michał</forename><surname>Zalewski</surname></persName>
		</author>
		<ptr target="https://lcamtuf.coredump.cx/afl/technical_details.txt" />
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
