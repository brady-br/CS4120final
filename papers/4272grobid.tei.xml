<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:08+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Temporal System Call Specialization for Attack Surface Reduction Temporal System Call Specialization for Attack Surface Reduction</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seyedhamed</forename><surname>Ghavamnia</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Stony Brook University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tapti</forename><surname>Palit</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Stony Brook University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shachee</forename><surname>Mishra</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Stony Brook University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michalis</forename><surname>Polychronakis</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Stony Brook University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seyedhamed</forename><surname>Ghavamnia</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Stony Brook University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tapti</forename><surname>Palit</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Stony Brook University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shachee</forename><surname>Mishra</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Stony Brook University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michalis</forename><surname>Polychronakis</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Stony Brook University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Temporal System Call Specialization for Attack Surface Reduction Temporal System Call Specialization for Attack Surface Reduction</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Attack surface reduction through the removal of unnecessary application features and code is a promising technique for improving security without incurring any additional overhead. Recent software debloating techniques consider an applica-tion&apos;s entire lifetime when extracting its code requirements, and reduce the attack surface accordingly. In this paper, we present temporal specialization, a novel approach for limiting the set of system calls available to a process depending on its phase of execution. Our approach is tailored to server applications, which exhibit distinct ini-tialization and serving phases with different system call requirements. We present novel static analysis techniques for improving the precision of extracting the application&apos;s call graph for each execution phase, which is then used to pinpoint the system calls used in each phase. We show that requirements change throughout the lifetime of servers, and many dangerous system calls (such as execve) can be disabled after the completion of the initialization phase. We have implemented a prototype of temporal specialization on top of the LLVM compiler, and evaluated its effectiveness with six popular server applications. Our results show that it disables 51% more security-critical system calls compared to existing library specialization approaches, while offering the additional benefit of neutralizing 13 more Linux kernel vulnerabilities that could lead to privilege escalation.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Modern software is complex. Applications typically support a wide range of functionalities for different use cases <ref type="bibr" target="#b32">[28,</ref><ref type="bibr" target="#b53">49]</ref>, as evidenced by the existence of multiple features, options, and configuration settings. To support these different features, programs typically require access to a vast range of privileged operations from the OS kernel (e.g., allocating memory, creating new processes, and accessing files or the network), which are made available through the system call interface.</p><p>Some of these capabilities, however, are used by the application only once during startup, and are never used again during the lifetime of the program. This is especially true for server applications, which once launched, remain running and serving requests for a long period of time. This means that all kernel capabilities (i.e., system calls) remain available to a potentially vulnerable process, and can thus be used as part of exploitation attempts.</p><p>Software debloating and specialization has recently gained popularity as a technique for removing or constraining unused parts of applications, with the goal of reducing the code and features available to attackers. While some approaches use static analysis to identify unused parts of shared libraries <ref type="bibr" target="#b15">[12,</ref><ref type="bibr" target="#b55">51]</ref>, others rely on dynamic analysis and training to identify unneeded parts of the application <ref type="bibr" target="#b16">[13,</ref><ref type="bibr" target="#b24">21,</ref><ref type="bibr" target="#b52">48]</ref>. Similar techniques have also been applied on containers to constrain the set of system calls available to the hosted programs <ref type="bibr" target="#b25">[22,</ref><ref type="bibr" target="#b42">38,</ref><ref type="bibr" target="#b63">59]</ref>. A key shared characteristic of the above approaches is that they consider the entire lifetime of a program as part of the scope of their analysis.</p><p>In this paper, we explore software specialization from a different perspective, and present temporal system call specialization, a novel attack surface reduction approach for limiting even further the set of system calls that are available to a process, depending on its phase of execution. Instead of treating each application as a single, monolithic entity with an unchanging set of requirements, temporal specialization takes into consideration the changes in an application's requirements throughout its execution lifetime. In particular, we focus on server applications, which typically exhibit two distinct initialization and serving phases.</p><p>Our main motivation is that many dangerous system calls, such as execve, which are frequently used as part of exploit code, are often not removed by existing code debloating and specialization techniques, because they are required by the application for legitimate purposes. Crucially, however, operations such as spawning new processes or creating listening sockets are typically only performed during the very first moments of a server's lifetime-the initialization phase. Temporal specialization automatically derives the set of system calls required by each execution phase, and restricts the set of 1. We propose a novel temporal system call specialization approach that considers the different operational characteristics of server applications throughout their different execution phases.</p><p>2. We present type-based and address-taken-based pruning mechanisms to improve the precision of static analysis techniques for call graph construction.</p><p>3. We evaluate our prototype implementation with six popular applications and a diverse set of 567 shellcode and 17 ROP payload samples, demonstrating its effectiveness in blocking exploit code, as well as in reducing the exposed attack surface of the underlying kernel.</p><p>Our prototype implementation is publicly available as an open-source project at https://github.com/shamedgh/ temporal-specialization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and Motivation</head><p>User-space applications rely on the system call API to interact with the OS. The Linux kernel v4.15 used in this work provides 333 system calls, while its latest version 5.6 (as of June 2020) provides 349. Applications, however, typically rely only on a subset of these system calls for their operation. Moreover, their requirements change according to the phase of execution, e.g., whether the application is being initialized or serving requests. From a security perspective, this overabundance of system calls allows an attacker to i) use the additional system calls to carry out malicious operations as part of exploiting a vulnerability, and ii) exploit underlying kernel vulnerabilities triggered through system calls and achieve privilege escalation <ref type="bibr" target="#b25">[22,</ref><ref type="bibr" target="#b35">31,</ref><ref type="bibr" target="#b36">32]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Static vs. Temporal API Specialization</head><p>Previous works in attack surface reduction <ref type="bibr" target="#b24">[21,</ref><ref type="bibr" target="#b30">26,</ref><ref type="bibr" target="#b38">34,</ref><ref type="bibr" target="#b52">48,</ref><ref type="bibr" target="#b54">50]</ref> consider the entire application lifetime, and remove functionality that will never be used at any point. When considering the execution phases of typical server applications, however, we observe that further specialization can be achieved.</p><p>In particular, servers typically start handling client requests after performing a series of one-time operations for setting up the process. This initialization phase mainly consists of operations such as parsing configuration files, binding network ports, and forking worker processes. After the completion of these tasks, the server enters its main long-term serving phase for handling client requests. In this stable state, the server typically performs operations such as reading from and writing to sockets or files, managing memory, and allocating tasks to the worker processes. <ref type="bibr">Nginx [7]</ref> is an example of a server which exhibits this behavior. Depending on whether it is started in "single-process" or "multi-process" mode, Nginx either executes the function ngx_single_process_cycle, or forks the configured number of worker processes, each of which invokes the function ngx_worker_process_cycle. Both functions mark the beginning of the serving phase by entering an infinite loop that processes client requests.</p><p>The operations performed in these two phases are distinctively different, and thus the required system calls for carrying them out are also different. For example, if a server only creates a fixed set of long-lived worker processes during the initialization phase, it will not need access to system calls such as fork and execve during the serving phase. <ref type="figure" target="#fig_0">Figure 1</ref> shows a simplified view of the call graph for Apache httpd <ref type="bibr" target="#b18">[15]</ref>, one of the most popular open source web servers. The different shapes correspond to application functions, library functions, and system calls. The initialization phase begins with main, and this phase performs operations such as binding and listening to sockets, and spawning the worker processes through calls to fork and execve. The forked worker processes begin execution at the func-  <ref type="bibr" target="#b15">[12,</ref><ref type="bibr" target="#b55">51]</ref> can only remove system calls that are never used during the entire lifetime of the application (top left). Temporal specialization removes additional system calls that are never used after the initialization phase (top right).</p><p>tion child_main, which denotes the beginning of the serving phase. During this phase, the application performs tasks such as allocating buffers and handling I/O operations. Library debloating techniques <ref type="bibr" target="#b15">[12,</ref><ref type="bibr" target="#b55">51]</ref> analyze the code of a given application to identify and remove parts of the linked libraries that are not needed by the application, thereby creating specialized versions of each library. However, they consider the entire lifetime of the application, and therefore, in the example of <ref type="figure" target="#fig_0">Figure 1</ref>, are unable to prevent access to system calls such as fork and execve-crucial for attackers' exploit code-as they are used during the initialization phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Seccomp BPF</head><p>Seccomp BPF <ref type="bibr" target="#b11">[8]</ref> is a mechanism provided by the Linux kernel for restricting the set of system calls that are accessible by user-space programs. Specifically, Seccomp BPF uses the Berkeley Packet Filter language <ref type="bibr" target="#b44">[40]</ref> for allowing developers to write programs that act as system call filters, i.e., BPF programs that inspect the system call number (as well as argument values, if needed) and allow, log, or deny the execution of the respective system call. Applications can apply Seccomp BFP filters by invoking either the prctl or seccomp system call from within their own process. After doing so, all system call invocations from within the process itself or any forked child processes will be checked against the installed filters to grant or reject permission. We use this mechanism to reduce the set of system calls available to programs after the completion of their initialization phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Threat Model</head><p>We consider remote adversaries armed with a vulnerability that allows arbitrary code execution. Temporal system call specialization does not rely on any other exploit mitigations, but as an attack surface reduction technique, it is meant to be used along with other code specialization techniques. Our technique limits the set of system calls an attacker can invoke. Therefore, any exploit code (e.g., shellcode or ROP payload) will have limited capabilities, and will not be able to invoke system calls that are not needed by the server after its initialization phase. These typically include security-critical system calls that can be used to spawn additional services, execute shell commands, and so on. Preventing access to these system calls also effectively neutralizes the corresponding kernel code, which may contain vulnerabilities that can lead to privilege escalation <ref type="bibr" target="#b43">[39]</ref>-an attacker cannot trigger those vulnerabilities to compromise the kernel, as the respective system calls cannot be invoked in the first place.</p><p>Time-of-check to time-of-use (TOCTTOU) <ref type="bibr" target="#b64">[60]</ref> and other race condition attacks are out of the scope of this work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Design</head><p>Our goal is to reduce the number of system calls available to attackers once a server application has finished its initialization phase, and thus reduce the exposed attack surface. Disabling system calls that remain unused during the serving phase requires the identification of those system calls that the application uses during the initialization phase, and does not need afterwards. To achieve this, our approach performs the following steps, illustrated in <ref type="figure">Figure 2</ref>.</p><p>• Build a sound call graph of the application, and derive the list of imported functions from external libraries.</p><p>• Map the application call graph, as well as the imported external library functions, to system calls.</p><p>• Use programmer-supplied information about the functions that mark the beginning of the initialization and serving phases, respectively, to derive the call graph of each of these phases of execution.  <ref type="figure">Figure 2</ref>: Overview of the process for generating a sound call graph to identify the system calls required by each execution phase.</p><p>• Based on these call graphs, identify the list of system calls required by each phase.</p><p>• Create Seccomp filters to restrict the use of unneeded system calls, and apply them right after the end of the initialization phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Identifying the Transition Point</head><p>We require an expert to identify the boundary where the program transitions from the initialization phase to the serving phase, and pass it to our toolchain through a configuration file. This is the point where the server begins its main operation and its system call requirements change. As discussed in Section 2.1, in many applications, such as Apache Httpd <ref type="bibr" target="#b18">[15]</ref> and <ref type="bibr">Nginx [7]</ref>, the transition takes place after the server's main process forks, and child processes are created. In others, such as Memcached <ref type="bibr" target="#b8">[4]</ref>, which use an event-driven model, this transition takes place at the beginning of the event loop that handles client requests. In case of Apache Httpd, as shown in <ref type="figure" target="#fig_0">Figure 1</ref>, this transition boundary is defined by the function child_main, and once execution reaches this function, many system calls are no longer needed. Although identifying this transition boundary could perhaps be automated based on heuristics or dynamic analysis, we did not invest the effort to develop such a capability, as this needs to be done only once per application. Manually pinpointing the entry point to the serving phase is relatively easy even if one is not familiar with a given code base. This is the only step where manual intervention is required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Call Graph Construction</head><p>Applications and libraries written in C/C++ often use indirect function calls via function pointers. For example, the libapr and libapr-util libraries used by Apache Httpd, use function pointers to register custom memory allocation functions, to register callbacks, and to provide other functionalities that allow the programmer to customize the library. Resolving these indirect function calls in a sound and precise manner is therefore critical for identifying the system calls needed by the application.</p><p>Points-to analysis is a static code analysis technique for deriving the possible targets of pointers in a program, and is necessary to soundly identify the target functions of indirect function calls. We use the well-known Andersen's points-to analysis algorithm <ref type="bibr" target="#b17">[14]</ref> for this purpose.</p><p>Applying Andersen's algorithm to the source code of an application generates a sound call graph, in which all indirect call sites are resolved. However, like all static analysis techniques, points-to analysis suffers from imprecision and overapproximation. For example, Apache's function ap_run_pre_config contains an indirect function call. Andersen's points-to analysis reports 136 targets for this function pointer. We manually verified that only seven targets can actually be executed, and the rest 129 are spurious targets that were included due to the imprecision of the analysis.</p><p>Previous works <ref type="bibr" target="#b17">[14,</ref><ref type="bibr" target="#b31">27]</ref> have extensively discussed the challenges of scalable and accurate points-to analysis, and an in-depth discussion of these issues is out of the scope of this paper. However, we briefly describe the different sources of overapproximation we faced in our problem space, along with how we mitigated them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Points-to Analysis Overapproximation</head><p>Points-to analysis can be modeled with multiple types of sensitivity, which reflect how objects in memory are modeled. These include field sensitivity, context sensitivity, and path sensitivity. An analysis algorithm employing a higher degree of sensitivity will provide more precise results, and in turn will allow us to gain a more fine-grained view into the system calls required by each execution phase. However, using higher degrees of sensitivity has the fundamental problem of increasing the analysis time, while it requires significant effort to implement such a capability. For example, the popular implementation of Andersen's algorithm, SVF <ref type="bibr" target="#b59">[55]</ref>, supports field sensitivity (it models every field of a struct type uniquely), but not context sensitivity or path sensitivity. This results in imprecision in the results of the points-to analysis.</p><p>Context-sensitive analysis considers the calling context when analyzing the target of a function call. When the same function is invoked from different call sites, each function call gets its own "context" and is analyzed independently of the other function calls. This prevents return values of the called function from propagating into unintended call sites, leading to imprecision. This is critical for functions that allocate or reassign objects referenced by their arguments, or functions that return pointers. Lack of context sensitivity in such cases causes the propagation of analysis results to all call sites and all return sites of these functions. For example, to allocate memory, Nginx uses a wrapper around memory allocation routines (e.g., malloc), called ngx_alloc. Because the analysis used by SVF is not context sensitive, its results contain significant overapproximation.</p><p>Similarly to context sensitivity, the lack of path sensitivity also causes overapproximation in the results of the pointsto analysis. Path-sensitive points-to analysis takes into account the predicates of the branch conditions in the control flow graph of the program when solving pointer constraints. Without path sensitivity, the analysis cannot reason about the predicate conditions of a branch.</p><p>During our analysis of popular servers, we observed that it was common for libraries (e.g., libapr) to provide an option to insert optional callback functions at various stages of the life cycle of the library. These callbacks are implemented as indirect function calls, and their call sites are guarded by NULL checks on the callback function pointer. We call these guarded indirect call sites, and discuss them further in Section 4.2.3.</p><p>Due to the lack of context sensitivity, even if no callback function is registered, the points-to analysis can return spurious targets for the guarded indirect call site. Due to the lack of path sensitivity, the analysis cannot detect that the call site is in fact guarded, and will be skipped at runtime. <ref type="figure" target="#fig_1">Figure 3</ref> shows an example of a guarded indirect call site. The imprecise call graph contains a spurious edge to piped_log_maintenance from a guarded indirect call site accessible in the serving phase. As this function contains a call to the execve system call, the overapproximation would prevent it from being removed in the serving phase. Similarly, the lack of context sensitivity and path sensitivity causes overapproximation in the number of possible targets for all indirect call sites, even if they are not optional callback functions guarded by NULL checks. A more detailed discussion on overapproximation in points-to analysis is available in Appendix A.</p><p>To reduce the overapproximation that the lack of context and path sensitivity introduces in our analysis, and consequently increase the number of system calls that can be removed in the serving phase, we implemented two filtering schemes that prune spurious call edges based on argument types and taken addresses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Pruning Based on Argument Types</head><p>A naive implementation of Andersen's points-to analysis algorithm does not consider any semantics regarding the type of pointers while solving the constraint graph. For example, SVF's implementation of Andersen's algorithm considers the number of arguments, but not their types, when solving indirect call sites. Due to the lack of context sensitivity and path sensitivity, the results of the points-to analysis often contain imprecision in the form of pointers of one type pointing to memory objects of a different type.</p><p>Similarly, when resolving targets for indirect function calls, the results of the points-to analysis often contain functions whose types of arguments do not match those of the call site. For example, in the imprecise call graph of Apache Httpd shown in <ref type="figure" target="#fig_1">Figure 3</ref>, the guarded indirect call site in function other_child_cleanup has two possible targets, piped_log_maintenance and event_run, despite the fact that only the former matches the types of arguments of the guarded call site.</p><p>We have mitigated this problem by checking every indirect call site and pruning any call edges to functions with arguments whose types do not match those of the call site. To maintain soundness, when pruning based on argument types, we consider only arguments of struct type, as primitive types may have a mismatch due to reasons such as integer promotion. This simple mechanism is extremely effective in reducing the number of edges in our final call graph. Indicatively, for Nginx, it reduces the number of edges by 70%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Pruning Based on Taken Addresses</head><p>Andersen's algorithm considers all functions in the program to be reachable from its entry point. We observed that this leads to an imprecision in the results of the resolution of indirect call sites, with the result set containing functions that are not accessible from main at all.</p><p>A function can be the target of an indirect call site only if its address is taken (and stored in a variable) at some point in the program. Consequently, if the address of a function is taken at some point in the program that is unreachable from main, it can never be a target of an indirect call.</p><p>Based on this intuition, we prune further the (still) overapproximated graph generated from the previous argument type based pruning step by first identifying all functions whose addresses are taken along any path that is accessible from the main function. This gives us all possible functions that can actually be targets of indirect calls. Using this list of potential address-taken functions, we visit each indirect call site in the program and prune all edges towards targets that do not have their address taken along any valid path.</p><p>Going back to the example of <ref type="figure" target="#fig_1">Figure 3</ref>, the address of piped_log_mnt is stored in a function pointer within the function start_module, but start_module is not reachable from the entry point of Apache Httpd. On the other hand, the function other_child_cleanup contains a guarded indirect call site, which first checks if that function pointer is not NULL, in which case then dereferences it to invoke the target function. At run time, this NULL check will always return false, and this indirect call site is never executed. Path-insensitive points-to analysis cannot determine whether the guard NULL check will fail or not. However, as we prune indirect call sites based on address-taken functions, and given that the address of piped_log_mnt is never taken along any reachable path from main, we can correctly infer that this guarded indirect call site does not have any valid targets, and will be skipped at run time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Mapping System Call Invocations to the Application Call Graph</head><p>System calls are typically invoked through the Libc library, which provides corresponding wrapper functions (e.g., the write Libc function invokes the SYS_write system call). We map each exported Libc function to its relevant system call by first generating the call graph of the entire library, and then augmenting it with information about the system calls of each function as "leaves" on the generated call graph <ref type="bibr" target="#b25">[22]</ref>. In addition to using Libc wrappers, applications and libraries can also invoke system calls directly using the syscall() glibc function or the syscall assembly instruction-we handle both of these cases as well. Finally, we combine the Libc call graph with the call graphs of the main application and all its dependent libraries. Using the resulting unified graph, we extract the set of system calls required by the application for the initialization phase, and then for the serving phase, and identify the system calls that are not needed in the latter. We then use Seccomp to apply the respective filters at the beginning of the serving phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation</head><p>In this section, we describe the implementation details of our framework for temporal system call specialization. Our framework currently supports server applications written in C. Although we currently support only Linux libraries and applications, the concept can easily be applied to other operating systems as well. We use the LLVM <ref type="bibr" target="#b7">[3]</ref> compiler toolchain to statically analyze the code of the target application. Because Glibc does not compile with LLVM, we use the GCC toolchain for the compilation and analysis of Glibc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Constructing a Sound Call Graph</head><p>Our goal is to identify the functions that may be invoked during the initialization and serving phases. To that end, the first step is to construct a sound and precise call graph for the whole application. Accurate points-to analysis for resolving the targets of indirect call sites is the most critical part of this process. We use SVF's <ref type="bibr" target="#b59">[55,</ref><ref type="bibr" target="#b60">56]</ref> implementation of the Andersen's points-to analysis algorithm <ref type="bibr" target="#b17">[14]</ref>. SVF operates on the LLVM intermediate representation (IR), so we first lower the C source code into the LLVM IR format using the clang compiler and by applying link-time optimization (LTO). We then run SVF on this generated bitcode.</p><p>As we discussed in Section 4.2, SVF's implementation of Andersen's algorithm is field sensitive, but not context sensitive or path sensitive, leading to significant imprecision. We also observed that in some cases, the lack of context and array index sensitivity causes objects to lose field sensitivity. We provide more details on this subtle issue in Appendix A.</p><p>Solving these imprecision problems would fundamentally require implementing a context-sensitive, path-sensitive, and array-index-sensitive analysis, which increases the complexity of the points-to algorithm, and also requires significant programming effort. Instead, we implemented an alternative lightweight solution that simply prunes call edges in the call graph that are provably added as a result of imprecision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Pruning Based on Argument Types</head><p>SVF begins by iterating over all instructions in the IR bitcode, collecting constraints along the way, and adding them to the constraint graph. Then, it iterates over all constraints and solves each of them. At the end of each iteration, it checks if it can successfully find a new target for an indirect call site. For any new target found, it first checks if the number of arguments in the call site matches the number of arguments in the target function. In case they match (and the target function is not a variadic function), the analysis adds the target function as a possible target of the indirect call site. Then, it begins a new iteration to solve any additional constraints due to the newly discovered target function. As discussed in Section 4.2.2, this results in the inclusion of targets with the same number of arguments, but completely unrelated argument types. We modified SVF to take the argument type into account and only add functions as possible targets when the argument types match.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Pruning Based on Taken Addresses</head><p>One of the downsides of using path-insensitive and contextinsensitive pointer analysis is that it cannot consider the state of the program when solving the points-to set constraints. In particular, as discussed in Section 4.2.3, if an indirect function call is guarded by a NULL check on a function pointer, and the function pointer is not initialized in any function that is reachable from the program's entry point, then the call will be skipped at run time. This is especially useful for modular programs, where initializing a module causes the address of one or multiple functions to be taken, and any housekeeping tasks related to that module are performed after doing the not-NULL check on their relevant function pointers. However, due to the imprecision of SVF's static analysis, its results include spurious targets for these guarded indirect call sites.</p><p>Using the call graph generated after argument type pruning, we record all functions whose addresses are stored into function pointers. A function's address can be stored into a pointer in three ways: i) by a direct store to a pointer, ii) when passed as an argument to another function, or iii) as part of the initialization of a constant global variable. We implemented an LLVM IR pass to extract functions that have their addresses taken via any of these cases. It traverses the call graph in a depth-first manner, starting at the main function, and analyzes every LoadInst IR instruction to check if the address of a function is being loaded from memory. To track functions passed as arguments to other functions, it iterates over every IR Value passed as an argument at a call site, and checks if it corresponds to a function. Finally, it iterates over all constant GlobalVariable objects in the IR to track whether a function is part of their initialized values. Based on the resulting set of address-taken functions, we remove any spurious targets at each indirect call site, while retaining all direct call sites without any modifications.</p><p>Algorithm 1 summarizes the steps for both types of pruning based on argument types and taken addresses, which result in a much more precise call graph than the one provided by SVF. Once the final call graph is derived, the next and final step is to identify the system call invocations performed during the initialization phase and the serving phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1: Generation of Precise Call Graph</head><p>Input </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Pinpointing System Call Invocations</head><p>System calls are typically invoked through library function calls implemented in the standard C library-the most common implementation of which is glibc. Since glibc cannot be compiled with LLVM, we do not use points-to analysis to generate the call graph and rely on a more overapproximated mechanism, which considers any function having its address taken as a potential target of any indirect call site in its own module. This is only performed once to generate the glibc call graph, and is then used for all applications.</p><p>We implemented an analysis pass written in GCC's RTL (Register Transfer Language) intermediate representation to extract the call graph and system call information from glibc. Our analysis pass first builds the call graph using the Egypt tool <ref type="bibr" target="#b27">[24]</ref>, which operates on GCC's RTL IR. Then, the anal-ysis pass iterates over every call instruction in the IR and records any inline assembly code containing the native x86-64 syscall instruction. These are then added as the "leaves" of the functions in the call graph.</p><p>In addition to making direct system calls via inlineassembly, glibc also makes system calls via wrapper macros such as T_PSEUDO, T_PSEUDO_ERRNO, and T_PSEUDO_ERRVAL. We identify these wrappers and add the system calls invoked through them to the call graph.</p><p>Glibc also uses weak symbols and versioned symbols to support symbol versioning. Both weak_alias and versioned_symbol provide aliases for functions. We statically analyze the source code to collect all such aliases, and add them to the call graph. In this way we can map Glibc function calls to system calls.</p><p>System calls can also be invoked directly by the application through the syscall() glibc function, inline-assembly, or the use of assembly files. We analyze the IR bitcode of the application for invocations of the syscall() function, and add the corresponding syscall number information to the call graph. To track the directly invoked system calls in inline assembly, we analyze the LLVM IR for InlineAsm blocks. If an InlineAsm block contains the syscall instruction, we extract the system call number and add it to the functions that call the inline assembly block.</p><p>To scan assembly files for syscall instructions, we developed a tool that extracts the corresponding system call number. In 64-bit systems, the syscall instruction reads the system call number from the RAX register. Starting from every syscall instruction, we perform backwards slicing to identify the initialization point of RAX with the system call number. The process continues tracing backwards in the assembly code to find the value (or set of values) that RAX can take at runtime. While glibc does use inline assembly, we did not encounter any custom assembly-level system call invocations in the set of applications we evaluated.</p><p>Once we have mapped the Glibc interface to system calls, and have extracted the direct system calls, we combine this information with the previously generated precise call graph, to obtain the list of system calls required by the initialization phase and the serving phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Installing Seccomp Filters</head><p>Finally, we create and apply Seccomp filters that disable the unneeded system calls at the transition boundary from the initialization to the serving phase. We use the prctl system call to install the Seccomp filters. We currently require manual intervention to install the Seccomp filters, but this can be easily automated as part of the compilation process. Seccomp filters are expressed as BPF programs, and once installed, they cannot be modified. However, if the prctl system call is not blocked, then it is possible to install new Seccomp filters. When two installed BPF programs contradict each other, the least permissive of the two takes precedence. Therefore, once a system call is prohibited, the attacker cannot remove it from the deny list. For example, if invoking execve is prohibited, and an attacker is able to install another BPF program that allows it, the deny list will have priority and execve will remain blocked. Furthermore, an installed Seccomp filter cannot be uninstalled without killing the process it has been applied to.</p><p>As an additional safeguard, the invocation of the prctl and seccomp system calls is prohibited as part of our Seccomp filtering at the beginning of the serving phase, if the application no longer needs them. This means that an attacker cannot install any new filters at all once the serving phase begins.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experimental Evaluation</head><p>The main focus of our experimental evaluation lies on assessing the additional attack surface reduction achieved by temporal specialization compared to library specialization techniques, and evaluating its security benefits. For all experiments, we used a set of six very popular server applications: Nginx, Apache Httpd, Lighttpd, Bind, Memcached, and Redis.</p><p>Existing library specialization techniques <ref type="bibr" target="#b15">[12,</ref><ref type="bibr" target="#b55">51]</ref> only remove unused code, and do not actually perform any kernelbacked system call filtering (e.g., using Seccomp). That is, although the Libc functions corresponding to some system calls may be removed, the attacker is still able to directly invoke those system calls, e.g., as part of injected shellcode or a code reuse payload. Still, such a capability is relatively easy to implement once the unused Libc functions have been identified. In fact, for our evaluation purposes, we developed our own library specialization tool, similar to piecewise compilation <ref type="bibr" target="#b55">[51]</ref>, and on top of it implemented the capability of applying Seccomp filters to actually block the execution of system calls that correspond to removed Libc functions (unless they are also invoked directly by other parts of the application, in which case they cannot be disabled). Piecewise compilation leverages the SVF <ref type="bibr" target="#b59">[55]</ref> tool to perform pointsto analysis and generate the call graph for each library. Our custom library specialization tool also uses SVF to create call graphs for each library and further extends them to extract the list of system calls required for each application.</p><p>For our security evaluation, we explore two aspects of the protection offered by temporal specialization. First, we evaluate its effectiveness in blocking exploit code using a large set of shellcode and ROP payload samples. To account for potential evasion attempts using alternative system call combinations, we also exhaustively generate all possible variants of each sample. Second, given that system calls are the gateway to exploiting kernel vulnerabilities, we also look into the number of Linux kernel CVEs that are neutralized once the relevant system calls have been blocked.</p><p>We also validated the correctness of our implementation by applying temporal specialization and running each application with various workloads. For each application, we performed 100 client requests and validated the responses, without encountering any issues. We also compared the server logs in both cases to further ensure the absence of any internal errors that are not visible at the client side.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Call Graph Analysis</head><p>Identifying the transition boundary between the initialization and serving phase for the applications we consider is straightforward. We begin by providing some further details for each application. For Nginx <ref type="bibr">[7]</ref>, we use the default configuration with all the default modules enabled.</p><p>Nginx has three functions that can act as transition points to the serving phase: ngx_worker_process_cycle and ngx_single_process_cycle are used for handling client requests, while ngx_cache_manager_process_cycle is responsible for cache management. Each of them runs in its own separate thread. We use the vanilla configuration of Apache Httpd <ref type="bibr" target="#b18">[15]</ref>, statically compiled with libapr and libapr-util to make our analysis simpler. Our configuration enables all default modules. The transition boundary of the serving phase is the child_main function.</p><p>Lighttpd has an event-driven architecture, not relying on a primary-secondary process model. It can be launched with a configurable number of processes, and each process executes the server_main_loop function to handle client requests.</p><p>Bind is one of the most widely used DNS servers, acting as both an authoritative name server and as a recursive resolver. Bind uses multi-threading to handle client requests and enters the serving phase after creating the secondary threads, by invoking the isc_app_ctxrun function.</p><p>Memcached and Redis are both in-memory key-value databases. Similarly to Lighttpd, Memcached also has an event-driven architecture and executes the worker_libevent function to serve client requests. In Redis, the aeMain function serves as the event processing loop.</p><p>As shown in <ref type="table" target="#tab_2">Table 1</ref>, these applications vary in complexity, with the number of edges in the initial call graph (generated by SVF) ranging from 3K for Lighttpd to 67.9K for Bind. By applying our pruning techniques based on argument types and taken addresses, the precision of the points-to analysis  improves significantly, reducing the number of spurious edges to half or even less, especially for the most complex applications. This improvement allows us to disable more system calls during the serving phase of each application. For example, in case of Apache Httpd, using the more imprecise results of SVF alone does not allow the removal of security-sensitive system calls such as execve.</p><p>The complexity of each application affects the analysis time required to generate the call graph. <ref type="table" target="#tab_3">Table 2</ref> shows the breakdown of the amount of time required for generating the call graph in each step, with the total time for the whole toolchain in the last column. We compiled each application 10 times and report the average time. The compilation time is only a few seconds different in each case for all applications. The analysis time ranges from three minutes for Lighttpd to more than nine hours for Bind. The most time-consuming aspect of our approach is running Andersen's points-to analysis algorithm, which is expected. While one could use other algorithms, such as Steensgard's <ref type="bibr" target="#b58">[54]</ref>, which are both more efficient and more scalable, they come at the price of precision. We discuss other algorithms and tools which can be used to generate call graphs in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Filtered System Calls</head><p>We compare our approach with library specialization <ref type="bibr" target="#b15">[12,</ref><ref type="bibr" target="#b55">51]</ref> to show the benefit of applying temporal specialization. As shown in <ref type="table" target="#tab_4">Table 3</ref>, once entering the long-term serving phase, temporal specialization retains fewer system calls than static : System call is removed.</p><p>: System call is not removed. O: Can be mitigated by applying configuration-driven debloating <ref type="bibr" target="#b38">[34]</ref> (details in Section 6.2). * : Can be mitigated by applying API specialization (details in Section 6.3).</p><p>library debloating. Although in most cases the reduction is not significant (in the best case for Bind, the number of system calls drops from 127 to 85, while in the worst case for Nginx, only 7 system calls are removed), a more crucial question is whether the removed system calls are "critical" or not, i.e., whether they will hinder the execution of exploit code that relies on them.</p><p>As a first step towards answering this question, <ref type="table" target="#tab_5">Table 4</ref> shows which critical system calls are filtered in each application after applying library debloating and temporal specialization. We chose a set of 17 security-critical system calls which are used as part of shellcode and ROP payloads (more details on this data set are provided in Section 6.3). As shown in <ref type="table" target="#tab_5">Table 4</ref>, temporal specialization removes a total of 53 critical system calls across all applications, compared to just 35 for library debloating alone-an overall increase by 51%.</p><p>We group these system calls according to their functionality into three categories to analyze further the impact of temporal specialization. Command Execution includes system calls used to execute arbitrary code. Permission includes system calls which can be used to modify user, file, or memory permissions. Networking contains system calls mostly used in establishing network connections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Command Execution</head><p>The system calls execveat, fork and ptrace can be filtered across all applications by both techniques. No application uses execveat or ptrace. In place of the former most use execve, while the use of the latter is rare. The reason no application uses the fork system call is that Libc's fork function actually uses the clone system call. The widely used by exploit code execve system call is also used in many applications to spawn child processes, so it can not be removed by library debloating.</p><p>After entering the serving phase, however, most servers do not need to invoke execve anymore, and thus temporal specialization can remove it. This has significant security benefits, as also discussed in the next section. For Lighttpd and Redis, we manually verified that execve was invoked only if the application was launched with a specific run-time configuration option that is disabled by default. Therefore, the prior application of some form of configuration-driven debloating <ref type="bibr" target="#b38">[34]</ref> would allow temporal specialization to successfully remove execve from all six applications.</p><p>Permissions Four of the permission system calls (chmod, setgid, setuid, and setreuid) can be filtered in all applications, except Nginx. As allocating memory and setting its permissions is a crucial operation for most applications, the mprotect system call cannot be filtered under any circumstances. As we discuss in Section 6.3, we could still enforce a more restrictive invocation policy for this system call by limiting the allowable permissions to be applied on memory pages, as after the initialization phase it is unlikely that executable memory will need to be allocated. Networking Neither approach can filter system calls used for creating network connections (socket, connect). This is because server applications may establish connections with other backend services, such as databases.</p><p>Although we expected listen and bind to be removed by temporal specialization, as these operations are typically part of the initialization phase, they are only removed in Apache Httpd, Lighttpd and Redis (only listen). We suspect that the reason they remain in the rest is related to the remaining overapproximation in the call graph, and we plan to further analyze these cases as part of our future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Exploit Code Mitigation</head><p>To evaluate the security benefits of temporal specialization, we collected a large and diverse set of exploit payloads. This set consists of 53 shellcodes from Metasploit <ref type="bibr" target="#b70">[5]</ref>, 514 shellcodes from Shell-storm <ref type="bibr" target="#b12">[9]</ref>, and 17 ROP payloads (from PoCs and in-the-wild exploits). Shellcodes are generic and can work against every application. Although the ROP payload of a given proof-of-concept exploit is meant to be used against a specific application, since all these payloads use one or more system calls to interact with the operating system, their final intent can be generalized irrespective of the target application. Thus, for ROP payloads, we make the conservative assumption that each can be used against any of our test applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">Shellcode Analysis</head><p>For Metasploit, we use the msfvenom utility to generate a binary for each of the 53 available Linux payloads. We then disassemble each generated file to extract the system calls used. Similarly, we extract the system calls used by the 514 payloads collected from Shell-storm. Finally, we compare the set of system calls used in each payload with the set of system calls available in each application after applying library specialization and temporal specialization, to get the number of shellcodes "broken" in each case. We consider a payload broken if at least one of the system calls it relies on is removed. For instance, the bind_tcp shellcode uses six system calls: setsockopt, socket, bind, mprotect, accept and listen. Temporal specialization blocks bind in Lighttpd and Apache Httpd, and the attacker can no longer successfully run this shellcode.</p><p>To account for potential evasion attempts by swapping blocked system calls with equivalent ones, we also exhaustively generate all possible variants of each shellcode using other system call combinations that provide the same functionality. For instance, replacing accept with accept4 maintains the same functionality, but would allow an attacker to bypass a filter that restricts only one of them. Starting from our initial set of 567 shellcodes, we generate 1726 variants according to the equivalent system calls listed in <ref type="table" target="#tab_6">Table 5</ref>.</p><p>We have summarized the results regarding the number of blocked shellcodes for each application by each specialization technique in <ref type="table" target="#tab_7">Table 6</ref>. As shown in the row titled "All Shellcodes," for each of the six tested applications, temporal specialization successfully breaks a higher number of shellcode variants compared to library debloating. The improvement is significant in Lighttpd (1248 with temporal vs. 919 with library specialization), Apache Httpd (1466 vs. 1097), Nginx (1249 vs. 923), and Redis (1307 vs. 1165), while it is marginal for Memcached (1319 vs. 1258) and Bind (1341 vs. 1258).</p><p>Payloads can be categorized according to the task they perform. The broad categories include i) payloads that open a port and wait for the attacker to connect and launch a shell, ii) payloads that connect back and launch a reverse shell, iii) payloads that execute arbitrary commands, and iv) payloads that perform system operations, e.g., access a file or add a user. The first four rows in <ref type="table" target="#tab_7">Table 6</ref> provide the number of broken payloads in each of these categories. We see that 90% of the payloads that open a port are broken with temporal specialization. For Apache Httpd, although 88% of the "connect" and 91% of the "execute" shellcodes are broken with our approach, none of the two specialization schemes perform well for payloads that perform file operations. This is because file system operations are required by applications during both the initialization and the serving phases.</p><p>Achieving arbitrary remote code execution provides an attacker the ultimate control over a target system. Removing the ability to execute commands thus has a more significant impact on restricting an attacker's actions compared to blocking payloads of other categories, e.g. payloads that open a port. The execve system call is the most crucial for executing arbitrary commands, and as shown in <ref type="table" target="#tab_5">Table 4</ref>, it can be removed in Apache Httpd, Nginx, Memcached and Bind by applying temporal specialization. This can also be seen in the row titled "Execute Command" in <ref type="table" target="#tab_7">Table 6</ref>, where more than 80% of the shellcodes that aim to achieve arbitrary command execution are broken in Nginx, Apache Httpd, Bind, and Memcached. In these cases, the attacker is heavily restricted, and even if payloads in other categories (e.g., network connection establishment) are successful, the capability of executing arbitrary commands is still restricted. Change Permission 3 0 ( 0%) 0 ( 0%) 0 ( 0%) 0 ( 0%) 0 ( 0%) 0 ( 0%) 0 ( 0%) 0 ( 0%) 0 ( 0%) 0 ( 0%) 0 ( 0%) 0 ( 0%)</p><p>Execute Command 14 7 (50%) 14 (100%) 7 (50%) 14 (100%) 7(50%) 7 (50%) 14 (100%) 14 (100%) 14 (100%) 14 (100%) 7 (50%) 7 (50%)</p><p>All ROP Payloads 17 7 (41%) 14 ( 82%) 7 (41%) 14 ( 82%) 7 (41%) 7 (41%) 14 ( 82%) 14 ( 82%) 14 ( 82%) 14 ( 82%) 7 (41%) 7 ( 41%)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2">ROP Payload Analysis</head><p>We collected a set of 17 publicly available ROP payload samples for Linux (details for each one are provided in <ref type="table" target="#tab_9">Table 8</ref> in the appendix). We follow the same strategy as with the shellcodes and make the generic assumption that each of the payloads can be used against any of our tested applications. From a system call perspective, ROP payloads are much simpler and usually aim towards either allocating executable memory for enabling the execution of second-stage shellcode, or invoking execve or similar system calls for direct command execution. ROP payloads can thus be broadly categorized into these two categories. The last three rows in <ref type="table" target="#tab_7">Table 6</ref> provide the number of ROP payloads in the two categories and their combined results. Ten ROP payloads attempt to execute commands and temporal specialization blocks all of them in four applications (Apache Httpd, Nginx, Memcached and Bind). In case of Lighttpd and Redis, because execve is used even in the serving phase (when used with a specific non-default configuration), temporal specialization cannot filter it. Neither library nor temporal specialization can block any payloads that try to change in-process memory permissions. This is because mprotect is used by all applications for memory allocation and permission assignment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.3">What Else can Attackers Do?</head><p>Assuming command execution (e.g., through execve and the like) has been blocked, attackers may resort to other system calls to achieve their goals. Meterpreter <ref type="bibr">[6]</ref> is an advanced payload that uses DLL injection to inject malicious code into a process. Using such a payload would remove the requirement of using execve directly to launch external binaries, and instead allows the attacker to inject the necessary code to perform any operation as part of the vulnerable process itself. While Meterpreter (in its original form) is only available for Windows, there are equivalents for Linux which use the ptrace system call. However, none of the applications in our dataset require this system call, so it can be filtered in all cases. Furthermore, by default, this capability is limited to processes that have a predefined relationship with the target process since Linux kernel v3.2 due to the associated security risks. The traced process should either be a child process of the tracer, or should have tracing enabled using prctl.</p><p>Even if ptrace is not available, there are other system call combinations that could be leveraged to perform DLL injection. For example, Linux applications have the option of dynamically loading shared objects after program launch, using the dlopen and dlsym functions. Even if these two functions are not available, the attacker can simply emulate their functionality using the open, mmap, and close system calls to inject a malicious library. Given that these are very basic operations, it is unlikely that library or temporal specialization will be able to remove these system calls. However, a crucial requirement of DLL injection is to place the injected DLL in executable memory. When an application enters its serving phase it will definitely need mmap to allocate memory, but this memory is typically used for data which is not executable. Applying argument-level API specialization <ref type="bibr" target="#b45">[41]</ref> in this case would prevent the attacker from mapping executable memory once the application enters the serving phase, thereby preventing these attacks. The set of system calls used for file operations can also be leveraged by an attacker to gain command execution. Consider the case of an attacker writing to a file in the crontab folder by invoking open, write, and close. In this case, the crond service will run an attacker-controlled script which gives them the capability of executing arbitrary commands. While applying argument-level API specialization <ref type="bibr" target="#b45">[41]</ref> can potentially protect against such a scenario (assuming the file paths can be predetermined), our approach cannot prevent such cases in general if file permissions are not set properly. For instance, regular programs should not have write access to sensitive folders like crontab.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Kernel Security Evaluation</head><p>System calls are the main entry point into the kernel. Although system calls (especially security-critical ones) are mainly used by attackers to perform unauthorized operations as part of exploiting a vulnerable process, they can also be used to exploit vulnerabilities in the underlying kernel. Previous works <ref type="bibr" target="#b35">[31]</ref><ref type="bibr" target="#b36">[32]</ref><ref type="bibr" target="#b37">[33]</ref><ref type="bibr" target="#b50">46]</ref> have shown that malicious users can target the kernel to perform privilege escalation or leak sensi- tive information. In most cases, these attacks are performed by exploiting a kernel vulnerability that is triggered through a system call, when invoked with specially crafted arguments. By disabling system calls associated with kernel vulnerabilities we can thus reduce the attack surface of the kernel that is exposed to attackers. While filtering security-critical system calls is of importance in case of user-space vulnerability exploitation, it is important to note that any system call associated with a kernel vulnerability can be exploited to mount privilege escalation attacks.</p><p>To gain a better understanding of how filtering individual system calls impacts mitigating potential kernel vulnerabilities, we constructed the Linux kernel's call graph using KIRIN <ref type="bibr" target="#b68">[64]</ref>. This allows us to identify all functions that are invoked as a result of specific system call invocations, and thus reason about which part of the kernel's code-and therefore which vulnerabilities-become inaccessible when blocking a given set of system calls.</p><p>To perform our analysis, we crawled the CVE website <ref type="bibr" target="#b5">[1]</ref> for Linux kernel vulnerabilities using a custom automated tool. Our tool extracts each CVE's relevant commit, and after parsing it in the Linux kernel's Git repository, finds the corresponding patch, and retrieves the relevant file and function that was modified by the patch. We discovered that while there were only a few CVEs directly associated with filtered system call code, many CVEs were associated with files and functions that were invoked exclusively by filtered system call code. By matching the CVEs to the call graph created by KIRIN, we were able to pinpoint all the vulnerabilities that are related to the set of system calls filtered by a given application under each specialization mechanism. This provides us with a metric to assess the attack surface reduction achieved by temporal specialization at the kernel level. This reduction is reflected in the number of CVEs neutralized for a given application after applying our Seccomp filters at the beginning of the serving phase.</p><p>Based on our analysis, a total of 53 CVEs are effectively removed in at least one of the six applications (i.e., the respective vulnerabilities cannot be triggered by the attacker) by temporal specialization. Out of the 53 vulnerabilities that can be mitigated by temporal specialization, 40 can be mitigated by system call filtering based on library debloating as well. <ref type="table" target="#tab_7">Table 6</ref> shows the 13 CVEs that are neutralized by temporal specialization, and which cannot be neutralized by library specialization in some or all applications. The last two columns correspond to the number of applications for which the CVE is neutralized for library debloating and temporal specialization, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Discussion and Limitations</head><p>Our approach does not remove any code from the protected program, and consequently cannot mitigate any vulnerabilities in the application itself, or reduce the code that could be reused by an attacker.</p><p>Similarly to other attack surface reduction techniques, the effectiveness of temporal specialization varies according to the specific requirements of a given application, and as our results show, it may not prevent all possible ways an attacker can perform harmful interactions with the OS. Our equivalent system call analysis attempts to quantify the evasion potential by replacing system calls with others, but depending on the attacker's specific goals, there may be more creative ways to accomplish them using the remaining system calls. For example, without our technique, an attacker could read the contents of a file simply by executing the cat program. Once the execve-family of system calls are blocked, the attacker would have to implement a more complex shellcode to open and read the file and write it to an already open socket. As part of our future work, we plan to extend our analysis by extracting the arguments passed to system calls and constraining them as well <ref type="bibr" target="#b45">[41,</ref><ref type="bibr" target="#b46">42]</ref>. This would further limit the attacker's capabilities when using the remaining system calls.</p><p>Although we have considered only server applications in this work, there could be benefit in applying temporal specialization to some client applications. In general, any application that follows the initialization/serving phase execution model can benefit from our approach. Examples of desktop applications which follow this model are ssh-agent <ref type="bibr" target="#b65">[61]</ref> and syslog-ng <ref type="bibr">[10]</ref>. Further analysis of how well these applications follow the two-stage execution model has been left for future work.</p><p>Due to multiple inheritance with support for polymorphism in C++, our type-based matching currently supports only C code. We plan to extend our approach to support applications developed in C++ as part of our future work.</p><p>Additionally, we plan to investigate the use of alternative points-to analysis algorithms. In particular, the authors of TeaDSA <ref type="bibr" target="#b40">[36]</ref>, which is the type-aware implementation of SeaDSA <ref type="bibr" target="#b26">[23]</ref>, report better accuracy than SVF in some cases (typically for C++ applications) and worse in others (C applications). The authors acknowledge that TeaDSA is more precise for C++ applications than SVF. However, for C applications (e.g., OpenSSL), their results show that it is less precise than SVF. Moreover, the comparison in the paper is with the type-unaware SVF. Because most server applications are written in C, we anticipate the accuracy of our type-based pruning to be better than type-aware SeaDSA. Unfortunately we could not get TeaDSA to work with our applications due to crashes. We will explore TeaDSA and other points-to analysis algorithms as part of our future work.</p><p>Applications can dynamically load libraries through the dlopen and dlsym functions. Due to the dynamic nature of this feature, our current prototype does not support it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related Work</head><p>System call filtering based on policies derived through static or dynamic analysis has been widely used in host-based intrusion detection <ref type="bibr">[18-20, 29, 35, 44, 52, 58]</ref>. Since in this paper we focus on attack surface reduction through software specialization, we mainly discuss related works in this context. Application Debloating Many previous works have focused on reducing the attack surface by removing unused code from the application's process address space. Mulliner and Neugschwandtner <ref type="bibr" target="#b47">[43]</ref> proposed one of the first approaches for preforming library debloating by removing non-imported functions from shared libraries at load time. <ref type="bibr">Quach et al.</ref> [51] improve library debloating by extending the compiler and the loader to remove all unused functions from shared libraries at load time. <ref type="bibr">Agadakos et al. [12]</ref> propose a similar library debloating approach at the binary level, through function boundary detection and dependency identification.</p><p>Porter et al.</p><p>[47] also perform library debloating, but load library functions only when requested by the application. While this is similar to our approach in taking the program execution phase into account, library functions are loaded and unloaded based on the need of the application, whereas we install restrictive filters (which cannot be removed) after the execution enters the serving phase. <ref type="bibr">Davidsson et al. [16]</ref> analyze the complete software stack for web applications to create specialized libraries based on the requirements of both the server application binaries and PHP code. Song et al. <ref type="bibr" target="#b57">[53]</ref> apply data dependency analysis to perform fine-grained library customization of statically linked libraries. Shredder <ref type="bibr" target="#b45">[41]</ref> instruments binaries to restrict arguments passed to critical system API functions to a predetermined legitimate of possible values. Saffire <ref type="bibr" target="#b46">[42]</ref> performs call-site-specific argument-level specialization for functions at build time.</p><p>Another line of research on debloating focuses on using training to identify unused sections of applications. Qian et al. <ref type="bibr" target="#b52">[48]</ref> use training and heuristics to identify unnecessary basic blocks and remove them from the binary without relying on the source code. Ghaffarinia and Hamlen <ref type="bibr" target="#b24">[21]</ref> use a similar approach based on training to limit control flow transfers to unauthorized sections of the code.</p><p>Other works explore the potential of debloating software based on predefined feature sets. CHISEL <ref type="bibr" target="#b30">[26]</ref> uses reinforcement learning to debloat software based on test cases generated by the user. TRIMMER <ref type="bibr" target="#b28">[25]</ref> finds unnecessary basic blocks using an inter-procedural analysis based on userdefined configurations. DamGate <ref type="bibr" target="#b67">[63]</ref> rewrites binaries with gates to prevent execution of unused features.</p><p>While the above works focus on C/C++ applications, other works specifically focus on the requirements of other programming languages <ref type="bibr" target="#b34">[30,</ref><ref type="bibr" target="#b61">57,</ref><ref type="bibr" target="#b66">62]</ref>. Jred <ref type="bibr" target="#b66">[62]</ref> uses static analysis on Java code to identify and remove unused methods and classes. Jiang et al. <ref type="bibr" target="#b34">[30]</ref> used data flow analysis to implement a feature-based debloating mechanism for Java. Azad et al. <ref type="bibr" target="#b16">[13]</ref> propose a framework for removing unnecessary features from PHP applications through dynamic analysis. <ref type="bibr">Kernel and Container Debloating KASR [65]</ref> and FACE-CHANGE <ref type="bibr">[66]</ref> use dynamic analysis to create kernel profiles for each application by using training to identify used parts of the kernel. <ref type="bibr">Kurmus et al. [37]</ref> propose a method to automatically generate kernel configuration files to tailor the Linux kernel for specific workloads. Similarly, Acher et al. <ref type="bibr">[11]</ref> use a statistical supervised learning method to create different sets of kernel configuration files. Sysfilter <ref type="bibr" target="#b20">[17]</ref> is a static binary analysis framework that reduces the kernel's attack surface by restricting the system calls available to user-space processes.</p><p>Wan et al. <ref type="bibr" target="#b63">[59]</ref> use dynamic analysis to profile the required system calls of a container and generate relevant Seccomp filters. Due to the incompleteness of dynamic analysis, Confine <ref type="bibr" target="#b25">[22]</ref> uses static analysis to create similar Seccomp profiles to filter unnecessary system calls from containers. DockerSlim <ref type="bibr" target="#b6">[2]</ref> is an open source tool which also relies on dynamic analysis to remove unnecessary files from Docker images. Similar to temporal debloating, SPEAKER <ref type="bibr" target="#b42">[38]</ref> separates the required system calls of containers in two main phases, booting and runtime. The approach only targets containers and relies on training to identify the system calls for each phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion</head><p>We presented temporal system call specialization, a novel approach for limiting the system calls that are available to server applications after they enter their serving or stable state. Compared to previous software specialization approaches, which consider the whole lifetime of a program, temporal specialization removes many additional system calls, including dangerous ones such as execve, which are typically required by server applications only during their initialization phase.</p><p>For a given server application, we perform static analysis of the main program and all imported libraries to extract the set of system calls which are no longer used after the transition into the serving phase. As precise call graph generation is a known problem in static analysis, we perform multiple optimizations on top of existing points-to analysis algorithms to reduce the imprecision of the call graph, which helps in identifying a near-accurate set of used system calls.</p><p>We demonstrate the effectiveness of temporal specialization by evaluating it with six well known server applications against a set of shellcodes and ROP payloads. We show that temporal specialization disables 51% more security-critical system calls compared to existing library specialization approaches, breaking 77% of the shellcodes and 68% of the ROP payloads tested. In addition, 53 Linux kernel CVEs are mitigated once temporal specialization comes into effect, 13 of which are not preventable by library specialization.</p><p>As a best-effort attack surface reduction solution, temporal specialization is practical, easy to deploy, and significantly restricts an attacker's capabilities. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Appendix</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Imprecision of Points-to Analysis</head><p>In Sections 4.2 and 5.1, we discussed how context sensitivity and path sensitivity contribute to the overapproximation problem and make the results of Andersen's analysis imprecise. While our experiences show that the lack of context sensitivity and path sensitivity are the primary contributors to this imprecision, other factors too contribute to overapproximation in the results of the points-to analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Field Sensitivity</head><p>The points-to analysis provided by the SVF library is field-sensitive. Field sensitivity allows every field of a struct to be uniquely modeled, which is critical for the precision of the analysis. For example, in case of Apache Httpd, the cleanup_t type contains function pointers for cleaning memory allocated on various heaps. To distinguish between the different function pointers in this structure, we must model the individual fields of the struct cleanup_t as field-sensitive. However, there are certain circumstances under which SVF forsakes field sensitivity in lieu of simplicity of implementation and reduction in analysis time.</p><p>Array Index Sensitivity SVF's implementation of Andersen's algorithm is not array-index-sensitive. Individual elements of an array are not modeled uniquely. Therefore, if multiple struct objects are stored in a array, the individual struct objects become field-insensitive, because the array elements themselves are not modeled uniquely. For example, objects of type ap_listen_rec are stored in the array of pointers listen_buckets. The type ap_listen_rec has a field accept_func which stores a pointer to the function that is invoked on the accept event. As these objects are stored in an index-insensitive array, they lose </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Library debloating [12, 51] can only remove system calls that are never used during the entire lifetime of the application (top left). Temporal specialization removes additional system calls that are never used after the initialization phase (top right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The effect of pruning based on argument types and taken addresses on generating a precise call graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>permission check analysis framework for linux kernel. In Proceedings of the 28th USENIX Security Symposium, pages 1205-1220, 2019. [65] Zhi Zhang, Yueqiang Cheng, Surya Nepal, Dongxi Liu, Qingni Shen, and Fethi Rabhi. KASR: A reliable and practical approach to attack surface reduction of com- modity OS kernels. In Proceedings of the International Conference on Research in Attacks, Intrusions, and De- fenses (RAID), pages 691-710, 2018. [66] Xiangyu Zhang Zhongshu Gu, Brendan Saltaformaggio and Dongyan Xu. Face-change: Application-driven dy- namic kernel view switching in a virtual machine. In Proceedings of the 44th IEEE/IFIP International Con- ference on Dependable Systems and Networks (DSN), 2014.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><head>Table 1 : "Argument type" and "address taken" pruning reduce the number of spurious edges on the call graph significantly.</head><label>1</label><figDesc></figDesc><table>Application 
SVF 
+ Arg. Type + Address Taken 

Nginx 
38.2K 
11.6K 
11.5K 
Apache Httpd 
23.8K 
12.4K 
11.1K 
Lighttpd 
3.0K 
2.7K 
2.7K 
Bind 
67.9K 
33.7K 
33.3K 
Memcached 
7.6K 
6.2K 
5.8K 
Redis 
33.8K 
18.6K 
18.6K 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><head>Table 2 : Breakdown of the time (in minutes) required for each step of our analysis.</head><label>2</label><figDesc></figDesc><table>Application Bitcode 
Size(MB) 

Default 
(min) 

SVF w. 
Arg. Type 

+ Addr. 
Taken 

Temp. 
Total 

Nginx 
1.9 
1 
+80 
+2 
83 
Apache 
2.1 
3 
+13 
+1 
17 
Lighttpd 
1.0 
1 
+1 
+1 
3 
Bind 
11.0 
3 
+554 
+5 
562 
Memcached 
1.6 
1 
+1 
+1 
3 
Redis 
9.2 
1 
+21 
+1 
23 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Number of system calls retained (out of 333 available) 
after applying library debloating and temporal specialization. 

Application 
Library 
Debloating 

Temporal Specialization 
Initialization Serving 

Nginx 
104 
104 
97 
Apache 
105 
94 
79 
Lighttpd 
95 
95 
76 
Bind 
127 
99 
85 
Memcached 
99 
99 
84 
Redis 
90 
90 
82 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><head>Table 4 : Critical system calls removed by library specialization ("Lib.") and temporal specialization ("Temp.").</head><label>4</label><figDesc></figDesc><table>Syscall 
Nginx 
Apache Httpd 
Lighttpd 
Bind 
Memcached 
Redis 
Lib. 
Temp. 
Lib. Temp. 
Lib. Temp. 
Lib. Temp. 
Lib. Temp. 
Lib. 
Temp. 

Cmd Execution 

clone 



* 

* 

* 

* 

* 
execveat 












execve 





O 





O 
fork 












ptrace 













Permission 
chmod 












mprotect 












setgid 












setreuid 












setuid 













Networking 

accept4 












accept 












bind 












connect 












listen 












recvfrom 












socket 













</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="true"><head>Table 5 : Equivalent system calls.</head><label>5</label><figDesc></figDesc><table>System call 
Equivalent System call(s) 
execve 
execveat 
accept 
accept4 
dup 
dup2,dup3 
eventfd 
eventfd2 
chmod 
fchmodat 
recv 
recvfrom, read 
send 
sendto, write 
open 
openat 

select 
pselect6, epoll_wait, epoll_wait_old, 
poll, ppoll, epoll_pwait 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>Table 6 : Number (and percentage) of payloads broken by library ("Lib.") and temporal ("Temp.") specialization for each category.</head><label>6</label><figDesc></figDesc><table>Payload Category Count 
Nginx 
Apache Httpd 
Lighttpd 
Bind 
Memcached 
Redis 

Lib. 
Temp. 
Lib. 
Temp. 
Lib. 
Temp. 
Lib. 
Temp. 
Lib. 
Temp. 
Lib. 
Temp. </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>Table 7 : Kernel CVEs mitigated by filtering unneeded system calls.</head><label>7</label><figDesc></figDesc><table>CVE 
System Call(s) 
Description 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>Table 8 : Linux ROP payloads used in our evaluation.</head><label>8</label><figDesc></figDesc><table>1) 
Return Oriented Programming and ROPgadget tool 

http : / / shell -storm.org / blog / Return -Oriented -Programming -and -
ROPgadget-tool/ 

2) 
ARM Exploitation -Defeating DEP -executing mprotect() 

https : / / blog.3or.de / arm -exploitation -defeating -dep -executing -
mprotect.html </table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank our shepherd, Claudio Canella, the anonymous reviewers, and the members of the artifact evaluation committee for their helpful feedback. This work was supported by the Office of Naval Research (ONR) through award N00014-17-1-2891, the National Science Foundation (NSF) through award CNS-1749895, and the Defense Advanced Research Projects Agency (DARPA) through award D18AP00045. Any opinions, findings, and conclusions or recommendations expressed herein are those of the authors and do not necessarily reflect the views of the ONR, NSF, or DARPA.</p></div>
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<idno>60%) 471 (84%) 199 (71%) 546 (98%) 330 (59%) 525 (94%) 500 (89%) 505 (90%) 471 (84%) 479 (85%) 439 (78%) 527 (94%</idno>
	</analytic>
	<monogr>
		<title level="j">Open Port</title>
		<imprint>
			<biblScope unit="volume">560</biblScope>
			<biblScope unit="page">334</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<idno>67%) 313 (86%) 268 (73%) 321 (87%) 263 (71%) 271 (74%) 313 (85%) 314 (85%) 289 (79%) 314 (85%) 280 (76%) 293 (80%</idno>
	</analytic>
	<monogr>
		<title level="j">Create Connection</title>
		<imprint>
			<biblScope unit="volume">366</biblScope>
			<biblScope unit="page">245</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
		<idno>54%) 340 (83%) 247 (60%) 370 (91%) 223 (54%) 273 (67%) 338 (83%) 358 (88%) 352 (86%) 362 (89%) 259 (63%) 274 (67%</idno>
	</analytic>
	<monogr>
		<title level="j">Execute Command</title>
		<imprint>
			<biblScope unit="volume">408</biblScope>
			<biblScope unit="page">223</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title/>
		<idno>30%) 125 (32%) 183 (46%) 229 (58%) 103 (26%) 179 (46%) 107 (27%) 164 (42%) 146 (37%) 164 (42%) 187 (47%) 213 (54%</idno>
	</analytic>
	<monogr>
		<title level="j">System Operations</title>
		<imprint>
			<biblScope unit="volume">392</biblScope>
			<biblScope unit="page">121</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<idno>85%) 919 (53%) 1248 (72%) 1258 (72%) 1341 (78%) 1258 (72%) 1319 (77%) 1165(68%) 1307 (76%</idno>
		<title level="m">All Shellcodes 1726 923 (53%) 1249 (72%) 1097(63%)</title>
		<imprint>
			<biblScope unit="page">1466</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Common vulnerabilities and exposures database</title>
		<ptr target="https://www.cvedetails.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dockerslim</surname></persName>
		</author>
		<ptr target="https://dockersl.im" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title/>
		<ptr target="http://llvm.org" />
	</analytic>
	<monogr>
		<title level="j">The LLVM compiler infrastructure</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Memcached</surname></persName>
		</author>
		<ptr target="https://memcached.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Meterpreter</surname></persName>
		</author>
		<ptr target="https://github.com/rapid7/metasploit-framework/wiki/Meterpreter/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Nginx</surname></persName>
		</author>
		<ptr target="https://www.nginx.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bpf</forename><surname>Seccomp</surname></persName>
		</author>
		<ptr target="https://www.kernel.org/doc/html/v4.16/userspace-api/seccomp_filter.html" />
		<title level="m">SECure COMPuting with filters</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shell-Storm</surname></persName>
		</author>
		<ptr target="http://www.shell-storm.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">G</forename><surname>Syslog</surname></persName>
		</author>
		<ptr target="https://www.syslog-ng.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Learning very large configuration spaces: What matters for Linux kernel sizes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathieu</forename><surname>Acher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugo</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juliana</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arnaud</forename><surname>Blouin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Marc</forename><surname>Jézéquel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Djamel</forename><surname>Khelladi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luc</forename><surname>Lesoil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olivier</forename><surname>Barais</surname></persName>
		</author>
		<idno>HAL-02314830</idno>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
		<respStmt>
			<orgName>Inria Rennes -Bretagne Atlantique</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Nibbler: Debloating binary shared libraries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ioannis</forename><surname>Agadakos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Di</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Williams-King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vasileios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Georgios</forename><surname>Kemerlis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Portokalidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th Annual Computer Security Applications Conference (ACSAC)</title>
		<meeting>the 35th Annual Computer Security Applications Conference (ACSAC)</meeting>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="page" from="70" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Less is more: Quantifying the security benefits of debloating web applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierre</forename><surname>Babak Amin Azad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Laperdrix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Nikiforakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th USENIX Security Symposium</title>
		<meeting>the 28th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Program analysis and specialization for the C programming language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lars</forename><forename type="middle">Ole</forename><surname>Andersen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
		<respStmt>
			<orgName>University of Cophenhagen</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Apache</forename><surname>Apache</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Httpd</surname></persName>
		</author>
		<ptr target="https://httpd.apache.org/" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Towards automated application-specific software stacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicolai</forename><surname>Davidsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andre</forename><surname>Pawlowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thorsten</forename><surname>Holz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th European Symposium on Research in Computer Security (ESORICS)</title>
		<meeting>the 24th European Symposium on Research in Computer Security (ESORICS)</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Sysfilter: Automated system call filtering for commodity software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Demarinis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kent</forename><surname>Williams-King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Di</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rodrigo</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vasileios</forename><forename type="middle">P</forename><surname>Kemerlis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Research in Attacks, Intrusions, and Defenses (RAID)</title>
		<meeting>the International Conference on Research in Attacks, Intrusions, and Defenses (RAID)</meeting>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Formalizing sensitivity in static analysis for intrusion detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathon</forename><forename type="middle">T</forename><surname>Henry Hanping Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yong</forename><surname>Giffin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Somesh</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenke</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barton P</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security &amp; Privacy (S&amp;P)</title>
		<meeting>the IEEE Symposium on Security &amp; Privacy (S&amp;P)</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="194" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A sense of self for Unix processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephanie</forename><surname>Forrest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Steven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anil</forename><surname>Hofmeyr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas A</forename><surname>Somayaji</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Longstaff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security &amp; Privacy (S&amp;P)</title>
		<meeting>the IEEE Symposium on Security &amp; Privacy (S&amp;P)</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="120" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Ostia: A delegating architecture for secure system call interposition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tal</forename><surname>Garfinkel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mendel</forename><surname>Rosenblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Binary control-flow trimming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Masoud</forename><surname>Ghaffarinia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><forename type="middle">W</forename><surname>Hamlen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 26th ACM Conference on Computer and Communications Security (CCS)</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Confine: Automated system call policy generation for container attack surface reduction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seyedhamed</forename><surname>Ghavamnia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tapti</forename><surname>Palit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Research in Attacks, Intrusions, and Defenses</title>
		<meeting>the International Conference on Research in Attacks, Intrusions, and Defenses</meeting>
		<imprint>
			<biblScope unit="page">2020</biblScope>
		</imprint>
	</monogr>
	<note>Azzedine Benameur, and Michalis Polychronakis</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A context-sensitive memory model for verification of C/C++ programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Gurfinkel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jorge</forename><forename type="middle">A</forename><surname>Navas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Static Analysis Symposium</title>
		<meeting>the International Static Analysis Symposium</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="148" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Gustafsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Egypt</surname></persName>
		</author>
		<ptr target="https://www.gson.org/egypt/egypt.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Trimmer: Application specialization for code debloating</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Gehani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hashim</forename><surname>Sharif</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muhammad</forename><surname>Abubakar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fareed</forename><surname>Zaffar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd</title>
		<meeting>the 33rd</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
				<title level="m">ACM/IEEE International Conference on Automated Software Engineering (ASE)</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Effective program debloating via reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kihong</forename><surname>Heo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Woosuk</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pardis</forename><surname>Pashakhanloo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mayur</forename><surname>Naik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 24th ACM Conference on Computer and Communications Security (CCS)</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Pointer analysis: Haven&apos;t we solved this problem yet?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Hind</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and Engineering (PASTE)</title>
		<meeting>the ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and Engineering (PASTE)</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="54" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Code inflation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Gerard J Holzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="10" to="13" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">User-level infrastructure for system call interposition: A platform for intrusion detection and confinement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kapil</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Feature-based software customization: Preliminary analysis, formalization, and methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yufei</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Can</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dinghao</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peng</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th IEEE International Symposium on High Assurance Systems Engineering (HASE)</title>
		<meeting>the 17th IEEE International Symposium on High Assurance Systems Engineering (HASE)</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Protecting Commodity Operating Systems through Strong Kernel Isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vasileios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kemerlis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
		<respStmt>
			<orgName>Columbia University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Michalis Polychronakis, and Angelos D. Keromytis. ret2dir: Rethinking kernel isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vasileios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kemerlis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd USENIX Security Symposium</title>
		<meeting>the 23rd USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="957" to="972" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">kguard: Lightweight kernel protection against return-to-user attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vasileios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Georgios</forename><surname>Kemerlis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Angelos</forename><forename type="middle">D</forename><surname>Portokalidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Keromytis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st USENIX Security Symposium</title>
		<meeting>the 21st USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Configuration-driven software debloating</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hyungjoon</forename><surname>Koo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seyedhamed</forename><surname>Ghavamnia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michalis</forename><surname>Polychronakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th European Workshop on Systems Security</title>
		<meeting>the 12th European Workshop on Systems Security</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Automating mimicry attacks using static binary analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engin</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Darren</forename><surname>Mutz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giovanni</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Unification-based pointer analysis without oversharing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jakub</forename><surname>Kuderski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jorge</forename><forename type="middle">A</forename><surname>Navas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Gurfinkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Formal Methods in Computer Aided Design (FMCAD)</title>
		<meeting>the Formal Methods in Computer Aided Design (FMCAD)</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019" />
			<biblScope unit="page" from="37" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Attack surface metrics and automated compile-time OS kernel tailoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anil</forename><surname>Kurmus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reinhard</forename><surname>Tartler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniela</forename><surname>Dorneanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernhard</forename><surname>Heinloth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valentin</forename><surname>Rothberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Ruprecht</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><surname>Schroder-Preikschat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Lohmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rudiger</forename><surname>Kapitza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">SPEAKER: Splitphase execution of application containers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lingguang</forename><surname>Lei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianhua</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kun</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Shenefiel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rui</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuewu</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qi</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th Conference on Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA)</title>
		<meeting>the 12th Conference on Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA)</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="230" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Lock-in-pop: Securing privileged operating system kernels by keeping on the beaten path</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yiwen</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brendan</forename><surname>Dolan-Gavitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sam</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Justin</forename><surname>Cappos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference</title>
		<meeting>the USENIX Annual Technical Conference</meeting>
		<imprint>
			<publisher>ATC</publisher>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">The BSD packet filter: A new architecture for user-level packet capture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Mccanne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Van Jacobson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Winter Conference</title>
		<meeting>the USENIX Winter Conference</meeting>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Shredder: Breaking Exploits through API Specialization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shachee</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michalis</forename><surname>Polychronakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual Computer Security Applications Conference (ACSAC)</title>
		<meeting>the 34th Annual Computer Security Applications Conference (ACSAC)</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Saffire: Context-sensitive function specialization against code reuse attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shachee</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michalis</forename><surname>Polychronakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th IEEE European Symposium on Security and Privacy (EuroS&amp;P)</title>
		<meeting>the 5th IEEE European Symposium on Security and Privacy (EuroS&amp;P)</meeting>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Breaking payloads with runtime code stripping and image freezing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Collin</forename><surname>Mulliner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Neugschwandtner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
			<pubPlace>Black Hat USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A practical mimicry attack against powerful system-call monitors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chetan</forename><surname>Parampalli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rob</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Information, Computer and Communications Security (ASI-ACCS)</title>
		<meeting>the ACM Symposium on Information, Computer and Communications Security (ASI-ACCS)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="156" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Wave propagation and deep propagation for pointer analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fernando</forename><surname>Magno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Quintao</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Berlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Code Generation and Optimization (CGO)</title>
		<meeting>the International Symposium on Code Generation and Optimization (CGO)</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="126" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">kRˆX: Comprehensive kernel protection against just-in-time code reuse</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marios</forename><surname>Pomonis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Theofilos</forename><surname>Petsios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Angelos</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michalis</forename><surname>Polychronakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vasileios</forename><forename type="middle">P</forename><surname>Kemerlis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th European Conference on Computer Systems (EuroSys)</title>
		<meeting>the 12th European Conference on Computer Systems (EuroSys)</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="420" to="436" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Blankit library debloating: Getting what you want instead of cutting what you don&apos;t</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Girish</forename><surname>Mururu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prithayan</forename><surname>Barua</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Santosh</forename><surname>Pande</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</title>
		<meeting>the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</meeting>
		<imprint>
			<date type="published" when="2020" />
			<biblScope unit="page" from="164" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">RAZOR: A framework for post-deployment software debloating</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chenxiong</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hong</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mansour</forename><surname>Alharthi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Pak Ho Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenke</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th USENIX Security Symposium</title>
		<meeting>the 28th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">A multi-OS cross-layer study of bloating in user programs, kernel and managed execution environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anh</forename><surname>Quach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rukayat</forename><surname>Erinfolami</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Demicco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aravind</forename><surname>Prakash</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Forming an Ecosystem Around Software Transformation (FEAST)</title>
		<meeting>the Workshop on Forming an Ecosystem Around Software Transformation (FEAST)</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="65" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Bloat factors and binary specialization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anh</forename><surname>Quach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aravind</forename><surname>Prakash</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd ACM Workshop on Forming an Ecosystem Around Software Transformation (FEAST)</title>
		<meeting>the 3rd ACM Workshop on Forming an Ecosystem Around Software Transformation (FEAST)</meeting>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="page" from="31" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Debloating software through piece-wise compilation and loading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anh</forename><surname>Quach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aravind</forename><surname>Prakash</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lok</forename><surname>Yan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Security Symposium</title>
		<meeting>the 27th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="869" to="886" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Authenticated system calls</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohan</forename><surname>Rajagopalan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matti</forename><surname>Hiltunen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trevor</forename><surname>Jim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Schlichting</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Dependable Systems and Networks (DSN)</title>
		<meeting>the International Conference on Dependable Systems and Networks (DSN)</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="358" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Fine-grained library customization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linhai</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xinyu</forename><surname>Xing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ECOOP International Workshop on Software Debloating and Delayering (SALAD)</title>
		<meeting>the 1st ECOOP International Workshop on Software Debloating and Delayering (SALAD)</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Points-to analysis in almost linear time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bjarne</forename><surname>Steensgaard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages</title>
		<meeting>the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="32" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">SVF: interprocedural static value-flow analysis in LLVM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yulei</forename><surname>Sui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jingling</forename><surname>Xue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Compiler Construction</title>
		<meeting>the 25th International Conference on Compiler Construction</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Detecting memory leaks statically with full-sparse value-flow analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yulei</forename><surname>Sui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ding</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jingling</forename><surname>Xue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="107" to="122" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Combining concern input with program analysis for bloat detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kanchi</forename><surname>Gopinath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Suparna</forename><surname>Bhattacharya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mangala Gowri</forename><surname>Nanda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages &amp; Applications (OOPSLA)</title>
		<meeting>the ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages &amp; Applications (OOPSLA)</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Intrusion detection via static analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Drew</forename><surname>Dean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security &amp; Privacy</title>
		<meeting>the IEEE Symposium on Security &amp; Privacy</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="156" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Mining sandboxes for Linux containers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhiyuan</forename><surname>Wan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xin</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shanping</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th IEEE International Conference on Software Testing, Verification and Validation (ICST)</title>
		<meeting>the 10th IEEE International Conference on Software Testing, Verification and Validation (ICST)</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="92" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">TOCTTOU vulnerabilities in UNIX-style file systems: An anatomical study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jinpeng</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Calton</forename><surname>Pu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Conference on File and Storage Technologies (FAST)</title>
		<meeting>the USENIX Conference on File and Storage Technologies (FAST)</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tatu Ylönen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ssh Agent</surname></persName>
		</author>
		<ptr target="https://www.ssh.com/ssh/agent" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Jred: Program customization and bloatware mitigation based on static analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dinghao</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yufei</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peng</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th Annual Computer Software and Applications Conference (ACSAC)</title>
		<meeting>the 40th Annual Computer Software and Applications Conference (ACSAC)</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Damgate: Dynamic adaptive multi-feature gating in program binaries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tian</forename><surname>Lan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yurong</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guru</forename><surname>Venkataramani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Forming an Ecosystem Around Software Transformation (FEAST)</title>
		<meeting>the Workshop on Forming an Ecosystem Around Software Transformation (FEAST)</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title level="m" type="main">PeX: A 3) 64-bit ROP | You rule</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tong</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenbo</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongyoon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Changhee</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmed</forename><forename type="middle">M</forename><surname>Azab</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruowen</forename><surname>Wang</surname></persName>
		</author>
		<ptr target="https://0x00sec.org/t/64-bit-rop-you-rule-em-all/1937" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<title level="m" type="main">4) 64-bit Linux Return-Oriented Programming</title>
		<ptr target="https://crypto.stanford.edu/~blynn/rop/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<title level="m" type="main">Return-Oriented-Programming(ROP FTW)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<monogr>
		<title level="m" type="main">PMS 0.42 -Local Stack-Based Overflow (ROP)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<monogr>
		<title level="m" type="main">Crashmail 1.6 -Stack-Based Buffer Overflow</title>
		<ptr target="https://www.exploit-db.com/exploits/44331/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Bypassing non-executable memory</title>
		<ptr target="https://www.antoniobarresi.com/security/exploitdev/2014/05/03/64bitexploitation/" />
	</analytic>
	<monogr>
		<title level="m">ASLR and stack canaries on x86-64 Linux</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<title level="m" type="main">Bypassing non-executable-stack during Exploitation (return-to-libc)</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
