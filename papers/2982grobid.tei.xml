<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:56+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Practical Web-based Delta Synchronization for Cloud Storage Services</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">He</forename><surname>Xiao</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
								<orgName type="institution" key="instit3">Yale University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhenhua</forename><surname>Li</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
								<orgName type="institution" key="instit3">Yale University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ennan</forename><surname>Zhai</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
								<orgName type="institution" key="instit3">Yale University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>UCSD</roleName><forename type="first">Tianyin</forename><surname>Xu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Tsinghua University</orgName>
								<orgName type="institution" key="instit3">Yale University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Practical Web-based Delta Synchronization for Cloud Storage Services</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Delta synchronization (sync) is known to be crucial for network-level efficiency of cloud storage services (e.g., Dropbox). Practical delta sync techniques are, however , only available for PC clients and mobile apps, but not web browsers-the most pervasive and OS-independent access method. To understand obstacles of web-based delta sync, we implemented a traditional delta sync solution (named WebRsync) for web browsers using JavaScript, and find that WebRsync severely suffers from the inefficiency of JavaScript execution inside web browsers, thus leading to frequent stagnation and even crashing. Given that the computation burden on the web browser mainly stems from data chunk search and comparison , we reverse the traditional delta sync approach by lifting all chunk search and comparison operations from the client side into the server side. Inevitably, this brings enormous computation overhead to the servers. Hence, we further leverage locality matching and a more efficient checksum to reduce the overhead. The resulting solution (called WebR2sync+) outpaces WebRsync by an order of magnitude, and it is able to simultaneously support ∼7300 web clients&apos; delta sync using an ordinary VM server based on a Dropbox-like system architecture.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recent years have witnessed enormous popularity of cloud storage services, such as Dropbox, Google Drive, iCloud Drive, and Microsoft OneDrive. They have not only provided a convenient and pervasive data store for billions of Internet users <ref type="bibr">[5]</ref>, but also become a critical component of numerous online applications (e.g., Dropbox's support for DocuSign, Google Drive's support for Gmail, and OneDrive's support for Office 365).</p><p>The popularity of cloud storage services inevitably brings tremendous network traffic overhead to both the client and cloud sides <ref type="bibr" target="#b13">[15]</ref>. Therefore, a lot of efforts have been made to improve the network-level efficiency of cloud storage services, including batched synchronization (sync), deferred sync, delta sync, compression and deduplication <ref type="bibr" target="#b10">[12,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr" target="#b15">17,</ref><ref type="bibr" target="#b16">18]</ref>. Among these efforts, delta sync is known to be of particular importance for its fine granularity (i.e., the client only sends the changed content of a file to the cloud), thus achieving significant traffic savings in the presence of users' file edits <ref type="bibr" target="#b17">[19]</ref>.</p><p>Unfortunately, delta sync is currently only practical for PC clients and mobile apps, but not web browsers-the most pervasive and OS-independent access method <ref type="bibr" target="#b15">[17]</ref>. For example, after a file f is edited into a new version f by the user, Dropbox's PC client or mobile app only uploads the altered bits to the cloud; in contrast, the web browser has to upload the whole content of f to the cloud. This gap severely affects web-based user experiences in terms of both sync performance and traffic cost.</p><p>To understand the potential obstacles of web-based delta sync, we implement a delta sync solution (referred to as WebRsync) for web browsers using JavaScript based on rsync <ref type="bibr" target="#b5">[7]</ref>, the de facto delta sync protocol for PC clients. Also, we develop an automated tool (called StagMeter) to accurately measure the stagnation of web browsers. Our experimental results show that WebRsync severely suffers from the inefficiency of JavaScript running inside web browsers. Under typical file editing workloads, WebRsync is slower than PC client-based delta sync by up to 25 times, thus causing web browsers to frequently freeze and even crash.</p><p>Specifically, when a user edits a file from f to f , WebRsync first requests the server side to execute (data) chunk segmentation and fingerprinting operations on f , and then requests the client side to perform chunk search and comparison operations on f . During the process, the computation overhead on the client side is larger than that on the server side by around 7 times. More in detail, the client-side computation burden mainly stems from chunk search (∼65%) and comparison (∼22%).</p><p>Motivated by the above observations, our first effort is to "reverse" the WebRsync process by handing all chunk search and comparison operations over to the server side. Meanwhile, chunk segmentation and fingerprinting operations are shifted to the client side. The resulting solution is referred to as WebR2sync, denoting web-based reverse rsync (more details are described in §3.1 and <ref type="figure">Figure 4)</ref>. Although WebR2sync significantly cuts the computation burden on the web client (and thus effectively avoids stagnation/crashing), it brings enormous computation overhead to the server side. To this end, we make two-fold additional efforts to optimize the server-side computation overhead. First, we exploit the locality of   users' file edits which can help bypass most (∼90%) chunk search operations in real usage scenarios. This can reduce nearly a half of server-side computation overhead. Second, by replacing the relatively secure, expensive MD5 algorithm with the more efficient, pseudorandom SipHash algorithm, we can reduce the complexity of chunk comparison by around 6 times. Through the above efforts, our final solution (named WebR2sync+) outpaces WebRsync by around an order of magnitude, approaching the performance of PC clientbased rsync. Also, it is able to simultaneously support ∼7300 web clients' delta sync using an ordinary VM server based on a Dropbox-like system architecture. This throughput (∼7300) is as 4 times as that of WebR2sync and as 9 times as that of NoWebRsync 1 . All source codes of WebRsync (including StagMeter), WebR2sync and WebR2sync+ are publicly available at https://WebDeltaSync.github.io.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Motivating Study</head><p>To quantitatively understand the reason why web-based delta sync is not supported by today's cloud storage services, we implement the WebRsync solution and measure its performance using the StagMeter tool as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>WebRsync.</head><p>We implement WebRsync by adapting the working procedure of rsync (demonstrated in <ref type="figure">Fig- ure 4(a)</ref>) to the web browser scenario. Moreover, the architecture of WebRsync follows Dropbox's system architecture. Specifically, we implement the client side based on the HTML5 File APIs <ref type="bibr" target="#b4">[6]</ref> and the WebSocket protocol, using 1500 lines of JavaScript code. The server side is developed based on the node.js framework, using 500 lines of node.js code and 600 lines of C++ code. Similar to Dropbox (on the server side), the web service runs on a VM server hosted on Aliyun ECS <ref type="bibr" target="#b1">[2]</ref>, and the file content is stored in object storage hosted on Aliyun OSS <ref type="bibr" target="#b2">[3]</ref>. More details on the server, client and network configurations are described in §4.1 and <ref type="figure" target="#fig_4">Figure 7</ref>.</p><p>To compare the performance of WebRsync and rsync, we do a random edit (an insertion or a deletion) with different sizes on a typical text file every 10 seconds. Here typical means that we use a real-world cloud storage dataset released in <ref type="bibr" target="#b15">[17]</ref>, where the average file size is nearly 1 MB and the median file size is 7.5 KB. As shown in <ref type="figure" target="#fig_0">Figure 1</ref>, the sync time of WebRsync is significantly longer than that of rsync by 14-25 times. In other words, WebRsync is much slower than rsync on handling the same file edit. Further, we break down the sync time of WebRsync into three stages as depicted in <ref type="figure" target="#fig_1">Figure 2</ref>. Clearly, the vast majority of sync time is spent at the client side, indicating that the slowness of WebRsync is owing to the inefficiency of the browser. Additionally, <ref type="figure" target="#fig_2">Figure 3</ref> shows that the CPU utilization of WebRsync almost doubles that of rsync, because JavaScript programs consume enormous CPU resources.</p><p>In summary, WebRsync costs not only more sync time but also more computation resources on the client side, thus causing the web browser to frequently stagnate and even crash. Here "stagnate" means that the browser does not react to user actions (e.g., mouse clicks) in time, and "crash" means that the browser never reacts to user actions. We further develop the StagMeter tool as follows to measure the stagnation of the browser.</p><p>StagMeter. Although stagnation of the browser can be perceived by users, they can hardly be quantified. Thus, we automate the measurement of stagnation time by integrating a snippet of JavaScript code (referred to as StagMeter) into the browser. The snippet periodically 2 prints the current timestamp on the concerned web page (e.g., the web page that executes delta sync). If the current timestamp (say t) is successfully printed at the moment, there is no stagnation; otherwise, there is a stagnation and then the printing of the current timestamp will be postponed to t &gt; t. Thereby, the corresponding stagnation time is calculated as t − t. Using StagMeter, we measure and visualize the stagnation of WebRsync (on handling various file-edit workloads) in <ref type="figure" target="#fig_3">Figure 5</ref>. Here StagMeter only attempts to print 10 timestamps for the first second. Therefore, spaces between consecutive timestamps represent stagnation, and larger spaces imply more severe stagnation. Meanwhile, as indicated in <ref type="figure" target="#fig_3">Figure 5</ref>, stagnation cases are directly associated with high CPU utilization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Design and Implementation</head><p>In this section, we first present the WebR2sync solution which implements the reverse process of WebRsync, and then describe the server-side optimizations for mitigating the computation overhead on servers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">WebR2sync</head><p>Before we describe the design of WebR2sync, we first review the work flow of WebRsync as a comparison. As demonstrated in <ref type="figure">Figure 4(a)</ref>, in WebRsync when a user edits a file from f to f , the client instantly sends a request to the server for the file synchronization. On receiving the request, the server first executes (data) chunk segmentation and fingerprinting operations on f (which is available on the cloud side), and then returns a checksum list of f to the client. Except for the last chunk, each data chunk is 8 KB in size. Thus when f is 1 MB in size, its checksum list contains 128 weak rolling 32-bit checksums as well as 128 strong 128-bit MD5 checksums <ref type="bibr" target="#b5">[7]</ref>. After that, based on the checksum list of f , the client first performs chunk search and comparison operations on f , and then generates both the matching tokens and literal bytes. The matching tokens indicate the overlap between f and f , while the literal bytes represent the novel parts in f relative to f . Both of them are sent to the server for constructing f . Finally, the server returns an acknowledgment to the client to conclude the process.</p><p>As depicted in <ref type="figure">Figure 4</ref>(b), WebR2sync implements the reverse process of WebRsync by handing computation intensive search and comparison operations over at the server side, and meanwhile shifting the lightweight segmentation and fingerprinting operations to the client side. Accordingly, the checksum list of f is generated by the client and the matching tokens are generated by the server, while the literal bytes are still generated by the client. Note that on the server side, the search and comparison operations are implemented in C/C++ rather than in JavaScript. Therefore, WebR2sync can not only avoid stagnation/crashing for the web client, but also effectively shorten the duration of the whole sync process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Server-side Optimization</head><p>Although WebR2sync significantly reduce the computation burden on the web client, it brings enormous computation overhead to the server side. We make two-fold efforts to optimize the server-side computation overhead.</p><p>Exploiting locality of file edits in chunk search. When the server receives a checksum list from the client, WebR2sync uses a 3-level chunk searching scheme to figure out matched chunks between f and f , as demonstrated in <ref type="figure">Figure 6</ref> (following the 3-level chunk searching scheme of rsync <ref type="bibr" target="#b5">[7]</ref>). Specifically, in the checksum list of f there is a 32-bit weak rolling checksum (calculated by the Adler32 algorithm <ref type="bibr" target="#b11">[13]</ref>) as well as a 128-bit strong MD5 checksum for each data chunk in f . When this checksum list is sent to the server, the server leverages an additional (rolling checksum) hash table where every entry is a 16-bit hash code of the 32-bit rolling checksum <ref type="bibr" target="#b5">[7]</ref>. The checksum list is then sorted according to the 16-bit hash code of the 32-bit rolling checksums. Note that a 16-bit hash code can point to multiple rolling/MD5 checksums. To find each matched chunk  <ref type="figure">Figure 6</ref>: The 3-level chunk searching scheme used by rsync and WebR2sync.</p><p>between f and f , the 3-level chunk searching scheme always goes from the 16-bit hash code to the 32-bit rolling checksum and further to the 128-bit MD5 checksum. The 3-level chunk searching scheme can effectively minimize the computation overhead for general fileedit patterns, particularly random edits to a file. However, it has been observed that real-world file edits typically follow a local pattern rather a general/random pattern <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b25">[25]</ref><ref type="bibr" target="#b26">[26]</ref>. This offers an opportunity to bypass a considerable portion of (unnecessary) chunk search operations. In essence, give that edits to a file are typically local, when we find that the i-th chunk of f matches the j-th chunk of f , the (i + 1)-th chunk of f is highly likely to match the ( j + 1)-th chunk of f . Therefore, we "simplify" the 3-level chunk searching scheme by directly comparing the MD5 checksums of the (i + 1)-th chunk of f and the ( j + 1)-th chunk of f . If the two chunks are identical, we move forward to the next chunk; otherwise, we return to the regular 3-level chunk searching scheme.</p><p>Replacing MD5 with SipHash in chunk comparison. Besides exploiting locality, we notice that the majority of server-side computation overhead is attributed to the calculations of MD5 checksums. Thus, we wonder whether the usage of MD5 is necessary in chunk comparison.</p><p>MD5 was initially designed as a cryptographic hash function for generating secure and low-collision hash code <ref type="bibr" target="#b22">[23]</ref>, which makes it quite computation intensive. In our scenario, however, it is not necessary to use such a computationally expensive hash function, because our purpose is just to obtain a low collision probability. In fact, we can employ the HTTPS protocol for data exchange between the web client and server to ensure the security. Driven by this insight, we decide to replace MD5 with a lightweight pseudorandom hash function <ref type="bibr" target="#b9">[11]</ref> in order to reduce the computational overhead.</p><p>Quite a few pseudorandom hash functions can satisfy our goal, such as Spooky <ref type="bibr" target="#b14">[16]</ref>, FNV <ref type="bibr" target="#b20">[21]</ref>, CityHash <ref type="bibr" target="#b21">[22]</ref>, SipHash <ref type="bibr" target="#b8">[10]</ref>, and Murmur3 <ref type="bibr" target="#b7">[9]</ref>. Among them, some are very lightweight but have high collision probabilities. For example, the computation overhead of MD5 is around 5 to 6 cycles per byte <ref type="bibr" target="#b3">[4]</ref> while the computation overhead of CityHash is merely 0.23 cycle per byte <ref type="bibr" target="#b6">[8]</ref>, but the collision probabilities of CityHash is quite high.</p><p>On the other hand, some pseudorandom hash functions have extremely low collision probabilities but are slow.</p><p>As listed in <ref type="table" target="#tab_1">Table 1</ref>, SipHash is a sweet spot-its computation overhead is about 1.13 cycles per byte and its collision probability is acceptable (keep safe under flood attack). By replacing MD5 with SipHash in our web-based delta sync solution, we manage to reduce the computation complexity of chunk comparison by nearly 6 times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Implementation</head><p>The client side of WebR2sync+ is implemented based on the HTML5 File APIs, the WebSocket protocol, and a Javascript implementation of SipHash-2-4 <ref type="bibr" target="#b0">[1]</ref>, with 1700 lines of JavaScript code in total. The server side of WebR2sync+ is developed based on the node.js framework and C++ processing module. The former (500 lines of node.js code) handles the user requests, and the latter (1000 lines of C++ code) embodies the reverse delta sync process together with the two-fold optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Evaluation</head><p>In this section, we show the performance and overhead of WebR2sync+ in comparison to WebRsync, WebR2sync and PC client-based rsync under typical workloads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Experiment Setup</head><p>Like WebRsync, the server side of WebR2sync+ adopts a Dropbox-like system architecture by running the web service on a VM (with a quad-core Intel Xeon CPU @2.5GHz and 16-GB memory) hosted on Aliyun ECS, and all file content is stored in object storage hosted on Aliyun OSS. The ECS VM and OSS storage locate at the same data center so there is no bottleneck between them. Also, the client side of WebR2sync+ is integrated into the Google Chrome browser (Windows version 56.0) running on a laptop with a quad-core Intel Core-i5 CPU @2.8GHz, 16-GB memory, and an SSD disk. More in detail, the server side and client side lie in different cities (i.e., Shanghai and Beijing) and different ISPs (i.e., China Unicom and CERNET), as depicted in     </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Results</head><p>Synchronization time. We measure the sync time of WebR2sync+. As demonstrated in <ref type="figure">Figure 8</ref>, the sync time of WebR2sync+ is substantially shorter than that of WebR2sync (by 2 to 3 times) and WebRsync (by 15 to 20 times). In other words, WebR2sync+ outpaces WebRsync by an order of magnitude; it has comparable performance as PC client-based rsync. Further, we break down the sync time of WebR2sync+ into three stages, as shown in <ref type="figure">Figure 9</ref>. <ref type="figure">Comparing Fig- ures 9</ref> and 2 leads to two major observations. First, the majority of sync time is spent at the client side for WebRsync, while it is spent for network latency for WebR2sync+. Therefore, the web browser does not stagnate or crash. Second, the server-side sync time is still much shorter than the client-side sync time, which confirms the efficacy of our server-side optimizations.</p><p>CPU utilization. We show the client-side and serverside CPU utilizations in <ref type="figure" target="#fig_0">Figure 10</ref> and <ref type="figure" target="#fig_0">Figure 11</ref> respectively. On the client side, WebR2sync+ consumes less CPU resources than WebRsync and WebR2sync, while PC client-based rsync consumes the least CPU resources. On the server side, the CPU utilizations of all solutions are similar.</p><p>Throughput. WebR2sync+ can simultaneously support ∼7300 web clients' delta sync using an ordinary VM server under typical workloads (refer to <ref type="figure" target="#fig_0">Figure 12</ref>). This throughput is as 4 times as that of WebR2sync/rsync and as 9 times as that of NoWebRsync.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Future Work</head><p>In the near future, we plan to evaluate the performance of WebR2sync+ in more aspects and details, such as the traffic overhead, deduplication and delta-encoding rates, and the efficiency of the three optimizations (i.e., reverse rsync, locality matching, and a weaker checksum).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Acknowledgments</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Average sync time vs. edit size to a typical text file.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Sync time decomposition for WebRsync.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Average CPU utilization vs. edit size to a typical text file.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 4: Flow charts of WebRsync and WebR2sync.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Basic experiment setup visualized in a map of China.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :Figure 10 :</head><label>810</label><figDesc>Figure 8: Average sync time vs. edit size to a typical text file.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Server-side average CPU utilization vs. edit size to a typical text file.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Number of concurrent users supported by a single VM server under typical workloads.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Their network RTT is ∼30 ms and their network bandwidth is ∼100 Mbps. To evaluate the realworld performance of WebR2sync+ (mentioned in §2), we do a random edit with different sizes to a typical text file every 10 seconds, thus emulating various workloads of practical users' file edits [17].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Hash Table</head><label>Hash</label><figDesc></figDesc><table>... 

Adler32 
MD5 

Adler32 
MD5 

Adler32 
MD5 

Adler32 
MD5 

Chunk #2 

Adler32 
MD5 

File f 

Chunk #4 

Chunk #1 

Chunk #3 

Chunk #5 

Chunk #1 Chunk #2 Chunk #3 Chunk #4 
... 
Chunk #n 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><head>Table 1 : A comparison of pseudorandom hash functions</head><label>1</label><figDesc></figDesc><table>Hash Function Collision Probability Cycles per Byte 
MD5 
Low 
5.58 
Murmur3 
High 
0.33 
CityHash 
High 
0.23 
FVN 
High 
1.75 
Spooky 
High 
0.14 
SipHash 
Low 
1.13 

</table></figure>

			<note place="foot" n="1"> NoWebRsync refers to the approach that uploads the entire file for synchronization without delta sync. Note that NoWebRsync is the common approach for web-based access adopted by current cloud storage services such as Dropbox, SugarSync and iCloud Drive.</note>

			<note place="foot" n="2"> By default we set the period as 100 ms, so as to simulate the minimum intervals of common web users&apos; operations.</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">A Javascript Implementation of SipHash-2-4</title>
		<ptr target="https://github.com/jedisct1/siphash-js" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<ptr target="https://www.aliyun.com/product/ECS" />
	</analytic>
	<monogr>
		<title level="j">Aliyun ECS (Elastic Compute Service</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oss</forename><surname>Aliyun</surname></persName>
		</author>
		<ptr target="https://www.aliyun.com/product/OSS" />
	</analytic>
	<monogr>
		<title level="j">Object Storage Service</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
				<ptr target="https://bench.cr.yp.to/results-hash.html" />
		<title level="m">eBACS: ECRYPT Benchmarking of Cryptographic Systems</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<ptr target="https://www.html5rocks.com/en/tutorials/file/dndfiles/" />
		<title level="m">JavaScript Using the File APIs</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
				<ptr target="http://www.samba.org/rsync" />
		<title level="m">rsync Web Site</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Fast Keyed Hash/Pseudo-random Function Using SIMD Multiply and Permute</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Alakuijala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wassenberg</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1612.06257</idno>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Murmur3 hash function</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Appleby</surname></persName>
		</author>
		<ptr target="https://github.com/aappleby/smhasher" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">SipHash: a Fast Short-input PRF</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-P</forename><surname>Aumasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Bernstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Cryptology in India</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="489" to="508" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Keying Hash Functions for Message Authentication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Cryptology Conference</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">QuickSync: Improving Synchronization Efficiency for Mobile Cloud Storage Services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Miao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Annual International Conference on Mobile Computing and Networking (MobiCom)</title>
		<meeting>the 21st Annual International Conference on Mobile Computing and Networking (MobiCom)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="592" to="603" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Zlib Compressed Data Format Specification Version 3.3</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Deutsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-L</forename><surname>Gailly</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
		<respStmt>
			<orgName>RFC Network Working Group</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Benchmarking Personal Cloud Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Drago</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bocchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mellia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Slatman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th ACM Internet Measurement Conference (IMC)</title>
		<meeting>the 13th ACM Internet Measurement Conference (IMC)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="205" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Inside Dropbox: Understanding Personal Cloud Storage Services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Drago</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mellia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Munafò</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sperotto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sadre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM Internet Measurement Conference (IMC)</title>
		<meeting>the 12th ACM Internet Measurement Conference (IMC)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="481" to="494" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Spookyhash: A 128-Bit Noncryptographic Hash</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Jenkins</surname></persName>
		</author>
		<ptr target="http://burtleburtle.net/bob/hash/spooky.html" />
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Towards Networklevel Efficiency for Cloud Storage Services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z.-L</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM Internet Measurement Conference (IMC)</title>
		<meeting>the 14th ACM Internet Measurement Conference (IMC)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="115" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An Empirical Analysis of a Large-scale Mobile Cloud Storage Service</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Kaafar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Steenkiste</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM Internet Measurement Conference (IMC)</title>
		<meeting>the 16th ACM Internet Measurement Conference (IMC)</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="287" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient Batched Synchronization in Dropbox-like Cloud Storage Services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z.-L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Dai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM/IFIP/USENIX International Middleware Conference (Middleware)</title>
		<meeting>the 14th ACM/IFIP/USENIX International Middleware Conference (Middleware)</meeting>
		<imprint>
			<biblScope unit="page" from="307" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Sparse Indexing: Large Scale, Inline Deduplication Using Sampling and Locality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lillibridge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Eshghi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bhagwat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Deolalikar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Trezis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Camble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th USENIX Conference on File and Storage Technologies (FAST)</title>
		<meeting>the 6th USENIX Conference on File and Storage Technologies (FAST)</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="111" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">C</forename><surname>Noll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hash</surname></persName>
		</author>
		<ptr target="http://www.isthe.com/chongo/tech/comp/fnv/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pike</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Alakuijala</surname></persName>
		</author>
		<ptr target="http://google-" />
		<title level="m">Introducing Cityhash</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<title level="m">RFC 1321: The MD5 Messagedigest Algorithm. Internet activities board</title>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="volume">143</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">SiLo: A Similarity-Locality based Near-Exact Deduplication Scheme with Low RAM Overhead and High Throughput</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Hua</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 USENIX</title>
		<meeting>the 2011 USENIX</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
				<title level="m">Annual Technical Conference (ATC)</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="26" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Similarity and Locality Based Indexing for High Performance Data Deduplication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Hua</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1162" to="1176" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">FastCDC: a Fast and Efficient Content-defined Chunking Approach for Data Deduplication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Hua</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 USENIX Annual Technical Conference (ATC)</title>
		<meeting>the 2016 USENIX Annual Technical Conference (ATC)</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="101" to="114" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
