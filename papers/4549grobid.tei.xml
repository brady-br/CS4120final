<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:24+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fractured Processes: Adaptive, Fine-Grained Process Abstractions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thanumalayan</forename><forename type="middle">Sankaranarayana</forename><surname>Pillai</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Wisconsin-Madison</orgName>
								<orgName type="institution" key="instit2">University of Wisconsin-Madison</orgName>
								<orgName type="institution" key="instit3">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Wisconsin-Madison</orgName>
								<orgName type="institution" key="instit2">University of Wisconsin-Madison</orgName>
								<orgName type="institution" key="instit3">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Remzi</forename><forename type="middle">H</forename><surname>Arpaci-Dusseau</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Wisconsin-Madison</orgName>
								<orgName type="institution" key="instit2">University of Wisconsin-Madison</orgName>
								<orgName type="institution" key="instit3">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Fractured Processes: Adaptive, Fine-Grained Process Abstractions</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We introduce Fracture, a novel framework that transforms and modernizes the basic process abstraction. By &quot;fracturing&quot; an application into logical modules, Fracture enables powerful and novel run-time configurations that improve run-time testing, application availability, and general robustness, all in a generic and incremental manner. We demonstrate the utility of fracturing via in-depth case studies of a chat client, a web server, and two user-level file systems. Through these examples, we show that Fracture enables applications to transparently tolerate memory leaks, buffer overflows , and isolate subsystem crashes, with little change to source code; through intelligent fracturing, we can achieve low overhead as well, thus enabling deployment.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Since the advent of modern operating systems, the process has been the central abstraction of the machine that is presented to users <ref type="bibr" target="#b21">[25,</ref><ref type="bibr" target="#b14">18,</ref><ref type="bibr" target="#b40">44]</ref>. To users and developers, processes directly represent a virtual machine, providing a clean and simple abstraction of a computer system, and thus are essential in all modern systems.</p><p>Unsurprisingly, with processes as a core abstraction, an entire ecosystem of tools and techniques has developed around them. For example, debuggers such as GDB help users pinpoint problems in their code; memory checking tools such as Purify <ref type="bibr">[2]</ref> and Valgrind <ref type="bibr" target="#b41">[45]</ref> automatically find common memory-related errors; environment-related specializations, such as those made available by the run-time linker and user limits, enable further specialization (e.g., allowing transparent use of a debugging malloc library or restricting the amount of memory a process can allocate).</p><p>However, applications have changed greatly since the time when processes were invented. Early applications, particularly in the UNIX domain, were generally small and "did one thing well"; complex applications were built by stringing together many small processes <ref type="bibr" target="#b40">[44]</ref>. Modern applications, in contrast, are monoliths. Good examples are Microsoft's Office Suite, Apple's iPhoto, iTunes, and iMovie <ref type="bibr" target="#b22">[26]</ref>, Apache's web server, and Postgres database.</p><p>Unfortunately, monolithic applications can restrict the effective usage of process-based tools and techniques. For example, when downloading a code patch, a user might want to restrict the environment of the patch, gaining assurance that it works before running it unrestricted; however, patches cannot currently be easily isolated in their own environment. Alternately, the user might want to run the patched and unpatched version in parallel to compare results; currently, this might not give correct results given side effects. Finally, the user might wish to test the modified code with a memory-checking tool such as Valgrind; unfortunately, the cost of applying a tool to the entire application may be too high. Therefore, we propose that environments and tools should be applicable to sub-portions of an application.</p><p>In this paper, we introduce a new framework that enables fractured processes. Given an existing code base (written in C), a developer adds a small amount of annotation to demarcate natural boundaries within the code, thus splitting the code into a set of static modules. A fracturing specification dynamically groups modules into one or more fractured mini-processes (FMPs). Each FMP may be run in its own environment, which allows selective application of OS policies (e.g., scheduling or security); it also enables powerful process-level tools (e.g., Memcheck <ref type="bibr" target="#b41">[45]</ref>) to be selectively applied, significantly reducing overhead.</p><p>FMPs, in their simplest implementation, correspond directly to UNIX processes. Modules within an FMP communicate directly via function calls, share memory, and thus represent an isolated sub-unit of the application; modules in different FMPs communicate via shared-memory queues. Both cases are the same to the programmer, who simply annotates the code; the fracture compiler transforms the code automatically. One essential feature of the framework is that it is incremental; only relevant pieces of code need to be modified. This aspect allows large complex applications to be annotated only as needed, increasing deployability.</p><p>Beyond grouping modules into separate isolation domains, fracturing also enables many configurations. For example, individual FMPs can be restarted automatically and transparently after a crash, as in microreboots <ref type="bibr" target="#b9">[13]</ref>. One can also replicate an FMP, enabling various forms of N-version programming <ref type="bibr" target="#b3">[7]</ref>. Finally, sampling replicated FMPs can reduce overheads.</p><p>This paper makes three major contributions. First, we provide a complete framework that makes it practical to use mini-processes for application written in C; Fracture handles incremental conversion, multi-threading, and intelligent partitioning at runtime. An important aspect of Fracture is its flexibility, which allows an application to be split into mini-processes at function-level, yet also to be run as a single, low-overhead, monolithic process.</p><p>Second, we outline our experience modularizing four different applications: a simple web server, two FUSE file systems, and an open-source chat client. We present guidelines for modularizing applications and labeling the capabilities of each module (e.g., restartable, replicable, and samplable) in such a way that is low effort yet leads to acceptable performance and functionality.</p><p>Finally, we evaluate the performance overhead of applying Fracture and show how Fracture can increase robustness. We find that Fracture can be used without overhead for some configurations, but care must be taken to obtain the best trade-off between performance and isolation of modules. We show how Fracture can be used to efficiently detect buffer overflows with a padded memory allocator, find memory leaks with Memcheck, tolerate memory leaks via isolation and restart, and even use replicated fracturing to verify that a new patch behaves functionally identical to the old one-to-one. By applying this functionality for specific FMPs instead of the entire application, performance remains acceptable, indicating that all could be run in deployment.</p><p>The rest of this paper presents our framework. After an overview of the design, the paper describes our implementation, our experience fracturing different applications, an evaluation, related work, and conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Design</head><p>This section presents our goals, Fracture's ecosystem, basic fracturing approaches, and runtime configurations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Goals and Scope</head><p>The aim of Fracture is a framework that, with regards to the conventional abstractions of a process, achieves: Fine-grained mappings of parts of a program into separate runtime entities, for process-like OS-level monitoring, isolation, and policy enforcement. The fine-grained entities should allow convenient control actions, similar to process restarts. This can be contrasted to the traditional mapping of each program to a single OS process. Incremental conversion of existing programs. If only one portion of a program requires fine-grained mechanisms, it can be transformed with little effort, a stark contrast to rewriting the program in a new language. Supporting complex applications written in C. The framework should aim for minimal changes to the C paradigm, even supporting multi-threaded programs. Low overhead by adaptively mapping static code parts to fine-grained runtime entities. Runtime overhead for separating out parts must be incurred only when the user desires the separation, at runtime, and should be optimized to the environment and workload of each deployment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">System Overview</head><p>The basis of Fracture is identifying fine-grained static divisions of the code at development time, but mapping them onto runtime entities in different ways after deployment. The static divisions are identified by the programmer, who typically exposes logical divisions already present in the source code. The mappings are configured by the user or administrator, sometimes considering trade-offs (between performance and robustness, for example). Users and administrators do not require knowledge of the code, but need to know which static divisions are present and the capabilities of each division. The basic elements of this workflow are: Module: Modules are static divisions in the program that could form a separate runtime entity. Modules, shown in <ref type="figure" target="#fig_0">Figure 1a</ref>, are identified by the programmer. From the programmer's perspective, a module is a collection of functions that are closely coupled, likely share data, and interact with other modules through inter-modular function calls; they are akin to classes in object-oriented languages or servers in microkernel-based systems. Fractured Mini-process: An FMP is a set of static modules that form a dynamic runtime entity, and corresponds to the notion of an OS-level process. <ref type="figure" target="#fig_0">Figures 1b and 1c</ref> show two different ways of composing modules into FMPs. Calls within an FMP act like procedure calls; calls between FMPs are converted into RPCs. FMP-Environment: An FMP-Environment (FMP-E) is the runtime environment of an FMP and is the key to applying process-level tools and specializations to targeted portions of an application. The FMP-E includes all aspects of a process-level environment, such as resource limits, resource restrictions based on user IDs, and dynamic linker behavior (i.e., LD PRELOAD in UNIX). An FMP-E can even be a transparent emulator for executable binaries, such as tools built using Valgrind <ref type="bibr" target="#b41">[45]</ref> or Pin <ref type="bibr" target="#b33">[37]</ref>. Providing different environments is a key feature of traditional systems, since it allows generalized tools and strategies to be applied to each process; FMPEs extend this notion for modules (or groups of modules) and thus are critical in Fracture. <ref type="figure" target="#fig_0">Figure 1b</ref> illustrates each FMP with a different FMP-E; in <ref type="figure" target="#fig_0">Figure 1c</ref>, the entire program is run with the same FMP-E. Fracturing: A fracturing describes how modules are composed into FMPs, and the FMP-Environment for each FMP. Hence, it specifies the isolation boundaries used at runtime (e.g., a single monolithic process without any boundaries, or as a group of processes) as well as how each FMP is specialized (e.g., one FMP could be targeted with special debugging tools). <ref type="figure" target="#fig_0">Figure 1b</ref> and 1c present two different fracturings of an application. Execution Control: In addition to partitioning modules, three execution control actions can be performed on FMPs: restarting, replicating, and sampling. Modules have execution control capabilities corresponding to actions; an action can be imposed on an FMP only if all its modules are labeled with the associated capability. Modules with no special capabilities can be only isolated. Runtime Configuration: A runtime configuration, consisting of a fracturing and the execution control on different FMPs, is specified for each run of the application.</p><p>The rest of the paper explains Fracture with respect to fault tolerance and testing strategies. Different runtime configurations can be used by the system administrator, the developer, or end user, to achieve a variety of outcomes. The flexibility provided by Fracture in enabling different environments, fracturings, execution controls, and runtime configurations is central to its design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Basic Fracturings</head><p>Fracturings offer a trade-off. Having many FMPs results in many inter-FMP procedure calls, and hence can be inefficient. However, very few FMPs can be too coarsegrained, and hence ineffective. We now explain some likely fracturings and their utility. Monolithic Process: Running all modules together in a single FMP <ref type="figure" target="#fig_0">(Figure 1c)</ref> is similar to the classic approach of running an application as a single process. This fracturing has no overhead (other than from modularization source code changes), but it does not permit fine-grained reliability mechanisms. It should be used if no finegrained mechanism is needed or performance is critical. Micro-isolation: Isolating each module into an individual FMP <ref type="figure" target="#fig_0">(Figure 1b)</ref> is the most fine-grained fracturing; it is the most flexible but suffers the highest overheads. Single Module Isolation (SMI): This consists of two FMPs <ref type="figure" target="#fig_1">(Figure 2a</ref>), one containing a targeted module, the other with all other modules. The targeted module is thus isolated, and (importantly) can have a different FMP-E. Intelligent Partitioning: SMI can be optimized if more modules can be assigned to the separated FMP <ref type="figure" target="#fig_1">(Fig- ure 2b</ref>). An example is a small set of "important" modules needing isolation from a buggy module; all other modules can then be intelligently assigned to either FMP, reducing inter-FMP calls. Fracture includes a mechanism to automatically realize an intelligent partitioning. Duplicate Modules: Overheads can sometimes be reduced by duplicating some modules across FMPs, as shown in <ref type="figure" target="#fig_1">Figure 2c</ref>. The functions of the duplicated modules act as if they belong to all modules. Determining whether a module is duplicable is the responsibility of the programmer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Runtime Configurations</head><p>Basic fracturing simply allocates modules to FMPs. Runtime configurations dictate how Fracture is used, by specifying if FMPs are only partitioned, or if they are also restarted, replicated, and/or sampled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.1">Partition-only</head><p>Adding no extra execution control actions to the basic fracturing results in a partition-only runtime configuration, as shown in <ref type="figure" target="#fig_1">Figure 2</ref>. This configuration facilitates isolation between modules, and the ability to associate an FMP-E with only a subset of modules. An example usage is isolating a suspected buggy module from the rest of an application; this provides increased fail-fast behavior, due to the detection of any faulty access by the module. Resource isolation is also useful for debugging; for example, generic memory-leak-finding tools need a logically isolated address space.</p><p>Another usage arises when FMP-Es can be designed to tolerate faults (but have high overhead), or cause unsafe behavior that should not be imposed on the rest of the application (such as failure-oblivious computing <ref type="bibr" target="#b39">[43]</ref> or reactive immunity <ref type="bibr" target="#b43">[47]</ref>). Partitioning allows such FMP-Es to be applied selectively upon suspicious modules. Yet another usage concerns high-overhead FMP-Es that facilitate transparent bug testing (such as Memcheck <ref type="bibr" target="#b41">[45]</ref> for memory leak detection). These cannot typically be used in actual deployment due to high overheads, but might find the divergent workloads in the field helpful in detecting bugs. With partitioning, the FMP-E can be applied to only one module in each deployment, thus reducing overhead, while gaining the insights such measurement "in the wild" provide.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.2">Restarting FMPs</head><p>Capable FMPs can be configured to restart if they crash. Doing so achieves the usual benefits of process-level restarts, resetting the process environment and any allocated OS resources (including memory). Any FMP that communicates with a restarting FMP only perceives delays. Moreover, the FMP-E can be changed with each restart. Thus, FMP restart facilitates fine-grained versions of fault tolerance mechanisms based on restart or retry, much like microreboots <ref type="bibr" target="#b9">[13]</ref>. This can be useful when FMP restarts might be quicker, or when, for GUI-based applications, transparent full restarts are not readily achievable. Other uses include FMP rejuvenation <ref type="bibr" target="#b28">[32]</ref>, and fault tolerance with special FMP-Es <ref type="bibr" target="#b38">[42]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.3">Replicating FMPs</head><p>Some FMPs can be replicated, as shown in <ref type="figure">Figure 3a</ref>, while appearing non-replicated to the rest of the application. This allows each replica to run different code atop different FMP-Es. When replicas crash, hang, or return different values, the configuration will specify a handling policy, such as terminating the application, using the results of a single trusted replica, or using majority voting. Thus, FMP replication facilitates N-versioned fault tolerance <ref type="bibr" target="#b3">[7]</ref> for parts of an application, even if the rest of the application cannot be replicated transparently or efficiently. Similarly, when software patches themselves can be a source of bugs <ref type="bibr" target="#b51">[55]</ref>, FMP replication allows a patch to be tested with real workloads in deployment <ref type="bibr" target="#b11">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.4">Sampling FMPs</head><p>For FMPs composed of all samplable modules, function calls to the FMP can be multiplexed among replicas with a specified ratio, as shown in <ref type="figure">Figure 3b</ref>. For all previously described use-cases applying a special FMP-E to one FMP, sampling can reduce overhead by multiplexing between two replicas, only one running atop the special (and perhaps non-performant) FMP-E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Modularization Semantics</head><p>In this section, we explain the semantics of how programmers transform their code so that it can be fractured.</p><p>Our goal is to enable powerful fracturings to be realized without a great deal of programming effort.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Modules</head><p>Modules are specified in terms of functions: a set of functions forms a module. All functions need not be associated with specific modules; functions that are not will behave as if there are multiple copies, one per module, like a typical library function linked into separate processes.</p><p>Since modules are units of isolation, Fracture does not allow arbitrary access of data or resources, such as global variables, between modules. Doing so does not obstruct logical data sharing; instead, to access data in a different module, one must do so through a function call. For example, if two hash tables contain pointers to the same data, Fracture requires either both hash tables (and the data) to belong to a single module, or the data to be accessed via accessor functions.</p><p>In inter-modular function calls, Fracture replaces the usual pointer parameter semantics with a similar, but not equivalent, on-demand copy-by-value-result semantic. This new approach is required because, without a global address space, pointers in inter-modular calls do not work; allowing only pass-by-value makes module boundaries expensive and modularization challenging. At runtime, if modules are isolated into different FMPs, the new semantic passes a copy of the pointed-to object to the callee; within the same FMP, normal semantics apply and the pointer is simply passed. Although the semantic reduces modularization overhead, it requires marshalling of data referred to by pointer parameters; thus annotation is needed for some complex types.</p><p>Similar to pointer parameters, the semantics for heapallocated data is also extended in Fracture. When data is allocated in a module, and a reference is returned to a calling module, the data is automatically re-allocated to the calling module (if the modules are isolated). Thus, any references to the data still in the called module will be invalid. The same principle is applied on the return path as needed.</p><p>As with any modular system, there is the question of how the application should be split into modules and the exact boundaries. For existing programs, Fracture enables this transformation to be incremental, first splitting off only key pieces of code, and more only as need be.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Module Capabilities</head><p>Semantics for module capabilities are designed so that any effects are transparent to other modules, while still being useful. Modules can be labeled with three control capabilities: restartability, replicability, and samplability. They can also be labeled with duplicability, useful in fracturings to optimize performance. It is the programmer's responsibility to understand the code within a module well enough to determine whether it has any (or all) of these capabilities. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Restartable</head><p>Restartable modules can be aborted at any point in time, and then restarted. All OS and data resources associated with the module will be reset, and a module initialization handler will be run at restart. If a thread of control had called into the module during the abort (but not exited), after restart, its execution will be resumed from the point of entry into the module. This approach simplifies understanding of restart behavior, but introduces challenges for non-idempotent modules, which may need to be restructured to be restartable.</p><p>A re-executed thread must make the same sequence of inter-modular calls as it did before the abort, until the point of crash. In reality, such calls (if happening across FMPs) are only simulated during re-execution: the framework returns the same values returned before the abort. Thus, for example, if a file append is called indirectly via a non-restartable module, it will not be performed multiple times. No context of the call (other than the return value) is simulated; thus, a sleep(seconds) external call might return immediately during re-execution. Finally, the presence of recursive inter-modular calls does not change restart semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Replicable</head><p>In replicated modules, multiple replicas can be simultaneously active at runtime, each with its own instances of data and OS resources. Parallel threads of control entering the module are mirrored in all replicas. All mirrored instances of a thread (across replicas), are required to make the same sequence of outgoing inter-modular calls, and return the same values for incoming calls. Other than this, mirrored instances can take different execution paths in each replica. Outgoing inter-modular calls are collated across the instances, and performed only once; returns are equivalently dispersed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Samplable</head><p>In samplable modules, multiple replicas can be active at runtime, but with each thread executing within only one replica at any point in time; data modifications are local to its current replica. A thread will remain in the same replica during a call, even with additional inter-modular or recursive calls; when a thread fully exits the module, its next entry into the module may use a different replica.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.4">Duplicable</head><p>In duplicable modules, functions belonging to the module can be simultaneously active in all FMPs. While this is similar to replication and sampling, thread entries into FMPs are not constrained by any duplicated modules. Instead, each thread enters different FMPs based solely upon other specifications in the fracturing, and just uses the duplicated functions in any FMP it enters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Source Code Annotations</head><p>A mild amount of source-code annotation is required to enable Fracture to operate correctly. Listing 1 highlights the different annotations, using a hypothetical FileCache module. The programmer has decided that FileCache can be replicated or restarted. The function declarations within the module construct identify the entry functions of the module. The char * parameters, representing strings, can be automatically marshalled without any annotations. The getData and put functions have void * parameters or return types that cannot be automatically marshalled, and require annotating some parameters as their length. The module also has a initialization handler, that is called each time it is restarted. Although the standard struct stat can be automatically marshalled, this example illustrates a manual marshaller that marshalls a given stat by issuing calls to a Marshaller object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation</head><p>With annotated source code, the framework uses a simple source-to-source compiler to convert the annotations into calls for a runtime engine. The runtime engine takes a configuration as input, and runs the application according to the configuration. A subsystem helps in choosing optimal configurations for each workload.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Compilation Unit</head><p>The source-to-source compilation unit examines the annotated source code, identifying module declarations and pseudo pointer capable types. At each relevant function definition, the compilation unit adds calls to the run-time engine described later, which might transfer control to another FMP if necessary. Marshalling code is generated for pseudo-pointer parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Runtime Configuration</head><p>The runtime configuration specifies the fracturing, the execution control for each FMP in the fracturing, and parameters associated with the execution control. For FMPs with no special execution control, the only parameter is the FMP-E. The FMP-E can be any program that, taking the application's binary as a command line argument, executes the application in a modified environment, without affecting the application's inter-modular communication. For restartable FMPs, the parameter is a list of FMP-Es that should be used each time the FMP is restarted; restarts are performed after crashes. For both replicated and sampled FMPs, the FMP-E for each replica is specified. Fracture also requires, for sampling, the ratio with which function calls are multiplexed between replicas, and for replication, the replica to be trusted if there is mismatch in behavior. Our prototype can be easily extended; we leave this for future work.</p><p>Listing 2 is an example configuration, and uses numbers for denoting modules. In the listing, Modules 1, 2, and 3 form a single FMP using nice (to change scheduling priority) as the FMP-E. Modules 4 and 5 form an FMP that is simply restarted on the first crash. If restarted again, the FMP is run atop safe runtime, a userimplemented script. Modules 6 and 7 are duplicated across all FMPs. Modules 8 and 9 form FMP replicas sampled in a 10:1 ratio, one replica run atop Valgrind.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Runtime Engine</head><p>Our prototype runtime engine maps each FMP in the configuration to a set of Linux processes, run atop the given FMP-Es. Restartable FMPs, and FMPs without special control, map to one process each. For restarts, a new process is created after each crash. Replicable and samplable FMPs map to one process per replica.</p><p>For inter-FMP function calls, the prototype uses message passing by shared memory concurrent queues. Each logical thread is mapped to one real thread per FMP process. Execution control is implemented by adding extra logic to the queue management. malloc()-like calls are wrapped for implementing heap-allocation semantics.</p><p>For FMP restarts, queue messages are logged in shared memory by reusing the queue's buffers. After a crash, on a per-thread basis corresponding to the semantic of restartable modules, the log is replayed or checked. For FMP replication and sampling, according to their semantics, the queue messages are distributed, mirrored, or collated. For FMP replication, if replicas behave differently, the current prototype trusts one designated replica, and kills the others. For sampling, at each complete entry of a thread into the FMP, the replica the thread is scheduled in is decided based on the sampling ratio.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Intelligent Boundary Subsystem (IBS)</head><p>Typically, for a goal such as isolating a buggy module from non-restartable modules, multiple fracturings can be used, but with differing overheads. Fracture provides assistance in finding a fracturing with low overhead via clever partitioning. To achieve this end, the intelligent boundary subsystem (IBS) records the interaction between each pair of modules at runtime. It then represents the interaction as a node-edge graph, and, given a goal, uses the s-t mincut algorithm <ref type="bibr" target="#b15">[19]</ref> to predict optimal fracturings. IBS also exports this graph directly, enabling further manual optimization as needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Modularization Guidelines</head><p>Two aspects of Fracture greatly affect its programmability and utility. The first is incremental modularization, which enables a programmer to evolve pieces of a monolithic application into well-defined modules; modules are central to all of the features Fracture enables. The second is capability labeling, which informs the runtime system of the properties of a given module, such as whether it is restartable, replicable, or samplable; with such knowledge, Fracture can then realize numerous interesting, novel, and useful configurations.</p><p>After numerous experiences, we have found that the following workflow is useful in transforming existing applications into modularized form, and then labeling capabilities per module. Due to space limitations, we concentrate only upon key aspects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Splitting Programs into Modules</head><p>The first step in using Fracture is to (partially) split the application of interest. Here we present guidelines we have developed from our experiences. Partition global data structures. Shared data structures should be identified. The easiest partitioning strategy groups all code that accesses particular data structures into the same module; if this approach is not sufficiently fine-grained, accessor and update functions should be created, and requisite code rewritten to use said functions instead of directly accessing the shared data. Partition OS state. Similarly, OS state should be carefully partitioned, by grouping OS resource access into a single module and perhaps adding accessor functions. One example is a file descriptor; access to the descriptor should likely be localized within a single module. Identify heap-allocated data. Identify places where a called module stores a pointer (in local state) to data passed in as a parameter, or when it both returns allocated data and stores a pointer to it in local state. After identifying such places, the called function should be changed to make a separate copy of the data in local state. Handle external libraries and state. Some applications have state specific to external libraries, and depend on the entire application being externally visible as a single process. Hence, each library the application uses must be analyzed; if the library depends on a single processidentity or address-space, all code and state relating to the library should be moved to a single module.</p><p>Handle state initialization. The programmer should find all initialization calls to data structures and other resources and move them to module initialization handlers. Annotate complex parameters. The programmer should examine the pointer-parameters passed between functions and provide annotations if the data types are complex. For example, consider a char * parameter on an inter-FMP call; without annotation, Fracture assumes that this parameter represents a string and copies all bytes until reaching the end-of-string delimiter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Labeling Modules with Capabilities</head><p>After modularization is complete, the programmer must label each module with its relevant capabilities. Doing so requires understanding what the module does, since mislabeling can lead to incorrect program behavior for certain deployment scenarios. Thus labeling is a critical aspect in the usage of Fracture. We now identify the steps for labeling (or not labeling) modules. Identify stateless, simple modules. If a module does not possess local state, does not relate to external libraries, and does not perform any explicit system calls, the module can be labeled with all capabilities. In the future, we believe this could be automated. Visualize modules as (idempotent) micro-servers. Similar to advice in <ref type="bibr" target="#b9">[13]</ref>, we imagine each module as idempotent micro-servers. We restructure modules with state such that replaying requests is acceptable. If this is not straight-forward, then the module should not be labeled restartable or replicable, but can be samplable. Determine call-chain determinism. The programmer should find if all inter-modular calls performed by the module, between the arrival of each request and the corresponding reply, are deterministic. Modules cannot be labeled replicable or restartable if they are not deterministic. Non-determinism can occur if the module has local state, issues system calls, or relates to complicated external libraries. Modules that do not perform any intermodular calls and only reply to the given request can be easily identified as restartable; these modules can be identified using call-graph analysis. Filter infinite loops. The programmer should identify modules that never return from an inter-modular call, and should not mark such modules restartable. Filter inter-modular synchronization. Threads may synchronize through function calls to other modules; the programmer should identify such modules and label them non-restartable. For example, consider the situation where threads in module A, to protect a critical section, call module B to lock/unlocking a mutex (the mutex exists in B). During replay (after restart), the calls to B will not act as real synchronization calls; thus, the critical region will be compromised. Hence, it is necessary to identify modules such as A and make them non-restartable.  Filter local-state synchronization and thread creation.</p><p>The programmer should identify modules that use local state to synchronize threads, or that have benign data races. These modules should be labeled restartable or replicable only if the programmer is confident that these modules do not exhibit externally visible nondeterminism. Modules that create threads cannot have any of the capabilities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>We evaluate the Fracture framework to answer three questions: How complex is it to modularize applications? How much performance penalty does Fracturing induce? How can Fracture be useful in the real world? We evaluate four applications. The applications were chosen to stress different aspects of modularization, such as code size, server versus desktop, and the threading model. We chose applications written in C that are widely used and a manageable size.</p><p>Null-httpd <ref type="bibr" target="#b1">[3]</ref> (nhttpd) is a multi-threaded, CGIcapable, small (around 2000 lines of code) web server. NTFS-3g <ref type="bibr" target="#b2">[6]</ref> is a widely used filesystem implementation on FUSE <ref type="bibr" target="#b0">[1]</ref>; NTFS-3g is single threaded and has around 30,000 lines of code. SSHFS <ref type="bibr">[5]</ref> is a FUSE-based file system for remote files; SSHFS is multi-threaded and implements an in-memory cache, but has only around 1500 lines of code. Pidgin <ref type="bibr">[4]</ref> is a desktop chat client supporting many protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Modularization Complexity</head><p>We now assess the difficulty of splitting and labeling each program; we do so to address the question of how difficult it is to use Fracture in existing (and sometimes complex) applications. Although this characterization is challenging (e.g., in our experience, lines of code changed does not reflect the amount of programmer effort), we believe it is an important part of our evaluation. <ref type="table">Table 1</ref> shows the number of modules split in each application, and the number labeled with each capabil-ity. Most modules supported all capabilities. <ref type="table">Table 1</ref> also shows the distribution of the number of functions assigned to each module. The distribution differs between applications, based on the assumed purpose of each modularization explained in subsequent sections. <ref type="table" target="#tab_4">Table 2</ref> shows a summary of the programming overhead related to each step in Section 5, for each application. While splitting modules, all steps were easy or straight-forward, except identifying heap-allocated data; since an actual application developer needs to be knowledgeable about heap-allocations to manage memory, we believe identification will be easy for such a developer. During modularization, we made three trivial changes across all applications to improve fractured performance; they are detailed subsequently. While labeling modules, we found most modules to be simple and stateless: all the fully capable modules in <ref type="table">Table 1</ref> correspond to the stateless modules in <ref type="table" target="#tab_4">Table 2</ref>. Determining call-chain determinism for the complex modules was not straight-forward. However, Fracture's design offered an easy alternative: even if non-deterministic modules were marked restartable, the worst consequence would be failure to restart a crashed FMP, leading to a full-application restart (similar to when not using Fracture). Hence, instead of verifying determinism, we optimistically chose to label the modules restartable (but not replicable).</p><p>Overall, the effort required seems substantially less than rewriting the entire program, mostly because good software already has logical divisions whose capabilities programmers inherently understand. In particular, the capabilities of external libraries are readily understandable, given the purpose and interface of the libraries (e.g., an encryption library is both restartable and replicable). However, the effort does vary with applications, and might be large if the software itself is less structured.</p><p>We next present the details for each application. While we found the modularization process mostly straightforward (though not trivial) in practice, it is possible that modularization might be wrong, exposing failures when the application is run as multiple mini-processes. To further evaluate programmer overhead, we evaluate the correctness of our modularization by systematic verification (the modularized code was verified previously only with trivial testruns); results are discussed in Section 6.1.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.1">Nhttpd</head><p>Our goal for modularizing Nhttpd was to find the most fine-grained divisions possible. We attempted to place each C function into its own module. The 28 functions in Nhttpd were placed into 27 modules; in only one case could two functions not be easily separated.</p><p>Our modularization required changing the size of two parameters to improve performance. First, the size of the scratchpad variable was reduced, since it was being passed across modules and thus decreased performance. Second, the size of a buffer passed to send() was increased, so as to reduce the number of calls to send() and improve performance.</p><p>One complex module (having state) was not idempotent: a dedicated module for OS resources with external side effects. Another module waited for incoming connections and spawns threads, and hence could not be labeled with any capabilities. The remaining two complex modules were labeled restartable and samplable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.2">NTFS-3g</head><p>Since NTFS-3g has a significant code base, our goal was only to separate some chosen functions from the remainder (i.e., from the main module). Many of the functions (i.e., 242) were placed in this one module. Modularizing NTFS-3g was mostly easy; we describe here two particularly interesting experiences.</p><p>First, the FUSE library supplies a function pointer to an NTFS-3g handler (read-directory) which invokes the supplied function with some data (directory entries). With modularization, the function must be invoked in the FMP containing the main routine, since FUSE might not expect the invocation from a different process. Hence, we wrapped the invocation of the function (by the handler), and assigned the wrapper to the main module.</p><p>Second, NTFS-3g operates on complicated NTFS filesystem data structures. We changed one structure for performance: the volume-meta-information structure contained a large byte array with constant string-encoding information. Since the structure was being passed frequently between modules, we removed the byte array from the structure and instead keep the information in a dummy local variable in each module where it is used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.3">SSHFS</head><p>Our goal with SSHFS was to modularize its source code based on high-level logical divisions in its functionality. Specifically, SSHFS contains functions for sending requests, receiving replies, and maintaining a connection to the SSH server; functions for caching; functions for each of the FUSE filesystem operations; and, functions to initialize and register SSHFS with FUSE. Thus, we modularized SSHFS into 20 different modules.</p><p>Three modules in SSHFS had local state. Both the fuse funcs and the ssh connection module deal with OS resources and thus have no capabilities. The cache module has local state and synchronizes via a local mutex; it can behave differently if restarted or replicated. Nevertheless, we labeled it restartable, since the benefits outweigh the occasional consequence of failing FMP restarts, as previously explained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.4">Pidgin</head><p>Our last application, Pidgin, is event-based, extensively uses the GTK library, and contains an extensible library  of IM protocols and plugins. Our agenda in modularizing Pidgin was to place code corresponding to five patches into separate modules. These patches fix four bugs which we will tolerate with Fracture in Section 6.3. To make the modularization more representative of typical circumstances, we formed 23 small modules. Every module other than the very large main module was easily identified as being fully capable. The only complexity we encountered was marshalling annotations: since Pidgin extensively uses data structures from the glib library, manual marshallers were needed.</p><formula xml:id="formula_0">Nhttpd Ntfs-3g SSHFS Pidgin Splitting Global data structures 3,L - 2,L - Global structure optimizations 2 1 - - OS state L L L - Heap allocation - 0,H 4,H 0,H External libraries, state 1,L 1,L 1,L - State initialization 1,L 1,L 1,L -</formula><formula xml:id="formula_1">Idempotent micro-servers -1,L 0,- -1,L 0,- Call-chain determinism H - H - Infinite loops - - - - Inter-module sync - - - - Thread create, local sync -1 - - -</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.5">Verification</head><p>To verify our modularization, we used standard testsuites for each application. Since Nhttpd does not provide an inbuilt test-suite, we used http-test-suite <ref type="bibr" target="#b8">[12]</ref>. For SSHFS and NTFS-3g, we used the POSIX Test Suite <ref type="bibr" target="#b46">[50]</ref> associated with NTFS-3g. We used the included libpurple test suite for Pidgin. In Nhttpd and Pidgin, since the test suite does not exercise all modules, we wrote additional tests. The original version of Nhttpd fails some of the supplied tests; we modified the test suite to match the original version of Nhttpd.</p><p>We first verify whether the application works correctly when ran with each module assigned to a separate FMP (micro-isolation). As expected, all applications passed all tests atop this fully fractured configuration. To verify restartable labels, we used micro-isolation with all restartable modules configured to restart on a crash. We then crashed each restartable FMP multiple times during execution. Similarly, for verifying replication and sampling, we configured capable modules to be replicated and sampled (1:1 ratio), respectively. For verifying duplication, we changed the micro-isolation fracturing to with sgets, and little with sock init. Seven modules (eg:dir list) that are not executed in this workload are omitted. Shaded regions are module clusters used in intelligent fracturings; for isolating a grey module, the containing innermost cluster is placed in an FMP; for white modules, SMI is chosen. The inset shows the manually optimized partition for send file: two FMPs, each a shaded region (duplicated modules overlap both regions).</p><p>duplicate all duplicable modules across the other FMPs.</p><p>In all cases, we found the applications to pass all tests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Performance</head><p>Fracture enables run-time configurations that fall on a spectrum; on one side are configurations that provide little isolation and low overhead; the other side has finegrained isolation but potentially higher overhead. Depending on the performance sensitivity of the application and the anticipated deployment scenarios, different fracturings may be desired. To illustrate the range of performance overheads, we begin by investigating the two extreme points on the spectrum: monolithic (all modules in a single FMP, lowest isolation) and micro-isolation (all modules separated from each other for maximum isolation). We then explore the configurations in the middle of the spectrum: single module isolation (SMI: one module is isolated from all others), and intelligent partitioning (one module may be grouped with others). Our evaluation workloads are as follows. For nhttpd, we use two workloads. nhttpd-Throughput consists of five threads requesting files of sizes 1KB, 2KB . . . 512KB with uniform distribution, and is similar to previous work <ref type="bibr" target="#b38">[42]</ref>. nhttpd-Latency consists of a single thread with repeated requests to the same file; this is designed to stress overheads. For NTFS-3g and SSHFS, we use Postmark <ref type="bibr" target="#b26">[30]</ref>. Pidgin uses a workload that repeatedly logs-in and sends 20 messages; the number of GUI actions (return key presses or mouse clicks) per second, guips, is measured. Experimental machines had 1 GB of RAM, a unicore 2.2 GHz processor, and Linux 2.6.22.   To begin, we verify that Fracture can be configured to impose negligible overhead on applications. We first compare the performance of each original application to the version we modified by hand. As expected, the measured overhead (not shown) is not statistically significant, since we did not aggressively change the internal logic of individual functions. We next evaluate the performance of the applications when run as a monolithic process with Fracture. Again, the overhead is insignificant (not shown). Thus, applications can be modularized and run atop Fracture without worrying about performance, even if no immediate use-cases are known.</p><p>We next investigate the other extreme: micro-isolation of each module of the application. <ref type="figure" target="#fig_6">Figure 4</ref> shows the performance of micro-isolation (with a dashed line) for each of the five workloads. For some workloads, the performance overhead of even this most extreme partitioning is tolerable; <ref type="figure" target="#fig_6">Figure 4a</ref> and 4c show that the penalty is less than 3% for nhttpd-Throughput and less than 20% for SSHFS. Even the apparently high overhead of 50% for Pidgin is not observable to a user. Thus, for these workloads, micro-isolation for deployments could improve reliability with tolerable performance.</p><p>For performance sensitive workloads (i.e., nhttpdLatency and NTFS-3g shown in <ref type="figure" target="#fig_6">Figures 4b and 4d)</ref>, micro-isolation is not viable. For these workloads, we consider more targeted partitionings, beginning with SMI. As shown, for nhttpd-Latency and NTFS-3g, SMI performance is fine for some modules (e.g., mst pread in NTFS-3g) but not for others (e.g., map pairs build).</p><p>Specifically, SMI is not appropriate for modules that interact heavily with others either through many intermodular calls or with large parameters during calls. To explain this effect, inter-module interactions are shown in <ref type="figure" target="#fig_4">Figure 5</ref> for nhttpd-Latency. For example, the node for send file has thick edges with many other nodes, representing a high rate of interaction. Hence, isolating the send file module incurs a high overhead.</p><p>To investigate whether the problematic modules can be isolated from others using intelligent boundaries, we trained the intelligent boundary subsystem (IBS) on nhttpd-Latency and NTFS-3g. IBS reports the most appropriate grouping for each restartable module; for example, as shown in <ref type="figure" target="#fig_4">Figure 5</ref>, send file should be placed with ten other modules (the gray bubble).</p><p>As shown in <ref type="figure" target="#fig_6">Figure 4a</ref> and 4c, intelligent boundaries do improve performance for a few modules. We also manually experimented with fracturings using duplicate modules in nhttpd-Latency (inset in <ref type="figure" target="#fig_4">Figure 5</ref>), and found that they can further improve performance in some cases. Summary: The Fracture environment does not impose noticeable overhead if all modules are placed in the same FMP. For the most flexibility and isolation of modules, one might wish to place each module into its own FMP, but this cannot always be done with acceptable performance. Thus, care must be taken to understand application performance when allocating modules to FMPs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Usefulness</head><p>To demonstrate the usefulness of Fracture, we focus on Pidgin; in particular, we demonstrate that Fracture can be used to find or tolerate real-world bugs that are hard to capture in normal testing. These bugs are handled by configuring FMP-Es with special functionality, by restarting individual FMPs, by sampling FMPs to reduce performance overhead, and by replicating FMPs to detect differences. In some cases, we repeat the run-time configurations on the other applications (Null-httpd, NTFS3g, and SSHFS) to show their generality.</p><p>We focus on four bugs that cause Pidgin to either crash or hang: two memory leaks and two buffer overflows. The four Pidgin bugs have been fixed using code patches. When dividing Pidgin into 23 modules, we ensured that the code patches corresponded to specific modules: Jabber, IRC, SILC, and ICQ (all IM protocols), and UTF8 (a UTF-8 string function causing both overflows). While this one-to-one correspondence is optimistic, the approaches described below could still be applied across multiple modules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">Specialized Environments with FMP-Es</head><p>To illustrate the benefits of specialized environments (FMP-Es) for different modules within an application, we show how Fracture repairs the two memory overflow bugs in Pidgin. When the unmodified version of Pidgin is run with certain inputs, a buffer overflow bug crashes the application, as shown in <ref type="figure" target="#fig_7">Figure 6a</ref>. It is well known that buffer overflow attacks can be prevented by padding memory allocations; without Fracture, this padding can be done for the entire application by specializing the process environment using the LD PRELOAD mechanism. <ref type="figure" target="#fig_7">Figure 6b</ref> shows that this environment tolerates the overflows, but unfortunately instills a 10% overhead.</p><p>Fracture enables special FMP-Es (i.e., zero-padding LD PRELOAD) to be applied to a subset of modules. In this case, Fracture can isolate the buggy UTF8 module from the others and apply the special FMP-E to that module alone. The resulting timeline is shown in <ref type="figure" target="#fig_7">Figure 6c</ref>: Pidgin runs without crashes at only 0.25% overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.2">FMP Restarts</head><p>To explore the benefits of restarting individual FMPs, we apply Fracture to fix the two memory leaks in Pidgin; restarting individual FMPs is especially useful when restarting the entire application would be visible to the user, as in Pidgin. When a bug causing a memory leak is triggered in the unmodified version of Pidgin, Pidgin first exhibits a significant slowdown and then crashes. It is known that the initial slowdown can be avoided using a per-process memory limit in the environment; when the memory limit is exceeded, the process crashes and can be restarted. Unfortunately, this restart is user-visible.</p><p>The Fracture environment enables the two leaky modules (Jabber, IRC) to be isolated into separate FMPs with a specialized memory-limit FMP-E. This has two benefits. First, the memory limit can be more precisely specified for these smaller modules, thus avoiding the slowdown. Second, the crash and resulting restarts can be applied to only those two modules; these restarts are transparent to the user. <ref type="figure">(Figure not</ref> shown due to space.)</p><p>To further stress FMP restart capability, we configured each of the other applications (Null-httpd, NTFS3g, and SSHFS) to place each restartable module in its own FMP; we then crashed each isolated FMP at a rate of 5 crashes per second. As desired, each crash was tolerated transparently and each module restarted within 1 ms (not shown); there was no additional overhead compared to the partitioned-only SMI configurations in <ref type="figure" target="#fig_6">Figure 4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.3">Adaptive Fracturing and Modified Restarts</head><p>Fracture enables run-time configurations in which different modules are adaptively placed into different FMPs based on their past behavior. This functionality can be used to identify modules with previously unknown bugs. We demonstrate a simple "adaptive tolerance" strategy in which all modules are initially trusted and are run as a single FMP with the default environment (i.e., with no memory padding). If the FMP crashes, it is subdivided into two smaller groups of modules (with intelligent boundaries provided by the IBS). If the FMP crashes with a single module, then the faulty module has been successfully identified and is restarted with the bugtolerant environment (e.g., with memory padding). <ref type="figure" target="#fig_7">Figure 6d</ref> shows the timeline for memory-overflow input when the buggy module in Pidgin is not known. The first three times that Pidgin crashes, Fracture subdivides the FMPs into two smaller groups; the fourth time, the faulty module is identified and is restarted with the padded-allocation FMP-E which tolerates later faults.</p><p>With this approach, Pidgin incurs negligible overhead, since the more costly FMP-E is never applied to the entire application and highly interacting modules (memcpy and main) are always in the same FMP. However, our current approach leads to multiple user-visible restarts. Straight-forward modifications could reduce this effect; for example, the specialized FMP-E could be applied to FMPs larger than a single module.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.4">Reducing Overhead with Sampling</head><p>The memory leaks in Pidgin occur for rare workloads that appeared only in deployment. One way to discover such memory leaks is to run the entire application with the Memcheck tool during deployment and to send bug reports back to the developers. Unfortunately, Pidgin with Memcheck achieves only 1.4 guips (shown as the dotted line in <ref type="figure" target="#fig_8">Figure 7a</ref>), which is not acceptable.</p><p>To discover bugs using Fracture, different users can run Pidgin such that a random module is isolated with the Memcheck FMP-E. As desired, when the Memcheck FMP-E is applied to the leaking modules (Jabber or IRC), the leaks are easily identified. The light-gray bars in <ref type="figure" target="#fig_8">Figure 7a</ref> show performance when each module is  separated from other modules, and Memcheck is applied on the separated module. We make a few observations. First, main should not be isolated from the other modules with Memcheck; Memcheck imposes too high of an overhead for main. Second, the majority of modules can use Memcheck and be isolated with only a negligible performance impact (less than 5%). However, a few specific modules lead to unacceptable performance with Memcheck (i.e., strcmp, memcpy, getrhash, and strchr).</p><p>The impact of high overhead environments on performance sensitive modules can be reduced using sampling. When sampling is applied to an isolated module (e.g., strcmp), the default environment is applied to the module for some of the invocations, while the modified environment (e.g., Memcheck) is applied other times. <ref type="figure" target="#fig_8">Fig- ure 7a</ref> shows that a 10:1 sampling ratio leads to a worstcase overhead of only 20% for all of the isolated modules in Pidgin (excepting main, which cannot be sampled).</p><p>We have experimented further with sampling for the more performance sensitive server workloads (Nullhttpd, NTFS-3g, and SSHFS). For example, <ref type="figure" target="#fig_8">Figure 7b</ref> shows that applying the Memcheck FMP-E individually to the 25 samplable modules of nhttpd-Throughput incurs significant overhead; this overhead can be reduced in many cases with a 10:1 sampling ratio. In those cases where sampling improves performance but not enough (e.g., send file), a higher ratio should be used; in those cases where sampling cannot be applied (e.g., resources wrapper), the Memcheck FMP-E cannot be used. We found sampling an effective technique for reducing overhead in most cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.5">Validating with Replication</head><p>Software patches that introduce new bugs are a real problem <ref type="bibr" target="#b11">[15,</ref><ref type="bibr" target="#b51">55]</ref>. Performance patches can sometimes be validated by running the patched and unpatched application and comparing the results; but, this approach is not possible in Pidgin due to the GUI.</p><p>If a patch can be placed in a set of restartable modules such that interactions with other modules are unchanged, then Fracture can help validate performance patches by replicating the resulting FMPs transparently. To verify this functionality in Pidgin, for each of the four patches, we ran replicated FMPs with one patched and one unpatched version. As expected, when Pidgin is run without bug-inducing inputs, the two FMPs return the same results; as desired, when one of the replicated FMP crashes, the error is logged and the application continues without replication for that FMP. Across all patches, the worst overhead is within 10% (not shown).</p><p>We have also investigated the performance impact of replication on the other applications (Null-httpd, NTFS3g, and SSHFS). <ref type="figure" target="#fig_8">Figure 7a</ref> shows the impact of replicating each of the 32 replicable modules in NTFS-3g. In most cases, the overhead of FMP replication is not significantly greater than that of simple isolation; thus, FMP replication is likely to enable fine-grained N-versioning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Simple restarts, checkpointing, software rejuvenation, and restarts with logging and replay are well known fault tolerance techniques <ref type="bibr" target="#b20">[24,</ref><ref type="bibr" target="#b17">21,</ref><ref type="bibr" target="#b32">36]</ref> for distributed systems. Applying these techniques might be challenging, as some processes are not readily restartable; alternatively, precautions such as logging and replay <ref type="bibr" target="#b17">[21]</ref> might be inefficient. <ref type="bibr">Rx [42]</ref> explores a set of techniques to be applied during the restart process, but is not fine-grained. Fracture enables classic techniques (e.g, process pairs, replicated RPC <ref type="bibr" target="#b20">[24,</ref><ref type="bibr" target="#b12">16]</ref>) to be used on parts of an application. Existing fine-grained techniques include Microreboot <ref type="bibr" target="#b9">[13]</ref> for restarts, and Band-aid Patching <ref type="bibr" target="#b42">[46]</ref> and delta execution <ref type="bibr" target="#b45">[49]</ref> for replication. These do not offer a generic (process-like) abstraction for tools and techniques to be applied to existing C programs, instead focusing on a specific technique. Similarly, tools like Pin <ref type="bibr" target="#b33">[37]</ref> allow partial instrumentation but are not generic. Quarantine <ref type="bibr" target="#b36">[40]</ref> debates fine-grained boundaries conceptually, but does not present a design or implementation.</p><p>Component-based systems and middleware (such as OSGi, COM, EJB) support applications made of multiple components, thus making modularization easier. However, their existence does not help legacy C programs. Mutable Protection Domains <ref type="bibr" target="#b35">[39]</ref> comes close to Fracture by intelligently splitting an application for fault isolation, but uses a specialized operating system. Security research has focused on splitting C applications into multiple protection domains. Examples are OKWS <ref type="bibr" target="#b29">[33]</ref>, privilege-separated OpenSSH <ref type="bibr" target="#b37">[41]</ref>, Privtrans <ref type="bibr" target="#b7">[11]</ref>, and Wedge <ref type="bibr" target="#b6">[10]</ref>. These do not explore restarting or replicating individual parts, instead focusing on aspects like information flow. Also, the final goal (se-curity) makes their desired divisions different from Fracture. For example, they require a strict conceptual assignment of memory objects to "trusted" or "untrusted" code parts, and a strict static division at runtime.</p><p>Research in mobile code offloading <ref type="bibr" target="#b19">[23,</ref><ref type="bibr" target="#b4">8]</ref> looks at optimally partitioning applications, sometimes without any manual effort. Most of these target application-level virtual machines, or existing process-separated applications. Intelligent partitioning in Fracture, derived from classic research like Coign <ref type="bibr" target="#b25">[29]</ref> and intelligent satellites <ref type="bibr" target="#b47">[51]</ref>, is similar. But, none of these (or Coign and intelligent satellites) focus on a generic abstraction for generic code (mobile applications have a "deep architectural unity" <ref type="bibr" target="#b4">[8]</ref>) that enables many tools and techniques.</p><p>The idea of extending the process abstraction has been well-explored. Resource containers <ref type="bibr" target="#b5">[9]</ref> and Exokernel <ref type="bibr" target="#b18">[22]</ref> propose a separate abstraction for resource management; Asbestos <ref type="bibr" target="#b16">[20]</ref> and Ribbons <ref type="bibr" target="#b23">[27]</ref> provide thread-boundary isolation and fine-grained labels within a process or JVM; sandboxing <ref type="bibr" target="#b48">[52,</ref><ref type="bibr" target="#b50">54]</ref> provides multiple fault domains within a single process. Other approaches include capability-based systems <ref type="bibr" target="#b30">[34]</ref>, and single address space operating systems <ref type="bibr" target="#b27">[31]</ref> emphasizing partially-shared address spaces. These do not preserve many properties of the process abstraction, and are hence more difficult to adapt for generic tools and techniques.</p><p>The use of fine-grained isolated domains has been studied extensively. Research in this area includes SFI <ref type="bibr" target="#b48">[52]</ref>, fine-grained memory protection <ref type="bibr" target="#b49">[53,</ref><ref type="bibr" target="#b10">14]</ref>, typesafe operating systems <ref type="bibr" target="#b24">[28,</ref><ref type="bibr" target="#b52">56]</ref>, microkernels <ref type="bibr" target="#b31">[35,</ref><ref type="bibr" target="#b13">17]</ref> and isolated OS extensions <ref type="bibr" target="#b44">[48,</ref><ref type="bibr" target="#b34">38,</ref><ref type="bibr" target="#b10">14]</ref>. Such approaches establish a fixed boundary between parts of a kernel and do not provide generic abstractions for user applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>We believe mini-processes that support process-like restarts, replication, environments, and other features, are needed for modern user software; our case studies reveal that such flexibility and configurability are important. A generalized, fine-grained abstraction facilitates innovative methods to increase the robustness of applications like Pidgin, where equivalent coarse-grained strategies might fail. In the case of servers, mini-processes allow balancing performance and robustness, especially in cases like Null-httpd, where optimal fracturings are completely different for two different workloads. Fracture is our attempt at providing full-featured mini-processes, in a way we believe will be easy to adopt.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Modules, Fracturings, FMPs, and FMP-Es. (a) is a visualization of the application's source code divided into modules. (b) and (c) are two different fracturings, i.e., visualizations of the application at runtime. The fracturing in (b) has maximum runtime isolation and consists of 7 FMPs, each using a different FMP-E. (c) is minimal isolation, with a single FMP and FMP-E.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Basic Fracturings, for isolating module 2 from 1. (a) Single Module Isolation: 2 constitutes an individual FMP. (b) Intelligent Paritioning: 3 and 7 are with 2, reducing FMP interaction. (c) Duplication: 3 and 7 duplicated across FMPs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Module Interaction Graph for nhttpdLatency. Black nodes are non-restartable modules; grey and white are restartable; edge thickness represents module interaction. For example, resources wrapper interacts heavily</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Partitioned Performance. Performance of different configurations normalized to the performance of the unmodularized application is shown. Module names are shown within the bars. Modules with bold names do not possess some capability.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Pidgin: Tolerating Buffer Overflows. (a) Unmodularized. (b) Unmodularized with special environment. (c) UTF8 SMI with special FMP-E. (d) Adaptive fracturing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: FMP Replication and Sampling.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Programming overhead summary. 'L' indi-

cates low programming overhead, such as requiring only an 
overall understanding of the logic, or using automated text re-
placement to address the concern. 'H' indicates high over-
head, requiring in-depth understanding of the source code. '-' 
indicates concerns that are easily dismissed for the applica-
tion. For quantifiable concerns (e.g., the number of global vari-
ables), the quantity is shown. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>SMI + Memcheck FMP-E SMI + Sample 1:10 Memcheck</head><label></label><figDesc></figDesc><table>0 

0.2 

0.4 

0.6 

0.8 

1 

Normalized Performance 

Module Memchecked 

(a) Fixing memory leaks in Pidgin 

Jabber 
IRC 
UTF8 
SILC 
ICQ 
main 
strcmp 
memcpy 

g 
s tr 
h ash 
strchr 
memmove 

get domain 
get resource 
get bare jid 
id get bare jid 
jid is domain 
nodeprep validate 
domain validate 
resourceprep validate 

buddy st get name 
buddy st get show 
buddy st id state 
buddy sh get state 

Unmodularized Pidgin + Memcheck 

Module Memchecked 

(b) Sampling in nhttpd-Throughput 

SMI + Memcheck FMP-E 
SMI + Sample 1:10 Memcheck 

cgi main 
config read 
send file 
dir list 
decode url 

fix slashes 
hex2int 
striprn 
swap char 
strcasestr 

print error 
get mime type 
read post data 
read header 
send header 
send fileheader 
do request 
flush header 
flush buffer 
sgets 
close connection 
server shutdown 
sock init 
htloop 
accept loop 
main func 
resources wrapper 

Module Replicated 

(c) Replication in NTFS-3g 

SMI + Replication 
SMI, no special execution control 

fuse funcs 
disk funcs 
mst pread 
mst pwrite 
cluster read 
cluster write 
device size get 
device get pss 
device get heads 
device get spt 
device get ss 
device set bs 

rl pread 
rl pwrite 
write sb 
map pairs build 
rl truncate 
runlists merge 
readdir 
create 
create device 
create symlink 
check empty dir 
delete 
link 
attr exist 
attr remove 
attr upd map pairs 
res attr vr 
attr record resize 
attr rm 
attr add 
inode add attrlist 
inode free space 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank the anonymous reviewers for their insightful comments, and Idit Keidar (our shepherd) for useful feedback. This material is based upon work supported by the NSF under CNS-1421033, CNS-1319405, and CNS-1218405 as well as donations from EMC, Facebook, Fusion-io, Google, Huawei, Microsoft, NetApp, Samsung, Sony, and VMware. Any opinions, findings, and conclusions, or recommendations expressed herein are those of the authors and do not necessarily reflect the views of the NSF or other institutions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fs In Userspace</surname></persName>
		</author>
		<ptr target="http://fuse.sourceforge.net/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Null-Httpd</surname></persName>
		</author>
		<ptr target="http://www.nulllogic.ca/httpd/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<ptr target="http://www.tuxera.com/community/ntfs-3g-download/" />
		<title level="m">Tuxera ntfs-3g + ntfsprogs</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The n-version approach to fault-tolerant software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Avizienis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">12</biblScope>
			<date type="published" when="1985-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Simplifying cyber foraging for mobile devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Balan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gergle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Satyanarayanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Herbsleb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI &apos;12</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Resource containers: a new facility for resource management in server systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Banga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Mogul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI &apos;99</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Wedge: splitting applications into reduced-privilege compartments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bittau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Marchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Karp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI &apos;08</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Privtrans: automatically partitioning programs for privilege separation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SSYM &apos;04</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Web server test suite</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bykov</surname></persName>
		</author>
		<ptr target="https://github.com/init/http-test-suite" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Microreboot : A technique for cheap recovery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kawamoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Fujiki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI &apos;04</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Fast byte-granularity software fault isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-P</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Peinado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Akritidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Donnelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Black</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;09</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Highly reliable upgrading of components</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Dage</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;99</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Replicated distributed programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">C</forename><surname>Cooper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;85</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">CuriOS: Improving Reliability through Operating System Structure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">M</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Carlyle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Campbell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI &apos;08</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Programming Semantics for Multiprogrammed Computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Dennis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">C V</forename><surname>Horn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">9</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Diestel</surname></persName>
		</author>
		<title level="m">Graph Theory</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Morris. Labels and event processes in the asbestos operating system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Efstathopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Krohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Vandebogart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Frey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ziegler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mazì Eres</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;05</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A survey of rollback-recovery protocols in message-passing systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">N M</forename><surname>Elnozahy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Exokernel: An Operating System Architecture for Application-Level Resource Management</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename><surname>O&amp;apos;toole</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;95</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Cyber Foraging: Bridging Mobile and Cloud Computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Flinn</surname></persName>
		</author>
		<imprint>
			<publisher>Morgan &amp; Claypool</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Why Do Computers Stop and What Can We Do About It?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<idno>TR-85.7</idno>
		<imprint>
			<date type="published" when="1985" />
		</imprint>
	</monogr>
<note type="report_type">Tech</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The nucleus of a multiprogramming system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">B</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A File is Not a File: Understanding the I/O Behavior of Apple Desktop Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Harter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dragga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Vaughn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;11</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Ribbons: a partially shared memory programming model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">J</forename><surname>Hoffman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Metzger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Eugster</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">11</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Sealing os processes to improve dependability and safety</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fahndrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hawblitzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Hodson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Larus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Levi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Steensgaard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tarditi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wobber</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The Coign Automatic Distributed Partitioning System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI &apos;99</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">PostMark: A New File System Benchmark</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Katcher</surname></persName>
		</author>
		<idno>TR-3022</idno>
	</analytic>
	<monogr>
		<title level="j">Network Appliance Inc</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Architectural Support for Single Address Space Operating Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Koldinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chase</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Eggers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS V</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Software rejuvenation: Analysis, module and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kolettis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">D</forename><surname>Fulton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FTCS &apos;95</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Building secure high-performance web services with okws</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Krohn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ATEC &apos;04</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Policy/mechanism separation in Hydra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Corwin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">J</forename><surname>Pollack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Wulf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;75</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">On micro-kernel construction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Liedtke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;95</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Exploring failure transparency and the limits of generic recovery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Lowell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI &apos;00</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Pin: building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-K</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">J</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Hazelwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;05</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Software fault isolation with api integrity and multiprincipal modules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;11</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Mutable protection domains: Adapting system fault isolation for reliability and efficiency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Parmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>West</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<date type="published" when="2012-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Quarantine: Fault tolerance for concurrent servers with datadriven selective isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Pillai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">11</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Preventing privilege escalation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Provos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Friedl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Honeyman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SSYM &apos;03</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Rx: Treating Bugs As Allergies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sundaresan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;05</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Enhancing Server Availability and Security Through Failure-Oblivious Computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dumitran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Leu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>William</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Beebe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI &apos;04</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">The UNIX Time-Sharing System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Ritchie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Thompson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;73</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Using Valgrind to detect undefined value errors with bit-precision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Seward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Nethercote</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX &apos;05</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Band-aid patching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ioannidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotDep &apos;07</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Building a Reactive Immune System for Software Services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Locasto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename><surname>Boyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX &apos;05</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Improving the Reliability of Commodity Operating Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;03</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Efficient online validation with delta execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Posix test suite</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tuxera</surname></persName>
		</author>
		<ptr target="http://www.tuxera.com/community/posix-test-suite" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Intelligent satellites for interactive graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Dam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Stabler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Harrington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGGRAPH Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Efficient Software-Based Fault Isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wahbe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lucco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Graham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;93</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Mondrian memory protection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cates</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Asanovi´casanovi´c</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS X</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Native client: A sandbox for portable, untrusted x86 native code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Yee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sehr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Dardyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ormandy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Okasaka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Narula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Fullagar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SP &apos;09</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">How do fixes become bugs?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pasupathy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bairavasundaram</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE &apos;11</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">SafeDrive: Safe and Recoverable Extensions Using Language-Based Techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Bagrak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ennals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Brewer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI &apos;06</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
