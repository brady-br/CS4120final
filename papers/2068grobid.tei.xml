<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:25+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">libmpk: Software Abstraction for Intel Memory Protection Keys (Intel MPK) libmpk: Software Abstraction for Intel Memory Protection Keys (Intel MPK)</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>July 10-12, 2019</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soyeon</forename><surname>Park</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wen</forename><surname>Xu</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soyeon</forename><surname>Park</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sangho</forename><surname>Lee</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wen</forename><surname>Xu</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hyungon</forename><surname>Moon</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Ulsan National Institute of Science and Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Georgia Institute of Technology; Hyungon Moon</orgName>
								<orgName type="department" key="dep2">Ulsan National Institute of Science and Technology</orgName>
								<orgName type="department" key="dep3">Institute of Technology</orgName>
								<orgName type="institution" key="instit1">Georgia Institute of Technology</orgName>
								<orgName type="institution" key="instit2">Sangho Lee</orgName>
								<orgName type="institution" key="instit3">Microsoft Research</orgName>
								<address>
									<country key="GE">Georgia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Georgia Institute of Technology † Microsoft Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">libmpk: Software Abstraction for Intel Memory Protection Keys (Intel MPK) libmpk: Software Abstraction for Intel Memory Protection Keys (Intel MPK)</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2019 USENIX Annual Technical Conference</title>
						<meeting>the 2019 USENIX Annual Technical Conference <address><addrLine>Renton, WA, USA</addrLine></address>
						</meeting>
						<imprint>
							<date type="published">July 10-12, 2019</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 2019 USENIX Annual Technical Conference is sponsored by USENIX. https://www.usenix.org/conference/atc19/presentation/park-soyeon</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Intel Memory Protection Keys (MPK) is a new hardware primitive to support thread-local permission control on groups of pages without requiring modification of page tables. Unfortunately , its current hardware implementation and software support suffer from security, scalability, and semantic problems: (1) vulnerable to protection-key-use-after-free; (2) providing the limited number of protection keys; and (3) incompatible with mprotect()&apos;s process-based permission model. In this paper, we propose libmpk, a software abstraction for MPK. It virtualizes the hardware protection keys to eliminate the protection-key-use-after-free problem while providing accesses to an unlimited number of virtualized keys. To support legacy applications, it also provides a lazy inter-thread key synchronization. To enhance the security of MPK itself, libmpk restricts unauthorized writes to its metadata. We apply libmpk to three real-world applications: OpenSSL, JavaScript JIT compiler, and Memcached for memory protection and isolation. Our evaluation shows that it introduces negligible performance overhead (&lt;1%) compared with the original , unprotected versions and improves performance by 8.1× compared with the secure equivalents using mprotect(). The source code of libmpk is publicly available and maintained as an open source project.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Maintaining and enforcing memory access permission is an important duty of OSes and CPUs. Traditionally, they have used page tables to specify whether processes have rights to read from, write to, or execute specific memory pages. OSes can change access permission by updating page-table entries (PTEs) and flushing corresponding translation lookaside buffer (TLB) entries to reload them. In addition to page tables, some CPUs, e.g., ARM <ref type="bibr" target="#b4">[5]</ref> and IBM Power <ref type="bibr" target="#b17">[18]</ref>, allow OSes to maintain the permission of a page group together by assigning the same key to the correlated pages and controlling the key's permission. To modify the permission of the page groups, OSes should, on behalf of the process, change the permission of the corresponding registers.</p><p>Recently, Intel deployed a similar key-based permission control, called Intel Memory Protection Keys (Intel MPK) <ref type="bibr" target="#b19">[20]</ref>, that allows a userspace process to change the permission of the page groups. MPK has three key benefits over page-table-based mechanisms: (1) performance, (2) group-wise control, and (3) per-thread view. First, MPK utilizes a protection key rights register (PKRU) to maintain the access rights of individual keys associated with specific pages: read/write, read-only, or no access. Processes only need to execute a non-privileged instruction (WRPKRU) to update PKRU, which takes less than 20 cycles ( §2.3) and requires no TLB flush and context switching. Note that PKRU and page-table permissions cannot override each other, so the effective permission is the intersection of both.</p><p>Second, MPK can change the access rights of up to 16 different page groups at once, where each group consists of pages associated with the same key <ref type="bibr" target="#b0">1</ref> . This group-wise control allows applications to change access rights to page groups according to the types and contexts of data stored in them (e.g., per-session data of a web server).</p><p>Third, MPK allows each thread (i.e., each hyperthread) to have a unique PKRU, realizing per-thread memory view. Accordingly, even if two threads share the same address space, their access rights to the same page can be different.</p><p>Although MPK is a promising primitive in concept, its current hardware implementation as well as standard library and kernel support suffer from three problems: (1) security, (2) scalability, and (3) subtle semantic differences, hindering its broader adoption. First, we found that MPK suffers from the protection-key-use-after-free problem. The Linux kernel provides two system calls, pkey_alloc() and pkey_free(), to allocate and de-allocate protection keys, respectively. During key de-allocation (pkey_free()), however, it does not invalidate pages associated with a de-allocated key, resulting in ambiguity when the de-allocated key is re-allocated and assigned to different pages later.</p><p>Second, MPK fails in scaling because PKRU can manage only up to 16 protection keys because of its hardware limitation. When an application tries to allocate more than 16 protection keys, pkey_alloc() simply fails, implying that the application itself should implement its own mechanism to multiplex these protection keys.</p><p>Third, the semantic of MPK is different from the conventional mprotect(), i.e., thread-view versus processview, which results in potential security and performance problems. For example, the Linux kernel implements an execute-only memory with MPK by disabling read access through PKRU and allowing execution through a page table: mprotect(addr, len, PROT_EXEC). Although this feature is invoked via mprotect(), it only changes the PKRU's permission of the calling thread, meaning that other threads sharing the same address space can still read the execute-only memory. In other words, it is non-trivial to apply MPK securely and efficiently to legacy applications that rely on a process-level memory permission model.</p><p>In this paper, we propose libmpk, a secure, scalable, and semantic-compatible software abstraction to fully utilize MPK in a practical manner. In particular, libmpk implements (1) protection key virtualization to eliminate the protectionkey-use-after-free problem and to support the unrestricted number of memory page groups, (2) lazy inter-thread key synchronization to selectively ensure per-process semantics with MPK, allowing us to substitute mprotect() in an efficient and compatible manner, and (3) metadata integrity to ensure the integrity of the mapping information while minimizing the number of system call invocations. libmpk consists of a userspace library mainly for efficient permission change and a kernel module mainly for synchronization and metadata integrity.</p><p>To show the effectiveness and practicality, we apply libmpk to three real-world applications: OpenSSL library, JavaScript just-in-time (JIT) compiler, and Memcached. First, we modify the OpenSSL library to create secure memory pages for storing cryptographic keys to mitigate information leakage. Second, we modify three JavaScript JIT compilers (i.e., SpiderMonkey, ChakraCore, and v8) to protect the code cache from memory corruption by enforcing the W⊕X security policy. Third, we modify Memcached to secure almost all its data, including the slab and hash table, whose size can be several gigabytes. The evaluation results show that libmpk and its applications have negligible overhead (&lt;1%). Furthermore, libmpk is 1.73-3.78× faster than mprotect() when changing the permission of 1-1,000 pages at the view of a process, and, especially, the throughput of Memcached with libmpk is 8.1× higher than that of Memcached with mprotect().</p><p>We summarize the contributions of this paper as follows:</p><p>• Comprehensive study. We study the design, functionality, and characteristics of Intel MPK in detail. We identify the critical challenges of utilizing MPK in terms of security, scalability, and semantics.</p><p>• Software abstraction. We design and implement libmpk, a software abstraction to fully utilize MPK. The protection key virtualization, metadata protection, and inter-thread key synchronization of libmpk allow appli- cations to effectively overcome the three challenges.</p><p>• Case studies. We apply libmpk to OpenSSL library, JavaScript JIT compiler, and Memcached to show its effectiveness and practicality. libmpk secures them with a few modifications and negligible overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Intel MPK Explained</head><p>In this section, we describe the hardware design of Intel MPK and current kernel and library support. Also, we check the performance characteristics of MPK to show its efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Hardware Primitives</head><p>Intel MPK updates the permission of a group of pages by associating a protection key to the group and changing the access rights of the protection key instead of individual memory pages ( <ref type="figure">Figure 1</ref>).</p><p>Protection key field in page  <ref type="table" target="#tab_2">Table 1</ref>: Overhead of MPK instruction, system calls, and standard library APIs. ref shows the overhead of mprotect() and normal register move instructions for comparison. We averaged 10 runs of microbenchmarks, where each one executes individual instruction, system call, or API 10 million times while measuring the latency with the RDTSCP instruction.</p><p>information to overwrite the PKRU, and the other two registers, ECX and EDX, filled with zeroes. RDPKRU also uses the three registers for its operation: it returns the current PKRU value via the EAX register while overwriting the EDX register with 0.</p><p>The ECX register also should be filled with zeroes to execute RDPKRU correctly. Note that the actual usage of ECX and EDX registers is undocumented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Kernel Integration and Standard APIs</head><p>The Linux kernel has supported MPK since version 4.6, and glibc has supported MPK since version 2.27. They focus on how to manage protection keys and how to assign them to particular PTEs. The Linux kernel provides three new system calls: pkey_mprotect(), pkey_alloc(), and pkey_free(). The kernel also changes the behavior of mprotect() to provide execute-only memory. glibc provides two userspace functions, pkey_get and pkey_set, to retrieve and update the access rights of a given protection key. <ref type="table" target="#tab_2">Table 1</ref> summarizes the APIs. pkey_mprotect(). The pkey_mprotect() system call extends the mprotect() system call to associate a protection key with the PTEs of a specified memory region while changing its page protection flag. Interestingly, pkey_mprotect() does not allow a user thread to reset a protection key to zero, the default protection key value assigned to newly created memory pages such that it should be public to avoid accidental application crashes. We anticipate that resetting a key to zero is prohibited to avoid such potential crashes made by mistakes (i.e., denying access to the key zero). pkey_alloc() and pkey_free(). The Linux kernel provides two other new system calls to allocate and de-allocate memory protection keys: pkey_alloc() and pkey_free(). When a user thread invokes pkey_alloc() with access right, the kernel allocates and returns a protection key with corresponding permission according to a 16-bit bitmap that tracks which protection keys are allocated. When a user thread invokes pkey_free(), the kernel simply marks the freed key as available in the bitmap. The pkey_mprotect() function examines the bitmap afterward to prohibit the use of non-allocated keys.</p><p>Execute-only memory. The Linux kernel supports execute- only memory with MPK. If a user thread invokes mprotect() only with PROT_EXEC, the kernel (1) allocates a new protection key, (2) disables the read and write permission of the key, and (3) assigns the key to the given memory region.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Quantifying Characteristics of Intel MPK</head><p>To evaluate the overhead and benefits of MPK, we measure (1) the overhead of the MPK instructions, (2) the overhead of the MPK system calls, and (3) the overhead of mprotect() for contiguous memory and sparse memory. Environment. Our system consists of two Intel Xeon Gold 5115 CPUs (each CPU has 20 logical cores at 2.4 GHz) and 192GB of memory. Linux kernel version 4.14 configured for MPK is installed to this system. Instruction latency. We measure the latency of RDPKRU and WRPKRU to identify their micro-architectural characteristics. Table 1 summarizes the results. The latency of RDPKRU is similar to that of reading a general register, but the latency of WRPKRU is high. We anticipate that WRPKRU performs serialization (e.g., pipeline flushing) to avoid potential memory access violation resulting from out-of-order execution. To confirm this, we insert various numbers of ADD instructions before (W1) and after (W2) WRPKRU and measure the overall latency ( <ref type="figure" target="#fig_0">Figure 2</ref>). The results show that W2 is always slower than W1, implying that the instructions executed right after WRPKRU fail to benefit from out-of-order execution because of the serialization. System calls. We measure the latency of the four Linux system calls for MPK (  To construct contiguous memory pages, we call mmap() one time with certain memory size. For sparse memory pages, we call mmap() several times with one page size. <ref type="figure" target="#fig_1">Figure 3</ref> shows that the overhead of mprotect() increases in proportion to the number of pages. The number of pages affects how many virtual memory areas (VMAs) <ref type="bibr" target="#b9">[10]</ref> mprotect() needs to look up for permission update. Moreover, the overhead of mprotect() on sparse memory pages is high because multiple mprotect() calls introduce frequent context switchings between kernel and userspace.</p><p>Summary. Intel MPK allows a thread to rapidly change the per-thread access rights to a group of pages associated with the same protection key by updating a thread-local register PKRU which only takes around 20 cycles. Its performance is independent of the number of pages composing a group and their sparseness, unlike mprotect().</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Challenges of Utilizing Intel MPK</head><p>In this section, we explain the challenges of using MPK in terms of security, scalability, and synchronization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Potential Security Problem</head><p>The existing OS support of MPK <ref type="bibr" target="#b2">[3]</ref> suffers from the protection-key-use-after-free problem. In particular, pkey_free() just removes a protection key from a key bitmap and does not update the corresponding PTEs. Regardless of whether a key could already be associated with some pages, the kernel will allocate the key if it is freed by pkey_free().</p><p>If a program obtains a key that is still associated with some memory pages through pkey_alloc(), the new page group will include unintended pages that it is supposed to have. A developer can face this vulnerable situation unconsciously, as current kernel implementation neither handles this automatically nor checks if a free key is still associated with some pages. The developer community also recognized the problem and recommends not to free the protection keys <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b12">13]</ref>. Handling this problem superficially (i.e., wiping protection keys in PTE) without a fundamental design change of memory management in the kernel will introduce huge performance overhead because it requires traversing the page table and</p><p>VMAs to detect entries associated with a freed key to update them and flushing all corresponding TLB entries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Limited Hardware Resources</head><p>Currently, MPK relies on a 32-bit PKRU such that it supports up to 16 keys. Developers are responsible for ensuring that an application never creates more than 16 page groups at the same time. This implies that developers have to examine at runtime the number of active page groups, which are used by both the application itself and the third-party libraries it depends on. Otherwise, the program may fail to properly benefit from MPK. This issue undermines the usability of MPK and discourages developers from utilizing it actively. Using a large register (e.g., 1024 bits) does not scale because MPK needs additional storage to associate keys with pages. For example, to support 512 protection keys, nine bits are necessary for each PTE, requiring enlarged page tables, shrunken address bits, or separate storage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Semantic Differences</head><p>To change the permission of any page group, MPK modifies the value of the PKRU. However, the value is effective only in a single thread because PKRU is thread-local intrinsically as a register. As a result, different threads in a process can have different permissions for the same page group. This thread-local inherence helps to improve security for the applications that require isolation on memory access among different threads, but hinders MPK from optimizing and improving mprotect(). mprotect() semantically guarantees that page permissions are synchronized among all threads in a process on which particular applications rely. This not only makes it difficult to accelerate mprotect() with MPK, but also breaks the guarantee of execute-only memory implemented on mprotect in the latest kernel. mprotect() supporting executable-only memory relying on MPK does not consider synchronization among threads, which developers basically expect of mprotect(). Even when the kernel successfully allocates a key for the execute-only page, another thread might have a read access to it due to a lack of synchronization. To make MPK a drop-in replacement of mprotect() for both security and usability, developers need to synchronize the PKRU values among all the threads.  lines of C/C++ code in total. Goals. To utilize MPK for domain-based isolation and as a substitute for mprotect(), we have to overcome the three challenges: (1) insecure key management, (2) hardware resource limitations, and (3) different semantics from mprotect(). libmpk adopts two approaches: (1) key virtualization, and (2) inter-thread key synchronization, which effectively solve the challenges. libmpk also protects its internal metadata from corruption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Threat Model and Assumptions</head><p>libmpk has the following threat model and assumptions, in accordance with prior studies <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b34">35]</ref>. libmpk aims to prevent an adversary from reading from or writing in sensitive pages through memory corruption vulnerabilities. libmpk achieves this goal by protecting the sensitive pages with new MPK APIs and preventing the adversary from arbitrarily executing the WRPKRU instruction. We assume that a program should solely use the libmpk APIs to utilize MPK in a controlled manner. That is, the program should not use conventional MPK APIs together with the libmpk APIs. Also, any uncontrolled execution of the WRPKRU instruction should 1 #define GROUP_1 100 2 #define GROUP_2 101 be prohibited by using existing countermeasures, such as data execution prevention <ref type="bibr" target="#b0">[1]</ref>, control-flow integrity <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b37">38]</ref>, and call gate <ref type="bibr" target="#b34">[35]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">libmpk API</head><p>libmpk provides eight APIs, shown in <ref type="table" target="#tab_4">Table 2</ref>. To utilize libmpk, an application first calls mpk_init() to obtain all the hardware protection keys from the kernel and initialize its metadata. mpk_mmap() allocates a page group for a virtual key, which should be a constant integer that the developer passes. mpk_munmap() destructs a page group by freeing a virtual key for the group and unmaps all the pages. libmpk maintains the mappings between virtual keys and pages to avoid scanning all pages at this destruction step. On top of these, libmpk also provides simple heap over each page group (mpk_malloc() and mpk_free()), so that a developer can also use one or more page groups to create a heap memory region for sensitive data.</p><p>libmpk provides two usage models for developers. The first model, a thread-local domain-based isolation model, allows an application to temporarily grant permission to a page group only for the calling thread. mpk_begin() and mpk_end() are the APIs for this model, which make a page group accessible and inaccessible, respectively. The second model allows an application to quickly change the access rights to a page group by replacing mprotect() with mpk_mprotect(). <ref type="figure">Fig- ure 5</ref> shows an example of utilizing libmpk APIs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Protection Key Virtualization</head><p>libmpk enables an application to create more than 16 page groups by virtualizing the hardware protection keys. When an application creates a new page group by calling mpk_mmap(), a virtual key passed as argument is associated with newly allocated metadata for the new group. The application uses the virtual key to obtain or release the permission, or free the group, while being prohibited from manipulating hardware keys. The exact physical key that a page is associated with is hidden from the program and developer.</p><p>libmpk maintains the mappings between virtual and hardware keys through a cache-like structure ( <ref type="figure" target="#fig_3">Figure 6</ref>). If a virtual key is already associated with a hardware key, the virtual key exists inside the cache and further access to it produces a few latencies. Otherwise, libmpk evicts another virtual key or does nothing but just invokes mprotect() for performance to change page permission. The frequency of eviction or calling mprotect() is determined by the eviction rate. The cache guarantees that a frequently updated virtual key will be mapped with a hardware key since it has a high possibility to be placed into the cache. libmpk provides two policies to determine the mappings between virtual and hardware keys. When an application grants permission to a page group thread-locally by calling mpk_begin(), libmpk always maps the group's virtual key with a hardware key and uses it to grant access to the calling thread. libmpk maintains the mapping until the thread calls mpk_end() to release the access. For this reason, libmpk does not ensure that a calling thread always obtains the access due to hardware limitations. That is, if all hardware keys are actively used, libmpk is no longer able to provide any key. In this case, mpk_begin() raises an exception and lets the calling thread handle it (e.g., sleeps until a key is available). If a page group is not used by a thread, libmpk evicts the group by changing its protection key to 0 (default) and revoking its page permission to disallow subsequent accesses.</p><p>The second policy, mpk_mprotect(), also needs to map the virtual key to a hardware key, but not exclusively. Even when the page group is accessible, libmpk can unmap a hardware key and rely solely on the page attributes because all threads have the access. Hence, libmpk maps only the page groups whose access rights change frequently. If libmpk fails to find an available hardware key when it handles mpk_mprotect(), it unmaps and uses the least recently used (LRU) key for handling mpk_mprotect(). The hardware key of the evicted page group turns to 0. To avoid excessive overhead resulting from frequent unmapping, a developer can configure an eviction rate to control whether a hardware key has to be evicted according to how frequently its permission updates. In our approach, enforcing executable-only permission is not straightforward because a conventional approach (i.e., mprotect()) does not support executable-only permission. Therefore, mpk_mprotect() reserves one key for execute-only pages when an application creates them first, and does not evict this key until all executed-only pages disappear. Every incoming executable-only permission request is guaranteed to get a hardware protection key to achieve executable-only permission. If mpk_mprotect() has already been invoked for executable-only page groups, further requests will merge the    incoming page groups with the existing executable-only ones to utilize the reserved key.</p><p>The integrity of libmpk metadata (e.g., the mappings between virtual and hardware keys, and the page group information) is important to prevent attackers from manipulating libmpk's protection. For the metadata integrity, libmpk maps each metadata physical page into two virtual pages: a readonly page for its userspace code and a writable page for its kernel-space code. Updating the metadata can be done only by the libmpk kernel module and slightly modified system calls (e.g., mmap(), munmap(), and mprotect()). Most of simple metadata retrieval can be done by the userspace code to avoid unnecessary user-kernel mode switches.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Inter-thread Key Synchronization</head><p>libmpk implements an inter-thread PKRU synchronization technique, do_pkey_sync(), in mpk_mprotect() for two purposes:</p><p>(1) to ensure no thread has the read access to an execute-only page and (2) to replace existing page-table-based mprotect() for performance. do_pkey_sync() guarantees that a PKRU update is globally visible and effective as soon as it returns. Intuitively, this requires a synchronous inter-thread communication; the calling thread needs to send messages to the other threads and wait until they update the PKRU value and acknowledge it, which suffers from a high cost. We minimize the inter-thread PKRU synchronization latency in a lazy manner, leveraging the fact that the PKRU values are utilized in the userspace. If a remote thread is not currently being scheduled, it does not need the up-to-date PKRU value immediately. Even if the thread is currently being scheduled, we only need to update its PKRU value when it returns to the userspace. If the calling thread can create a hook that the other threads will invoke right before jumping back to the userspace and ensure that they are not in the userspace, we can guarantee that all the other threads have the new PKRU value when do_pkey_sync() returns. <ref type="figure" target="#fig_5">Figure 7</ref> illustrates the overall procedure of mpk_mprotect(). do_pkey_sync() utilizes an existing hooking point in the Linux kernel to enforce the remote threads to update the PKRU values right before returning to the userspace and ensures that all threads use the new PKRU value by sending rescheduling interrupts. In Linux, a thread can register a list of callback functions (task_work) that are invoked at designated points (e.g., when returning to the userspace) by calling task_work_add(). In this way, do_pkey_sync() guarantees that all the remote threads eventually acquire the new PKRU value. Although do_pkey_sync() still needs to send inter-processor interrupts to ensure that no other thread uses the old PKRU value after a certain point, our evaluation shows that the overall latency of mpk_mprotect() is less than that of mprotect() ( §6.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Applications</head><p>We demonstrate the security benefit, efficiency, and usability of libmpk by augmenting three types of popular applications: an SSL library, three JavaScript Just-in-time (JIT) compilation engines, and an in-memory key-value store. <ref type="table" target="#tab_7">Table 3</ref> summarizes the mechanisms (e.g., page isolation or W⊕X) that we aim to provide as well as the protected data (e.g., key or code). Evaluation results are described in §6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">OpenSSL</head><p>OpenSSL is a popular open-source library implementing the secure sockets layer (SSL) and transport layer security (TLS) protocols. Since it manages sensitive information (e.g., private keys and encrypted data), its information leakage bugs are security-critical. For example, OpenSSL's Heartbleed bug <ref type="bibr" target="#b25">[26]</ref> allowed attackers the chance to leak sensitive data from millions of web servers.</p><p>We apply libmpk to OpenSSL to protect its private keys from potential information leakage by storing the keys in isolated memory pages. More specifically, the isolated memory pages are protected by single pkey or multiple pkeys assigned per private key to show the trade-off between performance and security. First, we identify all the data types that store private keys (e.g., EVP_PKEY) and replace their heap memory allocation function from OpenSSL_malloc() to mpk_malloc() for single pkey or mpk_mmap() for multiple pkeys to store them in an isolated memory region. Next, we locate all the functions that access private keys (e.g., pkey_rsa_decrypt()) and modify them to access the isolated memory region by inserting mpk_begin() and mpk_end() before and after their call sites. Note that assigning pkey per private key offers finer-grained security, which minimizes the attack window for the isolated memory region. For example, even if a function whose call site is located between mpk_begin() and mpk_end() has a memory leakage bug, it cannot access any other isolated pages except the single page isolated with the pkey provided to mpk_begin() as argument.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Just-in-time (JIT) Compilation</head><p>JIT compilation dynamically translates interpreted script languages, e.g., JavaScript and ActionScript, into native machine code or bytecode to avoid the overhead of full compilation and repeated interpretation. Technically, it relies on writable code, resulting in potential arbitrary code execution. To support JIT compilation, the code cache that stores code generated at runtime needs to be writable for a JIT compilation thread and be executable for an execution thread. Thus, if attackers compromise the JIT compilation thread, they can make the execution thread execute the code they provide.</p><p>ChakraCore <ref type="bibr" target="#b26">[27]</ref> and SpiderMonkey <ref type="bibr" target="#b27">[28]</ref> mitigate the above-mentioned problem by enforcing the W⊕X security policy on the code cache with mprotect(). They make the code cache writable while disallowing execution when they are updating code, and, after it has updated, they make the code cache executable while disallowing write. However, they can suffer from race condition attacks <ref type="bibr" target="#b32">[33]</ref> because they use mprotect() to change page permissions; that is, when a thread makes the code cache writable with mprotect(), other threads compromised by attackers can also manipulate the code cache with the same permission.</p><p>We apply libmpk to the three popular JavaScript engines (SpiderMonkey, ChakraCore, and v8) to enforce the W⊕X security policy without the race condition problem while ensuring better performance. We propose two approaches to implement the W⊕X policy with libmpk.</p><p>One key per page. A context-free solution is to replace mprotect() with libmpk APIs to perform fast permission switches on targeted pages in the code cache. All the protection keys are initialized with read-only permission when a new thread is created. We dedicate one protection key to one page when it is the first time to be re-protected via mprotect() and change its page permission to rwx. Later, we only need to call mpk_begin() and mpk_end() before and after when the JIT compiler updates the corresponding page. Based on the observation that generally only one page is updated at a time, we still invoke mprotect() if multiple pages change permission.</p><p>One key per process. Another approach is to use a single protection key for the entire code cache. When pages are first committed from the preserved memory region into the code cache, they are assigned with the protection key and their page permission is set to rwx. Whenever any page in the code cache is to be updated, the script engine needs to call mpk_begin() and mpk_end(). Although more pages become temporarily writable, the security of the code cache is ensured thanks to the per-thread view of the protection key.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">In-Memory Key-Value Store</head><p>In-memory key-value stores, such as Memcached, are widely used to manage a large amount of data in memory to ensure low latency and high throughput. With a high requirement for performance, such key-value stores normally avoid using security techniques whose performance depends on input size (e.g., mprotect() and encryption) to protect stored data. This implies that, if an in-memory key-value store has arbitrary read or write vulnerabilities, attackers are able to leak or corrupt sensitive information stored inside.</p><p>libmpk manages to efficiently mitigate such attacks. To demonstrate this, we apply libmpk to Memcached. libmpk protects Memcached's slabs that contain values and hash tables that maintain key-value mappings by replacing Memcached's malloc() function with mpk_malloc(), and wraps the call sites of all the legitimate functions (e.g., ITEM_key() and assoc_find()), which operate on protected data with mpk_begin() and mpk_end(). Note that we assign two different keys to slabs and hash tables, to narrow the attack surface. It is possible to use more keys to secure slabs in a fine-grained manner, e.g., differentiating them according to their sizes. More importantly, libmpk's performance is independent of the size of memory to protect, and thereby efficiently works with Memcached even when protecting data of several gigabytes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>In this section, we evaluate libmpk in terms of its security implication and performance by answering the following questions:</p><p>• What security guarantees does libmpk provide? ( §6.1)</p><p>• Does libmpk solve the security, scalability, and semanticgap problems of existing MPK APIs without introducing much performance overhead? ( §6.2) • Does libmpk have negligible performance impact and outperform mprotect() in real-world applications? ( §6.</p><p>3) The same system environment explained in §2.3 is used for performance evaluations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Security Evaluation</head><p>We first evaluate the security benefits from libmpk regarding memory protection and isolation. For OpenSSL and Memcached, libmpk provides domain-based isolation to protect memory space that stores sensitive data. The permission for the particular memory space set by libmpk is locally effective, which also prevents malicious accesses from other compromised threads. In particular, exploiting a memory corruption bug to leak or ruin sensitive data stored in the isolated pages is killed by segmentation faults resulting from the lack of permission. To verify this, we mimic the Heartbleed vulnerability by deliberately introducing a heap-out-of-bounds read bug and inserting a decoy private key placed next to the victim heap region. When the vulnerability is triggered, OpenSSL hardened by libmpk crashes with invalid memory access. However, libmpk cannot fully mitigate memory leakage that originates inside the protected domain. Thus, developers should carefully design the domain to minimize the potential attack surface when using libmpk in their applications. JavaScript JIT compilers can use libmpk to guarantee W⊕X for JIT code pages. Unlike mprotect(), libmpk is immune to race condition attacks launched by compromised threads running in parallel resulting from the thread-local effectiveness of protection keys. When the JIT compiler uses libmpk to switch the permission of a code page for updates, other threads controlled by attackers cannot write malicious shellcode into the page simultaneously. To verify this, we introduce two custom JavaScript APIs for arbitrary memory read and write to SpiderMonkey and ChakraCore, and test a simple PoC that leverages these two APIs to locate a JIT code page and write shellcode into it. Both engines crash with a segmentation fault at the end.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Microbenchmarks</head><p>We run several microbenchmarks to understand the performance behavior of APIs in libmpk. Cache performance. libmpk introduces a cache to enable protection on more than 16 page groups, whose performance When the hit rate is 100%, mpk_mprotect() is 12.2× faster than mprotect() for one thread and 3.11× faster for four threads.</p><p>is affected by its eviction rate and hit rate and the number of virtual keys in use. We run the following two microbenchmarks to check the cache performance. Hit rate and eviction rate. The first benchmark measures cache performance with different hit rates, eviction rates, and number of threads. We run the benchmark with both one thread and four threads, where each thread warms up by filling the key cache to evade cold miss and invokes mpk_mprotect() on one page for a hundred times after 15 entries are filled. <ref type="figure" target="#fig_6">Figure 8</ref> presents the evaluation results, where (1) the green box indicates the overhead incurred by the cache hit, which is dominated by the time cost on WRPKRU and maintaining internal data structures; (2) the blue box indicates the overhead incurred by the cache miss, which is dominated by the time cost on key eviction. More specifically, mpk_mprotect() needs to unset the protection key that is to be evicted and bind a new virtual key to it. We test the microbenchmark with three eviction rates that indicate the ratio of cache misses that eventually leads to key eviction. If a cache miss occurs without key eviction, mprotect() is invoked to change the permission of the pages.</p><p>Experimental results show that mpk_mprotect() outperforms mprotect() except when the cache hit rate is below 25% with an eviction rate above 50%. This is because, unlike mprotect(), mpk_mprotect() does not merge and split the VMAs of targeted pages. It becomes slow when being tested with four threads, but is still comparable with mprotect(), whose latency also increases in a multi-threading program.</p><p>Number of virtual keys. To evaluate how the number of used virtual keys affects the cache performance of libmpk, we re-implement W⊕X in ChakraCore in a one-key-per-page approach (see §5.2) and set the eviction rate as 100%. To introduce an increasing number of pages to be protected (i.e., an increasing number of virtual keys to be used) during the execution of ChakraCore, we design a simple microbenchmark. The microbenchmark consists of a set of JavaScript files, and the ith file contains i hot functions being invoked for 100,000 times. For each hot function, ChakraCore allocates one new executable page to store the native code and performs nine permission switches on the page through one virtual key at runtime. Without any hot function, ChakraCore allocates one page in the code cache. We run the original ChakraCore (version 1.9.0.0-beta) and the modified one with our microbenchmarks, and record the time cost of changing permission of the pages in the code cache (i.e., the execution time of VirtualProtect() and that of mpk_begin() and mpk_end()) in total. Each JavaScript file is executed 200 times, and the average time is presented in <ref type="figure" target="#fig_7">Figure 9</ref>. The result shows that with the libmpk-based implementation of W⊕X, the time cost on permission switches linearly increases when more hot functions are emitted and thus more virtual keys are allocated to protect the code pages of the hot functions. In particular, after 15 virtual keys are allocated (marked in red), the time cost increases slightly faster than before (marked in blue) as a result of cache eviction. Nevertheless, the ChakraCore hardened by libmpk still outperforms by 3.2× the original ChakraCore using mprotect() to enforce W⊕X.</p><p>Memory overhead. libmpk dedicates memory space to store its internal data structures for maintaining the metadata of these page groups under protection (see §4.3). Each mpk_mmap() allocates 32 bytes of memory to store the information of a new page group (e.g., base address and size). libmpk maintains a hashmap to store the mapping between virtual keys and hardware keys for fast query and access. In the current implementation, we pre-allocate 32 KB of memory for the hashmap, and its size will automatically expand when a program invokes mpk_mmap() more than about 4,000 times.</p><p>Synchronization latency. <ref type="figure">Figure 10</ref> shows the latency of inter-thread permission synchronization using mpk_mprotect() and mprotect() on memory of varying sizes.   <ref type="figure">Figure 10</ref>: Latency of inter-thread permission synchronization using mpk_mprotect() and mprotect() calls on memory of varying sizes. mpk_mprotect() outperforms mprotect() 1.73× for a single page and 3.77× for 1,000 pages.</p><p>mpk_mprotect() is 1.73× faster than mprotect() when updating the permission of a single page. The latency of mprotect() increases with the number of pages it changes due to the expensive operations of managing VMAs. Compared to mpk_mprotect(), mprotect() costs at least 3.78× to change the permission of 1,000 pages. The performance overhead of mpk_mprotect() is independent of the number of pages whose permission has been updated. <ref type="figure">Figure 10</ref> also shows that when there are many threads, the latency of both mprotect() and mpk_mprotect() increases; mprotect() flushes more TLBs, whereas mpk_mprotect() creates many hooks in the kernel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Application Benchmarks</head><p>We measure the performance overhead of libmpk in practice by evaluating three applications proposed in §5.</p><p>OpenSSL. The Apache HTTP server <ref type="bibr" target="#b11">[12]</ref> (httpd) uses OpenSSL to implement SSL/TLS protocols. To evaluate the overhead caused by libmpk, which is introduced to protect private keys, we use ApacheBench to test httpd with both the original OpenSSL library and the modified one with libmpk.</p><p>ApacheBench is launched 10 times and each time sends 1,000 requests of different sizes from four concurrent clients to the server. We choose the DHE-RSA-AES256-GCM-SHA256 algorithm with 1024-bit keys as a cipher suite in the evaluation. <ref type="figure" target="#fig_9">Figure 11</ref> presents the evaluation result. On average, libmpk introduces 0.58% and 4.82% performance overhead, respectively, in terms of the throughput. In the single pkey case, the negligible overhead mainly comes from internal data structure maintenance in libmpk. In the multiple pkeys case, httpd utilizes more than 1,000 pkeys, as it allocates a new pkey while creating a new session. These pkeys are maintained by cache invoke eviction, so the multiple pkeys generates higher overhead than the single pkey case. Just-in-time compilation. We applied two proposed W⊕X solutions based on libmpk, namely, one key per page and one key per process ( §5.2) to both SpiderMonkey (version 59.0) and ChakraCore (version 1.9.0.0-beta) and evaluated their performance with the Octane benchmark <ref type="bibr" target="#b14">[15]</ref>, which involves heavy JIT-compilation workloads at runtime. Each  JavaScript program in the benchmark was directly executed by the original and modified script engines for 20 times, and we calculated the average score ( <ref type="figure" target="#fig_0">Figure 12</ref>). For SpiderMonkey, both libmpk-based approaches outperform the mprotect()-based approach on the total score, namely, 0.38% and 1.26%, which is consistent with the claim from Firefox developers that enabling W⊕X with mprotect() in SpiderMonkey introduces less than 1% overhead for the Octane benchmark. The reason is that SpiderMonkey is designed to get rid of unnecessary mprotect() calls when its JIT compiler works. The performance scores of nearly all the programs increase through one key per page (at most 3.60% on Box2D) and one key per process (at most 4.75% on Box2D), except for SplayLatency protected by one key per page (dropped by 1.36%). SplayLatency becomes worse because it barely updates the code cache such that the initial overhead to associated keys with pages cannot be hidden.</p><p>Our two libmpk-based approaches improve ChakraCore by 1.01% and 4.39% on the total score of the Octane benchmark, respectively. ChakraCore is suitable for libmpk-based W⊕X solutions since it only makes one page writable per time regardless of emitted code size. One key per page increases the performance score of ChakraCore at most 7.96% when testing SplayLatency, while one key per process improves the performance by at most 31.11% on Box2D. Similar to the results of SpiderMonkey, we observe a few performance degradations when benchmarks rarely update code cache.</p><p>For v8, we compare our approach with a mprotect()-based scheme, SDCG <ref type="bibr" target="#b32">[33]</ref>. SDCG protects the JIT code pages of v8 with W⊕X by emitting the code in a dedicated process. No other processes can change the code pages. To demonstrate the performance advantage of our in-process libmpk-based approaches, which are free of race condition attacks, we applied one of our approaches, one key per process, to Google v8 (version 3.20.17.1 used in <ref type="bibr" target="#b32">[33]</ref>) and evaluated the performance through the Octane benchmark as well. <ref type="figure" target="#fig_1">Figure 13</ref> presents the performance comparison among the original v8, v8 with SDCG, and v8 with libmpk. Note that originally, v8 has not deployed W⊕X to protect its code cache so far. Our approach only introduces 0.81% overall performance loss, compared with 6.68% caused by SDCG.</p><p>To summarize, our libmpk-based approaches, which are free of the race condition attacks, outperform the mprotect()-based approach currently applied in practice to enforce W⊕X protection on code cache pages with negligible overhead. In-memory key-value store. To study the performance overhead of libmpk when protecting large memory, we evaluate the modified Memcached whose key-value pairs are isolated by libmpk. More specifically, the modified Memcached preallocates 1 GB memory, which is used instead of slab pages allocated by glibc malloc() to store key-value pairs. Besides the original Memcached, we also evaluate the Memcached whose key-value pairs are protected by mprotect(). To study the performance of mpk_mprotect() in real-world applications, we also create the Memcached guarded by libmpk with permission synchronized as another evaluation target for comparison. Each aforementioned version of Memcached launches with four concurrent threads, and we connect to it remotely through twemperf <ref type="bibr" target="#b33">[34]</ref>. We create from 250 to 1,000 connections per second, and 10 requests are sent during each connection. <ref type="figure" target="#fig_11">Figure 14</ref> presents the evaluation results. The modified Memcached hardened by libmpk only has 0.01% overhead in terms of data throughput and almost no overhead regarding concurrent connections processed per second, which indicates that libmpk performs well even when protecting a huge number of pages. By contrast, mprotect() introduces nearly 89.56% overhead in terms of data throughput when protecting 1 GB memory in Memcached and a large number of unhandled concurrent connections accumulate in this case. This is because mprotect() involves page table traversing, which is considered expensive when dealing with a large number of pages. To evaluate the synchronization service of libmpk in practice, we also run Memcached protected by mpk_mprotect(). This design ensures the same semantics but outperforms mprotect() 8.1× regarding throughput. libmpk provides the same functionality of mprotect() with much better performance when protecting huge memory. Moreover, in multi-threading applications, using mprotect() to ensure in-thread memory isolation requires lock, which is not required when using libmpk because of its inherent property.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Discussion</head><p>In this section, we discuss a potential attack on both Intel MPK and libmpk. Rogue data cache load (Meltdown). We found that Intel MPK can suffer from the rogue data cache load, also known as the Meltdown attack <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b23">24]</ref>. The Meltdown attack is possible because current Intel CPUs check the access permission to a specific memory page after they have loaded it into the cache. MPK is not an exception because Intel CPUs check the access rights of PKRU when checking the page permission at the same pipeline phase. This allows attackers to infer the content of a present (accessible) page even when its protection key has no access right. Since Intel is considering hardware-level mitigation techniques <ref type="bibr" target="#b18">[19]</ref>, we believe this problem will be solved in the near future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related Work</head><p>MPK applications. While conducting our study, we noticed that there were a few ongoing studies using MPK to achieve different goals. Burow et al. <ref type="bibr" target="#b7">[8]</ref> leverage both MPK and memory protection extension (MPX) to efficiently isolate the shadow stack. ERIM <ref type="bibr" target="#b34">[35]</ref> utilizes MPK to isolate sensitive code and data. MemSentry <ref type="bibr" target="#b20">[21]</ref> provides a unified memory isolation framework to use various hardware features, including MPK and Memory Protection Extensions (MPX), with the same interface. XOM-Switch <ref type="bibr" target="#b38">[39]</ref> relies on MPK to enable execute-only memory for unmodified binaries, and IskiOS <ref type="bibr" target="#b15">[16]</ref> leverages MPK and kernel page table isolation (KPTI) to enforce execute-only memory in kernel. Our effort to provide a software abstraction for MPK is orthogonal to these studies, which are all potential applications of libmpk. These schemes can leverage libmpk to achieve secure and scalable key management to create as many sensitive memory regions as required securely. Memory protection with other hardware features. Other hardware features exist for efficient memory protection such as ARM Domain <ref type="bibr" target="#b4">[5]</ref> and IBM Storage Protection <ref type="bibr" target="#b17">[18]</ref>, which have a similar concept to MPK. For instance, ARMlock <ref type="bibr" target="#b39">[40]</ref>, FlexDroid <ref type="bibr" target="#b30">[31]</ref>, and Shreds <ref type="bibr" target="#b8">[9]</ref> rely on Domain to isolate untrusted program modules, third-party libraries, and sensitive code modules, respectively. libmpk helps to port these applications from ARM to the Intel platform. Software-based fault isolation (SFI). SFI <ref type="bibr" target="#b35">[36]</ref> prohibits unintended memory accesses by inserting address masking instructions just before load and store instructions. This idea motivates many applications to utilize and further optimize it. Sandboxing mechanisms, such as Native Client (NaCl) <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b29">30]</ref>, relies on SFI to isolate untrusted code. Code-Pointer Integrity <ref type="bibr" target="#b22">[23]</ref> also uses SFI to protect the code pointers from unsanitized memory accesses. SFI enables an application to partition its memory into multiple regions, but the cost of address masking limits the shape of partitions, which are commonly contiguous pieces of memory. By contrast, MPK enables an application to partition the memory into the regions with arbitrary shape. Further, the overhead of SFI on address masking increases by the number of isolated memory regions, unlike MPK. Multiple virtual address spaces. Using multiple virtual address spaces for a single program can protect the memory of sensitive or untrusted components from the others. Some systems <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b36">37</ref>] rely on multiple page tables to isolate the memory of threads in a single process from each other. Other systems <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b24">25]</ref> also provide different memory views to individual threads or small execution units using separated page tables. <ref type="bibr">Kenali [32]</ref> uses a page-table-based isolation mechanism to protect sensitive data in which a separate page table is created for each thread. Unlike libmpk, these mechanisms suffer from non-negligible performance overhead resulting from slow and frequent page table switches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion</head><p>Intel MPK supports efficient per-thread permission control on groups of pages. However, its hardware implementation and software support suffer from security, scalability, and semantic-gap problems. libmpk proposes a secure, scalable, and semantic-gap-mitigated software abstraction of MPK for developers to perform fast memory protection and domainbased isolation in their applications. Evaluation results show that libmpk incurs negligible performance overhead (&lt;1%) for domain-based isolation and better performance for a substitute of mprotect() when adopted to real-world applications: OpenSSL, JavaScript JIT compiler, and Memcached.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Effect of WRPKRU serialization on simple (i.e., ADD) instructions either preceding or succeeding WRPKRU (average of 10 million repetitions).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Overhead of mprotect() on contiguous and sparse memory (average cost of 10 million repetitions). Protecting contiguous pages takes less time than protecting sparse pages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>3 4Figure 5 :</head><label>35</label><figDesc>Figure 5: Example code for libmpk APIs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Key virtualization in libmpk. vkey and pkey represent a virtual key and its corresponding hardware protection key associated with a page group. #threads indicates the number of threads running parallel inside a particular domain.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: PKRU synchronization: 1 mpk_mprotect() calls do_pkey_sync() to update the PKRU values of remote threads; 2 do_pkey_sync() adds hooks to the threads' task_work; 3 do_pkey_sync() kicks all the running threads for synchronization; 4 do_pkey_sync() returns to its caller; 5 The threads update their PKRUs when they are scheduled to run.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Latency of libmpk's key cache with various hit rates, eviction rates, and different number of threads. mpk_mprotect() and mprotect() are invoked on a 4 KB page. Red line marks the overhead of mprotect(). When the hit rate is 100%, mpk_mprotect() is 12.2× faster than mprotect() for one thread and 3.11× faster for four threads.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Average time cost to update permission when original and modified ChakraCore JIT-compile an increasing number of hot functions demanding distinct virtual keys.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Throughput of original httpd and httpd hardened by libmpk. Protecting private keys with single pkey and 1000+ pkeys, libmpk slows down httpd by at most 2.52% and 18.84% respectively. The averages of overhead are 0.58% and 4.82% respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :Figure 13 :</head><label>1213</label><figDesc>Figure 12: Octane benchmark scores of SpiderMonkey and ChakraCore with original and libmpk-based W⊕X solutions. libmpk outperforms the original, mprotect()-based defense by at most 4.75% (SpiderMonkey) and 31.11% (ChakraCore).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Throughput and unhandled concurrent connections of original Memcached and three versions of Memcached whose keyvalue pairs are protected by mpk_begin(), mpk_mprotect(), and mprotect(). mpk_begin()'s overhead is negligible compared to the original. mpk_mprotect() outperforms mprotect() 8.1× while ensuring the same semantics.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>table entry .</head><label>entry</label><figDesc></figDesc><table>MPK assigns a 
unique protection key to a memory page group to update its 
permission at the same time. MPK exploits the previously 
unused four bits of each page table entry (from 32nd to 35th 
bits) to store a memory page's corresponding key value. Thus, 
MPK supports up to 16 different page groups. Since only 
supervised code can access and change PTEs, the Linux ker-
nel (from version 4.6) starts to provide a new system call, 
pkey_mprotect(), to allow applications to assign or change 
the keys of their memory pages ( §2.2). 
Protection key rights register (PKRU). MPK uses the value 
of PKRU to determine its access right to each page group. 
Two bits representing the right are access disable (AD) and 
write disable (WD) bits. The value of (AD,W D) represents a 
thread's permission to a page group: read/write (0, 0), read-
only (0, 1), or no access (1, x). PKRU exists for each hyper-
thread to provide a per-thread view. 
Instruction set. MPK introduces two new instructions to 
manage the PKRU: (1) WRPKRU to update the protection infor-
mation of the PKRU and (2) RDPKRU to retrieve the current 
protection information from the PKRU. WRPKRU uses three reg-
isters as input: the EAX register containing new protection Name 

Cycles Description 

pkey_alloc() 

186.3 Allocate a new pkey 

pkey_free() 

137.2 Deallocate a pkey 

pkey_mprotect() 

1,104.9 
Associate a pkey key with memory pages 

pkey_get()/RDPKRU 

0.5 Get the access right of a pkey 

pkey_set()/WRPKRU 

23.3 
Update the access right of a pkey 

Ref. mprotect(): 1,094.0 / MOVQ (rbx to rdx): 0.0 / MOVQ (rdx to xmm): 2.09 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 1 ).</head><label>1</label><figDesc></figDesc><table>The latency of mprotect() 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 2 : libmpk APIs.</head><label>2</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>→ rw- ❶ retrieve ❷ evict and load ❸�return</head><label></label><figDesc></figDesc><table>vkey pkey 
24 
? 

vkey pkey #threads 

24 
10 
2 

1 
1 
0 

... 
75 
0 
0 

vkey pkey 
24 
10 

❶ retrieve 
❷ return 

(a) Hit case: 1 A thread calls mpk_begin() or mpk_mprotect() with 
a vkey; 2 libmpk returns the corresponding pkey immediately. 

vkey pkey 
75 
? 

vkey pkey #threads 

24 
10 
2 

1 1→0 
0 

... 
75 0→1 
0 

vkey pkey 
75 
1 

PTEs (vkey=1) 

. . . 

pkey: 1→0 

... 

perm: rw-→ ---

PTEs (vkey=75) 

. . . 

pkey: 0→1 

... 

perm: ---(only for 

mpk_begin) 

(b) Miss case: 1 A thread retrieves a vkey, but no corresponding 
pkey exists (pkey=0); 2 libmpk evicts the LRU pkey. In addition, 
mpk_begin() updates the page permission of the evicted and loaded 
page groups using mprotect(); 3 libmpk returns the new pkey. 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Application Protection Protected data #pkeys #vkeys Changed LoC</head><label></label><figDesc></figDesc><table>OpenSSL 
Isolation Private key 
1 
1 
83 
JIT (key/page) 
W⊕X 
Code cache 
15 
&gt; 15 
CC 10 | SM 18 
JIT (key/process) W⊕X 
Code cache 
1 
1 
CC 18 | SM 24 | v8 134 
Memcached 
Isolation Slab, hashtable 2 
2 
117 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Three real-world applications of libmpk. To enable W⊕X in 
JavaScript engines, we use two approaches, including using a virtual 
key for every page in the code cache (One key per page) and using a 
single protection key for all the pages in the code cache (One key per 
process). CC, SM, and v8 indicate Microsoft ChakraCore, Mozilla 
SpiderMonkey, and Google v8, respectively. pkeys and vkeys stand 
for protection keys and virtual keys, respectively. 

</table></figure>

			<note place="foot" n="1"> The default group (0) has a special purpose, so only 15 groups are available for general uses.</note>

			<note place="foot" n="248"> 2019 USENIX Annual Technical Conference USENIX Association</note>

			<note place="foot" n="250"> 2019 USENIX Annual Technical Conference USENIX Association</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Acknowledgment</head><p>We thank the anonymous reviewers, and our shepherd, John Criswell, for their helpful feedback. This research was supported, in part, by the NSF award CNS-1563848, CNS-1704701, CRI-1629851 and CNS-1749711 ONR under grant N00014-18-1-2662, N00014-15-1-2162, N00014-17-1-2895, DARPA TC (No. DARPA FA8650-15-C-7556), and ETRI IITP/KEIT[B0101-17-0644], and gifts from Facebook, Mozilla and Intel.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Exec Shield</title>
		<ptr target="https://lwn.net/Articles/31032/" />
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
	<note>new Linux security feature</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Linux kernel</title>
		<idno>v4.20</idno>
		<ptr target="https://elixir.bootlin.com/linux/v4.20-rc1/source/mm/mprotect.c#L630" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">programmer&apos;s manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pkeys</surname></persName>
		</author>
		<ptr target="http://man7.org/linux/man-pages/man7/pkeys.7.html" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Control-flow integrity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martín</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mihai</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ulfar</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jay</forename><surname>Ligatti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 12th ACM Conference on Computer and Communications Security (CCS)<address><addrLine>Alexandria, VA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<title level="m">ARM. ARM ® Architecture Reference Manual ARMv7-A and ARMv7-R edition</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Wedge: Splitting Applications into Reduced-Privilege Compartments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bittau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Marchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Handley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Karp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th USENIX Symposium on Networked Systems Design and Implementation (NSDI)</title>
		<meeting>the 5th USENIX Symposium on Networked Systems Design and Implementation (NSDI)<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Privtrans: Automatically partitioning programs for privilege separation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th USENIX Security Symposium (Security)</title>
		<meeting>the 13th USENIX Security Symposium (Security)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">SoK: Shining light on shadow stacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Burow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xinping</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathias</forename><surname>Payer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th IEEE Symposium on Security and Privacy</title>
		<meeting>the 40th IEEE Symposium on Security and Privacy<address><addrLine>Oakland; San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Shreds: Fine-grained Execution Units with Private Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yaohui</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhichuang</forename><surname>Sebassujeen Reymondjohnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Long</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th IEEE Symposium on Security and Privacy (Oakland)</title>
		<meeting>the 37th IEEE Symposium on Security and Privacy (Oakland)<address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">How the Kernel Manages Your Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gustavo</forename><surname>Duarte</surname></persName>
		</author>
		<ptr target="https://manybutfinite.com/post/how-the-kernel-manages-your-memory/" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">SpaceJMP: Programming with Multiple Virtual Address Spaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Izzat El Hajj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gerd</forename><surname>Merritt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dejan</forename><surname>Zellweger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reto</forename><surname>Milojicic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Achermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wen-Mei</forename><surname>Faraboschi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><surname>Hwu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karsten</forename><surname>Roscoe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schwan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the 21st ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)<address><addrLine>Atlanta, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title/>
		<ptr target="https://httpd.apache.org/" />
	</analytic>
	<monogr>
		<title level="j">Apache Software Foundation. Apache HTTP Server Project</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Free Software Foundation. The gnu c library</title>
		<ptr target="https://www.gnu.org/software/libc/manual/html_mono/libc.html#Memory-Protection" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">NaCl SFI model on x86-64 systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google</surname></persName>
		</author>
		<ptr target="https://developer.chrome.com/native-client/reference/sandbox_internals/x86-64-sandbox" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">The JavaScript Benchmark Suite for the modern web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google</surname></persName>
		</author>
		<ptr target="https://developers.google.com/octane" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Spyridoula</forename><surname>Gravani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohammad</forename><surname>Hedayati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Criswell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">L</forename><surname>Scott</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1903.04654</idno>
		<title level="m">IskiOS: Lightweight defense against kernel-level code-reuse attacks</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Enforcing Least Privilege Memory Views for Multithreaded Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terry Ching-Hsiang</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Hoffman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Eugster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathias</forename><surname>Payer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 23rd ACM Conference on Computer and Communications Security (CCS)<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">ISATM Version 3.0 B</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ibm</forename><surname>Power</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Intel Analysis of Speculative Execution Side Channels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Intel ® 64 and IA-32 Architectures Software Developer&apos;s Manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">No Need to Hide: Protecting Safe Regions on Commodity Hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koen</forename><surname>Koning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herbert</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristiano</forename><surname>Giuffrida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elias</forename><surname>Athanasopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th European Conference on Computer Systems (EuroSys)</title>
		<meeting>the 12th European Conference on Computer Systems (EuroSys)<address><addrLine>Belgrade, Serbia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Vasileios P Kemerlis, and Michalis Polychronakis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hyungjoon</forename><surname>Koo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yaohui</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Long</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th IEEE Symposium on Security and Privacy (Oakland)</title>
		<meeting>the 39th IEEE Symposium on Security and Privacy (Oakland)<address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-05" />
		</imprint>
	</monogr>
	<note>Compiler-assisted Code Randomization</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Code-Pointer Integrity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Szekeres</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Payer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>the 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI)<address><addrLine>Broomfield, Colorado</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Meltdown: Reading Kernel Memory from User Space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Prescher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Werner</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anders</forename><surname>Fogh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jann</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Kocher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Hamburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Security Symposium (Security)</title>
		<meeting>the 27th USENIX Security Symposium (Security)<address><addrLine>Baltimore, MD</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Light-Weight Contexts: An OS Abstraction for Safety and Performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Litton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anjo</forename><surname>Vahldiek-Oberwagner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eslam</forename><surname>Elnikety</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deepak</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bobby</forename><surname>Bhattacharjee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Druschel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>the 12th USENIX Symposium on Operating Systems Design and Implementation (OSDI)<address><addrLine>Savannah, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mehta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Codenomicon</forename></persName>
		</author>
		<ptr target="http://heartbleed.com/" />
	</analytic>
	<monogr>
		<title level="j">The Heartbleed Bug</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">ChakraCore is the core part of the Chakra Javascript engine that powers Microsoft Edge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Microsoft</surname></persName>
		</author>
		<ptr target="https://github.com/Microsoft/ChakraCore" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mozilla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Spidermonkey</surname></persName>
		</author>
		<ptr target="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Preventing Privilege Escalation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Niels</forename><surname>Provos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Friedl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Honeyman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th USENIX Security Symposium (Security)</title>
		<meeting>the 12th USENIX Security Symposium (Security)<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Adapting Software Fault Isolation to Contemporary CPU Architectures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Sehr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cliff</forename><surname>Biffle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Victor</forename><surname>Khimenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Egor</forename><surname>Pasko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><surname>Schimpf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bennet</forename><surname>Yee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brad</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th USENIX Security Symposium (Security)</title>
		<meeting>the 19th USENIX Security Symposium (Security)<address><addrLine>Washington, DC, Au</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>gust</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">FlexDroid: Enforcing In-App Privilege Separation in Android</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jaebaek</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daehyeok</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donghyun</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Insik</forename><surname>Shin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the 2016 Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Enforcing Kernel Security Invariants with Data Flow Integrity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengyu</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Byoungyoung</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kangjie</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">R</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenke</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the 2016 Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Exploiting and Protecting Dynamic Code Generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengyu</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chao</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tielei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenke</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Melski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the 2015 Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Twitter</surname></persName>
		</author>
		<ptr target="https://github.com/twitter-archive/twemperf" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">ERIM: Secure, Efficient In-process Isolation with Protection Keys (MPK)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anjo</forename><surname>Vahldiek-Oberwagner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eslam</forename><surname>Elnikety</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nuno</forename><forename type="middle">O</forename><surname>Duarte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Sammler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deepak</forename><surname>Garg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th USENIX Security Symposium (Security)</title>
		<meeting>the 28th USENIX Security Symposium (Security)<address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Efficient Software-based Fault Isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Wahbe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Lucco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Susan L</forename><surname>Thomas E Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Graham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM Symposium on Operating Systems Principles (SOSP)</title>
		<meeting>the 14th ACM Symposium on Operating Systems Principles (SOSP)<address><addrLine>Asheville, NC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Between Mutual Trust and Mutual Distrust: Practical Fine-grained Privilege Separation in Multithreaded Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jun</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xi</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peng</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 USENIX Annual Technical Conference (ATC)</title>
		<meeting>the 2015 USENIX Annual Technical Conference (ATC)<address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">VTint: Protecting Virtual Function Tables Integrity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chao</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengyu</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><forename type="middle">Zhijie</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhaofeng</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the 2015 Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">eXecutable-Only-Memory-Switch (XOM-Switch): Hiding Your Code From Advanced Code Reuse Attacks in One Shot</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mingwei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ravi</forename><surname>Sahita</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daiping</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Black Hat Asia Briefings</title>
		<meeting><address><addrLine>Black Hat Asia; Singapore</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">ARMlock: Hardware-based Fault Isolation for ARM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yajin</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaoguang</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yue</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhi</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the 21st ACM Conference on Computer and Communications Security (CCS)<address><addrLine>Scottsdale, Arizona</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-11" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
