<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T01:58+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">In Search of I/O-Optimal Recovery from Disk Failures</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Osama</forename><surname>Khan</surname></persName>
							<email>okhan@cs.jhu.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Electrical Eng. and Comp. Science</orgName>
								<orgName type="institution" key="instit1">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit2">University of Tennessee</orgName>
								<orgName type="institution" key="instit3">Microsoft Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Randal</forename><surname>Burns</surname></persName>
							<email>randal@cs.jhu.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Electrical Eng. and Comp. Science</orgName>
								<orgName type="institution" key="instit1">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit2">University of Tennessee</orgName>
								<orgName type="institution" key="instit3">Microsoft Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Plank</surname></persName>
							<email>plank@cs.utk.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Electrical Eng. and Comp. Science</orgName>
								<orgName type="institution" key="instit1">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit2">University of Tennessee</orgName>
								<orgName type="institution" key="instit3">Microsoft Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cheng</forename><surname>Huang</surname></persName>
							<email>cheng.huang@microsoft.com</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Electrical Eng. and Comp. Science</orgName>
								<orgName type="institution" key="instit1">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit2">University of Tennessee</orgName>
								<orgName type="institution" key="instit3">Microsoft Research</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">In Search of I/O-Optimal Recovery from Disk Failures</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We address the problem of minimizing the I/O needed to recover from disk failures in erasure-coded storage systems. The principal result is an algorithm that finds the optimal I/O recovery from an arbitrary number of disk failures for any XOR-based erasure code. We also describe a family of codes with high-fault tolerance and low recovery I/O, e.g. one instance tolerates up to 11 failures and recovers a lost block in 4 I/Os. While we have determined I/O optimal recovery for any given code, it remains an open problem to identify codes with the best recovery properties. We describe our ongoing efforts toward characterizing space overhead versus recovery I/O tradeoffs and generating codes that realize these bounds.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recovery from failures has become a critical component of disk storage systems because they have reached such a massive scale that failures must be expected and dealt with as a matter of regular operation <ref type="bibr" target="#b7">[8]</ref>. Large scale deployments now typically tolerate multiple failures both to keep service available and to avoid data loss, e.g. three replicas has become the de facto standard in Hadoop! and systems utilizing RAID-6 are widely deployed.</p><p>We answer a fundamental question in recovery performance: what are the fewest number of I/Os needed to recover from an arbitrary number of disk failures? As the amount of redundancy grows, storage system codes offer many different schedules to recover a lost disk that vary widely in their I/O requirements. For example, in row-diagonal parity <ref type="bibr" target="#b22">[23]</ref> and Even-Odd codes <ref type="bibr" target="#b21">[22]</ref> that tolerate two disk failures, I/O can be reduced by 25% by recovering a combination of rows and diagonals that share blocks, rather than the standard practice of recovering each row independently. We provide an algorithm that minimizes the I/O recovery cost for any XOR-based code.</p><p>Two application contexts, cloud storage systems and deep archival storage, motivate the need for I/O efficient coding (Section 2). Cloud storage systems perform erasure decoding when recovering from disk failures and when performing system upgrades. Upgrades occur frequently-they are often continuous <ref type="bibr" target="#b6">[7]</ref>-and minimizing I/O limits performance degradation. Deep archival stores include data that are almost never read, but need to be stored for regulatory or archival purposes. For these data, the only workload is introspection and recovery. Therefore, highly fault-tolerant recovery I/O efficient codes allow us to increase scale and save power.</p><p>Many advances have been made in improving recovery performance in disk redundancy coding. These include hardware to minimize data copying <ref type="bibr" target="#b5">[6]</ref>, loadbalancing recovery among disks <ref type="bibr" target="#b11">[12]</ref>, recovering popular data first to decrease read degradation <ref type="bibr" target="#b20">[21]</ref>, and only recovering blocks that contain live data <ref type="bibr" target="#b18">[19]</ref>. Recently, the issue of minimizing I/O recovery schedules has emerged as a research topic. The results for Even-Odd codes <ref type="bibr" target="#b21">[22]</ref> and row-diagonal parity <ref type="bibr" target="#b22">[23]</ref> represent solutions for two specific codes. We present an algorithm that defines the I/O lower bound for any matrix code and allows multiple codes to be compared for I/O recovery cost.</p><p>Optimizing the recovery I/O of existing erasure codes shows benefits, but does not transform recovery. In contrast, codes designed specifically for recovery radically reduce I/O. Our algorithm applied to Liberation codes and Cauchy Reed-Solomon codes reduce I/O by 20-30%: on the same order as previous results <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b22">23]</ref>. We present a family of codes (Section 4) that leverage the constrained data dependencies of Weaver codes <ref type="bibr" target="#b9">[10]</ref> and 2-dimensional properties of Grid codes <ref type="bibr" target="#b14">[15]</ref>. One instance of these codes tolerates up to 11 failures and can recover a lost encoded block in 4 I/Os! A Reed-Solomon code with similar properties uses 12 I/Os.</p><p>The design of recovery I/O optimal codes remains an open problem. We conjecture that there are tradeoffs between recovery I/O and storage efficiency, i.e. that an increase in storage can reduce I/O at a given fault tolerance. We are pursuing the fundamental bounds for this problem. At the same time, we are exploring the structure of recovery I/O by searching for the best feasible codes using our optimization algorithm.</p><p>Note: Regenerating codes provide minimal recovery bandwidth and storage overhead <ref type="bibr" target="#b4">[5]</ref>. They were designed for distributed systems in which wide-area bandwidth limits recovery performance. They achieve minimum bandwidth by transferring a smaller amount of data from as many shares of the data as are available. For storage systems, minimizing I/O is more valuable than minimizing bandwidth and regenerating codes that access all existing shares of data increase I/O.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Applications of I/O-Optimal Recovery</head><p>Cloud File Systems: Cloud storage systems, such as Amazon S3 and Windows Azure Storage, assemble massive amounts of unreliable hardware and rely on software to deliver highly reliable and available storage services. Typically, they store three replicas <ref type="bibr" target="#b7">[8]</ref> to guard against failures. Erasure coding provides an alternative that improves fault tolerance at reduced storage costs <ref type="bibr" target="#b0">[1]</ref>.</p><p>Cloud storage uses erasure decoding when recovering from failures and, more frequently, when storage nodes are unavailable. Scheduled events, such as patches and software updates, and unscheduled events, such are reboots, make nodes unvailable. For example, an update of the storage software stack rolls out in phases. Small batches of the storage nodes are suspended and the update applied. Then, the entire system is left running until performance metrics stabilize. The entire update process can last hours <ref type="bibr" target="#b6">[7]</ref>. During updates, read requests to the unavailable nodes invoke erasure decoding and recovery dictates overall I/O performance.</p><p>Deep Archival Stores: Regulatory requirements and preservation dictate that data needs to be archived for future availability. However, a large fraction of this data will never be read. The workload for these systems consists of introspection, checking that data are intact, and error recovery. Pergamum <ref type="bibr" target="#b19">[20]</ref> defined archival systems of this type based on massive arrays of idle disks (MAID). They demonstrate that 95% of disks may be powered off at all times. We extend Pergamum's vision of infrequent error detection and look to employing untrusted cloud storage. To increase power savings, we take a much more passive approach to introspection and recovery. Encoding data with large amounts of redundancy allows for the lazy detection of failed devices/sites and recovery from multiple drive and latent sector errors. Combining I/O-efficient erasure coding with secure auditing for outsourced data <ref type="bibr" target="#b3">[4]</ref> enables cost reduction in cloud archives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Finding I/O Optimal Recovery Schedules</head><p>Any erasure code based on exclusive-or operations may be represented by a bit-matrix-vector product as in <ref type="figure" target="#fig_0">Fig- ure 1</ref>. A vector of k data bits is multiplied by a (n × k) Generator matrix to yield an n-element vector called the codeword. In our simplified example, each bit (or row) of the input data vector, and consequently the codeword, can represent one or more disk sectors. The code represented in <ref type="figure" target="#fig_0">Figure 1</ref> is a RAID-6 code for a four-disk system, where each disk stores two bits (or rows), of the codeword. All XOR-based codes can be represented by a Generator matrix. The difference between the various codes lies in different Generator matrices, and different ways to store the bits on different disks. For example, Greenan et al define a "flat" code as one where each bit is stored on a different disk <ref type="bibr" target="#b8">[9]</ref>. Thus, <ref type="figure" target="#fig_0">Figure 1</ref> could represent a flat code for an 8-disk system. Each bit in the codeword is represented by a row of the Generator matrix. When data is lost, the standard methodology for reconstruction is to create an invertible (k × k) matrix from k rows of the Generator matrix that correspond to surviving bits in the codeword. This matrix is inverted, and multiplying the inverse by the surviving bits yields the original data <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>While this technique is general-purpose, it produces one of the many possible ways to reconstruct the lost data. We solve the problem of determining how to recalculate the lost data while minimizing the total number of surviving bits that are read. With each bit representing one or more sectors on disk, minimizing the bits read will minimize the number of disk I/O's required for recovery.</p><p>We present an algorithm for this task that is computationally expensive, but feasible for systems of sizes typically used today. In practice, one calculates the recovery strategies for all potential failure scenarios a priori and stores them for later use.</p><p>We use the code in <ref type="figure" target="#fig_0">Figure 1</ref> as an illustrative example. Consider a collection of bits in the codeword whose corresponding rows in the Generator matrix sum to zero. One example is D 0 , D 2 and C 0 . We call such a collection of bits a decoding equation, because the fact that their sum is zero allows us to decode any one of its bits as long as the remaining bits are not lost. For example, if D 2 is lost, and both D 0 and C 0 are not, then this equation may be used to decode D 2 .</p><p>Suppose that we enumerate all decoding equations for a given Generator matrix, and suppose some subset F of the codeword bits are lost. Then for each bit f i ∈ F , we determine the set E i of decoding equations for f i . Formally, an equation e i ∈ E i if e i ∩F = {f i }. Our goal is to select one equation e i from each E i such that the number of elements in the union of all e i is minimized.</p><p>For example, suppose bits D 0 and D 1 in <ref type="figure" target="#fig_0">Figure 1</ref> are lost. A standard way to decode the failed bits is to use coding bits C 0 and C 1 . In equation form,</p><formula xml:id="formula_0">F = {D 0 , D 1 }, e D0 = {D 0 , D 2 , C 0 }, and e D1 = {D 1 , D 3 , C 1 }.</formula><p>Since e D0 and e D1 have distinct elements, their union is composed of six elements, which means that four are required for recovery. However, if we use {D 1 , D 2 , C 3 } for e D1 , then |e D0 ∪ e D1 | is five elements, meaning that three are required for recovery. This saves one I/O operation.</p><p>Thus, our problem is as follows: Given |F | sets of decoding equations E 0 , E 1 , . . . E |F |−1 , we wish to select one equation from each set such that the size of the union of these equations is minimized. Unfortunately, this problem is NP-Hard in |F | and |E i |. 1 However, we can solve the problem for practical values of |F | and |E i | by converting the equations into a directed, weighted graph and finding the shortest path through the graph.</p><p>Given an instance of the problem, we convert it to a graph as follows. First, we represent each decoding equation in set form as an n-element bit string. For example, {D 0 , D 2 , C 0 } is represented by 10101000.</p><p>Each graph node is also represented by an n-element bit string. There is a starting node Z whose string is all zeroes. The remaining nodes are partitioned into |F | sets labeled S 0 , S 1 , . . . S |F |−1 . Each node in S i is at the same depth (number of edges) relative to Z as any other node in S i . For each equation e 0 ∈ E 0 , there is a node s 0 ∈ S 0 whose bit string equals e 0 's bit string. There is an edge from Z to each s 0 whose weight is equal to the number of ones in s 0 's bit string.</p><p>Traversing a single level (or edge) in the graph signifies the recovery of a single bit in F . For each node s i ∈ S i , there is an edge that corresponds to each e i+1 ∈ E i+1 . This edge is to a node s i+1 ∈ S i+1 whose bit string is equal to the bitwise OR of s i and e i+1 's bit strings. The OR calculates the union of the equations leading up to s i and e i+1 , with s i+1 denoting the cumulative number of elements required for recovery up to that point. The weight of the edge is equal to the difference between the number of ones in s i and s i+1 's bit strings. The shortest path from Z to any node in S |F |−1 denotes the minimum number of elements required for recovery. If we annotate each edge with the decoding equation that creates it, then the shortest path contains the equations that are used for recovery.</p><p>To illustrate, suppose again that F = {D 0 , D 1 }, meaning f 0 = D 0 and f 1 = D 1 . The decoding equations for E 0 and E 1 are enumerated below:</p><formula xml:id="formula_1">E 0 E 1 e 0,0 = 10101000 e 1,0 = 01010100 e 0,1 = 10010010 e 1,1 = 01101110 e 0,2 = 10011101 e 1,2 = 01100001 e 0,3 = 10100111 e 1,3 = 01011011</formula><p>These equations may be converted to the graph depicted in <ref type="figure" target="#fig_1">Figure 2</ref>, which has two shortest paths of length five: {e 0,0 , e 1,2 } and {e 0,1 , e 1,0 }. Both require three bits for recovery:</p><formula xml:id="formula_2">{D 2 , C 0 , C 3 } and {D 3 , C 1 , C 2 }.</formula><p>While the graph clearly contains an exponential number of nodes, one may program Dijkstra's algorithm to determine the shortest path and only create the graph on demand. For example, in <ref type="figure" target="#fig_1">Figure 2</ref>, the dotted edges and grayed nodes will not be constructed, because the shortest path is discovered before nodes 10011101 and 10100111 are evaluated by the algorithm. Greenan et al. <ref type="bibr" target="#b8">[9]</ref> use a similar approach to enumerate the recovery equations for flat-XOR codes. Their algorithm employs pruning heuristics on the search space, rather than converting the problem into a graph. <ref type="figure" target="#fig_2">Figure 3</ref> presents the results of running the algorithm on eleven different RAID-6 erasure codes for 8-disk systems (six data, two parity). The first two codes are RDP and Even-Odd, for which I/O minimization results exist already <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b12">13]</ref>. The next three are "Minimal Density" that best fit 8-disk systems (Blaum-Roth <ref type="bibr" target="#b1">[2]</ref>, Liberation <ref type="bibr" target="#b16">[17]</ref> and Liber8tion <ref type="bibr" target="#b17">[18]</ref>), and the last six are Cauchy Reed-Solomon codes where the variable w, which specifies the number of bits stored per disk, varies from three to eight <ref type="bibr" target="#b2">[3]</ref>. For each code, we calculated the average number of bits required for recovery when one data disk fails, plotted as a percentage of the number of bits that are required when matrix inversion is used to decode.</p><p>The results show that the Miminal Density codes require fewer bits than RDP and Even-Odd, with the quirky Liber8tion code requiring the fewest bits of all codes.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RDP</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">An I/O Efficient Recovery Code</head><p>Our search for codes which exhibit both low recovery I/O and high fault tolerance led us to consider GRID codes <ref type="bibr" target="#b14">[15]</ref> as a suitable candidate. In a GRID code <ref type="figure" target="#fig_3">(Fig- ure 4)</ref>, the disks form a logical grid with each dimension being encoded using (potentially) different schemes. The GRID code allows us to use recovery I/O efficient Weaver codes in conjunction with fault tolerant STAR codes <ref type="bibr" target="#b13">[14]</ref>, thereby enabling us to capture the desirable properties of both. Weaver codes are parameterized by W(k, t) in which k is the in-degree to a parity symbol and t (fault tolerance) is the in-degree to a data symbol. The fixed in-degree limits the recovery I/O regardless of the stripe size (number of disks). This differs from all systematic erasure codes. Failures within Weaver's fault tolerance in any column are recovered entirely by the Weaver code and benefit from Weaver's efficient recovery I/O. With a Weaver code, recovery from a single disk failure can be done in two ways. The naive way of recover-  ing from a failure entails accessing the t connected parity disks. But when k &lt; t, one can also recover a failed disk by accessing any one of the t parity symbols and then using its connected k data symbols to recover the failed data symbol. Therefore, the cost to recover the failed data symbol is k + 1 I/Os. Parity symbols are recovered using their own k connected disks. Thus, recovery of an entire encoded block takes (k + 1)r + qk = r(t + k + 1) I/Os (since rt = qk), where r and q are the number of data and parity symbols per disk respectively. In some cases, Weaver codes can also recover data and parity from the same disk. This does not reduce the number of I/Os, i.e. block transfers, but does benefit MAID systems in that fewer disks must be spun up. Examining the GRID/Weaver construction reveals that the codes use very few I/Os in recovery relative to their fault tolerance and access even fewer disks <ref type="table">(Table 1)</ref>. We experiment with the most efficient (minimum distance separable-MDS) instances of Weaver codes: W(2,2), W(3,3), and W(2,4). We combine this with a STAR code with 5 data disks and 3 parity disks. The GRID(STAR, W(2,2)) tolerates 11 failures and recovers a lost encoded block (data and parity) using 4 I/Os from three disks, in one case accessing data and parity from the same disk. The number of disks that needs to be accessed remains small as fault tolerance increases. Storage overheads for these codes are substantial, but are reasonable given the high fault tolerance and their intended use in archival applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussion and Open Problems</head><p>We have corroborated our conjecture that for all XORbased erasure codes, there is a fundamental tradeoff between recovery I/O and storage overhead at a given fault tolerance. We know the extrema in this tradeoff. Replication has maximum storage overhead and recovers a data block in a single I/O. Minimum distance separable codes provide maximum storage efficiency and the algorithm we present for minimizing recovery I/O gives optimal recovery schedules. We evaluated optimal recovery for the most prevalent XOR-based erasure codes. In between these extrema, lie codes that increase storage overhead and reduce recovery I/O. We demonstrate meaningful intermediate points in the GRID/Weaver code.</p><p>It remains an open problem to formalize the tradeoff between storage efficiency and recovery I/O and construct codes that are recovery optimal. We are pursuing this problem both analytically and through automatic erasure code generation. At present, we are conducting a programmatic search of feasible generator matrices and their optimal recovery I/O schedules to find the codes with minimum I/O requirements. The exponential growth of possible codes as a function of matrix size means that we need to develop methods to prune the search both in matrix generation and in the finding of optimal recovery schedules. However, exploring the space for reasonable sized systems, up to one hundred disks, seems within reach.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Erasure-coding as a matrix-vector product.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Recovery graph when D 0 and D 1 are lost.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Minimum bits needed for recovering from single failures in RAID-6 codes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: The GRID/Weaver code. The dashed boxes indicate the two separate code dimensions.</figDesc></figure>

			<note place="foot" n="1"> Adam Buchsbaum, personal communication, reduction from Vertex Cover.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Efficient eventual consistency in Pahoehoe, an erasure-coded key-blob archive. Dependable Systems and Networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Merchant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Smathers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Uysal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Wylie</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On lowest-density MDS codes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Blaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Information Theory</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="46" to="59" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">An XOR-based erasure-resilient coding scheme</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Blomer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kalfane</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Karpinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Zuckerman</surname></persName>
		</author>
		<idno>TR-95-048</idno>
		<imprint>
			<date type="published" when="1995-08" />
		</imprint>
		<respStmt>
			<orgName>International Computer Science Institute</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Remote data checking for network coding-based distributed storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Curtmola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ateniese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Burns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cloud Computing Security Workshop</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Network coding for distributed storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Dimakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">B</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Wainwright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ramchandran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theor</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="4539" to="4551" />
			<date type="published" when="2010-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">RAID-II: a high-bandwidth network file server</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">L</forename><surname>Drapeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Computer architecture</title>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Availability in globally distributed storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Labelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">I</forename><surname>Popovici</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stokely</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Truong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Barroso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Grimes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Quinlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX OSDI</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The Google file system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Gobioff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SOSP</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Flat xor-based erasure codes in storage systems: Constructions, efficient recovery, and tradeoffs. Mass Storage Systems and Technologies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Greenan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Wylie</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Weaver codes:highly fault tolerant erasure codes for storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Hafner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX FAST</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Matrix methods for lost data reconstruction in erasure codes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Hafner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Deenadhayalan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">K</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Tomlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX FAST</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Balancing I/O response time and disk rebuild time in a RAID5 disk array</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">Y</forename><surname>Hou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">N</forename><surname>Patt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Hawaii International Conference on System Sciences</title>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Pyramid codes: Flexible schemes to trade space for access efficiency in reliable data storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Network Computing and Applications</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Star : An efficient coding scheme for correcting triple storage node failures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="889" to="901" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Grid codes: Strip-based erasure codes with high fault tolerance for storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zheng</surname></persName>
		</author>
		<idno>15:1-15:22</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Storage</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A tutorial on Reed-Solomon coding for faulttolerance in RAID-like systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Plank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software-Practice &amp; Experience</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="995" to="1012" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The RAID-6 Liberation codes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Plank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX FAST</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The RAID-6 Liber8Tion code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Plank</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. High Perform. Comput. Appl</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="242" to="251" />
			<date type="published" when="2009-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Improving storage system availability with D-GRAID</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sivathanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX FAST</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Pergamum: Replacing tape with energy efficient, reliable, disk-based archival storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">W</forename><surname>Storer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Greenan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Voruganti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX FAST</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">PRO: a popularity-based multi-threaded reconstruction optimization for RAIDstructured storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX FAST</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Rebuilding for array codes in distributed storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">G</forename><surname>Dimakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bruck</surname></persName>
		</author>
		<idno>abs/1009.3291</idno>
	</analytic>
	<monogr>
		<title level="j">CoRR</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Optimal recovery of single disk failure in RDP code storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C S</forename><surname>Lui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMETRICS</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
