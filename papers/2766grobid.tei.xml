<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:52+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Is Linux Kernel Oops Useful or Not?</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Takeshi</forename><surname>Yoshimura</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">CREST/JST</orgName>
								<orgName type="department" key="dep2">CREST/JST</orgName>
								<orgName type="institution" key="instit1">Keio University</orgName>
								<orgName type="institution" key="instit2">Keio University</orgName>
								<orgName type="institution" key="instit3">Keio University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hiroshi</forename><surname>Yamada</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">CREST/JST</orgName>
								<orgName type="department" key="dep2">CREST/JST</orgName>
								<orgName type="institution" key="instit1">Keio University</orgName>
								<orgName type="institution" key="instit2">Keio University</orgName>
								<orgName type="institution" key="instit3">Keio University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenji</forename><surname>Kono</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">CREST/JST</orgName>
								<orgName type="department" key="dep2">CREST/JST</orgName>
								<orgName type="institution" key="instit1">Keio University</orgName>
								<orgName type="institution" key="instit2">Keio University</orgName>
								<orgName type="institution" key="instit3">Keio University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Is Linux Kernel Oops Useful or Not?</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Linux kernel oops is invoked when the kernel detects an erroneous state inside itself. It kills an offending process and allows Linux to continue its operation under a compromised reliability. We investigate how reliable Linux is after a kernel oops in this paper. To investigate the reliability after a kernel oops, we analyze the scope of error propagation through an experimental campaign of fault injection in Linux 2.6.38. The error propagation scope is process-local if an error is confined in the process context that activated it, while the scope is kernel-global if an error propagates to other processes&apos; contexts or global data structures. If the scope is process-local, Linux can be reliable even after a kernel oops. Our findings are twofold. First, the error propagation scope is mostly process-local. Thus, Linux remains consistent after a kernel oops in most cases. Second, Linux stops its execution before accessing inconsistent states when kernel-global errors occur because synchronization primitives prevent the inconsistent states from being accessed by other processes.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Linux kernel oops is invoked when the kernel detects an erroneous state inside itself. It prints out an oops message and kills the offending process to allow Linux to continue its operation under a compromised reliability. After the kernel oops occurs, nothing is guaranteed because no one can tell which kernel states are consistent or not. If an inconsistent state happens to be confined in the context of the offending process, Linux is expected to be reliable even after the oops because the inconsistent state can be revoked by killing the offending process. Otherwise, the kernel becomes unreliable since its operation is based on inconsistent states.</p><p>We investigate how reliable Linux can be after a kernel oops in this paper. We introduce the concept of the scope of error propagation to investigate the reliability after a kernel oops. The error propagation scope is processlocal if an error is confined in the process context that activated it. The scope is kernel-global if an error propagates to other processes' contexts or global data structures.</p><p>The distinction between process-local and kernelglobal propagation is significant. If an error is processlocal, the kernel oops allows us to recover from the error because it revokes the inconsistent states by killing the faulty process. If an error is kernel-global, the recovery is hopeless because corrupted global data structures must be recovered in order to continue processing.</p><p>We conduct a series of fault injection experiments to investigate the scope of error propagation. Since our target is Linux bugs, we use a fault injection tool widely used in the OS community <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b8">9]</ref>. This fault injector focuses on the emulation of low-and high-level software faults, including errors specific to operating system kernels.</p><p>In our fault injection experiments, 6,738 faults (15 types of faults) are injected into Linux 2.6.38. The kernel oops is invoked in 134 out of 6,128 faults, including panic(). We follow an execution trace until either an oops or panic() is called in order to analyze the error propagation when an injected fault is activated. We track down how an injected error propagates in the kernel using the execution trace.</p><p>According to our experimental results, the Linux kernel oops is useful in handling kernel failures for the following reasons.</p><p>• The scope of error propagation is mostly processlocal in Linux. This implies that the Linux kernel oops is effective in recovering from kernel failures in most cases. Since an error is not propagated to other process contexts, the kernel can be recovered to a consistent state simply by revoking the context of the faulty process.</p><p>• Even if an error propagates to shared kernel data structures, the non-faulty processes do not access the inconsistent data because the faulty process crashes inside a critical section with a lock acquired. This suggests that Linux shows fail-stopness even when there are kernel-global errors.</p><p>The rest of this paper is organized as follows. Section 2 describes the work related to ours. Section 3 explains the software fault injector used in the experiments. Section 4 reports our experimental results. Section 5 concludes this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Linux is far from bug-free. In practice, it is almost impossible to eliminate all the bugs in Linux, despite the tremendous advances made in debugging tools, testing methodologies, static analysis, and formal methods. According to the empirical study on Linux bugs <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b0">1]</ref>, the number of bugs per line is decreasing but the increased size of the Linux code makes the total number of bugs almost constant. Microkernel-based OSes are expected to be more reliable. Minix3 can isolate error propagation <ref type="bibr" target="#b5">[6]</ref> and the seL4 can be formally verified to be correct <ref type="bibr" target="#b6">[7]</ref>. Software-implemented fault injection (SWIFI) has been conducted with emphasis placed on the different aspects of fault manifestation to better understand the kernel behavior under fault manifestation. Our focus in this paper is the "scope" of error propagation (i.e., processlocal or kernel-global). Previous work focuses on other aspects of error propagation than the scope of error propagation.</p><p>Gu et al. <ref type="bibr" target="#b4">[5]</ref> use SWIFI to characterize Linux behaviors under error manifestation. Their analysis shows that crash latencies are within 10 cycles in most cases and also shows how an error propagates between OS subsystems. Our concern in this paper is that an error propagates beyond the boundary of the process context. Even if an error propagates across subsystems, we can recover from the failure if the scope is process-local. <ref type="bibr">Pham et al. [11]</ref> use SWIFI to evaluate virtualization environments in a cloud infrastructure.</p><p>The techniques used in SWIFI are evolving. G-SWFIT precisely emulates general software faults by mutating binary executable code <ref type="bibr" target="#b3">[4]</ref>. According to the analysis in <ref type="bibr" target="#b1">[2]</ref>, G-SWFIT improves the fault injection accuracy. Unfortunately, G-SWFIT does not inject faults that are specific to Linux kernels. So, we use another fault injector that is widely used in the OS community.</p><p>Numerous mechanisms for kernel recovery have been proposed to mitigate the impact of kernel failures. Swift et al. <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b11">12]</ref> propose a kernel mechanism for manag- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Fault Injection</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Fault Injector</head><p>We conduct an experimental fault injection campaign in Linux 2.6.38 to investigate the scope of error propagation. The fault injector <ref type="bibr" target="#b7">[8]</ref> used in the experiments is widely used in the OS research community <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b13">14]</ref>. The fault injector obtained from the Nooks web site is ported to the Linux x86 kernel (ver. 2.6.38) and extended to emulate some software bugs that are not included in the original but observed in the Linux empirical bug study <ref type="bibr" target="#b9">[10]</ref>. Such extensions include the size fault that makes the size of a heap allocation smaller to emulate a heap overrun, the var fault that allocates huge local variables, and the null fault that emulates missing checks of the null pointers.</p><p>In our experiments, 15 types of faults that are injected are listed in <ref type="table" target="#tab_0">Table 1</ref>. Due to the space limitations, five faults out of 15, which are peculiar to the kernels, are explained in detail. For ease of understanding, <ref type="table" target="#tab_1">Table 2</ref> lists some examples of the injected faults on the C-language level although the injection is done on the binary level. You can refer to other papers or resources (e.g., <ref type="bibr" target="#b3">[4]</ref>) to know the details of other faults because they are common in SWIFI. while (x &lt;= 10) alloc ptr = kmalloc(10, GFP_KERNEL); ptr = NULL; free kfree(ptr); deleted.</p><p>• init: This fault creates a situation where the initialization of the variables is missed. The instructions responsible for initializing a variable are deleted to create such a situation. More concretely, it deletes an instruction that assigns an immediate value to an address lower than the stack pointer.</p><p>• irq: A situation is created where a programmer forgets to enable the interrupts after disabling them. The injector removes the calls to arch local irq restore(), which restores the disabled interrupts in Linux 2.6.38.</p><p>• off by one: This fault imitates loop boundary condition errors. The injector changes conditions such as &gt; to &gt;=, &lt; to &lt;=, and so on. For example, "jae" is changed into "ja".</p><p>• alloc: This fault makes kmalloc return NULL to emulate the shortage of the heap memory. In x86 64, kmalloc returns the address of the allocated memory through the %rax register. Thus, call kmalloc is changed into xor %rax, %rax to inject the alloc fault.</p><p>• free: This fault emulates a situation where the memory is not appropriately released. The injector removes the call to kfree, which is responsible for releasing the unused heap memory. Since kfree does not return any values, the injector simply deletes the call to kmalloc.</p><p>The injector rewrites the binary code of the running kernel to inject each type of fault. The code is rewrote at runtime as in other work <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b10">11]</ref>. The injector disassembles the binary of a randomly selected function in the kernel text segment. Since the faults injected by our injector are context-dependent, it analyzes the disassembled code and searches for proper locations to which each type of fault can be injected. For example, to inject the var fault, the injector must change at least two instructions for allocating and deallocating a large local variable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Error Scope Analysis</head><p>A trace of the executed instructions is taken from the fault activation to the error manifestation to keep track of the error propagation. A breakpoint is set in the instruction to which a fault is injected. After the fault is activated, the CPU is set into the single-step execution mode to take a trace of every instruction.</p><p>Using the execution trace, the scope of error propagation is analyzed in the same way as a taint analysis. If the injected fault produces an erroneous value, the value is marked as an "error". When the value marked as an "error" is used to calculate another value, the calculated value is also marked as an "error". If the value marked as an "error" is used in the prediction of conditional branches, all the values updated in the taken clause are marked as an "error". If no value marked as an "error" is written to a heap until an oops or panic() is called, the error is concluded to be process-local. Otherwise, the error is concluded to be kernel-global. Our analysis is conservative; i.e., an error is considered kernel-global if we are not confident that it is process-local.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experimental Results</head><p>An experimental fault injection campaign has been conducted in Linux 2.6.38 to estimate the reliability after the Linux kernel oops. In this experiment, 6,738 faults are injected to randomly selected locations. We run a workload for each injected fault to activate the faults. We use six benchmarks that all stress the kernel. The six workloads are, 1) UnixBench on ext4, 2) UnixBench on fat, 3) UnixBench on USB, 4) Netperf, 5) Apaly, and 6) Restartd. UnixBench calls a lot of file-and processrelated system calls and puts a heavy workload on current file systems. Netperf calls network-related system calls. Aplay invokes sound device drivers. As a benchmark, we listen to a wav file for 10 seconds. Restartd is a benchmark to restart all the system daemons. We run our target system on a VMware workstation to reduce the time for rebooting the kernel after failures. The VMware workstation sometimes detects a critical error in the guest OS and terminates the execution of the guest OS.    <ref type="figure" target="#fig_1">Figure 1</ref> shows the overall results of our fault injection experiments ("FSV" means fail silence violation and "TERM" means unexpected termination by VMM in <ref type="figure" target="#fig_1">Figure 1(b)</ref>). There are a total of 6,738 faults injected in our experiments and 13% of the injected faults are activated. Every workload runs 1122 times and 6 faults manifests failures before the workloads start. The kernel oops are called in 14% (124 out of 887) and panic() is called in 1.1% (10 out of 887). 9.9% of the manifested errors do not invoke a kernel oops because they result in fail silence violations, hangs, or unexpected terminations by VMM. 75% of the faults are not manifested.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Scope of Error Propagation</head><p>Since our focus is on the reliability after the kernel oops, we investigate the scope of error propagation in the cases of the 124 kernel oops plus the 10 panic (because most panic() is called by the oops procedure). <ref type="figure" target="#fig_2">Figure 2</ref> summarizes the scope of error propagation. According to our experiments, 73% (98 out of 134) of the kernel oops are process-local, while 27% (36 out of 134) of them are kernel-global. This suggests that three quarters of the kernel oops can be recovered simply by revoking the faulty process.</p><p>This high rate of process-local errors is attributed to a defensive style of coding in Linux. Linux contains a lot of self-checking codes. For example, BUG ON macro, which is similar to assert() in C, checks a given predicate and calls a kernel oops if the predicate is true. Some errors injected by our injector are caught by BUG ON and their propagation is prevented.</p><p>A typical example we encountered during the ex-  periments is as follows. The irq fault, which removes a call to arch local irq restore, which restores disabled interrupts. When this fault is activated, the kernel continues to run with the interrupts disabled. Meanwhile, lookup bh lru(bdev, block, size) is invoked, which is assumed to be called with the interrupts enabled. It eventually calls check irqs on, which executes BUG ON(irq disabled()) to check this assumption. Since the interrupts are disabled here (if the fault is not injected, the interrupts are enabled here), BUG ON macro detects this incorrect status of interrupts.</p><p>Note that our analysis is very conservative. The rate of process-local errors is expected to be higher than 73% in reality. This is because the power of our analyzer of the propagation scope is very limited, and concludes an error is kernel-global if it is not confident that the error is process-local.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Estimating Reliability after Kernel Oops</head><p>According to the results of our analysis on the scope of error propagation, Linux is expected to be reliable with a probability of 73% after the kernel oops. We observe what happens if we run another workload after killing a faulty process on the kernel oops to confirm that the Linux kernel can continue to run after the kernel oops. Note that the kernel cannot continue to run after crashes other than the kernel oops. In reality, it is quite difficult to distinguish process-local errors from kernel-global ones. So, we run a second workload after every kernel oops, regardless of whether it is caused by process-local or kernel-global errors. Just after the kernel oops occur, we also remove the injected fault to analyze the effect of the error propagation caused by it. <ref type="figure" target="#fig_3">Figure 3</ref> shows the summary of the kernel behavior after the kernel oops. The converge of the workloads run after the kernel oops are quite important for precisely estimating the reliability of the Linux kernel. To this end, we inject an identical fault again and again that caused the kernel oops in the previous experiment and run different workloads after the kernel oops. So, the total number of errors is larger in <ref type="figure" target="#fig_3">Figure 3</ref> than <ref type="figure" target="#fig_2">Figure 2</ref>.</p><p>No errors manifest in 68% of the process-local errors after the kernel oops. This probability is less than our expectation, where no errors manifest in almost all the cases. Even after the process-local errors, deadlock occurs in 29% (132 out of 463). This is because a faulty process is killed with the lock acquired. Although no global data structures are corrupted in process-local errors, the faulty process holds locks and killing it results in deadlocks after the kernel oops.</p><p>In kernel-global errors, no errors manifest in 25% after the kernel oops. This is because the workloads run after the kernel oops do not access the shared data corrupted by the faulty process. When the corrupted data is accessed after the kernel oops, deadlock occurs in most cases. In our experiments, deadlock occurs in 47%. An error inside a critical section tends to result in a failure within the critical section because an error does not usually propagate a long way. Since the accesses to global data structures are controlled by synchronization primitives, the offending process is killed with the lock held and deadlocks are caused afterwards. This behavior of the Linux kernel is preferable because it contributes to fail-stopness after the kernel oops. This result is interesting because no further data corruption occurs even after kernel-global errors in 72% (= 25% + 47%).</p><p>In summary, if we continue to run the Linux kernel after the kernel oops, it runs reliably or stops its execution before trying to access corrupted data with a probability of 91% (not manifested and deadlock in <ref type="figure" target="#fig_3">Figure 3)</ref>. While the kernel compromised by the process-local errors does not always succeed in continuing execution, kernel-global errors do not cause fatal failures in which the operation continues using inconsistent and corrupted data. In other words, the Linux kernel has a good failstopness property after the kernel oops.</p><p>Killing a faulty process sometimes leads to another problem. No proc in <ref type="figure" target="#fig_3">Figure 3</ref> indicates cases where workloads running after the kernel oops cannot run as usual because the killed process is mandatory to continue the execution of the workloads. For example, UnixBench on USB cannot be started after kernel oops because a kernel daemon monitoring the plugs for USB devices is killed.</p><p>In process-local errors, panic() is called in 1.5% of the cases. It is observed when the kernel detects a buffer overrun in a kernel stack with a canary, or the kernel finds that the faulty contexts are those for interrupts or the init process in the kernel oops procedure. The kernel determines to call panic() regardless of the state of its data structure, and therefore, panic() is observed even when errors are process-local.</p><p>In kernel-global errors, oops and panic() are called in 23% of the cases. In these cases, the errors that propagate to global data structures are simple, so access to them can be caught with the kernel oops. Unfortunately, there are three cases (labeled as erroneous in <ref type="figure" target="#fig_3">Figure 3</ref>) in which the Linux kernel continues its operation using inconsistent and corrupted data structures. However, this terrible situation happens only in 0.5% (3 out of 589 errors) of the cases in our experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We investigated how reliable Linux is after a kernel oops in this paper. We introduced the concept of the scope of error propagation to investigate the reliability after a kernel oops. The error propagation scope is process-local if an error is confined in the process context that activated it. The scope is kernel-global if an error propagates to other processes' contexts or global data structures. Our findings are twofold. First, the error propagation scope is mostly process-local. Thus, Linux remains consistent after a kernel oops in most cases. Second, Linux stops its execution before accessing inconsistent states when kernel-global errors occur because synchronization primitives prevent the inconsistent states from being accessed by other processes.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Observed Failures This figure shows the relative frequency with which ac- tivated faults manifest different categories of failures. The number at the end of each bar represents the total number of activated faults.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Overall Fault Injection Results.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Scope of Error Propagation This figure shows the relative frequency with which propagated errors are process-local or kernel-global. The number at the end of each bar indicates the total number of investigated errors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Kernel behavior after oops This figure shows the relative frequency with which the kernel manifests different failure categories after oops recovery. The number at the end of each bar indicates the total number of investigated kernel behaviors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Fault types 
Fault types Description 
branch 
deletes branches 
inverse 
flips predictions 
ptr 
destroys pointers 
dstsrc 
destroys assignments 
interface 
omits function arguments 
init 
omits initialization 
irq 
deletes restoration of interrupts 
off by one 
e.g., ja change into jae 
alloc 
kmalloc returns NULL 
free 
deletes kfree 
size 
makes heap alloc. smaller 
bcopy 
makes string functions overrun 
loop 
destroys loop condition 
var 
allocates huge local valuable 
null 
omits NULL check 

ing and recovering from device driver failures. Other-
world [3] enables us to restart the kernel without dis-
carding the applications' memory states. Phase-based 
Reboot [14] shortens the downtime involved in a reboot-
based recovery. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><head>Table 2 : C-Language Level View of the Injected Faults.</head><label>2</label><figDesc></figDesc><table>Fault 
Before 
After 
init 
int x = 1; 
int x; 
irq 
arch_local_irq_restore(); 
deleted. 
off by one while (x &lt; 10) 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head></head><label></label><figDesc>This figure shows the relative frequency with which in- jected faults are activated or not. The number at the end of each bar represents the total number of injected faults.</figDesc><table>0% 

20% 

40% 

60% 

80% 

100% 

branch 
inverse 
ptr 
dstsrc 
interface 
init 
irq 
off-by-one 
alloc 
free 
size 
bcopy 
loop 
var 
null 
total 

576 
576 
576 
571 
150 
540 
97 
566 
349 
504 
240 
522 
571 
324 
576 
6738 
activated 
not activated 

(a): Activated/Not Activated Faults 
0% 

20% 

40% 

60% 

80% 

100% 

branch 
inverse 
ptr 
dstsrc 
interface 
init 
irq 
off-by-one 
alloc 
free 
size 
bcopy 
loop 
var 
null 
total 

72 
73 
90 
65 
18 
102 
37 
55 
55 
44 
2 
48 
70 
65 
71 
887 

panic 
oops 
FSV 
hang 
TERM 
not manifested 

</table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">An Empirical Study of Operating Systems Errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM Symposium on Operating Systems Principles (SOSP &apos;01)</title>
		<meeting>the 18th ACM Symposium on Operating Systems Principles (SOSP &apos;01)</meeting>
		<imprint>
			<date type="published" when="2001-10" />
			<biblScope unit="page" from="73" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Experimental analysis of binary-level software fault injection in complex software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cotroneo</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lanzaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Natella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barbosa</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE 9th European Dependable Computing Conference (EDCC &apos;12</title>
		<meeting>the IEEE 9th European Dependable Computing Conference (EDCC &apos;12</meeting>
		<imprint>
			<date type="published" when="2012-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Otherworld -Giving Applications a Change to Servive OS Kernel Crashes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Depoutovitch</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stumm</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th European Conference on Computer Systems (EuroSys &apos;10)</title>
		<meeting>the 5th European Conference on Computer Systems (EuroSys &apos;10)</meeting>
		<imprint>
			<date type="published" when="2010-04" />
			<biblScope unit="page" from="181" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Emulation of software faults: A field data study and a practical approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Duraes</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madeira</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="849" to="867" />
			<date type="published" when="2006-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Characterization of Linux Kernel Behavior under Errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Kalbarczyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 IEEE International Conference on Dependable Systems and Networks (DSN &apos;03)</title>
		<meeting>the 2003 IEEE International Conference on Dependable Systems and Networks (DSN &apos;03)</meeting>
		<imprint>
			<date type="published" when="2003-06" />
			<biblScope unit="page" from="459" to="468" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Fault isolation for device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herder</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">N</forename><surname>Bos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Gras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Homburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tanenbaum</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 39st Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN &apos;09</title>
		<meeting>of the 39st Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN &apos;09</meeting>
		<imprint>
			<date type="published" when="2009-06" />
			<biblScope unit="page" from="33" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Formal verification of an os kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klein</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Elphinstone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Andronick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Derrin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Elkaduwe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Engelhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Norrish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kolanski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tuch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Winwood</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM symposium on Operating systems principles (SOSP &apos;09</title>
		<meeting>the 22nd ACM symposium on Operating systems principles (SOSP &apos;09</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The Systematic Improvement of Fault Tolerance in the Rio File Cache</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">G</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Symposium on Fault-Tolerant Computing (FTCS &apos;99)</title>
		<meeting>the 29th Symposium on Fault-Tolerant Computing (FTCS &apos;99)</meeting>
		<imprint>
			<date type="published" when="1999-06" />
			<biblScope unit="page" from="76" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Design and Verification of the Rio File Cache</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">G</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="322" to="337" />
			<date type="published" when="2001-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Faults in Linux: Ten Years Later</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Palix</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Calvéscalv´calvés</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muller</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
		<idno>ASP- LOS &apos;11</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the ACM International Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="2011-03" />
			<biblScope unit="page" from="305" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Cloudval: A framework for validation of virtualization environment in cloud infrastructure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pham</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kalbarczyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>And Iyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 41st Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN &apos;11</title>
		<meeting>of the 41st Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN &apos;11</meeting>
		<imprint>
			<date type="published" when="2011-06" />
			<biblScope unit="page" from="189" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Recoverying device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Annamalai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Levy</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th USENIX Symposium on Operating Systems Design and Implementation (OSDI &apos;04</title>
		<meeting>the 6th USENIX Symposium on Operating Systems Design and Implementation (OSDI &apos;04</meeting>
		<imprint>
			<date type="published" when="2004-12" />
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Improving the Reliability of Commodity Operating Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Levy</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th ACM Symposium on Operating Systems Principles (SOSP &apos;03)</title>
		<meeting>the 19th ACM Symposium on Operating Systems Principles (SOSP &apos;03)</meeting>
		<imprint>
			<date type="published" when="2003-10" />
			<biblScope unit="page" from="207" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Phase-based Reboot: Reusing Operating System Execution Phases for Cheap Reboot-based Recovery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yamakita</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Yamada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kono</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 41st Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN &apos;11)</title>
		<meeting>of the 41st Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN &apos;11)</meeting>
		<imprint>
			<date type="published" when="2011-06" />
			<biblScope unit="page" from="169" to="180" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
