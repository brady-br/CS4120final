<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:14+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. Agamotto: Accelerating Kernel Driver Fuzzing with Lightweight Virtual Machine Checkpoints Agamotto: Accelerating Kernel Driver Fuzzing with Lightweight Virtual Machine Checkpoints</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dokyung</forename><surname>Song</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Felicitas</forename><surname>Hetzelt</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonghwan</forename><surname>Kim</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brent</forename><forename type="middle">Byunghoon</forename><surname>Kang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Franz</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dokyung</forename><surname>Song</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Felicitas</forename><surname>Hetzelt</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonghwan</forename><surname>Kim</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaist</forename><surname>Brent</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Byunghoon</forename><surname>Kang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Pierre</forename><surname>Seifert</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Franz</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Irvine</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Technische Universität Berlin</orgName>
								<orgName type="institution" key="instit2">KAIST</orgName>
								<address>
									<addrLine>Jean-Pierre Seifert</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">Technische Universität Berlin</orgName>
								<orgName type="institution" key="instit2">University of California</orgName>
								<address>
									<settlement>Irvine</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Irvine</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution" key="instit1">Technische Universität Berlin</orgName>
								<orgName type="institution" key="instit2">KAIST</orgName>
								<orgName type="institution" key="instit3">Technische Universität Berlin</orgName>
								<orgName type="institution" key="instit4">University of California</orgName>
								<address>
									<settlement>Irvine</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. Agamotto: Accelerating Kernel Driver Fuzzing with Lightweight Virtual Machine Checkpoints Agamotto: Accelerating Kernel Driver Fuzzing with Lightweight Virtual Machine Checkpoints</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the 978-1-939133-17-5</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Kernel-mode drivers are challenging to analyze for vulner-abilities, yet play a critical role in maintaining the security of OS kernels. Their wide attack surface, exposed via both the system call interface and the peripheral interface, is often found to be the most direct attack vector to compromise an OS kernel. Researchers therefore have proposed many fuzzing techniques to find vulnerabilities in kernel drivers. However, the performance of kernel fuzzers is still lacking, for reasons such as prolonged execution of kernel code, interference between test inputs, and kernel crashes. This paper proposes lightweight virtual machine check-pointing as a new primitive that enables high-throughput kernel driver fuzzing. Our key insight is that kernel driver fuzzers frequently execute similar test cases in a row, and that their performance can be improved by dynamically creating multiple checkpoints while executing test cases and skipping parts of test cases using the created checkpoints. We built a system, dubbed Agamotto, around the virtual machine check-pointing primitive and evaluated it by fuzzing the peripheral attack surface of USB and PCI drivers in Linux. The results are convincing. Agamotto improved the performance of the state-of-the-art kernel fuzzer, Syzkaller, by 66.6% on average in fuzzing 8 USB drivers, and an AFL-based PCI fuzzer by 21.6% in fuzzing 4 PCI drivers, without modifying their underlying input generation algorithm.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Device drivers are the leading cause of kernel vulnerabilities <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b45">47,</ref><ref type="bibr" target="#b54">56]</ref>. A primary reason is the breadth and variety of driver implementations, which impedes scalable and coherent security analysis. Worse, they expose a richer attack surface than other kernel subsystems: kernel-mode drivers expose a peripheral attack surface in addition to the system call attack surface. Consequently, vulnerabilities in device drivers have been frequently discovered and exploited by adversaries through both attack surfaces in local and remote attack scenarios <ref type="bibr" target="#b5">[7,</ref><ref type="bibr" target="#b8">10,</ref><ref type="bibr" target="#b10">12,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr" target="#b18">20,</ref><ref type="bibr" target="#b40">42]</ref>.</p><p>In practice, fuzzing has proven to be effective at finding vulnerabilities in different kernel subsystems, including device drivers <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b16">18,</ref><ref type="bibr" target="#b22">24,</ref><ref type="bibr" target="#b24">26,</ref><ref type="bibr" target="#b27">29,</ref><ref type="bibr" target="#b44">46,</ref><ref type="bibr" target="#b51">53,</ref><ref type="bibr" target="#b62">64]</ref>. Many techniques have been proposed to improve kernel fuzzing, e.g., via hand-written input grammars <ref type="bibr" target="#b22">[24]</ref> or various forms of static and dynamic analysis <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b16">18,</ref><ref type="bibr" target="#b24">26,</ref><ref type="bibr" target="#b27">29,</ref><ref type="bibr" target="#b44">46,</ref><ref type="bibr" target="#b51">53,</ref><ref type="bibr" target="#b62">64]</ref>. For fuzzing device drivers, Syzkaller represents the state-of-the-art, incorporating many of the proposed techniques <ref type="bibr" target="#b22">[24]</ref>. It recently added support for fuzzing the peripheral attack surface of USB device drivers in Linux, which leverages all of its existing smart fuzzing capabilities such as grammar-and coverage-guidance in input generation. In its early development stage, Syzkaller already discovered hundreds of vulnerabilities from a wide range of device drivers <ref type="bibr" target="#b21">[23]</ref>, demonstrating its effectiveness.</p><p>However, despite these recent developments, highthroughput kernel driver fuzzing still remains challenging. A driver's execution can easily be prolonged during its loading and initialization, or peripheral input processing in general. Low-priority, time-consuming tasks in kernel space are typically processed asynchronously and in a deferred manner, increasing total input processing time. Also, executing each test case may change the driver's internal state, which, in turn, can negatively influence subsequent test case executions. This influence can result in the driver locking itself up <ref type="bibr" target="#b16">[18,</ref><ref type="bibr" target="#b53">55]</ref>, or unstable system state in general, when, for example, a memory corruption bug corrupts a wider system state. Unloading and reloading the driver after executing each test case, and rebooting the system after hitting a bug, can prevent the interference between test case executions, but doing so incurs a significant reduction in fuzzing throughput. As an alternative, prior work used a system snapshot created at system startup to always restore a clean state of the system for each test case, skipping time-consuming reboots. However, snapshot techniques at the virtual machine level without optimizations can be too costly (e.g., QEMU's VM snapshot <ref type="bibr" target="#b0">[1]</ref>), and user-mode system snapshot techniques either suffer from similar performance problems <ref type="bibr" target="#b1">[2]</ref> or require extensive driver porting efforts when a user-mode kernel is used <ref type="bibr" target="#b62">[64]</ref>. This paper proposes a new primitive-dynamic virtual machine checkpointing-to address the aforementioned challenges and enable high-throughput, clean-state kernel driver fuzzing. The core idea is to continuously create checkpoints during a fuzzing run in order to skip previously observed, and checkpointed operations that a kernel driver fuzzer performs. We find that test cases generated by fuzzers often have a substantial amount of similarities between them, leading to a repeated traversal of identical target driver states. Virtual machine checkpoints, strategically created by our checkpoint management policies, can be used to directly restore the virtual machine state established by time-consuming operations without repeatedly executing them. This primitive reduces the average test case execution time and, by design, ensures that no residual states remain after executing a test case; even if the test case causes a kernel panic, a known virtual machine state can be quickly restored from an existing checkpoint.</p><p>We built a system, called Agamotto 1 , around this new virtual machine checkpointing primitive, which can transparently accelerate kernel driver fuzzers regardless of the OS and the peripheral bus on which a target driver operates. Agamotto abstracts away from the heterogeneity of the device drivers and OSs, leveraging our virtual machine checkpointing primitive together with other commodity virtual machine introspection mechanisms that are readily available for different OSs. Agamotto is also fuzzer-agnostic, as it provides an abstract fuzzer interface that can be implemented to accelerate any existing kernel driver fuzzers.</p><p>Different forms of virtual machine checkpointing mechanisms have been used in many contexts for high availability (e.g., fault tolerance or live migration) <ref type="bibr" target="#b14">[16,</ref><ref type="bibr" target="#b17">19]</ref>, or debugging and introspection purposes <ref type="bibr" target="#b19">[21,</ref><ref type="bibr" target="#b32">34]</ref>. In these contexts, checkpoints are typically created on a single timeline, which together describe a single execution path that has been realized in production, debugging, or introspection settings. In contrast, checkpoints created during a fuzzing run describe multiple possible execution paths that can be realized in adversarial settings depending on the input. Under multi-path exploration, virtual machine checkpoints are frequently created, and used for virtual machine restoration; therefore, achieving time and space efficiency of checkpointing and restoration mechanisms becomes a key challenge. To address this, we heavily optimized both virtual machine checkpointing and restoration mechanisms, making their run-time and space overheads suitable for high-throughput fuzzing.</p><p>We thoroughly and conservatively evaluated the run-time and memory overheads of our proposed checkpointing primitives as well as the effectiveness of our system, Agamotto. The results show that the checkpointing primitive creates a new promising dimension in the optimization space of kernel driver fuzzing. In fuzzing 8 USB and 4 PCI drivers, 35.6% of test case executions on average skipped one or more opera-1 Available at: https://github.com/securesystemslab/agamotto tions by directly restoring the virtual machine from a checkpoint automatically created and managed by Agamotto. The creation and management of checkpoints incur a run-time overhead, but their impact on the fuzzing throughput is significantly reduced with our controlled checkpoint creation and optimized checkpointing primitives. Overall, the utility of multiple checkpoints created by Agamotto outweighed the cost; Agamotto improved the throughput of USB and PCI driver fuzzing, on average, by 66.6% and 21.6%, respectively. Moreover, as fuzzing went deeper, Agamotto became more effective-the throughput increased by up to 70.5%-thanks to the checkpoints created in deeper code paths. This is without making any change to the fuzzing algorithm (i.e., input generation algorithm) of the fuzzers we used. This means that our approach leverages an overlooked aspect of the fuzzing algorithm; the fuzzing algorithms employed by state-of-the-art fuzzers produce many similar test cases during a fuzzing run, and thus can benefit from checkpoints created while executing earlier test cases. Further improvement could also be possible by optimizing Agamotto's dynamic checkpointing policies together with the fuzzing algorithm itself.</p><p>In summary, we make the following contributions:</p><p>• A new primitive in kernel driver fuzzing. We introduce dynamic virtual machine checkpointing to accelerate kernel driver fuzzing. This new primitive is OS-, bus-and driver-agnostic, since it operates at the virtual machine level" and it opens a new dimension in the optimization space of kernel driver fuzzing.</p><p>• Checkpoint management policies and optimization techniques. We present checkpoint management policies that can increase the utility of checkpoints created during our dynamic checkpointing process. We also present virtual machine checkpointing and restoration algorithms optimized for fuzzers' multi-path exploration.</p><p>• Improved kernel driver fuzzing throughput. By applying the proposed techniques to a state-of-the-art USB fuzzer, Syzkaller, we improved its throughput by 66.6% on average, without modifying the underlying fuzzing algorithm. We also built a fuzzer for PCI drivers based on AFL, and improved its throughput by 21.6% on average.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Motivation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Peripheral Attack Surface</head><p>Kernel subsystems are typically exposed to adversaries through the system call interface. Device drivers expose an additional attack surface: the peripheral interface. This attack surface is subject to physical attacks such as an "evil maid attack" <ref type="bibr" target="#b50">[52]</ref>, remote attacks such as an "airborne attack" <ref type="bibr">[6,</ref><ref type="bibr" target="#b8">10,</ref><ref type="bibr" target="#b10">12]</ref>, or even social engineering attacks <ref type="bibr" target="#b59">[61]</ref>. An attacker having physical access to the victim system, e.g., an evil maid, can compromise the system by physically connecting malicious peripherals. A remote attacker, who can reach communication peripherals such as Wi-Fi or Ethernet controllers, can remotely compromise the system by attacking these controllers as well as their device drivers.</p><p>Scope. This paper investigates the USB and PCI peripheral attack surfaces of kernel-mode drivers. Our choice was motivated by (i) their accessibility to potential adversaries, as exemplified by real-world attacks originating in USB or PCI devices <ref type="bibr" target="#b8">[10,</ref><ref type="bibr" target="#b10">12,</ref><ref type="bibr" target="#b18">20,</ref><ref type="bibr" target="#b40">42]</ref>, and (ii) their widespread use. We find that many security-sensitive devices, such as communication peripherals that have their own external access vector, operate on USB, PCI, or both. According to a survey on Linux device drivers <ref type="bibr" target="#b29">[31]</ref>, more than 70% of drivers target either USB or PCI devices. Hundreds of bugs already found by Syzkaller's USB fuzzer are from a wide range of driver classes <ref type="bibr" target="#b21">[23]</ref>, which also reflects the prevalence of USB devices. Although this paper investigates two peripheral buses, we emphasize that our approach is not bus-specific. Any fuzzer for a peripheral attack surface, regardless of its underlying I/O interception mechanism, can be accelerated with our approach. We provide more insight on I/O interception in Section 3.6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Why Use Snapshots?</head><p>Prior work used different snapshot techniques for fuzzing OS kernel subsystems <ref type="bibr" target="#b1">[2]</ref> and user-space programs <ref type="bibr" target="#b61">[63,</ref><ref type="bibr" target="#b63">65]</ref>. The basic idea is to snapshot the target program before it starts processing input and run the program from that snapshot for each test input. This means that every test input executes on the same, clean state of the target program. No residual state remains, by construction, after each iteration of the fuzzing loop. Test inputs do not interfere with each other, increasing the reproducibility of bugs <ref type="bibr" target="#b62">[64]</ref>. Even when a test input corrupts the program state by hitting bugs, a fresh target program state can always be restored from an existing snapshot, which effectively provides crash resilience. Test inputs after a crash can execute without re-executing time-consuming initial bootstrap operations (e.g., system reboot in kernel fuzzing). Fuzzers for user-space programs typically achieve this using fork(). A new, fresh child process is forked from a single parent process for each test input, the performance of which is optimized via the copy-on-write mechanism. Several kernel fuzzers also use different forms of snapshots for a reboot-free and reproducible fuzzing <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b62">64]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Why Not Use Snapshots?</head><p>Although snapshot techniques ensure clean-state fuzzing, the snapshot operations themselves may pose a non-negligible overhead. In particular, system-wide snapshot techniques, e.g., using an emulated, user-mode virtual machine with a forkbased snapshot technique <ref type="bibr" target="#b1">[2]</ref>, or using a hardware-accelerated virtual machine with a full memory snapshot technique, can be expensive. Several fuzzing tools do not use snapshot techniques at all <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b36">38,</ref><ref type="bibr" target="#b51">53]</ref>, due in part to the overhead. For example, LibFuzzer <ref type="bibr" target="#b36">[38]</ref>, an in-process user-space fuzzer, and Syzkaller <ref type="bibr" target="#b22">[24]</ref>, a state-of-the-art kernel fuzzer, execute each test case on the same running instance of the program, and cleaning the program state is left to the user. The user must write cleanup routines to clean up global states that may persist across fuzzing loop iterations. To reduce the overhead associated with virtual machine snapshots, a library OS approach was proposed <ref type="bibr" target="#b62">[64]</ref>. This approach, however, lacks compatibility with kernel-mode drivers; it requires manual efforts (or a sophisticated tool <ref type="bibr" target="#b11">[13]</ref>) to port device drivers into user-mode ones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Design</head><p>This paper proposes dynamic virtual machine checkpointing as a key primitive to improve the performance of kernel driver fuzzing. The key idea is to dynamically create checkpoints during a fuzzing run, and use these checkpoints to skip timeconsuming parts in the execution of test cases. Recurring sequences of operations that test cases perform need not be executed many times; instead, the state of a virtual machine established by such operations, once checkpointed, can be directly restored from a checkpoint. This idea underpins the design of our system, Agamotto.</p><p>Agamotto addresses the shortcomings of prior work, as described in <ref type="table" target="#tab_0">Table 1</ref>. It uses virtual machine snapshots (or "checkpoints") and thus inherits all of its advantages-cleanstate, reboot-free fuzzing. In contrast to prior snapshot-based approaches, which used a single snapshot created at a fixed point in time (usually at program startup), however, Agamotto creates multiple checkpoints automatically at strategic points during a fuzzing run. These checkpoints allow Agamotto to skip initial parts of many test cases, improving the overall fuzzing performance. In addition, we heavily optimized individual virtual machine checkpointing primitives for an efficient multi-path exploration, which limits the performance impact of the primitives themselves.  <ref type="figure" target="#fig_0">Figure 1</ref> shows a high-level overview of Agamotto. The architecture of Agamotto takes the form of a typical virtual machine introspection infrastructure. A full operating system including the kernel-mode device driver-the fuzzing target-runs within a guest virtual machine. Unlike prior work <ref type="bibr" target="#b1">[2]</ref>, Agamotto does not impose any constraint on the mode of execution; the guest virtual machine can execute natively, using hardware support (e.g., Intel's Virtual Machine Extensions <ref type="bibr" target="#b26">[28]</ref>) when available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association 29th USENIX Security Symposium 2543</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">System Overview</head><p>The fuzzer, whose primary task is to generate test cases and process their execution feedback, is placed outside this virtual machine, running alongside the virtual machine monitor. Some kernel fuzzers such as Syzkaller place the fuzzer inside the guest virtual machine. This architecture is not suitable when using virtual machine checkpointing, because, as we restore the virtual machine from a checkpoint, the fuzzer's internal states about the fuzzing progress would also get restored and thus lost. By placing the fuzzer outside the virtual machine, the fuzzer survives virtual machine restorations. Moreover, the fuzzer is shielded against guest kernel crashes and subsequent virtual machine reboots, limiting their impact on the fuzzing progress.</p><p>The fuzzer interface is a fuzzer abstraction layer that hides details about individual fuzzers from other components. A new fuzzer can be added by implementing various callbacks defined in this interface. These callbacks are invoked by the fuzzing driver, the core component of Agamotto placed inside the virtual machine monitor, which (i) drives the fuzzing loop interacting with both the fuzzer as well as the guest virtual machine, and (ii) creates and manages virtual machine checkpoints. The guest agent, running inside the guest virtual machine, provides the fuzzing driver with finer-grained virtual machine introspection capabilities. For example, as the guest agent starts at boot, it notifies the fuzzing driver of the boot event, so that it can start the fuzzing loop. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Fuzzing Loop</head><p>The fuzzing driver component of Agamotto drives the main fuzzing loop. In each iteration of the fuzzing loop, a fuzzer generates a single test case, executes it, and processes the result of its execution as feedback. In fuzzing event-driven systems such as OS kernels, each test case generated by the fuzzer can be defined as the sequence of actions it performs on the target system. Formally, let S = {S 0 , S 1 , ..., S N } be the set of states of the fuzzing target, and T be a fuzzer-generated test case, which comprises a sequence of N actions, denoted by an ordered set {a 1 , a 2 , ..., a N }. An execution of T, denoted by a function exec(T), is a sequential execution of actions in T on the fuzzing target. Each action a i ∈ T (for i ∈ {1, ..., N}) moves the state of the fuzzing target from S i−1 to S i . <ref type="bibr" target="#b1">2</ref> The target state observed by the fuzzer (e.g., coverage) is denoted by R = {R 1 , R 2 , ..., R N }, where each element R i ⊂ S i is the fuzzer-observed state of the fuzzing target after executing a i . We use this notation throughout the paper. <ref type="figure" target="#fig_1">Figure 2</ref> depicts Agamotto's fuzzing loop in comparison with Syzkaller's fuzzing loop using the above notation. The differences are (i) the added flows into checkpoint and restore and (ii) the removed flows into cleanup and reboot. Virtual machine restoration is initiated after generating, but before executing, a given test case. A checkpoint request is issued and evaluated after each action of a test case. Agamotto skips both cleanup and reboot, since a consistent virtual machine state is always restored from a checkpoint without requiring manual cleanup, even after a crash.</p><p>After the guest virtual machine boots, but before it starts executing any test case ( 1 in <ref type="figure" target="#fig_1">Figure 2</ref>), the first checkpoint, which we call the root checkpoint, is created ( 1a ). Then, the fuzzer generates a test case ( 2 ) and starts executing it ( 3 ). Based on (i) the test case just generated and (ii) available checkpoints, the fuzzer decides what checkpoint the test case can start executing from and restores the virtual machine from the chosen checkpoint ( 3a ). Initial parts of the test case, the result of which is already contained in the checkpoint, are skipped.</p><p>During the execution of a test case, secondary checkpoints are requested and created according to a configurable checkpoint policy. After executing each action, the test case executing inside the guest virtual machine sends a checkpoint request to the fuzzer ( 3b ). Then Agamotto's checkpoint policy decides whether to checkpoint the virtual machine or not.</p><p>Once a test case has been executed, either successfully, with a failure (e.g., timeout), or with a system failure (e.g., kernel crash), the execution result (e.g., coverage) is sent to and subsequently processed by the fuzzer ( 4 ). If a test case did not execute in full, but only until kth action, a k , due to timeouts or system failures, the result for only the executed parts of the test case, {R 1 , R 2 , ..., R k }, will be sent to the fuzzer.</p><p>Since restoring the virtual machine entails a full system cleanup, Agamotto skips an explicit cleanup process, if any ( 5 ). To avoid influence between iterations, existing kernel driver fuzzers either perform an explicit cleanup <ref type="bibr" target="#b22">[24]</ref> or simply ignore the issue <ref type="bibr" target="#b16">[18,</ref><ref type="bibr" target="#b53">55]</ref>. Agamotto uses virtual machine restoration, which does not allow any internal system state, even corrupted or inconsistent ones created by kernel bugs or panics, to transfer between iterations, without requiring manually-written cleanup routines.</p><p>A bug may occur during the cleanup process that we skip. However, potential bugs that arise in the cleanup process can be found by actively fuzzing the cleanup routines. This way, a cleanup routine can be tested more thoroughly, fully leveraging whatever smart fuzzing capabilities that the fuzzer provides. For example, a fuzzer may generate a corner test case that calls, the cleanup routine multiple times in between other actions, which may trigger more interesting and potentially more dangerous behavior of the driver under test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Checkpoint Store and Search</head><p>While the fuzzing loop is running, multiple checkpoints get created, which we store in Agamotto's checkpoint storage. To reduce the overhead induced by processing QEMU's snapshot format we manually manage the (re)storing of guest and device memory pages and use memory-backed volatile storage to capture the remaining virtual machine state.</p><p>The volatile state of a virtual machine comprises its CPU and memory state, and any bookkeeping information about <ref type="figure">Figure 3</ref>: Checkpoint tree example.</p><formula xml:id="formula_0">R A C B … Node Label R {} A {a 1 , a 2 } B {a 1 , a 2 , a 3 , a 4 } C {a 1 , a 2 , a 5 , a 6 , a 7 }</formula><p>the virtual machine such as device states kept by the virtual machine monitor. A virtual machine checkpoint must contain all the volatile information to be able to fully restore the state of a virtual machine at a later point in time.</p><p>The state of a virtual machine upon each checkpoint request can be attributed to the executed part of the test case. Therefore, we label each newly created checkpoint as the prefix of a test case that represents only the executed part of a test case. That is, given a test case, T = {a 1 , a 2 , ..., a N }, the checkpoint created after executing kth action is labeled as</p><formula xml:id="formula_1">T 1..k = {a 1 , a 2 , ..., a k }.</formula><p>Since the root checkpoint is requested when no part of any test case has executed, it is labeled as an empty test case. Checkpoints subsequently created are marked as a non-empty test case. Checkpoints are stored in a prefix tree, which we call a checkpoint tree. Each node in this tree represents a checkpoint and is labeled as a prefix of the test case that was executing when this checkpoint was created. An example checkpoint tree is depicted in <ref type="figure">Figure 3</ref>.</p><p>The checkpoint tree forms an efficient search tree of checkpoints. After generating a new test case, Agamotto searches for a checkpoint from which to restore the virtual machine. To find the checkpoint that saves the largest amount of time in executing the test case, Agamotto traverses the checkpoint tree searching for a node that has a label that matches the longest prefix of the given test case. In <ref type="figure">Figure 3</ref>, given a test case, T = {a 1 , a 2 , a 7 , a 8 }, for example, Agamotto finds the node A , which has the label that matches the longest prefix, {a 1 , a 2 }. Since the checkpoint tree is a prefix tree, this longest prefix match can be performed efficiently without scanning all the checkpoints stored in the tree.</p><p>The checkpoint tree also constitutes an incremental checkpoint dependency graph when checkpoint storage is further optimized with incremental checkpoints (see Section 3.5.1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Checkpoint Management Policies</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Checkpoint Creation Policy</head><p>Checkpointing is requested after executing each action in a test case. A checkpoint creation policy decides, upon each checkpoint request, whether to create a checkpoint or not. A checkpoint creation policy should create checkpoints frequently enough, to increase the chances of finding a checkpoint in restoring the virtual machine later, thus saving time. Checkpointing should not be too frequent, however, because (i) the checkpointing operation itself adds a run-time overhead and (ii) each newly created checkpoint adds memory pressure to the checkpoint storage. Excessive creation of checkpoints, whose expected gain is less than its cost, must be avoided. We present two general checkpoint creation policies, which take these two requirements into account.</p><formula xml:id="formula_2">S 0 S 1 S 2 a 2 a 1 a 3 a ′ 4 S 3 S 4 t 1 t 2 = 2 · t 1 t 3 = 2 · t 2 T = {a 1 , a 2 , a 3 , a 4 , a 5 } T ′ = {a 1 , a 2 , a 3 , a ′ 4 , a 5 } S 5 a 5 (Test</formula><p>Checkpointing at Increasing Intervals. This policy creates checkpoints at configurable intervals in the timeline of the guest virtual machine. Upon each checkpoint request, we measure the time elapsed since the last checkpoint, and, if it exceeds the configured interval, a checkpoint is created. The intervals can be configured to be constant, or dynamically determined. We use an adaptive interval that increases as the level of the last checkpoint node in the checkpoint tree increases. In particular, we use an exponentially increasing interval using two as the base; this means that the policy requires a guest execution time twice as long as the one that was required for the last checkpoint (see 1 and 2 in <ref type="figure" target="#fig_2">Figure 4</ref>). The idea is to reduce the number of checkpoints created later in time during a test case execution, thus alleviating the overhead of checkpoint creation.</p><p>Disabling Checkpointing at First Mutation. This policy targets feedback-guided mutational fuzzers, which generate new test cases by mutating parts of older test cases in the corpus. It is well-known that the great majority of mutations do not produce a new feedback signal (e.g., coverage signal <ref type="bibr" target="#b39">[41]</ref>), which means that a new test case is more likely to be discarded than to be used for further mutation. Therefore, the expected gain of checkpointing the execution of a test case after the point of a new mutation is low. To reduce the overhead of checkpointing, this policy restricts the creation of checkpoints when executing a mutated test case. Specifically, checkpointing is disabled starting from the location of the first mutation in each test case (see <ref type="bibr" target="#b2">3</ref> in <ref type="figure" target="#fig_2">Figure 4</ref>). We do allow checkpointing, however, at any point before the new mutation, because the initial part of the test case still corresponds to a prefix of some older test case in the corpus and is likely to occur again as a base for new mutations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">Checkpoint Eviction Policy</head><p>Since the size of the checkpoint storage is limited, we cannot store as many checkpoints as created by the checkpoint creation policy. A checkpoint eviction policy evicts an existing checkpoint to free space for a newly created checkpoint when the memory limit allocated for checkpoint storage is reached. Given a configurable checkpoint pool size, checkpoints created by the checkpoint creation policy are unconditionally stored until there is no remaining space. If there is no available space upon creation of a checkpoint, we consult checkpoint eviction policies to find a node to evict. The goal of a checkpoint eviction policy is to keep a high usage rate of the checkpoints in restoring a virtual machine. A checkpoint eviction policy needs to predict what checkpoints are likely to be used in the near future, to keep those candidates in the checkpoint tree, and evict others.</p><p>We use multiple checkpoint eviction policies, which we consult sequentially. Each policy takes a set of nodes in the checkpoint tree as input and produces one or more candidate nodes as output. If a policy produces more than one candidate node, we consult the next policy using the output nodes of the previous policy as its input. We continue consulting each policy in the pipeline until it finds a single checkpoint node to evict.</p><p>Policy-1: Non-Active. This policy is placed first in the pipeline, which prevents any active checkpoint nodes from being evicted. Active checkpoint nodes in the checkpoint tree include the node that the virtual machine is currently based on, and, recursively, the parent node of an active node. This policy selects all but the active nodes in the checkpoint tree as eviction candidates, preventing any active node from being evicted. We consider the checkpoints that are currently active to be spatially close because they were created in executing a single test case-the unit of fuzzing. This policy promotes preserving the spatial locality between the active checkpoint nodes by evicting others.</p><p>Policy-2: Last-Level. This policy selects the nodes in the last level of the checkpoint tree as eviction candidates. As the depth of the checkpoint tree increases, its nodes are labeled with longer, more specialized test cases. The intuition behind selecting last-level nodes as eviction candidates is that the shorter the test case that a checkpoint node is labeled with, the more likely the label matches test cases that the fuzzer would generate in the future. By evicting last-level nodes, this policy effectively balances the checkpoint tree, letting the tree grow horizontally, rather than vertically.</p><p>Policy-3: Least-Recently-Used. The last policy in the pipeline is the Least-Recently-Used (LRU) policy, a policy widely known to be effective at managing different types of caches such as CPU data and address translation caches.</p><p>We track the time each checkpoint was last used; we say a checkpoint was used, (i) when it was created, or (ii) when the virtual machine was restored from it. The policy evicts the checkpoint used earliest in time. As widely known, an LRU policy promotes the temporal locality present in the checkpoint usage pattern. The more recently a checkpoint was used, the more likely it will be used again. Unlike previous policies, this LRU policy always determines one and only one eviction candidate, because each checkpoint is used at a unique point in time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Lightweight Checkpoint and Restore</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.1">Incremental Checkpointing</head><p>QEMU's default virtual machine snapshot mechanism stores all volatile states of a virtual machine in a snapshot image. Each snapshot can introduce prohibitive space overhead, however, the memory size of the virtual machine being the dominating factor. Thus, this full snapshot mechanism is not suitable for the fuzzing use case, where a large number of virtual machines are created, and their snapshots can quickly consume all the available memory. Creating a full snapshot can also introduce a prohibitively high run-time overhead for a virtual machine with high memory requirements.</p><p>To reduce both space and run-time overheads of checkpointing, Agamotto performs incremental checkpointing, where only the modified (or "dirty") memory pages are stored into each checkpoint image. The first checkpoint created by Agamotto after the first boot-the root checkpoint-would be identical to what a full snapshot mechanism would create, which contains all pages in memory. Whenever Agamotto creates a new checkpoint based on an existing one, however, only the memory pages that have been modified with respect to the base checkpoint are stored into the checkpoint image. This incremental approach greatly reduces the size of a non-root checkpoint, as well as the time it takes to create one.</p><p>The dependencies between incremental checkpoints are already expressed in our checkpoint tree data structure; that is, the virtual machine state of a given node in the checkpoint tree can be fully restored by following the path from the root to that node and incrementally applying checkpoints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.2">Delta Restore</head><p>A strawman approach to restoring a virtual machine using incremental checkpoints is to sequentially apply incremental checkpoint images starting from the root to the target node in an incremental checkpoint tree. The number of memory pages that this strawman approach should restore, however, is greater than the one that a non-incremental snapshot approach would restore; the root checkpoint in an incremental checkpoint tree already contains the full virtual machine state, and additional restorations of incremental checkpoints will add further overhead. In the fuzzing context, high-performance restore is a requirement, because the virtual machine is restored at the beginning of every iteration of the fuzzing loop. However, since Syzkaller's default Linux kernel configuration for USB fuzzing requires at least 512MB of working memory, and Windows requires a minimum of 4GB, it would take up to several seconds for the strawman approach to restore the full virtual machine memory. We, therefore, introduce the delta restore algorithm, which minimizes the number of memory pages that are copied during a virtual machine restoration. The full algorithm is described in Algorithm 1. The key idea is to restore (i) only the pages that have been modified in either the current or target virtual machine state after their execution has diverged, and (ii) each modified page only once via bottom-up tree traversal. This means that the number of memory pages that are copied during a virtual machine restoration is bounded by the number of pages modified within the current or the target virtual machine state. Observe that, in the strawman approach, the number of copied memory pages is greater than or equal to the number of all pages in memory. <ref type="figure">Figure 5</ref> contrasts (a) the top-down, strawman approach with (b) our bottom-up, delta restore approach in restoring a virtual machine state. In the given checkpoint tree, the node Dst refers to the checkpoint that the system is being restored to, and the node Src is a temporary node representing the current system state from which the restoration starts. The node B refers to the last checkpoint that the current system state is based on, and the node R refers to the root checkpoint. </p><formula xml:id="formula_3">S Dst S Src VM State S R S L Dirty Src..L Dirty Bitmap Dirty Dst...L DirtyDelta S Dst … …</formula><p>Figure 5: Top-down restore vs. Bottom-up delta restore.</p><p>Our delta restore algorithm first locates the lowest common ancestor node (node L ) of the node Src and Dst , and computes a bitmap of modified memory pages (or a dirty bitmap) of each node with respect to the node L , denoted by Dirty Src..L and Dirty Dst..L , respectively. We take the union of these two dirty bitmaps, which we call a delta dirty bitmap, denoted by Dirty Delta . Dirty Delta contains a complete list of memory pages that need restoring. Then, starting from the node Dst , we traverse the checkpoint tree backwards to the root node. At each node during the traversal, we restore only the memory pages that are in Dirty Delta and clear their corresponding bits in Dirty Delta to ensure that each dirty page is restored only once. The traversal stops when Dirty Delta is fully cleared. The strawman approach, by contrast, restores all pages stored in incremental checkpoints starting from the node R .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">I/O Interception for Fuzzing</head><p>Fuzzing driver code paths that can be reached through a given peripheral interface requires interception and redirection of the driver's I/O requests. We find two common models for driver I/O interception and redirection:</p><p>• User-Space Device Emulation. I/O requests coming from a kernel driver are redirected to a user-mode program through the system call interface. This approach typically requires kernel source code modifications for intercepting and redirecting driver I/O requests.</p><p>• Device Virtualization. Device virtualization techniques allow the virtual machine monitor to intercept I/O requests coming from the corresponding kernel driver.</p><p>Syzkaller's USB fuzzing mode takes the user-space device emulation approach. It adds a kernel module that intercepts and redirects USB driver I/O requests to a program running in user space via the system call interface. Since Syzkaller already contains many smart fuzzing features such as structureawareness of USB packets, we modified Syzkaller such that Agamotto can be applied. Our key modification was moving Syzkaller's fuzzer outside of the virtual machine so that the fuzzer survives virtual machine restorations as well as kernel crashes. We also modified the communication channels between Syzkaller's components. The fuzzing algorithm and other aspects of Syzkaller were left unmodified.</p><p>For fuzzing the PCI interface, we developed our own fuzzer, which uses a device virtualization approach to intercept the driver's I/O requests at the virtual machine monitor level. A key benefit of this approach is that it does not require kernel modifications; a virtual device can be implemented within the virtual machine monitor without modifying the guest OS kernel. We created a "fake" virtual PCI device in QEMU, and plugged it into QEMU's virtual PCI bus. Our fake PCI device attached to the PCI bus gets recognized by the PCI bus driver as the guest OS kernel boots, and, once the target PCI driver gets loaded, it intercepts all memory-mapped I/O (MMIO) requests coming from the target driver. We fuzzed these MMIO requests by sending fuzzer-generated data to the driver as a response to each driver I/O request.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation</head><p>We implemented Agamotto on top of QEMU 4.0.0 running in an x86 Linux environment <ref type="bibr" target="#b6">[8]</ref>. We used the Linux Kernel Virtual Machine (KVM) for hardware accelerated virtualization <ref type="bibr" target="#b41">[43]</ref>. We used Syzkaller 3 for USB fuzzing <ref type="bibr" target="#b22">[24]</ref>, and American Fuzzy Lop (AFL) version 2.52b for PCI fuzzing <ref type="bibr" target="#b63">[65]</ref>.</p><p>Dirty Page Logging. We used KVM's dirty page logging to identify modified pages, as required for our incremental checkpointing and delta restoration techniques. KVM's dirty page bitmap was looked up upon a checkpoint creation request and a virtual machine restoration request. We cleared KVM's dirty page bitmap after each checkpoint creation and virtual machine restoration. We note that KVM's dirty page logging can transparently be accelerated as hardware support-e.g., Page Modification Logging in Intel x86 CPUs-becomes available. Using this dirty page logging, we implemented our own optimized versions of virtual machine checkpointing and restoration mechanisms, since QEMU's snapshot implementation was found to be slower than we expected.</p><p>Inter-Component Communication. We used a variety of commodity virtual machine introspection (VMI) mechanisms to implement inter-component communication channels. Control channels were implemented via hypercalls and VIRTIO pipes established between QEMU and the guest virtual machine <ref type="bibr" target="#b42">[44]</ref>. Data channels for bulk data transfer were implemented via direct reads and writes to the guest memory or by using a separate shared memory device. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head><p>We conducted all of our experiments on a machine equipped with AMD EPYC 7601 CPU and 500GB of memory. We targeted device drivers in Linux v5.5-rc3 in our fuzzing experiments. We enabled Kernel AddressSanitizer to expose more bugs <ref type="bibr" target="#b33">[35]</ref>. We first evaluate Agamotto's individual primitives, and then the performance of kernel driver fuzzers augmented with Agamotto in both USB and PCI fuzzing scenarios.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Incremental Checkpointing</head><p>We compare the run-time and memory overheads of our incremental checkpointing implementation with the overheads of QEMU's non-incremental snapshot approach <ref type="bibr" target="#b0">[1]</ref>. To measure the overheads conservatively, we disabled QEMU's zero page optimization, a checkpoint size reduction technique that handles a page filled with zeros by storing a fixed-size entry in the checkpoint image, instead of storing 4KiB of zeros. Run-Time Overhead. The run-time overhead of checkpointing primarily depends on the number of pages copied into the checkpoint image. <ref type="figure" target="#fig_4">Figure 6a</ref> shows the overhead of our incremental checkpointing mechanism, and that of the baseline, when checkpointing a 512MiB memory guest virtual machine. As the number of dirty pages increases, the run-time overhead of incremental checkpointing increases linearly. In contrast, the overhead of the baseline, a non-incremental approach, remains constant regardless of the number of dirty pages. In addition, QEMU's non-incremental checkpoint approach adds an additional overhead due to its implementation and the full inclusion of the device memory, of which only a few pages are dirtied during fuzzing. A full restore can, therefore, take more than 200ms per checkpoint for copying all 131,072 pages, whereas our incremental checkpointing, for a typical range of the number of dirty pages (see Section 5.3), takes less than 20ms on average as it only copies the dirty pages.</p><p>Memory Overhead. <ref type="figure" target="#fig_4">Figure 6b</ref> shows how the size of each checkpoint correlates to the number of dirty pages when checkpointing a 512MiB memory virtual machine. As expected, the size of an incremental checkpoint increases in proportion to the number of pages that have been modified since the last checkpoint. Given the distribution of the number of modified pages, which typically ranges from 0 to 8,000 (see Section 5.3), each checkpoint should take no more than 64MiB. With the zero page optimization enabled, the size of each checkpoint observed in actual fuzzing runs, on average, is less than 32MiB. This is a reduction of 90% or more in size from the baseline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Delta Restore</head><p>Run-Time Overhead. <ref type="figure" target="#fig_5">Figure 7</ref> shows the run-time overhead of our implementation of the delta restore algorithm depending on the number of pages that are restored when restoring a 512MiB memory virtual machine. We used QEMU's default restoration mechanism as the baseline, which restores a virtual machine state from a non-incremental, full snapshot image. The smaller the number of restored pages as computed by our delta restore algorithm, the less time it takes to restore a virtual machine state. The number of restored pages, as observed in actual fuzzing runs, is significantly lower than the total number of pages in memory (see Section 5.3). With an average number of under 8,000 restored guest and device memory pages, our delta restore implementation can restore the virtual machine in 12.5ms on average, 8.9 times faster than the baseline, QEMU's implementation of the full snapshot restore approach, which takes 112ms on average.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Syzkaller-USB Fuzzing</head><p>Experimental Setup. We fuzzed USB drivers individually, one in each experiment. We chose 8 USB drivers, as shown in <ref type="table" target="#tab_3">Table 2</ref>, which include drivers (i) of 5 different classes, (ii) of different numbers of source lines of code, and (iii) from different vendors. We ran 32 fuzzing instances for three hours in fuzzing each driver. Each instance fuzzed the driver running in a 512MiB memory virtual machine. We enabled all USB related functions and constrained the parameters of syz_usb_connect-i.e., device and interface descriptors-to fuzz the drivers individually in each experiment. To minimize the effects of non-determinism in our experiment, we limited coverage instrumentation to the driver code as well as generic kernel code that drivers call into. <ref type="bibr" target="#b3">4</ref> The fuzzing algorithm of Syzkaller was not modified. We only increased Syzkaller's default five-second timeout to ten seconds to encourage deeper exploration. <ref type="bibr" target="#b4">5</ref> We started fuzzing without any seed input to eliminate its impact on the results. To minimize the randomness inherent in fuzzing algorithms, we used different but fixed sets of PRNG seed values for different instances, using the equation, {id inst + #crashes inst * 128} where inst = {0, 1, ..., 31}. This equation ensures that seed values (i) are always unique across instances, and (ii) change after each kernel crash. With these adjustments, the randomness of Syzkaller's fuzzing algorithm was controlled; note, however, that the randomness originating in the target system, e.g., coverage signal, was not controlled. To account for this randomness, we ran each experiment three times. We ran two different versions of Agamotto-(i) a fullfledged Agamotto and (ii) Agamotto with only the root checkpoint enabled (Agamotto-R)-to quantify the effectiveness of checkpoints dynamically created by Agamotto. We used Syzkaller as a baseline, only with the aforementioned changes for controlling timeout and randomness. We configured Agamotto with the following additional parameters: The checkpoint pool size was configured to be 12GiB per instance, and we used 500ms as the initial checkpoint creation interval.</p><p>Execution Time of Individual Test Cases. <ref type="figure" target="#fig_6">Figure 8</ref> shows how much time Agamotto skips in executing each test case. By using fine-grained checkpoints created by Agamotto, the initial parts of many test cases were skipped. We measured each test case's execution time in all experiments <ref type="figure" target="#fig_6">(Figure 8a</ref>) and computed each test case's normal execution time, the time each test case execution could have taken if fine-grained checkpoints were not used <ref type="figure" target="#fig_6">(Figure 8b</ref>). Agamotto successfully reduced the execution time of many test cases-a large portion of test cases took less than a second with Agamotto, as shown in <ref type="figure" target="#fig_6">Figure 8a</ref>.</p><p>Overall Fuzzing Throughput. <ref type="figure" target="#fig_7">Figure 9</ref> illustrates how much Agamotto improves Syzkaller's USB fuzzing throughput. This overall fuzzing throughput includes the overhead of Agamotto itself. One common trend observed in all experiments is that Agamotto's fuzzing throughput peaks in the first 10 minutes. This is because, as fuzzing instances are started, lots of test cases producing new coverage were discovered and minimized. Each minimized test case was then mutated 100 times and executed in a row. During this period of time in which new inputs were frequently discovered, a large number of similar test cases were executed in a row, the throughput of which was greatly improved by Agamotto. As the fuzzing continued, coverage-increasing test cases were seldom discovered, stabilizing the throughput. Still, Agamotto's throughput  was consistently higher than the baseline. Of the eight analyzed drivers only two experienced kernel crashes (MWIFIEX and RSI). The performance improvement of the remaining targets is therefore solely due to the reduced average execution time by using the checkpoints created by Agamotto.</p><p>Checkpoint Utilization and Effectiveness. We identify a checkpoint hit as selecting a non-root checkpoint in executing a test case, and a checkpoint miss as selecting the root checkpoint. The hit rate refers to the portion of executions that had a checkpoint hit among all executions. At each checkpoint hit, a different amount of time is skipped depending on the checkpoint used. <ref type="table" target="#tab_4">Table 3</ref> summarizes the hit rates, as well as the amounts of the guest execution time skipped in each fuzzing experiment. The hit rates and time skip rates vary depending on the driver targeted in each experiment; on average, we achieved 51.5% of hit rate, saving 30.9% in guest execution time.</p><p>To quantify the effectiveness of multiple checkpoints created by Agamotto, we compare the throughput of Agamotto and Agamotto-R; the throughput was improved by 38% on average. The shape of the checkpoint tree used to achieve this improvement is characterized in <ref type="figure" target="#fig_0">Figure 10</ref>. The depths of the checkpoint nodes-i.e., the number of edges from the root node-created and evicted by Agamotto ranged from 1 to 3, and the resulting checkpoint trees had an average branching factor of 175. This large branching factor reflects (i) how Syzkaller explores the input space, and (ii) that our checkpoint management policies favor checkpoint nodes of lower depths in the checkpoint tree. In these checkpoint trees, the length of the restoration path-i.e., the path from the node representing the dirty system state after each test case execution to the node being restored-ranged from 1 to 6, as shown in <ref type="figure" target="#fig_0">Figure 11</ref>. The widely ranging lengths of the restoration paths mean that different checkpoints created at various depths were actively used for virtual machine restoration, which also supports the utility of multiple checkpoints created by Agamotto.</p><p>Resilience to Kernel Panics. Agamotto found several known bugs in RSI and MWIFIEX that were already found and reported in earlier kernel versions by Syzbot <ref type="bibr" target="#b60">[62]</ref>, but left unfixed. Agamotto found one unknown bug in MWIFIEX. This bug was not found in the baseline (nor Syzbot), as it was obscured by a known, shallow bug in MWIFIEX, which repeatedly caused immediate kernel panics in the baseline. In contrast, since Agamotto puts the fuzzer outside the virtual machine, Agamotto continuously generated and ran test cases despite kernel panics, eventually getting past the known bug to discover this unknown bug. Moreover, Agamotto maintains the fuzzing throughput, even when it frequently hits these bugs. In fuzzing MWIFIEX as well as RSI, where Agamotto encountered bugs more than 6,000 and 200 times in every 10 minutes, their baseline throughput is significantly lower than the ones observed in fuzzing other drivers. Agamotto, in contrast, maintained a similar level of throughput across all experiments.</p><p>Dirty Page Statistics. To show that our incremental checkpointing and delta restore techniques are effective in practice, we measured the number of pages that are restored and dirtied in each iteration of the fuzzing loop. The results are shown in <ref type="figure" target="#fig_0">Figure 12a</ref> and 12b. In our experiments, the number of pages dirtied after executing a test case has an upperbound near 8,000 pages. The number of restored pages is similarly bounded, but often exceeds this limit when the modified pages of the checkpoint being restored do not completely overlap with the current set of dirty pages. This means that, as discussed in Section 5.1 and 5.2, the run-time overhead of virtual machine checkpointing and restoration was greatly reduced. Also, with the zero page optimization enabled, most of the checkpoints were found to be smaller than 32MiB, as depicted in <ref type="figure" target="#fig_0">Figure 12c</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">AFL-PCI Fuzzing</head><p>Experimental Setup. To evaluate our device-virtualizationbased PCI fuzzer augmented with Agamotto, we fuzzed four PCI drivers. We used AFL as the fuzzer this time, with its fuzzing algorithm unmodified again; we note that AFL implements a different input generation and scheduling algorithm than Syzkaller. With our own PCI fuzzer, we used a conservative baseline, where Agamotto was applied, but the creation of non-root checkpoints was disabled. In effect, our PCI experiments measured the effectiveness of fine-grained checkpoints created by Agamotto in improving the performance of kernel driver fuzzing. To avoid introducing randomness through the seed input, we started fuzzing with a single input as the seed, which contains an eight-byte string-"Agamotto" in the ASCII formatand without any dictionary entries. Randomness in the fuzzing algorithm was also controlled the same way as in the USB experiments. We fuzzed each driver using 32 instances for three hours. Since the driver's interactions with a PCI device were faster than what we observed in USB fuzzing, we reduced the starting checkpoint interval to 50ms. We used 100ms as a timeout value; we terminated each iteration 100ms after the driver's last access to the I/O mappings.</p><p>Fuzzing Throughput. Although AFL uses a fuzzing algorithm different from Syzkaller's, Agamotto again improved the throughput by 21.6% on average, as shown in <ref type="figure" target="#fig_0">Figure 13</ref>. We emphasize that neither AFL's nor Syzkaller's fuzzing algorithm produces a sequence of test cases that are optimal for Agamotto to accelerate. In particular, AFL's fuzzing algorithm is not tailored to fuzzing of event-driven systems (e.g., it always mutates each test case in the corpus from the first byte). Still, Agamotto consistently improved the fuzzing throughput in all experiments, and has potential to improve it further when the checkpoint management policies are optimized together with other aspects of the fuzzing algorithm.</p><p>Path Coverage.  * Median values from 3 independent runs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion</head><p>Checkpoint-Aware Fuzzing Algorithm. Our checkpointing primitive introduces a new dimension in the optimization space of fuzzing kernel drivers or other event-driven, reactive systems in general. We conservatively evaluated Agamotto without modifying the underlying fuzzing algorithm; that is, we only leveraged spatial and temporal localities that are already present in the fuzzing algorithm of state-of-the-art fuzzers. Thus, various aspects of the fuzzing algorithm such as input selection and mutation strategies can be revisited. We intend to explore checkpoint-aware or -oblivious fuzzing algorithms as future work.</p><p>Supporting Other OSs. Agamotto itself does not require any modification to the OS. Agamotto interacts with the virtual machine using standard virtual machine introspection mechanisms-hypercalls, VIRTIO, and shared memory devices-which are also readily available in closedsource, proprietary operating systems such as Windows <ref type="bibr" target="#b43">[45]</ref>.</p><p>Syzkaller's USB fuzzing component requires kernel modifications, in order to redirect a USB driver's I/O requests to user space via the system call interface. Our modifications to Syzkaller only pertain to its user-space components. Due to its OS-independence Agamotto can be used in conjunction with general kernel fuzzing approaches <ref type="bibr" target="#b51">[53,</ref><ref type="bibr" target="#b52">54]</ref>.</p><p>Fuzzing the System Call Interface. OS kernels have an event-driven system that processes incoming inputs from peripherals and user-space programs. Agamotto can make fuzzing the system call attack surface more efficient. The degree to which system call fuzzing can benefit from Agamotto, however, can vary depending on the kernel subsystem being targeted. Kernel subsystems that pose similar challenges to those that Agamotto addresses may benefit more than others. Device drivers themselves can also be tested more thoroughly by simultaneously fuzzing both their system call (e.g., ioctl) and peripheral attack surface. A local attacker having access to both of these attack surfaces can compromise the OS kernel by exploiting vulnerabilities found by such two-dimensional fuzzing. Prior work showed that two-dimensional fuzzing is effective at finding bugs in file systems <ref type="bibr" target="#b62">[64]</ref>. The same idea can be applied to device drivers, and Agamotto can facilitate an in-depth exploration of their two-dimensional input space.</p><p>Fuzzing Other Event-Driven Systems. Virtualization techniques have also been used for running and fuzzing IoT firmware <ref type="bibr" target="#b15">[17,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b64">66]</ref>. Although this paper focuses on fuzzing kernel-mode device drivers running in a full-fledged OS kernel, Agamotto's core techniques can be applied to fuzzing IoT firmware running in a virtual machine. Eventdriven systems running in user mode can also benefit from Agamotto. For example, when fuzzing a multi-process system where processes interact with each other, Agamotto, as it transparently captures the states of all running processes at the virtual machine level, can facilitate a deep exploration of the state space of such systems as a whole.</p><p>Further Optimizations. In a multi-instance fuzzing setup, one can deduplicate checkpoints across fuzzing instances via shared memory. Deduplication allows Agamotto to store more checkpoints in memory, which in turn may prevent thrashing and result in a higher hit rate of checkpoints. One can also explore different checkpointing and eviction policies that are either generic (e.g., the ones we presented), or tailored to certain classes of fuzzing algorithms. Virtual machine introspection primitives can also be further optimized via software and hardware techniques <ref type="bibr" target="#b3">[4]</ref>.</p><p>Limitations. Syzkaller supports a multi-proc mode, which runs multiple instances of a fuzzer within a single guest OS, increasing the fuzzing throughput. Agamotto does not support this mode currently, but we believe that this mode can be supported with a finer-grained checkpointing mechanism, e.g., via finer-grained virtual machine introspection or in-kernel checkpoints with kernel modifications <ref type="bibr" target="#b28">[30]</ref>. We intend to explore this direction as future work. We emphasize, however, that other aspects of Agamotto, e.g., checkpoint management and optimization techniques, would still apply even with such finer-grained checkpointing mechanism. We also emphasize that our choice of checkpointing at the virtual machine level allows Agamotto to support other VM-based kernel driver fuzzers as we demonstrated with PCI-AFL experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Peripheral Attacks and Defenses. Malicious peripherals have long been a threat to OS kernel security. A well-known example are malicious USB devices, which often appear as benign USB flash drives <ref type="bibr" target="#b40">[42]</ref>. Peripherals other than USB devices, even non-pluggable ones hardwired in an SoC, can also potentially turn malicious via peripheral attacks <ref type="bibr" target="#b7">[9,</ref><ref type="bibr" target="#b9">11]</ref>. Many defenses against malicious peripherals have been proposed <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b11">13,</ref><ref type="bibr" target="#b56">[58]</ref><ref type="bibr" target="#b57">[59]</ref><ref type="bibr" target="#b58">[60]</ref>, though securing the peripheral attack surface is still an ongoing effort <ref type="bibr" target="#b37">[39]</ref>. With the performance improvements that Agamotto provides, the exploration of the peripheral attack surface via fuzzing can be made more efficient, reducing the time for discovering new vulnerabilities.</p><p>Kernel Fuzzing. Many fuzzers exist that find vulnerabilities in kernel subsystems <ref type="bibr">[2, 3, 18, 24, 26, 27, 29, 32, 40, 46, 48, 53-55, 57, 64]</ref>. A line of work used various snapshot techniques <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b62">64]</ref>, which we already discussed in detail in Section 2. Other lines of work generally focused on the fuzzing algorithm, e.g., generating coverage-increasing test cases; Agamotto complements these efforts, as it transparently creates and uses checkpoints to save time in executing the generated test cases. Hybrid fuzzing, a combination of symbolic execution and fuzzing, has also been used to find bugs in OS kernels <ref type="bibr" target="#b31">[33,</ref><ref type="bibr" target="#b34">36,</ref><ref type="bibr" target="#b47">49,</ref><ref type="bibr" target="#b49">51]</ref>. Since both Agamotto and symbolic execution systems maintain different forms of snapshots, by devising switching mechanisms between the two forms of snapshots, Agamotto could also augment hybrid kernel fuzzing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We presented Agamotto, a system which transparently improves the performance of kernel driver fuzzers using a highlyoptimized dynamic virtual machine checkpointing primitive. During a fuzzing run, Agamotto automatically checkpoints the virtual machine at fine-grained intervals and restores the virtual machine from these checkpoints allowing it to skip reboots on kernel panics and to "fast forward" through the timeconsuming parts of test cases that are repeatedly executed. We evaluated Agamotto in various USB and PCI fuzzing scenarios with two different fuzzers, and demonstrated the performance benefit that Agamotto can provide, as well as its adaptability.</p><p>material are those of the authors and do not necessarily reflect the views of our funding agencies.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: High-level overview of Agamotto.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Fuzzing loop comparison.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Checkpoint creation policy enforcement example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Overheads of incremental checkpointing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Run-time overhead of delta restore.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Distribution of the execution time per test case in Syzkaller-USB fuzzing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Syzkaller-USB fuzzing throughput (execs/second) measured every 10 minutes for 3 hours.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Distribution of the depths of all the (a) created and (b) evicted checkpoints in the checkpoint trees, as well as (c) the resulting branching factors of the trees, measured in Syzkaller-USB fuzzing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :Figure 12 :</head><label>1112</label><figDesc>Figure 11: Distribution of the length of the restoration path in Syzkaller-USB fuzzing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: AFL-PCI fuzzing throughput (execs/second) measured every 10 minutes for 3 hours.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><head>Table 1 : Comparison between kernel fuzzing approaches.</head><label>1</label><figDesc></figDesc><table>Clean State Compatibility * High Speed 

No Snapshot [18, 24, 55] 


User-mode 
Snapshot 

(LibOS) [64] 


(Emulation) [2] 


VM Snapshot 



VM Snapshot with Agamotto 




* Compatible with kernel-mode drivers. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><head>Table 2 : USB and PCI fuzzing targets.</head><label>2</label><figDesc></figDesc><table>Target 
USB 
( §5.3) 
PCI 
( §5.4) 
Path (/drivers/...) 

RSI 

net/wireless/rsi 
MWIFIEX 

net/wireless/marvell/mwifiex 
AR5523 

net/wireless/ath/ar5523 
BTUSB 

bluetooth/btusb.c 
PN533 

nfc/pn533 
GO7007 

media/usb/go7007 
SI470X 

media/radio/si470x 
USX2Y 

sound/usb/usx2y 
ATLANTIC 

net/ethernet/aquantia 
RTL8139 

net/ethernet/realtek 
STMMAC 

net/ethernet/stmicro 
SNIC 

scsi/snic 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Checkpoint hit and guest execution time statistics. * 

# Checkpoints 
# Executions 
Guest Exec. Time 

Created Evicted Total 
Hit 
(Rate) 
Total 
Skipped 
(Rate ** ) 

RSI 
87k 
63k 201k 120k (59%) 90.3h 42.1h (31%) 
MWIFIEX 
19k 
9.8k 236k 60k (25%) 28.0h 18.3h (39%) 
AR5523 
91k 
71k 201k 116k (57%) 95.0h 38.6h (28%) 
BTUSB 
74k 
59k 254k 145k (57%) 94.7h 47.1h (33%) 
PN533 
89k 
65k 199k 116k (58%) 95.2h 39.7h (29%) 
GO7007 
105k 
83k 201k 126k (62%) 95.1h 44.5h (31%) 
SI470X 
88k 
67k 223k 130k (58%) 94.9h 43.6h (31%) 
USX2Y 
92k 
76k 195k 90k (46%) 95.0h 29.4h (23%) 

Geo. Mean 
51.5% 
30.9% 

ATLANTIC 
8.4k 
0.6k 191k 43k (22%) 95.2h 18.5h (22%) 
RTL8139 
17.9k 
6.5k 272k 128k (47%) 91.5h 78.9h (46%) 
STMMAC 
4.8k 
0.3k 160k 23k (14%) 95.2h 15.9h (14%) 
SNIC 
4.0k 
0.2k 153k 8.3k (5.4%) 95.3h 5.35h (5.3%) 

Geo. Mean 
17.0% 
16.7% 

* Median values from 3 independent runs. 
** Skipped/(Skipped+Total) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table 4 shows</head><label>4</label><figDesc></figDesc><table>, in fuzzing each driver, the 
maximum number of code paths discovered among all fuzzing 
instances. Agamotto's effectiveness is far more pronounced 
when the underlying fuzzer keeps discovering new, deeper 
code paths; the more checkpoints created by Agamotto in 
deep code paths, the more time it saves. In fuzzing AT-
LANTIC, RTL8139, and STMMAC, Agamotto covered sub-
stantially more paths than the baseline did in the same amount 
of time; by executing 32.8% more test cases on average, Ag-
amotto covered 47.8% more paths. In fuzzing SNIC, however, 
AFL only discovered only a limited number of paths. Still, 
Agamotto did execute 6.2% more test cases than the baseline. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Table 4 :</head><label>4</label><figDesc></figDesc><table>Number of executions and discovered paths in AFL-
PCI fuzzing. * 

# Executions 
# Paths Discovered 

Agamotto-R 
Agamotto 
(Increase) 
Agamotto-R 
Agamotto 
(Increase) 

ATLANTIC 
147k 191k (30.1%) 
112 142 (18.7%) 
RTL8139 
152k 259k (70.5%) 
71 153 (115.4%) 
STMMAC 
137k 160k (16.6%) 
87 121 (50.5%) 
SNIC 
144k 153k (6.2%) 
8 
8 
(0%) 

</table></figure>

			<note place="foot" n="2"> We use a transition-relation style of specifying concurrent, reactive programs (e.g, an OS kernel) to incorporate non-determinism [37, 50]. In other words, a i is a relation between S i−1 and S i , not a function.</note>

			<note place="foot" n="3"> Specifically, the commit number: ddc3e85997efdad885e208db6a98bca86e5dd52f 2548 29th USENIX Security Symposium USENIX Association</note>

			<note place="foot" n="4"> We instrumented the source code under the following directories: drivers, sound/{usb, core}, and net/{bluetooth, nfc, wireless}. 5 We followed Syzkaller&apos;s default timeout model, where each test case can execute for at most three seconds, but, as long as the last action has returned within last one second, it can execute up to ten seconds.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors would like to thank our shepherd, Manuel Egele, and the anonymous reviewers for their valuable feedback. </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">QEMU system emulation user&apos;s guide</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">TriforceAFL: AFL/QEMU fuzzing with full-system emulation</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Trinity: Linux system call fuzzer</title>
		<ptr target="https://github.com/kernelslacker/trinity" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A comparison of software and hardware techniques for x86 virtualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Agesen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Defending against malicious peripherals with Cinch</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Angel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Wahby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Howald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Leners</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Spilo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">pwn4fun spring 2014 -Safari -part II</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Beer</surname></persName>
		</author>
		<ptr target="https://googleprojectzero.blogspot.com/2014/11/pwn4fun-spring-2014-safari-part-ii.html" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">QEMU, a fast and portable dynamic translator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Bellard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference, FREENIX Track</title>
		<meeting>the USENIX Annual Technical Conference, FREENIX Track</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Exploiting the Wi-Fi stack on Apple devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Beniamini</surname></persName>
		</author>
		<ptr target="https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-2-exploiting-wi-fi.html" />
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
	<note>Over the air -</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Over the air</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Beniamini</surname></persName>
		</author>
		<ptr target="https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-3-exploiting-wi-fi.html" />
	</analytic>
	<monogr>
		<title level="m">pt. 3: Exploiting the Wi-Fi stack on Apple</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Over the air: Exploiting Broadcom&apos;s Wi-Fi stack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Beniamini</surname></persName>
		</author>
		<ptr target="https://googleprojectzero.blogspot.com/2017/04/over-air-exploiting-broadcoms-wi-fi_4.html" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note>part 1</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Over the air: Exploiting Broadcom&apos;s Wi-Fi stack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Beniamini</surname></persName>
		</author>
		<ptr target="https://googleprojectzero.blogspot.com/2017/04/over-air-exploiting-broadcoms-wi-fi_11.html" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Tolerating malicious device drivers in Linux</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Boyd-Wickizer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference (ATC)</title>
		<meeting>the USENIX Annual Technical Conference (ATC)</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Attacking the Windows NVIDIA driver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Chang</surname></persName>
		</author>
		<ptr target="https://googleprojectzero.blogspot.com/2017/02/attacking-windows-nvidia-driver.html" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An empirical study of operating systems errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Operating Systems Principles (SOSP)</title>
		<meeting>the ACM Symposium on Operating Systems Principles (SOSP)</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Live migration of virtual machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fraser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">G</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Jul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Limpach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Pratt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Warfield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Symposium on Networked Systems Design &amp; Implementation</title>
		<meeting>the USENIX Symposium on Networked Systems Design &amp; Implementation</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">HALucinator: Firmware re-hosting through abstraction layer emulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">A</forename><surname>Clements</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gustafson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Scharnowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Grosen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fritz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bagchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Payer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">DIFUZE: Interface aware fuzzing for kernel drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Corina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Machiry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Salls</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on Computer and Communications Security (CCS</title>
		<meeting>the ACM Conference on Computer and Communications Security (CCS</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Remus: High availability via asynchronous virtual machine replication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cully</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lefebvre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Meyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Feeley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Hutchinson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Warfield</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Symposium on Networked Systems Design &amp; Implementation</title>
		<meeting>the USENIX Symposium on Networked Systems Design &amp; Implementation</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">USB -undermining security barriers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Davis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<pubPlace>Black Hat USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">ReVirt: Enabling intrusion analysis through virtual-machine logging and replay</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">W</forename><surname>Dunlap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Cinar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Basrai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>the USENIX Symposium on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">P2IM: Scalable and hardware-independent firmware testing via automatic peripheral interface modeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mera</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Found Linux kernel USB bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google</surname></persName>
		</author>
		<ptr target="https://github.com/google/syzkaller/blob/master/docs/linux/found_bugs_usb.md" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">syzkaller -kernel fuzzer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google</surname></persName>
		</author>
		<ptr target="https://github.com/google/syzkaller" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Toward the analysis of embedded firmware through automated rehosting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gustafson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Muench</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Spensky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Redini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Machiry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Fratantonio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Balzarotti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Francillon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">R</forename><surname>Choe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Research in Attacks, Intrusions and Defenses (RAID)</title>
		<meeting>the International Symposium on Research in Attacks, Intrusions and Defenses (RAID)</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">IMF: Inferred model-based fuzzer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Cha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on Computer and Communications Security (CCS)</title>
		<meeting>the ACM Conference on Computer and Communications Security (CCS)</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">A Linux system call fuzzer using TriforceAFL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hertz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Newsham</surname></persName>
		</author>
		<ptr target="https://github.com/nccgroup/TriforceLinuxSyscallFuzzer" />
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Intel 64 and IA-32 architectures software developer&apos;s manual -Chapter 23 Introduction to Virtual Machine Extensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<ptr target="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Razzer: Finding kernel race bugs through fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shivakumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Shin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
		<meeting>the IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Finegrained fault tolerance using device checkpoints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kadav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Renzelmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Understanding modern device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kadav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Stateful fuzzing of wireless device drivers in an emulated environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Keil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kolbitsch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<pubPlace>Black Hat Japan</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">CAB-Fuzz: Practical concolic testing techniques for COTS operating systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference</title>
		<meeting>the USENIX Annual Technical Conference</meeting>
		<imprint>
			<publisher>ATC</publisher>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Debugging operating systems with time-traveling virtual machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">W</forename><surname>Dunlap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference (ATC)</title>
		<meeting>the USENIX Annual Technical Conference (ATC)</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">KernelAddressSanitizer (KASan): A fast memory error detector for the Linux kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Konovalov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Vyukov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LinuxCon North America</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Testing closed-source binary device drivers with DDT</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Chipounov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference (ATC)</title>
		<meeting>the USENIX Annual Technical Conference (ATC)</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Specifying concurrent program modules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="190" to="222" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">libFuzzer -a library for coverageguided fuzz testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Llvm</forename><surname>Developers</surname></persName>
		</author>
		<ptr target="https://llvm.org/docs/LibFuzzer.html" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Thunderclap: Exploring vulnerabilities in operating system IOMMU protection via DMA from untrustworthy peripherals</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">T</forename><surname>Markettos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rothwell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">F</forename><surname>Gutstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">G</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">N M</forename><surname>Watson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Fuzzing Wi-Fi drivers to locate security vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mendonça</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Neves</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Dependable Computing Conference (EDCC)</title>
		<meeting>the European Dependable Computing Conference (EDCC)</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Full-speed fuzzing: Reducing fuzzing overhead through coverage-guided tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Nagy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
		<meeting>the IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">BadUSB -on accessories that turn evil</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Nohl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<pubPlace>Black Hat USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Open Virtualization Alliance. Linux kernel virtual machine</title>
		<ptr target="https://www.linux-kvm.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Open Virtualization Alliance</title>
		<ptr target="https://www.linux-kvm.org/page/Virtio" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Open Virtualization Alliance. Windows guest drivers</title>
		<ptr target="https://www.linux-kvm.org/page/WindowsGuestDrivers" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Moonshine: Optimizing OS fuzzer seed selection with trace distillation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pailoor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aday</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Faults in Linux: Ten years later</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Palix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Calvès</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Digtool: A virtualizationbased framework for detecting kernel vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Fan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">POTUS: Probing off-the-shelf USB drivers with symbolic fault injection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Patrick-Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Cavallaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kinder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Workshop on Offensive Technologies (WOOT)</title>
		<meeting>the USENIX Workshop on Offensive Technologies (WOOT)</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Applications of temporal logic to the specification and verification of reactive systems: A survey of current trends</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pnueli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Current trends in Concurrency</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1986" />
			<biblScope unit="page" from="510" to="584" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">SymDrive: Testing drivers without devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Renzelmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kadav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>the USENIX Symposium on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Why do I miss Microsoft BitLocker?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rutkowska</surname></persName>
		</author>
		<ptr target="http://theinvisiblethings.blogspot.com/2009/01/why-do-i-miss-microsoft-bitlocker.html" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">kAFL: Hardware-assisted feedback fuzzing for OS kernels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schumilo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Aschermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gawlik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schinzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Holz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">Don&apos;t trust your USB! how to find bugs in USB device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schumilo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Spenneberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Schwartke</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<pubPlace>Black Hat Europe</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">PeriScope: An effective probing and fuzzing framework for the hardware-OS boundary</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Hetzelt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Spensky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Na</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Volckaert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-P</forename><surname>Seifert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Franz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Year in review: Android kernel security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">V</forename><surname>Stoep</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tolvanen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Linux Security Summit</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Charm: Facilitating dynamic analysis of device drivers of mobile systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M S</forename><surname>Talebi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Tavakoli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">A</forename><surname>Sani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Qian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Defending against malicious USB firmware with GoodUSB</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bates</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Butler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual Computer Security Applications Conference (ACSAC)</title>
		<meeting>the Annual Computer Security Applications Conference (ACSAC)</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">LBM: A security framework for peripherals within the Linux kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hernandez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">I</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">C</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">R B</forename><surname>Butler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
		<meeting>the IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Making USB great again with USBFILTER</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Scaife</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bates</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Traynor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Users really do plug in USB drives they find</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tischer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Durumeric</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mori</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bursztein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bailey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
		<meeting>the IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Syzbot and the tale of thousand kernel bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Vyukov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Linux Security Summit</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Designing new operating primitives to improve fuzzing performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Conference on Computer and Communications Security (CCS</title>
		<meeting>the ACM Conference on Computer and Communications Security (CCS</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Fuzzing file systems via two-dimensional input space exploration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-N</forename><surname>Tseng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy</title>
		<meeting>the IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m" type="main">American Fuzzy Lop</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zalewski</surname></persName>
		</author>
		<ptr target="http://lcamtuf.coredump.cx/afl" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Firm-AFL: High-throughput greybox fuzzing of IoT firmware via augmented process emulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Davanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium</title>
		<meeting>the USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
