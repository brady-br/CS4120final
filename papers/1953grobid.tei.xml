<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:18+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">DSAC: Effective Static Analysis of Sleep-in-Atomic-Context Bugs in Kernel Modules DSAC: Effective Static Analysis of Sleep-in-Atomic-Context Bugs in Kernel Modules</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>July 11-13. 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jia-Ju</forename><surname>Bai</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu-Ping</forename><surname>Wang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jia-Ju</forename><surname>Bai</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu-Ping</forename><surname>Wang</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julia</forename><surname>Lawall</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Sorbonne Université /Inria/LIP6</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shi-Min</forename><surname>Hu</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Tsinghua University</orgName>
								<orgName type="institution" key="instit2">Julia Lawall</orgName>
								<orgName type="institution" key="instit3">Sorbonne Université/Inria/LIP6</orgName>
								<orgName type="institution" key="instit4">Shi-Min Hu</orgName>
								<orgName type="institution" key="instit5">Tsinghua University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">DSAC: Effective Static Analysis of Sleep-in-Atomic-Context Bugs in Kernel Modules DSAC: Effective Static Analysis of Sleep-in-Atomic-Context Bugs in Kernel Modules</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2018 USENIX Annual Technical Conference (USENIX ATC &apos;18)</title>
						<meeting>the 2018 USENIX Annual Technical Conference (USENIX ATC &apos;18) <address><addrLine>Boston, MA, USA</addrLine></address>
						</meeting>
						<imprint>
							<date type="published">July 11-13. 2018</date>
						</imprint>
					</monogr>
					<note>Open access to the Proceedings of the 2018 USENIX Annual Technical Conference is sponsored by USENIX. This paper is included in the</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>In a modern OS, kernel modules often use spinlocks and interrupt handlers to monopolize a CPU core to execute concurrent code in atomic context. In this situation, if the kernel module performs an operation that can sleep at runtime, a system hang may occur. We refer to this kind of concurrency bug as a sleep-in-atomic-context (SAC) bug. In practice, SAC bugs have received insufficient attention and are hard to find, as they do not always cause problems in real executions. In this paper, we propose a practical static approach named DSAC, to effectively detect SAC bugs and automatically recommend patches to help fix them. DSAC uses four key techniques: (1) a hybrid of flow-sensitive and-insensitive analysis to perform accurate and efficient code analysis; (2) a heuristics-based method to accurately extract kernel interfaces that can sleep at runtime; (3) a path-check method to effectively filter out repeated reports and false bugs; (4) a pattern-based method to automatically generate recommended patches to help fix the bugs. We evaluate DSAC on kernel modules (drivers, file systems, and network modules) of the Linux kernel, and on the FreeBSD and NetBSD kernels, and in total find 401 new real bugs. 272 of these bugs have been confirmed by the relevant kernel maintainers, and 43 patches generated by DSAC have been applied by kernel maintainers.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Concurrency bugs are known to be difficult to debug. Many tools have been proposed to detect common concurrency bugs such as atomicity violations and data races. However, as a kind of concurrency bug, sleep-inatomic-context (SAC) bugs have received less attention. SAC bugs occur at the kernel level when a sleeping operation is performed in atomic context <ref type="bibr" target="#b9">[10]</ref>, such as when holding a spinlock or executing an interrupt handler. Code executing in atomic context monopolizes a CPU core, and the progress of other threads that need to concurrently access the same resources is delayed. Thus the code execution in atomic context should complete as quickly as possible. Sleeping in atomic context is forbidden, as it can block a CPU core for a long period and may lead to a system hang.</p><p>Even though sleeping in atomic context is forbidden, many SAC bugs still exist, especially in kernel modules, such as device drivers and file systems. The main reasons why SAC bugs continue to occur include: (1) Determining whether an operation can sleep often requires system-specific experience; (2) Testing kernel modules can be difficult, for example, running a device driver requires its associated device; (3) SAC bugs do not always cause problems in real execution, and they are often hard to reproduce at runtime. Recent studies <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b48">48]</ref> have shown that SAC bugs have caused serious system hangs at runtime. Thus, it is necessary to detect and fix SAC bugs in kernel modules.</p><p>Many existing approaches <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b41">42]</ref> can detect concurrency bugs, but most of them are designed for user-level applications. Some approaches <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b44">44]</ref> can detect some common kinds of kernel-level concurrency bugs, such as atomicity violations and data races, but they have not addressed SAC bugs. Several approaches <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr">53]</ref> can detect common kinds of OS kernel faults, including SAC bugs. But they are not specific to SAC bugs, and most of them <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b33">34]</ref> are designed to collect statistics rather than report specific bugs to the user, making issues such as detection time and false positive rate less important.</p><p>In this paper, we propose a static approach named DSAC 1 that targets accurately and efficiently detecting SAC (sleep-in-atomic-context) bugs in kernel modules, and can automatically recommend patches to help fix the detected bugs. DSAC consists of four phases. Firstly, DSAC uses a hybrid of flow-sensitive and -insensitive analysis (subsequently referred to as a hybrid flow analysis) to analyze the source code, in order to collect the set of functions that are possibly called in atomic context. Secondly, from the collected functions, DSAC exploits a heuristics-based method, which uses some heuristics based on the analysis of the call graphs and comments of the kernel code, to extract kernel interfaces that can sleep at runtime. Thirdly, with the extracted sleep-able kernel interfaces, DSAC first reuses the hybrid flow analysis to detect possible bugs, and then uses a path-check method to filter out repeated reports and false bugs by validating the code path of each detected bug. Finally, DSAC exploits a pattern-based method to automatically generate patches to help fix the bugs. This method analyzes the bug reports generated in the previous phase, and uses common fixing patterns to correct the buggy code.</p><p>We have implemented DSAC using LLVM <ref type="bibr" target="#b50">[51]</ref>. To validate its effectiveness, we first evaluate DSAC on Linux drivers, which are typical of modules in the Linux kernel. To validate the generality and portability, we then use DSAC to check file systems and network modules in the Linux kernel, and finally use DSAC in FreeBSD and NetBSD to check their kernel source code. The results show that DSAC can indeed accurately and efficiently find real SAC bugs and recommend a number of correct patches to help fix the bugs.</p><p>DSAC has four main advantages in practical use: 1) Efficient and accurate code analysis. DSAC uses an efficient inter-procedural and context-sensitive analysis to maintain a lock stack across function calls, which can accurately identify the code in atomic context. All source files of the kernel module are analyzed at once to perform accurate analysis across function calls.</p><p>2) Precise and detailed bug reports. To achieve precise bug detection, DSAC uses a heuristics-based method to extract sleep-able kernel interfaces, and uses a path-check method to filter out repeated reports and false bugs. It also produces detailed reports of the found bugs, including code paths and source file names, for the user to locate and check.</p><p>3) Recommended patch generation. With the generated bug reports, DSAC uses a pattern-based method to automatically generate patches to help fix the detected bugs, which can reduce the manual work of bug fixing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4) High automation, generality and portability.</head><p>Once the user offers the names of spin-lock and -unlock functions, interrupt-handler-register functions and basic sleep-able kernel interfaces, the remaining phases of DSAC are fully automated. DSAC can effectively check kernel modules, including drivers, file systems and network modules. And it can also be easily ported in another OS to check the kernel code.</p><p>In this paper, we make three main contributions:</p><p> We first analyze the challenges in detecting SAC bugs in kernel modules, and then propose four key techniques to address these challenges: (1) a hybrid flow analysis to perform accurate and efficient code analysis; (2) a heuristics-based method to accurately extract sleep-able kernel interfaces in the analyzed kernel modules; (3) a path-check method to effectively filter out repeated reports and false bugs; </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background</head><p>In this section, we first introduce atomic context, and then motivate our work by an example of a real SAC bug in a Linux driver.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Atomic Context</head><p>Atomic context is an OS kernel state that a CPU core is monopolized to execute the code, and the progress of other threads that need to concurrently access the same resources is delayed. This context can protect resources from concurrent access, in which the code execution should complete as quickly as possible without able to be rescheduled. Due to this special situation, sleeping in atomic context is forbidden, as it can block CPU cores for long periods and may lead to a system hang.</p><p>There are two common examples of atomic context in the kernel, namely holding a spinlock and executing an interrupt handler. If a thread sleeps when holding a spinlock, another thread that requests the same spinlock will spin on a CPU core to wait until the former thread releases the spinlock. If threads spin on all CPU cores like this, no CPU core will be available for the former thread to release the spinlock, causing a deadlock <ref type="bibr" target="#b10">[11]</ref>. If an interrupt handler sleeps, the kernel scheduler cannot reschedule it and a system hang may occur, as the interrupt handler is not backed by a process <ref type="bibr" target="#b28">[29]</ref>.</p><p>Note that atomic context only occurs at the kernel level, as user-level applications are regularly interrupted by the OS scheduler when their time slices end. Though kernel developers often know that sleeping is not allowed in atomic context, many SAC bugs still exist <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b33">34]</ref>, especially in kernel modules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Motivating Example</head><p>We motivate our work by a real bug in the usb_gadget that persisted over 8 releases (1.5 years) from Linux 2.6.38 to Linux 3.7. <ref type="figure" target="#fig_0">Figure 1</ref> presents part of the source code for the driver. The function mv_ep_queue calls spin_lock_irqsave to take a spinlock (line 774) and then calls req_to_dtd (line 775). The function req_to_dtd calls build_dtd (line 452), which calls dma_pool_alloc with GFP_KERNEL to request a DMA memory pool (line 399). According to the kernel documentation <ref type="bibr" target="#b49">[50]</ref>, dma_pool_alloc called with GFP_KERNEL can sleep, thus a SAC bug exists. This bug was first fixed in Linux 3.7, by replacing GFP_KERNEL with GFP_ATOMIC, which indicates to dma_pool_alloc that it cannot sleep.</p><p>This example illustrates three main reasons why SAC bugs occur in kernel modules. (1) Determining whether an operation can sleep requires OS-specific knowledge. In this example, without experience in Linux kernel development, it may be hard to know that the function dma_pool_alloc called with GFP_KERNEL can sleep at runtime. (2) SAC bugs do not always cause problems in real execution and are hard to reproduce at runtime. In this example, the function dma_pool_alloc called with GFP_KERNEL only sleeps when memory is insufficient. Even in a low-memory situation, this SAC bug is not always triggered at runtime in a multi-core system, because of the non-determinism of concurrent execution. (3) Multiple layers of function calls need to be considered when finding SAC bugs. In this example, the function dma_pool_alloc is called across two function levels after spin_lock_irqsave is called.</p><p>The bug in <ref type="figure" target="#fig_0">Figure 1</ref> has been fixed, but many SAC bugs still remain in current kernel modules. Some recent studies <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b48">48]</ref> have shown that SAC bugs have caused serious system hangs, and these bugs were often hard to locate and reproduce. Thus, to improve the reliability of the operating system, it is necessary to design an approach to detect SAC bugs in kernel modules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Challenges and Techniques</head><p>In this section, we first discuss the main challenges in detecting SAC bugs and then propose our techniques to address these challenges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Challenges and Overview of Our Solutions</head><p>There are four main challenges in detecting SAC bugs in kernel modules: C1: Code analysis coverage, accuracy and time. A key goal in bug detection is to efficiently cover more code and generate accurate results. Running kernel modules can be difficult (for example, running a driver needs the associated device), and thus we use static analysis to achieve high code coverage without the need to execute the code. Static analysis can be either flow-sensitive or flow-insensitive. Flow-sensitive analysis searches each code path of a branch and can cover all code paths. For this reason, it can produce accurate results, but it often requires much time and memory especially in interprocedural analysis. Flow-insensitive analysis handles each code line instead of each path. Thus, it is more efficient, but its results may be less accurate. We propose a hybrid flow analysis to obtain the advantages of both flow-sensitive and -insensitive analysis. It uses flow-sensitive analysis when its accuracy is expected to be beneficial and falls back to flow-insensitive analysis when full accuracy is not necessary. We will introduce the hybrid flow analysis in Section 3.2.1. C2: Sleep-able function extraction. Determining whether a function can sleep often requires a good understanding of the kernel code. Specifically, for a function defined in the kernel module (referred to as a module function subsequently), whether it can sleep depends on whether the called kernel interfaces can sleep. Using this idea, we design a heuristics-based method that first collects all kernel interfaces possibly called in atomic context of the kernel module, and then analyzes the kernel source code and comments to identify sleep-able ones. We will introduce this method in Section 3.2.2. C3: Filtering out repeated and false bugs. Some detected bugs may be repeated, because they take the spinlock at the same place and call the same sleep-able function, but only differ in their code paths. Moreover, some detected bugs may be false positives, as the analysis does not consider variable value information, and thus may search some infeasible code paths. We design a pathcheck method that checks the code path of each detected bug to filter out repeated reports and false bugs. We will introduce it in Section 3.2.3.   </p><formula xml:id="formula_0">1: if PathHasExisted(myblock, path_stack) == TRUE then 2:</formula><p>return; 3: end if 4: AddPathStack(myblock, path_stack);</p><formula xml:id="formula_1">5: foreach func_call in FunctionCallList(myblock) do 6:</formula><p>if func_call is a call to a spin-lock function then 7</p><p>Push func_call onto lock_stack; 8:</p><p>else if func_call is a call to a spin-unlock function then 9:</p><p>Pop an item from lock_stack; 10:</p><formula xml:id="formula_2">else 11:</formula><p>HanCall <ref type="formula">(</ref> C4: Bug fixing recommendation. After finding real bugs, the user may manually write patches to fix them. Besides, incorrect patches can introduce new bugs <ref type="bibr" target="#b20">[21]</ref>. To reduce the manual work of bug fixing, we summarize common patterns for fixing SAC bugs, and propose a pattern-based method to automatically generate recommended patches to help fix the bugs. We will introduce this method in Section 3.2.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Key Techniques</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Hybrid Flow Analysis</head><p>Our hybrid flow analysis is used to identify the code in atomic context. It is based on two points: (1) The analysis is context-sensitive and inter-procedural, in order to maintain the spinlock status and detect atomic context across functions calls. <ref type="formula">(2)</ref> The choice of flow-sensitive or -insensitive analysis is made as follows: if a module function calls a spin-lock or spin-unlock function (this module function is referred to as a target function) or it is called by an interrupt handler, flow-sensitive analysis is used to analyze each code path from the entry basic block; otherwise, flow-insensitive analysis is used to handle each function call made by the function. In the first case, flow-sensitive analysis is used to accurately maintain the spinlock status and collect code paths for subsequent bug filtering. In the second case, flowinsensitive analysis is used to reduce analysis cost, because in this case, the spinlock status is expected not to change explicitly.</p><p>Our hybrid flow analysis has two steps. The first step identifies target functions and interrupt handler functions, as flow-sensitive analysis is performed in these functions. For target functions, we analyze the definition of each module function and check whether it calls a spin-lock or spin-unlock function. For interrupt handler functions, we identify the calls to interrupt-handlerregister kernel interfaces (like request_irq in the Linux kernel), and extract interrupt handler functions from the related arguments.</p><p>The second step performs the main analysis. <ref type="figure" target="#fig_7">Figure 2</ref> presents the procedure FlowAnalysis. It maintains two stacks, namely a path stack (path_stack) to store the executed code path and a lock stack (lock_stack) to store the spinlock status. A flag (g_intr_flag) is used to indicate whether the code is in an interrupt handler. If lock_stack is not empty or g_intr_flag is TRUE, the code is in atomic context. FlowAnalysis uses HanCall to handle a function call and HanBlock to handle a basic block. We introduce them as follows:</p><p>HanCall. It handles the function call mycall with the arguments path_stack and lock_stack, to check if the definition of the function called by mycall needs to be handled, and if so to determine if the flow-sensitive orinsensitive analysis should be used. Firstly, HanCall checks if lock_stack is empty and g_intr_flag is FALSE (lines 1-3). If so, no spinlock is held and the code is not in an interrupt handler, and thus HanCall returns. Secondly, HanCall uses path_stack to check if mycall has been analyzed (lines 4-6). If so, it returns to avoid repeated analysis. Note that this prevents infinite looping on recursive calls. Thirdly, HanCall adds mycall into path_stack, and gets the called function myfunc (lines 7-8). Fourthly, HowToFunc (line 9) performs the analyses presented in Sections 3.2.2 and 4.1.3. Fifthly, HanCall checks if myfunc is a module function (lines 10-12). If not, it returns. Finally, it handles the definition of myfunc (lines <ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref>. If myfunc is a target function or g_intr_flag is TRUE, flow-sensitive analysis is used to handle its entry basic block using HanBlock (lines 13-15); otherwise, flow-insensitive analysis is used to handle each function call made by myfunc using HanCall (lines <ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref>. HanBlock. It handles the basic block myblock with the arguments path_stack and lock_stack, to perform flowsensitive analysis as well as maintain the spinlock status. Firstly, HanBlock uses path_stack to check if myblock has been analyzed (lines 1-3). If so, it returns to avoid repeated analysis. Secondly, HanBlock adds myblock into path_stack (line 4). Thirdly, HanBlock handles each function call in myblock (lines 5-13). If the function call is a call to a spin-lock or spin-unlock function, HanBlock pushes the call onto or pops an item from lock_stack; otherwise, the call is handled by HanCall. Fourthly, HanBlock checks if lock_stack is empty and g_intr_flag is FALSE. If so, it returns (lines 14-16); otherwise, each successive basic block of myblock is handled using HanBlock (lines <ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref>. FlowAnalysis. It performs the main analysis, in two steps. Firstly, each target function is analyzed (line 1-7). For a target function, each basic block that contains a spin-lock function call is an analysis entry. In this case, path_stack and lock_stack are first set to empty, and g_intr_flag is set to FALSE. Then, the analysis is started by using HanBlock to handle this basic block. Secondly, each interrupt handler function is analyzed (line 8-12). In this case, path_stack and lock_stack are set to empty, but g_intr_flag is set to TRUE. Then, the analysis is started by using HanBlock to handle the entry basic block of the interrupt handler function.</p><p>Our hybrid flow analysis has three main advantages: (1) The functions that are possibly called in atomic context can be accurately detected; (2) Detailed code paths and complete spinlock status are maintained, to help accurately detect atomic context; (3) Many unnecessary paths are not considered to reduce the analysis time. However, a main limitation of our analysis is that variable value information is not considered, which may cause false positives in bug detection.</p><p>We illustrate our hybrid flow analysis using some simplified driver-like code shown in <ref type="figure" target="#fig_3">Figure 3</ref>. As shown in <ref type="figure" target="#fig_3">Figure 3(a)</ref>, the module consists of MyFunc, FuncA and FuncB, where MyFunc calls FuncA and FuncB. Because MyFunc and FuncB both call spin_lock and spin_unlock, they are target functions and handled by the flow-sensitive analysis; because FuncA does not call spin-lock or spin-unlock functions, it is handled by the flow-insensitive analysis. During the analysis, no spinlock is held after the first line of FuncB (line 24), thus the following call paths in FuncB are not analyzed. In total, only two useful call paths marked in solid edges in <ref type="figure" target="#fig_3">Figure 3</ref>(c) are handled when analyzing MyFunc, and they are the only necessary call paths for atomic context analysis in this case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Heuristics-Based Sleep-able Function Extraction</head><p>We use some heuristics to accurately extract sleep-able kernel interfaces in the kernel modules. Firstly, we perform our hybrid flow analysis on the analyzed kernel module(s), to collect all kernel interfaces that are possibly called in atomic context, through HowToFunc in <ref type="figure" target="#fig_7">Figure 2</ref>  The comments in or before it contain keywords like "can sleep" and "may block".</p><p> It calls an already identified sleep-able kernel interface in the call graph. To avoid repeated checking, we maintain two cache lists. If a function is marked as sleep-able, it is added to a sleep-able list; otherwise it is added to a non-sleep list. When analyzing a function, we first check whether the function is in either of these lists.</p><p>After the extraction, we get the sleep-able kernel interfaces that are possibly called in atomic context of the analyzed kernel modules(s). These kernel interfaces can be used to detect SAC bugs in the kernel module(s).   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Path-Check Bug Filtering</head><p>We use the detailed code paths recorded in our hybrid flow analysis to filter out repeated and false SAC bugs.</p><p>Firstly, we filter out repeated bugs. For each new possible bug, we check whether its entry and terminal basic blocks are the same as those of an already detected bug, and whether they call the same sleep-able kernel interface. If both conditions are satisfied, this possible bug is marked as a repeated bug and is filtered out.</p><p>Secondly, we filter out false bugs, which are mainly introduced by the fact that our hybrid flow analysis neglects variable value information. The best strategy is to validate path conditions <ref type="bibr" target="#b5">[6]</ref>. But it is often hard to ensure the accuracy and efficiency when control flow is complex, especially across function calls.</p><p>By studying the Linux kernel source code, we find a useful and common semantic information for variables: a conditional that checks a parameter of the containing function or the return value of a specific kernel interface is often used to decide whether sleeping is allowed. <ref type="figure">Figure 4</ref> presents two examples in Linux driver code. In <ref type="figure">Figure 4</ref>(a), a conditional checks the function parameter can_sleep to decide whether the sleep-able kernel interface usleep_range can be called. In <ref type="figure">Figure 4</ref>(b), a conditional checks the return value of the kernel interface in_interrupt to check whether the code is executed in an interrupt handler to decide whether the sleep-able kernel interface wait_for_completion can be called. Using this semantic information, we design a straightforward strategy to cover common cases. If the code path of a possible bug satisfies one of the two criteria, we mark this bug as a false bug and filter it out:</p><p> The path contains a conditional that checks a parameter of the containing function, and the name of this parameter contains a keyword like "can_sleep", "atomic" and "can_block".</p><p> The path contains a conditional that checks the return value of a kernel interface used to check atomic context, like in_interrupt in the Linux kernel.</p><p>We propose a path-check method that uses the above steps, to automatically and effectively filter out repeated reports and false bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.4">Pattern-based Patch Generation</head><p>By studying Linux kernel patches, we have found four common patterns of fixing SAC bugs: P1: Replace the sleep-able kernel interface with a nonsleep kernel interface having the same functionality, like usleep_range ⇒ udelay in <ref type="figure">Figure 4(a)</ref>. P2: Replace the specific sleep-able constant flag with a non-sleep flag, like GFP_KERNEL ⇒ GFP_ATOMIC in <ref type="figure" target="#fig_0">Figure 1</ref>. P3: Move the sleep-able kernel interface to some place where a spinlock is not held. P4: Replace the spinlock with a lock that allows sleeping, like spin_lock ⇒ mutex_lock and spin_unlock ⇒ mutex_unlock in the Linux kernel.</p><p>These patterns have different usage scenarios and raise different challenges. Firstly, P1 and P2 can be used for all atomic contexts, while P3 and P4 are only used when holding a spinlock. Secondly, P1 and P2 involve simple modifications, while P3 and P4 involve more difficult modifications and are error-prone. Using P3 requires carefully determining where the sleep-able function should be moved to. Using P4 requires modifying all locking and unlocking operations. Thus, using P3 and P4 to automatically generate patches is hard.</p><p>We only use P1 and P2 to automatically generate recommended patches, because these patterns are simple and effective. Supporting P3 and P4 is left as future work. The method has three steps. Firstly, the bug is located using its code path, and the relevant fixing pattern (P1 or P2) is selected according to the code. If no relevant pattern is available, no patch is generated. Secondly, the buggy code is corrected by using the selected pattern. Finally, a patch is generated by comparing the corrected code to original code. This pattern-based method has two advantages. Firstly, it can reduce the manual work of bug fixing. Secondly, by using common fixing patterns, it can ensure the correctness of the generated patches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Approach</head><p>Based on the four techniques in Section 3.2, we propose a static approach DSAC, to effectively detect SAC bugs in kernel modules and recommend patches to help fix the detected bugs. We have implemented DSAC with the Clang compiler <ref type="bibr">[49]</ref>, and perform static analysis on the LLVM bytecode of the kernel module. <ref type="figure">Figure 5</ref> presents the architecture of DSAC, which has five parts: </p><formula xml:id="formula_3"></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Function Information Collection</head><p>In this phase, DSAC performs two steps:</p><p>Firstly, the code compiler compiles each source file of the kernel module into a LLVM bytecode file, and then links all bytecode files into a single bytecode file. This single bytecode file includes all module function definitions, thus all analyses of the kernel module can be directly performed on only this single bytecode file.</p><p>Secondly, the function extractor performs the hybrid flow analysis to collect the information about functions that are possibly called when holding a spinlock or in an interrupt handler. The information is stored in a MySQL <ref type="bibr">[52]</ref> database as the intermediate results, including the function name, constant arguments, file name, etc. The intermediate results will be later used in sleep-able kernel interface extraction and bug detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Sleep-able Kernel Interface Extraction</head><p>In this phase, the function extractor first extracts function call graphs of kernel interfaces and comments of these kernel interfaces, and then uses the heuristicsbased method to extract sleep-able kernel interfaces. The user can check and modify the extracted sleep-able kernel interfaces as needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Bug Detection</head><p>In this phase, DSAC first detects possible SAC bugs, and then filters out repeated reports and false bugs.</p><p>Firstly, the bug detector uses the hybrid flow analysis to check whether each extracted sleep-able kernel interface is called in atomic context, which is implemented in HowToFunc in <ref type="figure" target="#fig_7">Figure 2</ref>. If so, a possible bug and its detailed code path to the sleep-able kernel interface call are recorded. To speed up analysis, we use the intermediate results to only check the buggy kernel modules.</p><p>Secondly, the bug filter filters out repeated reports and false bugs. Finally, DSAC produces detailed reports for the found bugs (including code paths and source file names), so the user can locate and check the bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Recommended Patch Generation</head><p>In this phase, the patch generator automatically generates recommended patches to help fix the bugs. Then, the user can use the detailed code paths found in the bug reports to write log messages, and finally submit these patches to kernel maintainers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Setup</head><p>To validate the effectiveness of DSAC, we first evaluate it on Linux drivers, which are typical kernel modules. To cover different kernel versions, we select an old version 3.17.2 (released in October 2014), and a new version 4.11.1 (released in <ref type="bibr">May 2017)</ref>. Then, to validate the generality of DSAC, we use it to check file systems and network modules in the Linux kernel. Finally, to validate the portability of DSAC, we run it in FreeBSD and NetBSD to check their kernel code.</p><p>We run the experiments on a Lenovo x86-64 PC with four Intel i5-3470@3.20G processors and 4GB memory. We compile the code using Clang 3.2. We use the kernel configuration allyesconfig to enable all drivers, file systems and network modules for the x86 architecture.</p><p>To run DSAC, the user performs three steps. Firstly, the user configures DSAC for the checked OS kernel, by providing the names of spin-lock and -unlock functions (such as spin_lock_irq and spin_unlock_irq for the Linux kernel), interrupt-handler-register functions (such as request_irq for the Linux kernel), and basic sleep-able kernel interfaces (such as schedule for the Linux kernel). Secondly, the user compiles the source code of the kernel modules and OS kernel using the kernel's underlying Makefile and DSAC's compiling script. As a result, DSAC produces sleep-able functions and intermediate results. Finally, the user executes DSAC's bug-detecting script to detect bugs and generate recommended patches. The second and third steps are fully automated. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Extracting Sleep-able Kernel Interfaces</head><p>We first extract the sleep-able kernel interfaces that are called in atomic context of the drivers. <ref type="table" target="#tab_6">Table 1</ref>  2) Our heuristics-based method can efficiently extract real sleep-able kernel interfaces that are called in atomic context of the analyzed drivers. In Linux 3.17.2 and 4.11.1, 70 and 94 sleep-able kernel interfaces are respectively identified from among 3104 and 3613 different kernel interfaces (candidate functions) that are possibly called in atomic context. We manually check the kernel interfaces identified as sleep-able, and find that all of them can sleep at runtime. Over 97% of the candidate functions are automatically filtered out, thus the manual work of checking these functions is saved.</p><p>3) Our code analysis is efficient. DSAC respectively spends around 108 and 129 minutes on handling 8K and 11K driver source files, including the compilation time of these source files using the Clang compiler. Excluding compilation time, DSAC spends 61 and 74 minutes respectively, amounting to less than 0.44 seconds per source file. 4) Many of the extracted sleep-able kernel interfaces are related to resource handling (such as allocation and release). The data in parentheses present the number of these kernel interfaces, which amount to more than 60% of all the sleep-able kernel interfaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Detecting Bugs and Generating Patches</head><p>Based on the above extracted sleep-able kernel interfaces, we use DSAC to perform bug detection and recommend patches. Firstly, to validate whether DSAC can find known bugs, we use DSAC to check the drivers in Linux 3.17.2. We do not generate patches in this case, because this kernel version is very old. Secondly, to validate whether DSAC can find new bugs and recommend patches to help fix them, we use DSAC to check the drivers in Linux 4.11.1. We count the bugs according to the pair of entry and terminal basic blocks. To check results' accuracy, we manually check all detected bugs to identify whether they are real bugs. <ref type="table" target="#tab_7">Table 2</ref> shows the results. We have the following findings:</p><p>1) Our path-check filtering method is effective in automatically filtering out repeated reports and false bugs. 4) DSAC can accurately find real bugs in our evaluated driver code. The false positive rates are respectively only 7.0% and 5.9% in the drivers of Linux 3.17.2 and 4.11.1, based on our identification of real bugs. Reviewing the driver source code, we find these false positives are mainly introduced by the fact that some invalid code paths are searched by our hybrid flow analysis and our path-check method does not filter them out. 5) Few of the detected bugs are in interrupt handlers (7 bugs in 3.17.2, and 17 bugs in 4.11.1). Indeed, driver developers often write clear comments to mark the driver functions that are called from an interrupt handler, to prevent calling sleep-able functions in these functions.</p><p>6) DSAC automatically and successfully generates 43 patches that it recommends to help fix 82 real bugs in Linux 4.11.1. <ref type="table" target="#tab_7">Table 2</ref> classifies the patches by the pattern in Section 3.2.4 that is used. We manually review these patches, add appropriate descriptions, and then submit them to the relevant kernel maintainers. As of January 2018, 30 patches have been applied, noted in  parentheses in <ref type="table" target="#tab_7">Table 2</ref>. 2 patches were not directly applied as the maintainers wanted to fix the bugs in other ways (such as P3 and P4). There has been no reply yet for 11 patches. There are still 238 real bugs for which DSAC cannot recommend patches, as they do not match P1 or P2. Most of these bugs can be fixed using P3 or P4. But those patterns require more difficult changes, and DSAC is not currently able to automatically apply them. In general, the results indicate that DSAC can generate a number of correct patches to reduce the manual work of bug fixing. 7) Bug detection and patch generation are efficient, requiring less than 10 minutes. The reasons include that intermediate results are used to reduce repeated analysis and our hybrid flow analysis is efficient.</p><p>Reviewing the results, we find two interesting things. Firstly, most of the detected bugs involve multiple functions. Indeed, driver developers may easily forget that the code is in atomic context across multiple function calls. Secondly, many of the detected bugs are related to resource allocation and release, because many extracted sleep-able functions relate to this issue.</p><p>We also classify the 320 real bugs found by DSAC in Linux 4.11.1 drivers, according to driver class. <ref type="table" target="#tab_10">Table 3</ref> shows the top results. We find that SCSI and network drivers share 58% of all bugs. <ref type="figure">Figure 6</ref>(a) shows a real bug detected by DSAC in the gma500 driver of Linux 4.11.1, which has been confirmed by the developer. The function psbfb_2d_submit first calls spin_lock_irqsave to acquire a spinlock (line 115), and then it calls psb_2d_wait_available (line 119) that calls psb_spank in definition (line 91). The function psb_spank calls msleep (line 58) that can sleep. To help fix the bug, our pattern-based method recommends a patch that replaces msleep with mdelay (P1), and this patch has been applied by the kernel maintainer. Part of the DSAC's report for this bug is listed above <ref type="table" target="#tab_10">Table 3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Generality and Portability</head><p>We use DSAC to check file systems and network modules in Linux 4.11.1. Then we run DSAC in FreeBSD 11.0 and NetBSD 7.1 to check their kernel code. <ref type="table" target="#tab_0">Table  4</ref> shows the results. We have the following findings: 1) DSAC works normally when checking Linux file systems and network modules and other OS kernels. DSAC can handle their source code in a modest amount of time. It can extract real sleep-able kernel interfaces and filter out many repeated reports and false bugs.</p><p>2) DSAC in total finds 81 real bugs out of the 88 detected bugs. The false positive rate is thus 8.0%. The false positives are again due to searching invalid code paths. As of January 2018, 63 of these bugs have been confirmed by kernel developers. <ref type="figure">Figure 6</ref>(b) and (c) present two real SAC bugs found by DSAC in FreeBSD scsi_sa and NetBSD if_vte drivers. These bugs involve respectively a spinlock and an interrupt handler.</p><p>3) DSAC in total generates 18 recommended patches to help fix 59 real bugs. We manually add appropriate descriptions and submit them to kernel maintainers. As of January 2018, 13 of the patches have been applied.    Reviewing the results, we find two interesting things. Firstly, compared to the Linux kernel, fewer SAC bugs are detected in FreeBSD and NetBSD. The main reason is that in FreeBSD and NetBSD, many kernel interfaces that can sleep are carefully designed to avoid SAC bugs. For example, the FreeBSD msleep function takes the held spinlock as an argument and unlocks the spinlock before actually sleeping and then locks it again. Secondly, in FreeBSD and NetBSD, most of the detected bugs are in drivers, as shown in the parentheses on "Real bugs" line of <ref type="table" target="#tab_0">Table 4</ref>. It shows that drivers remain a significant cause of system failures <ref type="bibr" target="#b38">[39]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Sensitivity Analysis</head><p>DSAC performs flow-insensitive analysis to reduce time usage in specific cases when doing so is expected to not affect accuracy, and also maintains a lock stack to accurately identify the code in atomic context. To show the value of these two techniques, we modify DSAC to remove each of them, and evaluate each modified tool on a typical SCSI driver fnic (drivers/scsi/fnic/) of Linux 4.11.1. Original DSAC checks the driver in three seconds, and finds two real confirmed SAC bugs. Flow-insensitive analysis. We use a full flow-sensitive analysis rather than the hybrid flow analysis. It finds the two SAC bugs too, but it spends two minutes, which is much longer than original DSAC. Lock stack. We only keep a single bit indicating whether a lock is held rather than the lock stack during analysis. It also spends three seconds, but does not find any bugs. Indeed, the two bugs exist when two spinlocks are held and just one spinlock has been released, thus keeping a single bit cannot identify this atomic context.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Summary of Results</head><p>Our experiments show three significant results of using DSAC on the Linux, FreeBSD and NetBSD kernels: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Comparison to Previous Approaches</head><p>Several previous approaches <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b33">34]</ref>  By manually comparing the bug reports shows: (1) 53 real bugs reported by DSAC are equivalent to 23 real bugs reported by BlockLock. DSAC reports more bugs because it detects sleep-able kernel interfaces, while BlockLock detects sleep-able functions. Thus, if a function defined in the kernel module calls several sleepable kernel interfaces in atomic context, DSAC reports all these kernel interfaces, while BlockLock only reports this function. The two remaining real bugs reported by BlockLock are missed by DSAC, as Clang-3.2 cannot successfully compile the related driver source code. <ref type="formula">(2)</ref> DSAC filters out all false bugs reported by BlockLock. (3) DSAC reports 155 real bugs missed by BlockLock. Most of these bugs involve multiple source files, and BlockLock cannot handle them very precisely. And 18 bugs are related to interrupt handling, which is not considered by BlockLock. (4) The false positive rate of DSAC is 8.8%, which is lower than that of BlockLock.</p><p>However, compared to BlockLock, an important limitation of DSAC is that its results are specific to a single kernel configuration. BlockLock is based on Coccinelle <ref type="bibr" target="#b32">[33]</ref>, which does not compile the source code. Thus it can conveniently check all source files without any kernel configuration. DSAC is based on LLVM, which compiles the source code with a selected kernel configuration. Thus, the 18 bugs found by BlockLock for nonx86 architectures are missed by DSAC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Limitations and Future Work</head><p>DSAC still has some limitations. Firstly, DSAC analyzes LLVM bytecode in which macros are expanded, thus the user needs to configure DSAC in terms of expanded versions of the functions and constants that are defined by macros. We plan to introduce source code information to address this issue. Secondly, DSAC cannot handle function pointers. We plan to use alias analysis <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b46">46]</ref> to analyze them. Thirdly, as is typical for static analysis, the path-check method cannot filter out all invalid code paths produced by the hybrid flow analysis, which can introduce false positives. We plan to improve our path-check method by checking path conditions more accurately. Finally, the bug-fixing patterns P3 and P4 need to be supported, e.g., we plan to add the analysis for other kinds of locks to support P4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Related Work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Detecting Concurrency Bugs</head><p>Many approaches <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b42">43]</ref> have been proposed to detect concurrency bugs in user-mode applications. Some of them <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b41">42]</ref> use dynamic analysis to collect and analyze runtime information to detect concurrency bugs. But the code coverage of dynamic analysis is limited by test cases. Others <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b42">43]</ref> use static analysis to cover more code without running the tested programs. But static analysis often introduces false positives. Some approaches <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b27">28]</ref> combine static and dynamic analysis to achieve higher code coverage with fewer false positives. Even though DSAC uses static analysis, it also exploits complementary information such as semantic information for variables to check code paths to filter out false positives.</p><p>To improve OS reliability, some approaches <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b44">44]</ref> detect some kinds of concurrency bugs like data races, but they do not detect SAC bugs.</p><p>Several approaches <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr">53]</ref> can detect common kinds of OS kernel bugs, including SAC bugs. But they do not specifically target SAC bugs, thus they may miss many real bugs or report many of false positives. For example, BlockLock <ref type="bibr" target="#b33">[34]</ref> has an overall false positive rate of 20%, while DSAC has a lower one of 6.3%, and it also misses some real bugs found by DSAC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Checking API Rules</head><p>Checking API rules is a promising way of finding deep and semantic bugs in the OS kernel. Some approaches <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b30">31]</ref> use specified and known API rules to statically or dynamically detect API misuses. For example, with known paired reference count management functions, RID <ref type="bibr" target="#b29">[30]</ref> uses a summary-based inter-procedural analysis to detect reference counting bugs. To find implicit API rules, some approaches <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b45">45,</ref><ref type="bibr" target="#b47">47]</ref> do specification mining by analyzing source code <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b47">47]</ref> or execution traces <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b45">45]</ref>, and then use the mined API rules to detect violations.</p><p>Most of these approaches focus on the temporal rules of common API usages, such as resource acquiring and releasing pairs <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b45">45]</ref> and error handling patterns <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b23">24]</ref>, but these approaches have not targeted SAC bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Improving Kernel Module Architecture</head><p>To prevent concurrency bugs, several improved kernel module architectures have been proposed, typically for device drivers. The active driver architecture <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b35">36]</ref> runs each driver in a separate thread, which can serialize access to the driver and eliminate the possibility of concurrency bugs. In this way, the driver works serially and does not need to use locks, thus many common concurrency bugs will never occur. The user-mode device-driver architecture <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b34">35]</ref> runs each driver in a separate user-mode process. This architecture protects the OS kernel against crashes caused by driver code.</p><p>These approaches have a main limitation, namely that the driver code must be manually rewritten.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Conclusion</head><p>In this paper, we have proposed DSAC, a static approach, to effectively detect SAC bugs and automatically recommend patches to help fix them. DSAC uses four key techniques: (1) a hybrid flow analysis to identify the code in atomic context; (2) a heuristics-based method to extract sleep-able kernel interfaces; (3) a path-check method to filter out repeated reports and false bugs; (4) a pattern-based method to automatically generate recommended patches to help fix the bugs. We have used DSAC to check the kernel code of Linux, FreeBSD and NetBSD, and find 401 new real bugs. As of January 2018, 272 of them have been confirmed, and 43 of the patches generated by DSAC have been applied.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Part of the usb_gadget driver code in Linux 2.6.38.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>FILE</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Figure 2: Hybrid flow analysis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 (</head><label>3</label><figDesc>b) presents the call path of each function, with the code line numbers from Figure 3(a) shown in the vertices. Figure 3(c) shows the call paths used in inter-procedural analysis of MyFunc.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Example of hybrid flow analysis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Checking the return value of a kernel interface Figure 4: Examples of path checks in drivers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>2 )</head><label>2</label><figDesc>Of the 215 bugs reported by DSAC in the drivers of Linux 3.17.2, we have identified 200 as real bugs, 50 of which have been fixed in Linux 4.11.1. By reading the messages in relevant Linux driver mailing lists, we find that kernel maintainers confirmed that these fixed bugs could cause serious problems, like system hangs. The results indicate DSAC can indeed find known bugs. 3) Of the 340 bugs reported by DSAC in the drivers of Linux 4.11.1, we have identified 320 as real bugs. 150 bugs are inherited from the legacy code in 3.17.2, and 170 bugs are introduced by new functionalities and new drivers. We have reported all the bugs that we identified as real to kernel maintainers. As of January 2018, 209 bugs have been confirmed, and replies for the other bugs have not been received. The results indicate DSAC can indeed find new real bugs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>(</head><label></label><figDesc>a) Linux gma500 driver (b) FreeBSD scsi_sa driver (c) NetBSD if_vte driver Figure 6: Examples of the real bugs detected by DSAC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>401 new real bugs are found, of which 272 have been confirmed by kernel developers.  Only 27 reports are false positives. Thus the overall false positive rate of bug detection is only 6.3%.  61 recommended patches are generated, of which 43 have been applied by kernel maintainers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>( 4 ) a pattern-based method to automatically gener- ate recommended patches to help fix the bugs.</head><label>4</label><figDesc></figDesc><table> Based on the four techniques, we propose a practi-
cal approach named DSAC, to accurately and effi-
ciently detect SAC bugs in kernel modules and au-
tomatically recommend patches to help fix the bugs. 

 We evaluate DSAC on drivers in Linux 3.17.2 and 
4.11.1. We select these kernel versions as they are 
near the beginning of stable series, and thus the 
simplest bugs should have been fixed in them. We 
find 200 and 320 real bugs respectively in these 
versions. 50 real bugs in 3.17.2 have been fixed in 
4.11.1, and 209 real bugs in 4.11.1 have been con-
firmed by kernel maintainers. To validate the gen-
erality and portability, we use DSAC to check file 
systems and network modules in the Linux kernel, 
and then run it in FreeBSD 11.0 and NetBSD 7.1 to 
check their kernel code, and find 81 new real bugs. 
43 generated patches for the three OS kernels have 
been applied by kernel maintainers. 
The remainder of the paper is organized as follows. 
Section 2 presents the background. Section 3 presents 
the challenges and our techniques. Section 4 introduces 
DSAC in detail. Section 5 presents the evaluation. Sec-
tion 6 compares DSAC to previous approaches. Section 
7 presents limitations and future work. Section 8 gives 
the related work. Section 9 concludes this paper. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>if lock_stack == ø and g_intr_flag == FALSE thenif PathHasExisted(mycall, path_stack) == TRUE thenmyfunc) == TRUE or g_intr_flag == TRUE then</head><label></label><figDesc></figDesc><table>: linux-2.6.38/drivers/usb/gadget/mv_udc_core.c 

382. static struct mv_dtd *build_dtd(…) { 
…… 
399. dtd = dma_pool_alloc(udc-&gt;dta_pool, GFP_KERNEL, dma); 
…… 
438. } 

441. static int req_to_dtd(…) { 
…… 
452. dtd = build_dtd(…); 
…… 
473. } 

724. static int mv_ep_queue(…) { 
…… 
774. spin_lock_irq_save(…); 
775. req_to_dtd(…); 
…… 
799. } HanCall(mycall, path_stack, lock_stack) 

1: 2: 
return; 
3: end if 
4: 5: 
return; 
6: end if 
7: AddPathStack(mycall, path_stack); 
8: myfunc := GetCalledFunction(mycall); 
9: HowToFunc(myfunc, path_stack, lock_stack, g_intr_flag); 
10: if IsModuleFunc(myfunc) == FALSE then 
11: 
return; 
12: end if 
13: if IsTargetFunc(14: 
entry_block := GetEntryBlock(myfunc); 
15: 
HanBlock(entry_block, path_stack, lock_stack); 
16: else 
17: 
foreach call in FunctionCallList(myfunc) do 
18: 
HanCall(call, path_stack, lock_stack); 
19: 
end foreach 
20: end if 

HanBlock(myblock, path_stack, lock_stack) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>able:  It calls a basic sleep-able function, like schedule in the Linux kernel and sleep in the NetBSD kernel.  It is called with a specific constant argument indi- cating it can sleep, like GFP_KERNEL in the Linux kernel and M_WAITOK in the FreeBSD kernel.</head><label></label><figDesc>. The collected information is stored into a da- tabase as intermediate results, including the function name, constant arguments, file name and so on. Second- ly, we use some heuristics to inter-procedurally analyze the call graph of each collected kernel interface, and determine whether it can sleep. If a kernel interface satisfies one of the five criteria, we identify it sleep-</figDesc><table> It calls a specific macro that indicates the operation 
can sleep, like might_sleep in the Linux kernel. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>With</head><label></label><figDesc>Code compiler. For a given kernel module, this part compiles all the source files of the kernel module into a single LLVM bytecode file.the extracted sleep-able kernel interfaces and intermediate results, this part reuses our hybrid flow analysis to automatically detect possible SAC bugs from the LLVM bytecode.  Bug filter. This part uses our path-check method to filter out repeated and false bugs and generates re- ports for the final detected SAC bugs.  Patch generator. With the bug code paths and ker- nel module source code, this part uses our pattern- based method to automatically recommend patches to help fix the bugs. Based on the architecture, DSAC consists of four phases which are introduced as follows.</figDesc><table> Function extractor. With the LLVM bytecode and 
the kernel source code, this part uses our hybrid 
flow analysis and heuristics-based method to gen-
erate intermediate results and extract sleep-able 
kernel interfaces called in the kernel module(s). 

 Bug detector. </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head></head><label></label><figDesc>presents the results for Linux 3.17.2 and 4.11.1. We make the following observations: 1) DSAC can scale to large code bases. It handles 7M and 9M source code lines from 8K and 11K source files. And the analysis is started from many entry basic blocks and many interrupt handler (INTR) functions.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="true"><head>Table 1 : Results of extracting sleep-able kernel interfaces.</head><label>1</label><figDesc></figDesc><table>Description 
3.17.2 
4.11.1 

Code 
handling 

Handled bytecode files 
3377 
4396 
Source files (.c) 
8321 
11153 
Source code lines 
7392K 
9464K 
Hybrid flow 
analysis 

Entry basic blocks 
32167 
37770 
Handled INTR functions 
578 
673 
Heuristic 
extraction 

Recorded functions 
3104 
3613 
Sleep-able kernel interfaces 
70 (51) 
94 (63) 

Time usage 

Original compilation 
47m21s 
55m34s 
DSAC total 
108m43s 
129m58s 
DSAC pure 
61m22s 
74m22s 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="true"><head>Table 2 : Detected bugs and generated patches in drivers.</head><label>2</label><figDesc></figDesc><table>Description 
3.17.2 
4.11.1 

Detected bugs 

Repeated filtered 
479630 
629924 
False filtered 
282 
430 
Final detected 
215 
340 
Interrupt handling 
7 
17 
Real 
200 
320 

Patch generation 

P1 (replace the function) 
-
28 (18) 
P2 (replace the flag) 
-
15 (12) 
Total 
-
43 (30) 

Time usage 

Bug detection 
6m31s 
8m46s 
Patch generation 
-
1m02s 
Total 
6m31s 
9m48s </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="true"><head>Table 4 : Results of Linux fs and net, FreeBSD and NetBSD.</head><label>4</label><figDesc></figDesc><table>Description 
fs &amp; net FreeBSD NetBSD 

Code 
handling 

Handled bytecode files 
925 
632 
710 
Source files 
2506 
1615 
1977 
Source code lines 
2013K 
1759K 
1896K 
Function 
extraction 

Recorded functions 
1927 
582 
304 
Sleep-able kernel interfaces 
34 
12 
10 

Bugs &amp; 
patches 

Filtered bugs 
682081 
508 
2414 
Final detected bugs 
42 
39 
7 
Real bugs 
39 
35 (26) 
7 (7) 
Generated patches 
5 
10 
3 
Pure time usages 
32m45s 49m12s 43m38s 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>Table 3 : Bug distribution according to driver class.</head><label>3</label><figDesc></figDesc><table>Driver Class 
scsi 
network staging 
gpio 
others 

Bugs 
103 (32%) 84 (26%) 62 (19%) 12 (4%) 59 (18%) </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>We select the bugs related to the x86 architecture based on driver Kconfig files.the kernel configuration allyesconfig to enable all drivers for the x86 architecture</head><label></label><figDesc>. DSAC reports 42 sleep-able kernel interfaces and 228 reported SAC bugs. We manually check the bugs and find that 208 are real.</figDesc><table>have consid-
ered SAC bugs. Among them, we select the BlockLock 
checker [34] to make a detailed comparison. We select 
this approach because: (1) It is a state-of-the-art tool to 
detect SAC bugs in the Linux kernel. (2) It is open-
source and its bug reports are available [54]. In design, 
DSAC has some key improvements over BlockLock: 
Code analysis. BlockLock only uses one bit of context 
information to check if a lock is held, so it may not ac-

curately identify the code in atomic context when multi-
ple locks are taken but only some of them are released. 
DSAC maintains a complete lock stack and performs 
context-sensitive analysis, thus it can accurately detect 
all code in atomic context. BlockLock is also not sensi-
tive to the module Makefile, and thus may choose the 
wrong definition when unfolding a function call if the 
called function has multiple definitions. DSAC uses the 
module Makefile to accurately identify the definition of 
each function. And DSAC can detect SAC bugs in inter-
rupt handlers and involving sleeping operations other 
than a call to an allocation function with GFP_KERNEL, 
which are not considered by BlockLock. 
Sleep-able function extraction. BlockLock regards all 
functions called in the kernel as candidate functions to 
extract sleep-able functions. This strategy entails check-
ing each function in the kernel inter-procedurally, so it 
may require much time. DSAC only treats the kernel 
interfaces possibly called in atomic context of the ana-
lyzed kernel module(s) as candidate functions, and skips 
the other functions not called in atomic context. 
False bug filtering. BlockLock does not consider varia-
ble value information to validate path conditions, which 
may cause a number of false positives. DSAC checks 
the detailed code path of each possible bug, and filters 
out false bugs using useful and common semantic in-
formation for variables in atomic context. 
Patch generation. BlockLock only reports bugs, but it 
does not help fix the bugs. DSAC uses common fixing 
patterns to generate recommended patches to help fix 
the bugs. The produced code paths of the bugs are also 
useful to help the user write log messages in the patches. 
We also compare the results of BlockLock and DSAC, 
with two steps. Firstly, we download the bug reports of 
BlockLock on Linux 2.6.33 drivers, and get 49 reported 
bugs. We get 31 reported SAC 
bugs (25 real bugs and 6 false bugs). Secondly, we use 
DSAC to check the Linux 2.6.33 driver source code. 
We use </table></figure>

			<note place="foot" n="1"> DSAC website: http://oslab.cs.tsinghua.edu.cn/DSAC/index.html</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Automatic verification of active device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Amani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Chubb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">F</forename><surname>Donaldson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Legg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">C</forename><surname>Ong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ryzhyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGOPS Operating System Review</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="106" to="118" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Beyond bug-finding: sound program analysis for Linux</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Brewer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ennals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Workshop on Hot Topics in Operating Systems (HotOS)</title>
		<meeting>the 11th International Workshop on Hot Topics in Operating Systems (HotOS)</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Runtime checking for paired functions in device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Bai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">Q</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">P</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Asia-Pacific Software Engineering Conference (APSEC)</title>
		<meeting>the 21st Asia-Pacific Software Engineering Conference (APSEC)</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="407" to="414" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Mining and checking paired functions in device drivers using characteristics fault injection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Bai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">P</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">Q</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information and Software Technology</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">73</biblScope>
			<biblScope unit="page" from="122" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Thorough static analysis of device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bounimova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Cook</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lichtenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mcgarvey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ondrusek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Rajamani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ustuner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st European Conference on Computer Systems (EuroSys)</title>
		<meeting>the 1st European Conference on Computer Systems (EuroSys)</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="73" to="85" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">KLEE: unassisted and automatic generation of high-coverage tests for complex systems programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dunbar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>the 8th International Conference on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="209" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A deployable sampling strategy for data race detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Symposium on Foundations of Software Engineering (FSE)</title>
		<meeting>the 24th International Symposium on Foundations of Software Engineering (FSE)</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="810" to="821" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Kivati: fast detection and prevention of atomic violations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Chew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 5th European Conference on Computer Systems (EuroSys)</title>
		<meeting>5th European Conference on Computer Systems (EuroSys)</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="307" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An empirical study of operating systems errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Symposium on Operating Systems Principles (SOSP)</title>
		<meeting>the 18th International Symposium on Operating Systems Principles (SOSP)</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="73" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Atomic context and kernel API design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Corbet</surname></persName>
		</author>
		<ptr target="https://lwn.net/Articles/274695/" />
	</analytic>
	<monogr>
		<title level="m">Linux Weekly News (LWN.net)</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Spinlocks and atomic context</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Corbet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rubini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">K</forename><surname>Hartman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Linux Device Drivers</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="118" to="119" />
		</imprint>
	</monogr>
	<note>3rd edition</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Assessment and improvement of hang detection in the Linux operating system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cotroneo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Natella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Russo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Symposium on Reliable Distributed Systems (SRDS)</title>
		<meeting>the 28th International Symposium on Reliable Distributed Systems (SRDS)</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="288" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast and precise symbolic analysis of concurrency bugs in device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Deligiannis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">F</forename><surname>Donaldson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Rakamaric</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th International Conference on Automated Software Engineering (ASE)</title>
		<meeting>the 30th International Conference on Automated Software Engineering (ASE)</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="166" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Symbolic deadlock analysis in concurrent libraries and their clients</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Deshmukh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sankaranarayanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th International Conference on Automated Software Engineering (ASE)</title>
		<meeting>the 24th International Conference on Automated Software Engineering (ASE)</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="480" to="491" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">RacerX: effective, static detection of race conditions and deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ashcraft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Symposium on Operating Systems Principles (SOSP)</title>
		<meeting>the 19th International Symposium on Operating Systems Principles (SOSP)</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="237" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Checking system rules using system-specific, programmer-written compiler extensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hallem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Conference on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>the 4th International Conference on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Effective data-race detection for the kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Erickson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Burckhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Olynyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International Conference on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>the 9th International Conference on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="151" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">SKI: exposing kernel concurrency bugs through systematic schedule exploration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Brandenburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Conference on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>the 11th International Conference on Operating Systems Design and Implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="415" to="431" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Finding complex concurrency bugs in large multi-threaded applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rodrigues</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th European Conference on Computer Systems (EuroSys)</title>
		<meeting>the 6th European Conference on Computer Systems (EuroSys)</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="215" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The design and implementation of microdrivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ganapathy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Renzelmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="168" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Has the bug really been fixed?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">T</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Hamilton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
		<idno>pag- es 55-64</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd International Conference on Software Engineering (ICSE)</title>
		<meeting>the 32nd International Conference on Software Engineering (ICSE)</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Bootstrapping: a technique for scalable flow and context-sensitive pointer alias analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kahlon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Conference on Programming Language Design and Implementation (PLDI)</title>
		<meeting>the 29th International Conference on Programming Language Design and Implementation (PLDI)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="249" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Frequent pattern mining for kernel trace data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Larosa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mandelberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd Annual ACM Symposium on Applied Computing (SAC)</title>
		<meeting>the 23rd Annual ACM Symposium on Applied Computing (SAC)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="880" to="885" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">WYSIWIB: a declarative approach to finding API protocols and bugs in Linux code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Brunel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Palix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Stuart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th International Conference on Dependable Systems and Networks (DSN)</title>
		<meeting>the 39th International Conference on Dependable Systems and Networks (DSN)</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="43" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">User-level device drivers: achieved performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Leslie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Chubb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Fitzroy-Dale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Götz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Macpherson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Potts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">T</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Elphinstone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Heiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Journal of Computer Science and Technology</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="654" to="664" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Effectively manifesting concurrency bugs in Android apps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd Asia-Pacific Software Engineering Conference (APSEC)</title>
		<meeting>the 23rd Asia-Pacific Software Engineering Conference (APSEC)</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="209" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">PR-Miner: automatically extracting implicit programming rules and detecting violations in large software code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Symposium on Foundations of Software Engineering (FSE)</title>
		<meeting>the 13th International Symposium on Foundations of Software Engineering (FSE)</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="306" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">DCatch: automatically detecting distributed concurrency bugs in cloud systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Lukman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S</forename><surname>Gunawi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Tian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the 22nd International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="677" to="691" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Interrupt context</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Love</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Linux Kernel Development</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page">122</biblScope>
		</imprint>
	</monogr>
	<note>3rd edition</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">RID: finding reference count bugs with inconsistent path pair checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the 21st International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="531" to="544" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Crosschecking semantic correctness: the case of finding file system bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles (SOSP)</title>
		<meeting>the 25th Symposium on Operating Systems Principles (SOSP)</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="361" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Effective static race detection for Java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Whaley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th International Conference on Programming Language Design and Implementation (PLDI)</title>
		<meeting>the 27th International Conference on Programming Language Design and Implementation (PLDI)</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="308" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Documenting and automating collateral evolutions in Linux device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Padioleau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd European Conference on Computer Systems (EuroSys)</title>
		<meeting>the 3rd European Conference on Computer Systems (EuroSys)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="247" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Faults in Linux 2.6</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Palix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Calvè S</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lawall</surname></persName>
		</author>
		<idno>1-4:40</idno>
	</analytic>
	<monogr>
		<title level="m">ACM Transactions on Computer Systems (TOCS)</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">32</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Decaf: moving device drivers to a modern language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Renzelmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 Conference on USENIX Annual Technical Conference (USENIX ATC)</title>
		<meeting>the 2009 Conference on USENIX Annual Technical Conference (USENIX ATC)</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The case for active device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ryzhyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Heiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st Aisa-Pacific Workshop on Systems (APSys)</title>
		<meeting>the 1st Aisa-Pacific Workshop on Systems (APSys)</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="25" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Hector: detecting resource-release omission faults in error-handling code for systems software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Lozi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd International Conference on Dependable Systems and Networks (DSN)</title>
		<meeting>the 43rd International Conference on Dependable Systems and Networks (DSN)</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Static deadlock detection for asynchronous C# programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Santhiar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kanade</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th International Conference on Programming Language Design and Implementation (PLDI)</title>
		<meeting>the 38th International Conference on Programming Language Design and Implementation (PLDI)</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="292" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Improving the reliability of commodity operating systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">M</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Symposium on Operating Systems Principles (SOSP)</title>
		<meeting>the 19th International Symposium on Operating Systems Principles (SOSP)</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="207" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">aComment: mining annotations from comments and code to detect interrupt related concurrency bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Padioleau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd International Conference on Software Engineering (ICSE)</title>
		<meeting>the 33rd International Conference on Software Engineering (ICSE)</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="11" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Static race detection for device drivers: the Goblint approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vojdani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Apinis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Rõtov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Seidl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vene</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Vogler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st International Conference on Automated Software Engineering (ASE)</title>
		<meeting>the 31st International Conference on Automated Software Engineering (ASE)</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="391" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Analyzing concurrency bugs using dual slicing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weeratunge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">N</forename><surname>Sumner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jagannathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Symposium on Software Testing and Analysis (ISSTA)</title>
		<meeting>the 19th International Symposium on Software Testing and Analysis (ISSTA)</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="253" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Static deadlock detection for Java libraries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Thies</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th</title>
		<meeting>the 19th</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
				<title level="m">European Conference on Object-Oriented Programming (ECOOP)</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="602" to="629" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Model checking concurrent Linux device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Witkowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Blanc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Weissenbacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Conference on Automated Software Engineering (ASE)</title>
		<meeting>the 22nd International Conference on Automated Software Engineering (ASE)</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="501" to="504" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Perracotta: mining temporal API rules from imperfect traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bhardwaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Bhat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 28th International Conference on Software Engineering (ICSE)</title>
		<meeting>28th International Conference on Software Engineering (ICSE)</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="282" to="291" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Level by level: making flow-and context-sensitive pointer analysis scalable for millions of lines of code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Huo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Symposium on Code Generation and Optimization (CGO)</title>
		<meeting>the 8th International Symposium on Code Generation and Optimization (CGO)</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="218" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">APISan: sanitizing API usages through semantic crosschecking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th USENIX Security Symposium</title>
		<meeting>the 25th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="363" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">What is system hang and how to handle it</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Symposium on Software Reliability Engineering (ISSRE)</title>
		<meeting>the 23rd International Symposium on Software Reliability Engineering (ISSRE)</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="141" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">Linux kernel document for memory allocation</title>
		<ptr target="https://www.kernel.org/doc/htmldocs/kernel-api/API-kmalloc.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Llvm Compiler Infrastructure</surname></persName>
		</author>
		<ptr target="https://llvm.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Faults in Linux: Ten years later</title>
		<ptr target="http://faultlinux.lip6.fr/" />
		<imprint/>
	</monogr>
	<note>Website for</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
