<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T03:09+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Enforcing Network-Wide Policies in the Presence of Dynamic Middlebox Actions using FlowTags Enforcing Network-Wide Policies in the Presence of Dynamic Middlebox Actions using FlowTags</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>April 2-4, 2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seyed</forename><forename type="middle">Kaveh</forename><surname>Fayazbakhsh</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seyed</forename><forename type="middle">Kaveh</forename><surname>Fayazbakhsh</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luis</forename><surname>Chiang</surname></persName>
							<affiliation key="aff4">
								<orgName type="laboratory">Deutsche Telekom Labs ‡ USC 񮽙 Google</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vyas</forename><surname>Sekar</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Carnegie Mellon University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minlan</forename><surname>Yu</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>񮽙</roleName><forename type="first">Jeffrey</forename><forename type="middle">C</forename><surname>Mogul</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<addrLine>Luis Chiang</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Deutsche Telekom Labs</orgName>
								<orgName type="institution" key="instit2">Vyas Sekar</orgName>
								<orgName type="institution" key="instit3">Carnegie Mellon University</orgName>
								<address>
									<addrLine>Minlan Yu</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">University of Southern California</orgName>
								<orgName type="institution" key="instit2">Jeffrey C. Mogul</orgName>
								<address>
									<settlement>Google</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Enforcing Network-Wide Policies in the Presence of Dynamic Middlebox Actions using FlowTags Enforcing Network-Wide Policies in the Presence of Dynamic Middlebox Actions using FlowTags</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 11th USENIX Symposium on Networked Systems Design and Implementation (NSDI &apos;14)</title>
						<meeting>the 11th USENIX Symposium on Networked Systems Design and Implementation (NSDI &apos;14) <address><addrLine>Seattle, WA, USA</addrLine></address>
						</meeting>
						<imprint>
							<biblScope unit="page">533</biblScope>
							<date type="published">April 2-4, 2014</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 11th USENIX Symposium on Networked Systems Design and Implementation (NSDI &apos;14) is sponsored by USENIX https://www.usenix.org/conference/nsdi14/technical-sessions/presentation/fayazbakhsh</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Middleboxes provide key security and performance guarantees in networks. Unfortunately, the dynamic traffic modifications they induce make it difficult to reason about network management tasks such as access control, accounting, and diagnostics. This also makes it difficult to integrate middleboxes into SDN-capable networks and leverage the benefits that SDN can offer. In response, we develop the FlowTags architecture. FlowTags-enhanced middleboxes export tags to provide the necessary causal context (e.g., source hosts or internal cache/miss state). SDN controllers can configure the tag generation and tag consumption operations using new FlowTags APIs. These operations help restore two key SDN tenets: (i) bindings between packets and their &quot;origins,&quot; and (ii) ensuring that packets follow policy-mandated paths. We develop new controller mechanisms that leverage FlowTags. We show the feasibility of minimally extending middleboxes to support FlowTags. We also show that FlowTags imposes low overhead over traditional SDN mechanisms. Finally, we demonstrate the early promise of FlowTags in enabling new verification and diagnosis capabilities.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Many network management tasks are implemented using custom middleboxes, such as firewalls, NATs, proxies, intrusion detection and prevention systems, and application-level gateways <ref type="bibr" target="#b42">[53,</ref><ref type="bibr" target="#b43">54]</ref>. Even though middleboxes offer key performance and security benefits, they introduce new challenges: (1) it is difficult to ensure that "service-chaining" policies (e.g., web traffic should be processed by a proxy and then a firewall) are implemented correctly <ref type="bibr" target="#b38">[49,</ref><ref type="bibr" target="#b39">50]</ref>, and (2) they hinder other management functions such as performance debugging and forensics <ref type="bibr" target="#b45">[56]</ref>. Our conversations with enterprise operators suggest that these problems get further exacerbated with the increasing adoption of virtualized/multi-tenant deployments.</p><p>The root cause of this problem is that traffic is modified by dynamic and opaque middlebox behaviors. Thus, the promise of software-defined networking (SDN) to enforce and verify network-wide policies (e.g., <ref type="bibr" target="#b28">[39,</ref><ref type="bibr" target="#b29">40,</ref><ref type="bibr" target="#b33">44]</ref>) does not extend to networks with middleboxes. Specifically, middlebox actions violate two key SDN tenets <ref type="bibr" target="#b13">[24,</ref><ref type="bibr" target="#b21">32]</ref>: 1. ORIGINBINDING: There should be a strong binding between a packet and its "origin" (i.e., the network entity that originally created the packet); 2. PATHSFOLLOWPOLICY: Explicit policies should determine the paths that packets follow. <ref type="bibr" target="#b0">1</ref> For instance, NATs and load balancers dynamically rewrite packet headers, thus violating ORIGINBINDING. Similarly, dynamic middlebox actions, such as responses served from a proxy's cache, may violate PATHSFOL-LOWPOLICY. (We elaborate on these examples in §2.)</p><p>Some might argue that middleboxes can be eliminated (e.g., <ref type="bibr" target="#b15">[26,</ref><ref type="bibr" target="#b43">54]</ref>), or that their functions can be equivalently provided in SDN switches (e.g., <ref type="bibr" target="#b30">[41]</ref>), or that we should replace proprietary boxes by open solutions (e.g, <ref type="bibr" target="#b9">[20,</ref><ref type="bibr" target="#b41">52]</ref>). While these are valuable approaches, practical technological and business concerns make them untenable, at least for the foreseeable future. First, there is no immediate roadmap for SDN switches to support complex stateful processing. Second, enterprises already have a significant deployed infrastructure that is unlikely to go away. Furthermore, these solutions do not fundamentally address ORIGINBINDING and PATHSFOLLOW-POLICY; they merely shift the burden elsewhere.</p><p>We take a pragmatic stance that we should attempt to integrate middleboxes into the SDN fold as "cleanly" as possible. Thus, our focus in this paper is to systematically (re-)enforce the ORIGINBINDING and PATHSFOL-LOWPOLICY tenets, even in the presence of dynamic middlebox actions. We identify flow tracking as the key to policy enforcement. <ref type="bibr" target="#b1">2</ref> That is, we need to reliably associate additional contextual information with a traffic flow as it traverses the network, even if packet headers and contents are modified. This helps determine the packet's true endpoints rather than rewritten versions (e.g., as with load balancers), and to provide hints about the packet's provenance (e.g., a cached response).</p><p>Based on this insight, we extend the SDN paradigm with the FlowTags architecture. Because middleboxes are in the best (and possibly the only) position to provide the relevant contextual information, FlowTags envisions simple extensions to middleboxes to add tags, carried in packet headers. SDN switches use the tags as part of their flow matching logic for their forwarding operations. Downstream middleboxes use the tags as part of their packet processing workflows. We retain existing SDN switch interfaces and explicitly decouple middleboxes and switches, allowing the respective vendors to innovate independently.</p><p>Deploying FlowTags thus has two prerequisites: (P1) adequate header bits with SDN switch support to match on tags and (P2) extensions to middlebox software. We argue that (P1) is possible in IPv4; quite straightforward in IPv6; and will become easier with recent OpenFlow standards that allow flexible matching <ref type="bibr" target="#b4">[9]</ref> and new switch hardware designs <ref type="bibr" target="#b12">[23]</ref>. As we show in §6, (P2) requires minor code changes to middlebox software.</p><p>Contributions and roadmap: While some of these arguments appeared in an earlier position paper <ref type="bibr" target="#b17">[28]</ref>, several practical questions remained w.r.t. (1) policy abstractions to capture the dynamic middlebox scenarios; (2) concrete controller design; (3) the viability of extending middleboxes to support FlowTags; and (4) the practical performance and benefits of FlowTags.</p><p>Our specific contributions in this paper are: • We describe controller-middlebox interfaces to configure tagging capabilities ( §4), and new controller policy abstractions and rule-generation mechanisms to explicitly configure the tagging logic ( §5).</p><p>• We show that it is possible to extend five software middleboxes to support FlowTags, each requiring less than 75 lines of custom code in addition to a common 250-line library. (To put these numbers in context, the middleboxes we have modified have between 2K to over 300K lines of code.) ( §6).</p><p>• We demonstrate that FlowTags enables new verification and network diagnosis methods that are otherwise hindered due to middlebox actions ( §7).</p><p>• We show that FlowTags adds little overhead over SDN mechanisms, and that the controller is scalable ( §8). §9 discusses related work; §10 sketches future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and Motivation</head><p>In this section we present a few examples that highlight how middlebox actions violate ORIGINBINDING and PATHSFOLLOWPOLICY, thus making it difficult to enforce network-wide policies and affecting other management tasks such as diagnosis. We also discuss why some seemingly natural strawman solutions fail to address our requirements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Motivating Scenarios</head><p>Attribution problems: <ref type="figure" target="#fig_0">Figure 1</ref> shows two middleboxes: a NAT that translates private IPs to public IPs and a firewall configured to block hosts H 1 and H 3 from accessing specific public IPs. Ideally, we want administrators to configure firewall policies in terms of original source IPs. Unfortunately, we do not know the privatepublic IP mappings that the NAT chooses dynamically; i.e., the ORIGINBINDING tenet is violated. Further, if only traffic from H 1 and H 3 should be directed to the firewall and the rest is allowed to pass through, an SDN controller cannot install the correct forwarding rules at switches S 1 /S 2 , as the NAT changes the packet headers; i.e., PATHSFOLLOWPOLICY no longer holds. Network diagnosis: In <ref type="figure" target="#fig_1">Figure 2</ref>, suppose the users of hosts H 1 and H 3 complain about high network latency. In order to debug and resolve this problem (e.g., determine if the middleboxes need to be scaled up <ref type="bibr" target="#b19">[30]</ref>), the network administrator may use a combination of hostlevel (e.g., X-Trace <ref type="bibr" target="#b18">[29]</ref>) and network-level (e.g., <ref type="bibr" target="#b2">[3]</ref>) logs to break down the delay for each request into persegment components as shown. Because ORIGINBIND-ING does not hold, it is difficult to correlate the logs to track flows <ref type="bibr" target="#b39">[50,</ref><ref type="bibr" target="#b45">56]</ref>. Data-dependent policies: In <ref type="figure">Figure 3</ref>, the light IPS checks simple features (e.g., headers); we want to route suspicious packets to the heavy IPS, which runs deeper analysis to determine if the packet is malicious. Such a triggered architecture is quite common; e.g., rerouting suspicious packets to dedicated packet scrubbers <ref type="bibr" target="#b5">[12]</ref>.</p><p>The problem here is that ensuring PATHSFOLLOWPOL-ICY depends on the processing history; i.e., did the light IPS flag a packet as suspicious? However, each switch and middlebox can only make processing or forwarding decisions with its link-local view.  <ref type="figure">Figure 3</ref>: S 2 cannot decide if an incoming packet should be sent to the heavy IPS or the server.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>񮽙</head><p>Policy violations due to middlebox actions: <ref type="figure">Figure 4</ref> shows a proxy used in conjunction with an access control device (ACL  <ref type="figure">Figure 4</ref>: Lack of visibility into the middlebox context (i.e., cache hit/miss in this example) makes policy enforcement challenging.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Strawman Solutions</head><p>Next, we highlight why some seemingly natural strawman solutions fail to address the above problems. Due to space constraints, we discuss only a few salient candidates; <ref type="table" target="#tab_3">Table 1</ref> summarizes their effectiveness in the previously-presented examples.</p><p>Placement constraints: One way to ensure ORIGIN-BINDING/PATHSFOLLOWPOLICY is to "hardwire" the policy into the topology. In <ref type="figure" target="#fig_0">Figure 1</ref>, we could place the firewall before the NAT. Similarly, for <ref type="figure">Figure 3</ref> we could connect the light IPS and the heavy IPS to S 1 , and configure the light IPS to emit legitimate/suspicious packets   on different output ports. S 1 can then use the incoming port to determine if the packet should be sent to the heavy IPS. This coupling between policy and topology, however, violates the SDN philosophy of decoupling the control logic from the data plane. Furthermore, this restricts flexibility to reroute under failures, load balance across middleboxes, or customize policies for different workloads <ref type="bibr" target="#b39">[50]</ref>.</p><p>Tunneling: Another option to ensure PATHSFOLLOW-POLICY is to set up tunneling rules, for example, using MPLS or virtual circuit identifiers (VCIs). For instance, we could tunnel packets from the "suspicious" output of the light IPS to the heavy IPS in <ref type="figure">Figure 3</ref>. (Note that this requires middleboxes to support tunnels.) Such topology/tunneling solutions may work for simple examples, but they quickly break for more complex policies; e.g., if there are more outputs from the light IPS. Note that even by combining placement+tunneling, we cannot solve the diagnosis problem in <ref type="figure" target="#fig_1">Figure 2</ref>, as it does not provide ORIGINBINDING.</p><p>Middlebox consolidation: At first glance, it may seem that we can ensure PATHSFOLLOWPOLICY by running all middlebox functions on a consolidated platform <ref type="bibr" target="#b9">[20,</ref><ref type="bibr" target="#b41">52]</ref>. While consolidation provides other benefits (e.g., reduced hardware costs), it has several limitations. First, it requires a significant network infrastructure change. Second, it merely shifts the burden of PATHSFOLLOWPOLICY to the internal routing "shim" that routes packets between the modules. Finally, if the individual modules are provided by different vendors, diagnosis and attribution is hard, as this shim cannot ensure ORIGINBINDING.</p><p>Flow correlation: Prior work attempts to heuristically correlate the payloads of the traffic entering and leaving middleboxes to correlate flows <ref type="bibr" target="#b38">[49]</ref>. However, this approach can result in missed/false matches too of- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>񮽙 񮽙񮽙񮽙 񮽙</head><p>Figure 5: <ref type="figure" target="#fig_0">Figure 1</ref> augmented to illustrate how tags can solve the attribution problem.</p><p>ten to be useful for security applications <ref type="bibr" target="#b38">[49]</ref>. Also, such "reverse engineering" approaches fundamentally lack ground truth. Finally, this process has high overhead, as multiple packets per flow need to be processed at the controller in a stateful manner (e.g., when reassembling packet payloads).</p><p>As <ref type="table" target="#tab_3">Table 1</ref> shows, none of these strawman solutions can address all of the motivating scenarios. In some sense, each approach partially addresses some symptoms of the violations of ORIGINBINDING and PATHSFOL-LOWPOLICY, but does not address the cause of the problem. Thus, despite the complexity they entail in terms of topology hacks, routing, and middlebox and controller upgrades, they have limited applicability and have fundamental correctness limitations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">FlowTags Overview</head><p>As we saw in the previous section, violating the ORIG-INBINDING and PATHSFOLLOWPOLICY tenets makes it difficult to correctly implement several network management tasks. To address this problem, we propose the FlowTags architecture. In this section, we highlight the main intuition behind FlowTags, and then we show how FlowTags extends the SDN paradigm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Intuition</head><p>FlowTags takes a first-principles approach to ensure that ORIGINBINDING and PATHSFOLLOWPOLICY hold even in the presence of middlebox actions. Since the middleboxes are in the best (and sometimes the only) position to provide the relevant context (e.g., a proxy's cache hit/miss state or a NAT's public-private IP mappings), we argue that middleboxes need to be extended in order to be integrated into SDN frameworks.</p><p>Conceptually, middleboxes add tags to outgoing packets. These tags provide the missing bindings to ensure ORIGINBINDING and the necessary processing context to ensure PATHSFOLLOWPOLICY. The tags are then used in the data plane configuration of OpenFlow switches and other downstream middleboxes.</p><p>To explain this high-level idea, let us revisit the example in <ref type="figure" target="#fig_0">Figure 1</ref> and extend it with the relevant tags and ac- tions as shown in <ref type="figure">Figure 5</ref>. We have three hosts H 1 − H 3 in an RFC1918 private address space; the administrator wants to block the Internet access for H 1 and H 3 , and allow H 2 's packets to pass through without going to the firewall. The controller (not shown) configures the NAT to associate outgoing packets from H 1 , H 2 , and H 3 with the tags 1, 2, and 3, respectively, and adds these to prespecified header fields. (See §5.3). The controller configures the firewall so that it can decode the tags to map the observed IP addresses (i.e., in "public" address space using RFC1918 terminology) to the original hosts, thus meeting the ORIGINBINDING requirement. Similarly, the controller configures the switches to allow packets with tag 2 to pass through without going to the firewall, thus meeting the PATHSFOLLOWPOLICY requirement. As an added benefit, the administrator can configure firewall rules w.r.t. the original host IP addresses, without needing to worry about the NAT-induced modifications.</p><p>This example highlights three key aspects of FlowTags. First, middleboxes (e.g., the NAT) are generators of tags (as instructed by the controller). The packetprocessing actions of a FlowTags-enhanced middlebox might entail adding the relevant tags into the packet header. This is crucial for both ORIGINBINDING and PATHSFOLLOWPOLICY, depending on the middlebox.</p><p>Second, other middleboxes (e.g., the firewall) are consumers of tags, and their processing actions need to decode the tags. This is necessary for ORIGINBINDING. (In this simple example, each middlebox only generates or only consumes tags. In general, however, a given middlebox could both consume and generate tags.)</p><p>Third, SDN-capable switches in the network use the tags as part of their forwarding actions, in order to route packets according to the controller's intended policy, ensuring PATHSFOLLOWPOLICY holds.</p><p>Note that the FlowTags semantics apply in the context of a single administrative domain. In the simple case, we set tag bits to NULL on packets exiting the domain. <ref type="bibr" target="#b2">3</ref> This alleviates concerns that the tag bits may accidentally leak proprietary topology or policy information. When incoming packets arrive at an external interface, the gateway sets the tag bits appropriately (e.g., to ensure stateful middlebox traversal) before forwarding the packet into the domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Architecture and Interfaces</head><p>Next, we describe the interfaces between the controller, middleboxes, switches, and the network administrator in a FlowTags-enhanced SDN architecture.</p><p>Current SDN standards (e.g., OpenFlow <ref type="bibr" target="#b34">[45]</ref>) define the APIs between the controller and switches. As shown in FlowTags requires neither new capabilities from SDN switches, nor any direct interactions between middleboxes and switches. Switches continue to use traditional SDN APIs such as OpenFlow. The only interaction between switches and middleboxes is indirect, via tags embedded inside the packet headers. We take this approach for two reasons: (1) to allow switch and middlebox designs and their APIs to innovate independently; and <ref type="formula">(2)</ref> to retain compatibility with existing SDN standards (e.g., OpenFlow). Embedding tags in the headers avoids the need for each switch and middlebox to communicate with the controller on every packet when making their forwarding and processing decisions.</p><p>We retain existing configuration interfaces for customizing middlebox actions; e.g., vendor-specific languages or APIs to configure firewall/IDS rules. The advantage of FlowTags is that administrators can configure these rules without having to worry about the impact of intermediate middleboxes. For example, in the first scenario of §2.1, FlowTags allows the operator to specify firewall rules with respect to the original source IPs. This provides a cleaner mechanism, as the administrator does not need to reason about the space of possible header values a middlebox may observe. <ref type="bibr">4</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>񮽙</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">FlowTags APIs and Operation</head><p>Next, we walk through how a packet is processed in a FlowTags-enhanced network, and describe the main FlowTags APIs. For ease of presentation, we assume each middlebox is connected to the rest of the network via a switch. (FlowTags also works in a topology with middleboxes directly chained together.) We restrict our description to a reactive controller that responds to incoming packets, but proactive controllers are also possible.</p><p>For brevity, we only discuss the APIs pertaining to packet processing. Analogous to the OpenFlow configuration APIs, we envision functions to obtain and set FlowTags capabilities in middleboxes; e.g., which header fields are used to encode the tag values ( §5.3).</p><p>In general, the same middlebox can be both a generator and a consumer of tags. For clarity, we focus on these two roles separately. We assume that a packet, before it reaches any middlebox, starts with a NULL tag.</p><p>Middlebox tag generation, <ref type="figure">Figure 7</ref>: Before the middlebox outputs a processed (and possibly modified) packet, it sends the FT GENERATE QRY message to the controller requesting a tag value to be added to the packet (Step 1). As part of this query the middlebox provides the relevant packet processing context: e.g., a proxy tells the controller if this is a cached response; an IPS provides the processing verdict. The controller provides a tag value via the FT GENERATE RSP response (Step 2). (We defer tag semantics to the next section.) dlebox receives a tag-carrying packet, it needs to "decode" this tag; e.g., an IDS needs the original IP 5-tuple for scan detection. The middlebox sends the FT CONSUME QRY message (Step 5) to the controller, which then provides the necessary decoding rule for mapping the tag via the FT CONSUME RSP message (Step 6).</p><p>Switch actions: In <ref type="figure">Figure 7</ref>, when the switch receives a packet from the middlebox with a tag (Step 3), it queries the controller with the OFPT PACKET IN message (Step 4), and the controller provides a new flow table entry (Step 5). This determines the forwarding action; e.g., whether this packet should be routed toward the heavy IPS in <ref type="figure">Figure 3</ref>. Similarly, when the switch receives a packet in <ref type="figure">Figure 8</ref> (Step 1), it requests a forwarding entry and the controller uses the tag to decide if this packet needs to be forwarded to the middlebox.</p><p>Most types of middleboxes operate at an IP flow or session granularity, and their dynamic modifications typically use a consistent header mapping for all packets of a flow. Thus, analogous to OpenFlow, a middlebox needs to send FT CONSUME QRY and FT GENERATE QRY only once per flow. The middlebox stores the per-flow tag rules locally, and subsequent packets in the same flow can reuse the cached tag rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">FlowTags Controller</head><p>In this section, we discuss how a FlowTags-enhanced SDN controller can assign tags and tags-related "rules" to middleboxes and switches. We begin with a policy abstraction ( §5.1) that informs the semantics that tags need to express ( §5.2). Then, we discuss techniques to translate this solution into practical encodings ( §5.3- §5.4). Finally, we outline the controller's implementation ( §5.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Dynamic Policy Graph</head><p>The input to the FlowTags controller is the policy that the administrator wants to enforce w.r.t. middlebox actions ( <ref type="figure" target="#fig_3">Figure 6</ref>). Prior work on middlebox policy focuses on a static policy graph that maps a given traffic class (e.g., as defined by network locations and flow header fields) to a chain of middleboxes <ref type="bibr" target="#b19">[30,</ref><ref type="bibr" target="#b27">38,</ref><ref type="bibr" target="#b38">49]</ref>. For instance, the administrator may specify that all outgoing web traffic from location A to location B must go, in order, through a firewall, an IDS, and a proxy. However, this static abstraction fails to capture the ORIGIN-BINDING and PATHSFOLLOWPOLICY requirements in the presence of traffic-dependent and dynamic middlebox actions. Thus, we propose the dynamic policy graph (or DPG) abstraction.</p><p>A DPG is a directed graph with two types of nodes: (1) In and Out nodes, and <ref type="formula">(2)</ref>   resents a type of middlebox function, such as "firewall." (For clarity, we restrict our discussion to "atomic" middlebox functions; a multi-function box will be represented using multiple nodes.) Each logical middlebox node is given a configuration that governs its processing behavior for each traffic class (e.g., firewall rulesets or IDS signatures). As discussed earlier, administrators specify middlebox configurations in terms of the unmodified traffic entering the DPG, without worrying about intermediate transformations.</p><p>Each edge in the DPG is annotated with the condition m → m � under which a packet needs to be steered from node m to node m � . This condition is defined in terms of (1) the traffic class, and (2) the processing context of node m, if applicable. <ref type="figure" target="#fig_5">Figure 9</ref> shows two DPG snippets:</p><p>• Data-dependent policies: <ref type="figure" target="#fig_5">Figure 9a</ref> revisits the example in <ref type="figure">Figure 3</ref>. Here, we want all traffic to be first processed by the light IPS. If the light IPS flags a packet as suspicious, then it should be sent to the heavy IPS. In this case, the edge connecting the light IPS to the heavy IPS is labeled "*, Alarm", where * denotes the class of "any traffic," and Alarm provides the relevant processing history from the light IPS.</p><p>• Capturing effects of middlebox actions: <ref type="figure" target="#fig_5">Figure 9b</ref> revisits the example in <ref type="figure">Figure 4</ref>, where we want to apply an ACL only on host H 2 's web requests. For correct policy enforcement, the ACL must be applied to both cached and uncached responses. Thus, both "H 2 , Hit" and "H 2 , Miss" need to be on the Proxy-to-ACL edge. (For ease of visualization, we do not show the policies applied to the responses coming from the Internet.) We currently assume that the administrator creates the DPG based on domain knowledge. We discuss a mechanism to help administrators to generate DPGs in §10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">From DPG to Tag Semantics</head><p>The DPG representation helps us reason about the semantics we need to capture via tags to ensure ORIGIN-BINDING and PATHSFOLLOWPOLICY.</p><p>Restoring ORIGINBINDING: We can ensure ORIGIN-BINDING if we are always able to map a packet to its original IP 5-tuple OrigHdr as it traverses a DPG. Note that having OrigHdr is a sufficient condition for ORIG-INBINDING: given the OrigHdr, any downstream middlebox or switch can conceptually implement the action intended by a DPG. In some cases, such as per-flow diagnosis <ref type="figure" target="#fig_1">(Figure 2</ref>), mapping a packet to the OrigHdr might be necessary. In other examples, a coarser identifier may be enough; e.g., just srcIP in <ref type="figure" target="#fig_0">Figure 1</ref>.</p><formula xml:id="formula_0">Restoring PATHSFOLLOWPOLICY:</formula><p>To ensure PATHSFOLLOWPOLICY, we essentially need to capture the edge condition m → m � . Recall that this condition depends on (1) the traffic class and (2) the middlebox context, denoted by C, from logical middlebox m (and possibly previous logical middleboxes). Given that the OrigHdr for ORIGINBINDING provides the necessary context to determine the traffic class, the only additional required information on m → m � is the context C.</p><p>If we assume (until §5.3) no constraints on the tag identifier space, we can think of the controller as assigning a globally unique tag T to each "located packet"; i.e., a packet along with the edge on the DPG <ref type="bibr" target="#b40">[51]</ref>. The controller maps the tag of each located packet to the information necessary for ORIGINBINDING and PATHSFOL-LOWPOLICY: T → �OrigHdr, C�. Here, the OrigHdr represents the original IP 5-tuple of this located packet when it first enters the network (i.e., before any middlebox modifications) and C captures the processing context of this located packet.</p><p>In the context of tag consumption from §4, FT CONSUME QRY and FT CONSUME RSP essentially "dereference" tag T to obtain the OrigHdr. The middlebox can apply its processing logic based on the OrigHdr; i.e., satisfying ORIGINBINDING.</p><p>For tag generation at logical middlebox m, FT GENERATE QRY provides as input to the controller: (1) the necessary middlebox context to determine which C will apply, and (2) the tag T of the incoming packet that triggered this new packet to be generated. The controller creates a new tag T � entry for this new located packet and populates the entry T � → �OrigHdr � , C� for this new tag as follows. First, it uses OrigHdr (for the input tag T ) to determine the value OrigHdr � for T � . In many cases (e.g., NAT), this is a simple copy. In some cases (e.g., proxy response), the association has to reverse the src/dst mappings in OrigHdr. Second, it associates the new tag T � with context C. The controller instructs the middlebox, via FT GENERATE RSP, to add T � to the packet header. Because T � is mapped to C, it supports enforcement of PATHSFOLLOWPOLICY.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Encoding Tags in Headers</head><p>In practice, we need to embed the tag value in a finite number of packet-header bits. IPv6 has a 20-bit Flow Label field, which seems ideal for this use (thus answering the question "how should we use the flowlabel field?" <ref type="bibr" target="#b8">[19]</ref>). For our current IPv4 prototype and testbed, we used the 6-bit DS field (part of the 8-bit ToS), which sufficed for our scenarios. To deploy FlowTags on large-scale IPv4 networks, we would need to borrow bits from fields that are not otherwise used. For example, if VLANs are not used, we can use the 12-bit VLAN Identifier field. Or, if all traffic sets the DF (Don't Fragment) IP Flag, which is typical because of Path MTU Discovery, the 16-bit IP ID field is available. <ref type="bibr">5</ref> Next, we discuss how to use these bits as efficiently as possible; §8 reports on some analysis of how many bits might be needed in practice.</p><p>As discussed earlier, tags restore ORIGINBINDING and PATHSFOLLOWPOLICY. Conceptually, we need to be able to distinguish every located packet-i.e., the combination of all flows and all possible paths in the DPG. Thus, a simple upper bound on the number of bits in each packet to distinguish between |Flows| flows on |DPGPaths| processing paths is: log 2 |Flows| + log 2 |DPGPaths|, where Flows is the set of IP flows (for ORIGINBINDING), and DPGPaths is the set of possible paths a packet could traverse in DPG (for PATHS-FOLLOWPOLICY). However, this grows log-linearly in the number of flows over time and the number of paths (which could be exponential w.r.t. the graph size).</p><p>This motivates optimizations to reduce the number of header bits necessary, which could include:</p><p>• Coarser tags: For many middlebox management tasks, it may suffice to use a tag to identify the logical traffic class (e.g., "CS Dept User") and the local middlebox context (e.g., 1 bit for cache hit or miss or 1 bit for "suspicious"), rather than individual IP flows.</p><p>• Temporal reuse: We can reuse the tag assigned to a flow after the flow expires; we can detect expiration via explicit flow termination, or via timeouts <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b34">45]</ref>. The controller tracks active tags and finds an unused value for each new tag.</p><p>• Spatial reuse: To address ORIGINBINDING, we only need to ensure that the new tag does not conflict with tags already assigned to currently active flows at the middlebox to which this packet is destined. For PATHSFOLLOWPOLICY, we need to: (1) capture the most recent edge on the DPG rather than the entire path (i.e., reducing from |DPGPaths| to the node degree); and (2) ensure that the switches on the path have no ambiguity in the forwarding decision w.r.t. other active flows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Putting it Together</head><p>Our current design is a reactive controller that responds to OFPT PACKET IN, FT CONSUME QRY, and FT GENERATE QRY events from the switches and the middleboxes.</p><p>Initialization: Given an input DPG, we generate a data plane realization DPGImpl; i.e., for each logical middlebox m, we need to identify candidate physical middlebox instances, and for each edge in DPG, we find a switchlevel path between corresponding physical middleboxes. This translation should also take into account considerations such as load balancing across middleboxes and resource constraints (e.g., switch TCAM and link capacity Switch and flow expiry handlers: The handlers for OFPT PACKET IN are similar to traditional OpenFlow handlers; the only exception is that we use the incoming tag to determine the forwarding entry. When a flow expires, we trace the path this flow took and, for each PM i , delete the entries in CtrlInTagsTable i and CtrlOutTagsTable i , so that these tags can be repurposed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Implementation</head><p>We implement the FlowTags controller as a POX module <ref type="bibr" target="#b4">[10]</ref>. The CtrlInTagsTable i and CtrlOutTagsTable i are implemented as hash-maps. For memory efficiency and fast look up of available tags, we maintain an auxiliary bitvector of the active tags for each middlebox and switch interface; e.g., if we have 16-bit tags, we maintain a 2 16 bit vector and choose the first available bit, using a log-time algorithm <ref type="bibr" target="#b11">[22]</ref>. We also implement simple optimizations to precompute shortest paths for every pair of physical middleboxes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">FlowTags-enhanced Middleboxes</head><p>As discussed in the previous sections, FlowTags requires middlebox support. We begin by discussing two candidate design choices for extending a middlebox to support FlowTags. Then, we describe the conceptual operation of a FlowTags-enhanced middlebox. We conclude this section by summarizing our experiences in extending five software middleboxes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Extending Middleboxes</head><p>We consider two possible ways to extend middlebox software to support FlowTags:</p><p>• Module modification: The first option is to modify specific internal functions of the middlebox to consume and generate the tags. For instance, consider an IDS with the scan detection module. Module modification entails patching this scan detection logic with hooks to translate the incoming packet headers+tag to the OrigHdr and to rewrite the scan detection logic to use OrigHdr. Similarly, for generation, we modify the output modules to provide the relevant context as part of the FT GENERATE QRY.</p><p>• Packet rewriting: A second option is to add a lightweight shim module that interposes on the incoming and outgoing packets to rewrite the packet headers. For consumption, this means we modify the packet headers so that the middlebox only sees a packet with the true OrigHdr. For generation, this means that the middlebox proceeds as-is and then the shim adds the tag before the packet is sent out. In both cases, the administrator sets up the middlebox configuration (e.g., IDS rules) as if there were no packet modifications induced by the upstream middleboxes because FlowTags preserves the binding between the packet's modified header and the OrigHdr.</p><p>For consumption, we prefer packet rewriting because it generalizes to the case where each middlebox has multiple "consumer" modules; e.g., an IDS may apply scan detection and signature-based rules. For generation, however, packet rewriting may not be sufficient, as the shim may not have the necessary visibility into the middlebox context; e.g., in the proxy cache hit/miss case. Thus, we use module modification in this case.</p><p>End-to-end view: <ref type="figure" target="#fig_0">Figure 10</ref> shows a simplified view of a FlowTags-enhanced middlebox. In general, consumption precedes generation. The reason is that the packet's current tag can affect the specific middlebox code paths, and thus impacts the eventual outgoing tags. Mirroring the controller's CtrlInTagsTable i and CtrlOutTagsTable i , each physical middlebox i maintains the tag rules in the MBInTagsTable i and MBOutTagsTable i . When a packet arrives, it first checks if the tag value in the packet already matches an existing tag-mapping rule in MBInTagsTable i . If there is a match, we rewrite packet headers (see above) so that the processing modules act as if they were operating on OrigHdr. If there is a MBInTagsTable i miss, the middlebox sends a FT CONSUME QRY, buffers the packet locally, and waits for the controller's response.</p><p>Note that the tags are logically propagated through the processing contexts (not shown for clarity). For example, most middleboxes follow a connection-oriented model with a data structure maintaining per-flow or perconnection state; we augment this structure to propagate the tag value. Thus, we can causally relate an outgoing packet (e.g., a NAT-ed packet or a proxy cached response) to an incoming packet.</p><p>When a specific middlebox function or module is about to send a packet forward, it checks the MBOutTagsTable i to add the outgoing tag value. If there is a miss, it sends the FT GENERATE QRY, providing the necessary module-specific context and the tag (from the connection data structure) for the incoming packet that caused this outgoing packet to be generated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Experiences in Extending Middleboxes</head><p>Given this high-level view, next we describe our experiences in modifying five software middleboxes that span a broad spectrum of management functions. (Our choice was admittedly constrained by the availability of the mid-   <ref type="table" target="#tab_9">Table 2</ref> summarizes these middleboxes and the modifications necessary.</p><p>Our current approach to extend middleboxes is semimanual and involved a combination of call graph analysis <ref type="bibr" target="#b3">[7,</ref><ref type="bibr" target="#b7">17]</ref> and traffic injection and logging techniques <ref type="bibr" target="#b1">[2,</ref><ref type="bibr">4,</ref><ref type="bibr">5,</ref><ref type="bibr">15]</ref>. Based on these heuristics, we identify the suitable "chokepoints" to add the FlowTags logic. Developing techniques to automatically extend middleboxes is an interesting direction for future work.</p><p>• Squid: Squid <ref type="bibr">[14]</ref> is a popular proxy/cache. We modified the functions in charge of communicating with the client, remote server, and those handling cache lookup. We used the packet modification shim for incoming packets, and applied module modification to handle the possible packet output cases, based on cache hit and miss events.</p><p>• Snort: Snort <ref type="bibr">[13]</ref> is an IDS/IPS that provides many functions-logging, packet inspection, packet filtering, and scan detection. Similar to Squid, we applied the packet rewriting step for tag consumption and module modification for tag generation as follows. When a packet is processed and a "verdict" (e.g., OK vs. alarm) is issued, the tag value is generated based on the type of the event (e.g., outcome of a matched alert rule).</p><p>• Balance: Balance [1] is a TCP-level load balancer that distributes incoming TCP connections over a given a set of destinations (i.e., servers). In this case, we simply read/write the tag bits in the header fields.</p><p>• PRADS: PRADS <ref type="bibr">[11]</ref> is passive monitor that gathers traffic information and infers what hosts and services exist in the network. Since this is a passive device, we only need the packet rewriting step to restore the (modified) packet's OrigHdr.</p><p>• NAT via iptables: We have registered appropriate tagging functions with iptables <ref type="bibr">[6]</ref> hook points, while Src / Time(s) DPG path Notes <ref type="figure">Figure 3</ref>, we configure Snort as the light IPS (L-IPS) to flag hosts sending more than 3 packets/sec and send them to the heavy IPS (H-IPS   it is configured as a source NAT. The goal is to maintain 5-tuple visibility via tagging. We added hooks for tag consumption and tag generation into the PRE-ROUTING and the POSTROUTING chains, which are the input and output checkpoints, respectively.</p><formula xml:id="formula_1">H 1 / 0 L-IPS→Internet - H 1 / 0.3 L-IPS→Internet - H 1 / 0.6 L-IPS→Internet L-IPS alarm H 1 / 0.8 L-IPS→H-IPS→Drop drop (a) In</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Validation and Use Cases</head><p>Next, we describe how we can validate uses of FlowTags. We also discuss how FlowTags can be an enabler for new diagnostic and verification capabilities.</p><p>Testing: Checking if a network configuration correctly implements the intended DPG is challenging-we need to capture stateful middlebox semantics, reason about timing implications (e.g., cache timeouts), and the impact of dynamic modifications. (Even advanced network testing tools do not capture these effects <ref type="bibr" target="#b28">[39,</ref><ref type="bibr" target="#b46">57]</ref>.) Automating this step is outside the scope of this paper, and we use a semi-manual approach for our examples. Given the DPG, we start from each ingress and enumerate all paths to all "egress" or "drop" nodes. For each path, we manually compose a request trace that traverses the required branch points; e.g., will we see a cache hit? Then, we emulate this request trace in our small testbed using Mininet <ref type="bibr" target="#b22">[33]</ref>. (See §8 for details.) Since there is no other traffic, we use per-interface logs to verify that packets follow the intended path. <ref type="figure" target="#fig_0">Figure 11</ref> shows an example with one set of request sequences for each scenario in <ref type="figure">Figures 3 and 4</ref>. To emulate <ref type="figure">Figure 3</ref>, we use Snort as the light IPS to flag any host sending more than 3 packets/second as suspicious, and direct such hosts' traffic to the heavy IPS for deep packet inspection (also Snort). <ref type="figure" target="#fig_0">Figure 11(a)</ref> shows the request trace and the corresponding transitions it triggers.</p><p>To emulate <ref type="figure">Figure 4</ref>, we use Squid as the proxy and Snort as the (web)ACL device. We want to route all H 2 's web requests through ACL and configure Snort to block We have validated the other possible paths in these examples, and in other scenarios from §2. We do not show these due to space constraints.</p><p>FlowTags-enabled diagnosis: We revisit the diagnosis example of <ref type="figure" target="#fig_1">Figure 2</ref>, with twenty user requests flowing through the NAT and LB. We simulated a simple "red team-blue team" test. One student ("red") synthetically introduced a 100ms delay inside the NAT or LB code for half the flows. The other student ("blue") was responsible for attributing the delays. Because of dynamic header rewriting, the "blue" team could not diagnose delays using packet logs. We repeated the experiment with FlowTags-enhanced middleboxes. In this case, the FlowTags controller assigns a globally unique tag to each request. Thus, the "blue" team could successfully track a flow through the network and identify the bottleneck middlebox using the packet logs at each hop.</p><p>Extending verification tools: Verification tools such as Header Space Analysis (HSA) <ref type="bibr" target="#b28">[39]</ref> check correctness (e.g., reachability) by modeling a network as the composition of header-processing functions. While this works for traditional switches/routers, it fails for middleboxes, as they operate at higher semantic layers. While a full discussion of such tools is outside the scope of this paper, we present an example illustrating how FlowTags addresses this issue. <ref type="figure" target="#fig_0">Figure 12</ref> extends the example in <ref type="figure">Figure 3</ref> to show both header-space annotations and DPG-based semantic annotations. Here, a header-space annotation (solid boxes) of �Src� describes a packet from Src, so � * � models a packet from any source. A DPG annotation (dashed boxes) of �Src, L, H� describes a packet from Src for which Light IPS returns L and Heavy IPS returns H, so � * , 0, * � indicates a packet from any source that is flagged by Light IPS as not OK; our policy wants such suspicious packets to go via Heavy IPS, while � * , 1, * � packets need no further checking.</p><p>Recall from §2 that we cannot implement this policy, in this topology, using existing mechanisms (i.e., without FlowTags). What if we rewired the toplogy by adding the (dashed) link Light IPS → Heavy IPS? Even with this hardwired topology, tools like HSA incorrectly conclude that "all" packets exit the network (the output edge is labeled � * �), because HSA models middleboxes as "wildcard"-producing blackboxes <ref type="bibr" target="#b28">[39]</ref>. FlowTags bridges the gap between "header space," in which verification tools operate, and "semantic space," in which the policy operates. Instead of modeling middleboxes as blackboxes, or reverse-engineering their functions, in FlowTags we treat them as functions operating on tag bits in an (extended) header space. Then, we apply HSA on this extended header space to reason if the network implements the reachability defined by the DPG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Performance Evaluation</head><p>We frame questions regarding the performance and scalability of FlowTags:  <ref type="bibr" target="#b22">[33]</ref> on the same server, configured to use 24 cores and 32 GB RAM to model the network switches and hosts. We augment Mininet with middleboxes running as external virtual appliances. Each middlebox runs as a VM configured with 2GB RAM on one core. (We can run at most 28 middlebox instances, due to the maximum number of PCI interfaces that can be plugged in using KVM <ref type="bibr">[8]</ref>). We emulate the example topologies from §2, and larger PoP-level ISP topologies from RocketFuel <ref type="bibr" target="#b44">[55]</ref>. Our default DPG has an average path length of 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Q1 Middlebox overhead:</head><p>We configure each middlebox to run with the default configuration. We vary the offered load (up to 100 Mbps) and measure the perpacket processing latency. Overall, the overhead was low (&lt;1%) and independent of the offered load (not shown). We also analyzed the additional memory and CPU usage using atop; it was &lt; 0.5% across all experiments (not shown).   bility information. This implies that a single-thread POX controller can handle 1 0.028ms ≈ 35K middlebox queries per second (more than three times larger than the peak number of flows per second reported in <ref type="bibr" target="#b13">[24]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Q2 Controller scalability:</head><p>We also varied the DPG complexity along three axes: number of nodes, node degrees, and distance between adjacent DPG nodes in terms of number of switches. With route pre-computation, the controller processing time is independent of the DPG complexity (not shown).</p><p>Q3 End-to-end overhead: <ref type="figure" target="#fig_0">Figure 13</ref> shows the breakdown of different components of the flow setup time in a FlowTags-enhanced network (i.e., mirroring the steps in <ref type="figure">Figure 7</ref>) for different Rocketfuel topologies. Since our goal is to compare the FlowTags vs. SDN operations, we do not show round-trip times to the controller here, as it is deployment-specific <ref type="bibr" target="#b24">[35]</ref>. <ref type="bibr">6</ref> Since all values are close to the average, we do not show error bars. We can see that the FlowTags operations add negligible overhead. In fact, the middlebox tag processing is so small that it might be hard to see in the figure.</p><p>We also measure the reduction in TCP throughput a flow experiences in a FlowTags-enhanced network, compared to a traditional SDN network with middleboxes (but without FlowTags). We vary two parameters: (1) controller RTT and (2) the number of packets per flow. As we can see in <ref type="table" target="#tab_15">Table 4</ref>, except for very small flows (2 packets), the throughput reduction is &lt;4%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Q4 Number of tag bits:</head><p>To analyze the benefits of spatial and temporal reuse, we consider the worst case, where we want to diagnose each IP flow. We use packet traces from CAIDA (Chicago and San Jose traces, 2013 <ref type="bibr" target="#b6">[16]</ref>) and a flow-level enterprise trace <ref type="bibr">[18]</ref>. We sim-   ulate the traces across the RocketFuel topologies, using a gravity model to map flows to ingress/egress nodes <ref type="bibr" target="#b44">[55]</ref>. <ref type="table" target="#tab_16">Table 5</ref> shows the number of bits necessary with different reuse strategies, on the AT&amp;T topology from RocketFuel. <ref type="bibr" target="#b3">7</ref> The results are similar across other topologies (not shown). We see that temporal reuse offers the most reduction. Spatial reuse helps only a little; this is because with a gravity-model workload, there is typically a "hotspot" with many concurrent flows. To put this in the context of §5.3, using the (Spatial, 1 sec) configuration, tags can fit in the IPv6 FlowLabel, and would fit in the IPv4 IP ID field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Related Work</head><p>We have already discussed several candidate solutions and tools for verification and diagnosis (e.g., <ref type="bibr" target="#b23">[34,</ref><ref type="bibr" target="#b28">39]</ref>). Here, we focus on other classes of related work.</p><p>Middlebox policy routing: Prior work has focused on orthogonal aspects of policy enforcement such as middlebox load balancing (e.g., <ref type="bibr" target="#b31">[42,</ref><ref type="bibr" target="#b38">49]</ref>) or compact data plane strategies (e.g,. <ref type="bibr" target="#b16">[27]</ref>). While these are candidates for translating the DPG to a DPGImpl ( §5), they do not provide reliable mechanisms to address dynamic middlebox actions.</p><p>Middlebox-SDN integration: OpenMB [31] focuses on exposing the internal state (e.g., cache contents and connection state) of middleboxes to enable (virtual) middlebox migration and recovery. This requires significantly more instrumentation and vendor support compared to FlowTags, which only requires externally relevant mappings. Stratos <ref type="bibr" target="#b19">[30]</ref> and Slick <ref type="bibr" target="#b10">[21]</ref> focus on using SDN to dynamically instantiate new middlebox modules in response to workload changes. The functionality these provide is orthogonal to FlowTags.</p><p>Tag-based solutions: Tagging is widely used to implement Layer2/3 functions, such as MPLS labels or virtual circuit identifiers (VCIs). In the SDN context, tags have been used to avoid loops <ref type="bibr" target="#b38">[49]</ref>, reduce FlowTable sizes <ref type="bibr" target="#b16">[27]</ref>, or provide virtualized network views <ref type="bibr" target="#b35">[46]</ref>. Tags in FlowTags capture higher-layer semantics to address ORIGINBINDING and PATHSFOL-LOWPOLICY. Unlike these Layer2/3 mechanisms where switches are generators and consumers of tags, FlowTags middleboxes generate and consume tags, and switches are consumers.</p><p>Tracing and provenance: The idea of flow tracking has parallels in the systems (e.g., tracing <ref type="bibr" target="#b18">[29]</ref>), databases (e.g., provenance <ref type="bibr" target="#b47">[58]</ref>), and security (e.g., taint tracking <ref type="bibr" target="#b36">[47,</ref><ref type="bibr" target="#b37">48]</ref>) literature. Our specific contribution is to use flow tracking for integrating middleboxes into SDNcapable networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Conclusions and Future Work</head><p>The dynamic, traffic-dependent, and hidden actions of middleboxes make it hard to systematically enforce and verify network-wide policies, and to do network diagnosis. We are not alone in recognizing the significance of this problem-others, including the recent IETF network service chaining working group, mirror several of our concerns <ref type="bibr" target="#b26">[37,</ref><ref type="bibr" target="#b32">43,</ref><ref type="bibr" target="#b39">50]</ref>.</p><p>The insight behind FlowTags is that the crux of these problems lies in violation of two key SDN tenets-ORIGINBINDING and PATHSFOLLOWPOLICY-caused by middlebox actions. We argue that middleboxes are in the best (and possibly the only) vantage point to restore these tenets, and make a case for minimally extending middleboxes to provide the necessary context, via tags embedded inside packet headers. We design new SDN APIs and controller modules to configure this tagrelated behavior. We showed a scalable proof-of-concept controller, and the viability of adding FlowTags support, with minimal changes, to five canonical middleboxes. We also demonstrated that the overhead of FlowTags is comparable to traditional SDN mechanisms.</p><p>We believe that there are three natural directions for future work: automating DPG generation via model refinement techniques (e.g., <ref type="bibr" target="#b14">[25]</ref>); automating middlebox extension using appropriate programming-languages techniques; and, performing holistic testing of the network while accounting for switches and middleboxes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">Acknowledgments</head><p>We would like to thank our shepherd Ben Zhao and the NSDI reviewers for their feedback. This work was supported in part by grant number N00014-13-1-0048 from the Office of Naval Research and by Intel Labs' University Research Office.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Applying the blocking policy is challenging, as the NAT hides the true packet sources.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Middlebox modifications make it difficult to consistently correlate network logs for diagnosis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Interfaces between different components in the FlowTags architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 ,</head><label>6</label><figDesc>FlowTags adds three extensions to today's SDN approach: 1. FlowTags APIs between the controller and FlowTags- enhanced middleboxes, to programmatically config- ure their tag generation and consumption logic ( §4). 2. FlowTags controller modules that configure the tagging-related generation/consumption behavior of the middleboxes, and the tag-related forwarding ac- tions of SDN switches ( §5). 3. FlowTags-enhanced middleboxes consume an in- coming packet's tags when processing the packet and generate new tags based on the context ( §6).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: The DPGs for the examples in Figures 3 and 4. Rectangles with solid lines denote "Ingress" nodes and with dotted lines denote "Egress" nodes. Circles denote logical middlebox functions. Each edge is annotated with a {Class}; Context denoting the traffic class and the processing context(s). All traffic is initialized as "{null};-".</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: We choose a hybrid design where the "consumption" side uses the packet rewriting and the "generation" uses the module modification approach.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>(</head><label></label><figDesc>b) In Figure 4, we use Squid as the proxy and Snort as the ACL and block H 2 's access to the Dept site.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Request trace snippets for validating the example scenarios in Figure 3 and Figure 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Disconnect between header-space analysis and the intended processing semantics in Figure 3. H 2 's access to the department website. Figure 11(b) shows the sequence of web requests to exercise different DPG paths. We have validated the other possible paths in these examples, and in other scenarios from §2. We do not show these due to space constraints.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Breakdown of flow processing time in different topologies (annotated with #nodes).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Analyzing strawman solutions vs. the moti-
vating examples in  §2.1. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>logical middlebox nodes. In and Out nodes represent network ingresses and egresses (including "drop" nodes). Each logical middlebox rep-</head><label></label><figDesc></figDesc><table>񮽙񮽙 
񮽙񮽙
񮽙 
񮽙
񮽙 
񮽙񮽙
񮽙 
񮽙 

! 񮽙񮽙񮽙񮽙񮽙 

񮽙񮽙 

! 񮽙񮽙
񮽙 

񮽙
񮽙 
񮽙 

񮽙 

! 񮽙񮽙񮽙񮽙񮽙 

! 񮽙񮽙񮽙 
! 񮽙񮽙
񮽙 

(a) Dynamic policy routing 

񮽙 
񮽙񮽙񮽙񮽙 

񮽙

񮽙 

񮽙 񮽙񮽙 񮽙 

񮽙 񮽙 

񮽙 񮽙 

񮽙񮽙 

񮽙 񮽙 

񮽙񮽙񮽙 
񮽙񮽙񮽙 
񮽙 񮽙 !񮽙 "񮽙 

񮽙񮽙񮽙 

񮽙!񮽙
"񮽙 
񮽙񮽙 


񮽙 
񮽙񮽙 
񮽙 
񮽙 

񮽙 񮽙 񮽙 ! 

񮽙 " "񮽙 

񮽙񮽙񮽙 

񮽙 񮽙 


!񮽙
"񮽙 

񮽙 

񮽙񮽙񮽙 

(b) Middlebox context 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>PM i , the controller maintains two FlowTags tables: CtrlInTagsTable i and the CtrlOutTagsTable i . The CtrlInTagsTable i maintains the tags corresponding to all incoming active flows into this middlebox using entries {T → OrigHdr}. The CtrlOutTagsTable i tracks the tags that need to be assigned to outgoing flows and maintains a table of entries {�T, C� → T � }, where T is the tag for the incoming packet, C captures the relevant middlebox context for this flow (e.g., cache hit/miss), and T � is the output tag to be added. At bootstrap time, these struc- tures are initialized to be empty. The HANDLE FT CONSUME QRY handler looks up the entry for tag T in the CtrlInTagsTable i and sends the mapping to PM i . As we will see in the next sec- tion, middleboxes keep these entries in a FlowTable-like structure, to avoid look ups for subsequent packets. The HANDLE FT GENERATE QRY handler is slightly more involved, as it needs the relevant middlebox context C. Given C, the DPG, and the DPGImpl, the controller identifies the next hop physical middlebox PM i � for this packet. It also determines a non-conflicting T � using the logic from §5.3.</head><label></label><figDesc>). While FlowTags is agnostic to the specific realiza- tion, we currently use SIMPLE [49], mostly because of our familiarity with the system. (This procedure only needs to run when the DPG itself changes or in case of a network topology change. It does not run for each flow arrival.) Middlebox event handlers: For each physical middle- box instance</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Summary of the middleboxes we have added 
FlowTags support to along with the number of lines 
of code and the main modules to be updated. We use 
a common library (≈ 250 lines) that implements rou-
tines for communicating to the controller. 

dlebox source code.) </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>) .</head><label>.</label><figDesc></figDesc><table>Host / URL DPG path 
Notes 
H 1 / Dept 
Proxy→Internet 
always allow 
H 2 / CNN 
Proxy→ACL→Internet miss, allow 
H 2 / Dept 
Proxy→ACL→Drop 
hit, drop 
H 1 / CNN 
Proxy 
hit, allow 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>• Q1: What overhead does support for FlowTags add to middlebox processing? • Q2: Is the FlowTags controller fast and scalable? • Q3:</head><label></label><figDesc></figDesc><table>What is the overhead of FlowTags over traditional 
SDN? 
• Q4: How many tag bits do we need in practice? 
Setup: For Q1 and Q2, we run each middlebox and 
POX controller in isolation on a single core in a 32-core 
2.6 Ghz Xeon server with 64 GB RAM. For Q3, we use 
Mininet </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12" validated="false"><head>Table 3 shows</head><label>3</label><figDesc>the running time for the HANDLE FT GENERATE QRY. (This is the most complex FlowTags processing step; other functions take negligible time.) The time is linear as a function of topology size with the baseline algorithms, but almost constant using the optimization to pre-compute reacha-</figDesc><table>Topology (#nodes) 
Baseline (ms) 
Optimized (ms) 
Abilene (11) 
0.037 
0.024 
Geant (22) 
0.066 
0.025 
Telstra (44) 
0.137 
0.026 
Sprint (52) 
0.161 
0.027 
Verizon (70) 
0.212 
0.028 
AT&amp;T (115) 
0.325 
0.028 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Time to run HANDLE FT GENERATE QRY. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15" validated="false"><head>Table 4 :</head><label>4</label><figDesc></figDesc><table>Reduction in TCP throughput with Flow-
Tags relative to a pure SDN network. 

Configuration 
Number of bits 
(spatial, temporal) 
CAIDA trace 
Enterprise trace 
(No spatial, 30 sec) 
22 
22 
(Spatial, 30 sec) 
20 
20 
(Spatial, 10 sec) 
18 
18 
(Spatial, 5 sec) 
17 
17 
(Spatial, 1 sec) 
14 
14 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16" validated="false"><head>Table 5 : Effect of spatial and temporal reuse of tags.</head><label>5</label><figDesc></figDesc><table></table></figure>

			<note place="foot" n="1"> A third SDN tenet, HIGHLEVELNAMES, states that network policies should be expressed in terms of high-level names. We do not address it in this work, mostly to retain backwards compatibility with current middlebox configuration APIs. We believe that HIGHLEVEL-NAMES can naturally follow once we restore the ORIGINBINDING property. 2 We use the term &quot;flow&quot; in a general sense, not necessarily to refer to an IP 5-tuple.</note>

			<note place="foot" n="3"> More generally, if we have a domain hierarchy (e.g., &quot;CS dept&quot; and &quot;Physics dept&quot; and &quot;Univ&quot; at a higher level), each sub-domain&apos;s egress switch can rewrite the tag to only capture higher-level semantics (e.g, &quot;CS&quot; rather than &quot;CS host A&quot;), without revealing internal details.</note>

			<note place="foot" n="4"> Going forward, we want to configure the middlebox rules to ensure the HIGHLEVELNAMES as well [24].</note>

			<note place="foot">Middlebox tag consumption, Figure 8: When a mid-</note>

			<note place="foot" n="5"> IP ID isn&apos;t part of the current OpenFlow spec; but it can be supported with support for flexible match options [9, 23].</note>

			<note place="foot" n="6"> FlowTags adds 1 more RTT per middlebox, but this can be avoided by pre-fetching rules for the switches and middleboxes.</note>

			<note place="foot" n="7"> Even though the number of flows varies across traces, they require the same number of bits, as the values of ceil(log 2 (# f lows)) are the same.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<ptr target="http://www.inlab.de/balance.html" />
	</analytic>
	<monogr>
		<title level="j">Balance</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bit-Twist</surname></persName>
		</author>
		<ptr target="http://bittwist.sourceforge.net/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Cisco systems netflow services export version 9</title>
		<imprint/>
	</monogr>
	<note>RFC 3954</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kcachegrind</surname></persName>
		</author>
		<ptr target="http://kcachegrind.sourceforge.net/html/Home.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pox</forename><surname>Controller</surname></persName>
		</author>
		<ptr target="http://www.noxrepo.org/pox/about-pox/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Prolexic</surname></persName>
		</author>
		<ptr target="www.prolexic.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">The Cooperative Association for Internet Data Analysis (caida)</title>
		<ptr target="http://www.caida.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Valgrind</surname></persName>
		</author>
		<ptr target="http://www.valgrind.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Ipv6 flow label update</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Amante</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rajahalme</surname></persName>
		</author>
		<ptr target="http://rmv6tf.org/wp-content/uploads/2012/11/rmv6tf-flow-label11.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">xOMB: extensible open middleboxes with commodity servers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Braud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kapoor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Vahdat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ANCS</title>
		<meeting>ANCS</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Slick Control Plane for Network Middleboxes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Anwer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ONS, research track</title>
		<meeting>ONS, research track</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Scalable kernel performance for Internet servers under realistic loads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Banga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mogul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX ATC</title>
		<meeting>USENIX ATC</meeting>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Forwarding Metamorphosis: Fast Programmable Match-Action Processing in Hardware for SDN</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bosshar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Izzard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Mujica</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Ethane: Taking control of the enterprise</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pettit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Counterexample-guided abstraction refinement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Veith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CAV</title>
		<meeting>CAV</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">ETTM: a scalable fault tolerant network manager</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dixon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Uppal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Brajkovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Brandon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">CellSDN: Software-defined cellular networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">Erran</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">M</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Techinical Report</title>
		<meeting><address><addrLine>Princeton University</addrLine></address></meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">FlowTags: Enforcing network-wide policies in the presence of dynamic middlebox actions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Fayazbakhsh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Mogul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotSDN</title>
		<meeting>HotSDN</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">X-Trace: a pervasive network tracing framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Stratos: A network-aware orchestration layer for middleboxes in the cloud</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gember</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Grandl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Anand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
		<idno>abs/1305.0209</idno>
		<imprint>
			<date type="published" when="2013" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Toward software-defined middlebox networking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gember</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Prabhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Ghadiyali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotNets-XI</title>
		<meeting>HotNets-XI</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">NOX: towards an operating system for networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Gude</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Koponen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pettit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCR</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Reproducible network experiments using container-based emulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Handigol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Heller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Jeyakumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lantz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CoNext</title>
		<meeting>CoNext</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Where is the debugger for my softwaredefined network?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Handigol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Heller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Jeyakumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Maziéres</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotSDN</title>
		<meeting>HotSDN</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The Controller Placement Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Heller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotSDN</title>
		<meeting>HotSDN</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Softcell: Scalable and flexible cellular core network architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">Erran</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Vanbever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CoNext</title>
		<meeting>CoNext</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Research directions in network service chaining</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Pentikousis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Agapiou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kind</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Manzalini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Risso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Staessens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Steinert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Meirosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE SDN4FNS</title>
		<meeting>IEEE SDN4FNS</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A policy-aware switching layer for data centers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Joseph</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tavakoli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Header space analysis: static checking for networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kazemian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Veriflow: verifying network-wide invariants in real time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Khurshid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Caesar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">B</forename><surname>Godfrey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">No More Middlebox: Integrate Processing into Network</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tourrilhes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Banerjee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM posters</title>
		<meeting>SIGCOMM posters</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">PACE: Policy-Aware Application Cloud Embedding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Liaghat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hajiaghay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wilfong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Service chaining and unintended consequences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Macvittie</surname></persName>
		</author>
		<ptr target="https://devcentral.f5.com/articles/service-chaining-and-unintended-consequences#.Uvbz0EJdVe9" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<title level="m">Mind the Gap: SIGCOMM&apos;12</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">OpenFlow: enabling innovation in campus networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Parulkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CCR</title>
		<imprint>
			<date type="published" when="2008-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Composing Software Defined Networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Monsanto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Reich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Practical Data-Leak Prevention for Legacy Applications in Enterprise Networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Mundada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ramachandran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Tariq</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<ptr target="http://hdl.handle.net/1853/36612" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Dynamic Taint Analysis for Automatic Detection, Analysis, and Signature Generation of Exploits on Commodity Software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">SIMPLE-fying Middlebox Policy Enforcement Using SDN</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Qazi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Miao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Network service chaining problem statement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Quinn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Guichard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Manur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chauhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Leyman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Boucadir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Jacquenet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Yadav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Nadeau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Mcconnell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Glavin</surname></persName>
		</author>
		<ptr target="http://tools.ietf.org/html/draft-quinn-nsc-problem-statement-03" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Abstractions for network update</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Reitblatt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Schlesinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Design and implementation of a consolidated middlebox architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Egi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">The middlebox manifesto: enabling innovation in middlebox deployment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Egi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotNets</title>
		<meeting>HotNets</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Making middleboxes someone else&apos;s problem: Network processing as a cloud service</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sherry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hasan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Measuring ISP Topologies with Rocketfuel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Spring</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACM SIG-COMM</title>
		<meeting>of ACM SIG-COMM</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Virtual network diagnosis as a service</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shaikh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SoCC</title>
		<meeting>SoCC</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Automatic test packet generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kazemian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CoNext</title>
		<meeting>CoNext</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Efficient querying and maintenance of network provenance at internet-scale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sherr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">T</forename><surname>Loo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Mao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
