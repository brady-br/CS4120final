<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:26+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Read It Twice! A mass-storage-based TOCTTOU attack</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Collin</forename><surname>Mulliner</surname></persName>
							<email>collin@sec.t-labs.tu-berlin.de</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Security in Telecommunications</orgName>
								<orgName type="department" key="dep2">Telekom Innovation Laboratories</orgName>
								<orgName type="institution">Technische Universität Berlin</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Michéle</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Security in Telecommunications</orgName>
								<orgName type="department" key="dep2">Telekom Innovation Laboratories</orgName>
								<orgName type="institution">Technische Universität Berlin</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Read It Twice! A mass-storage-based TOCTTOU attack</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>race condition</term>
					<term>USB</term>
					<term>mass-storage</term>
					<term>con- sumer electronics</term>
					<term>software attestation</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Consumer electronics and embedded devices often allow the installation of applications and firmware upgrades from user-provided mass-storage devices. To protect the integrity of these devices and the associated electronic markets, the software packages are protected by cryptographic signatures. The software installation code assumes that files on attached mass-storage devices cannot change while the storage device is connected. The software installation is therefore not bound to the file integrity check, thus laying the foundations for a time-of-check-to-time-of-use (TOCTTOU) attack. This work presents a TOCTTOU attack via externally attached mass-storage devices. The attack is based on emulating a mass-storage device to observe and alter file access from the consumer device. The TOCTTOU attack is executed by providing different file content to the check and installation code of the target device, respectively. The presented attack effectively bypasses the file content inspection, resulting in the execution of rogue code on the device .</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Consumer electronics today are heavily targeted by the hacking and modding community with the primary goal to modify or replace the software running the devices. To fulfill this goal the attacker (the modder) has to execute his own code on the target device. In most cases the attack further needs to gain system or root privileges on the target device.</p><p>There are many ways to achieve code execution and firmware replacement mostly depending on the type of device and software running on it. Low cost devices are mostly not hardened against hacking and modding. Here the effort mostly comes down to figuring out file and firmware formats or finding the serial console on the hardware. More costly devices contain more sophisticated security measures. Here firmware upgrades are protected by cryptographic signatures. Attacking the more costly and thus protected devices comes down to finding and exploiting software bugs to achieve code execution often requiring a lot of effort.</p><p>Many embedded systems and especially consumer electronics (CE) support the installation of software and firmware upgrades through attached mass-storage devices. Most commonly, USB mass-storage devices are used for this, such as flash drives and hard disks. Depending on the type of embedded system, Secure Digital (SD) and Compact Flash (CF) cards are also popular.</p><p>In this paper we present a novel time-of-check-totime-of-use (TOCTTOU) attack that targets file content. We attack software installation and firmware upgrade code that reads files from an external massstorage volume. Our attack is based on an emulated mass-storage device that allows to change the content of files while the mass-storage volume is connected to the attacked target.</p><p>Our attack method is based on a number of observations that are present on many different consumer electronics devices today. The main observation is that code for software installation and firmware upgrade is separated into two parts: check and install. If each part implements its own file access it is potentially prone to a TOCTTOU attack.</p><p>This work demonstrates a practical implementation of such an attack against a Linux-based TV-set. We show that we are able to install a shared library on the system, which is then loaded by the main application running on the TV-set. Our code runs with root privileges. Our attack currently is the only method to root a specific series of Samsung TV-sets. We further present a tool to analyze the behavior of CE devices to determine if a device might be susceptible to mass-storagebased TOCTTOU attacks.</p><p>Similar issues exist in the areas of trusted computing and software attestation. One party tries to verify or measure the integrity of another party (the other partie's code) before accessing or using it. If a time window between measurement and access exists, the software attestation might be vulnerable to a TOCTTOU attack.</p><p>The contributions of this paper are the following:</p><p>• Read It Twice (RIT) Attack which is a massstorage-based TOCTTOU attack based on the condition that software installation and firmware upgrade code are separated into two parts: check and install. If each code part individually reads file(s) from an external mass-storage device an exploitable TOCTTOU condition might exist. Our attack also specifically accounts for a possible existing block and file system cache on the target device. Our approach is different from traditional TOCTTOU attacks as we target the content of files and not their permissions.</p><p>• USB-Mass-Storage RIT Attack Implementation and Evaluation against a Samsung TVset. Using this attack we were able to gain code execution and root privileges on our target device.</p><p>• Mass-Storage File Access Analysis Method and tool for black box investigation of file access to external mass-storage devices. This analysis method allows to detect possible TOCTTOU conditions in firmware upgrade and software installation code of embedded systems that read files from external mass-storage devices.</p><p>The rest of this paper is organized as follows. In Section 2 we introduce our novel Read It Twice attack. In Section 3 we provide a brief overview of our target, a TV-set. Section 4 presents our Mass-Storage File Access Analysis method and tool. Our method is general and can be used for black box analysis of arbitrary devices that read files from a USB mass-storage device. In Section 5 we present a practical implementation of our RIT attack against the software installation subsystem of our TV-set. In Section 6 we discuss related work and in Section 7 we briefly conclude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The Read It Twice Attack</head><p>Our Read It Twice (RIT) attack is based on the observation that software installation and firmware upgrade code on embedded devices assumes that files on an attached mass-storage device will not change during the installation. In general, an installation consists of the following steps:</p><p>Check the software package or firmware upgrade.</p><p>This step verifies version numbers and cryptographic signatures of the packages that are going to be installed.</p><p>Install the actual software or firmware upgrade. This step copies the files from the external storage device to the internal storage or flashes the firmware.</p><p>The check and installation phases are not combined in an atomic operation as file contents are assumed to be immutable while the mass-storage device is plugged-in.</p><p>Our RIT attack works as follows:</p><p>Given the file-X that is expected by the check-install code. We have the benign file-B and the modified version file-M. We construct a mass-storage device that can observe the read requests to fileX. For the first access to fileX our mass-storage device serves the benign file-B. This is likely the check code that calculates and compares the cryptographic hashes or verifies other parameters contained in fileX. For the second read access to fileX our mass-storage device serves our modified file-M. This is likely the installation phase of software install code.</p><p>The attack succeeds if the check code verifies the signature of the benign file file-B and then the install code uses the modified file file-M. Effectively our attack circumvents the signature check and/or file content inspection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Boundary Conditions</head><p>There are two boundary conditions for our RIT attack that have to be resolved in real world implementations. These are:</p><p>File size of the benign file and the modified file likely need to be equal. Further the filesystem usage must be exactly the same to guarantee that both files are located within the same blocks in each filesystem image.</p><p>Block cache. Embedded devices running sophisticated operating systems such as Linux, BSD, and Windows implement a block cache. If the target file fits in the block or filesystem cache the attack has to be adjusted so that the install code will read the file from the attached device rather than from the block cache.</p><p>Another boundary condition is that the target device does not copy the software package or firmware upgrade file to internal memory before checking it. This is an obvious countermeasure for our attack that we briefly discuss in Section 5.3. In the remainder of this paper we will discuss these boundary conditions and how we dealt with them to successfully launch our attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The Samsung TV-set</head><p>Our target TV-set is the Samsung LE32B650T2-PXZG <ref type="bibr" target="#b11">[13]</ref>, a 32 inch version of the Samsung B series LCD-based television set. We chose this TV-set because this series has a very active modding community called SamyGO <ref type="bibr" target="#b13">[15]</ref>. Through this community many technical details of this line of Samsung TVs are available to the general public. Our TV model has a Common Interface Plus (CI+) <ref type="bibr" target="#b0">[1]</ref> slot for Conditional Access Modules (CAM). CI+ was developed to protect digital video broadcasts and offers a protected data path between the CAM and the TV set. Vendors put a lot effort in securing these TV sets as a compromise is likely to give access to decrypted video broadcasts.</p><p>The TV-set consists of a display and a computing unit. The computing part is an ARM-based Linux system. Besides the audio and video interfaces such as HDMI, SCART, and an antenna plug the TV-set features an Ethernet interface and multiple USB interfaces. The USB interface can be used to plug in a USB WiFi adapter (to replace the Ethernet connection) or for connecting USB storage devices such as USB flash disks or hard disks. The TV-set is able to play back audio and video files from the USB storage devices.</p><p>This TV is equipped with 290MB of RAM and a total of approximately 650MB of flash memory for permanent storage.</p><p>This line of Samsung TV-sets is one of the first that offers installation of widgets and games. On the TV-set these features are accessible through the Content menu. The content subsystem can launch two kinds of executables: Adobe Flash files and native code loaded as a shared object (a simple .so file). Content packages can be executed and installed from a USB drive.</p><p>The busybox-based Linux system executes a large binary called exeDSP. This binary controls the entire TV-set. It is responsible for showing the On Screen Display (OSD) to navigate through the TV chan-1 &lt;?xml version="1.0" encoding="utf-8"?&gt; 2 &lt;contentlibrary&gt; 3 &lt;contentpack id="tocttou"&gt; 4 &lt;category&gt;Wellness&lt;/category&gt; 5 &lt;title language_id="English"&gt;tocttou&lt;/title&gt; 6 &lt;startpoint language_id="English"&gt; 7</p><p>tocttou.so&lt;/startpoint&gt; 8 &lt;thumbnailpath&gt;tocttou.bmp&lt;/thumbnailpath&gt; 9 &lt;totalsize&gt;1&lt;/totalsize&gt; 10 &lt;/contentpack&gt; 11 &lt;/contentlibrary&gt; <ref type="figure">Figure 1</ref>. Example clmeta.dat file that we used for testing and the RIT attack. nels, changing the TV settings, interacting with UPnP servers, and for accessing the content applications. The exeDSP application runs as user root, i.e., with full privileges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Samsung TV Software Packages</head><p>Software packages with content for the Samsung TV consist of a minimum of three files <ref type="bibr" target="#b12">[14]</ref>: The executable code (Adobe Flash or a shared object), a bitmap (the application icon), and the package description in the clmeta.dat file. <ref type="figure">Figure 1</ref> shows an example of such a package description. The important values in the clmeta.dat file are the startpoint and the category. The startpoint specifies which file contains the executable code; in this example it is the shared object tocttou.so. The category specifies the kind of application. The TV-set recognizes categories such as Game, Children, and Wellness among others.</p><p>Interestingly, the category implies the kind of executable code expected to be contained in the package. Games come in the form of shared objects while packages belonging to the other categories are Adobe Flash-based.</p><p>Every game's shared object has to provide a single function called Game Main <ref type="bibr" target="#b12">[14]</ref> that is called once the shared object is loaded by the exeDSP process. Applications can be developed in pure C and by using the Simple DirectMedia Layer (SDL) <ref type="bibr" target="#b1">[2]</ref> library that is pre-installed on the Samsung TV-sets. <ref type="figure">Figure 2</ref> shows the code for a very simple exemplary plugin.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">The SamyGO Jailbreak</head><p>Previously, before the introduction of CI+ <ref type="bibr" target="#b0">[1]</ref> devices, Samsung TV-sets allowed to execute and install int Game_Main(char *path, char *udn) { system("telnetd &amp;"); return 0; } <ref type="figure">Figure 2</ref>. Simple Samsung content library application that executes system(3).</p><p>applications based on shared objects from USB massstorage devices. Execution of an application is straightforward: The application was selected and run from the content menu. The only requirement for installing an application on the TV-set was to enable write access to the TV-set's internal memory via the WiseLink Write option in the TV configuration <ref type="bibr" target="#b14">[16]</ref>. Once the application was installed, the shared object could be loaded by the exeDSP process. As exeDSP is run with root privileges, code from the user-supplied shared object is executed with root privileges, too, hence taking over control of the TV system. This enabled the installation of custom applications like a telnetd server or flashing of customized firmware versions to the TV set.</p><p>Flashing a customized firmware involves additional steps, which are not important in the scope of this work. They can be found on the SamyGO Wiki <ref type="bibr" target="#b13">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Mass-Storage File Access Analysis</head><p>To determine if a specific device is susceptible to our RIT attack the behavior of its check and install code has to be analyzed. We developed a Mass-Storage File Access Analysis tool that allows black box analysis of the access behavior to USB mass-storage devices.</p><p>Our analysis tool is implemented using a gumstix <ref type="bibr" target="#b8">[10]</ref> board running Linux. The gumstix board is equipped with a USB OTG <ref type="bibr">[4]</ref> port and thus can emulate a USB client device. The Linux USB stack already has support for USB mass-storage emulation through the gadget API <ref type="bibr" target="#b2">[3]</ref>. The driver source is in file storage.c (in linux/drivers/usb/gadget/), which compiles as the kernel module g file storage.ko.</p><p>The g file storage module works in a simple way. At module load time, the filename of a filesystem image or block device is passed to the module as a parameter. The module exports the given file or block device as a USB mass-storage volume. Each block requested by the host is read from the file by the module and sent back to the host via USB.</p><p>Our tool works as follows:</p><p>g file storage.ko operates as designed. The given file is exported as an emulated mass-storage volume. Blocks requested by the host are read from the file and sent back to the host.</p><p>Block and file system access tracking. We track every block read access and match the file and directory associated to that block. This allows us to monitor which files are accessed by the host and how often a given file is actually read from our emulated block device. We implemented this for FAT16 and FAT32 <ref type="bibr" target="#b10">[12]</ref> as these are the common filesystems for our target devices. Other filesystem types can easily be added if required.</p><p>Our tool enables us to conduct black box analysis of USB mass-storage-based firmware upgrade and software installation code running on embedded systems such as CE devices. We were able to gather the following information about our Samsung TV-set by using this tool.</p><p>File and directory access during the check and install phase of the target device. This allows us to identify the files actually being accessed by the check and install code during a firmware update or software package installation.</p><p>Files read by the check and install code. This discloses if files are read completely or only partially.</p><p>Timing of file access. The time of each block access is logged accurately, thus allowing the observation of delays between accesses to consecutively read files. This can provide hints about processes such as signature checks after having read one file and before reading the next one.</p><p>The output of our analysis tool provides a great starting point for designing our attack. <ref type="figure">Figure 3</ref> shows an example output for the installation of a content library application on our Samsung TV set.</p><p>This output allows to deduce some of the TV set's internal functioning by matching user interface interactions to file access patterns. After invoking the USB inspection menu of the content library (11:18:56), the TV set scans each directory for a clmeta.dat file. Each of these files is read to populate entries in each of the content categories, being Wellness in our example software package.</p><p>As the user opens the Wellness category (11:19:10), the TV set reads the corresponding bitmap file of each package as indicated in the clmeta.dat file. These  <ref type="figure">Figure 3</ref>. The output shows files and directories being access. In addition it shows that files are being read completely and the time at which the files have been accessed. bitmaps are then displayed to the user as the package's icon.</p><p>Finally, the user selects an application to be installed (11:19:56), which in our example is the TOCTTOU package. The package content, i.e., the entire directory, is then copied from the mass-storage device to the internal flash memory. This includes the executable files telnetd and tocttou.so.</p><p>After installation, the user can launch the freshly installed application from internal memory by selecting it in the content menu. Each time the application is launched, the TV set will analyze the clmeta.dat to choose how to launch the application, i.e., as Adobe Flash or as a shared object.</p><p>Note that the clmeta.dat and the bitmap file is not read again as it is copied to the internal memory. This indicates that these files are copied directly from the internal block cache and that no second access to the block device occurred (cf. Section 2.1).</p><p>Based on the results of our analysis we design and implement our RIT attack and corresponding tool, which we present in the following Sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">The RIT Attack</head><p>Our Samsung LE32B650 TV, like all current Samsung CI+ TV-sets, does not allow to execute or copy applications based on shared objects from a USB drive. Only Adobe Flash-based applications may be executed and copied from USB drives. But pre-installed games such as WiseStar are based on the shared object interface, therefore, shared object-based applications still seem to be supported.</p><p>Our RIT attack is based on the observation that shared object applications are supported while only Flash applications can be copied to the device. The goal of our attack is to trick the TV-set into copying an application that is based on a shared object to the TV-set's internal memory from which it can be executed.</p><p>The software check-install code determines the kind of application by inspecting the clmeta.dat file, as shown in <ref type="figure">Figure 1</ref> and described in Section 3.1. The categories Wellness and Children denote Adobe Flashbased applications that may be installed, i.e., copied to internal flash memory. The Game type application is based on a shared object and thus may not be installed. We call this first part the check code as described in Section 2.</p><p>The install code that actually copies the application files to the TV-set's internal memory is not checking the clmeta.dat file and just copies the whole subdirectory. If we can change the clmeta.dat file from category Wellness to category Game our tocttou application will change to a shared object-based application. As a result we will have our code running inside the exeDSP process which runs with root privileges.</p><p>Note that the execution of code from shared object files is prohibited only for files from external storage. Once this code is executed from internal storage, no restrictions apply. Therefore, an attacker has to persuade the check-install code to copy the shared object file and a corresponding clmeta.dat to internal memory.</p><p>The remainder of this section describes our attack tool and how it is leveraged to perform our RIT attack against the Samsung TV set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">The Attack Tool</head><p>Our attack tool is an extension of our analysis tool, basically two features were added. These are:</p><p>Trigger file monitoring. Our version of g file storage takes an additional filename as the trigger file. Every time the trigger file is read from the block device the trigger counter is incremented. The match of block access to filename is done via our block and filesystem access tracking code that we added for our analysis tool (cf. Section 4).</p><p>Filesystem switch. When the trigger counter reaches the trigger value, which is passed as a parameter to our version of g file storage, all block requests are redirected to the modified filesystem image. Effectively, the volume is switched to the modified filesystem image.</p><p>Hence, our version of the g file storage module requires three additional parameters: the path to our modified filesystem image, a filename as the trigger file, and the trigger value to switch between the original and the modified filesystem image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Executing the Attack</head><p>To execute the attack we require two FAT filesystem images. The first image contains the benign filesystem (compare file-B in Section 2). The second image contains the modified filesystem (file-M). Both filesystems contain exactly the same files with the exception of the clmeta.dat file. In the modified filesystem the clmeta.dat file of our tocttou application specifies the category Game whereas it is Wellness in the benign image.</p><p>Note that the two filesystem images are required to be completely identical as the host will use the FAT of the benign image to request blocks of the modified image. This can be achieved by first creating the benign image and modifying a copy thereof to create the modified image. Alternatively, copying the files in exactly the same order to both images will yield suitable images.</p><p>To execute the attack we have to further ensure that the clmeta.dat file is actually read multiple times. The problem is, as described in Section 2.1, that the TV runs Linux and thus has a block cache. Therefore, the TV will read each block from the external storage device only once and then store it in the block cache. To resolve this issue and to force the TV to re-read the clmeta.dat file from our tocttou application, we added a second application named cache. The second application is basically a copy of our tocttou application with a different name. To circumvent the block cache, we padded the clmeta.dat file from the cache application with spaces until it hit 260 Megabytes. When the TV-set reads this large file all previously cached blocks are discarded. The file size of 260MB was determined by experimenting with various reasonable values, i.e., common RAM sizes. Using our block access tracking code we can easily observe if the blocks of the clmeta.dat from our tocttou application are requested again by the host. If this happens, the blocks are not in the block cache anymore and our attack succeeds. <ref type="figure" target="#fig_0">Figure 4</ref> shows the basic concept of our attack. The tool's output for a successful RIT attack is shown in <ref type="figure">Figure 5</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Countermeasures</head><p>There are many possibilities for countermeasures against our RIT attack; here we only discuss one simple solution that is straightforward.</p><p>The most obvious and easiest to implement is to first copy the software or firmware files to internal storage and then execute the checks on the copy. After all checks have passed, the installation process is executed using the internal copy of the files. This countermeasure is only possible if the target device has enough unused storage space. Alternatively, the copy could also be held in free memory (RAM), if available.</p><p>This simple copy-based countermeasure will only work for devices that contain excess storage or system memory. Consumer electronics devices are mostly built to be cheap and use as few resources as possible, often having just enough storage to support the operational functionalities of the device. More sophisticated countermeasures have to be developed to protect devices that do not contain enough memory to implement a simple copy-based check-install procedure. Figure 5. Output of our attack tool for the RIT attack. In line 6 the device is switched to the modified filesystem image after the access to the clmeta.dat file in the cache directory. The clmeta.dat in the cache directory is 260MB in size to flush tocttou/clmeta.dat from the block cache of the TV-set. The attack is finalized in line 16 where the TV-set reads clmeta.dat again but this time the block are read from the modified filesystem image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>Related work falls into four different areas. First, general race conditions and file-based TOCTTOU attacks, second USB mass-storage-based attacks, third USB-based attacks, and fourth trusted computing and software attestation.</p><p>Bishop et al. <ref type="bibr" target="#b5">[7]</ref> characterized and analyzed a similar class of TOCTTOU attacks that targets file access on UNIX systems. Their work mainly targeted file permission checks versus file open operations. In this paper we present a novel TOCTTOU attack against the content of files.</p><p>The PSjailbreak and the open source version PSGroove <ref type="bibr" target="#b4">[6]</ref> attack to jailbreak Sony's PlayStation 3 is based on a rogue USB device. The exploit leverages a memory corruption bug in the PlayStation USB driver code that parses USB device descriptors. The attack works by emulating multiple USB devices with malicious content in the device descriptors. The attack allowed arbitrary code execution on the PlayStation 3.</p><p>In <ref type="bibr" target="#b15">[17]</ref> the authors added malicious functionality to the USB drivers of an Android-based smartphone to attack the attached computer while the phone was connected for charging its battery. The malicious functionality emulated a keyboard and mouse to interact with the computer.</p><p>There are various attacks based on USB massstorage devices <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b9">11]</ref> that contain autorun files for either Windows or Linux.</p><p>The GTV Hacking scene <ref type="bibr" target="#b3">[5]</ref> found that the Sony Google TV could be rooted and downgraded by a simpler version of our RIT attack. Their attack is based on three USB flash drives that contain different versions of firmware and firmware meta files. The attack works by inserting and removing the USB flash disk during a firmware upgrade. Since the Sony GTV software doesn't seem to check if a device is inserted and removed during the upgrade process this simple attack is able to downgrade the firmware version. After the downgrade the device can be rooted since the older version contains a software vulnerability that allows shell command injection. Our attack is similar but targets more hardened systems that can detect removal of the upgrade medium such as the USB flash drive.</p><p>Our work also falls into the area of trusted computing and software attestation. One of the challenges in these areas is to prove the integrity of data stored in the off-chip memory, i.e., memory not part of the actual CPU. <ref type="bibr" target="#b7">[9]</ref> presents a survey on memory authentication mechanisms and attacks that also deal with external memory and storage. Our attack relies on the ability to modify the content of an external storage device that is connected to the target system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions</head><p>In this work we presented a novel time-of-check-totime-of-use (TOCTTOU) attack that targets the content of files based on emulated mass-storage devices. Our attack is called Read It Twice! (RIT). We designed and implemented a USB mass-storage-based version of our novel TOCTTOU attack to inject a shared object into a Samsung TV-set bypassing the implemented security checks. The shared object is executed with root privileges thus it is effectively rooting or jailbreaking the device.</p><p>We believe that our RIT attack applies to many kinds of consumer electronics and embedded systems that install software packages from external storage devices, given the same boundary conditions apply. Mainly the check and install code must not be bound together.</p><p>Although we developed our proof-of-concept attack for USB-based mass-storage, we believe the attack transfers to any kind of flash and disk technology as long as the block access can be observed and altered. A prime example of another kind of external storage device is a Secure Digital (SD) or Multi Media Card (MMC) card. Any storage device technology that can be emulated can be used to carry out our RIT attack. Storage devices containing a sophisticated processor may be modified via software to carry out a RIT attack without emulation but directly returning different data for multiple read operations of the same block.</p><p>In the future, manufacturers need to take special care when reading sensitive data from external attached mass-storage devices. The device could be emulated to carry out an attack such as our Read It Twice! attack.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Our attack in 4 steps: 1) The TV-set request block 23 from our emulated storage device. 2) Our tool reads block 23 from the benign filesystem image and delivers it to the TV-set. 3) At a later point, the TV-set again requests block 23 form the storage device. 4) This time our tool reads block 23 from the modified filesystem image and delivers the block to the TV-set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>SO (4608b) [/TOCTTOU] 15 TOCTTOU.SO -&gt; read completed! 16 CLMETA.DAT (471b) [/TOCTTOU] 17 CLMETA.DAT -&gt; read completed! [3/2]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>11 :18:56 TOCTTOU</head><label>11</label><figDesc></figDesc><table>(DIR) 
11:18:56 CLMETA.DAT (471b) [/TOCTTOU] 
11:18:56 CLMETA.DAT -&gt; read completed! 
11:18:56 CACHE 
(DIR) 
11:18:56 CLMETA.DAT (450b) [/CACHE] 
11:18:56 CLMETA.DAT -&gt; read completed! 
11:19:10 CACHE.BMP 
(843758b) [/CACHE] 
11:19:10 CACHE.BMP 
-&gt; read completed! 
11:19:10 TOCTTOU.BMP (490734b) [/TOCTTOU] 
11:19:10 TOCTTOU.BMP -&gt; read completed! 
11:19:56 TELNETD 
(1745016b) [/TOCTTOU] 
11:19:56 TELNETD 
-&gt; read completed! 
11:19:56 TOCTTOU.SO (4608b) [/TOCTTOU] 
11:19:56 TOCTTOU.SO -&gt; read completed! 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The authors would like to thank Patrick Stewin, Dmitry Nedospasov, and Jean-Pierre Seifert for reviewing early versions of this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<ptr target="http://www.ci-plus.com" />
		<title level="m">CI Plus (CI+</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
				<ptr target="http://www.libsdl.org" />
		<title level="m">Simple DirectMedia Layer</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<ptr target="http://kernel.org/doc/htmldocs/gadget.html" />
		<title level="m">USB gadget API of the Linux kernel</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">About</forename><surname>Sony Downgrade + Rebooter</surname></persName>
			<affiliation>
				<orgName type="collaboration">Root</orgName>
			</affiliation>
		</author>
		<ptr target="http://gtvhacker.com/index.php/About_Sony_Downgrade_+_Rebooter_" />
		<imprint>
			<date type="published" when="2012-02" />
		</imprint>
	</monogr>
	<note>Root</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Alaoui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Psgroove</surname></persName>
		</author>
		<ptr target="https://github.com/psgroove/psgroove" />
		<imprint>
			<date type="published" when="2010-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Checking for Race Conditions in File Accesses</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bishop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bishop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dilger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing Systems</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="131" to="152" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Plug and Prey: Malicious USB Devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Crenshaw</surname></persName>
		</author>
		<ptr target="http://www.irongeek.com/downloads/Malicious%20USB%20Devices.pdf" />
		<imprint>
			<date type="published" when="2011-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Hardware mechanisms for memory authentication: A survey of existing techniques and engines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Elbaz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Champagne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Gebotys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">R</forename><surname>Potlapally</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Torres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions on Computational ScienceSpecial Issue on Security in Computing</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="1" to="22" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gumstix</forename><surname>Inc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Gumstix</surname></persName>
		</author>
		<ptr target="http://www.gumstix.com/" />
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">USB autorun attacks against Linux</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Larimer</surname></persName>
		</author>
		<ptr target="http://blogs.iss.net/archive/papers/ShmooCon2011-USB_Autorun_attacks_against_Linux.pdf" />
		<imprint>
			<date type="published" when="2011-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Microsoft Extensible Firmware Initiative FAT32 File System Specification</title>
		<ptr target="http://msdn.microsoft.com/en-us/windows/hardware/gg463084" />
	</analytic>
	<monogr>
		<title level="j">FAT General Overview On-Disk Format</title>
		<imprint>
			<date type="published" when="2006-12" />
		</imprint>
	</monogr>
	<note>Microsoft Corporation</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
				<ptr target="http://www.samsung.com" />
		<title level="m">Samsung Inc. LE32Bxxx LCD TV</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Creating Content Library applications -SamyGO</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Samygo</surname></persName>
		</author>
		<ptr target="http://wiki.samygo.tv/index.php5/Creating_Content_Library_applications" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Samygo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Samygo</surname></persName>
		</author>
		<ptr target="http://www.samygo.tv" />
		<imprint/>
	</monogr>
	<note>Samsung Firmware on the GO</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Service Menu Enabling Add/Delete in Content Manager -SamyGO</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Samygo</surname></persName>
		</author>
		<ptr target="http://wiki.samygo.tv/index.php5/Service_Menu\#Enabling_Add.2FDelete_in_Content_Manager" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Exploiting smart-phone USB connectivity for fun and profit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Stavrou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th Annual Computer Security Applications Conference, ACSAC &apos;10</title>
		<meeting>the 26th Annual Computer Security Applications Conference, ACSAC &apos;10</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="357" to="366" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
