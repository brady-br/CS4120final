<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:17+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards Production-Run Heisenbugs Reproduction on Commercial Hardware Towards Production-Run Heisenbugs Reproduction on Commercial Hardware</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>July 12-14, 2017</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shiyou</forename><surname>Huang</surname></persName>
							<email>huangsy@tamu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit2">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit3">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit4">Texas A&amp;M University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bowen</forename><surname>Cai</surname></persName>
							<email>bowen.cai@tamu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit2">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit3">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit4">Texas A&amp;M University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Huang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit2">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit3">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit4">Texas A&amp;M University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shiyou</forename><surname>Huang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit2">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit3">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit4">Texas A&amp;M University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bowen</forename><surname>Cai</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit2">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit3">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit4">Texas A&amp;M University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Huang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit2">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit3">Texas A&amp;M University</orgName>
								<orgName type="institution" key="instit4">Texas A&amp;M University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Towards Production-Run Heisenbugs Reproduction on Commercial Hardware Towards Production-Run Heisenbugs Reproduction on Commercial Hardware</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2017 USENIX Annual Technical Conference (USENIX ATC &apos;17)</title>
						<meeting>the 2017 USENIX Annual Technical Conference (USENIX ATC &apos;17) <address><addrLine>Santa Clara, CA, USA</addrLine></address>
						</meeting>
						<imprint>
							<date type="published">July 12-14, 2017</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 2017 USENIX Annual Technical Conference is sponsored by USENIX. https://www.usenix.org/conference/atc17/technical-sessions/presentation/huang</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We present a new technique, H3, for reproducing Heisenbugs in production runs on commercial hardware. H3 integrates the hardware control flow tracing capability provided in recent Intel processors with symbolic constraint analysis. Compared to a state-of-the-art solution , CLAP, this integration allows H3 to reproduce failures with much lower runtime overhead and much more compact trace. Moreover, it allows us to develop a highly effective core-based constraint reduction technique that significantly reduces the complexity of the generated symbolic constraints. H3 has been implemented for C/C++ and evaluated on both popular benchmarks and real-world applications. It reproduces real-world Heisenbugs with overhead ranging between 1.4%-23.4%, up to 8X more efficient than CLAP, and incurs only 4.9% runtime overhead on PARSEC benchmarks.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The ability to reproduce software bugs is crucial for debugging, yet due to the often non-deterministic memory races among threads, it is notoriously difficult to reproduce concurrency bugs, i.e., the so-called Heisenbugs <ref type="bibr" target="#b13">[15]</ref>. Researchers have investigated significant efforts in record &amp; replay (RnR) systems aiming to eliminate the non-determinism. However, it remains challenging to deploy an RnR system for production runs. Most existing solutions either are too slow due to the high runtime overhead incurred by tracing the shared memory dependencies, introduce the observer effect that makes the Heisenbugs disappear <ref type="bibr" target="#b15">[17,</ref><ref type="bibr" target="#b18">20,</ref><ref type="bibr" target="#b29">31]</ref>, or require special hardware that does not exist <ref type="bibr" target="#b14">[16,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b24">26,</ref><ref type="bibr" target="#b26">28,</ref><ref type="bibr" target="#b31">33]</ref>.</p><p>CLAP <ref type="bibr" target="#b16">[18]</ref> introduces the idea of recording only thread-local information (i.e., thread-local control flow paths) and then using offline constraint solving to reconstruct the shared memory dependencies. It is a promising solution for reproducing Heisenbugs because it does not record any cross-thread communication (data or synchronization); hence it requires no synchronizations during recording, which not only reduces the runtime overhead but also minimizes the observer effect.</p><p>To enable a production-run RnR solution, however, CLAP is still unsatisfactory due to two important challenges. First, although CLAP is much faster than conventional solutions, the runtime overhead incurred by CLAP using software path-recording is as large as 3X, which is unacceptable for most production environments. Second, the constraints generated by CLAP can be too complex to solve. In the worst case, the complexity of the constraints is exponential in the trace size. Despite that SMT solvers (e.g., Z3 <ref type="bibr" target="#b12">[14]</ref>) are becoming increasingly powerful, in practice, the constraints can become too large to solve in a reasonable time.</p><p>In this paper, we present H3, a new RnR system to reproduce Heisenbugs by extending CLAP with commercial hardware features. Our key observation is that both of the aforementioned challenges can be effectively addressed by hardware-supported control-flow tracing. As also indicated in the CLAP paper <ref type="bibr" target="#b16">[18]</ref>, for path recording, hardware techniques <ref type="bibr" target="#b28">[30]</ref> can achieve as low as 0.6% overhead. In reality, recent Intel processors (starting from the 5th generation) have provided a new feature called Processor Tracing (PT) to trace the program control flow with very small (less than 5%) runtime overhead <ref type="bibr" target="#b1">[2]</ref>. PT uses highly-compacted packets (i.e., only one bit for each conditional branch) to capture branch outcomes, often producing a compact trace requiring &lt; 1 bit per retired assembly instruction. Moreover, hardware-supported tracing allows us to perform a significant reduction of the constraints generated by CLAP, because memory accesses executed on each core are ordered internally. We develop a core-based constraint reduction technique that reduces the complexity of the constraints from exponential in the trace size to only exponential in the number of cores.</p><p>As illustrated in <ref type="figure" target="#fig_0">Figure 1</ref>, H3 consists of two phases. First, users run the target program on a COTS (commercial off-the-shelf) hardware with PT enabled. Once a failure occurs, the PT trace together with the thread context switch log are sent to the developer for reproducing the bug. From the PT trace and the binary image of the target program, H3 generates the instructions executed on each core. Second, H3 infers the instructions executed by each thread based on the thread context switch log and generates a symbolic trace for each thread. It then constructs symbolic constraints with the core-based constraint reduction, and computes a global failure reproducing schedule with an SMT solver. Despite a clear design, realizing H3 faces two main additional technical challenges: 1) How to transform the low-level hardware trace to a high-level (source or IR) trace? 2) How to capture the data values (PT does not trace data values)? To solve the first challenge, we transform the hardware trace into a sequence of IR-level tuples, to identify what basic blocks are executed by each thread. This is done by matching the low-level assembly instructions in the per-thread local execution with that in the IR (i.e., LLVM bitcode). For the second challenge, we symbolically execute the IR along the sequence of basic blocks for each thread. The unknown data values (including all the unknown read values and addresses) are encoded as symbolic variables, and are computed via constraint solving.</p><p>We implemented H3 for C/C++ programs based on PT, and evaluated it with a collection of popular performance benchmarks and real-world applications containing known Heisenbugs. Our experimental results show that H3 incurs only 1.4% to 23.4% runtime overhead for all the applications and only 4.9% for the PARSEC benchmarks on average, as much as 8X more efficient than CLAP. Moreover, H3 reduces the size of the constraints in CLAP by 28% to 99%, improving the speed of constraint solving by 2X-250X in most cases, and enabling H3 to reproduce more bugs than CLAP within a limited time budget.</p><p>This paper makes the following contributions:</p><p>• To our best knowledge, H3 is the first technique that integrates hardware control flow tracing with offline symbolic analysis for reproducing production-run</p><p>Heisenbugs on commercial hardware.</p><p>• We develop a new core-based constraint reduction technique that significantly reduces the complexity of generated symbolic constraints from exponential in the trace size to exponential in the core counts.</p><p>• We implement and evaluate H3 on both popular benchmarks and real applications. Experiments show that H3 can reproduce real Heisenbugs in production runs with very small overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>In this section, we first review the CLAP technique and elaborate its limitations. We then show how hardware control-flow tracing addresses these limitations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">CLAP</head><p>CLAP can not only reproduce Heisenbugs under sequential consistency (SC), but also a wide range of weak consistency memory models, including TSO (total store order) and PSO (partial store order) <ref type="bibr" target="#b7">[9]</ref>. It has two key components: I) collecting per-thread control flow information via software path-recording (using an extended Ball-Larus path-recording algorithm <ref type="bibr" target="#b9">[11]</ref>), and II) assembling a global schedule by solving symbolic constraints constructed over the thread local paths. To assemble a global schedule, CLAP has three steps:</p><p>1. Along the local path of each thread, it collects all the critical accesses (read, write or synchronization) to shared variables.</p><p>2. It introduces a fresh symbolic value for each read access, and collects the path constraints following the control flow for each thread via symbolic execution; it introduces an order variable for each critical access, and generates additional constraints according to synchronization, memory-consistency model, and potential inter-thread memory dependencies.</p><p>3. It uses an SMT solver to solve the constraints, to which the solutions correspond to global schedules that can reproduce the error. In other words, the SMT solver computes what inter-thread memory dependencies would satisfy the memoryconsistency model and enable the recorded local execution path. CLAP contains several components to model a failing execution as constraints (e.g., failure, path, synchronization, read-write, and memory model). We next use an example in <ref type="figure">Figure 2</ref> to illustrate these constraints. Section 3.3 presents the constraint model in detail.</p><p>The program in <ref type="figure">Figure 2</ref> contains a real Heisenbug that only manifests under the PSO memory model, which caused a $12 million financial loss in the real-world <ref type="bibr" target="#b5">[7]</ref>. The root cause of the bug is that the write to z (line 5) can be reordered with the writes to x and y (lines 3-4) under PSO. The dashed arrow in the figure shows that the satisfaction of the if condition at line 7 depends on the write to z at line 5, which always happens after lines 3 and 4 under SC. However, under PSO, the write to z is allowed to happen before the write to y at line 4. As a result, when the if condition is satisfied, the value of x + 1 and y may be unequal and hence triggering the error. The error can be triggered by the following PSO schedule: 1-2-3 R x -3 W x -4 R y -5-7-8 R x -8 R y (the subscripts are used to distinguish different operations from the same line).</p><p>The CLAP constraints for reproducing the buggy PSO schedule are shown in <ref type="figure" target="#fig_1">Figure 3</ref>. We use the order variable O i denotes the order of the corresponding access at line i. The symbolic variable R i v denotes the value returned by the read access to the variable v at line i, and W i v the value written to v by the write at line i. To distinguish different operations at the same line, we add the type of the operation to the order variable. For example, O R x 3 and O W x 3 represent the orders of the read and write to x at line 3, respectively.</p><p>To manifest the error, CLAP enforces the assertion to be violated while satisfying the path constraints, i.e., true ≡ (R 7 z = 1∧R 8 x +1 񮽙 = R 8 y ). A major part of the CLAP constraints is the read-write constraints, which are used to capture the potential inter-thread memory dependencies. Because the order of the memory accesses from different threads is unknown, the read-write constraints must encode a schedule for every potential read-write match, in which the read returns the value written by the write. For example, the read of z at line 7, R 7 z , may be matched with either the initial value 0, or the value written by line 2 or 5. If the former, the read R 7 z should happen before all the writes to z; if the latter, R 7 z should be matched with the corresponding write. For example, if R 7 z returns the value by the write at line 2, the constraint</p><formula xml:id="formula_0">R 7 z = W 2 z ∧ O 2 &lt; O 7 ∧ (O 5 &lt; O 2 ∨ O 7 &lt; O 5 ) is generated.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CLAP Limitations</head><p>1. Exponential complexity of read-write constraints.</p><p>The read-write constraints generated by CLAP are very <ref type="figure">Figure 2</ref>: A real PSO bug in an electron microscope software <ref type="bibr" target="#b5">[7]</ref>, which caused a $12 million loss of equipment.  complicated in practice because there may exist many writes that a read can be matched with. In the worst case, the complexity of the read-write constraints (i.e., the space of scheduling choices) is exponential in the number of writes (which typically accounts for a large percentage of the events in the trace). This is a bottleneck in CLAP especially for programs with intensive interthread memory dependencies, because the SMT solver may fail to solve the constraints. We will present a detailed complexity analysis in Section 3.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Read-Write Constraints</head><formula xml:id="formula_1">(" # $ = 0 ∧ ) $ &lt; ) + ) ∨ (" # $ = . # + ∧ ) + &lt; ) $ ∧ () / &lt; ) + ∨ ) $ &lt; ) / )) ∨ (" # $ = . # / ∧ ) / &lt; ) $ ∧ () + &lt; ) / ∨ ) $ &lt; ) + ))</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Path Constraints Failure Constraints</head><p>2. Slowdown of software path-recording. CLAP uses a highly optimized algorithm (i.e., Ball-Larus <ref type="bibr" target="#b9">[11]</ref>) to track the control flow information for each thread. Although it greatly reduces the runtime overhead incurred by many other RnR solutions, it still incurs 10%-3X performance slowdown on popular benchmarks <ref type="bibr" target="#b16">[18]</ref>. For instance, for the example in <ref type="figure">Figure 2</ref>, when the code is executed in a loop for 10 million times, CLAP incurs 2.3X program slowdown.</p><p>3. Difficulty of code instrumentation. It is difficult to apply software path-recording in production runs because it requires code instrumentation. Real-world programs often rely on external libraries, proprietary code, and/or are composed from layers of frameworks and extended by third-party plugins. Tracing the whole pro- gram control flow by code instrumentation is difficult or impossible. For example, if a failure is caused by a bug in the uninstrumented external code, the constraints generated by CLAP may be incomplete and hence fail to reproduce the bug.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Hardware Control-Flow Tracing</head><p>Tracing control flow at the hardware level opens a door to apply CLAP in production runs by addressing the aforementioned limitations in three ways. First, hardwaresupported control flow tracing is significantly more efficient than software-level path-recording. Compared to the 10%-3X overhead by software path-recording, PT achieves as low as 5% runtime overhead <ref type="bibr" target="#b1">[2]</ref>. Second, hardware can track the full control flow of the code executed on each core. PT can not only trace the application code, but also the whole operating system kernel <ref type="bibr" target="#b1">[2]</ref>. Third, tracing the control flow on each core enables a significant reduction of the complexity of the read-write constraints, because reads and writes from the same core are ordered already. Next, we first review the basics of PT and then show its performance improvement over software path-recording on PARSEC 3.0 benchmarks <ref type="bibr" target="#b3">[5]</ref>.</p><p>Intel PT. As depicted in <ref type="figure" target="#fig_2">Figure 4</ref>, PT consists of two main components: tracing and decoding. For tracing, it only records the instructions that are related to the change of the program control flow and omits everything that can be deduced from the code (e.g., unconditional direct jumps). For each conditional branch executed, PT generates a single bit (1/0) to indicate whether a conditional branch is taken or not taken. As such, PT tracks the control flow information, such as loops, conditional branches and function calls of the program, with minimal perturbation, and outputs a highly compact trace.</p><p>For decoding, PT provides a decoding library <ref type="bibr" target="#b0">[1]</ref> to reconstruct the control flow from the recorded raw trace. It first synchronizes the packet streams with the synchronization packets generated during tracing, and then iterates over the instructions from the binary image to identify what instructions have been executed. Only when the decoder cannot decide the next instruction (e.g., when it encounters a branch), the raw trace is queried to guide the decoding process.</p><p>PT is configurable via a set of model-specific registers by the kernel driver. It provides a privilege-level filtering function for developers to decide what code to trace (i.e. kernel vs. user-space) and a CR3 filtering function to trace only a single application or process. PT on Intel Skylake processors also supports filtering by the instruction pointer (IP) addresses. This feature allows PT to selectively trace code that is only within a certain IP range, which can further reduce the tracing perturbation.</p><p>PT Performance. <ref type="table" target="#tab_1">Table 1</ref> reports the runtime and space overhead of PT on the PARSEC 3.0 benchmarks. We report the execution time of the programs without and with PT tracing (and the trace size), marked as native and PT respectively. Among the 10 benchmarks, PT incurs 1.4% to 14.7% runtime overhead (4.9% on average) and 88MB to 2.4GB space overhead (0.5GB on average).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">H3</head><p>In this section, we present the technical details of H3. As we have described in <ref type="figure" target="#fig_0">Figure 1</ref>, H3 integrates hardware control-flow tracing with offline symbolic constraint analysis to reproduce Heisenbugs. Although the overall flow is easy to understand, there are three technical challenges in the integration:</p><p>1. Absence of the thread information. There is no thread information from the PT traces. It is unknown which instruction is executed by which thread, and hence difficult to construct the interthread synchronization and memory dependency constraints.</p><p>2. Gap between low-level hardware traces and high-level symbolic traces. The decoded execu-tion from PT is in the low-level assembly form. However, to construct constraints and to reproduce bugs, we need a high-level symbolic trace containing shared variable accesses and branch conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>No data values for memory accesses. PT only traces control flow information but does not record any data values of memory accesses. To reconstruct the shared memory dependencies, we need a way to match reads with writes without using values.</p><p>We present our solutions to these challenges in the next three subsections. We also present a constraint reduction algorithm in Section 3.4 enabled by the partial order of writes per-core, which significantly reduces the complexity of the generated constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Thread Local Execution Generation</head><p>We leverage the context-switch software events (generated by the Linux Perf tool) to distinguish instructions from different threads. Each context-switch event contains three attributes: TID, CPUID, and TIME (i.e., the timestamp of the event). Because PT also generates frequent synchronization packets (including the timestamp information) into the packet stream, we can use the timestamp information to synchronize the context switch events with the PT packets from the same core (i.e., CPUID). Because the timestamp clocks local to each core is precise, the inferred thread identity based on the timestamp information is also precise. Hence, we locate the context switch points in the PT packets on each core by comparing the timestamps, and determine the thread identity of each instruction as the TID attribute of the leading context-switch event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Symbolic Trace Generation</head><p>In CLAP, the symbolic trace of each thread is generated by symbolic execution along the recorded path profile of each thread. The path profile for each thread is decoded (from the Ball-Larus path encoding <ref type="bibr" target="#b9">[11]</ref>) as a sequence of basic block transitions at the LLVM IR level in the form of <ref type="bibr">(Tid, BasicBlockId)</ref>. In H3, we also rely on these high-level per-thread path profiles to collect the symbolic traces, and we extract the path profiles from the low-level PT trace as follows. We first instrument all basic blocks of the target program and assign each a unique identifier. Then we compare the generated assembly code from the instrumented program with the decoded instructions from the PT trace to identify which basic blocks are executed by each thread.</p><p>Algorithm 1 shows the process of generating the path profiles for each thread. The algorithm takes as input:</p><p>(1) the executed instructions and their corresponding line for each item ∈ 񮽙 do 5:</p><p>if item.line ∈ B.line then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6:</head><p>block id = B.get(item.line)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7:</head><p>Q.add(tid, block id) 8: return Q number; and (2) the basic blocks of the control-flow of the program with the BlockId and the line number of the first instruction of this block. The algorithm first gets the executed instructions by each thread (line 3) and then matches the line number of the executed instructions with that contained in each basic block (line 4-7). To identify the path profile of a thread, the algorithm iterates over the instructions of each thread to check whether the instruction is the first one of the block by comparing the line number (line 5). If so, we add this block into the path profile as (Tid, BasicBlockId).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Matching Reads and Writes</head><p>To reconstruct the shared memory dependencies without data values, similar to CLAP, we construct a system of symbolic constraints over the per-thread symbolic traces. The basic idea is to introduce an order variable for each read/write denoting the unknown scheduling order, and a symbolic variable for each read/address denoting the unknown read value and address. We symbolically execute the program following the recorded per-thread control flow, and constructs constraints over the order and symbolic variables to determine the inter-thread orders and values of reads/addresses. More specifically, we construct a system of SMT constraints formula, denoted by Φ g , over the symbolic traces. The computed orders/values from solving Φ g then correspond to one or more concrete global schedules that can reproduce the Heisenbugs. We note that the computed schedules may be different from that in the failure execution, but any one of them is sufficient to reproduce the Heisenbugs.</p><p>Φ g can be decomposed into five parts:</p><formula xml:id="formula_2">Φ g = Φ path ∧ Φ bug ∧ Φ sync ∧ Φ mo ∧ Φ rw</formula><p>where Φ path denotes the path conditions by each thread; Φ bug the condition for the bug manifestation; Φ sync the interactions between inter-thread synchronizations; Φ rw the potential inter-thread memory dependencies; and Φ mo the memory model constraints. The formula contains two types of variables: (1) V -the symbolic value variables denoting the values returned by reads; and (2) O -the order variables the order of each operation in the final global schedule.</p><p>Path Constraints (Φ path ). The path constraints are constructed by a conjunction of all the path conditions of each thread, with each path condition corresponds to a branch decision by that path. The path conditions are collected by recording the decision of each branch via symbolic execution. Bug Constraints (Φ bug ). The bug constraints enforce the conditions for a bug to happen. A bug can be a crash segfault, an assert violation, a buffer overflow, or any program state-based property. To construct the bug constraints, an expression over the symbol values for satisfying the bug conditions is generated. For example, the violation of an assertion exp can be modeled as !exp. Synchronization Constraints (Φ sync ). The synchronization constraints consist of two parts: partial order constraints and locking constraints. The partial order constraints model the order between different threads caused by synchronizations fork/join/signal/wait. For example, The begin event of a thread t should happen after the fork event that starts t. A join event for a thread t should happen after the last event of t. The locking constraints ensures that events guarded by the same lock are mutually exclusive. It is constructed over the ordering of the lock and unlock events. More specifically, for each lock, all the lock/unlock pairs of events are extracted, and the following constraints for each two pairs (l 1 , u 1 ) and (l 2 , u 2 ) are constructed:</p><formula xml:id="formula_3">O u 1 &lt; O l 2 ∨ O u 2 &lt; O l 1 .</formula><p>Memory Order Constraints (Φ mo ). The memory order constraints enforce orders specified by the underlying memory models. H3 currently supports three memory models: SC, TSO and PSO. For SC, all the events by a single thread should happen in the program order. TSO allows a read to complete before an earlier write to a different memory location, but maintains a total order over writes and operations accessing the same memory location. PSO is similar to TSO, except that it allows re-ordering writes on different memory locations.</p><p>Read-Write Constraints (Φ rw ). Φ rw matches reads and writes by encoding constraints to enforce the read to return the value written by the write. Consider a read r on a variable v and r is matched to a write w on the same variable; we must construct the following constraints: the order variables of all the other writes that r can be matched to are either less than O w or greater than O r . As discussed in Section 2.1, Φ rw can be complicated because there may exist many potential matches between reads and writes. The size of Φ rw is cubic in the trace size and its complexity is exponential in the trace size. Nevertheless, in next subsection, we show that both the size and complexity of Φ rw can be greatly reduced in H3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Core-based Constraints Reduction</head><p>Besides the low runtime overhead, another key innovation enabled by PT is that the order of executed events on each core (either by the same thread or by different threads) is determined, which can reduce the complexity of Φ rw from exponential in the number of writes to exponential in the core counts.</p><p>The key observation of this reduction is that the executed memory accesses on each core decoded from PT trace are already ordered, following the program order. Once the order of a certain write in the global schedule is determined, all the writes that happen before or after this write, on the same core, should occur before or after this write in the schedule correspondingly. This eliminates a large number of otherwise necessary read-write constraints for capturing the potential inter-thread memory dependencies.</p><p>Consider an example in <ref type="figure" target="#fig_4">Figure 5</ref>, which has four cores with each executing four different writes. Suppose there is a read R that can be potentially matched with all of these writes, because each of them writes a different value to the same shared variable read by R. Without the partial order information of each core, we must include all writes and their orderings into the constraints.</p><p>For instance, if R reads the value from the write W 7 on Core 2, then R must happen after W 7 (i.e., O R &gt; O W <ref type="bibr" target="#b5">7</ref> ), and all the other writes must either happen before W 7 or after R. Taking W 5 as an example; it must either happen before W 7 or after the read R, resulting in the con-</p><formula xml:id="formula_4">straint (O R &lt; O W 5 ∨ O W 5 &lt; O W 7 )</formula><p>. In general, if there are N writes in the trace, the constraints can generate 2 N different ordering choices for these writes. As typically most accesses in the trace are reads and writes, this exponential search space can be a bottleneck for the technique to scale.</p><p>However, with the per-core partial order information, the execution order of the writes on each core is already determined. To prevent other writes from happening between the considered write and read, we only need to take the read-write as a whole and insert it to those sorted writes. Algorithm 2 presents our constraints reduction algorithm. Following this algorithm, to make R read</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 Core-based constraints reduction</head><p>Input: a matched read-write &lt; R,W &gt; Output: Φ rw to make R read from W 1: Initial: Φ rw = / 0 2: case 1: writes executed on the same core as W 3:  </p><formula xml:id="formula_5">Φ rw = Φ rw ∧ (O W &lt; O R &lt; O W 񮽙 ) //</formula><formula xml:id="formula_6">Φ rw = Φ rw ∧ (O R &lt; O W i ∨ (O W i &lt; O W ∧ O R &lt; O W i+1 )) ∨ O W &gt; O W</formula><formula xml:id="formula_7">R &lt; O W 1 ∨ (O W 1 &lt; O W 7 ∧ O R &lt; O W 2 ) ∨ (O W 2 &lt; O W 7 ∧ O R &lt; O W 3 ) ∨ (O W 3 &lt; O W 7 ∧ O R &lt; O W 4 ) ∨ O W 4 &lt; O W 7 )</formula><p>. There are only 5 ordering choices (compared to 16 in CLAP).</p><p>We note that the core-based constraints apply to SC and TSO, but may not apply to those weak memory models that allow re-ordering of writes on the same core. The reason is that if writes are re-ordered, the partial order witnessed on each core may not reflect the actual buggy execution order.</p><p>Theorem 1 below states the soundness guarantee of the core-based reduction:</p><p>Theorem 1 If a concurrent program runs on an SC or TSO platform with C cores and there are N writes executed, the number of the ordering choices of the readwrite constraints is reduced from 2 N to (</p><formula xml:id="formula_8">N C + 1) C .</formula><p>Proof. Consider that a read R returns the value of a write W . When not knowing the partial order of the writes on each core, each write either happens before W or after R. Consequently, there are 2 N ordering choices in total. If the partial order of the writes on each core is known and each core contains m i = N C writes, the ordering on each core has only m i + 1 choices. Therefore, the total number of choices is reduced to Π C i=1 (m i + 1), which equals to ( N C + 1) C .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation</head><p>We have implemented H3 for Pthreads-based C/C++ programs based on a number of tools, including CLAP <ref type="bibr" target="#b16">[18]</ref>, the Linux Perf Tools <ref type="bibr">[3]</ref>, the PT decoding library <ref type="bibr" target="#b0">[1]</ref>, and the Z3 SMT solver <ref type="bibr" target="#b12">[14]</ref>. We use Perf to control Intel PT to collect the packet streams and the context switch events. We first insert the context switch events to the packet streams by comparing the timestamp information, and then use the PT decoding library to decode the packets information. As in CLAP, we use KLEE <ref type="bibr" target="#b10">[12]</ref> as the symbolic execution engine to generate the symbolic traces for each thread, and construct an SMT constraint formula. We modified CLAP to implement the core-based constraint reduction algorithm, and we use Z3 to solve the constraints.</p><p>Shared Variable Identification. We first run a static thread sharing analysis based on the Locksmith <ref type="bibr" target="#b27">[29]</ref> race detector and then manually mark each shared variable x as symbolic by klee make symbolic <ref type="bibr">(&amp;x, sizeof(x)</ref>, "x"), like CLAP. One way to automate this step is to conservatively consider all variables in the program as potentially shared and marked them as symbolic. However, this would produce a large amount of unnecessary constraints. For external function calls that are not supported by KLEE, we also mark the input and return variables of the external function calls as symbolic.</p><p>Constraint Reduction. For the core-based constraint reduction, we first extract the writes on the same core from the PT trace and store these writes in a map (core Id: w 1 [line], w 2 [line]...). When constructing the readwrite constraints, this map is used to determine which write belongs to which core by comparing the associated line number information. Because all writes on the same core occur in the order that they are executed, we construct a happens-before constraint over these writes.</p><p>When matching a read r to a corresponding write w, we first constrain r to happen after w and happen before the write that occurs right after w on the same core, and we then only need to disjunct the order constraints between w and those writes from a different core.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head><p>Our evaluation of H3 focuses on answering two sets of questions:</p><p>• How is the runtime performance of H3? How much runtime improvement is achieved by H3 compared to CLAP?</p><p>• How effective is H3 for reproducing real-world Heisenbugs? How effective is the core-based constraint reduction technique?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Methodology</head><p>We evaluated H3 with a variety of multithreaded C/C++ programs collected from previous studies <ref type="bibr" target="#b16">[18,</ref><ref type="bibr" target="#b33">35,</ref><ref type="bibr" target="#b4">6]</ref>, including nine popular real-world applications containing known Heisenbugs. <ref type="table" target="#tab_4">Table 2</ref> summarizes these benchmarks. pfscan is a parallel file scanner containing a known bug; aget-0.4.1 is a parallel ftp/http downloading tool containing a deadlock; pbzip2-0.9.4 is a multithreaded implementation of bzip with a known order violation; bbuf is shared bounded buffer and sbuf is a C++ implementation of the JDK1.4 StringBuffer class; httpd-2.2.9, httpd-2.0.48, httpd-2.0.46 are from the Apache HTTP Server each containing a known concurrency bug; We also included racey <ref type="bibr" target="#b4">[6]</ref>, a special benchmark with intensive races that are designed for evaluating RnR systems. We use Apache Bench (ab) to test httpd, which is set to handle 100 requests with a maximum of 10 requests running concurrently. We compared the runtime performance of H3 and CLAP by measuring the time and space overhead caused by PT tracing and software path-recording. We ran each benchmark five times and calculated the average. All experiments were performed on a 4 core 3.5GHz Intel i7 6700HQ Skylake CPU with 16 GB RAM running Ubuntu 14.04.</p><p>We evaluated the effectiveness of H3 for reproducing bugs by checking if H3 can generate a failure reproducing schedule and by measuring the time taken by offline constraint solving. We set one hour timeout for Z3 to solve the constraints.</p><p>For most benchmarks, the failures are difficult to manifest because the erroneous schedule for triggering the Heisenbugs is rare. Similar to CLAP, we inserted timing delays (sleep functions) at key places in each benchmark and executed it repeatedly until the failure is produced. We also added the corresponding assertion to denote the bug manifestation.</p><p>Benchmark Characteristics. <ref type="table" target="#tab_4">Table 2</ref> reports the execution characteristics of the benchmarks. Columns 3 and 4 report the number of threads and shared variables, respectively, contained in the execution. We also profiled the total number of the executed instructions and branches in the assembly code, and the branches from the LLVM IR code, as reported in Columns 5-7. Column 8 reports the ratio of the number of the branches in the instrumented application code versus the total number of branches (in both the application code and all the external libraries). For most benchmarks (except racey), the ratio is smaller than or around 20%. Column 9 reports the time for constructing the symbolic trace for the corresponding recorded execution of the benchmark. <ref type="table" target="#tab_5">Table 3</ref> reports the performance comparison between H3 and CLAP. Column 2 reports the native execution time of the benchmarks. Columns 3-4 report the execution time with H3 and CLAP and their runtime overhead. Column 5 reports the speedup of H3 over CLAP. Column 6 reports the percentage of branch instructions in the execution. This number is proportional to the runtime  Overall, the runtime overhead of H3 on these benchmarks ranges between 7.5%-23.4% and 12.9% on average. Compared to CLAP (11.0%-2X overhead), H3 achieves as much as 8X performance improvement and reduces its overhead significantly by 2.6%-65.2% and 31.3% on average. The only exception is pfscan. However, this is just because pfscan contains significantly more external calls compared to the other benchmarks; while H3 records all external library calls, the implementation of CLAP does not (which sacrifices the correctness). In addition, the short execution time of pfscan can suffer from noise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Runtime Performance</head><p>For space overhead, H3 produces 30KB-2.4GB traces on these benchmarks, whereas CLAP produces 2KB-2.1GB. Some numbers of CLAP are smaller than that of H3, because external library calls are not traced by CLAP.</p><p>H3 performance analysis. We note that the performance of H3 is dominated by PT for tracking the control flow events. The additional cost for H3 to track context switching events is almost negligible as compared to tracing the control flow. We have also evaluated the runtime performance of H3 on the PARSEC 3.0 benchmarks and found that H3 incurs only 1.4% to 14.7% runtime overhead (4.9% on average) and 0.5GB trace size, the same as that reported in <ref type="table" target="#tab_1">Table 1</ref> for PT.</p><p>We further conducted a performance study of H3 on PARSEC with respect to three impacting factors: the trace size, the number and percentage of branch instructions, as shown in <ref type="figure" target="#fig_5">Figure 6</ref>.  <ref type="table" target="#tab_4">Table 2</ref> that the number of branches in the application code often accounts for a small percentage of the total number of branches. Hence, in practice, the performance of H3 can be further improved by tracing only the application code and omitting external library calls. <ref type="table" target="#tab_6">Table 4</ref> reports the results of Heisenbug reproduction. We successfully evaluated five benchmarks 1 with a total number of seven Heisenbugs. racey1, racey2 and racey3 correspond to the racey benchmark with 500, 1000, and 1500 loop iterations. Column 2 reports the number of unknown variables in the constraint formula, corresponding to the number of read/write/synchronization operations in the symbolic trace. Columns 3-6 report the results of CLAP, including the total size of the generated constraints (in terms of the number of constraint clauses), the size of readwrite constraints, the constraint solving time by Z3 and whether Z3 returns a solution before timeout in one hour. Columns 7-10 report the corresponding results of H3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Effectiveness of Bug Reproduction</head><p>Overall, H3 is more efficient and effective than CLAP in reproducing Heisenbugs. The key difference between H3 and CLAP is that with the core-based constraint reduction, H3 generates a much simpler and smaller con- straint formula than CLAP. H3 reduces the size of the CLAP constraints by 28%-99%, and is able to reproduce more bugs than CLAP. Both H3 and CLAP reproduce the bugs in the four benchmarks bbuf, sbuf, pfscan and pbzip2. H3 additionally reproduces the bug in racey1, while CLAP fails because the solver could not solve the constraints in time. In addition, for bbuf, although both H3 and CLAP can reproduce the bug, H3 is much faster (52s vs 98s) than CLAP. H3 fails on racey2 and racey3 because the constraints in these two cases are still too complex to solve.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Limitations and Future Work</head><p>Our experimental results show that H3 achieves a significant performance improvement over CLAP by integrating hardware control-flow tracing with constraint analysis. Nevertheless, we observe several factors that can be leveraged to further improve the performance of H3.</p><p>Large PT Trace Data. On our current platform, the size of the PT trace buffer per core is limited to 4MB. For tracing long running programs, the buffer can get full quickly (e.g., 0.01s for the PARSEC benchmarks). Currently, Perf actively monitors the trace buffer and flushes it to disk once the buffer is full. To avoid overwriting the buffered data, Perf also needs to disable PT when the buffer is full, and wakes it up when the data is copied out. This is a main bottleneck that limits the runtime performance of H3 because the program execution has to be suspended when PT is off, otherwise the control flow data may be lost when the buffer data is being copied out. We also experienced data loss with Perf when using PT to track long traces. This happens because the speed of copying data out is not fast enough, causing certain buffered data overwritten by the new data. We expect that a larger trace buffer or double buffering in the future generations of PT will help alleviate this problem.</p><p>Data Values. Another limitation of PT is that it only tracks the control flow of the program but not any data values or memory addresses. This is the main reason why symbolic execution is needed in H3 to construct symbolic traces. Although symbolic execution engines such as KLEE are becoming increasing powerful, scaling symbolic execution to long running programs remains a challenging problem. In addition, limited by KLEE, H3 currently can only reproduce concurrency failures that occur in the application code, but not external function calls (though it traces the control flow in all external libraries).</p><p>For future work, we plan to use hardware watchpoints (as also used in Gist <ref type="bibr" target="#b17">[19]</ref>) to capture the value and address of variables along with the PT control flow tracing. With the value information, we can then skip the symbolic execution part but construct the constraints by matching the values of reads and writes directly. Moreover, this will further reduce the complexity of the generated constraints.</p><p>Constraint Solving for Long Traces. Although our constraint reduction is effective, the complexity of the generated constraints is still exponential in the number of cores. For long traces, the constraint size can still be large and solving them remains challenging. For example, H3 failed on racey2 and racey3 due to the solver timeout. For this problem, we plan to improve H3 in two ways. First, we can perform periodic checkpoints (e.g., using the snapshot mode of Perf) to save the current state of the program, such that when a failure occurs, H3 needs only to generate the constraints from the last checkpoint to the failure. Second, we can reduce the amount of the trace by not tracing the control flow in the external libraries (e.g., using the IP filtering featured supported by Skylake processors). As shown in our experimental results, the branches from the application code account for only a small percentage (7-20%) of the total trace, most of which are from the external libraries. Skipping tracing the external libraries will greatly reduce both the trace size and the runtime overhead.</p><p>Non-deterministic Program Inputs. Similar to CLAP, currently H3 does not record the program input but assumes that all program inputs are fixed. If the program input is non-deterministic or certain program inputs are missed, H3 may fail to reproduce the bug. This prob-lem can be addressed by tracking the program input and enforcing the same input value during the symbolic trace construction and the bug reproduction. Mozilla RR <ref type="bibr" target="#b2">[4]</ref> is a promising solution to track non-deterministic inputs in real-world systems, by tracing only system call results and signals with ptrace. We expect that by integrating H3 with RR, H3 will be able to reproduce failures resulted from both non-deterministic schedules and inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Researchers have proposed many different RnR systems, both at the software level <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b11">13,</ref><ref type="bibr" target="#b15">17,</ref><ref type="bibr" target="#b16">18,</ref><ref type="bibr" target="#b19">21,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b21">23,</ref><ref type="bibr" target="#b25">27,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b32">34,</ref><ref type="bibr" target="#b36">38]</ref> and hardware-level <ref type="bibr" target="#b14">[16,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b24">26,</ref><ref type="bibr" target="#b26">28,</ref><ref type="bibr" target="#b31">33]</ref>. Most RnR systems are either order-based <ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b15">17,</ref><ref type="bibr" target="#b21">23,</ref><ref type="bibr" target="#b32">34,</ref><ref type="bibr" target="#b36">38]</ref> that rely on faithfully recording the shared memory dependencies at runtime, or search-based <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b16">18,</ref><ref type="bibr" target="#b19">21,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b30">32]</ref> that record only partial information at runtime and rely on powerful search engines such as SMT solvers to reconstruct the memory dependencies.</p><p>A central goal of RnR systems is to reduce the runtime overhead such that they can be used in production runs. Hardware techniques <ref type="bibr" target="#b14">[16,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b24">26,</ref><ref type="bibr" target="#b26">28,</ref><ref type="bibr" target="#b31">33]</ref> are often much more efficient than software-level implementation, but most previous RnR systems rely on special hardware that is not available. Intel PT is an exciting hardware feature that opens a door for RnR systems to be applied broadly in COTS platforms.</p><p>Gist <ref type="bibr" target="#b17">[19]</ref> introduces a bug diagnosis technique that also leverages PT to identify root causes of a failure with low overhead. Different from H3, Gist assumes the failure can be reproduced in the first place, but it may fail to do so. In addition, Gist relies on statistical analysis to identify failure causes, but it has no guarantee, i.e., it may miss real causes or report false positives. Compared to Gist, H3 solves a different problem: reproducing failures before they can be diagnosed, and H3 is sound: it guarantees to reproduce the failure as long as the constraints can be solved by the solver.</p><p>Arulraj et al.</p><p>[10] use hardware performance counters for failure diagnosis. This technique leverages the hardware to sample predicates from a large number of successful and failing runs and then use the sampled predicates to diagnose the failure via statistical analysis.</p><p>ReCBuLC <ref type="bibr" target="#b34">[36]</ref> uses hardware clocks that are available on modern processors to help reproducing Heisenbugs. The recorded timestamps local to each thread together with a statistical analysis for calculating the time differences among local clocks across different cores, are used to determine the global schedule of shared-resource accesses. One limitation of this approach is that the statistical analysis may fail to infer a correct global schedule.</p><p>The idea of using offline constraint analysis to infer global failure schedules was pioneered by Lee et al. <ref type="bibr" target="#b19">[21,</ref><ref type="bibr" target="#b20">22]</ref>. The technique uses load-based checkpoints to search for a global schedule without recording any shared memory dependencies. However, compared to PT, the load-based checkpoints are not supported by the commodity architecture.</p><p>Similar to CLAP, both ODR <ref type="bibr" target="#b6">[8]</ref> and Symbiosis <ref type="bibr" target="#b22">[24]</ref> rely on symbolic constraint solving to figure out schedules that can satisfy certain conditions. ODR uses constraints to reproduce failures, and Symbiosis uses constraints for reducing the schedule complexity.</p><p>PRES <ref type="bibr" target="#b25">[27]</ref> proposes a probabilistic replay technique that uses an intelligent feedback-based replayer to reproduce failures with lightweight recording. PRES may fail to reproduce the bug in the first attempt due to a recorded incomplete schedule. However, it can learn from the previous failing replays to rectify the schedule. Typically after a few attempts, PRES is able to find a correct schedule to reproduce the bug.</p><p>Both CoreDump <ref type="bibr" target="#b30">[32]</ref> and ESD <ref type="bibr" target="#b35">[37]</ref> rely on only the program coredumps to diagnose failures. CoreDump uses a technique called execution indexing to compare the differences between coredumps from failing and normal runs to identify the failing point. ESD uses static analysis and symbolic execution to synthesize both program inputs and schedule to reproduce failures. Using coredumps is promising for diagnosing real-world failures since coredumps are often available after the program crash. However, since there is no program control flow information, the technique may be difficult to reproduce failures that require complex paths and schedules to manifest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We have presented H3, a novel technique that reproduces Heisenbugs by integrating hardware control flow tracing and symbolic constraint solving. With the efficient control flow tracing supported by PT, H3 enables for the first time the ability to efficiently reproduce Heisenbugs in production runs on commercial hardware. We have also presented an effective core-based constraint reduction technique that significantly reduces the size of the symbolic constraints and hence scales H3 to larger programs compared to the state-of-the-art solutions. Our evaluation on both popular benchmarks and real-world applications shows that H3 can effectively reproduce Heisenbugs in production runs with very small overhead, 4.9% on average on PARSEC.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: H3 Overview.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The CLAP constraints for reproducing the PSO error in Figure 2. To save space, we show the readwrite constraints for z only. Those for x and y are similar.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Components of Intel Processor Tracing (PT).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Algorithm 1</head><label>1</label><figDesc>Path profiles generation Input: L:&lt; line, insn &gt; //execute instructions and #line Input: B: &lt;line, block id&gt; //basic blocks of the paths Output: Q: &lt;tid, block id&gt;//path profile of each thread 1: for each tid do //traverse each thread 2: //get the instructions of each thread 3: 񮽙 = {S ⊆ L|∀insn ∈ S.insn, Tid(insn) = tid} 4:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Core-based constraint reduction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: H3 performance analysis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 (</head><label>6</label><figDesc>a) shows the rela- tion between the size of the recorded trace and the ex- ecution time of H3. Figure 6(b) shows the relation be- tween the number of executed branches and the size of the recorded trace. Figure 6(c) shows that relation be- tween the percentage of executed branch instructions and the runtime overhead of H3. The results indicate that the performance of H3 is proportional to the percentage of executed branch instructions in the execution. Recall Column 8 in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><head>Table 1 : Runtime and space overhead of PT on PARSEC.</head><label>1</label><figDesc></figDesc><table>Program 
Native 
PT 
time (s) time (s) OH(%) 
trace 
bodytrack 
0.557 
0.573 
2.9% 
94M 
x264 
1.086 
1.145 
5.4% 
88M 
vips 
1.431 
1.642 
14.7% 
98M 
blackscholes 
1.51 
1.56 
9.9% 
289M 
ferret 
1.699 
1.769 
4.1% 
145M 
swaptions 
2.81 
2.98 
6.0% 
897M 
raytrace 
3.818 
4.036 
5.7% 
102M 
facesim 
5.048 
5.145 
1.9% 
110M 
fluidanimate 
14.8 
15.1 
1.4% 1240M 
freqmine 
15.9 
17.1 
7.5% 2468M 

Avg. 
4.866 
5.105 
4.9% 
553M 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><head>Table 2 : Benchmarks.</head><label>2</label><figDesc></figDesc><table>Program 
LOC #Threads #SV 
#insns 
#branches #branches 
Ratio 
Symb. 
(executed) 
(total) 
(app) 
app/total 
time 
racey 
192 
4 
3 
1,229,632 
78,117 
77,994 
99.8% 
107s 
pfscan 
1026 
3 
13 
1,287 
237 
43 
18.1% 
2.5s 
aget-0.4.1 
942 
4 
30 
3,748 
313 
5 
1.6% 
117s 
pbzip2-0.9.4 1942 
5 
18 
1,844,445 
272,453 
5 
0.0018% 
8.7s 
bbuf 
371 
5 
11 
1,235 
257 
3 
1.2% 
5.5s 
sbuf 
151 
2 
5 
64,993 
11,170 
290 
2.6% 
1.6s 
httpd-2.2.9 
643K 
10 
22 
366,665 
63,653 
12,916 
20.3% 
712s 
httpd-2.0.48 643K 
10 
22 
366,379 
63,809 
13,074 
20.5% 
698s 
httpd-2.0.46 643K 
10 
22 
366,271 
63,794 
12,874 
20.2% 
643s 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><head>Table 3 : Performance comparison between H3 and CLAP.</head><label>3</label><figDesc></figDesc><table>Program 
Native 
Time (s) 
Branch 
Space overhead 
time (s) CLAP (Overhead) H3 (Overhead) Speedup insts% CLAP 
H3 
racey 
0.268 
0.768(186.6%) 
0.288(7.5%) 
65.2% 
6.4% 
96M 
2.68M 
pfscan 
0.094 
0.104(11.0%) 
0.116(23.4%) 
-11.5% 
18.4% 
3.2K 
30K 
aget-0.4.1 
0.139 
0.156 (12.1%) 
0.152(9.4%) 
2.6% 
17.9% 
11K 
41K 
pbzip2-0.9.4 
0.102 
0.134(31.4%) 
0.112(9.8%) 
16.4% 
14.8% 
5.2K 
677K 
bbuf 
0.232 
0.696(200%) 
0.264(13.8%) 
62.1% 
20.1% 
3.9K 
2.7M 
sbuf 
0.216 
0.299(38.5%) 
0.256(18.5%) 
14.4% 
17.2% 
6.6K 
4.5M 
httpd-2.2.9 
0.53 
0.71(34.0%) 
0.57(7.5%) 
19.7% 
17.4% 
7.8M 
10.43M 
httpd-2.0.48 
0.45 
0.59(32.1%) 
0.51(13.3%) 
13.6% 
17.4% 
8.1M 
11.79M 
httpd-2.0.46 
0.42 
0.57(36.2%) 
0.50(19.0%) 
12.3% 
17.4% 
7.2M 
10.62M 
avg. 
0.272 
0.447(64.3%) 
0.307(12.9%) 
31.3% 
16.3% 13.2M 
4.8M 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="true"><head>Table 4 : Results of Heisenbug reproduction. (-) means the solver runs timeout in one hour.</head><label>4</label><figDesc></figDesc><table>Program 
#Var 
CLAP #constraints 
solve time success? 
H3 #constraints 
solve time success? 
#Total 
#RW 
#Total 
#RW(Reduction) 
bbuf 
79 
14264 
13902 
98s 
Y 
10344 
9982(28.2%) 
52s 
Y 
sbuf 
102 
438 
302 
1s 
Y 
344 
208(31.1%) 
1s 
Y 
pfscan 
25 
199 
60 
1s 
Y 
179 
40(33.3%) 
1s 
Y 
pbzip2 
113 
5890 
1270 
2s 
Y 
5460 
840(33.9%) 
1s 
Y 
racey1 
15040 
540602 
540388 
-
N 
50602 
50388(90.7%) 
267s 
Y 
racey2 
30108 
41612000 41607900 
-
N 
201202 
200788(99.5%) 
-
N 
racey3 
67850 
1.3 × 10 8 
1.3 × 10 8 
-
N 
451802 
451188(99.7%) 
-
N 

</table></figure>

			<note place="foot" n="1"> We excluded aget and the httpd benchmarks because the KLEE symbolic execution failed on them.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>We would like to thank our shepherd, Gilles Muller, and the anonymous reviewers for their valuable feedback. This work was supported by NSF award CCF-1552935.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Intel processor trace decoder library</title>
		<ptr target="https://github.com/01org/processor-trace" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<ptr target="https://sites.google.com/site/intelptmicrotutorial" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mozilla</surname></persName>
		</author>
		<ptr target="https://github.com/mozilla/rr" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Parsec</forename><surname>The</surname></persName>
		</author>
		<ptr target="http://parsec.cs.princeton.edu/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<ptr target="http://pages.cs.wisc.edu/~markhill/racey.html" />
		<title level="m">Racey: A stress test for deterministic execution</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">A real-world bug caused by relaxed consistency</title>
		<ptr target="http://stackoverflow.com/questions/16159203" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Odr: Output-deterministic replay for multicore debugging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Altekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGOPS 22Nd Symposium on Operating Systems Principles, SOSP</title>
		<meeting>the ACM SIGOPS 22Nd Symposium on Operating Systems Principles, SOSP</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">architecture manual. Version 9</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<publisher>SPARC International, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Production-run software failure diagnosis via hardware performance counters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Arulraj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS</title>
		<meeting>the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient path profiling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Larus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Annual ACM/IEEE International Symposium on Microarchitecture, MICRO 29</title>
		<meeting>the 29th Annual ACM/IEEE International Symposium on Microarchitecture, MICRO 29</meeting>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Klee: Unassisted and automatic generation of high-coverage tests for complex systems programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dunbar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation</title>
		<meeting>the 8th USENIX Conference on Operating Systems Design and Implementation</meeting>
		<imprint>
			<publisher>OSDI</publisher>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Scalable deterministic replay in a parallel full-system emulator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</title>
		<meeting>the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</meeting>
		<imprint>
			<publisher>PPoPP</publisher>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Z3: An efficient smt solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Construction and Analysis of Systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="337" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Why do computers stop and what can be done about it?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Reliability in Distributed Software and Database Systems</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1986" />
			<biblScope unit="page" from="3" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Rerun: Exploiting episodes for lightweight memory race recording</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Hower</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th Annual International Symposium on Computer Architecture, ISCA</title>
		<meeting>the 35th Annual International Symposium on Computer Architecture, ISCA</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Leap: Lightweight deterministic multi-processor replay of concurrent java programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighteenth ACM SIGSOFT International Symposium on Foundations of Software Engineering, FSE</title>
		<meeting>the Eighteenth ACM SIGSOFT International Symposium on Foundations of Software Engineering, FSE</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Clap: Recording local executions to reproduce concurrency failures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dolby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI</title>
		<meeting>the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Failure sketching: A technique for automated root cause diagnosis of in-production failures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Schubert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles, SOSP</title>
		<meeting>the 25th Symposium on Operating Systems Principles, SOSP</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Chimera: Hybrid program analysis for determinism</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Flinn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>PLDI</publisher>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Offline symbolic analysis to infer total store order</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Said</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2011 IEEE 17th International Symposium on High Performance Computer Architecture</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="357" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Offline symbolic analysis for multiprocessor execution replay</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Said</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42Nd Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 42Nd Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page">44</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Light: Replay via tightly bounded recording</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Tripp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>PLDI</publisher>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Concurrency debugging with differential schedule projections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Machado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Quinta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Rodrigues</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Softw. Eng. Methodol</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2016-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Delorean: Recording and deterministically replaying sharedmemory multiprocessor execution ef?ciently</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Montesinos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Torrellas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th Annual International Symposium on Computer Architecture, ISCA</title>
		<meeting>the 35th Annual International Symposium on Computer Architecture, ISCA</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Bugnet: Continuously recording program execution for deterministic replay debugging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32Nd Annual International Symposium on Computer Architecture, ISCA</title>
		<meeting>the 32Nd Annual International Symposium on Computer Architecture, ISCA</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Pres: Probabilistic replay with execution sketching on multiprocessors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGOPS 22Nd Symposium on Operating Systems Principles, SOSP</title>
		<meeting>the ACM SIGOPS 22Nd Symposium on Operating Systems Principles, SOSP</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Coreracer: A practical memory race recorder for multicore x86 tso processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-R</forename><surname>Adl-Tabatabai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gottschlich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 44th Annual IEEE/ACM International Symposium on Microarchitecture, MICRO-44</title>
		<meeting>the 44th Annual IEEE/ACM International Symposium on Microarchitecture, MICRO-44</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Locksmith: Context-sensitive correlation analysis for race detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Pratikakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;06</title>
		<meeting>the 27th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;06</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A programmable hardware path profiler</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Vaswani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Thazhuthaveetil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">N</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Code Generation and Optimization, CGO</title>
		<meeting>the International Symposium on Code Generation and Optimization, CGO</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Doubleplay: Parallelizing sequential logging and replay</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Veeraraghavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wester</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ouyang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Flinn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS</title>
		<meeting>the Sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Analyzing multicore dumps to facilitate concurrency bug reproduction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weeratunge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jagannathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifteenth Edition of ASPLOS on Architectural Support for Programming Languages and Operating Systems, ASPLOS</title>
		<meeting>the Fifteenth Edition of ASPLOS on Architectural Support for Programming Languages and Operating Systems, ASPLOS</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A&quot; flight data recorder&quot; for enabling full-system multiprocessor deterministic replay</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Architecture, 2003. Proceedings. 30th Annual International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="122" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Order: Object centric deterministic replay for java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Zang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 USENIX Conference on USENIX Annual Technical Conference, USENIX-ATC</title>
		<meeting>the 2011 USENIX Conference on USENIX Annual Technical Conference, USENIX-ATC</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Maple: A coverage-driven testing tool for multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pokam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Conference on Object Oriented Programming, Systems, Languages, and Applications</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="485" to="502" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Recbulc: Reproducing concurrency bugs using local clocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-C</forename><surname>Yew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Guan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th International Conference on Software Engineering</title>
		<meeting>the 37th International Conference on Software Engineering</meeting>
		<imprint>
			<publisher>ICSE</publisher>
			<date type="published" when="2015" />
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Execution synthesis: A technique for automated software debugging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Zamfir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th European Conference on Computer Systems, EuroSys</title>
		<meeting>the 5th European Conference on Computer Systems, EuroSys</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Stride: Searchbased deterministic replay in polynomial time via bounded linkage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th International Conference on Software Engineering, ICSE</title>
		<meeting>the 34th International Conference on Software Engineering, ICSE</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
