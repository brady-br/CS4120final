<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:06+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automating the Development of Chosen Ciphertext Attacks Automating the Development of Chosen Ciphertext Attacks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabrielle</forename><surname>Beck</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit2">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit3">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit4">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maximilian</forename><surname>Zinkus</surname></persName>
							<email>zinkus@cs.jhu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit2">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit3">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit4">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Green</surname></persName>
							<email>mgreen@cs.jhu.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit2">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit3">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit4">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabrielle</forename><surname>Beck</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit2">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit3">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit4">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maximilian</forename><surname>Zinkus</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit2">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit3">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit4">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Green</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit2">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit3">Johns Hopkins University</orgName>
								<orgName type="institution" key="instit4">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Automating the Development of Chosen Ciphertext Attacks Automating the Development of Chosen Ciphertext Attacks</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. https://www.usenix.org/conference/usenixsecurity20/presentation/beck</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>In this work we investigate the problem of automating the development of adaptive chosen ciphertext attacks on systems that contain vulnerable format oracles. Unlike previous attempts, which simply automate the execution of known attacks, we consider a more challenging problem: to programmatically derive a novel attack strategy, given only a machine-readable description of the plaintext verification function and the malleability characteristics of the encryption scheme. We present a new set of algorithms that use SAT and SMT solvers to reason deeply over the design of the system, producing an automated attack strategy that can entirely decrypt protected messages. Developing our algorithms required us to adapt techniques from a diverse range of research fields, as well as to explore and develop new ones. We implement our algorithms using existing theory solvers. The result is a practical tool called Delphinium that succeeds against real-world and contrived format oracles. To our knowledge , this is the first work to automatically derive such complex chosen ciphertext attacks.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The past decades have seen enormous improvement in our understanding of cryptographic protocol design. Despite these advances, vulnerable protocols remain widely deployed. In many cases this is a result of continued support for legacy protocols and ciphersuites, such as TLS's CBC-mode ciphers <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b63">64]</ref>, export-grade encryption <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b18">19]</ref>, and legacy email encryption <ref type="bibr" target="#b58">[59]</ref>. However, support for legacy protocols does not account for the presence of vulnerabilities in more recent protocols and systems <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b71">72,</ref><ref type="bibr" target="#b73">74]</ref>. * These authors contributed equally to the <ref type="bibr">work.</ref> In this work we consider a specific class of vulnerability: the continued use of unauthenticated symmetric encryption in many cryptographic systems. While the research community has long noted the threat of adaptive-chosen ciphertext attacks on malleable encryption schemes <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b55">56]</ref>, these concerns gained practical salience with the discovery of padding oracle attacks on a number of standard encryption protocols <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b39">40,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b51">52,</ref><ref type="bibr" target="#b72">73]</ref>. Despite repeated warnings to industry, variants of these attacks continue to plague modern systems, including TLS 1.2's CBC-mode ciphersuite <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b47">48]</ref> and hardware key management tokens <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b12">13]</ref>. A generalized variant, the format oracle attack can be constructed when a decryption oracle leaks the result of applying some (arbitrarily complex) formatchecking predicate F to a decrypted plaintext. Format oracles appear even in recent standards such as XML encryption <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b44">45]</ref>, Apple's iMessage <ref type="bibr" target="#b35">[36]</ref> and modern OpenPGP implementations <ref type="bibr" target="#b46">[47,</ref><ref type="bibr" target="#b58">59]</ref>. These attacks likely represent the "tip of the iceberg": many vulnerable systems may remain undetected, due to the difficulty of exploiting non-standard format oracles.</p><p>From a constructive viewpoint, format oracle vulnerabilities seem easy to mitigate: simply mandate that protocols use authenticated encryption. Unfortunately, even this advice may be insufficient: common authenticated encryption schemes can become insecure due to implementation flaws such as nonce re-use <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b45">46]</ref>. Setting aside implementation failures, the continued deployment of unauthenticated encryption raises an obvious question: why do these vulnerabilities continue to appear in modern protocols? The answer highlights a disconnect between the theory and the practice of applied cryptography. In many cases, a vulnerable protocol is not obviously an exploitable protocol. This is particularly true for non-standard format oracles which require en- <ref type="figure">Figure 1</ref>: Output of a format oracle attack that our algorithms developed against a bitwise padding check oracle F bitpad (see §5.2 for a full description). The original ciphertext is a valid 128-bit (random) padded message encrypted using a stream cipher. Each row of the bitmap represents a malleation string that was exclusive-ORed with the ciphertext prior to making a decryption query.</p><p>tirely new exploit strategies. As a concrete example, the authors of <ref type="bibr" target="#b35">[36]</ref> report that Apple did not repair a complex gzip compression format oracle in the iMessage protocol when the lack of authentication was pointed out; but did mitigate the flaw when a concrete exploit was demonstrated. Similar flaws in OpenPGP clients <ref type="bibr" target="#b35">[36,</ref><ref type="bibr" target="#b58">59]</ref> and PDF encryption <ref type="bibr" target="#b54">[55]</ref> were addressed only when researchers developed proof-of-concept exploits. The unfortunate aspect of this strategy is that cryptographers' time is limited, which leads protocol designers to discount the exploitability of real cryptographic flaws.</p><p>Removing the human element. In this work we investigate the feasibility of automating the design and development of adaptive chosen ciphertext attacks on symmetric encryption schemes. We stress that our goal is not simply to automate the execution of known attacks, as in previous works <ref type="bibr" target="#b44">[45]</ref>. Instead, we seek to develop a methodology and a set of tools to (1) evaluate if a system is vulnerable to practical exploitation, and (2) programmatically derive a novel exploit strategy, given only a description of the target. This removes the expensive human element from attack development.</p><p>To emphasize the ambitious nature of our problem, we summarize our motivating research question as follows:</p><p>Given a machine-readable description of a format checking function F along with a description of the encryption scheme's malleation properties, can we programatically derive a chosen-ciphertext attack that allows us to efficiently decrypt arbitrary ciphertexts?</p><p>Our primary requirement is that the software responsible for developing this attack should require no further assistance from human beings. Moreover, the developed attack must be efficient: ideally it should not require substantially more work (as measured by number of oracle queries and wall-clock execution time) than the equivalent attack developed through manual human optimization.</p><p>To our knowledge, this work represents the first attempt to automate the discovery of novel adaptive chosen ciphertext attacks against symmetric format oracles. While our techniques are designed to be general, in practice they are unlikely to succeed against every possible format checking function. Instead, in this work we initiate a broader investigation by exploring the limits of our approach against various real-world and contrived format checking functions. Beyond presenting our techniques, our practical contribution of this work is a toolset that we name Delphinium, which produces highly-efficient attacks across several such functions.</p><p>Relationship to previous automated attack work. Previous work <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b57">58</ref>] has looked at automatic discovery and exploitation of side channel attacks. In this setting, a program combines a fixed secret input with many "low" inputs that are (sometimes adaptively) chosen by an attacker, and produces a signal, e.g., modeling a timing result. This setting can be viewed as a special case of our general model <ref type="bibr">(and vice versa)</ref>. Like our techniques, several of these works employ SAT solvers and model counting techniques. However, beyond these similarities, there are fundamental differences that manifest in our results: (1) in this work we explore a new approach based on approximate model counting, and (2) as a result of this approach, our results operate over much larger secret domains than the cited works. To illustrate the differences, our experimental results succeed on secret (message) domains of several hundred bits in length, with malleation strings ("low inputs") drawn from similarly-sized domains. By contrast, the cited works operate over smaller secret domains that rarely even reach a size of 2 24 . Moreover, our format functions are relatively complex. It is an open question to determine whether the experimental results in the cited works can be scaled using our techniques.</p><p>Our contributions. In this work we make the following contributions:</p><p>• We propose new, and fully automated algorithms for developing format oracle attacks on symmetric encryption (and hybrid encryption) schemes. Our algorithms are designed to work with arbitrary format checking functions, using a machine-readable description of the function and the scheme's malleation features to develop the attack strategy.</p><p>• We design and implement novel attack-development techniques that use approximate model counting techniques to achieve significantly greater efficiency than previous works. These techniques may be of independent interest.</p><p>• We show how to implement our technique practically with existing tools such as SAT and SMT solvers; and propose a number of efficiency optimizations designed to improve performance for specific encryption schemes and attack conditions.</p><p>• We develop a working implementation of our techniques using "off-the-shelf" SAT/SMT packages, and provide the resulting software package (which we call Delphinium), an artifact accompanying this submission, as an open source tool for use and further development by the research community.</p><p>• We validate our tool experimentally, deriving several attacks using different format-checking functions. These experiments represent, to our knowledge, the first evidence of a completely functioning end-toend machine-developed format oracle attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Intuition</head><p>Implementing a basic format oracle attack. In a typical format oracle attack, the attacker has obtained some target ciphertext C * = Encrypt K (M * ) where K and M * are unknown. She has access to a decryption oracle that, on input any chosen ciphertext C, returns F(Decrypt K (C)) ∈ {0, 1} for some known predicate F. The attacker may have various goals, including plaintext recovery and forgery of new ciphertexts. Here we will focus on the former goal.</p><p>Describing malleability. Our attacks exploit the malleability characteristics of symmetric encryption schemes. Because the encryption schemes themselves can be complex, we do not want our algorithms to reason over the encryption mechanism itself. Instead, for a given encryption scheme Π, we require the user to develop two efficientlycomputable functions that define the malleability properties of the scheme. The function Maul Π ciph (C, S) → C takes as input a valid ciphertext and some opaque malleation instruction string S (henceforth "malleation string"), and produces a new, mauled ciphertext C . The function Maul Π plain (M, S) → M computes the equivalent malleation over some plaintext, producing a plaintext (or, in some cases, a set of possible plaintexts 1 ). The essential property we require from these functions is that the plaintext malleation function should "predict" the effects of encrypting a plaintext M, mauling the resulting ciphertext, then subsequently decrypting the result. For some typical encryption schemes, these functions can be simple: for example, a simple stream cipher can be realized by defining both functions to be bitwise exclusive-OR. However, malleation functions may also implement features such as truncation or more sophisticated editing, which could imply a complex and structured malleation string.</p><p>Building block: theory solvers. Our techniques make use of efficient theory solvers, such as SAT and Satisfiability Modulo Theories (SMT) <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b48">49]</ref>. SAT solvers apply a variety of tactics to identify or rule out a satisfying assignment to a boolean constraint formula, while SMT adds a broader range of theories and tactics such as integer arithmetic and string logic. While in principle our techniques can be extended to work with either system, in practice we will focus our techniques to use quantifier-free operations over bitvectors (a theory that easily reduces to SAT). In later sections, we will show how to realize these techniques efficiently using concrete SAT and SMT packages.</p><p>Anatomy of our attack algorithm. The essential idea in our approach is to model each phase of a chosen ciphertext attack as a constraint satisfaction problem. At the highest level, we begin by devising an initial constraint formula that defines the known constraints on (and hence, implicitly, a set of candidates for) the unknown plaintext M * . At each phase of the attack, we will use our current knowledge of these constraints to derive an experiment that, when executed against the real decryption oracle, allows us to "rule out" some non-zero number of plaintext candidates. Given the result of a concrete experiment, we can then update our constraint formula using the new information, and continue the attack procedure until no further candidates can be eliminated.</p><p>In the section that follows, we use M 0 , M 1 to represent the partition of messages induced by a malleation string. M 0 and M 1 represent concrete plaintext message assignments chosen by the solver, members of the respective partitions.</p><p>The process of deriving the malleation string represents the core of our technical work. It requires our algorithms to reason deeply over both the plaintext malleation function and the format checking function in combination. To realize this, we rely heavily on theory solvers, together with some novel optimization techniques.</p><p>Attack intuition. We now explain the full attack in greater detail. To provide a clear exposition, we will begin this discussion by discussing a simplified and inefficient precursor algorithm that we will later optimize to produce our main result. Our discussion below will make a significant simplifying assumption that we will later remove: namely, that Maul plain will output exactly one plaintext for any given input. This assumption is compatible with common encryption schemes such as stream ciphers, but will not be valid for other schemes where malleation can produce key-dependent effects following decryption.</p><p>We now describe the basic steps of our first attack algorithm.</p><p>Step 0: Initialization. At the beginning of the attack, our attack algorithm receives as input a target ciphertext C * , as well as a machine-readable description of the functions F and Maul plain . We require that these descriptions be provided in the form of a constraint formula that a theory solver can reason over. To initialize the attack procedure, the user may also provide an initial constraint predicate G 0 : {0, 1} n → {0, 1} that expresses all known constraints over the value of M * . 2 (If we have no a priori knowledge about the distribution of M * , we can set this initial formula G 0 to be trivial).</p><p>Beginning with i = 1, the attack now proceeds to iterate over the following two steps:</p><p>Step 1: Identify an experiment. Let G i−1 be the current set of known constraints on M * . In this first step, we employ the solver to identify a malleation instruction string S as well as a pair of distinct plaintexts M 0 , M 1 that each satisfy the constraints of G i−1 . Our goal is to identify an assignment for (S, M 0 , M 1 ) that induces the following specific properties on M 0 , M 1 : namely, that each message in the pair, when mauled using S and then evaluated using the format checking function, results in a distinct output from F. Expressed more concretely, we require the solver to identify an assignment that satisfies the following constraint formula:</p><formula xml:id="formula_0">G i−1 (M 0 ) = G i−1 (M 1 ) = 1 ∧ (1) ∀b ∈ {0, 1} : F(Maul plain (M b , S)) = b</formula><p>If the solver is unable to derive a satisfying assignment to this formula, we conclude the attack and proceed to <ref type="bibr">Step (3)</ref>. Otherwise we extract a concrete satisfying assignment for S, assign this value to S, and proceed to the next step.</p><p>Step 2: Query the oracle; update the constraints. Given a concrete malleation string S, we now apply the ciphertext malleation function to compute an experiment ciphertext C ← Maul ciph (C * , S), and submit C to the decryption oracle. When the oracle produces a concrete result r ∈ {0, 1}, we compute an updated constraint formula G i such that for each input M, it holds that:</p><formula xml:id="formula_1">G i (M) ← (G i−1 (M) ∧ F(Maul plain (M, S)) = r)</formula><p>If possible, we can now ask the solver to simplify the formula G i by eliminating redundant constraints in the underlying representation. We now set i ← i + 1 and return to Step (1).</p><p>Step 3: Attack completion. The attack concludes when the solver is unable to identify a satisfying assignment in Step (1). In the ideal case, this occurs because the constraint system G i−1 admits only one possible candidate plaintext, M * : when this happens, we can employ the solver to directly recover M * and complete the attack. However, the solver may also fail to find an assignment because no further productive experiment can be generated, or simply because finding a solution proves computationally intractable. When the solver conclusively rules out a solution at iteration i = 1 (i.e., prior to issuing any decryption queries) this can be taken as an indication that a viable attack is not practical using our techniques. Indeed, this feature of our work can be used to rule out the exploitability of certain systems, even without access to a decryption oracle. In other cases, the format oracle may admit only partial recovery of M * . If this occurs, we conclude the attack by applying the solver to the final constraint formula G i−1 to extract a human-readable description of the remaining candidate space (e.g., the bits of M * we are able to uniquely recover).</p><p>Remark on efficiency. A key feature of the attack described above is that it is guaranteed to make progress at each round in which the solver is able to find a satisfying assignment to Equation (1). This is fundamental to the constraint system we construct: our approach forces the solver to ensure that each malleation string S implicitly partitions the candidate message set into a pair (M 0 , M 1 ), such that malleation of messages in either subset by S will produce distinct outputs from the format checking function F. As a consequence of this, for any possible result from the real-world decryption oracle, the updated   <ref type="figure" target="#fig_2">Figure 2</ref>: Left: illustration of a plaintext candidate space defined by G i−1 , highlighting the two subsets M 0 , M 1 induced by a specific malleation string S. Right: the candidate space defined by G i , in which many candidates have been eliminated following an oracle response b = 1. constraint formula G i must eliminate at least one plaintext candidate that satisfied the previous constraints G i−1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>y m t Z 3 7 s X x h W A = " &gt; A A A B 6 n i c b V D L S g N B E O z 1 G e M r 6 t H L Y B D E Q 9 i N g h 6 D X r w I E c 0 D k j X M T i b J k N n Z Z a Z X C E s + w Y s H R b z 6 R d 7 8 G y f J H j S x o K G o 6 q a 7 K 4 i l M O i 6 3 8 7 S 8 s r q 2 n p u I 7 + 5 t b 2 z W 9 j b r 5 s o 0 Y z X W C Q j 3 Q y o 4 V I o X k O B k j d j z W k Y S N 4 I h t c T v / H E t R G R e s B R z P 2 Q 9 p X o C U b R S v e 3 j 6 e d Q t E t u V O Q R e J l p A g Z q p 3 C V 7 s b s S T k C p m k x r Q 8 N 0 Y / p R o F k 3 y c b y e G x 5 Q N a Z + 3 L F U 0 5 M Z P p 6 e O y b F V u q Q X a V s K y V T 9 P Z H S 0 J h R G N j O k O L A z H s T 8 T + v l W D v 0 k + F i h P k i s 0 W 9 R J J M C K T v 0 l X a M 5 Q j i y h T A t 7 K 2 E D q i l D m 0 7 e h u D N v 7 x I 6 u W S d 1 Y q 3 5 0 X K 1 d Z H D k 4 h C M 4 A Q 8 u o A I 3 U I U a M O j D M 7 z C m y O d F + f d + Z i 1 L j n Z z A H 8 g f P 5 A 7 9 M j X E = &lt; / l a t e x i t &gt;</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>t e x i t s h a 1 _ b a s e 6 4 = " M 1 B M g W 9 y C 0 s f o E j w 9 9 b + g X K V w g U = " &gt; A A A B 8 X i c b V B N S 8 N A E J 3 4 W e t X 1 a O X x S J 4 K k k V 9 F j 0 4 k W o Y D + w D W W z n b R L N 5 u w u x F K 6 L / w 4 k E R r / 4 b b / 4 b t 2 0 O 2 v p g 4 P H e D D P z g k R w b V z 3 2 1 l Z X V v f 2 C x s F b d 3 d v f 2 S w e H T R 2 n i m G D x S J W 7 Y B q F F x i w 3 A j s J 0 o p F E g s B W M b q Z + 6 w m V 5 r F 8 M O M E / Y g O J A 8 5 o 8 Z K j 1 m X U U H u J j 2 3 V y q 7 F X c G s k y 8 n J Q h R 7 1 X + u r 2 Y 5 Z G K A 0 T V O u O 5 y b G z 6 g y n A m c F L u p x o S y E R 1 g x 1 J J I 9 R + N r t 4 Q k 6 t 0 i d h r G x J Q 2 b q 7 4 m M R l q P o 8 B 2 R t Q M 9 a I 3 F f / z O q k J r / y M y y Q 1 K N l 8 U Z g K Y m I y f Z / 0 u U J m x N g S y h S 3 t x I 2 p I o y Y 0 M q 2 h C 8 x Z e X S b N a 8 c 4 r 1 f u L c u 0 6 j 6 M A x 3 A C Z + D B J d T g F u r Q A A Y S n u E V 3 h z t v D j v z s e 8 d c X J Z 4 7 g D 5 z P H 9 1 X k G I = &lt; / l a t e x i t &gt; M ⇤ &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " 5 z R 0 F b p p n 5 r A n b 6 y m t Z 3 7 s X x h W A = " &gt; A A A B 6 n i c b V D L S g N B E O z 1 G e M r 6 t H L Y B D E Q 9 i N g h 6 D X r w I E c 0 D k j X M T i b J k N n Z Z a Z X C E s + w Y s H R b z 6 R d 7 8 G y f J H j S x o K G o 6 q a 7 K 4 i l M O i 6 3 8 7 S 8 s r q 2 n p u I 7 + 5 t b 2 z W 9 j b r 5 s o 0 Y z X W C Q j 3 Q y o 4 V I o X k O B k j d j z W k Y S N 4 I h t c T v / H E t R G R e s B R z P 2 Q 9 p X o C U b R S v e 3 j 6 e d Q t E t u V O Q R e J l p A g Z q p 3 C V 7 s b s S T k C p m k x r Q 8 N 0 Y / p R o F k 3 y c b y e G x 5 Q N a Z + 3 L F U 0 5 M Z P p 6 e O y b F V u q Q X a V s K y V T 9 P Z H S 0 J h R G N j O k O L A z H s T 8 T + v l W D v 0 k + F i h P k i s 0 W 9 R J J M C K T v 0 l X a M 5 Q j i y h T A t 7 K 2 E D q i l D m 0 7 e h u D N v 7 x I 6 u W S d 1 Y q 3 5 0 X K 1 d Z H D k 4 h C M 4 A Q 8 u o A I 3 U I U a M O j D M 7 z C m y O d F + f d + Z i 1 L j n Z z A H 8 g f P 5 A 7 9 M j X E = &lt; / l a t e x i t &gt; G i񮽙1</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>&lt; l a t e x i t s h a 1 _ b a s e 6 4 = " S 1 j 5 w + N f i W T d P k 8 s k S f h X h x r r U Q = " &gt; A A A B 7 n i c b V B N S 8 N A E J 3 4 W e t X 1 a O X x S J 4 s S R V 0 G P R g x 4 r 2 A 9 o Q 9 l s N + 3 S z S b s T o Q S + i O 8 e F D E q 7 / H m / / G b Z u D t j 4 Y e L w 3 w 8 y 8 I J H C o O t + O y u r a + s b m 4 W t 4 v b O 7 t 5 + 6 e C w a e J U M 9 5 g s Y x 1 O 6 C G S 6 F 4 A w V K 3 k 4 0 p 1 E g e S s Y 3 U 7 9 1 h P X R s T q E c c J 9 y M 6 U C I U j K K V W n e 9 T J x 7 k 1 6 p 7 F b c G c g y 8 X J S h h z 1 X u m r 2 4 9 Z G n G F T F J j O p 6 b o J 9 R j Y J J P i l 2 U 8 M T y k Z 0 w D u W K h p x 4 2 e z c y f k 1 C p 9 E s b a l k I y U 3 9 P Z D Q y Z h w F t j O i O D S L 3 l T 8 z + u k G F 7 7 m V B J i l y x + a I w l Q R j M v 2 d 9 I X m D O X Y E s q 0 s L c S N q S a M r Q J F W 0 I 3 u L L y 6 R Z r X g X l e r D Z b l 2 k 8 d R g G M 4 g T P w 4 A p q c A 9 1 a A C D E T z D K 7 w 5 i f P i v D s f 8 9 Y V J 5 8 5 g j 9 w P n 8 A t 6 S P K Q = = &lt; / l a t e x i t &gt; G i &lt; l a t e x i t s h a 1 _ b a s e 6 4 = " O B e H G U b h g c M P k 9 H 7 M r Z d 2 p e z A 6 s = " &gt; A A A B 7 H i c b V B N S 8 N A E J 3 U r 1 q / q h 6 9 L B b B U 0 m q o M e i B z 1 W M G 2 h D W W z n b Z L N 5 u w u x F K 6 G / w 4 k E R r / 4 g b / 4 b t 2 0 O 2 v p g 4 P H e D D P z w k R w b V z 3 2 y m s r W 9 s b h W 3 S z u 7 e / s H 5 c O j p o 5 T x d B n s Y h V O 6 Q a B Z f o G 2 4 E t h O F N A o F t s L x 7 c x v P a H S P J a P Z p J g E N G h 5 A P O q L G S f 9 f L + L R X r r h V d w 6 y S r y c V C B H o 1 f + 6 v Z j l k Y o D R N U 6 4 7 n J i b I q D K c C Z y W u q n G h L I x H W L H U k k j 1 E E 2 P 3 Z K z q z S J 4 N Y 2 Z K G z N X f E x m N t J 5 E o e 2 M q B n p Z W 8 m / u d 1 U j O 4 D j I u k 9 S g Z I t F g 1 Q Q E 5 P Z 5 6 T P F T I j J p Z Q p r i 9 l b A R V Z Q Z m 0 / J h u A t v 7 x K m r W q d 1 G t P V x W 6 j d 5 H E U 4 g V M 4 B w + u o A 7 3 0 A A f G H B 4 h l d 4 c 6 T z 4 r w 7 H 4 v W g p P P H M M f O J 8 / 2 6 S O t w = = &lt; / l a t e x i t &gt;</head><p>While this property ensures progress, it does not imply that the resulting attack will be efficient. In some cases, the addition of a new constraint will fortuitously rule out a large number of candidate plaintexts. In other cases, it might only eliminate a single candidate. As a result, there exist worst-case attack scenarios where the algorithm requires as many queries as there are candidates for M * , making the approach completely unworkable for practical message sizes. Addressing this efficiency problem requires us to extend our approach.</p><p>Improving query profitability. We can define the profitability ψ(G i−1 , G i ) of an experimental query by the number of plaintext candidates that are "ruled out" once an experiment has been executed and the constraint formula updated. In other words, this value is defined as the number of plaintext candidates that satisfy G i−1 but do not satisfy G i . The main limitation of our first attack strategy is that it does not seek to optimize each experiment to maximize query profitability.</p><p>To address this concern, let us consider a more general description of our attack strategy, which we illustrate in <ref type="figure" target="#fig_2">Figure 2</ref>. At the i th iteration, we wish to identify a malleation string S that defines two disjoint subsets M 0 , M 1 of the current candidate plaintext space, such that for any concrete oracle result r ∈ {0, 1} and ∀M ∈ M r it holds that F(Maul plain (M, S)) = r. In this description, any concrete decryption oracle result must "rule out" (at a minimum) every plaintext contained in the subset M 1−r . This sets ψ(G i−1 , G i ) equal to the cardinality of M 1−r .</p><p>To increase the profitability of a given query, it is therefore necessary to maximize the size of M 1−r . Of course, since we do not know the value r prior to issuing a decryption oracle query, the obvious strategy is to find S such that both M 0 , M 1 are as large as possible. Put slightly differently, we wish to find an experiment S that maximizes the cardinality of the smaller subset in the pair. The result of this optimization is a greedy algorithm that will seek to eliminate the largest number of candidates with each query.</p><p>Technical challenge: model count optimization. While our new formulation is conceptually simple, actually realizing it involves overcoming serious limitations in current theory solvers. This is due to the fact that, while several production solvers provide optimization capabilities <ref type="bibr" target="#b48">[49]</ref>, these heuristics optimize for the value of specific variables. Our requirement is subtly different: we wish to solve for a candidate S that maximizes the number of satisfying solutions for the variables M 0 , M 1 in Equation (1). <ref type="bibr" target="#b2">3</ref> Unfortunately, this problem is both theoretically and practically challenging. Indeed, merely counting the number of satisfying assignments to a constraint formula is known to be asymptotically harder than SAT <ref type="bibr" target="#b68">[69,</ref><ref type="bibr" target="#b69">70]</ref>, and practical counting algorithms solutions <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b19">20]</ref> tend to perform poorly when the combinatorial space is large and the satisfying assignments are sparsely distributed throughout the space, a condition that is likely in our setting. The specific optimization problem our techniques require proves to be even harder. Indeed, only recently was such a problem formalized, under the name Max#SAT <ref type="bibr" target="#b34">[35]</ref>.</p><p>Approximating Max#SAT. While an exact solution to Max#SAT is NP PP -complete <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b68">69]</ref>, several works have explored approximate solutions to this and related counting problems <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b64">65]</ref>. One powerful class of approximate counting techniques, inspired by the theoretical work of Valiant and Vazirani <ref type="bibr" target="#b70">[71]</ref> and Stockmeyer <ref type="bibr" target="#b66">[67]</ref>, uses a SAT oracle as follows: given a constraint formula F over some bitvector T , add to F a series of s random parity constraints, each computed over the bits of T . For j = 1 to s, the j th parity constraint can be viewed as requiring that H j (T ) = 1 where H j : {0, 1} |T | → {0, 1} is a universal hash function. Intuitively, each additional constraint reduces the number of satisfying assignments approximately by half, independently of the underlying distribution of valid solutions. The implication is as follows: if a satisfying assigment to the enhanced formula exists, we should be convinced (probabilistically) that the original formula is likely to possess on the order of 2 s satisfying assignments. Subsequently, researchers in the model counting community showed that with some refinement, these approximate counting strategies can be used to approximate <ref type="bibr">Max#SAT [35]</ref>, although with an efficiency that is substantially below what we require for an efficient attack.</p><p>To apply this technique efficiently to our attack, we develop a custom count-optimization procedure, and apply it to the attack strategy given in the previous section. At the start of each iteration, we begin by conjecturing a candidate set size 2 s for some non-negative integer s, and then we query the solver for a solution to (S, M 0 , M 1 ) in which approximately 2 s solutions can be found for each of the abstract bitvectors M 0 , M 1 . This involves modifying the equation of Step <ref type="formula">(1)</ref> by adding s random parity constraints to each of the abstract representations of M 0 and M 1 . We now repeatedly query the solver on variants of this query, with increasing (resp. decreasing) values of s, until we have identified the maximum value of s that results in a satisfying assignment. <ref type="bibr" target="#b3">4</ref> For a sufficiently high value of s, this approach effectively eliminates many "unprofitable" malleation string candidates and thus significantly improves the efficiency of the attack.</p><p>The main weakness of this approach stems from the probabilistic nature of the approximation algorithm. Even when 2 s satisfying assignments exist for M 0 , M 1 , the solver may deem the extended formula unsatisfiable with relatively high probability. In our approach, this falsenegative will cause the algorithm to reduce the size of s, potentially resulting in the selection of a less-profitable experiment S. Following Gomes et al. <ref type="bibr" target="#b36">[37]</ref>, we are able to substantially improve our certainty by conducting t trials within each query, accepting iff at least ( 1 2 + δ)t trials are satisfied, where δ is an adjustable tolerance parameter.</p><p>Putting it all together. The presentation above is intended to provide the reader with a simplified description of our techniques. However, this discussion does not convey most challenging aspect of our work: namely, the difficulty of implementing our techniques and making them practical, particularly within the limitations of existing theory solvers. Achieving the experimental results we present in this work represents the result of months of software engineering effort and manual algorithm optimization. We discuss these challenges more deeply in §4. Using our techniques we were able to re-discover both well known and entirely novel chosen ciphertext attacks, all at a query efficiency nearly identical to the (optimal in expectation) human-implemented attacks. Our experiments not only validate the techniques we describe in this work, but they also illustrate several possible avenues for further optimization, both in our algorithms and in the underlying SMT/SAT solver packages. Our hope is that these results will inspire further advances in the theory solving community.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Encryption Schemes and Malleability</head><p>Our attacks operate assume that the target system is using a malleable symmetric encryption scheme. We now provide definitions for these terms.</p><p>Definition 1 (Symmetric encryption) A symmetric encryption scheme Π is a tuple of algorithms (KeyGen, Encrypt, Decrypt) where KeyGen(1 λ ) generates a key, the probabilistic algorithm Encrypt K (M) encrypts a plaintext M under key K to produce a ciphertext C, and the deterministic algorithm Decrypt K (C) decrypts C to produce a plaintext or the distinguished error symbol ⊥. We use M to denote the set of valid plaintexts accepted by a scheme, and C to denote the set of valid ciphertexts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Malleation Functions</head><p>The description of malleation functions is given in the form of two functions. The first takes as input a ciphertext along with an opaque data structure that we refer to as a malleation instruction string, and outputs a mauled ciphertext. The second function performs the analogous function on a plaintext. We require that the following intuitive relationship hold between these functions: given a plaintext M and an instruction string, the plaintext malleation function should "predict" the effect of mauling (and subsequently decrypting) a ciphertext that encrypts M. setˆMsetˆ setˆM ⊆ M ∪ {⊥} of possible plaintexts (augmented with the decryption error symbol ⊥). The structure of the malleation string is entirely defined by these functions; since our attack algorithms will reason over the functions themselves, we treat S itself as an opaque value.</p><p>We say that (Maul Π ciph , Maul Π plain ) describes the malleability features of Π if malleation of a ciphertext always induces the expected effect on a plaintext following encryption, malleation and decryption. More formally, ∀K ∈ KeyGen(1 λ ), ∀C ∈ C, ∀S ∈ {0, 1} * the following relation must hold whenever Maul Π ciph (C, S) = ⊥:</p><formula xml:id="formula_2">Decrypt K (Maul Π ciph (C, S)) ∈ Maul Π plain (Decrypt K (C), S)</formula><p>In §4.2.1 we discuss a collection of encryption schemes and implementing their associated malleation functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Theory Solvers and Model Counting</head><p>Solvers take as input a system of constraints over a set of variables, and attempt to derive (or rule out the existence of) a satisfying solution. Modern SAT solvers generally rely on two main families of theorem solver: DPLL <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b28">29]</ref> and Stochastic Local Search <ref type="bibr" target="#b38">[39]</ref>. Satisfiability Modulo Theories (SMT) solvers expand the language of SAT to include predicates in first-order logic, enabling the use of several theory solvers ranging from string logic to integer logic. Our prototype implementation uses a quantifier-free bitvector (QFBV) theory solver. In practice, this is implemented using SMT with a SAT solver as a back-end. <ref type="bibr" target="#b4">5</ref> For the purposes of describing our algorithms, we specify a query to the solver by the subroutine SATSolve{(A 1 , . . . , A N ) : G} where A 1 , . . . , A N each represent abstract bitvectors of some defined length, and G is a constraint formula over these variables. The response from this call provides one of three possible results: (1) sat, as well as a concrete satisfying solution (A 1 . . . , A N ), (2) the distinguished response unsat, or (3) the error unknown.</p><p>Model counting and Max#SAT. While SAT determines the existence of a single satisfying assignment, a more general variant of the problem, #SAT, determines the number of satisfying assignments. In the literature this problem is known as model counting <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b62">63,</ref><ref type="bibr" target="#b69">70,</ref><ref type="bibr" target="#b74">75]</ref>.</p><p>In this work we make use of a specific optimization variant of the model count problem, which was formulated as Max#SAT by Fremont et al. <ref type="bibr" target="#b34">[35]</ref>. In a streamlined form, the problem can defined as follows: given a boolean <ref type="bibr" target="#b4">5</ref> In principle our attacks can be extended to other theories, with some additional work that we describe later in this section. formula φ(X,Y ) over abstract bitvectors X and Y , find a concrete assignment to X that maximizes the number of possible satisfying assignments to Y . <ref type="bibr" target="#b5">6</ref> We will make use of this abstraction in our attacks, with realizations discussed in §3.2. Specifically, we define our main attack algorithm in terms of a generic Max#SAT oracle that has the following interface:</p><p>Max#SAT(φ, X,Y ) → X</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Format Checking Functions</head><p>Our attacks assume a decryption oracle that, on input a ciphertext C, computes and returns F(Decrypt K (C)). We refer to the function F : M ∪ {⊥} → {0, 1} as a format checking function. Our techniques place two minimum requirements on this function: (1) the function F must be efficiently-computable, and (2) the user must supply a machine-readable implementation of F, expressed as a constraint formula that a theory solver can reason over.</p><p>Function descriptions. Requiring format checking functions to be usable within SAT/SMT solvers raises additional implementation considerations. Refer to the full version of this paper <ref type="bibr" target="#b14">[15]</ref> for discussion of these considerations, and to the artifact accompanying this work for implemented examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Constructions</head><p>In this section we present a high-level description of our main contribution: a set of algorithms for programmatically conducting a format oracle attack. First, we provide pseudocode for our main attack algorithm, which uses a generic Max#SAT oracle as its key ingredient. This first algorithm can be realized approximately using techniques such as the MaxCount algorithm of Fremont et al. <ref type="bibr" target="#b34">[35]</ref>, although this realization will come at a significant cost to practical performance. To reduce this cost and make our attacks practical, we next describe a concrete replacement algorithm that can be used in place of a Max#SAT solver. The combination of these algorithms forms the basis for our tool Delphinium.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Main Algorithm</head><p>Algorithm 1 presents our main attack algorithm, which we name DeriveAttack. This algorithm is parameterized by three subroutines: (1) a subroutine for solving the Max#SAT problem, (2) an implementation of the ciphertext malleation function Maul ciph , and (3) a decryption oracle O dec . The algorithm takes as input a target ciphertext C * , constraint formulae for the functions Maul plain , F, and an (optional) initial constraint system G 0 that defines known constraints on M * .</p><p>This algorithm largely follows the intuition described in §1.1. At each iteration, it derives a concrete malleation string S using the Max#SAT oracle in order to find an assignment that maximizes the number of solutions to the abstract bitvector M 0 M 1 . It then mauls C * using this malleation string, and queries the decryption oracle O dec on the result. It terminates by outputting a (possibly incomplete) description of M * . This final output is determined by a helper subroutine SolveForPlaintext that uses the solver to find a unique solution for M * given a constraint formula, or else to produce a human-readable description of the resulting model. <ref type="bibr" target="#b6">7</ref> Theorem 3.1 Given an exact Max#SAT oracle, Algorithm 1 maximizes in expectation the number of candidate plaintext messages ruled out at each iteration.</p><p>A proof of Theorem 3.1 appears in the full version of this paper <ref type="bibr" target="#b14">[15]</ref>.</p><p>Remarks. Note that a greedy adaptive attack may not be globally optimal. It is hypothetically possible to modify the algorithm, allowing it to reason over multiple oracle queries simultaneously (in fact, Phan et al. discuss such a generalization in their side channel work <ref type="bibr" target="#b57">[58]</ref>). We find that this is computationally infeasible in practice. Finally, note also that our proof assumes an exact Max#SAT oracle. In practice, this will likely be realized with a probably approximately correct instantiation, causing the resulting attack to be a probably approximately greedy attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Realizing the Max#SAT Oracle</head><p>Realizing Algorithm 1 in practice requires that we provide a concrete subroutine that can solve specific instances of Max#SAT. We now address techniques for approximately solving this problem.</p><p>Realization from Fremont et al. Fremont et al. <ref type="bibr" target="#b34">[35]</ref> propose an approximate algorithm called MaxCount that can be used to instantiate our attack algorithms. The MaxCount algorithm is based on repeated application of approximate counting and sampling algorithms <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b24">25]</ref>, which can in turn be realized using a general SAT solver.</p><p>While MaxCount is approximate, it can be tuned to provide a high degree of accuracy that is likely to be effective for our attacks. Unfortunately, the Fremont et al. solution has two significant downsides. First, to achieve the discussed bounds requires parameter selections which induce infeasible queries to the underlying SAT solver. Fremont et al. address this by implementing their algorithm with substantially reduced parameters, for which they demonstrate good empirical performance. However, even the reduced Fremont et al. approach still requires numerous calls to a solver. Even conducting a single approximate count of solutions to the constraint systems in our experiments could take hours to days, and such counts might occur several times in a single execution of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MaxCount.</head><p>A more efficient realization. To improve the efficiency of our implementations, we instead realize a more efficient optimization algorithm we name FastSample. This algorithm can be used in place of the Max#SAT subroutine calls in Algorithm 1. Our algorithm can be viewed as being a subset of the full MaxCount algorithm of Fremont et al.</p><p>The FastSample algorithm operates over a constraint system φ(S, M 0 M 1 ), and returns a concrete value S that (heuristically) maximizes the number of solutions for the bitvectors M 0 , M 1 . It does this by first conjecturing some value s, and sampling a series of 2s low-density parity hash functions of the form H : {0, 1} n → {0, 1} (where n is the maximum length of M 0 or M 1 ). It then modifies the constraint system by adding s such hash function constraints to each of M 0 , M 1 , and asking the solver to find a solution to the modified constraint system. If a solution is found (resp. not found) for a specific s, FastSample adjusts the size of s upwards (resp. downwards) until it has found the maximal value of s that produces a satisfying assignment, or else is unable to find an assignment even at s = 0.</p><p>The goal of this approach is to identify a malleation string S as well as the largest integer s such that at least 2 s solutions can be found for each of M 0 , M 1 . To improve the accuracy of this approach, we employ a technique originally pioneered by <ref type="bibr">Gomes et al. [37]</ref> and modify each SAT query to include multiple trials of this form, such that only a fraction δ+1/2 of the trials must succeed in order for S to be considered valid. The parameters t, δ are adjustable; we evaluate candidate values in §5.</p><p>Unlike Fremont et al. (at least, when implemented at full parameters) our algorithm does not constitute a sound realization of a Max#SAT solver. However, empirically we find that our attacks using FastSample produce query counts that are close to the optimal possible attack.</p><p>More critically, our approach is capable of identifying a candidate malleation string in seconds on the constraint systems we encountered during our experiments.</p><p>Additional algorithms. Our algorithms employ an abstract subroutine AdjustSize that is responsible for updating the conjectured set size s in our optimization loop:</p><formula xml:id="formula_3">(b continue , s , Z ) ← AdjustSize(b success , n, s, Z)</formula><p>The input bit b success indicates whether or not a solution was found for a conjectured size s, while n provides a known upper-bound. The history string Z ∈ {0, 1} * allows the routine to record state between consecutive calls. AdjustSize outputs a bit b continue indicating whether the attack should attempt to find a new solution, as well as an updated set size s . If AdjustSize is called with s = ⊥, then s is set to an initial set size to test, b continue = TRUE, and Z = Z.</p><p>Finally, the subroutine ParityConstraint(n, l) constructs l randomized parity constraints of weight k over a bitvector b = b 1 b 2 . . . b n where k ≤ n denotes the number of bit indices included in a parity constraint (i.e. the parity constraints come from a family of functions H(b) = n i=1 b i · a i where a ∈ {0, 1} n and the hamming weight of a is k).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1: DeriveAttack</head><p>Input: Machine-readable description of F, Maul plain ; target ciphertext C * ; initial constraints G 0 ; Output: M * or a model of the remaining plaintext candidates Procedure:</p><formula xml:id="formula_4">i ← 1; do Define φ(S, M 0 M 1 ) as G i−1 (M 0 ) = 1 ∧ G i−1 (M 1 ) = 1 ∧ F(Maul plain (M 0 , S)) = 0 ∧ F(Maul plain (M 1 , S)) = 1 ; S ← Max#SAT (φ, S, M 0 M 1 ); if S = ⊥ then r ← O dec (Maul ciph (C * , S)); Define G i (M) as G i−1 (M) ∧ (F(Maul plain (M, S)) = r) ; i ← i + 1; while S = ⊥; return SolveForPlaintext(G i );</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2: FastSample</head><p>Input: φ a constraint system over abstract bitvectors S, M 0 M 1 ; n the maximum length of (each of) M 0 , M 1 ; m the maximum length of S; t number of trials; δ fraction of trials that must succeed Output: S ∈ {0, 1} m Procedure: (b continue , s, Z) ← AdjustSize(FALSE, n, ⊥, ε); // define t symbolic copies of the abstract bitvectors M 0 ,M 1 , and a new constraint system φ t</p><formula xml:id="formula_5">{M 1,0 , . . . , M t,0 } ← M 0 ; {M 1,1 , . . . , M t,1 } ← M 1 ; Define φ t (S, {M 1,0 , . . . , M t,0 }, {M 1,1 , . . . , M t,1 }) as φ(S, M 1,0 M 1,1 ) ∧ · · · ∧ φ(S, M t,0 M t,1 ); while b continue do // Construct 2t s-bit parity constraints for i ← 1 to t do H i,0 ← ParityConstraint (n, s); H i,1 ← ParityConstraint (n, s) // Query the solver S ← SATSolve{(S, {M 1,0 , . . . , M t,0 }, {M 1,1 , . . . , M t,1 }) : ∃R 0 ⊆ [1,t] : |R 0 | ≥ (0.5 + δ)t, ∀ j ∈ R 0 : H j,0 (M j,0 ) = 1 ∧ ∃R 1 ⊆ [1,t] : |R 1 | ≥ (0.5 + δ)t, ∀ j ∈ R 1 : H j,1 (M j,1 ) = 1 ∧ φ t (S, {M 1,0 , . . . , M t,0 }, {M 1,1 , . . . , M t,1 })}; if S == unsat then b success = FALSE; (b continue , s, Z) ← AdjustSize(b success , n, s, Z); return S</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Prototype Implementation</head><p>We now describe our prototype implementation, which we call Delphinium. We designed Delphinium as an extensible toolkit that can be used by practitioners to evaluate and exploit real format oracles. sible for executing the core algorithms of the attack, keeping state, and initiating queries to both the decryption oracle and SMT/SAT solver. It takes the target ciphertext C * and a description of the functions F and Maul plain as well as the attack parameters t, δ as input, and outputs the recovered plaintext.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Architecture Overview</head><p>SMT/SAT solver. Our implementation supports multiple SMT solver frameworks (STP <ref type="bibr" target="#b0">[1]</ref> and Z3 <ref type="bibr" target="#b48">[49]</ref>) via a custom compatibility layer that we developed for our tool. To improve performance, the orchestrator may launch multiple parallel instances of this solver.</p><p>In addition to these core components, the system incorporates two user-supplied modules, which can be customized for a specific target:</p><p>Ciphertext malleator. This module provides a working implementation of the malleation function Maul Π ciph . We realize this module as a Python program, but it can be implemented as any executable compatible with the expected interface. <ref type="bibr" target="#b7">8</ref> Target interface (shim). This module is responsible for formatting and transmitting decryption queries to the target system. It is designed as a user-supplied module in recognition of the fact that this portion will need to be customized for specific target systems and communication channels.</p><p>As part of our prototype implementation, we provide working examples for each of these modules, as well as a test harness to evaluate attacks locally.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Implementation Details</head><p>Realizing our algorithms in a practical tool required us to solve a number of challenging engineering problems <ref type="bibr" target="#b7">8</ref> The interface requires input of a ciphertext and a malleation string, with output the mauled ciphertext. and to navigate limitations of existing SAT/SMT solvers.</p><p>Test Harness. For our experiments in §5 we developed a test harness to implement the Ciphertext Malleator and Target Interface shim. This test harness implements the code for mauling and decrypting M * locally using a given malleation string S.</p><p>Selecting SAT and SMT solvers. In the course of this work we evaluated several SMT and SAT solvers optimized for different settings. Seeking the best of a few worlds, we use Z3 for formula manipulation and CryptoMiniSAT as a solving backend, bridged by CNF formula representations. Refer to the full version of this paper <ref type="bibr" target="#b14">[15]</ref> for discussion and challenges of the solvers we evaluated.</p><p>Low-density parity constraints. Our implementation of model counting requires our tool to incorporate 2t sbit distinct parity functions into each solver query. Each parity constraint comprises an average of n 2 exclusiveORs (where n is the maximum length of M * ), resulting in a complexity increase of tens to hundreds of gates in our SAT queries. To address this, we adopted an approach used by several previous model counting works <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b76">77]</ref>: using low-density parity functions. Each such function of these samples k random bits of the input string, with k centered around log 2 (n). As a further optimization, we periodically evaluate the current constraint formula G i to determine if any bit of the plaintext has been fixed. We omit fixed bits from the input to the parity functions, and reduce both n and k accordingly.</p><p>Implementing AdjustSize. Because SAT/SMT queries are computationally expensive, we evaluate a few strategies for implementing AdjustSize which minimize time spent solving. We omit discussion of these strategies for brevity; refer to the full version of this paper <ref type="bibr" target="#b14">[15]</ref>.</p><p>Describing malleation. To avoid making users reimplement basic functionality, Delphinium provides built-in support for several malleation functions. These include simple stream ciphers, stream ciphers that support truncation (from either the left or the right side), and CBC mode encryption. The design of these malleation functions required substantial extensions to the Delphinium framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Implementing Malleation Functions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Truncation.</head><p>Support for truncation requires Delphinium to support plaintexts of variable length. This functionality is not natively provided by the bitvector interfaces used in most solvers. We therefore modify the solver values to encode message length in addition to content. This necessitates changes to the interface for F. We accomplish this by treating the first log 2 (n) bits of each bitvector as a length field specifying how long the message is and by having every implementation of F decode this value prior to evaluating the plaintext. To properly capture truncation off either end of a message, the malleation bitvector is extended by 2 ˙ log 2 (n) so the lowest order log 2 (n) bits of the malleation bitvector specify how many bits should be truncated off the low order bits of the plaintext and the next log 2 (n) bits specify what should be truncated from high order bits of the message. For ease of implementation, in some schemes the n bits following the truncation describe the length field of the plaintext. This allows for easily expressing the exclusive-OR portion of our malleation without bit-shifting and allows encoding extension. Some schemes, such as stream ciphers, only enable truncation off one side of the message, and so in this case we add a constraint to the formula which disallows truncation off the low order bits of a message. This is because trunction off the high order bits would imply a misalignment of the ciphertext with the keystream, causing decryption to produce effectively randomized plaintext.</p><p>Truncation for Block Cipher Modes. In block cipher modes such as CTR, CFB, and OFB, an attacker also has the ability to increment the nonce and truncate off blocks of ciphertext. <ref type="bibr" target="#b8">9</ref> To capture this capability, in the malleation function we additionally constrain the malleation string to express truncation off the high order bits of a message (earlier blocks of ciphertext), provided the number of bits being truncated is a multiple of the block size. plain is significantly more complex. In CBC mode, decryption of a ciphertext block C i is defined as P i = Dec k (C i ) ⊕C i−1 where C i−1 denotes the previous ciphertext block. Since the block C i is given directly to a block cipher, any implementation must account for the the fact that modification of the block C i creates an unpredictable effect on the output P i , effectively randomizing it via the block cipher.</p><p>For a solver to reason over such an effect on the plaintext output, we would need to include constraint clauses corresponding to encryption and decryption, i.e. boolean operations implementing symmetric schemes like AES. To avoid this significant overhead, we instead modify the interface of Maul Π CBC plain to output two abstract bitvec-tors (M, Mask). Mask represents a mask string: any bit j where Mask[ j] = 1 is viewed as a wildcard in the message vector M. When Mask[ j] = 0, the value of the output message is equal to M <ref type="bibr">[ j]</ref> at that position, and when Mask[i] = 1 the value at position M[ j] must be viewed as unconstrained. This requires that we modify F to take (M, Mask) as input. The modified F is able to produce a third value in addition to true and false. This new output value indicates that the format check cannot assign a definite true/false value on this input, due to the uncertainty created by the unconstrained bits. <ref type="bibr" target="#b9">10</ref> Realizing this formulation requires only minor implementation changes to our core algorithms.</p><p>Exclusive-OR and Truncation for CBC. With CBC mode decryption, manipulating a preceding ciphertext block C i−1 produces a predictable exclusive-OR in the plaintext block P i . A message that has been encrypted with a block cipher can also be truncated, provided that truncation is done in multiples of the block size. Therefore, we define malleability for CBC to capture (1) blockwise truncation (from either the left or right side of the ciphertext) and (2) exclusive-OR, where exclusive-OR at index i in one block produces the corresponding bit-flip at index i in the next block of decrypted ciphertext.</p><p>Supporting Extension. For encryption schemes that allow truncation off the beginning of a message, an attacker may also be able to fill in the truncated portion with arbitrary ciphertext, even if this ciphertext may decrypt to plaintext unknown to them. If the corresponding portion of the plaintext is not examined by the format check function, the attacker can derive information from such queries (if the portion is checked, the attacker can only learn the result of the check over random bits by nature of ciphers). Thus, we create an additional initial constraint for this special case, which allows extension to the ciphertext, limited to where the corresponding plaintext is not examined by the format function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Software</head><p>Our prototype implementation of Delphinium comprises roughly 4.2 kLOC of Python. This includes the attack orchestrator, example format check implementations, the test harness, and our generic solver Python API which allows for modular swapping of backing SMT solvers, with implementations for Z3 and STP provided. In pursuing this prototype, we submitted various patches to the underlying theory solvers that have since been included in the upstream software projects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Extensions</head><p>In general, arbitrary functions on fixed-size values can be converted into boolean circuits which SMT solvers can reason over. Existing work in MPC develops compilers from DSLs or a subset of C to boolean circuits which could be used to input arbitrary check format functions easily <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b52">53]</ref>. Experimenting with these, we find that the circuit representations are very large and thus have high runtime overhead when used as constraints. It is possible that circuit synthesis algorithms designed to decrease circuit size (used for applications such as FPGA synthesis) or other logic optimizers could reduce circuit complexity, but we leave exploring this to future work.</p><p>We additionally provide a translation tool from the output format of CMBC-GC <ref type="bibr" target="#b33">[34]</ref> to Python (entirely comprised of circuit operations) to enable use of the Python front-end to Delphinium.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experimental Setup</head><p>To evaluate the performance of Delphinium, we tested our implementation on several multi-core servers using the most up-to-date builds of Z3 (4.8.4) and CryptoMiniSAT (5.6.8). The bulk of our testing was conducted using Amazon EC2, using compute-optimized c5d.18xlarge instances with 72 virtual cores and 144GB of RAM. 11 Several additional tests were run a 72-core Intel Xeon E5 CPU with 500GB of memory running on Ubuntu 16.04, and a 96-core Intel Xeon E7 CPU with 1TB of memory running Ubuntu 18.04. We refer to these machines as AWS, E5 and E7 in the sections below.</p><p>Data collection. For each experimental run, we collected statistics including the total number of decryption oracle queries performed; the wall-clock time required to construct each query; the number of plaintext bits recovered following each query; and the value of s used to construct a given malleation string. We also recorded each malleation string S produced by our attack, which allows us to "replay" any transcript after the fact. The total number of queries required to complete an attack provides the clearest signal of attack progress, and we use that as the primary metric for evaluation. However, in some cases we evaluate partial attacks using the ApproxMC approximate model counting tool <ref type="bibr" target="#b64">[65]</ref>. This tool provides us with an estimate for the total number of remaining candidates for M * at every phase of a given attack, and thus allows evaluation of partial attack transcripts.</p><p>Selecting attack parameters. The adjustable parameters in FastSample include t, the number of counting trials, δ, which determines the fraction of trials that must succeed, and the length of the parity constraints used to sample. We ran a number of experiments to determine optimal values for these parameters across the format functions PKCS7 and a bitwise format function defined in §5.2. Empirically, δ = 0.5, 2 t 5, and parity functions of logarthmic length are suitable for our purposes. Experiments varying t and comparing parity hash function lengths can be found in the full version of this paper <ref type="bibr" target="#b14">[15]</ref>. These tests were performed on AWS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experiments with Stream Ciphers</head><p>Because the malleation function for stream ciphers is relatively simple (consisting simply of bitwise exclusive-OR), we initiated our experiments with these ciphers.</p><p>Bytewise Encryption Padding. The PKCS #7 encryption standard (RFC 2315) <ref type="bibr" target="#b43">[44]</ref> defines a padding scheme for use with block cipher modes of operation. This padding is similar to the standard TLS CBC-mode padding <ref type="bibr" target="#b6">[7]</ref> considered by Vaudenay <ref type="bibr" target="#b72">[73]</ref>. We evaluate our algorithm on both these functions as a benchmark because PKCS7 and its variants are reasonably complex, and because the human-developed attack is well understood. Throughout the rest of this paper, we refer to these schemes as PKCS7 and TLS-PKCS7.</p><p>Setup. We conducted an experimental evaluation of the PKCS #7 attack against a 128-bit stream cipher, using parameters t = 5, δ = 0.5. Our experiments begin by sampling a random message M * from the space of all possible PKCS #7 padded messages, and setting G 0 ← F PKCS7 . <ref type="bibr" target="#b11">12</ref> This evaluation was performed on AWS, E5, and E7.</p><p>Results. Our four complete attacks completed in an average of 1699.25 queries (min. 1475, max. 1994) requiring 1.875 hours each (min. 1.63, max. 2.18). A visualization of the resulting attack appears in the full version of this paper <ref type="bibr" target="#b14">[15]</ref>. These results compare favorably to the Vaudenay attack, which requires˜2000requires˜2000 queries in expectation, however it is likely that additional tests would find some examples in excess of this average. As points of comparison, attacks with t = 3 resulted in a similar number of queries (modulo expected variability over different randomly sampled messages) but took roughly 2 to 3 times as long to complete, and attacks with t = 1 reached over 5000 queries having only discovered half of the target plaintext message.</p><p>Bitwise Padding. To test our attacks, we constructed a simplified bit padding scheme F bitpad . This contrived scheme encodes the bit length of the padding P into the rightmost log 2 (n) bits of the plaintext string, and then places up to P padding bits directly to the left of this length field, with each padding bit set to 1. We verified the effectiveness of our attacks against this format using a simple stream cipher. Using the parameters t = 5, δ = 0.5 the generated attacks took on average 153 queries (min. 137, max. 178). <ref type="figure">Figure 1</ref> shows one attack transcript at t = 5, δ = 0.5. Additional experiments measuring the effect of t on this format are provided in the full version of this paper <ref type="bibr" target="#b14">[15]</ref>. These experiments were run primarily on E5.</p><p>Negative result: Cyclic Redundancy Checks (CRCs). Cyclic redundancy checks (CRCs) are used in many network protocols for error detection and correction. CRCs are well known to be malleable, due to the linearity of the functions: namely, for a CRC it is always the case that CRC(a⊕b) = CRC(a)⊕CRC(b). To test Delphinium's ability to rule out attacks against format functions, we implemented a message format consisting of up to three bytes of message, followed by a CRC-8 and a 5-bit message length field. The format function F crc8 computes the CRC over the message bytes, and verifies that the CRC in the message matches the computed CRC. <ref type="bibr" target="#b12">13</ref> A key feature of this format is that a valid ciphertext C * should not be vulnerable to a format oracle attack using a simple exclusive-OR malleation against this format, for the simple reason that the attacker can predict the output of the decryption oracle for every possible malleation of the ciphertext (due to the linearity of CRC), and thus no information will be learned from executing a query. This intuition was confirmed by our attack algorithm, which immediately reported that no malleation strings could be found. These experiments were performed on E5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Ciphers with Truncation</head><p>A more powerful malleation capability grants the attacker to arbitrarily truncate plaintexts. In some ciphers, this truncation can be conducted from the low-order bits of the plaintext, simply by removing them from the right side of the ciphertext. In other ciphers, such as CTRmode or CBC-mode, a more limited left-side truncation can be implemented by modifying the IV of a ciphertext. Delphinium includes malleation functions that incorporate all three functionalities.</p><p>CRC-8 with a truncatable stream cipher. To evaluate how truncation affects the ability of Delphinium to find attacks, we conducted a second attack using the function F crc8 , this time using an implementation of AES-CTR supporting truncation. Such a scheme may seem contrived, since it involves an encrypted CRC value. However, this very flaw was utilized by Beck and Trew to break WPA <ref type="bibr" target="#b67">[68]</ref>. In our experiment, the attack algorithm was able to recover two bytes of the three-byte message, by using the practical strategy of truncating the message and iterating through all possible values of the remaining byte. Additional CRC experiments can be found in the full version of this paper <ref type="bibr" target="#b14">[15]</ref>. These experiments were run primarily on E5.</p><p>As this example demonstrates, the level of customization and variation in how software developers operate over encrypted data streams can obfuscate the concrete security of an existing implementation. This illustrates the utility of Delphinium since such variation's effect on the underlying scheme does not need to be fully understood by a user, outside of encoding the format's basic operation.</p><p>Thumb Embedded ISA. To exercise Delphinium against a novel format oracle of notably different structure than those traditionally analyzed (such as padding), we implemented a minimal instruction interpreter for the 16-bit Thumb instruction set architecture (ISA), defined as part of the ARM specification <ref type="bibr" target="#b2">[3]</ref>, capable of emitting illegal instruction signals. Then, operating over streamcipher encrypted Thumb instructions and using illegal instructions as a boolean signal, Delphinium is able to exploit the exclusive-OR malleation to uncover the top seven bits of each 16-bit instruction, in many cases uncovering nine or more (up to 16) bits of each instruction, 14 in an average of˜13of˜13.3 queries, with each full attack taking only seconds on E5.</p><p>Although limited in a few regards, most notably in the simplification of the format oracle into a boolean signal and the assumption that an attacker could be situated in a way that this signal could be gathered, this attack is timely in that it is inspired by the widespread use of unauthenticated encryption in device firmware updates <ref type="bibr" target="#b30">[31]</ref>.</p><p>If these updates are delivered over-the-air, they may be susceptible to man-in-the-middle attacks enabling such a decryption oracle. Extensive industry research and a current Internet Draft note that unauthenticated firmware updates are an ongoing problem <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b53">54]</ref>.</p><p>This initial result serves both as validation of Delphinium and as creation of an avenue for future work, including the development of a model for a more complex but widespread ISA such as 32-bit ARM <ref type="bibr" target="#b2">[3]</ref>, perhaps exploiting additional signals such as segmentation faults or side channels in order to capture the capabilities of a sophisticated adversary.</p><p>S2N with Exclusive-OR and Truncation. To evaluate a realistic attack on a practical format function, we developed a format checking function for the Amazon s2n <ref type="bibr" target="#b1">[2]</ref> TLS session ticket format. s2n uses 60-byte tickets with a 12-byte header comprising a protocol version, ciphersuite version, and format version, along with an 8-byte timestamp that is compared against the current server clock. Although s2n uses authenticated encryption (AES-GCM), we consider a hypothetical scenario where nonce re-use has allowed for message forgery <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b32">33]</ref>.</p><p>Our experiments recovered the 8-byte time field that a session ticket was issued at: in one attack run, with fewer than 50 queries. However, the attack was unable to obtain the remaining fields from the ticket. This is in part due to some portions of the message being untouched by the format function, and due to the complexity of obtaining a positive result from the oracle when many bytes are unknown. We determined that a full attack against the remaining bytes of the ticket key is possible, but would leave 16 bytes unknown and would require approximately 2 50 queries. Unsurprisingly, Delphinium timed out on this attack. These experiments were run on AWS and E5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">CBC mode</head><p>We also used the malleation function for CBC-mode encryption. This malleation function supports an arbitrary number of blocks, and admits truncation of plaintexts from either side of the plaintext. <ref type="bibr" target="#b14">15</ref> The CBC malleation function accepts a structured malleation string S, which can be parsed as (S , l, r) where l, r are integers indicating the number of blocks to truncate from the message.</p><p>To test this capability, we used the PKCS7 format function with a blocksize of B = 16 bytes, and a two-block CBC plaintext. (This corresponds to a ciphertext consisting of three blocks, including the Initialization Vector.) <ref type="bibr" target="#b14">15</ref> In practice, truncation in CBC simply removes blocks from either end of the ciphertext. Delphinium generated an attack which took 3441 oracle queries for a random message with four bytes of padding. This compares favorably to the Vaudenay attack, which requires 3588 queries in expectation. Interestingly, Delphinium settled on a more or less random strategy of truncation. Where a human attacker would focus on recovering the entire contents of one block before truncating and attacking the next block of plaintext, Delphinium instead truncates more or less as it pleases: in some queries it truncates the message and modifies the Initialization vector to attack the first block. In other queries it focuses on the second block. <ref type="figure" target="#fig_5">Figure 4</ref> gives a brief snapshot of this pattern of malleations discovered by Delphinium. Despite this query efficiency (which we seek to optimize, over wall-clock efficiency), the compute time for this attack was almost a week of computation on E5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>CCA-2 and format oracle attacks. The literature contains an abundance of works on chosen ciphertext and format oracle attacks. Many works consider the problem of constructing and analyzing authenticated encryption modes <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b60">61,</ref><ref type="bibr" target="#b61">62]</ref>, or analyzing deployed protocols, e.g., <ref type="bibr" target="#b15">[16]</ref>. Among many practical format oracle attacks <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b56">57,</ref><ref type="bibr" target="#b58">59,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b75">76]</ref>, the Lucky13 attacks <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b6">7]</ref> are notable since they use a noisy timingbased side channel.</p><p>Automated discovery of cryptographic attacks. Automated attack discovery on systems has been considered in the past. One line of work <ref type="bibr" target="#b25">[26]</ref>, <ref type="bibr" target="#b57">[58]</ref> focuses on generating public input values that lead to maximum leakage of secret input in Java programs where leakage is defined in terms of channel capacity and shannon entropy. Unlike our work, Pasareanu et al. <ref type="bibr" target="#b25">[26]</ref> do not consider an adversary that makes adaptive queries based on results of previous oracle replies. Both <ref type="bibr" target="#b25">[26]</ref> and <ref type="bibr" target="#b57">[58]</ref> assume leakage results from timing and memory usage side channels.</p><p>Using solvers for cryptographic tasks/model counting. A wide variety of cryptographic use cases for theory solvers have been considered in the literature. <ref type="bibr">Soos et al. [66]</ref> developed CryptoMiniSAT to recover state from weak stream ciphers, an application also considered in <ref type="bibr" target="#b26">[27]</ref>. Solvers have also been used against hash functions <ref type="bibr" target="#b49">[50]</ref>, and to obtain cipher key schedules following cold boot attacks <ref type="bibr" target="#b7">[8]</ref>. There have been many model counting techniques proposed in the past based on universal hash functions <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b76">77]</ref>. However, many other techniques have been proposed in the literature. Several works propose sophisticated multi-query approach with high accuracy <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b64">65]</ref>, resulting in the ApproxMC tool we use in our experiments. Other works examine the complexity of parity constraints <ref type="bibr" target="#b76">[77]</ref>, and optimize the number of variables that must be constrained over to find a satisfying assignment <ref type="bibr" target="#b40">[41]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>Our work leaves a number of open problems. In particular, we proposed several optimizations that we were not able to implement in our tool, due to time and performance constraints. Additionally, while we demonstrated the viability of our model count optimization techniques through empirical analysis, these techniques require theoretical attention. Our ideas may also be extensible in many ways: for example, developing automated attacks on protocols with side-channel leakage; on public-key encryption; and on "leaky" searchable encryption schemes, e.g., <ref type="bibr" target="#b37">[38]</ref>. Most critically, a key contribution of this work is that it poses new challenges for the solver research community, which may result in improvements both to general solver efficiency, as well as to the performance of these attack tools.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Definition 2 (</head><label>2</label><figDesc>Malleation functions) The malleation functions for a symmetric encryption scheme Π comprise a pair of efficiently-computable functions (Maul Π ciph , Maul Π plain ) with the following properties. Let M, C be the plaintext (resp. ciphertext) space of Π. The function Maul Π ciph : C × {0, 1} * → C ∪ {⊥} takes as input a ciphertext and a malleation instruction string. It outputs a ciphertext or the distinguished error symbol ⊥. The function Maul Π plain : M × {0, 1} * → ˆ M, on input a plaintext and a malleation instruction string, outputs a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 illustratesFigure 3 :</head><label>33</label><figDesc>Figure 3 illustrates the architecture of Delphinium. The software comprises several components: Attack orchestrator. This central component is respon-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>CBC Mode.</head><label></label><figDesc>In contrast with stream ciphers, Maul Π CBC plain is not equal to Maul Π CBC ciph and moreover Maul Π CBC</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: A contiguous set of malleation queries made by Delphinium during a simulated CBC attack. The rightmost bits signal truncation (from left or right).</figDesc></figure>

			<note place="foot" n="1"> This captures the fact that, in some encryption schemes (e.g., CBCmode encryption), malleation produces key-dependent effects on the decrypted message. We discuss and formalize this in §2.</note>

			<note place="foot" n="2"> Here n represents an upper bound on the length of the plaintext M * .</note>

			<note place="foot" n="3"> Some experimental SMT implementations provide logic for reasoning about the cardinality of small sets, these strategies scale poorly to the large sets we need to reason about in practical format oracle attacks.</note>

			<note place="foot" n="4"> Note that s = 0 represents the original constraint formula, and so a failure to find a satisfying assignment at this size triggers the conclusion of the attack.</note>

			<note place="foot" n="6"> The formulation of Fremont et al. [35] includes an additional set of boolean variables Z that must also be satisfied, but is not part of the optimization problem. We omit this term because it is not used by our algorithms. Note as well that, unlike Fremont et al., our algorithms are not concerned with the actual count of solutions for Y .</note>

			<note place="foot" n="7"> Our concrete implementation in §4 uses the solver to enumerate each of the known and unknown bits of M * .</note>

			<note place="foot" n="9"> This is not necessarily possible when dealing with other stream ciphers, due to the keystream being misaligned with the ciphertext.</note>

			<note place="foot" n="10"> In practice, we implement the output of F as a bitvector of length 2, and modify our algorithms to use 00 and 01 in place of 0 and 1, respectively.</note>

			<note place="foot" n="11"> We also mounted 900GB of ephemeral EC2 storage to each instance as a temporary filesystem to save CNF files during operation.</note>

			<note place="foot" n="12"> In practice, this plaintext distribution tends to produce messages with short padding.</note>

			<note place="foot" n="13"> In our implementation we used a simple implementation that does not reflect input and output, or add an initial constant value before or after the remainder is calculated.</note>

			<note place="foot" n="14"> Such a partial firmware decryption generally leaks the instruction opcode, but not its arguments. This could be very useful to an attacker, for example in fuzzy comparison with compiled open source libraries to determine libraries and their versions used in a given firmware update.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Available at https://stp. github</title>
		<imprint/>
	</monogr>
	<note>The Simple Theorem Prover (STP)</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Introducing s2n, a New Open Source TLS Implementation</title>
		<ptr target="https://aws.amazon.com/blogs/security/introducing-s2n-a-new-open-source-tls-implementation/" />
		<imprint>
			<date type="published" when="2015-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">ARM Architecture Reference Manual</title>
		<imprint>
			<date type="published" when="2018-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Imperfect Forward Secrecy: How Diffie-Hellman Fails in Practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Adrian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karthikeyan</forename><surname>Bhargavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zakir</forename><surname>Durumeric</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierrick</forename><surname>Gaudry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Alex</forename><surname>Halderman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadia</forename><surname>Heninger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Drew</forename><surname>Springall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmanuel</forename><surname>Thomé</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Valenta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Vandersloot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Wustrow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Santiago</forename><surname>Zanella-Béguelin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Zimmermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;15</title>
		<meeting>the 22nd ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="5" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Lucky Microseconds: A Timing Attack on Amazon&apos;s s2n Implementation of TLS. Cryptology ePrint Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">G</forename><surname>Albrecht</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Paterson</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2015/1129" />
		<imprint>
			<date type="published" when="1129" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Watson. Plaintext recovery attacks against SSH</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><forename type="middle">R</forename><surname>Albrecht</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gaven</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 30th IEEE Symposium on Security and Privacy, SP &apos;09</title>
		<meeting>the 2009 30th IEEE Symposium on Security and Privacy, SP &apos;09<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="16" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Lucky Thirteen: Breaking the TLS and DTLS Record Protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nadhem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">G</forename><surname>Alfardan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P (Oakland) &apos;13</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="526" to="540" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Applications of SAT Solvers to AES key Recovery from Decayed Key Schedule Images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abdel</forename><forename type="middle">Alim</forename><surname>Kamal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amr</forename><forename type="middle">M</forename><surname>Youssef</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">324</biblScope>
			<date type="published" when="2010-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">DROWN: Breaking TLS using SSLv2</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nimrod</forename><surname>Aviram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Schinzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juraj</forename><surname>Somorovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadia</forename><surname>Heninger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maik</forename><surname>Dankel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens</forename><surname>Steube</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Valenta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Adrian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Alex</forename><surname>Halderman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Viktor</forename><surname>Dukhovni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emilia</forename><surname>Käsper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shaanan</forename><surname>Cohney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Susanne</forename><surname>Engels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christof</forename><surname>Paar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Shavitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th USENIX Security Symposium (USENIX Security 16)</title>
		<meeting><address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="689" to="706" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Attacking GlobalPlatform SCP02-compliant Smart Cards Using a Padding Oracle Attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gildas</forename><surname>Avoine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Loïc</forename><surname>Ferreira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IACR Transactions on Cryptographic Hardware and Embedded Systems</title>
		<imprint>
			<date type="published" when="2018-05" />
			<biblScope unit="volume">2018</biblScope>
			<biblScope unit="page" from="149" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">DPLL with Caching: A new algorithm for #SAT and Bayesian inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fahiem</forename><surname>Bacchus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shannon</forename><surname>Dalmao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Toniann</forename><surname>Pitassi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronic Colloquium on Computational Complexity (ECCC)</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<date type="published" when="2003-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Online Synthesis of Adaptive Side-Channel Attacks Based On Noisy Observations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Rosner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Bultan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE European Symposium on Security and Privacy (EuroS P)</title>
		<imprint>
			<date type="published" when="2018-04" />
			<biblScope unit="page" from="307" to="322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient Padding Oracle Attacks on Cryptographic Hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Romain</forename><surname>Bardou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Riccardo</forename><surname>Focardi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yusuke</forename><surname>Kawamoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lorenzo</forename><surname>Simionato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Steel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joe-Kai</forename><surname>Tsay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO &apos;12</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012" />
			<biblScope unit="volume">7417</biblScope>
			<biblScope unit="page" from="608" to="625" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Counting Models using Connected Components</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><forename type="middle">J</forename><surname>Bayardo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jr</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Pehoushek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="157" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Using SMT Solvers to Automate Chosen Ciphertext Attacks. Cryptology ePrint Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabrielle</forename><surname>Beck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maximilian</forename><surname>Zinkus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Green</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2019/958" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Breaking and Provably Repairing the SSH Authenticated Encryption Scheme: A Case Study of the Encode-then-Encrypt-and-MAC Paradigm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tadayoshi</forename><surname>Kohno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chanathip</forename><surname>Namprempre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Inf. Syst. Secur</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="206" to="241" />
			<date type="published" when="2004-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Authenticated Encryption: Relations among Notions and Analysis of the Generic Composition Paradigm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mihir</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chanathip</forename><surname>Namprempre</surname></persName>
		</author>
		<editor>Tatsuaki Okamoto</editor>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Springer</publisher>
			<biblScope unit="page" from="531" to="545" />
			<pubPlace>Berlin, Heidelberg; Berlin Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Problem Areas for the IP Security Protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Steven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bellovin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Conference on USENIX Security Symposium, Focusing on Applications of Cryptography</title>
		<meeting>the 6th Conference on USENIX Security Symposium, Focusing on Applications of Cryptography<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="1996" />
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="21" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Messy State of the Union: Taming the Composite State Machines of TLS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Beurdouche</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bhargavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Delignat-Lavaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pironti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Strub</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">K</forename><surname>Zinzindohoue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2015-05" />
			<biblScope unit="page" from="535" to="552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Good Old DavisPutnam Procedure Helps Counting Models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elazar</forename><surname>Birnbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Eliezer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lozinskii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Int. Res</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="457" to="477" />
			<date type="published" when="1999-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Nonce-Disrespecting Adversaries: Practical Forgery Attacks on GCM in TLS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hanno</forename><surname>Böck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aaron</forename><surname>Zauner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sean</forename><surname>Devlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juraj</forename><surname>Somorovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philipp</forename><surname>Jovanovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th USENIX Workshop on Offensive Technologies (WOOT 16)</title>
		<meeting><address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Password interception in a SSL/TLS channel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brice</forename><surname>Canvel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alain</forename><surname>Hiltgen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Serge</forename><surname>Vaudenay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Vuagnoux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -CRYPTO 2003</title>
		<editor>Dan Boneh</editor>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="583" to="599" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Distribution-aware sampling and weighted model counting for SAT</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Supratik</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fremont</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kuldeep</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Meel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sanjit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Twenty-Eighth AAAI Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">From weighted to unweighted model counting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Supratik</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dror</forename><surname>Fried</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kuldeep</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Meel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TwentyFourth International Joint Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Algorithmic Improvements in Approximate Counting for Probabilistic Inference: From Linear to Logarithmic SAT Calls</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Supratik</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kuldeep</forename><forename type="middle">S</forename><surname>Meel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">2016</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Quoc-Sang Phan. Multirun side-channel analysis using Symbolic Execution and Max-SMT</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Corina</forename><forename type="middle">S</forename><surname>Pasquale Malacaria</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pasareanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 IEEE 29th Computer Security Foundations Symposium (CSF)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Practical Algebraic Attacks on the Hitag2 Stream Cipher</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicolas</forename><forename type="middle">T</forename><surname>Courtois</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O&amp;apos;</forename><surname>Sean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Jacques</forename><surname>Neil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Quisquater</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Security</title>
		<editor>Pierangela Samarati, Moti Yung, Fabio Martinelli, and Claudio A. Ardagna</editor>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="167" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A Machine Program for Theorem-proving</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Logemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><surname>Loveland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="394" to="397" />
			<date type="published" when="1962-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A Computing Procedure for Quantification Theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hilary</forename><surname>Putnam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="201" to="215" />
			<date type="published" when="1960-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">On the (in)security of IPsec in MAC-then-encrypt configurations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean</forename><surname>Paul Degabriele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th ACM Conference on Computer and Communications Security, CCS &apos;10</title>
		<meeting>the 17th ACM Conference on Computer and Communications Security, CCS &apos;10<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="493" to="504" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Perilous Peripherals: The Hidden Dangers Inside Windows &amp; Linux Computers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Eclypsium</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Low-Density Parity Constraints for Hashing-Based Discrete Integration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefano</forename><surname>Ermon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carla</forename><forename type="middle">P</forename><surname>Gomes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Sabharwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bart</forename><surname>Selman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Authentication Weaknesses in GCM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Niels</forename><surname>Ferguson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">CBMC-GC: an ANSI C compiler for secure two-party computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Franz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Holzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Katzenbeisser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Schallhart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Helmut</forename><surname>Veith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Compiler Construction</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="244" to="249" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Maximum Model Counting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Fremont</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><forename type="middle">N</forename><surname>Rabe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjit</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st AAAI Conference on Artificial Intelligence (AAAI)</title>
		<meeting>the 31st AAAI Conference on Artificial Intelligence (AAAI)</meeting>
		<imprint>
			<date type="published" when="2017-02" />
			<biblScope unit="page" from="3885" to="3892" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Dancing on the Lip of the Volcano: Chosen Ciphertext Attacks on Apple iMessage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christina</forename><surname>Garman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabriel</forename><surname>Kaptchuk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ian</forename><surname>Miers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Rushanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th USENIX Security Symposium (USENIX Security 16)</title>
		<meeting><address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="655" to="672" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Model Counting: A New Strategy for Obtaining Good Bounds</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carla</forename><forename type="middle">P</forename><surname>Gomes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Sabharwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bart</forename><surname>Selman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st National Conference on Artificial Intelligence</title>
		<meeting>the 21st National Conference on Artificial Intelligence</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="54" to="61" />
		</imprint>
	</monogr>
	<note>AAAI&apos;06</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Pump Up the Volume: Practical Database Reconstruction from Volume Leakage on Range Queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Grubbs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marie-Sarah</forename><surname>Lacharite</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brice</forename><surname>Minaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">G</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;18</title>
		<meeting>the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;18<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="315" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Stochastic Local Search: Foundations &amp; Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Holger</forename><surname>Hoos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Sttzle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<pubPlace>San Francisco, CA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Fear, uncertainty and the padding oracle exploit in ASP</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Troy</forename><surname>Hunt</surname></persName>
		</author>
		<ptr target="https://www.troyhunt.com/fear-uncertainty-and-and-padding-oracle/" />
		<imprint>
			<date type="published" when="2010-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">On computing minimal independent support and its applications to sampling and counting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Ivrii</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sharad</forename><surname>Malik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kuldeep</forename><surname>Meel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moshe</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Constraints</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<date type="published" when="2015-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">How to Break XML Encryption</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tibor</forename><surname>Jager</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juraj</forename><surname>Somorovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS &apos;2011</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2011-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Authentication failures in NIST version of GCM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antoine</forename><surname>Joux</surname></persName>
		</author>
		<ptr target="https://csrc.nist.gov/csrc/media/projects/block-cipher-techniques/documents/bcm/comments/800-38-series-drafts/gcm/joux_comments.pdf" />
		<imprint>
			<date type="published" when="2006-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">PKCS #7: Cryptographic Message Syntax Version 1.5. RFC 2315</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Burt</forename><surname>Kaliski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">How to Break XML Encryption -Automatically</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dennis</forename><surname>Kupser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Mainka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jörg</forename><surname>Schwenk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juraj</forename><surname>Somorovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX Conference on Offensive Technologies, WOOT&apos;15</title>
		<meeting>the 9th USENIX Conference on Offensive Technologies, WOOT&apos;15<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Authentication Key Recovery on Galois/Counter Mode GCM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Mattsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Magnus</forename><surname>Westerlund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Progress in Cryptology -AFRICACRYPT 2016</title>
		<meeting>the 8th International Conference on Progress in Cryptology -AFRICACRYPT 2016<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2016" />
			<biblScope unit="volume">9646</biblScope>
			<biblScope unit="page" from="127" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Format Oracles on OpenPGP</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Florian</forename><surname>Maury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Rene</forename><surname>Reinhard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olivier</forename><surname>Levillain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henri</forename><surname>Gilbert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Cryptographer&apos;s Track at the RSA Conference 2015</title>
		<meeting><address><addrLine>San Francisco, United States</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-04" />
			<biblScope unit="page" from="220" to="236" />
		</imprint>
	</monogr>
	<note>Topics in Cryptology -CT-RSA 2015</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Scalable Scanning and Automatic Classification of TLS Padding Oracle Vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Merget</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juraj</forename><surname>Somorovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nimrod</forename><surname>Aviram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Janis</forename><surname>Fliegenschmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jörg</forename><surname>Schwenk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Shavitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th USENIX Conference on Security Symposium, SEC&apos;19</title>
		<meeting>the 28th USENIX Conference on Security Symposium, SEC&apos;19<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2019" />
			<biblScope unit="page" from="1029" to="1046" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">The Z3 Theorem Prover</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Microsoft</forename><surname>Research</surname></persName>
		</author>
		<ptr target="https://github.com/Z3Prover/z3" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Applications of SAT Solvers to Cryptanalysis of Hash Functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Mironov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lintao</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Theory and Applications of Satisfiability Testing (SAT 06</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006-08" />
			<biblScope unit="volume">4121</biblScope>
			<biblScope unit="page" from="102" to="115" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Error oracle attacks on CBC mode: Is there a future for CBC mode encryption</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><forename type="middle">J</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Security, 8th International Conference</title>
		<meeting><address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-09-20" />
			<biblScope unit="page" from="244" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">This POODLE bites: Exploiting the SSLv3 Fallback</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bodo</forename><surname>Möller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thai</forename><surname>Duong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krzysztof</forename><surname>Kotowicz</surname></persName>
		</author>
		<ptr target="https://www.openssl.org/~bodo/ssl-poodle.pdf" />
		<imprint>
			<date type="published" when="2014-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Frigate: A validated, extensible, and efficient compiler and interpreter for secure computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Mood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Debayan</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Traynor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 IEEE European Symposium on Security and Privacy (EuroS&amp;P)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="112" to="127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">An Information Model for Firmware Updates in IoT Devices. Internet-Draft draft-ietf-suit-information-model-05, IETF Secretariat</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brendan</forename><surname>Moran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hannes</forename><surname>Tschofenig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henk</forename><surname>Birkholz</surname></persName>
		</author>
		<ptr target="http://www.ietf.org/internet-drafts/draft-ietf-suit-information-model-05.txt" />
		<imprint>
			<date type="published" when="2020-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">PDF Insecurity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabian</forename><surname>Ising</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vladislav</forename><surname>Mladenov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Mainka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Schinzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jörg</forename><surname>Schwenk</surname></persName>
		</author>
		<ptr target="https://www.pdf-insecurity.org/encryption/encryption.html" />
		<imprint>
			<date type="published" when="2019-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Public-key Cryptosystems Provably Secure Against Chosen Ciphertext Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-second Annual ACM Symposium on Theory of Computing, STOC &apos;90</title>
		<meeting>the Twenty-second Annual ACM Symposium on Theory of Computing, STOC &apos;90<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1990" />
			<biblScope unit="page" from="427" to="437" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Padding Oracle Attacks on the ISO CBC Mode Encryption Standard</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kenneth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arnold</forename><forename type="middle">K L</forename><surname>Paterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Yau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Cryptographers&apos; Track at the RSA Conference</title>
		<meeting><address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-02-23" />
		</imprint>
	</monogr>
	<note>Topics in Cryptology -CT-RSA</note>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Synthesis of Adaptive SideChannel Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Quoc-Sang</forename><surname>Phan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lucas</forename><surname>Bang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Corina</forename><forename type="middle">S</forename><surname>Pasareanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pasquale</forename><surname>Malacaria</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tevfik</forename><surname>Bultan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE 30th Computer Security Foundations Symposium (CSF)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Efail: Breaking S/MIME and OpenPGP Email Encryption using Exfiltration Channels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Damian</forename><surname>Poddebniak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Dresen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabian</forename><surname>Ising</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Schinzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><surname>Friedberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juraj</forename><surname>Somorovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jörg</forename><surname>Schwenk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th USENIX Security Symposium (USENIX Security 18)</title>
		<meeting><address><addrLine>Baltimore, MD</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="549" to="566" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Practical Padding Oracle Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juliano</forename><surname>Rizzo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thai</forename><surname>Duong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th USENIX Conference on Offensive Technologies</title>
		<meeting>the 4th USENIX Conference on Offensive Technologies</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Authenticated Encryption with Associated Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phillip</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS &apos;02</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<title level="m" type="main">A Provable-Security Treatment of the Key-Wrap Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phillip</forename><surname>Rogaway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Shrimpton</surname></persName>
		</author>
		<editor>Serge Vaudenay</editor>
		<imprint>
			<date type="published" when="2006" />
			<publisher>Springer</publisher>
			<biblScope unit="page" from="373" to="390" />
			<pubPlace>Berlin, Heidelberg; Berlin Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Combining Component Caching and Clause Learning for Effective Model Counting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tian</forename><surname>Sang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fahiem</forename><surname>Bacchus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Beam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><surname>Kautz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Toniann</forename><surname>Pitassi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAT</title>
		<imprint>
			<date type="published" when="2004-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m" type="main">What you need to know about BEAST</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Smith</surname></persName>
		</author>
		<ptr target="https://blogs.akamai.com/2012/05/what-you-need-to-know-about-beast.html" />
		<imprint>
			<date type="published" when="2012-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">BIRD: Engineering an Efficient CNF-XOR SAT Solver and its Applications to Approximate Model Counting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mate</forename><surname>Soos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kuldeep</forename><forename type="middle">S</forename><surname>Meel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI Conference on Artificial Intelligence (AAAI)</title>
		<meeting>AAAI Conference on Artificial Intelligence (AAAI)</meeting>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">2019</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Extending SAT Solvers to Cryptographic Problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mate</forename><surname>Soos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karsten</forename><surname>Nohl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claude</forename><surname>Castelluccia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Theory and Applications of Satisfiability Testing (SAT 2009)</title>
		<imprint>
			<date type="published" when="2009-06" />
			<biblScope unit="page" from="244" to="257" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">The complexity of approximate counting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larry</forename><surname>Stockmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the fifteenth annual ACM symposium on Theory of computing</title>
		<meeting>the fifteenth annual ACM symposium on Theory of computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1983" />
			<biblScope unit="page" from="118" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Practical attacks against WEP and WPA</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erik</forename><surname>Tews</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Beck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the second ACM conference on Wireless network security</title>
		<meeting>the second ACM conference on Wireless network security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="79" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seinosuke</forename><surname>Toda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PP is As Hard As the Polynomial-time Hierarchy. SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="865" to="877" />
			<date type="published" when="1991-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">The Complexity of Enumeration and Reliability Problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leslie</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="410" to="421" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">NP is as easy as detecting unique solutions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">V</forename><surname>Vazirani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="85" to="93" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Key Reinstallation Attacks: Forcing Nonce Reuse in WPA2</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathy</forename><surname>Vanhoef</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;17</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;17<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1313" to="1328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Security Flaws Induced by CBC Padding -Applications to SSL, IPSEC, WTLS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Serge</forename><surname>Vaudenay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT &apos;02</title>
		<meeting><address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<publisher>SpringerVerlag</publisher>
			<date type="published" when="2002" />
			<biblScope unit="volume">2332</biblScope>
			<biblScope unit="page" from="534" to="546" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W3c</forename><forename type="middle">Web</forename><surname>Cryptography</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Api</forename></persName>
		</author>
		<ptr target="https://www.w3.org/TR/WebCryptoAPI/" />
		<imprint>
			<date type="published" when="2017-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">A New Approach to Model Counting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bart</forename><surname>Selman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory and Applications of Satisfiability Testing</title>
		<editor>Fahiem Bacchus and Toby Walsh</editor>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="324" to="339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Padding Oracle Attacks on CBC-Mode Encryption with Secret and Random IVs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">G</forename><surname>Yau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><forename type="middle">J</forename><surname>Paterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fast Software Encryption: 12th International Workshop, FSE 2005</title>
		<meeting><address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="299" to="319" />
		</imprint>
	</monogr>
	<note>Revised Selected Papers</note>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Closing the Gap Between Short and Long XORs for Model Counting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shengjia</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sorathan</forename><surname>Chaturapruek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Sabharwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefano</forename><surname>Ermon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI 2016</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
