<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:57+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ElasticBF: Fine-grained and Elastic Bloom Filter Towards Efficient Read for LSM-tree-based KV Stores</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yueming</forename><surname>Zhang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Science</orgName>
								<address>
									<country>Technology of China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yongkun</forename><surname>Li</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Science</orgName>
								<address>
									<country>Technology of China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">Anhui Province Key Laboratory of High Performance Computing</orgName>
								<address>
									<country>USTC</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fan</forename><surname>Guo</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Science</orgName>
								<address>
									<country>Technology of China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cheng</forename><surname>Li</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Science</orgName>
								<address>
									<country>Technology of China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">Anhui Province Key Laboratory of High Performance Computing</orgName>
								<address>
									<country>USTC</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yinlong</forename><surname>Xu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Science</orgName>
								<address>
									<country>Technology of China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">Anhui Province Key Laboratory of High Performance Computing</orgName>
								<address>
									<country>USTC</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">ElasticBF: Fine-grained and Elastic Bloom Filter Towards Efficient Read for LSM-tree-based KV Stores</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>LSM-tree based KV stores suffer from severe read amplification , especially for large KV stores. Even worse, many applications may issue a large amount of lookup operations to search for nonexistent keys, which wastes a lot of extra I/Os. Even though Bloom filters can be used to speedup the read performance, existing designs usually adopt a uniform setting for all Bloom filters and fail to support dynamic adjustment, thus results in a high false positive rate or large memory consumption. To address this issue, we propose ElasticBF, which constructs more small filters for each SSTable and dynamically load into memory as needed based on access frequency, so it realizes a fine-grained and elastic adjustment in running time with the same memory usage. Experiment shows that ElasticBF can achieve 1.94×-2.24× read through-put compared to LevelDB under different workloads, and preserves the same write performance. More importantly , ElasticBF is orthogonal to existing works optimizing the structure of KV stores, so it can be used as an accelerator to further speedup their read performance.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Key-value (KV) store has become an important storage engine for many applications <ref type="bibr" target="#b10">[12,</ref><ref type="bibr" target="#b2">4,</ref><ref type="bibr" target="#b14">16,</ref><ref type="bibr" target="#b21">23]</ref>. The most common design of KV stores is based on LogStructured Merge-tree (LSM-tree), which groups KV pairs into fixed-size files, e.g., the SSTables in LevelDB <ref type="bibr" target="#b5">[7]</ref>. Files are further organized into multiple levels as shown in <ref type="figure" target="#fig_0">Figure 1</ref>. KV pairs are sorted in each level except level 0. With this level-based structure, data is first flushed from memory to the lowest level, and then merged into higher levels by using compaction when this level reaches its capacity limit. Compaction inevitably causes the write amplification problem, and many recent researches focus on addressing this issue <ref type="bibr" target="#b1">[3,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b11">13]</ref>.</p><p>On the other hand, LSM-tree based KV stores also suffer from severe read amplification problem <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b19">21]</ref>  especially for large KV stores. This is mainly because a KV store contains multiple levels, and reading a KV item needs to check from the lowest level to the highest level until the data is found or all levels are checked. This process inevitably incurs multiple I/Os and amplifies the read operation. In the worst case, 14 SSTables need to be inspected <ref type="bibr" target="#b11">[13]</ref>, and even worse, if the target KV item does not exist in the store <ref type="bibr" target="#b17">[19,</ref><ref type="bibr" target="#b18">20,</ref><ref type="bibr" target="#b7">9]</ref>, then all the I/O requests are totally wasted. We point out that only one file in each level need to be examined as data in each level are kept in a sorted order, and this file can also be easily located by checking the key ranges of each file.</p><p>To reduce extra I/O requests, Bloom filters are widely used in KV stores <ref type="bibr" target="#b17">[19]</ref>. By first asking the filter to check if the requested data exists in the SSTable, extra I/Os can be reduced. However, Bloom filter has false positive, so it may return an "existence" answer even if the data does not really exist, still incurs extra I/Os to inspect the SSTable. Even though the false positive rate (FPR) can be reduced by increasing the length of filters <ref type="bibr">[2,</ref><ref type="bibr" target="#b5">7]</ref>, it will increase the memory usage. As a result, some filters may be swapped out to disks as memory is usually a scarce resource in KV stores <ref type="bibr" target="#b9">[11,</ref><ref type="bibr" target="#b6">8]</ref>. If filters are not in memory, extra I/Os must be incurred to load the filter into memory before inspecting a SSTable, and this exacerbates the read amplification. A recent work proposes to adjust the length of filters for different levels <ref type="bibr" target="#b4">[6]</ref>, while it only uses a same setting for all filters in the same level and fails to dynamically adjust the setting according to data hotness. Therefore, there still remains a challenging problem for LSM-tree-like KV stores: How to reduce the false positive rate of Bloom filters with least memory usage? In this paper, we propose ElasticBF, realizes a finegrained and elastic Bloom filter by constructing more small filters on disk and dynamically load some into memory as needed based on access frequency and data hotness. So ElasticBF can easily tune the size of filters for each SSTable in running time with the same memory usage. With the fine-grained and elastic feature, ElasticBF greatly reduces the false positive rate under limited memory space. Besides, ElasticBF is orthogonal to existing works focusing on optimizing KV store structure. Our prototype based on LevelDB demonstrates that ElasticBF can achieve up to 2.24× read throughput compared to conventional Bloom filter design in LevelDB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background &amp; Motivation</head><p>As introduced in §1, Bloom filters can be used to reduce the number of I/Os incurred in each read operation. For example, each SSTable in LevelDB is associated with a filter, which can be viewed as a bit array constructed from all the KV pairs within the SSTable by using several hash functions, and then the filter can be used to easily check the existence of a KV pair. However, Bloom filters always have false positive, and the false positive rate can be expressed as (1 − e −k/b ) k <ref type="bibr" target="#b8">[10]</ref>, where b indicates the number of bits allocated for each key, denoted by bitsper-key, and k means the number of hash functions. We point out that b determines the memory usage of a Bloom filter.</p><formula xml:id="formula_0">Since (1 − e −k/b ) k is minimized when k = ln2 · b,</formula><p>false positive rate can be represented as 0.6185 b . Based on this formula, we can easily observe the tradeoff between memory usage and false positive rate for a filter.</p><p>It is a common consensus that accesses to files usually posses locality, this is also true for KV stores. We further validate this by running an experiment with LevelDB <ref type="bibr" target="#b5">[7]</ref>. Since there is no publicly available KV workload trace <ref type="bibr" target="#b13">[15]</ref>, and YCSB <ref type="bibr" target="#b3">[5]</ref> is the standard benchmark for evaluating KV stores. We use YCSB to load a 100GB database and generate two representative workloads <ref type="bibr" target="#b10">[12]</ref> containing one million Get requests with uniform and zipfian distributions, which are provided by YCSB to simulate real-world application scenarios <ref type="bibr" target="#b3">[5]</ref>. Note that there are about 50K SSTables in a 100GB KV store, so issuing one million Get requests is enough for us to evaluate the stable behaviour of the KV store. <ref type="figure" target="#fig_1">Figure 2</ref> shows the access frequency of all SSTables, which are numbered sequentially from the lowest level to the highest level. As the level increases, the access frequency of SSTables tends to decrease, because the higher the level is, the more SSTables are accessed. Therefore, filters at lower levels need a smaller false positive rate than those at higher levels. A recent work Monkey <ref type="bibr" target="#b4">[6]</ref> maximizes the read throughput under uniform distribution by allocating more bits-perkey to filters at lower levels. We emphasize that even for SSTables in the same level, unevenness of access frequency is still very common, but Monkey does not consider the skewness within the same level.</p><p>With the consideration of access locality, it is not costeffective when using the same bits-per-key to configure all filters for different SSTables. Instead, allocating more bits-per-key for filters of hot SSTables, and allocating less bits for cold SSTables, can reduce the overall false positive rate for all requests and keep the same memory usage, because hot SSTables may receive most read requests but only account for a small portion. Therefore, it is of big significance to adjust the bits-per-key for every SSTable in a fine-grained and elastic manner so as to minimize the false positive rate with least memory usage. However, the configuration of Bloom filters is fixed, or it can only be adjusted by regenerating filters, and adjusting it dynamically through regenerating will incur a large overhead. Since SSTables are immutable, regenerating Bloom filters needs to re-read the data in SSTables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ElasticBF</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Main Idea</head><p>The access frequency varies significantly from different SSTables, and the number of hot SSTables (with high access frequency) is far less than that of cold SSTables. Thus, we could reduce the amount of extra I/Os caused due to false positive of filters by increasing the bits-perkey for filters of hot SSTables, meanwhile, we can still limit the memory overhead by decreasing the bits-perkey for filters of cold SSTables. However, the bits-perkey allocated to a filter is fixed and unable to change as long as the filter has been generated, so it is unable to dynamically adjust the allocation for different filters at running time. To address this issue, instead of directly adjusting the bits-per-key, we choose to build multiple filters when constructing each SSTable, and each filter is usually allocated with smaller bits-per-key and called filter unit, we then dynamically adjust the number of filters in memory for each SSTable by enabling some filter units and loading them into memory or disabling some in-memory filter units and simply removing them from memory. Note that we do not need to write the filter units back to the disk, because copies of these filter units are also stored in the SSTables. Thus, we achieve the elastic feature to dynamically adjust the bits-per-key or the false positive rate, so we call the scheme ElasticBF. In ElasticBF, each SSTable is initially associated with multiple filter units, as shown in <ref type="figure" target="#fig_2">Figure 3</ref>, which are generated by using different and independent hash functions based on the KV pairs within the SSTable and sequentially placed in the metadata region of the SSTable. We collectively call all the filter units assigned to a SSTable a filter group. Since multiple filter units within a filter group are independent, when querying for a key exists in the SSTable, the key must be nonexistent certainly as long as one filter unit gives a negative return. That is, only when all filter units indicate the existence of a key, we then really read out the data blocks to search the key.</p><p>One important feature of ElasticBF is that the overall false positive rate of a filter group is exactly the same as that of a single Bloom filter which uses the same number of bits-per-key allocated to all filter units within the filter group. We call this feature separability. This feature can also be easily proved. Assuming that each filter unit is a b/n bits-per-key filter, so its FPR can be expressed as 0.6185 b/n . Since hash functions used by each filter unit are independent, the FPR of n filter units can be derived as (0.6185 b/n ) n , which is exactly the same with that of a single filter with b bits-per-key. We also validate this feature via experiments by using the bloom test provided by LevelDB, and the results conform with the analysis.</p><p>ElasticBF provides a way to dynamically adjust Bloom filters during running time, and based on the feature of separability, the memory usage can also be limited by enabling more filter units for hot SSTables and disabling some filter units for cold ones. However, to deploy ElasticBF in a KV store, there still remain two challenging issues: (1) How to design an adjusting rule to determine the most appropriate number of filter units for each SSTable? (2) How to realize a dynamic adjustment with small overhead?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Adjusting Rule</head><p>The goal of adjusting Bloom filters for each SSTable is to reduce the extra I/Os caused due to false positive, so we use a metric which is defined as the expected number</p><note type="other">of I/Os caused by false positive to guide the adjustment, and we denote this amount of extra I/Os as E[Extra IO]. Specifically, E[Extra IO] can be expressed as E[Extra IO</note><formula xml:id="formula_1">] = ∑ n i=1 f i · f p i ,<label>(1)</label></formula><p>where n means the total number of SSTables in the KV store, f i denotes the access frequency of SSTable i, f p i denotes the false positive rate and it is determined by the number of filter units loaded in memory for SSTable i. ElasticBF adjusts the number of filter units for each SSTable only when the metric E[Extra IO] could be reduced under the fixed memory usage. It limits memory usage by fixing the total length for all filter units in the memory, that is, we keep the average bits-per-key as a fixed value. Note that SSTables which have higher access frequency will contribute more to E[Extra IO] when using the same allocation of Bloom filters, so minimizing E[Extra IO] actually results in allocating more filter units for hot SSTtables, which meets our goal exactly.</p><p>The adjustment of Bloom filter proceeds as follows. Each time when a SSTable is accessed, we first increase its access frequency by one and update E[Extra IO], then we check whether E[Extra IO] could be decreased if enabling one more filter unit for this SSTable and disabling some filter units in other SSTables so as to guarantee the same memory usage. However, one critical issue is how to quickly find which filters should be disabled but not incurring a large overhead. To address this problem, we extend Multi-Queue (MQ) <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b15">17]</ref>, and we describe its design details in next subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Dynamic Adjustment with MQ</head><p>We maintain multiple Least-Recently-Used (LRU) queues to manage the metadata of each SSTable as shown in <ref type="figure" target="#fig_3">Figure 4</ref>, and we denote these queues as Q 0 ,...,Q m , where m is equal to the maximum number of filter units allocated to each SSTable. Recall that all the filter units within a filter group are kept on disks along with the SSTable, but not all filter units are enabled, and only the enabled filter units are used for key-existence check. Each element of a queue corresponds to one SSTable and keeps the metadata of the SSTable , including the enabled filter units residing in memory. Q i manages the SSTables which already enabled exactly i filter units, e.g., each SSTable in Q 2 enabled two filter units.</p><p>To determine which filter units should be disabled and then removed from memory, we use an expiring policy which associates a variable named expiredTime with each item in MQ, and it denotes the time point at which the corresponding SSTable should be expired and selected as a candidate to adjust its Bloom filters. Precisely, expiredTime is defined as currentTime + lifeTime, where currentTime denotes the number of Get requests issued to the KV store so far, and lifeTime is a fixed constant. In practice, we let lifeTime have the same order of magnitude as the total number of SSTables, and we point out that ElasticBF is not sensitive to the value of lifeTime under this setting. Based on the above definitions, when a SSTable is inserted into a queue, its expiredTime will be initialized as currentTime + lifeTime, and at each time when the SSTable is read, its expiredTime will be updated accordingly based on the new value of currentTime. We define a SSTable as "expired" if the total number of Get requests issued to the KV store becomes larger than its expiredTime. The physical meaning is that the SSTable has not been read in the past lifeTime requests if it becomes "expired", so this SSTable can be regarded as cold and some of its filter units could be disabled. For each access, we follow the original MQ algorithm to find the "expired" SSTable <ref type="bibr" target="#b15">[17]</ref>. To avoid "expired" SSTable enabling too many filter units, we search "expired" SSTables from Q m to Q 1 , and for each queue, we search from the LRU side to the MRU side, since an "expired" SSTable must be the least recently used one. When we find an "expired" SSTable, we downgrade it to the next lower-level queue to release one filter unit, and if we encounter a not "expired" SSTable, we jump to lower-level to search "expired" SSTables. This process stops until we find enough memory space to load new filter units for the SSTable which tends to increase its filter units. If we can not find enough "expired" filters to make room for new filters, then we simply skip the Bloom filter adjustment this time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Overhead Analysis</head><p>To support runtime adjustment, ElasticBF keeps multiple filter units in each SSTable. But it require extra storage and generating these filters may also add latency to writes. First, assuming that the size of KV pairs is 1KB and ElasticBF uses four bits-per-key, so one filter units only cost around 1KB storage, and it is just 0.05% of a SSTable which is usually 2MB. Second, our experiment shows that the time of building a filter takes only around 1% of the time for constructing a SSTable on the disk. ElasticBF also leverages multi-threading to generate multiple filter units simultaneously so as to further reduce the computation time of generating filters. Therefore, the storage overhead is small and computation time is short. Besides, ElasticBF maintains multiple queues to quickly identify candidate SSTables for decreasing filter units. Since the queues we used are LRU queues, it is easy to find "expired" SSTables. The number of CPU cycles for searching is small, and it can be ignored when compared with I/O time. Extra memory overhead of MQ comes mainly from keeping expiredTime, since LSMtree based KV stores originally use a linked list to manage the metadata of SSTables. Thus, the memory overhead is also small. For example, for a 100GB KV store, there are around 50K SSTables, assuming that 4B is used to record the expiredTime of each SSTable, then the total memory overhead is only around 200KB.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Performance Evaluation</head><p>We run experiments on a machine consisting of two Intel(R) Xeon(R) E5-2650 v4 CPUs with 48-cores running at 2.2GHz, 64GB memory and 480GB SSD. The operating system is Linux 3.10.0-514. We compare ElasticBF with LevelDB which is widely used KV store, and use the benchmark YCSB-C <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b16">18]</ref>, which is the C++ version of YCSB <ref type="bibr" target="#b3">[5]</ref> for evaluation. We set the KV pair size as 1KB, and set the lifeTime of ElasticBF as 20K as there are around 50K SSTables in total in our evaluation. Since lookups of non-existent items are common in practical systems <ref type="bibr" target="#b18">[20,</ref><ref type="bibr" target="#b7">9,</ref><ref type="bibr" target="#b17">19]</ref>, we assume half of the Get requests are to lookup non-existent items, and we use direct I/O to minimize the cache influence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Read Performance</head><p>We first show the read performance of ElasticBF and LevelDB. We focus on a 100GB KV store, and let the system start from an empty cache in which no filter is buffered so as to include the overhead of loading Bloom filters. The average Bloom filter space for each key(bitsper-key) is four bits. We issue one million Get requests under different workloads which are generated by adjusting the distribution of accessed keys.  <ref type="figure">Figure 5</ref> shows the results. Because LevelDB uses the same configuration for all Bloom filters, even if the workload changes, it has little effect on read performance. We can see that ElasticBF outperforms LevelDB under all workloads, e.g., the read throughput is increased to 1.94×-2.24× under different workloads. Besides, when the workload is more skewed, the improvement becomes larger. This also validates the efficiency of taking into account access locality. To further explain the improvement of ElasticBF, we also count the total number of I/Os generated to serve the one million Get operations. We can see that the number of I/Os issued by LevelDB is around 2.42× -3.05× larger than that of ElasticBF. This is the main reason why ElasticBF achieves higher read throughput than LevelDB.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Read Performance vs Memory Usage</head><p>In this experiment, we show the read throughput by varying the bits-per-key. Note that allocating more bits for each key can reduce the false positive rate and thus improve the read performance, but it also implies a larger memory usage, so this experiment actually shows the tradeoff between read performance and memory usage. We also enable a 8MB block cache <ref type="bibr" target="#b0">[1]</ref> to cache the recently accessed blocks in this experiment, and warm it up before evaluation. <ref type="figure" target="#fig_6">Figure 6</ref> shows the experiment results. The x-axis represents the number of bits allocated for each Bloom filter for LevelDB, while for ElasticBF, we adjust the setting of filter units to guarantee the same memory usage for fair comparison. Results show that ElasticBF always has higher read throughput than LevelDB with the same memory usage. In other words, ElasticBF can achieve the same read throughput with much smaller memory usage. For example, the read throughput of ElasticBF under the setting of 4 bits-per-key is similar to that of LevelDB under the setting of 8 bits-per-key. This implies that ElasticBF can achives a similar read performance with LevelDB with only a half memory usage. However, we can find that the benefit of ElasticBF decreases if more memory can be allowed to use. In particular, when the number of bits allocated for each key is 8, the increase of read throughput reduces to 10%. However, we like to point out that allocating a large number of bits for each key may not be practical in real systems as KV stores are usually large. For example, if we allocate 8 bits-per-key for a 100TB KV store, then only the Bloom filter costs about 100GB of memory, which is too large in practical use as other metadata also needs to consume memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Write Performance</head><p>Now we evaluate the impact of ElasticBF on write performance. We compare the time to load a 100 GB KV store by using ElasticBF and LevelDB. We also consider different Bloom filter settings, while the memory usage is guaranteed to be the same. We run the experiments three times for each setting so as to obtain a stable result. As shown in <ref type="figure" target="#fig_7">Figure 7</ref>, ElasticBF has almost the same write throughout with LevelDB (4.818MB/s and 4.823MB/s separately when bits-per-key is four), and the performance difference is only around 0.1%. The main reason is that Bloom filters are organized into blocks in SSTables, which are further written to devices sequentially, and ElasticBF also uses multi-threading to speedup the generation of Bloom filters. In short, ElasticBF has negligible impact on writes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>In this paper, we developed ElasticBF, a fine-grained and elastic Bloom filter to minimize extra I/Os in KV stores. ElasticBF supports dynamic adjustment during running time by effectively determining the most appropriate number of filter units for each SSTable according to access patterns. Experimental results show that ElasticBF can greatly reduce the number of I/Os during key lookups and improve the read throughput without sacrificing write performance. More importantly, ElasticBF is orthogonal to the works optimizing the structure of KV stores, so it can be widely used to further speedup the read performance for these KV stores.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: LSM-tree based structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: File access frequencies under two different workloads.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Construction of ElasticBF</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Multi-Queue Structure in ElasticBF</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>uniform zipf 0 .</head><label>0</label><figDesc>Figure 5: Read Throughput</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Read throughput w/ different memory usage</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Time to load a KV store</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>,</head><label></label><figDesc></figDesc><table>… 

Metadata 
Region 

… 

… 

Bloom filter 
Bloom filter 

񮽙񮽙񮽙 

1…13 
24…35 
36…64 66…97 
15…23 

1…36 
32..97 
5…43 

SSTable 

Memtable 

Bloom filter 
Bloom filter 

Immutable 
Memtable 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 1 : Number of I/Os for data access</head><label>1</label><figDesc></figDesc><table></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Acknowledgements</head><p>This work was supported in part by National Nature Science Foundation of China (61772484 and 61772486). Yongkun Li is the corresponding author.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Block Cache</surname></persName>
		</author>
		<ptr target="https://github.com/facebook/rocksdb/wiki/Block-Cache" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Triad: creating synergies between memory, disk and log in log structured key-value stores</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Balmau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><forename type="middle">M</forename><surname>Didona</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Guerraoui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Zwaenepoel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konka</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
		<idno>no. EPFL-CONF-228863</idno>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="volume">17</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Unlocking memory in persistent key-value stores</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Balmau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><forename type="middle">M</forename><surname>Guerraoui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Trigonakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zablotchi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">I</forename><surname>Flodb</surname></persName>
		</author>
		<idno>no. EPFL-CONF-227333</idno>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page">2017</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Benchmarking cloud serving systems with ycsb</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cooper</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">F</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ramakr-Ishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sears</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM symposium on Cloud computing</title>
		<meeting>the 1st ACM symposium on Cloud computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="143" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Monkey: Optimal navigable key-value store</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dayan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Athanassoulis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And Idreos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data</title>
		<meeting>the 2017 ACM International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="79" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ghemawat</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dean</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leveldb</surname></persName>
		</author>
		<ptr target="https://github.com/google/leveldb" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Analysis of hdfs under hbase: a facebook messages case study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harter</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Borthakur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Aiyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arpaci-Dusseau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A versioning flash key-value store using an object-based storage model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Pitchumani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Marlette</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename><surname>Muninn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Systems and Storage</title>
		<meeting>International Conference on Systems and Storage</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Less hashing, same performance: building a better bloom filter</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kirsch</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mitzenmacher</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESA</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="456" to="467" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Atlas: Baidu&apos;s key-value storage system for cloud data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lai</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cong</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mass Storage Systems and Technologies (MSST)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
	<note>31st Symposium on</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Towards accurate and fast evaluation of multi-stage logstructured designs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lim</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Andersen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaminsky</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="149" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Separating keys from values in ssd-conscious storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Pillai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arpaci-Dusseau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Wisckey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="133" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Design and implementation of a fast and efficient scale-up key-value store</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Papagiannis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Saloustros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gonz´alezgonz´ Gonz´alez-F ´ Erez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bilas</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tucana</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="537" to="550" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Realistic request arrival generation in storage benchmarks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pitchumani</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mass Storage Systems and Technologies (MSST), 2015 31st Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Building key-value stores using fragmented log-structured merge trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raju</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kadekodi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chidambaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abraham</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Pebblesdb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th Symposium on Operating Systems Principles</title>
		<meeting>the 26th Symposium on Operating Systems Principles</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="497" to="514" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Page placement in hybrid memory systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ramos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">E</forename><surname>Gorbatov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bianchini</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the international conference on Supercomputing</title>
		<meeting>the international conference on Supercomputing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="85" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ren</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ycsb-C</surname></persName>
		</author>
		<ptr target="https://github.com/basicthinker/YCSB-C" />
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">blsm: a general purpose log structured merge tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sears</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ramakrishnan</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2012 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="217" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Wikipedia workload analysis for decentralized hosting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Urdaneta</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pierre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van Steen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="1830" to="1845" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Logbase: a scalable log-structured database system in the cloud</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">T</forename><surname>Vo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ooi</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the VLDB Endowment</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1004" to="1015" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Lsm-trie: an lsm-tree-based ultra-large key-value store for small data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 USENIX Conference on Usenix Annual Technical Conference</title>
		<meeting>the 2015 USENIX Conference on Usenix Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="71" to="82" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient and available in-memory kv-store with hybrid erasure coding and replication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="167" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The multi-queue replacement algorithm for second level buffer caches</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Philbin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="91" to="104" />
		</imprint>
	</monogr>
	<note>General Track</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
