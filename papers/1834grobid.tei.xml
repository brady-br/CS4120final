<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:12+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Mahimahi: Accurate Record-and-Replay for HTTP Mahimahi: Accurate Record-and-Replay for HTTP</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>July 8-10. 2015</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ravi</forename><surname>Netravali</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anirudh</forename><surname>Sivaraman</surname></persName>
							<email>anirudh@csail.mit.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Somak</forename><surname>Das</surname></persName>
							<email>somakrdas@csail.mit.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ameesh</forename><surname>Goyal</surname></persName>
							<email>ameesh@csail.mit.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mit</forename><surname>Csail</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keith</forename><surname>Winstein</surname></persName>
							<email>keithw@cs.stanford.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hari</forename><surname>Balakrishnan</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ravi</forename><surname>Netravali</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anirudh</forename><surname>Sivaraman</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Somak</forename><surname>Das</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ameesh</forename><surname>Goyal</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keith</forename><surname>Winstein</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Mickens</surname></persName>
							<email>mickens@eecs.harvard.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">Harvard University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hari</forename><surname>Balakrishnan</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mit</forename><surname>Csail</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Stanford University</orgName>
								<address>
									<addrLine>James Mickens</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">MIT CSAIL</orgName>
								<orgName type="institution" key="instit1">Harvard University</orgName>
								<orgName type="institution" key="instit2">Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Mahimahi: Accurate Record-and-Replay for HTTP Mahimahi: Accurate Record-and-Replay for HTTP</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2015 USENIX Annual Technical Conference (USENIC ATC &apos;15)</title>
						<meeting>the 2015 USENIX Annual Technical Conference (USENIC ATC &apos;15) <address><addrLine>Santa Clara, CA, USA</addrLine></address>
						</meeting>
						<imprint>
							<biblScope unit="page">417</biblScope>
							<date type="published">July 8-10. 2015</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 2015 USENIX Annual Technical Conference (USENIX ATC &apos;15) is sponsored by USENIX. https://www.usenix.org/conference/atc15/technical-session/presentation/netravali USENIX Association</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>This paper presents Mahimahi, a framework to record traffic from HTTP-based applications, and later replay it under emulated network conditions. Mahimahi improves upon prior record-and-replay frameworks in three ways. First, it is more accurate because it carefully emulates the multi-server nature of Web applications, present in 98% of the Alexa US Top 500 Web pages. Second, it isolates its own network traffic, allowing multiple Mahimahi instances emulating different networks to run concurrently without mutual interference. And third, it is designed as a set of composable shells, providing ease-of-use and ex-tensibility. We evaluate Mahimahi by: (1) analyzing the performance of HTTP/1.1, SPDY, and QUIC on a corpus of 500 sites, (2) using Mahimahi to understand the reasons why these protocols are suboptimal, (3) developing Cumu-lus, a cloud-based browser designed to overcome these problems, using Mahimahi both to implement Cumulus by extending one of its shells, and to evaluate it, (4) using Mahimahi to evaluate HTTP multiplexing protocols on multiple performance metrics (page load time and speed index), and (5) describing how others have used Mahimahi.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>HTTP is the de facto communication protocol for clientserver applications today <ref type="bibr" target="#b24">[27]</ref>. Beyond its widespread use as an application-layer protocol for loading Web pages, HTTP is now used for mobile apps <ref type="bibr" target="#b19">[22]</ref>, video streaming <ref type="bibr" target="#b11">[14]</ref>, and instant messaging <ref type="bibr" target="#b16">[19]</ref>.</p><p>It is useful to evaluate the performance of these applications under controlled experimental conditions. For example, browser developers may wish to evaluate how changes to their document object model (DOM) and JavaScript parsers affect Web page load times, while network-protocol designers might want to understand the application-level impact of new multiplexing protocols like QUIC <ref type="bibr" target="#b27">[30]</ref>. Similarly, a mobile app developer may wish to determine the user-perceived latency <ref type="bibr" target="#b25">[28]</ref> for user interactions over different wireless networks.</p><p>Motivated by such questions, we developed Mahimahi 1 , a framework to record traffic from applications that use HTTP, and later replay recorded traffic under emulated network conditions. Mahimahi works with any application that uses HTTP or HTTPS. Application clients (Web browsers, video players, and <ref type="bibr" target="#b0">1</ref> Mahimahi was previously introduced in a demo <ref type="bibr" target="#b20">[23]</ref>. apps within mobile-phone emulators) can be run unmodified within Mahimahi. Additionally, Mahimahi's replay semantics can be extended to support the server-side logic of many applications, such as YouTube.</p><p>Mahimahi has three notable features that distinguish it from other record-and-replay tools such as Google's web-page-replay <ref type="bibr">[11]</ref> and Fiddler <ref type="bibr" target="#b32">[34]</ref>:</p><p>1. Accuracy: Mahimahi is careful about emulating the multi-server nature of Web applications. Instead of responding to all requests from a single server, Mahimahi creates a separate server for each distinct server contacted while recording. We find that emulating multiple servers is a key factor in accurately measuring Web page load times ( ยง4.1). 2. Isolation: Using Linux's network namespaces <ref type="bibr" target="#b5">[7]</ref>, Mahimahi isolates its traffic from the rest of the host system, allowing multiple instances of its shells to run in parallel with no mutual interference ( ยง4.2). Because other tools modify the network configuration of the entire host <ref type="bibr">[11,</ref><ref type="bibr" target="#b32">34]</ref>, they cannot provide this feature. 3. Composability and extensibility: Mahimahi is structured as a set of UNIX shells, allowing the user to run unmodified client binaries within each shell.</p><p>RecordShell allows a user to record all HTTP traffic for any process spawned within it. ReplayShell replays recorded content using local servers that emulate the application servers. To emulate network conditions, Mahimahi includes DelayShell, which emulates a fixed network propagation delay, and LinkShell, which emulates both fixed-capacity and variable-capacity links. These shells can be nested within one another, allowing the user to flexibly experiment with many different network configurations. Mahimahi makes it easy to modify these shells and add new ones; e.g., to record-and-replay YouTube videos, emulate packet losses, implement active queue management algorithms, etc. ( ยง4.3). We used Mahimahi to evaluate Web multiplexing protocols. We were able to easily extend Mahimahi to support QUIC, a new protocol in active development at Google. We compared HTTP/1.1, SPDY <ref type="bibr">[3]</ref>, and QUIC to a hypothetical optimal protocol and found that all three are suboptimal. We then used Mahimahi to understand the shortcomings of these multiplexing protocols. We found that each protocol is suboptimal because of the request serialization caused by source-level object dependencies present in today's Web pages. Resolving each dependency requires an RTT between the client and ori-  <ref type="table">Table 1</ref>: Median, 75%ile page load times, in seconds, for the Alexa US Top 500 sites for different link rates and the same minimum RTT (120 ms). Comparing the median page load times, Cumulus is between 18-33% of the hypothetical optimal, outperforming the best of the other schemes (shown in each row in italics) by between 19% to 80% in these configurations. Moreover, we show later that as RTT grows, the gap from optimal for HTTP/1.1, SPDY and QUIC grows quickly, whereas Cumulus is a lot closer to optimal.</p><p>gin Web servers; Mahimahi allowed us to pinpoint the problem because we were able to conduct a large number of emulation experiments under different network conditions quickly. We used these findings to develop Cumulus, a new system to improve HTTP application performance, especially on long-delay paths. Cumulus has two components: the "Remote Proxy," a headless browser that the user runs on a well-provisioned cloud server, and the "Local Proxy," a transparent, caching HTTP proxy that runs on the user's computer. These two components cooperate to move the resolution of object dependencies closer to origin Web servers, reducing the effective RTT. Mahimahi's shell structure allowed us to implement Cumulus with ease by adapting RecordShell to implement the Local Proxy.</p><p>To evaluate Cumulus, we used Mahimahi yet again, this time on the same large number of network configurations used to understand HTTP/1.1, SPDY, and QUIC.</p><p>Our key result is that page load times with Cumulus do not degrade dramatically with increasing round-trip times (RTTs), unlike the other multiplexing protocols. Some representative results are shown in <ref type="table">Table 1</ref>. We have also evaluated Cumulus on AT&amp;T's live cellular network in Boston, finding that it outperforms existing Web accelerators such as Opera Turbo <ref type="bibr" target="#b0">[1]</ref> and Chrome Data Compression Proxy <ref type="bibr" target="#b12">[15]</ref>.</p><p>Mahimahi has been used in other projects, including an analysis of mobile app traffic patterns to compare single-path and multi-path TCP <ref type="bibr" target="#b10">[13]</ref>, and an evaluation of intelligent network selection schemes <ref type="bibr" target="#b9">[12]</ref>. Mahimahi has also been used in Stanford's graduate networking course <ref type="bibr" target="#b39">[41]</ref> and at Mozilla to understand and improve networking within browsers. Mahimahi and our experimental data are available under an open source license at http://mahimahi.mit.edu. Mahimahi has been queued for inclusion with the Debian distribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>This section describes prior work on Web record-andreplay tools and network emulation frameworks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Record-and-replay tools</head><p>The most prominent Web page record-and-replay tools are Google's web-page-replay <ref type="bibr">[11]</ref> and Telerik's Fiddler <ref type="bibr" target="#b32">[34]</ref>. web-page-replay uses DNS indirection to intercept HTTP traffic during both record and replay, while Fiddler adjusts the system-wide proxy settings in the Windows networking stack. With both tools, all HTTP requests from a browser are sent to a proxy server that records the request and forwards it to the corresponding origin server. Responses also pass through the proxy server and are recorded and sent back to the browser.</p><p>Both tools suffer from two shortcomings. First, because they serve all HTTP responses from a single server, neither tool preserves the multi-server nature of Web applications. Consolidating HTTP resources onto a single server during replay allows browsers to use a single connection to fetch all resources, which is impossible when resources are on different servers. Mahimahi faithfully emulates the multi-server nature of Web applications, leading to more accurate measurements ( ยง4.1).</p><p>Second, these tools do not provide isolation: the network conditions that web-page-replay and Fiddler emulate affect all other processes on the host machine. These include the link rate, link delay, and DNS indirection settings for web-page-replay, and the system proxy address, specified in the Windows networking stack, for Fiddler. During replay, this lack of isolation could lead to inaccurate measurements if cross traffic from other processes reaches the replaying proxy server. The lack of isolation also precludes multiple independent instances of web-page-replay or Fiddler from running concurrently-a useful feature for expediting experiments, or for experimenting with different applications concurrently. Mahimahi overcomes these problems by using Linux's network namespaces <ref type="bibr" target="#b5">[7]</ref>.</p><p>Other record-and-replay tools such as Timelapse/Dolos <ref type="bibr" target="#b6">[8]</ref> and <ref type="bibr">WaRR [6]</ref> target reproducible application debugging by capturing program executions (including user input and activity) and replaying them, while providing popular debugging abstractions including breakpoints. These systems are complementary to Mahimahi; they can be run within ReplayShell, which ensures that served HTTP content, including dynamic content such as JavaScript, does not vary during replay.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Emulation Frameworks</head><p>Tools like dummynet <ref type="bibr" target="#b8">[10]</ref> and netem <ref type="bibr" target="#b17">[20]</ref> emulate network conditions including link rate, one-way delay, and stochastic loss. Mahimahi uses its own network emulation shells, LinkShell and DelayShell. Unlike dummynet and netem, LinkShell can emulate variable-rate cellular links, in addition to static link rates, because it runs over packet-delivery traces. Mahimahi also allows users to evaluate new in-network algorithms (instead of Drop Tail FIFO) by modifying the source code of LinkShell. A similar evaluation using web-page-replay would require developing a new kernel module for dummynet, a more complicated task.</p><p>Mahimahi is general enough to record and replay any HTTP client-server application under emulated conditions. It is, however, limited in that it only emulates one physical client connected to an arbitrary number of servers. Mahimahi supports a single shared link from the client to all servers, as well as multi-homed clients ( ยง5.5), allowing the evaluation of multipath-capable transport protocols such as MPTCP <ref type="bibr" target="#b22">[25]</ref>. Mahimahi cannot emulate arbitrary network topologies such as transit-stub <ref type="bibr" target="#b7">[9]</ref>; for emulating applications over such topologies, tools like Mininet <ref type="bibr" target="#b18">[21]</ref> are more suitable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">MAHIMAHI</head><p>Mahimahi is structured as a set of four UNIX shells, allowing users to run unmodified client binaries within each shell. Each shell creates a new network namespace for itself prior to launching the shell. Quoting from the man page, "a network namespace is logically another copy of the network stack, with its own routes, firewall rules, and network devices" <ref type="bibr" target="#b5">[7]</ref>. A separate network namespace minimizes disruption to the host machine during recording, prevents accidental download of resources over the Internet during replay, and ensures that the host machine is isolated from all network configuration changes that are required to evaluate an application.</p><p>RecordShell ( ยง3.1) records all HTTP traffic for subsequent replay. ReplayShell ( ยง3.2) replays previously recorded HTTP content. DelayShell ( ยง3.3) delays all packets originating from the shell by a user-specified amount and LinkShell ( ยง3.4) emulates a network link by delivering packets according to a user-specified packetdelivery trace. All components of Mahimahi run on a single physical machine (which we call the host machine) and can be arbitrarily composed with each other. For example, to replay recorded content over a cellular network with a 10 ms minimum RTT, one would run a client ap- plication inside DelayShell inside LinkShell inside ReplayShell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">RecordShell</head><p>RecordShell <ref type="figure" target="#fig_0">(Figure 1a</ref>) records HTTP data and stores it on disk in a structured format for subsequent replay. On startup, RecordShell spawns a man-in-the-middle proxy on the host machine to store and forward all HTTP traffic both to and from an application running within RecordShell. To operate transparently, RecordShell adds an iptable rule that forwards all TCP traffic from within RecordShell to the man-in-the-middle proxy.</p><p>When an application inside RecordShell attempts to connect to a server, it connects to the proxy instead. The proxy then establishes a TCP connection with the application, uses the SO ORIGINAL DST socket option to determine the server's address for the connection, and connects to the server on the application's behalf. An HTTP parser running at the proxy captures traffic passing through it to parse HTTP requests and responses from TCP segments. Once an HTTP request and its corresponding response have both been parsed, the proxy writes them to disk, associating the request with the response. At the end of a record session, a recorded directory consists of a set of files, one for each HTTP requestresponse pair seen during that session.</p><p>SSL traffic is handled similarly by splitting the SSL connection and establishing two separate SSL connections: one between the proxy and the application and another between the proxy and the server. The proxy can establish a secure connection with the application in two ways. In the first approach, RecordShell's proxy uses a new Root CA, in the same way Fiddler does <ref type="bibr" target="#b33">[35]</ref>. Clients must manually trust this CA once and individual certificates are signed by this Root CA.</p><p>Another approach is for RecordShell's proxy to use a self-signed certificate. This approach may trigger warn-ings within applications that only accept certificates signed by any one of a list of trusted Certificate Authorities (CAs). Most modern browsers allow users to disable these warnings. Certain applications, such as mobile phone emulators, do not allow these warnings to be disabled; the first approach handles these applications <ref type="bibr" target="#b29">[31]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">ReplayShell</head><p>ReplayShell <ref type="figure" target="#fig_0">(Figure 1b</ref>) also runs on the test machine and mirrors the server side of Web applications using content recorded by RecordShell. ReplayShell accurately emulates the multi-server nature of most Web applications today by spawning an Apache 2.2.22 Web server for each distinct IP/port pair seen while recording. Each server handles HTTPS traffic using Apache's mod ssl module and may be configured to speak HTTP/1.1 or SPDY (using mod spdy).</p><p>To operate transparently, ReplayShell binds each Apache server to the same IP address and port number as its recorded counterpart. To do so, ReplayShell creates a separate dummy (virtual) interface for each distinct server IP. These interfaces can have arbitrary IPs because they are in a separate network namespace.</p><p>All client requests are handled by one of ReplayShell's servers, each of which can read all of the previously recorded content. Each server redirects all incoming requests to a CGI script using Apache's mod rewrite module. The CGI script on each server compares each incoming HTTP request to the set of all recorded requestresponse pairs to locate a matching request and return the corresponding response. Incoming requests may be influenced by local state present in the client application (e.g. time-sensitive query string parameters) and may not exactly match any recorded request. We handle such requests using a matching heuristic that enforces that some parts of the request must match exactly, while tolerating some degree of imperfection in other parts.</p><p>We expect the Host and User-Agent header fields, along with the requested resource (without the query string), to exactly match the corresponding values in some stored request. If multiple stored requests match on these properties, the algorithm selects the request whose query string has the maximal common substring to the incoming query string.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">DelayShell</head><p>DelayShell emulates a link with a fixed minimum oneway delay. All packets sent to and from an application running inside DelayShell are stored in a packet queue. A separate queue is maintained for packets traversing the link in each direction. When a packet arrives, it is assigned a delivery time, which is the sum of its arrival time and the user-specified one-way delay. Packets are released from the queue at their delivery time. This technique enforces a fixed delay on a per-packet basis. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">LinkShell</head><p>LinkShell emulates a link using packet-delivery traces. It emulates both time-varying links such as cellular links and links with a fixed link rate. When a packet arrives into the link, it is directly placed into either the uplink or downlink packet queue. LinkShell is trace-driven and releases packets from each queue based on the corresponding packet-delivery trace. Each line in the trace is a packet-delivery opportunity: the time at which an MTU-sized packet will be delivered in the emulation. <ref type="bibr" target="#b1">2</ref> Accounting is done at the byte-level, and each delivery opportunity represents the ability to deliver 1500 bytes. Thus, a single line in the trace file can correspond to the delivery of several packets whose sizes sum to 1500 bytes. Delivery opportunities are wasted if bytes are unavailable at the instant of the opportunity.</p><p>LinkShell supports live graphing of network usage and per-packet queuing delay, giving near-instantaneous feedback on the performance of applications and network protocols. Uplink and downlink capacity are calculated using the input packet-delivery traces, while network usage, in each direction, is based on the amount of data that a client application attempts to transmit or receive. Per-packet queuing delay is computed as the time each packet remains in LinkShell's uplink or downlink queues. <ref type="figure" target="#fig_1">Figure 2</ref> illustrates the downlink network usage of a single Web page load of http://www.cnn.com, using Google Chrome over an emulated Verizon LTE cellular network with a minimum RTT of 100 ms. As shown, Web servers try to exceed the link capacity at around 9.3 seconds into the trace.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">NOVELTY</head><p>Mahimahi introduces three new features in comparison to existing record-and-replay tools. We describe each of these in greater detail below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Multi-server emulation for greater accuracy</head><p>A key component of ReplayShell is that it emulates the multi-server nature of Web applications. As discussed in ยง3, ReplayShell creates a network namespace containing an Apache server for each distinct server encountered in a recorded directory. We show through three experiments that emulating this multi-server nature is critical to the accurate measurement of Web page load times.</p><p>A large number of websites today are multi-server. We measure the number of physical servers used by each site in the the Alexa US Top 500 <ref type="bibr" target="#b3">[5]</ref>. We find that the median number of servers is 20, the 95%ile is 51, and the 99%ile is 58. Only 9 of the 500 Web pages (1.8%) we consider use a single server.</p><p>Next, we illustrate the importance of preserving the multi-server nature of Web applications by comparing measurements collected using ReplayShell and webpage-replay to real page load times on the Internet. To obtain measurements on the Internet, we use Selenium to automate Google Chrome loading 20 Web pages from the Alexa US Top 500, 25 times each, inside a LinkShell of 5 Mbits/s and a DelayShell with a minimum RTT of 100 ms. We chose a minimum RTT of 100 ms to equalize delays to Web servers contacted while loading each Web page. <ref type="bibr">3</ref> For a fair comparison, we record copies of each Web page with RecordShell and web-page-replay immediately following the completion of these Internet measurements; Web content can change frequently, which can significantly affect page load time. We then replay each recorded Web page 25 times using ReplayShell, a modified version of ReplayShell that serves all resources from a single server, and web-page-replay. With ReplayShell, we perform each page load inside LinkShell with a 5 Mbits/s trace and DelayShell with a minimum RTT of 100 ms, as described above. We emulate these same network conditions with web-page-replay.</p><p>We define the error, per site, as the absolute value of the percent difference between mean page load times (over 25 runs) within an emulation environment and on the Internet. As shown in <ref type="figure" target="#fig_2">Figure 3</ref>, ReplayShell with multi-server emulation yields page load times that most accurately resemble page load times collected on the Internet. The median error is 12.4%, compared to 36.7% and 20.5% with web-page-replay and single-server ReplayShell, respectively. 4 <ref type="bibr">3</ref> The 20 sites used here are all hosted by CDNs in close proximity with ping times of less than 5 ms. <ref type="bibr" target="#b2">4</ref> We are not certain why single-server ReplayShell is so much more accurate than web-page-replay.   Finally, we run more exhaustive experiments to show the effect that multi-server emulation has on Web page load times across different network conditions. Using an Amazon EC2 m3.large instance located in the USeast-1a region and running Ubuntu 13.10, we measure page load times for each recorded page in the Alexa US Top 500 when loaded with Google Chrome. We consider 9 different configurations: link rates in {1, 14, 25} Mbits/s and RTTs in {30, 120, 300} ms. We load each page over each configuration using both ReplayShell and the modified version of ReplayShell used above that eliminates the multi-server nature altogether by setting up one Apache server to respond to all HTTP requests and resolving all DNS queries to that server alone. <ref type="table" target="#tab_2">Table 2</ref> shows the median and 95%ile difference in page load time when multi-server nature is not preserved, compared to when multi-server nature is preserved. Although the page load times are comparable over a 1 Mbit/s link, the lack of multi-server emulation yields significantly worse performance at higher link rates.   erty of Mahimahi, along with the fact that its shells can be arbitrarily nested, enables many different configurations to be simultaneously tested on a host machine, in complete isolation from one another.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Isolation</head><p>Using distinct network namespaces for each shell also enables Mahimahi to produce reproducible results while imposing low overhead on collected measurements. Reproducibility: To evaluate the reproducibility of Mahimahi's measurements, we perform repeated experiments on the same host machines and across different host machines with similar hardware specifications. We choose two sites from the Alexa US Top 500 for this experiment, http://www.cnbc.com/ and http: //www.wikihow.com/, as they are are at the median and 95%ile site sizes (1.2 MB and 5.5 MB, respectively).</p><p>We use two different Amazon EC2 m3.large instances, each in the US-east-1a region and running Ubuntu 13.10. On each machine, we load the CNBC and wikiHow Web pages 100 times each inside ReplayShell, over a 14 Mbits/s link with a minimum RTT of 120 ms. <ref type="table" target="#tab_4">Table 3</ref> shows a summary of the distribution of page load times from these experiments. Mean page load times for each site are less than 0.5% apart across the two machines suggesting that Mahimahi produces comparable results across different host machines. Similarly, standard deviations are all within 1.6% of their corresponding means, implying that Mahimahi produces consistent results on a single host machine. Fidelity: Mahimahi's shells impose low overhead on collected measurements, even when they are nested within one another, leading to high fidelity in the results. We illustrate this property in <ref type="figure" target="#fig_3">Figure 4</ref>, which shows the overhead DelayShell and LinkShell impose on page load time measurements. We first load our recorded copies of the Alexa US Top 500 sites inside ReplayShell, without LinkShell or DelayShell. For comparison, we then load the 500 sites inside DelayShell, with 0 ms fixed per-packet delay, inside ReplayShell. Separately, we load the 500 sites inside LinkShell, with 1000 Mbits/s uplink and downlink traces, inside ReplayShell. <ref type="bibr" target="#b3">5</ref> Each of these experiments was performed on the same Amazon EC2 m3.large instance configured with Ubuntu 13.10 and located in the US-east-1a region. We find that the median per-site errors with DelayShell and LinkShell, relative to ReplayShell alone, are 0.33% and 0.31%, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Composability and extensibility</head><p>Unmodified application clients can be run within any of Mahimahi's shells. For instance, as described in ยง5.5, a mobile device emulator can be run within Mahimahi to measure mobile app performance. Similarly, to measure new performance metrics such as the speed index, virtual machines can be run within Mahimahi's shells ( ยง5.4).</p><p>The default replay algorithm is but one instance of a server-side HTTP matching algorithm. Mahimahi's replay semantics can be easily extended to support the server-side logic of many other applications and multiplexing protocols; for example, in ยง5.1.1, we extend ReplayShell to use QUIC Web servers rather than default Apache Web servers. It has also been extended to handle record-and-replay for YouTube videos ( ยง5.5).</p><p>In addition to DelayShell and LinkShell, which emulate different minimum RTTs and link rates, Mahimahi can be extended to support other network characteristics. For example, to emulate different levels of stochastic packet loss, we created LossShell <ref type="bibr" target="#b21">[24]</ref>, which probabilistically drops packets stored in LinkShell's upstream and downstream queues. Similarly, Mahimahi can be modified to evaluate in-network algorithms such as queuing disciplines. By default, LinkShell implements a Drop Tail FIFO queue, but we have extended it to implement CoDel, an active queue management scheme <ref type="bibr" target="#b30">[32]</ref>.</p><p>Mahimahi could also be used to replay recorded content to a different physical machine. Consider a scenario where the application to be evaluated is only available on Machine M, and a separate Linux Machine, A, is available. An EthShell could ferry packets from an Ethernet interface between M and A to a virtual network interface on A. Analogously, a UsbShell could ferry packets between an Ethernet-over-USB interface connected to a phone and a virtual interface on A. UsbShell could be used to run performance regression tests on actual phones rather than emulators. Neither of these has been developed yet, but Mahimahi's design allows these shells to be nested inside any of Mahimahi's existing shells. For instance, to test a mobile phone's browser over an LTE link with a 100 ms RTT, we would nest UsbShell inside DelayShell inside LinkShell inside ReplayShell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CASE STUDIES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Understanding Web Performance</head><p>We use Mahimahi to evaluate Web page load times under three multiplexing protocols: HTTP/1.1, SPDY <ref type="bibr">[3]</ref>, and QUIC <ref type="bibr" target="#b27">[30]</ref>, a protocol currently in development at Google. To put these measurements in context, we compare each protocol with an optimal protocol for each network configuration.</p><p>To automate the page load process and measure page load times, we use Selenium, a widely used browserautomation tool, along with Chrome Driver version 2.8 and the Web Driver API <ref type="bibr" target="#b36">[38]</ref>. We measure page load time by calculating the time elapsed between the navigationStart and loadEventEnd events <ref type="bibr" target="#b36">[38]</ref>.</p><p>In all evaluations, traffic originates from the Web browser alone. We emulate link rates and minimum RTTs ( ยง3), but do not emulate competing cross traffic. For each network configuration, we emulate a buffer size of 1 bandwidth-delay product and evaluate all sites in the Alexa US Top 500. SPDY: To evaluate SPDY, we create SPDYShell, which enables the mod spdy extension on all Apache servers within ReplayShell. The SPDY configuration evaluated here does not include server push because the push policy is specific to each website and is hard to infer automatically. If push policies were known, however, the CGI script within ReplayShell's servers could be modified to reflect them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Setup</head><p>QUIC: QUIC inherits several SPDY features, such as multiplexing streams onto a single transport-protocol connection and stream priorities. By using UDP and its own security instead of TCP and TLS, QUIC overcomes two drawbacks of SPDY: head-of-line blocking between streams due to lost packets and the three-way handshake required to establish a secure connection.</p><p>Unlike SPDY, Apache currently has no extensions for QUIC. We create QUICShell by replacing Apache within ReplayShell with an adapted version of the QUIC toy server <ref type="bibr" target="#b26">[29]</ref> from the Chromium project (commit 5bb5b95 from May, 2015, available at https://goo. gl/Jdr8hi). We modify the toy server, which originally searched for exact URL matches, to use the matching semantics in ReplayShell's CGI script.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Optimal page load time</head><p>We define the optimal page load time for a website as:</p><p>minimumRTT + (siteSize/linkRate) + browserTime.</p><p>The first term represents the minimum time between when the first HTTP request is made at the client and the first byte of the first HTTP response is received by the client, ignoring processing time at the server.</p><p>The second term represents the minimum time to transfer all bytes belonging to the Web page over a fixed capacity link. We calculate the site size by counting the total number of bytes delivered over the emulated link from the Web servers to the browser between the navigationStart and loadEventEnd events.</p><p>The third term represents the time for the browser to process all the HTTP responses and render the Web page (using the definition of "loaded" above). We measure this as the page load time in ReplayShell alone without network emulation, emulating an infinite-capacity, zerodelay link.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3">Canonical network results</head><p>We evaluate each protocol on 110 configurations: link rates in {0.2, 0.3, 0.6, 1, 1.7, 2.9, 5, 8.5, 14, 25} Mbits/s and RTTs between 0 ms and 300 ms in steps of 30 ms. These link rates and RTTs cover the majority of global network conditions reported by Akamai <ref type="bibr" target="#b2">[4]</ref>. We also perform evaluations over cellular networks using modified versions of the Verizon and AT&amp;T traces collected in <ref type="bibr" target="#b38">[40]</ref>. For each network configuration, we compare HTTP/1.1, SPDY, and QUIC (and in the next subsection, Cumulus) with the optimal page load times defined above. <ref type="figure">Figure 5</ref> shows the distributions of page load times with each protocol for six of these configurations: 1 Mbit/s and 25 Mbits/s, with RTTs of 30 ms, 120 ms, and 300 ms. We find that the gap from optimal for HTTP/1.1, SPDY, and QUIC grows quickly with the RTT, and grows with the link rate (although not as quickly). For example, on a 1 Mbit/s link with a minimum RTT of 30 ms, the median page load time for SPDY is 1.08ร worse than optimal. When the minimum RTT increases to 120 ms, the median SPDY page load time is 1.63ร worse than optimal, worsening to 2.02ร worse than optimal when the minimum RTT rises to 300 ms. For this RTT, increasing the link rate from 1 Mbit/s to 25 Mbits/s degrades median SPDY performance to 4.93ร worse than optimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.4">Understanding suboptimality</head><p>In addition to quantifying the extent of suboptimality of multiplexing protocols for the Web, the results presented in this case study corroborate the qualitative findings of many previous measurement studies <ref type="bibr" target="#b23">[26,</ref><ref type="bibr" target="#b35">37,</ref><ref type="bibr" target="#b37">39]</ref>. We used Mahimahi in conjunction with browser developer tools to identify the root cause of this suboptimality. We found that the suboptimal performance of each multiplexing protocol is a result of request serialization caused by source-level dependencies between objects on a Web page; this problem is exacerbated by small limits on the number of concurrent connections from the browser, but persists even if those browser limits are removed.  The fundamental issue is that resolving each dependency requires a round-trip communication between the client and origin Web servers. As a result, the negative effect of request serialization is more pronounced at high RTTs ( <ref type="figure">Figure 5</ref>). This finding motivated us to develop Cumulus, a system that uses Mahimahi to improve page load times on long-delay paths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Improving Web performance with Cumulus</head><p>Cumulus has two components: the "Remote Proxy," a headless browser that the user runs on a well-provisioned cloud server, and the "Local Proxy," a transparent, caching HTTP proxy that runs on the user's computer. These two components cooperate to move the resolution of object dependencies closer to origin Web serversreducing the effective RTT-without modifying Web browsers or servers.</p><p>The Remote Proxy listens for new requests from the Local Proxy. For each incoming request, the Remote Proxy launches an unmodified RecordShell and runs a headless browser, PhantomJS <ref type="bibr" target="#b1">[2]</ref>, to load the specified URL using the original HTTP headers. Once the page is loaded, the Remote Proxy packages and compresses the recorded HTTP request/response pairs into a bulk response, which it sends to the Local Proxy.</p><p>The Local Proxy is a modified version of RecordShell that caches HTTP objects rather than storing them in files. When the user's browser requests a URL not resident in the Local Proxy's cache, the Local Proxy forwards the request to the Remote Proxy. Upon receiving a bulk response from the Remote Proxy, the Local Proxy responds to the user's browser with the appropriate response and caches the remaining objects to handle subsequent browser requests. <ref type="figure">Figure 6</ref> illustrates how Cumulus loads a single Web page.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Evaluating Cumulus with Mahimahi</head><p>We first evaluate Cumulus over each emulated network configuration listed in ยง5.1.3. Page loads with Cumulus used Google Chrome and a Remote Proxy running on the other side of each emulated link. We find that Cumulus outperforms SPDY by 1.03-3.60ร over these configurations ( <ref type="figure">Figure 5</ref>). <ref type="figure">Figure 7</ref> shows how the ratio between median page load times with each protocol and the optimal varies as RTTs increase at fixed link rates. We find that Cumulus is less affected by increases in RTT compared to today's multiplexing protocols. For example, at a link rate of 14 Mbits/s and an RTT of 60 ms, Cumulus is 1.13ร worse than optimal while SPDY is 1.44ร worse than optimal. When RTT increases to 180 ms, Cumulus is 1.39ร worse, whereas SPDY is 2.61ร worse than optimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Some live experiments</head><p>We also compare the performance of Google Chrome run inside Cumulus with Chrome, and with Chrome Data Compression Proxy <ref type="bibr" target="#b12">[15,</ref><ref type="bibr" target="#b13">16]</ref> and Opera Turbo <ref type="bibr" target="#b0">[1]</ref>, which are cloud browsers that use proxy servers for compression. We load each page in the Alexa US Top 500 five times with each system, rotating among the systems under test to mitigate the effects of network variability. We define Cumulus's "speedup" relative to a system as the ratio of the page load time using that system to the page load time using Cumulus.</p><p>We ran experiments over the live AT&amp;T LTE/GSM/WCDMA cellular network in Boston using a   <ref type="figure">Figure 8</ref> shows the CDF of speedups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Understanding Cumulus' gains</head><p>Cumulus moves dependency resolution to the Remote Proxy where RTTs to Web servers are lower than from the client. The benefit of this technique depends on: 1. The RTT between the user and origin Web servers.</p><p>2. The complexity of the Web page.</p><p>To understand the importance of each factor, we use Mahimahi's shell abstraction to load two Web pages in emulation: TMZ's homepage with 508 objects and the Google homepage with only 15 objects. We use DelayShell to emulate fixed minimum RTTs from 0 ms to 400 ms. For each RTT, we load each page five times with Chrome Data Compression Proxy-which compresses objects in-flight, but does not perform dependency resolution on the user's behalf-and Cumulus, which performs dependency resolution and compresses objects inflight.</p><p>Page loads with Cumulus used a Remote Proxy running on the other side of the emulated long-delay link. Speedups for Cumulus relative to Chrome Data Compression Proxy are shown in <ref type="figure" target="#fig_7">Figure 9</ref>.</p><p>We observe two trends:</p><p>1. For a given Web page, speedups with Cumulus increase as RTT increases. 2. For a fixed RTT, speedups with Cumulus are larger for more complex Web pages. Our results show a 4ร speedup relative to Chrome Data Compression Proxy at an RTT of 100 ms, a typical RTT for cellular and transcontinental links. This corroborates the well-known intuition that Web page load times are dominated by network latencies rather than link rates, and suggests that the combination of remote dependency resolution and object compression helps Cumulus achieve performance not far from optimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Speed index</head><p>All of our measurements thus far have been of page load time. We now show that it is straightforward to use a different performance metric. We use Google's proposed speed index <ref type="bibr" target="#b14">[17]</ref> as an example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.1">Definition</head><p>Page load time may not accurately measure when a page is usable by the client. For long Web pages, content "above-the-fold" of the screen is important to retrieve quickly, but other content may not be. Taking this point into consideration for measurement is especially relevant for pages that support infinite scrolling. For example, Facebook "preloads" wall postings below the user's current location on its page in anticipation of a user scroll. In such cases, the "onload" event used to measure page load time would fire long after the page is ready for user interaction. Speed index is an attempt to address this issue.</p><p>Speed index tracks the visual progress of a Web page in the visible display area. A lower speed index signifies that the content is rendered more quickly. For example, a page that immediately paints 90% of its visual content will receive a lower speed index than a page that progressively paints 90% of its content, even if both pages fire their onload event at the same time.</p><p>Speed index is calculated by measuring the completeness of a page's display area over time. Completeness is defined as the pixel-by-pixel difference of a page snapshot with the final loaded Web page. Once the entire page has loaded, the completeness percentage of the page rendering over time is plotted. Speed index is defined as the area "above-the-curve" <ref type="figure" target="#fig_0">(Figure 10a)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.2">Measuring speed index</head><p>We calculate speed index using WebPagetest <ref type="bibr" target="#b14">[17]</ref>, which records videos of page loads at 10 frames per second   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.3">Optimal speed index</head><p>Calculating an optimal speed index is difficult. Instead, we define an upper bound 6 on the optimal speed index. We assume that a site renders in one shot at the optimal page load time; <ref type="figure" target="#fig_0">Figure 10b</ref> illustrates its implications on the "optimal" speed index. As shown, the percentage completeness of a given Web page is 0% until the optimal page load time where the percentage completeness jumps to 100%. As a result, the "area above the curve," or optimal speed index, equals the optimal page load time. There could be better rendering strategies that more gradually render the page between 0 and the optimal page load time, but such improved characterizations of the optimal speed index will only further increase the already large slowdowns <ref type="figure" target="#fig_0">(Figure 11</ref>) from the optimal speed index.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.4">Static link results</head><p>We measure the speed index for each site in the Alexa US Top 500 over networks with link rates between 1 Mbit/s and 25 Mbits/s and a fixed minimum RTT of 120 ms ( <ref type="figure" target="#fig_0">Figure 11</ref>). We notice similar patterns to those discussed with page load times: the gap between speed index with HTTP/1.1 and optimal speed index grows as link rates increase; over a 1 Mbit/s link with a 120 ms minimum RTT, speed index with HTTP/1.1 is 1.52ร worse than optimal at the median, while over a 25 Mbits/s link with a 120 ms minimum RTT, the median speed index with HTTP/1.1 is 3.63ร worse than optimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">External case studies</head><p>This section describes external use cases of Mahimahi in research, educational, and industrial settings. Mobile app record-and-replay: RecordShell has been used to characterize mobile app traffic by recording all HTTP traffic to and from mobile apps running inside an Android emulator <ref type="bibr" target="#b10">[13]</ref>. Using this recorded traffic, they evaluated the performance of mobile apps over Wi-Fi and LTE networks by running an Android emulator inside ReplayShell to measure the duration of data transfers for mobile apps over these wireless networks. The results showed that LTE outperforms Wi-Fi 40% of the time on flow completion time. Mobile multi-homing: To emulate mobile multihoming with Wi-Fi and LTE, the authors in <ref type="bibr" target="#b9">[12]</ref> extended LinkShell to create <ref type="bibr">MpShell [33]</ref>. They then compared single-path TCP and MPTCP by replaying mobile app traffic over 20 different emulated network conditions. Record-and-replay for video streaming: Mahimahi has been extended to handle record and replay for YouTube videos <ref type="bibr" target="#b34">[36]</ref>. Compared to Web pages, video replay requires more involved matching logic on the server side. HTTP requests encode the location (start and end time) and quality of video chunks requested by the client's video player. Both the location and quality attributes can change significantly from run to run, and between record and replay. Educational uses: Mahimahi is being used by students in Stanford's graduate networking course <ref type="bibr" target="#b39">[41]</ref> to understand the performance of their networked applications under controlled conditions. As part of a protocol design contest conducted in the same course, students used LinkShell's live graphing of network usage and perpacket queuing delay to obtain real-time feedback on the performance of their congestion-control protocols.</p><p>Browser networking: Engineers at Mozilla are using Mahimahi to improve the speed of Firefox's networking. Here, Mahimahi is helpful in understanding how improvements to link utilization and pipelining of HTTP requests affect Web performance over various networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>Mahimahi is an accurate and flexible record-and-replay framework for HTTP applications. Mahimahi's shellbased design makes it composable and extensible, allowing the evaluation of arbitrary applications and network protocols. It accurately emulates the multi-server nature of Web applications during replay, and by isolating its own traffic, allows several instances to run in parallel without affecting collected measurements.</p><p>We presented several case studies to evaluate Mahimahi and demonstrate its benefits. These include a study of HTTP/1.1, SPDY, and QUIC under various emulated network conditions. We used Mahimahi both to conduct the experiments and to understand the reasons for the suboptimality of these protocols. We then used our key finding-that these protocols are suboptimal due to source-level dependencies in Web pages-to design Cumulus. Mahimahi was useful in our implementation of Cumulus, as well as in our experiments to measure its performance. As round-trip times and link rates increase, the performance of Cumulus degrades much slower than previous HTTP multiplexing protocols.</p><p>We have released Mahimahi under an open source license at http://mahimahi.mit.edu.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: RecordShell has a transparent proxy for HTTP traffic. ReplayShell handles all HTTP traffic inside a private network namespace. Arrows indicate the direction of HTTP Request and Response traffic.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: LinkShell supports live graphing of network usage, comparing the link capacity of the input traces (red shading) to the amount of data a client application attempts to transmit (blue line).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Preserving a Web page's multi-server nature yields measurements that more closely resembles measurements on the Internet.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: DelayShell and LinkShell have a negligible effect on page load times in ReplayShell.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :Figure 6 :</head><label>56</label><figDesc>Figure 5: The gap between page load times with HTTP/1.1, SPDY, or QUIC and Optimal grows as link rate or minimum RTT increases. Cumulus is introduced in ยง5.2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :Figure 8 :</head><label>78</label><figDesc>Figure 7: Cumulus's performance does not degrade dramatically as RTTs increase (at fixed link rates), unlike HTTP/1.1, SPDY, and QUIC. Each point plots the ratio of median protocol performance to median performance of the optimal scheme (lower is better).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Benefits with Cumulus increase as RTT or Web page complexity increase.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fraction</head><label></label><figDesc>Fraction of page loaded with time Speed Index:10475.0 (a) Speed index is the area above the curve of the completeness of a page load as a function of time.of page loaded with time Opt. Page Load Time Speed Index = Opt. Page Load Time (b) We define an upper bound on optimal speed index by as- suming that a page instantaneously jumps from 0% to 100% completeness at the optimal page load time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Speed index calculation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Gap between speed index with HTTP/1.1 and Optimal grows as link rate increases (fixed minimum RTT).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Median and 95%ile difference in page load time 
without multi-server emulation. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head></head><label></label><figDesc>By creating a new network namespace for each shell, Mahimahi eliminates much experimental variability that results from interfering cross traffic during an experi- ment. Each namespace is separate from the host ma- chine's default namespace and every other namespace and thus, processes run inside the namespace of a Mahimahi tool are completely isolated from those run- ning directly on the host or in other namespaces. As a result, host machine traffic does not affect the measure- ments reported by Mahimahi. Similarly, network emu- lation done by Mahimahi's tools does not affect traffic outside of Mahimahi's network namespaces. This prop-</figDesc><table>Machine 1 
Machine 2 

CNBC 
7584 ms +-120 ms 
7612 ms +-111 ms 
wikiHow 
4804 ms +-37 ms 
4800 ms +-37 ms 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Mean and standard deviation for page load times 
across two similarly configured machines. 

0 

0.25 

0.5 

0.75 

1 

0 
1 
2 
3 
Cumulative Proportion 

Relative Percent Error 

DelayShell 0 ms 
LinkShell 1000 Mbits/s 

</table></figure>

			<note place="foot" n="2"> For example, a link that can pass one MTU-sized packet per millisecond (12 Mbits/s) can be represented by a file that contains just &quot;1&quot; (LinkShell repeats the trace file when it reaches the end).</note>

			<note place="foot" n="5"> We chose 1000 Mbits/s to ensure that link capacity was not a limiting factor in page load time.</note>

			<note place="foot" n="6"> Recall that a lower speed index is better.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">ACKNOWLEDGEMENTS</head><p>We thank Amy Ousterhout, Pratiksha Thaker, the ATC reviewers, and our shepherd, Liuba Shrira, for their helpful comments and suggestions. This material is based upon work supported in part by the National Science Foundation under Grant No. CNS-1407470. We thank the members of the MIT Center for Wireless Networks and Mobile Computing (Wireless@MIT) for their support.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Opera</forename><surname>Turbo</surname></persName>
		</author>
		<ptr target="http://www.opera.com/turbo" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Phantomjs</surname></persName>
		</author>
		<ptr target="http://phantomjs.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Akamai</surname></persName>
		</author>
		<ptr target="http://www.akamai.com/stateoftheinternet/" />
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Top sites in the United States</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexa</forename></persName>
		</author>
		<ptr target="http://www.alexa.com/topsites/countries/US" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">WaRR: A tool for high-fidelity web application record and replay</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Andrica</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DSN</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">W</forename><surname>Biederman</surname></persName>
		</author>
		<ptr target="http://man7.org/linux/man-pages/man8/ip-netns.8.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Interactive record/replay for web application debugging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Burg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">UIST</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Modeling Internet topology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Calvert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Doar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Zegura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Communications Magazine</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="160" to="163" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Carbone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Rizzo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dummynet revisited. SIGCOMM CCR</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="12" to="20" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Intelligent Network Selection and Energy Reduction for Mobile Devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Deng</surname></persName>
		</author>
		<ptr target="http://people.csail.mit.edu/shuodeng/papers/thesis.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">WiFi, LTE, or both? Measuring multi-homed wireless Internet performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Netravali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sivaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IMC</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">YouTube traffic characterization: A view from the edge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Arlitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mahanti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IMC</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Data compression proxy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Glowacki</surname></persName>
		</author>
		<ptr target="https://chrome.google.com/webstore/detail/data-compression-proxy/ajfiodhbiellfpcjjedhmmmpeeaebmep" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Data compression proxy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google</surname></persName>
		</author>
		<ptr target="https://developer.chrome.com/multidevice/data-compression" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google</surname></persName>
		</author>
		<ptr target="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">WebPagetest batch processing APIs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google</surname></persName>
		</author>
		<ptr target="https" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A study of Internet instant messaging and chat protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Jennings</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Nahum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Olshefski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z.-Y</forename><surname>Shae</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Waters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Network</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="16" to="21" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
	<note>IEEE</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An empirical study of netem network emulation functionalities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Jurgelionis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Laulajainen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hirvonen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICCCN</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">A network in a laptop: Rapid prototyping for software-defined networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lantz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Heller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<editor>HotNets</editor>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Mobile video delivery with HTTP. Communications Magazine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bartos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bhatia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Nair</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="166" to="175" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Mahimahi: A lightweight toolkit for reproducible web measurement (demo)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Netravali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sivaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Winstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Netravali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">J</forename><surname>Winstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sivaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lossshell</surname></persName>
		</author>
		<ptr target="https://github.com/ravinet/mahimahi/tree/lossshell" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Paasch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Barre</surname></persName>
		</author>
		<ptr target="http://multipath-tcp.org/" />
	</analytic>
	<monogr>
		<title level="j">TCP in the Linux kernel</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">A comparison of SPDY and HTTP performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Padhye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">F</forename><surname>Nielsen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<pubPlace>Microsoft</pubPlace>
		</imprint>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">HTTP as the narrow waist of the future Internet</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ghodsi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<editor>Hotnets</editor>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">AppInsight: Mobile app performance monitoring in the wild</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ravindranath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Padhye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Obermiller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shayandeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Experimenting with QUIC</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Roskind</surname></persName>
		</author>
		<ptr target="http://blog.chromium.org/2013/06/experimenting-with-quic.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">QUIC: Multiplexed stream transport over UDP</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Roskind</surname></persName>
		</author>
		<ptr target="https://docs.google.com/document/d/1RNHkx_" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">VvKWyWg6Lr8SZ-saqsQx7rFV-ev2jRFUoVD34/ edit</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Defeat SSL Certificate Validation for Google Android Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Rudrappa</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<pubPlace>McAfee</pubPlace>
		</imprint>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sivaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Netravali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">J</forename><surname>Winstein</surname></persName>
		</author>
		<ptr target="https://github.com/ravinet/mahimahi/releases/tag/old/codel" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sivaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Netravali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">J</forename><surname>Winstein</surname></persName>
		</author>
		<ptr target="https://github.com/ravinet/mahimahi/tree/old/mpshell_scripted" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Telerik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fiddler</surname></persName>
		</author>
		<ptr target="http://www.telerik.com/fiddler" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Telerik</surname></persName>
		</author>
		<ptr target="http://docs.telerik.com/fiddler/Configure-Fiddler/Tasks/TrustFiddlerRootCert" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vasiliev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Netravali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">J</forename><surname>Winstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sivaraman</surname></persName>
		</author>
		<ptr target="https://github.com/vasilvv/mahimahi" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">How speedy is SPDY? In NSDI</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Balasubramanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wetherall</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Navigation timing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Jain</surname></persName>
		</author>
		<ptr target="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/NavigationTiming/Overview.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-F</forename><surname>Mule</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Rice</surname></persName>
		</author>
		<ptr target="http://tools.ietf.org/html/draft-white-httpbis-spdy-analysis-00" />
	</analytic>
	<monogr>
		<title level="j">Analysis of SPDY and TCP initcwnd</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Stochastic forecasts achieve high throughput and low delay over cellular networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Winstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sivaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Your) great ideas for networked applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">J</forename><surname>Winstein</surname></persName>
		</author>
		<ptr target="https://web.stanford.edu/class/cs344g/" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
