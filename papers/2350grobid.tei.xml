<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:36+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">This paper is included in the Proceedings of the 13th USENIX Conference on File and Storage Technologies (FAST &apos;15). Open access to the Proceedings of the 13th USENIX Conference on File and Storage Technologies is sponsored by USENIX Reliable, Consistent, and Efficient Data Sync for Mobile Apps Reliable, Consistent, and Efficient Data Sync for Mobile Apps</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>February 16-19,</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Younghwan</forename><surname>Go</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nitin</forename><surname>Agrawal</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akshat</forename><surname>Aranya</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristian</forename><surname>Ungureanu</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Younghwan</forename><surname>Go</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nitin</forename><surname>Agrawal</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akshat</forename><surname>Aranya</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristian</forename><surname>Ungureanu</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory">Korea Advanced Institute of Science and Technology (KAIST) and NEC Labs</orgName>
								<orgName type="institution">NEC Labs</orgName>
								<address>
									<postCode>2015 •</postCode>
									<settlement>Santa Clara</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">NEC Labs America * KAIST †</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">This paper is included in the Proceedings of the 13th USENIX Conference on File and Storage Technologies (FAST &apos;15). Open access to the Proceedings of the 13th USENIX Conference on File and Storage Technologies is sponsored by USENIX Reliable, Consistent, and Efficient Data Sync for Mobile Apps Reliable, Consistent, and Efficient Data Sync for Mobile Apps</title>
					</analytic>
					<monogr>
						<title level="m">USENIX Association 13th USENIX Conference on File and Storage Technologies (FAST &apos;15)</title>
						<imprint>
							<biblScope unit="page">359</biblScope>
							<date type="published">February 16-19,</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Mobile apps need to manage data, often across devices, to provide users with a variety of features such as seamless access, collaboration, and offline editing. To do so reliably, an app must anticipate and handle a host of local and network failures while preserving data consistency. For mobile environments, frugal usage of cellular bandwidth and device battery are also essential. The above requirements place an enormous burden on the app developer. We built Simba, a data-sync service that provides mobile app developers with a high-level local-programming abstraction unifying tabular and object data-a need common to mobile apps-and transparently handles data storage and sync in a reliable, consistent , and efficient manner. In this paper we present a detailed description of Simba&apos;s client software which acts as the gateway to the data sync infrastructure. Our evaluation shows Simba&apos;s effectiveness in rapid development of robust mobile apps that are consistent under all failure scenarios, unlike apps developed with Dropbox. Simba-apps are also demonstrably frugal with cellular resources.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Personal smart devices have become ubiquitous and users can now enjoy a wide variety of applications, or apps for short, running on them. Many such apps are datacentric <ref type="bibr" target="#b1">[2]</ref> often relying on cloud-based resources to store, share, and analyze the data. In addition to the user interface and the various features, the developer of such an app needs to build the underlying data management infrastructure. For example, in order to deliver a high-quality notetaking app such as Evernote, the developers have to build a data management platform that supports rich multimedia notes, queries on data and metadata, collaboration, and offline operations, while ensuring reliability and consistency in the face of failures. Moreover, a mobile app developer needs to meet the above requirements while also being efficient with the limited resources on mobile devices such as cellular bandwidth and battery power. The better the developer handles the above-mentioned issues the more likely the app will attract and retain users.</p><p>With the rapid growth in the number and the variety of apps in the marketplace, there is a consequent demand * Work done as part of an internship at NEC Labs from practitioners for high-level abstractions that hide the complexity and simplify the various tasks of the app developer in managing data <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b31">34,</ref><ref type="bibr" target="#b48">52]</ref>.</p><p>Data-sync services have emerged as an aid to developers wherein an app can offload some of its data management to a third-party service such as Dropbox, iCloud, or Google Drive. While at first such services catered to end-users who want access to their files across multiple devices, more recently such services provide SDKs for apps to use directly through CRUD (Create, Read, Update, Delete) operations <ref type="bibr" target="#b13">[15]</ref>. Sync services are built upon decades of research on distributed and mobile data syncfrom foundational work on disconnected operations <ref type="bibr" target="#b27">[30]</ref>, weakly-connected replicated storage <ref type="bibr" target="#b34">[37,</ref><ref type="bibr" target="#b51">55]</ref>, and version management <ref type="bibr" target="#b39">[42]</ref>, to more recent work on wide-area database replication <ref type="bibr" target="#b54">[58]</ref>, collaborative editing <ref type="bibr" target="#b42">[46]</ref>, and caching for mobile devices <ref type="bibr" target="#b53">[57]</ref>.</p><p>The principles and mechanisms of data sync by themselves are well understood, here we do not seek to reinvent them, but a data-sync service needs to achieve a dual objective in order to be valuable to mobile apps. First, it must transparently handle matters of reliability, consistency, and efficiency, with little involvement from the app developer, which is challenging. As the makers of Dropbox also note, providing simplicity to users on the outside can require enormous complexity and effort underthe-hood <ref type="bibr" target="#b22">[24]</ref>. Second, a data-sync service must provide a data model that is beneficial to the majority of apps; while file sync is commonplace, many apps actually operate over inter-dependent structured and unstructured data <ref type="bibr" target="#b9">[11]</ref>. A high-level data model encompassing tables and files is of great value to app developers and the transparency must apply to this data model. A data-sync service must preserve, on behalf of the apps, the consistency between structured and unstructured data as it is stored and shared under the presence of failures. Consider the example of photo-sharing apps such as Picasa and Instagram; typically such an app would store album information in a table and the actual images on the file system or object store. In this case, the sync service needs to ensure that there will never be dangling pointers from albums to images. Since mobile apps can crash or stall frequently for a variety of reasons <ref type="bibr" target="#b8">[10,</ref><ref type="bibr" target="#b46">50]</ref>, if an app is in the middle of a data operation (a local write or sync) when a failure occurs, the sync service needs to reli-ably detect and recover to a consistent state. Recent work has shown that several data-sync services also spread corrupt data when used with desktop file systems <ref type="bibr" target="#b57">[61,</ref><ref type="bibr" target="#b58">62]</ref>. While services already exist for file <ref type="bibr" target="#b3">[4,</ref><ref type="bibr">27,</ref><ref type="bibr" target="#b52">56]</ref> and table <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b26">29,</ref><ref type="bibr">43</ref>] data, none meet the above criteria.</p><p>To better understand how mobile apps and sync services maintain data consistency under failures, we conducted a study of popular mobile apps for Android including ones that use Dropbox, Parse, and Kinvey for data sync. Our study revealed that apps manage data poorly with data loss, corruption, and inconsistent behavior.</p><p>We thus built Simba to manage data for mobile apps, which provides a high-level abstraction unifying files and tables. The tables may contain columns of both primitivetype (string, integer, etc.) and arbitrary-sized objects, all accessible through a CRUD-like interface. For ease of adoption, the interface is kept similar to the ones already familiar to iOS and Android developers. Apps can construct a data model spanning both tables and objects and Simba ensures that all data is reliably, consistently, and efficiently synced with the server and other mobile devices.</p><p>Simba consists of an SDK for developing mobile apps, the Simba client app (sClient) for the mobile device, and the Simba cloud server (sCloud); all apps written with the Simba SDK, Simba-apps, communicate only with the local instance of sClient which serves as the proxy for all interaction with sCloud. In this paper, we focus on the transparency of the high-level abstraction as it affects Simbaapps and hence primarily discuss sClient; the entire Simba service is presented in greater detail elsewhere <ref type="bibr" target="#b41">[45]</ref>.</p><p>Through case studies we show how Simba enabled us to quickly develop several mobile apps, significantly increasing development ease and functionality. Simbaapps benefited greatly from sClient's failure transparency; an app written using Dropbox failed to preserve atomicity of an entire data object leading to torn updates and synced inconsistent data under failure. Benefiting from Simba's ability to programmatically incorporate delaytolerant data transfer, Simba-apps also exhibited reduced network footprint and gave the device increased opportunity to turn off the cellular radio.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Study of Mobile App Reliability</head><p>We studied the reliability of some popular mobile apps and sync services (on Android) by systematically introducing failures -network disruption, local app crash, and device power loss -and observing the recovery outcome, if any. The apps in our study use both tables and files/objects, and rely on various existing services, i.e., Dropbox, Parse, and Kinvey, for data sync. We setup two Android devices with identical apps and initial state. To simulate a network disruption we activated airplane mode and for crashes (1) manually kill the app, and (2) pull the battery out; the outcomes for the two crash tests do not differ and we thus list them once, as shown in <ref type="table">Table 1</ref>.</p><p>For the network disruption tests, some apps (e.g., Hiyu, Tumblr) resulted in loss of data if the sync failure was not handled immediately after reconnection. If the app (or the notification) was closed, no recovery happened upon restart. Some apps (UPM, TomDroid, Keepass2) did not even notify the user that sync had failed. As most apps required the user to manually resync after failure, this oversight led to data perpetually pending sync. Some apps exhibited other forms of inconsistency. For TomDroid, if the second device contacted its server for sync even in absence of changes, the delete operation blocked indefinitely. For Evernote, manual re-sync after disruption created multiple copies of the same note over and over.</p><p>For the crash tests, the table-only apps recovered correctly since they depended entirely on SQLite for crash consistency. However, apps with objects showed problematic behavior including corruption and inconsistency. For YouTube, even though the object (video) was successfully uploaded, the app lost the post itself. Instagram and Keepass2 both created a local partial object; Keepass2 additionally failed to recover the table data resulting in a dangling pointer to the object. Dropbox created a conflict file with a partial object (local corruption) and spread the corruption to the second device, just like Evernote.</p><p>Our study reveals that mobile apps still lose or corrupt data in spite of abundant prior research, analysis tools, and data-sync services. First, handling objects was particularly problematic for most apps -no app in our study was able to correctly recover from a crash during object updates. Second, instead of ensuring correct recovery, some apps take the easier route of disabling object updates altogether. Third, in several cases, apps fail to notify the user of an error causing further corruption. The study further motivates us to take a holistic approach for transparently handling failures inside a data-sync service and provide a useful high-level abstraction to apps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">App Development with Simba</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Data Model and API</head><p>Data Model: Simba's data model is designed such that apps can store all of their data in a single, unified, store without worrying about how it is stored and synced. The high-level abstraction that enables apps to have a data model spanning tables and objects is called a Simba Table (sTable in short). To support this unified view of data management, Simba, under the hood, ensures that apps always see a consistent view of data stored locally, on the cloud, and other mobile devices.</p><p>The unit of client-server consistency in Simba is an individual row of an sTable (sRow in short) which consists of tabular data and all objects referred in it; objects are not shared across sRows. Simba provides causal consistency semantics with all-or-nothing atomicity over an sRow for both local and sync operations; this is a stronger guarantee than provided by existing sync services. An app can, of course, have a tabular-only or object-only schema, which Simba trivially supports. Since an sRow represents a higher-level, semantically meaningful, unit of app data, ensuring its consistency under all scenarios is quite valuable to the developer and frees her from writing complicated transaction management and recovery code. Simba currently does not provide atomic sync across sRows or sTables. While some apps may benefit from atomic multi-row sync, our initial experience has shown that ACID semantics under sync for whole tables would needlessly complicate Simba design, lead to higher performance overheads, and be overkill for most apps.</p><p>API: sClient's API, described in <ref type="table" target="#tab_3">Table 2</ref>, is similar to the popular CRUD interface but with four additional features: 1) CRUD operations on tables and objects 2) operations to register tables for sync 3) upcalls for new data and conflicts 4) built-in conflict detection and support for resolution. Objects are written to, or read from, using a stream abstraction which allows Simba to support large objects; it also enables locally reading or writing only part of a large object -a property that is unavailable for BLOBs (binary large objects) in relational databases <ref type="bibr" target="#b35">[38]</ref>.</p><p>Since different apps can have different sync requirements, Simba supports per-table sync policies controlled by the app developer using the sync methods (registerWriteSync etc). Each sTable can specify a non-zero period which determines the frequency of change collection for sync. A delay tolerance (DT) value can be specified which gives an additional opportunity for data to be coalesced across apps before sending over the network; DT can be set to zero for latency-sensitive data. Even when apps have non-aligned periods, DT enables crossapp traffic to be aligned for better utilization of the cellular radio. If an app needs to sync data on-demand, it can use the writeSyncNow() and readSyncNow() methods. Simba's delay-tolerant transfer mechanism directly benefits from prior work <ref type="bibr" target="#b20">[22,</ref><ref type="bibr" target="#b45">49]</ref>. Since sync happens in the background, when new data is available or conflicts occur due to sync, apps are informed using upcalls. An app can begin and end a conflict-resolution transaction at-will and iterate over conflicted rows to resolve with either the local copy, the server copy, or an entirely new choice.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Writing a Simba App</head><p>Simba's unified API simplifies data management for apps; this is perhaps best shown with an example. We consider a photo-sharing app which stores and periodically syncs the images, along with their name, date, and location. First, create an sTable by specifying its schema: sclient.createTable("album", "name VARCHAR, date INTEGER, location FLOAT, photo OBJECT", FULL_SYNC);</p><p>Next, register for read (download) and write (upload) sync. Here, the app syncs photos every 10 mins (600s) with a DT of 1 min (60s) for both reads and writes, selecting WiFi for write and allowing 3G for read sync.</p><p>sclient.registerWriteSync("album",600,60,WIFI); sclient.registerReadSync("album",600,60,3G);</p><p>A photo can be added to the table with writeData() followed by writing to the output stream. Finally, a photo can be retrieved using a query:</p><p>SCSCursor cursor = sclient.readData("album", new</p><p>String[] { "location", "photo" }, "name=?", new String[] { "Kopa" }, null); // Iterate over cursor to get photo data SCSInputStream mis = cursor.getInputStream().get(1);</p><formula xml:id="formula_0">4 Simba Design 4.1 Simba Server (sCloud)</formula><p>The server is a scalable cloud store that manages data across multiple apps, tables, and clients <ref type="bibr" target="#b41">[45]</ref>. It provides a  <ref type="table" target="#tab_5">Table Store</ref> Object Store sTable (logical) sTable (physical) <ref type="figure">Figure 1</ref>: Simba Client Data Store. network protocol for data sync, based on a model in which it is the responsibility of an sClient to pull updates from the server and push any local modifications, on behalf of all device-local Simba-apps; the sClient may register with the server to be notified of changes to subscribed tables. Sync Protocol: To discuss sClient's design we need to refer to the semantics offered by the server through the network protocol. The server is expected to provide durability, atomicity of row updates, and multi-version concurrency control. Thus, the sClient is exposed to versions, which accompany any data in messages exchanged with the server. Simba implements a variant of version vectors that provides concurrency control with causal consistency semantics <ref type="bibr" target="#b30">[33]</ref>. Since all sClients sync to a central sCloud, we simplify the versioning scheme to have one version number per row instead of a vector <ref type="bibr" target="#b39">[42]</ref>. Each sRow has a unique identifier ID row generated from a primary key, if one exists, or randomly, and a version V row .</p><p>Row versions are incremented at the server with each update of the row; the largest row version in a table is maintained as the table version, V table , allowing us to quickly identify which rows need to be synchronized. A similar scheme is used in gossip protocols <ref type="bibr" target="#b56">[60]</ref>. Since Simba supports variable-sized, potentially large, objects, the protocol messages explicitly identify objects' partially-changed sets that need to be applied atomically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Simba Client (sClient)</head><p>sClient allows networked Simba-apps to continue to have a local I/O model which is shown to be much easier to program for <ref type="bibr" target="#b12">[14]</ref>; sClient insulates the apps from server and network disruptions and allows for a better overall user experience. <ref type="figure" target="#fig_2">Figure 2</ref> shows the simplified architecture of the sClient; it is designed to run as a devicewide service which (1) provides all Simba-apps with access to their table and object data (2) manages a devicelocal replica to enable disconnected operations (3) ensures fault-tolerance, data consistency, and row-level atomicity (4) carries out all sync-related operations over the network. Simba-apps link with sClient through a lightweight library (sClientLib) which provides the Simba Client Interface <ref type="table" target="#tab_3">(Table 2</ref>) and forwards client operations to sClient; the apps are alerted through upcalls for events (e.g., new data, conflict) that happen in the background. Finally, sClient monitors liveness of apps, so that memory resources can be freed in case of app crash.</p><p>The sClient data store ( §4.2.1) provides a unified abstraction over a table store and an object store. SimbaSync performs sync processing ( §4.2.2) with the sCloud; for upstream sync, it collects the locally-modified data, and for downstream sync, it applies changes obtained from the server into the local store, detects conflicts, and generates upcalls to apps. The sync protocol and the local data store together provide transparent failure handling for all Simba-apps ( §5). The Network Manager handles all network connectivity and server notifications for the sClient ( §6); it provides an efficient utilization of the device's cellular radio through coalescing and delay-tolerance.</p><p>Implementation: sClient is currently implemented on Android, however, the design principles can be applied to other mobile platforms such as iOS. sClient is implemented as a daemon called the Simba Content Service (SCS) which is accessed by mobile apps via local RPC; on Android we use an AIDL <ref type="bibr" target="#b0">[1]</ref> interface to communicate between the apps and the service. An alternate approach -to link directly with the app -is followed by Dropbox <ref type="bibr" target="#b14">[16]</ref> and Parse <ref type="bibr">[43]</ref> but our approach allows sClient to shape network traffic for all Simba-apps on the same device thereby benefiting from several cross-app optimizations. While the benefits of using persistent connections have been long known <ref type="bibr" target="#b32">[35]</ref>, individual apps use TCP connections in a sub-optimal manner with frequent connection establishment and teardown. sClient's design allows it to use a single persistent TCP connection to the sCloud on behalf of multiple apps; the same connection is also reused by the server for delivering notifications, providing additional savings, similar to Thialfi <ref type="bibr" target="#b7">[9]</ref>.</p><p>A misbehaving app can potentially adversely affect other Simba-apps. In practice, we believe that developers already have an incentive to write well-behaved apps to keep users satisfied. In the future, fine-grained accounting of data, similar to Android's accounting, can be built into Simba to further discourage such behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Simba Client Data Store</head><p>The sClient Data Store (SDS) is responsible for storing app data on the mobile device's persistent storage (typically the internal flash memory or the external SD card). For Simba-apps, this means having the capability to store both tabular data and objects in a logically unified manner. The primary design goal for SDS is to enable, and efficiently support, CRUD operations on sRows; this requires the store to support atomic updates over the local data. Additionally, since objects are variablesized and potentially large, the store also needs to support atomic sync of such objects. Since the store persistently stores all local modifications, a frequent query that it must efficiently support is change detection for upstream sync; SDS should be able to quickly determine sub-object changes. <ref type="figure">Figure 1</ref> shows the SDS data layout.</p><p>Objects are subdivided into fixed-size chunks and stored in a key-value store (KVS) that supports range queries. The choice of the KVS is influenced by the need for good throughput for both appends and overwrites since optimizing for random writes is important for mobile apps <ref type="bibr" target="#b25">[28]</ref>. Each chunk is stored as a KV-pair, with the key being a 񮽙ob ject id, chunk number񮽙 tuple. An object's data is accessed by looking up the first chunk of the object and iterating the KVS in key order.</p><p>Local State: sClient maintains additional local state, persistent and volatile, for sync and failure handling. Two persistent per-row flags, Flag TD (table dirty) and Flag OD (object dirty), are used to identify locally-modified data, needed for upstream sync. To protect against partial object sync, we maintain for each row Count OO , the number of objects opened for update. A write transaction for a row is considered closed when all its open objects are closed. Each row has two more persistent flags, Flag SP (sync pending) and Flag CF (conflict), which track its current sync state. Finally, an in-memory dirty chunk table (DCT) tracks chunks that have been locally modified but not yet synced. This obviates the need to query the store for these changes during normal operation.</p><p>Implementation: We leverage SQLite to implement the tabular storage with an additional data type representing an object identifier (ob ject id). Object storage is implemented using LevelDB <ref type="bibr" target="#b29">[32]</ref> which is a KVS based on a log-structured merge (LSM) tree <ref type="bibr" target="#b37">[40]</ref>; LevelDB meets the throughput criteria for local appends and updates. LevelDB also has snapshot capability which we leverage for atomic sync. There is no native port of LevelDB for Android so we ported the original C++ LevelDB code using Android's Native Development Kit (NDK). We use one instance of LevelDB to keep objects for all tables to ensure sequential writes for better local performance <ref type="bibr" target="#b25">[28]</ref>. Since the local state is stored in an sRow's tabular part, SQLite ensures its consistent update.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Sync processing</head><p>An sClient independently performs upstream and downstream sync. The upstream sync is initiated based on the specified periodicity of individual tables, and using local state maintained in (Flag TD , Flag OD ) to determine dirty row data; these flags are reset upon data collection. For rows with dirty objects, chunks are read one-by-one and directly packed into network messages.</p><p>Since collecting dirty data and syncing it to the server may take a long time, we used the following techniques to allow concurrent operations by the foreground apps. First, sClient collects object modifications from LevelDB snapshots of the current version. As sClient syncs a modified object only after it is closed and the local state is updated (decrement Count OO by 1), sClient always ensures a consistent view of sRows at snapshots. Second, we allow sClient to continue making modifications while previous sync operations are in-flight; this is particularly beneficial if the client disconnects and sync is pending for an extended duration. These changes set sRow's local flags, Flag TD or Flag OD , for collection during the subsequent sync. For this, sClient maintains a sync pending flag Flag SP which is set for the dirty rows, once their changes are collected, and reset once the server indicates success. If another sync operation starts before the previous one completes, rows with Flag SP already set are ignored.</p><p>Downstream sync is also initiated by an sClient in response to a server notification of changes to a table. The client pulls all rows that have a version greater than the local V table , staging the downstream data until all chunks of a row are received and then applying it row-by-row onto the sClient data store in increasing V row order.</p><p>Conflicts on upstream sync are determined through V row mismatch on the server, while for downstream by inspecting the local dirty flag of received rows. To enable apps to automatically resolve <ref type="bibr" target="#b28">[31]</ref> or present to its users, the server-returned conflicted data is staged locally by sClient and the relevant Simba-app is notified. sClient is designed to handle conflicting updates gracefully. Conflicted rows are marked (Flag CF ) to prevent further upstream sync until the conflict is resolved. However, apps can resolve conflicts at their own convenience and can continue reading and writing to their local version of the row without sync. We believe this greatly improves the user experience since apps do not have to abruptly interrupt operations when conflicts arise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Transparent Failure Handling</head><p>Mobile apps operate under congested cellular networks <ref type="bibr" target="#b11">[13]</ref>, network disruptions <ref type="bibr" target="#b18">[20]</ref>, frequent service and app crashes <ref type="bibr" target="#b8">[10]</ref>, and loss of battery <ref type="bibr" target="#b40">[44]</ref>. Mobile OS memory management can also aggressively kill apps <ref type="bibr" target="#b10">[12]</ref>.</p><p>Failure transparency is a key design objective for sClient which it achieves through three inter-related aspects. First, the mechanism is comprehensive: the system detects each possible type of failure and the recovery leaves the system in a well-defined state for each of them. Second, recovery leaves the system not merely in a known state, but one that obeys high-level consistency in accordance with the unified data model. Third, sClient is judicious in trading-off availability and recovery cost (which itself can be prohibitive in a mobile environment). Barring a few optimizations (discussed in §5.2), an sClient maintains adequate local metadata to avoid distributing state with the server for the purposes of recovery <ref type="bibr" target="#b38">[41]</ref>. sClients are stateful for a reason: it allows the sync service, having many mobile clients, which can suffer from frequent failures, and a centralized server, to decouple their failure recovery thereby improving availability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Comprehensive &amp; High-level Consistent</head><p>sClient aims to be comprehensive in failure handling and to do so makes the use of a state machine <ref type="bibr" target="#b49">[53]</ref>. Each successful operation transitions sClient from one welldefined state to another; failures of different kinds lead to different faulty states each with well-defined recovery.</p><p>We first discuss network failures which affect only the sync operations. As discussed previously, the server response to upstream sync can indicate either success or conflict and to downstream sync can indicate either success or incompletion. <ref type="table" target="#tab_7">Table 3</ref>(a) describes sClient's status in terms of the local sync-pending state (Flag SP ) and the relevant server response (RC O , RC T , RU O , RU T ); note that only a subset of responses may be relevant for any given state. Each unique state following a network disconnection, for upstream or downstream sync, represents either a no-fault or a fault situation; for the latter, a recovery policy and action is specified sClient. <ref type="table" target="#tab_7">Tables 3 (b)</ref> and (c) specify the recovery actions taken for failures during upstream and downstream sync respectively. The specific action is determined based on a combination of the dirty status of the local data and the server response.</p><p>Crashes affect both sync and local operations and the state of the SDS is the same whether sClient, Simba-app, or the device crash. sClient detects Simba-app crashes through a signal on a listener and de-allocates in-memory resources for the app. <ref type="table" target="#tab_6">Table 4</ref> shows the recovery actions taken upon sClient restart after a crash; for a Simba-app crash, recovery happens upon its restart. sClient handles both network failures and crashes while maintaining all-or-nothing update semantics for sRowsin all cases, the state machine specifies a recovery action that preserves the atomicity of the tabular and object data -thereby ensuring the consistency of an app's highlevel unified view; this is an important value proposition of sClient's failure transparency to mobile apps. As seen in  tency, i.e., a torn write. Similarly, a network disruption during an object sync can cause a partial sync; sClient detects and initiates appropriate torn recovery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Judicious</head><p>sClient balances competing demands: on the one hand, normal operation should be efficient; on the other, failure recovery should be transparent and cheap. sClient maintains persistent state to locally detect and recover from most failures; for torn rows, after local detection, it recovers efficiently through server assistance. There are two kinds of tradeoffs it must make to keep recovery costs low.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Tradeoff: Local State vs. Network I/O</head><p>When sClient recovers from a crash, it can identify whether the object was dirty using Flag OD but it cannot determine whether it was completely or partially written to persistent storage; the latter would require recovery. Count OO counter enables making this determination: if it is set to zero, sClient can be sure that local data is consistent and avoid torn recovery using the server. The cost to sClient is an extra state of 4 bytes per row. However, one problem still remains: to sync this object, sClient still needs to identify the dirty chunks. The in-memory DCT will be lost post-crash and force sClient to either fetch all chunks from the server or send all chunks to the server for chunk-by-chunk comparison. sClient thus pays the small cost of persisting DCT, prior to initiating sync, to prevent re-syncing entire, potentially large, objects. Once persisted, DCT is used to sync dirty chunks after a crash and removed post-recovery. If sClient crashes before DCT is written to disk, it sends all chunks for dirty objects.   and out-of-place local throughput with 1KB rows that row; the client relies on this observation to either rollback or roll-forward to a consistent state. If sClient detect a local torn row during recovery, it obtains a consistent version of the row from the server; this is akin to rollback for aborted database transactions <ref type="bibr" target="#b33">[36]</ref>. If the server has since made progress -the client in essence rolls forward. If the client is disconnected, recovery cannot proceed, but also does not prevent normal operation -only the torn rows are made unavailable for local updates. For comparison, we also implement an out-of-place SDS; as shown in <ref type="table" target="#tab_9">Table 5</ref>, sClient is able to achieve 69% higher throughput with in-place updates as opposed to out-of-place updates for updating rows with 1KB objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Transparent Network Efficiency</head><p>Simba sync is designed to make judicious use of cellular bandwidth and device battery through a custom-built network protocol with two optimizations: Delay tolerance and coalescing: typically, many apps run in the background as services, for example to send/receive email, update weather, synchronize RSS feeds and news, and update social networking. sClient is designed as a device-wide service so that sync data for multiple independent apps can be managed together and transferred through a shared persistent TCP connection. Further, Simba supports delay-tolerant data scheduling which can be controlled on a per-table basis. Delay tolerance and coalescing has two benefits. 1) Improved network footprint: allows data transfer to be clustered, reducing network activity and improving the odds of the device turning off the radio <ref type="bibr" target="#b45">[49]</ref>. Control messages from the server are subject to the same measures. 2) Improved scope for data compression: outgoing data for multiple apps is coalesced to improve the compression <ref type="bibr" target="#b21">[23]</ref>.</p><p>Fine-grained change detection: an entire object need not be synced if only a part changes. Even though data is versioned per row, sClient keeps internal soft-state (DCT) to detect object changes at a configurable chunk level; Simba server does the same for downstream sync.</p><p>Implementation: Even though sRows are the logical sync unit, sClient's Network Manager packs network messages with data from multiple rows, across multiple tables and apps, to reduce network footprint. Simba's network protocol is implemented using Protobufs <ref type="bibr">[7]</ref>, which efficiently encodes structured data, and TLS for secure network communication; the current prototype uses twoway SSL authentication with client and server certificates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Evaluation</head><p>We wish to answer the following two questions:</p><p>• Does Simba provide failure transparency to apps?</p><p>• Does Simba perform well for sync and local I/O?</p><p>We implemented sClient for Android interchangeably using Samsung Galaxy Nexus phones and an Asus Nexus 7 tablet all running Android 4.2. WiFi tests were on a WPA-secured WiFi network while cellular tests were run on 4G LTE: KT and LGU+ in South Korea and AT&amp;T in US. Our prototype sCloud is setup using 8 virtual machines partitioned evenly across 2 Intel Xeon servers each with a dual 8-core 2.2 GHz CPU, 64GB DRAM, and eight 7200 RPM 2TB disks. Each VM was configured with 8GB DRAM, one data disk, and 4 CPU cores.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Building a Fault-tolerant App</head><p>The primary objective of Simba is to provide a high-level abstraction for building fault-tolerant apps. Evaluating success, while crucial, is highly subjective and hard to quantify; we attempt to provide an assessment through three qualitative means: (1) comparing the development effort in writing equivalent apps using Simba and Dropbox. (2) development effort in writing a number of Simbaapps from scratch. (3) observing failure recovery upon systematic fault-injection in sClient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Writing Apps: Simba vs. Dropbox</head><p>Objective: is to implement a photo-sync app that stores album metadata and images. App S is to be written using Simba and App D using Dropbox. We choose Dropbox since it has the most feature-rich and complete API of existing systems and is also highly popular <ref type="bibr" target="#b52">[56]</ref>; Dropbox provides APIs for files (Filestore) and tables (Datastore). App S and App D must provide the same semantics to the end-user: a consistent view of photo albums and reliability under common failures; we compare the effort in developing the two equivalent apps.</p><p>Summary: achieving consistency and reliability was straightforward for App S taking about 5 hours to write and test by 1 developer. However, in spite of considerable effort (3 -4 days), App D did not meet all its objectives; here we list a summary of the limitations:</p><p>1. Dropbox does not provide any mechanism to consistently inter-operate the table and object stores.</p><p>2. Dropbox Datastore in-fact does not even provide row-level atomicity during sync (only column-level)! 3. Dropbox does not have a mechanism to handle torn rows and may sync inconsistent data. 4. Dropbox carries out conflict resolution in the background and prevents user intervention. Methodology: we describe in brief our efforts to overcome the limitations and make App D equivalent to App S ; testing was done on 2 Android smartphones -one as</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Apps</head><p>Description Total LOC Simba LOC Simba-Notes "Rich" note-taking with embedded images and media; relies on Simba for conflict detection and resolution, sharing, collaboration, and offline support. Similar to Evernote <ref type="bibr" target="#b2">[3]</ref> 4,178 367</p><p>Surveil Surveillance app capturing images and metadata (e.g., time, location) at frequent intervals; data periodically synced to cloud for analysis. Similar to iCamSpy <ref type="bibr" target="#b24">[26]</ref> 258 58</p><p>HbeatMonitor Continuously monitors and records a person's heart rate, cadence and altitude using a Zephyr heartbeat sensor <ref type="bibr" target="#b59">[63]</ref>; data periodically synced to cloud for analysis. Similar to Sportstracklive <ref type="bibr" target="#b6">[8]</ref> 2,472 384</p><p>CarSensor Periodically records car engine's RPM, speed, engine load, etc using a Soliport OBD2 sensor attached to the car and then syncs to the cloud; similar to Torque car monitor <ref type="bibr" target="#b55">[59]</ref> 3,063 384</p><p>SimbaBench Configurable benchmark app with tables and objects to run test workloads 207 48 App S</p><p>Simba-based photo-sync app with write/update/read/delete operations on tabular and object data 527 170 App D</p><p>Dropbox-based photo-sync app written to provide similar consistency and reliability as App S 602 -sClient</p><p>Simba client app which runs as a background daemon on Android 11,326 -sClientLib Implements the Simba SDK for writing mobile apps; gets packaged with a Simba-app's .apk file 1,008 - Writes: when a new image is added on the writer, the app on the reader receives separate updates for tables and files, Since Dropbox does not provide row-atomicity, it is possible for Simba metadata columns to sync before app data. To handle out-of-order arrival of images or album info prior to Simba metadata, we set flags to indicate tabular and object sync completion; when Simba metadata arrives, we check this flag to determine if the entire row is available. The reader then displays the image.</p><p>Updates: are more challenging. Since the reader does not know the updated columns, and whether any objects are updated, additional steps need to be taken to determine the end of sync. We create a separate metadata column (MC) to track changes to Datastore; MC stores a list of updated app-columns at the writer. We also issue sync of MC before other columns so that the reader is made aware of the synced columns. Since Dropbox does not provide atomicity over row-sync, the reader checks MC for every table and object column update.</p><p>Deletes: once the writer deletes the tabular and object columns, both listeners on the reader eventually get notified, after which the data is deleted locally. ✓2. Row-atomicity for tables+files: for every column update, Datastore creates a separate sync message and sends the entire row; it is therefore not possible to distinguish updated columns and their row version at sync. Atomic sync with Dropbox thus requires even more metadata to track changes; we create a separate table for each column as a workaround <ref type="table" target="#tab_2">. For example, for an app table  having one table and one</ref> object column, two extra tables need to be created in addition to MC.</p><p>For an update, the writer lists the to-be-synced tabular and object columns (e.g., 񮽙col1, col3, ob j2񮽙) in MC and issues the sync. The reader receives notifications for each update and waits until all columns in MC are received. In case a column update is received before MC, we log the event and revisit upon receiving MC. Handling of new writes and deletes are similar and omitted for brevity. ✗3. Consistency under failures: Providing consistency under failures is especially thorny in the case of App D . To prevent torn rows from getting synced, App D requires a separate persistent flag to detect row-inconsistency after a crash, along with all of the recovery mechanism to correctly handle the crash as described in §5. Since App D also does not know the specific object in the row that needs to be restored, it would require a persistent data structure to identify torn objects. ✗4. Consistent conflict detection: Dropbox provides transparent conflict resolution for data; thus, detecting higher-level conflicts arising in the app's data model is left to the app. Since there is no mechanism to check for potential conflicts before updating an object, we needed to create a persistent dirty flag for each object in App D . Moreover, an app's local data can be rendered unrecoverable if the conflict resolution occurs in the background with an "always theirs" policy. To recover from inconsistencies, App D needs to log data out-of-place, requiring separate local persistent stores.</p><p>To meet 3. and 4. implied re-implementing the majority of sClient functionality in App D and was not attempted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.2">Other Simba Apps</head><p>We wrote a number of Simba-apps based on existing mobile apps and found the process to be easy; the apps were robust to failures and maintained consistency when tested. Writing the apps on average took 4 to 8 hours depending on the GUI since Simba handled data management. Table 6 provides a brief description of the apps along with their total and Simba-related lines of code (LOC).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.3">Reliability Testing</head><p>We injected three kinds of failures, network disruption, Simba-app crash, and sClient crash, while issuing local, sync, and conflict handling operations. <ref type="table" target="#tab_12">Table 7</ref> shows,   in brief, the techniques employed by sClient. For a given workload (a -x), gray cells represent unaffected or invalid scenarios, for example, read operations. A non-empty cell in detection implies that all cases were accounted for, and a corresponding non-empty cell in recovery implies corrective action was taken. The absence of empty cells indicates that sClient correctly detected and recovered from all of the common failures we tested for. Detection: each cell in <ref type="table" target="#tab_12">Table 7</ref>(a) lists the flags used to detect the status of tables and objects after a failure. sClient maintained adequate local state, and responses from the server, to correctly detect all failures. Change in tabular data was detected by Flag TD (T) for write and Flag SP (S) for sync as Flag TD is toggled at start of sync. sClient then performed a check on the server's response data (R). Sync conflict was identified by checking Flag CF (F). Similarly, usage of writestream and object update were detected by Count OO (C) and Flag OD (O) with the addition of DCT (D) for sync.</p><formula xml:id="formula_1">a b c d e f g h i j k l m n o p q r s t u v w x Tab T T S S, F, R S S, R S, R, F F, R R R, F Obj C C, O, D C, O, D S, D S, D S, D, R S, D, T, F S, D S, D, R S, D, R, F R R, D, F R R, D,</formula><p>Recovery: each cell in <ref type="table" target="#tab_12">Table 7</ref>(b) lists the recovery action taken by sClient from among no-op, reset, propagate, and local or server-assisted recovery. No-op (N) implies that no recovery was needed as the data was already in a consistent state. When a conflict was detected, but with consistent data, sClient propagated (P) an alert to the user seeking resolution. With the help of local state, in most cases sClient recovered locally (LR); for a torn row, sClient relied on server-assisted recovery (SR). In some cases, sClient needed to reset flags (R) to mark the successful completion of recovery or a no-fault condition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Performance and Efficiency</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Sync Performance</head><p>We want to verify if Simba achieves its objective of periodic sync. <ref type="figure">Figure 3</ref> shows the client-server interaction for two mobile clients both running the SimbaBench (Table 6); on Client 1 it creates a new row with 100 bytes of table data and a (50% compressible) 1MB object every 10 seconds. Client 1 also registers for a 60-second periodic upstream sync. Client 2 read-subscribes the same table also with a 60-second period. As can be seen from the figure, the network interaction for both upstream and downstream sync shows short periodic burst of activity followed by longer periods of inactivity. Client 2's read subscription timer just misses the first upstream sync (77s − 95s), so the first downstream sync happens about a minute later (141s − 157s); for the rest of the experiment, downstream messages immediately follow the upstream ones confirming that Simba meets this objective. We want to evaluate Simba's sync performance and how it compares with Dropbox. <ref type="figure">Figure 4</ref> compares the end-to-end sync latency of Simba and Dropbox over both WiFi and 4G; y-axis is time taken with standard deviation of 5 trials. For these tests we run two scenarios, both with a single row being synced between two clients: 1) with only a 1-byte column, and 2) with one 1-byte column and one 1KB object. The two clients were both in South Korea. The Dropbox server was located in California (verified by its IP address) whereas the Simba server was located on US east coast. As a baseline, we also measured the ping latency from clients to servers. <ref type="figure">Figure 4</ref> shows that the network latency ("Ping") is a small component of the total sync latency. For both the tests, Simba performs significantly better than Dropbox; in case 1), by about 100% to 200%, and in case 2) by more than 1200%.</p><p>Since Dropbox is proprietary we not claim to fully understand how it functions; it very well might be overloaded or throttling traffic. The experiment demonstrates that Simba performs well even when giving control of sync to apps. We want to test how quickly Simba resolves conflicts for a table with multiple writers. <ref type="figure" target="#fig_6">Figure 6</ref> shows this behavior. The x-axis shows the number of clients (min. 2 clients needed for conflict) and the y-axis shows the average time to converge (sec) and standard deviation over 5 trials. For "theirs", the server's copy is chosen every time and hence no changes need to be propagated back; for "mine", the local copy is chosen every time and re-synced back to the server. The "no conflicts" case is shown to establish a baseline -a normal sync still requires changes to be synced to the server; "mine" always and "theirs" always represent the worst-case and the best-case scenarios respectively with typical usage falling somewhere in between. The figure shows that for a reasonable number (i.e., 5) of collaborating clients, as the number of conflict resolution rounds increases, it does not impose a significant overhead compared to baseline sync, even when selecting the server's copy; when selecting the local copy, conflict resolution is fairly quick.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Network Efficiency</head><p>We want to evaluate Simba's impact on network efficiency. Three apps were chosen for this experiment that generate data periodically: CarSensor app in replay mode generating about 250 byte rows every second, SimbaBench set to create 1MB rows (50% compressible) every 10s, and an app that simulates the behavior of SimbaNotes, by generating ∼300 byte of data using Poisson distribution with a mean value of 300s and using a fixed seed for random number generation. CarSensor and SimbaBench run with a periodic upstream sync of 60s. <ref type="figure" target="#fig_5">Figure 5</ref> shows a scatter plot of the data transfer profile of the apps; y-axis is message size on a log scale, and xaxis is time in seconds. The colored bands are meant to depict temporal clusters of activity. The "Startup" band shows the one-time Simba authentication and setup, and sync registration messages for the tables. We ran the Simba apps (a) individually, (b) concurrently with SimbaNotes's DT=0, and (c) concurrently with Simba-Notes's DT=60s. <ref type="figure" target="#fig_5">Figure 5(a)</ref> shows the super-imposition of the data transfer profile when the apps were run individually, to simulate the behavior of the apps running without coordination. As also seen in the figure, while it is possible for uncoordinated timers to coincide, it is unlikely; especially so when the period is large compared to the data transfer time. Aperiodic apps like Simba-Notes also cause uncoordinated transfers. Uncoordinated transfers imply frequent radio activity and energy consumed due to large tail times. In <ref type="figure" target="#fig_5">Figure 5</ref>(b), all apps are run concurrently. The events generated by Simba-Notes are annotated. We see that the network transfers of CarSensor and SimbaBench are synchronized, but Simba-Notes still causes network transfer at irregular times (the thin bands represent network transfers by Simba-Notes). In <ref type="figure" target="#fig_5">Figure 5</ref>(c), we run an experiment similar to (b) but this time Simba-Notes employs a delay tolerance of 60s; its network activity is delayed until the next 60s periodic timer along with all pending sync activity (notice the absent thin bands). The resulting data transfer is clustered, increasing the odds of the radio being turned off. The x-axes in (b) and (c) start around 800s as we measured after a few minutes of app start.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.3">Local I/O Performance</head><p>Our objective is to determine whether sClient's local performance is acceptable for continuous operation, especially since storage can be a major contributor to performance of mobile apps <ref type="bibr" target="#b25">[28]</ref>. SimbaBench issues writes,  reads, and deletes for one row of data containing one 1MB object for both sClient with Dropbox (Core API). <ref type="figure" target="#fig_7">Fig- ure 7</ref> shows average times and standard deviation over 5 trials; sClient is about 10% slower than Dropbox for both writes and reads, primarily due to IPC overhead as sClient is a background service on Android while Dropbox directly accesses the file system. sClient performs better for deletes through lazy deletion -data is only marked as deleted but physically removed only after sync completion. sClient and Dropbox both perform several additional operations over Ext4 and SQLite; we provide this comparison only as a baseline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related Work</head><p>Data sync and services: sync has been much studied in the context of portable devices including seminal work on disconnected operations <ref type="bibr" target="#b27">[30]</ref>, weakly-consistent replicated storage <ref type="bibr" target="#b34">[37,</ref><ref type="bibr" target="#b51">55]</ref>, and data staging <ref type="bibr" target="#b16">[18,</ref><ref type="bibr" target="#b53">57]</ref>. In terms of failure transparency, Bayou <ref type="bibr" target="#b51">[55]</ref> provides a limited discussion of its crash recovery through a write log but it does not handle objects. LBFS <ref type="bibr" target="#b34">[37]</ref> atomically commits files on writeback, preventing corruption on crash or disruption, but does not handle tables. We find that for most apps, handling the dependencies -between tabular and object data -is the biggest source of inconsistency.</p><p>Of the existing services, Dropbox is the most comprehensive but still does not support sync atomicity for objects and tables, breaking failure transparency for several fault conditions. iCloud also provides separate mechanisms for a key-value interface and file sync. Mobius <ref type="bibr" target="#b12">[14]</ref> provides a CRUD API to a table-sync store but does not support objects at all. Similar to Simba, Parse <ref type="bibr">[43]</ref> and Kinvey <ref type="bibr" target="#b26">[29]</ref> are mobile backend-as-a-service offering GUI integration, administration, and limited data management; they only support tables and provide last-writerwins semantics which is inadequate for many apps. No sync service provides delay-tolerant transfer.</p><p>Fault tolerance: <ref type="bibr">ViewBox [62]</ref> integrates a desktop FS with a data-sync service so as to sync only consistent views of the local data; the paper also shows how Dropbox spreads local file corruption which ViewBox addresses through checksums. Simba focuses on providing transparent fault-handling to apps; while ViewBox works only for files, Simba spans both files and tables.</p><p>Storage unification: prior work for desktop file systems has considered database integration but without network sync or a unified API. InversionFS <ref type="bibr" target="#b36">[39]</ref> uses Postgres to implement a file system with transactional guarantees and fine-grained versioning. TableFS <ref type="bibr" target="#b47">[51]</ref> uses separate storage pools for metadata (an LSM tree) and files to improve its own performance through metadata operations. KVFS <ref type="bibr" target="#b50">[54]</ref> stores file data and file-system metadata both in a single key-value store built on top of VT-Trees, a variant of LSM trees, which enable efficient storage for objects of various sizes; VT-Trees can be used to build a better-performing sClient data store, in the future.</p><p>Mobile data transfer: Recent research has characterized and optimized data transfer for mobile environments <ref type="bibr" target="#b19">[21,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b43">47]</ref>, especially the adverse effects of small, sporadic transfers <ref type="bibr" target="#b15">[17,</ref><ref type="bibr" target="#b44">48]</ref>; SPDY <ref type="bibr" target="#b4">[5]</ref> extends HTTP for better compression and multiplexes requests over a single connection to save round trips. This large body of networking research has inspired Simba's network protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusions</head><p>Building high-quality data-centric mobile apps invariably mandates the developer to build a reliable and efficient data management infrastructure -a task for which few are well-suited. Mobile app developers should not need to worry about the complexities of network and data management but instead be able to focus on what they do best -implement the user interface and features -and deliver great apps to users. We built Simba to empower developers to rapidly develop and deploy robust and efficient mobile apps; through its mobile client daemon, sClient, it provides background data sync with flexible policies that suit a large class of mobile apps while transparently handling failures and efficiently utilizing mobile resources. We plan to release Simba's source code; please check with the contact author (Nitin Agrawal) for further details.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Fig- ure 1 shows Simba's data model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>/</head><label></label><figDesc>/ byte[] photoBuffer has camera image List&lt;SCSOutputStream&gt; objs = sclient.writeData("album" , new String[]{"name=Kopa","date=15611511"," location=24.342"}, new String[] {"photo"}); objs[0].write(photoBuffer); objs[0].close();</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Simba Client Architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>=0 1 -Restart SyncUpstream with table data and object if ∃DCT (OD←1 if ∃DCT, SP←0) 1 0 &gt;0 0 0 Start SyncUpstream with table data (OO←0) 1 Conflict upcall (OO←0) 1 0 &gt;0 1 -Restart SyncUpstream with table data and object if ∃DCT (OD←1 if ∃DCT, OO←0, SP←0) 1 1 =0 0 0 Start SyncUpstream with full row 1 Conflict upcall 1 1 =0 1 -Restart SyncUpstream with full row (SP←0) 1 1 &gt;0 0 * Recover Torn write (TD←0, OD←0, OO←0) 1 1 &gt;0 1 -Recover Torn write (TD←0, OD←0, OO←0, SP←0)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :Figure 4 :</head><label>34</label><figDesc>Figure 3: Sync Network Messages. Data and control transfer profile</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Network Transfer For Multiple Apps.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Time Taken for Conflict Convergence. Figure 7: sClient Local I/O Performance.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 6: Time Taken for Conflict Convergence. Figure 7: sClient Local I/O Performance.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>CRUD (on tables and objects) createTable(TBL, schema, properties) updateTable(TBL, properties) dropTable(TBL) outputStream[] ← writeData(TBL, TBLData, objColNames) outputStream[] ← updateData(TBL, TBLData, objNames, selection) inputStream[] ← rowCursor ← readData(TBL, projection, selection</head><label>CRUD</label><figDesc></figDesc><table>) 
deleteData(TBL, selection) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table and Object</head><label>and</label><figDesc></figDesc><table>Synchronization 
registerWriteSync(TBL, period, DT, syncpref) 
unregisterWriteSync(TBL) 
writeSyncNow(TBL) 

registerReadSync(TBL, period, DT, syncpref) 
unregisterReadSync(TBL) 
readSyncNow(TBL) 

Upcalls 
newDataAvailable(TBL, numRows) 
dataConflict(TBL, numConflictRows) 

Conflict Resolution 
beginCR(TBL) 
getConflictedRows(TBL) 
resolveConflict(TBL, row, choice) 
endCR(TBL) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 2 :</head><label>2</label><figDesc>Simba Client Interface. Operations available to mo- bile apps for managing table and object data. TBL refers to table name.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table Store is</head><label>Store</label><figDesc></figDesc><table>imple-

mented using a SQL database and Object Store with a key-value store 

based on LSM tree. Objects are split into fixed-size chunks. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Table 4 , when an object is both dirty and open (Flag OD = 1 &amp; Count OO &gt; 0), a crash can lead to row inconsis-TD←1, if ∃DCT OD←1 stream SP=1, after SyncUpResult(RC O =0) Completed Roll forward None (no-fault) SP=1, after SyncUpResult(RC O =1) Partial response Reset &amp; retry See Table 3(b)</head><label>4</label><figDesc></figDesc><table>Type State Upon Network Disconnection Implication 
Recovery Policy Action 

Up 
SP=0 
No sync 
Not needed 
None (no-fault) 
SP=1, before SyncUpResult 
Missed response Reset &amp; retry 
SP←0, Down 

Before Notify 
No sync 
Not needed 
None (no-fault) 
After Notify 
Sync needed 
Normal operation Send SyncDownstream 
After SyncDownstream 
Missed response Retry 
Resend SyncDownstream 
stream After SyncDownResult(RU O =0) 
Completed 
Roll forward 
See Table 3(c) 
After SyncDownResult(RU O =1) 
Partial response Reset &amp; retry 
See Table 3(c) 

(a) Sync Failure Detection and Recovery Policy 

Flags 
Resp. Recovery Action 
TD OD RC T 
0 
0 
* 
Delete entry, SP←0 
0 
1 
* 
Delete entry, SP←0, TD←1, if ∃DCT OD←1 
1 
0 
* 
Delete entry, SP←0, TD←1 
1 
1 
* 
Delete entry, SP←0, TD←1, if ∃DCT OD←1 

(b) Recovery action for SyncUpstream 

Flags 
Response Recovery Action 
TD OD RU T RU O 
* 
* 
* 
1 
Delete entry, resend w/ new 
V table : SyncDownstream 
0 
0 
1 
0 
Update table data 
1 
* 
1 
0 
Conflict on table data 

(c) Recovery action for SyncDownstream 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>Table 3 : Network Disconnection: State Space for Failure Detection and Recovery. CF= 0 for all the above states since sync is in-progress; OO is irrelevant. ∃DCT → Obj exists in DIRTYCHUNKTABLE. Delete entry → Delete row in TBLCONFLICT and corresponding object in LevelDB. TD: Table Dirty, OD: Object Dirty, SP: Sync Pending, RC O : Response conflict for object, RC T : Response conflict for table, RU O : Response update for object, RU T :</head><label>3</label><figDesc>Response update for table. Note TD and OD can be re-set to 1 after SP=1 since Simba allows local ops to safely proceed even when prior sync is in-progress. * indicates recovery action is independent.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>Table 4 :time, Simba has some consistent view of</head><label>4</label><figDesc></figDesc><table>Client Crash: State Space for Failure Detec-
tion &amp; Recovery. TD: Table Dirty, OD: Object Dirty, OO: Object 

Open Count, SP: Sync Pending, CF: Row Conflict; * indicates recovery 
action independent of flag; -indicates state with flag=1 is not possible 

5.2.2 Tradeoff: Local I/O vs. Network I/O 

If an object does have a non-zero Count OO post-crash, it is 
indeed torn. The most obvious way to recover torn rows 
is to never update data in-place in the SDS, but instead al-
ways write out-of-place first; once the data is successfully 
written, it can be copied to the final location similar to a 
write-ahead-log or journaling. Instead of paying the over-
head during common-case operation, in this case, sClient 
takes assistance from Simba. 
At any point in </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>Table 5 : Server-assisted Recovery. Comparison of in-place</head><label>5</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>Table 6 : Lines of Code for Simba and Apps. Total LOC counted using CLOC; Simba LOC counted manuallyin App D .</head><label>6</label><figDesc></figDesc><table>writer and the other as the reader. We were successful 
with 1, 2 but not with 3, 4. 
✓1. Consistency across stores: we store App D images 
in Filestore and album info in Datastore; to ac-
count for dependencies, we create an extra Datastore 
column to store image identifiers. To detect file modifica-
tions, we maintain Dropbox listeners </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>F ( a) Detection. T: Flag TD , O: Flag OD , C: Count OO , D: DCT, S: Flag SP , R: Server Response Table, F: Flag CF aR: Reset, P: Propagate Conflict, LR: Local Recovery, SR: Server-assisted Recovery</head><label>(</label><figDesc></figDesc><table>b c d e f 
g 
h 
i 
j 
k 
l 
m 
n 
o 
p 
q 
r s 
t 
u 
v 
w 
x 
Tab 
N 
N 
R R, P 
R 
R, LR R, LR, P 
R, P 
LR 
LR, P 
Obj 
R LR, SR LR, SR 
R 
R 
R, LR R, LR, P 
R 
R, LR R, LR, P 
R R, LR, P LR 
LR, P 

(b) Recovery. N: No Op, </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12" validated="false"><head>Table 7 :b: get obj readstream c: read obj d: read tab+obj e: write tab f: get obj writestream g: write obj h: write tab+obj i: syncup tab only j: syncupresult for tab only k: syncup obj only l: send objfrag for obj only syncup m: syncupresult for obj only n: get objfrag for obj only syncupresult o: syncup tab+obj p: syncupresult for tab+obj q: get objfrag for tab+obj syncupresult r: notify s: syncdown t: syncdownresult for tab only u: syncdownresult for obj only v: get objfrag for obj only syncdownresult w: syncdownresult for tab+obj syncdownresult x: get objfrag for tab+obj syncdownresult.</head><label>7</label><figDesc></figDesc><table>sClient Detection and Recovery. The table shows detection and recovery policies of sClient for failure at read, write, syncup 

and syncdown operations. The operations are a: read tab </table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Acknowledgements</head><p>We thank our FAST reviewers and shepherd, Jason Nieh, for their valuable feedback. We thank Dorian Perkins for his work on Simba Cloud and the IST group at NEC Labs for its setup; Simba Cloud was also evaluated using NMC PRObE <ref type="bibr" target="#b17">[19]</ref>. Younghwan thanks the ICT R&amp;D program of MSIP/IITP, Republic of Korea (14-911-05-001).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Android Developers Website</surname></persName>
		</author>
		<ptr target="http://developer.android.com/index.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Cisco Visual Networking Index: Global Mobile Data Traffic Forecast Update</title>
		<ptr target="http://tinyurl.com/cisco-vni-12" />
		<imprint>
			<biblScope unit="page" from="2011" to="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evernote</forename><surname>App</surname></persName>
		</author>
		<ptr target="http://evernote.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Google</forename><surname>Drive</surname></persName>
		</author>
		<ptr target="https://developers.google.com/drive/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Spdy</forename><surname>Google</surname></persName>
		</author>
		<ptr target="https://developers.google.com/speed/spdy" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Onavo. www.onavo.com</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">App</forename><surname>Sportstracklive Mobile</surname></persName>
		</author>
		<ptr target="http://www.sportstracklive.com/help/android" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Thialfi: a client notification service for internet-scale applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Adya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Piatek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;11</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Diagnosing mobile applications in the wild</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Bahl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM SIGCOMM Workshop on Hot Topics in Networks</title>
		<meeting>the 9th ACM SIGCOMM Workshop on Hot Topics in Networks</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page">22</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Mobile data sync in a blink</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aranya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ungureanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotStorage &apos;13</title>
		<meeting><address><addrLine>San Jose, California</addrLine></address></meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Android Developers. Processes and Threads</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Augmenting mobile 3g using wifi</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Balasubramanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Venkataramani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MobiSys &apos;10</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="209" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Mobius: unified messaging and data serving for mobile apps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B.-G</forename><surname>Chun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Curino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sears</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shraer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MobiSys &apos;12</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Dropbox Datastore API. dropbox.com/ developers/datastore</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dropbox</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Dropbox Sync API. dropbox.com/developers/ sync</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A first look at traffic on smartphones</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Falaki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lymberopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Estrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IMC &apos;10</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Data Staging on Untrusted Surrogates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Flinn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sinnamohideen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Tolia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Satyanarayanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST &apos;03</title>
		<meeting><address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Probe: A thousand-node experimental cluster for computer systems research</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gibson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Grider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lloyd</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-06" />
			<biblScope unit="volume">38</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A disruptiontolerant transmission protocol for practical mobile data offloading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Go</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MobiOpp&apos;12</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Just-in-time provisioning for cyber foraging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Pillai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Richter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Abe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Satyanarayanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MobiSys &apos;13</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="153" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Building a Delay-Tolerant Cloud for Mobile Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aranya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ungureanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE MDM</title>
		<imprint>
			<date type="published" when="2013-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">To Zip or not to Zip: Effective Resource Usage for Real-Time Compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harnik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Margalit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sotnikov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Traeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST 2013</title>
		<imprint>
			<date type="published" when="2013-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Dropbox dbx: Developer conference keynote</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Houston</surname></persName>
		</author>
		<ptr target="http://vimeo.com/70089044" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">An in-depth study of lte: Effect of network protocol and application behavior on performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">M</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Spatscheck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM &apos;13</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Audio Video Surveillance CCTV</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">App</forename><surname>Icamspy</surname></persName>
		</author>
		<ptr target="http://www.icamspy.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Revisiting Storage for Smartphones</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ungureanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST &apos;12</title>
		<imprint>
			<date type="published" when="2012-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kinvey</surname></persName>
		</author>
		<ptr target="http://kinvey.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Disconnected Operation in the Coda File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kistler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Satyanarayanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="1992-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Flexible and safe resolution of file conflicts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Satyanarayanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC &apos;95</title>
		<meeting><address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">LevelDB: A Fast and Lightweight Key/Value Database Library</title>
		<ptr target=".code.google.com/p/leveldb" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Andersen. A short primer on causal consistency. USENIX ;login magazine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kaminsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2013-08" />
			<biblScope unit="volume">38</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Miners</surname></persName>
		</author>
		<ptr target="http://www.pcworld.com/article/2043980/dropbox-adds-new-tools-to-make-syncing-smarter.html" />
		<title level="m">Dropbox adds new tools to make syncing smarter</title>
		<imprint>
			<date type="published" when="2013-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">The case for persistent-connection http</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Mogul</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGCOMM</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="299" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mohan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Haderle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lindsay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pirahesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schwarz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="94" to="162" />
			<date type="published" when="1992-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A LowBandwidth Network File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Muthitacharoen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mazì Eres</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighteenth ACM Symposium on Operating Systems Principles</title>
		<meeting>the Eighteenth ACM Symposium on Operating Systems Principles<address><addrLine>Lake Louise, Alberta</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-10" />
			<biblScope unit="page" from="174" to="187" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">MySQL BLOB and TEXT types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mysql</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">The Design and Implementation of the Inversion File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Olson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Winter &apos;93</title>
		<meeting><address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">The logstructured merge-tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>O&amp;apos;neil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gawlick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>O&amp;apos;neil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Acta Informatica</title>
		<imprint>
			<date type="published" when="1996-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">The role of distributed state</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">K</forename><surname>Ousterhout</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CMU Computer Science: a 25th Anniversary Commemorative</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page">page pp</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Detection of mutual inconsistency in distributed systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Parker</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">J</forename><surname>Popek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Rudisin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Stoughton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">J</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Walton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Engineering</title>
		<imprint>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="240" to="247" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
	<note>IEEE Transactions on</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Where is the energy spent inside my app?: fine grained energy accounting on smartphones with eprof</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pathak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">C</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroSys &apos;12</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="29" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Simba: Tunable End-to-End Data Consistency for Mobile Apps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Perkins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aranya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Go</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Madhyastha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ungureanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Computer Systems (EuroSys &apos;15)</title>
		<meeting>the European Conference on Computer Systems (EuroSys &apos;15)<address><addrLine>Bordeaux, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Docx2go: collaborative editing of fidelity reduced documents on mobile devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">P</forename><surname>Puttaswamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">C</forename><surname>Marshall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ramasubramanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Stuedi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Terry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wobber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MobiSys &apos;10</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename><surname>Quah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Erman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gerber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Spatscheck</surname></persName>
		</author>
		<title level="m">Web caching on smartphones: ideal vs. reality. In MobiSys &apos;12</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Periodic transfers in mobile applications: network-wide origin, impact, and optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gerber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Spatscheck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW &apos;12</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Energy-delay tradeoffs in smartphone applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-R</forename><surname>Ra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Paek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">B</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Govindan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Krieger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Neely</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Mobile Systems, Applications, and Services, MobiSys &apos;10</title>
		<meeting>the 8th International Conference on Mobile Systems, Applications, and Services, MobiSys &apos;10<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="255" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Automatic and scalable fault detection for mobile applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ravindranath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Nath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Padhye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM MobiSys</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Tablefs: Enhancing metadata efficiency in the local file system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gibson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC</title>
		<imprint>
			<date type="published" when="2013-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Why the facebook-parse deal makes parse&apos;s rivals very</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Rowinski</surname></persName>
		</author>
		<ptr target="http://readwrite.com/2013/04/29/parse-acquisition-makes-its-rivals-very-happy" />
		<imprint>
			<date type="published" when="2013-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Implementing fault-tolerant services using the state machine approach: A tutorial</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="299" to="319" />
			<date type="published" when="1990-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Building Workload-Independent Storage with VT-Trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Shetty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">P</forename><surname>Spillane</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Malpani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Andrews</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Seyster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Zadok</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST &apos;13</title>
		<imprint>
			<date type="published" when="2013-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Managing Update Conflicts in Bayou, a Weakly Connected Replicated Storage System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Terry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Theimer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Petersen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Demers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Spreitzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Hauser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;95</title>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">The Cristian Science Monitor. Dropbox has hit the 175-million-user mark</title>
		<ptr target="http://tinyurl.com/mlz8x3c" />
		<imprint>
			<date type="published" when="2013-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Integrating Portable and Distributed Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Tolia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Harkes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kozuch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Satyanarayanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST &apos;04</title>
		<meeting><address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-04" />
			<biblScope unit="page" from="227" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Improving mobile database access over wide-area networks without degrading consistency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Tolia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Satyanarayanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wolbach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th international conference on Mobile systems, applications and services</title>
		<meeting>the 5th international conference on Mobile systems, applications and services</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="71" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Engine Performance and Diagnostic Tool</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Torque</forename><surname>App</surname></persName>
		</author>
		<ptr target="http://torque-bhp.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Efficient Reconciliation and Flow Control for Anti-entropy Protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Van Renesse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dumitriu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Gough</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LADIS &apos;08</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">*-Box: Towards Reliability and Consistency in Dropbox-like File Synchronization Services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yupu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Dragga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Remzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Arpaci-Dusseau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th USENIX Workshop on Hot Topics in Storage and File Systems (HotStorage &apos;13)</title>
		<meeting>the 5th USENIX Workshop on Hot Topics in Storage and File Systems (HotStorage &apos;13)<address><addrLine>San Jose, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">ViewBox: Integrating Local File Systems with Cloud Storage Services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yupu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Dragga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Remzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Arpaci-Dusseau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th Conference on File and Storage Technologies (FAST &apos;14)</title>
		<meeting>the 12th Conference on File and Storage Technologies (FAST &apos;14)<address><addrLine>Santa Clara, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="middle">Zephyr</forename><surname>Zephyr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hxm Bt Heartrate</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Monitor</surname></persName>
		</author>
		<ptr target="http://tinyurl.com/zephyr-sensor" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
