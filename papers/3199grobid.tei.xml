<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T03:03+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">CiAO: An Aspect-Oriented Operating-System Family for Resource-Constrained Embedded Systems *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Lohmann</surname></persName>
							<email>lohmann@cs.fau.de</email>
							<affiliation key="aff0">
								<orgName type="institution">FAU</orgName>
								<address>
									<settlement>Erlangen-Nuremberg, Dortmund</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wanja</forename><surname>Hofer</surname></persName>
							<email>hofer@cs.fau.de</email>
							<affiliation key="aff0">
								<orgName type="institution">FAU</orgName>
								<address>
									<settlement>Erlangen-Nuremberg, Dortmund</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><surname>Schr√∂der-Preikschat</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">FAU</orgName>
								<address>
									<settlement>Erlangen-Nuremberg, Dortmund</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jochen</forename><surname>Streicher</surname></persName>
							<email>jochen.streicher@tu-dortmund.de</email>
							<affiliation key="aff0">
								<orgName type="institution">FAU</orgName>
								<address>
									<settlement>Erlangen-Nuremberg, Dortmund</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olaf</forename><surname>Spinczyk</surname></persName>
							<email>olaf.spinczyk@tu-dortmund.de</email>
							<affiliation key="aff0">
								<orgName type="institution">FAU</orgName>
								<address>
									<settlement>Erlangen-Nuremberg, Dortmund</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">CiAO: An Aspect-Oriented Operating-System Family for Resource-Constrained Embedded Systems *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>This paper evaluates aspect-oriented programming (AOP) as a first-class concept for implementing configurability in system software for resource-constrained embedded systems. To compete against proprietary special-purpose solutions, system software for this domain has to be highly configurable. Such fine-grained configurability is usually implemented &quot;in-line&quot; by means of the C preprocessor. However, this approach does not scale-it quickly leads to &quot;#ifdef hell&quot; and a bad separation of concerns. At the same time, the challenges of configurability are still increasing. AUTOSAR OS, the state-of-the-art operating-system standard from the domain of automotive embedded systems, requires configurability of even fundamental architectural system policies. On the example of our CiAO operating-system family and the AUTOSAR-OS standard, we demonstrate that AOP-if applied from the very beginning-is a profound answer to these challenges. Our results show that a well-directed, pragmatic application of AOP leads to a much better separation of concerns than does #ifdef-based configuration-without compromising on resource consumption. The suggested approach of aspect-aware operating-system development facilitates providing even fundamental system policies as configurable features.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The design and implementation of operating systems has always been challenging. Besides the sheer size and the inherent asynchronous and concurrent nature of operatingsystem code, developers have to deal with lots of crucial nonfunctional requirements such as performance, reliability, and maintainability. Therefore, researchers have always tried to exploit the latest advances in programming * This work was partly supported by the German Research Council (DFG) under grants no. SCHR 603/4, SCHR 603/7-1, and SP 968/2-1. languages and software engineering (such as object orientation <ref type="bibr" target="#b5">[6]</ref>, meta-object protocols <ref type="bibr" target="#b26">[26]</ref>, or virtual execution environments <ref type="bibr" target="#b14">[14]</ref>) in order to reduce the complexity of operating system development and to improve the systems' nonfunctional properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Operating Systems for Small Embedded Systems</head><p>This paper focuses on small ("deeply") embedded systems. More than 98 percent of the worldwide annual production of microprocessors ends up in small embedded systems <ref type="bibr" target="#b24">[24]</ref> -typically employed in products such as cars, appliances, or toys. Such embedded systems are subject to an enormous hardware-cost pressure. System software for this domain has to cope not only with strict resource constraints, but especially with a broad variety of application requirements and platforms. So to allow for reuse, an operating system for the embedded-systems domain has to be developed as a system-software product line that is highly configurable and tailorable. Furthermore, resource-saving static configuration mechanisms are strongly favored over dynamic (re-)configuration.</p><p>A good example for this class of highly configurable systems with small footprint is the new embedded operating-system standard specified by AUTOSAR, a consortium founded by all major players in the automotive industry <ref type="bibr" target="#b2">[3]</ref>. The goal of AUTOSAR is to continue the success story of the OSEK-OS specification <ref type="bibr" target="#b19">[19]</ref>. OSEKcompliant operating systems have been used in almost all European cars over the past ten years, which led to an enormous productivity gain in automotive software development. AUTOSAR extends the OSEK-OS specification in order to cover the whole system-software stack including communication services and a middleware layer.</p><p>Even in this restricted domain, there is already a huge variety of application requirements on operating systems. For instance, power-train applications are typically safetycritical and have to deal with real-time requirements,  <ref type="figure">Figure 1</ref>: "#ifdef hell" example from eCos <ref type="bibr" target="#b18">[18]</ref> while car body systems are far less critical. Hardware platforms range from 8-bit to 32-bit systems. Some applications require a task model with synchronization and communication primitives, whereas others are much simpler control loops. In order to reduce the number of electronic control units (up to 100 in modern cars <ref type="bibr" target="#b4">[5]</ref>), some manufacturers have the requirement to run multiple applications on the same unit, which is only possible with guaranteed isolation; others do not have this requirement. To fulfill all these varying requirements, the AUTOSAR-OS specification <ref type="bibr" target="#b1">[2]</ref> describes a family of systems defined by so-called scalability classes. It not only requires configurability of simple functional features, but also of all policies regarding temporal and spatial isolation. To achieve this within a single kernel implementation is challenging. The decision about fundamental operating-system policies (like the question if and how address-space protection boundaries should be enforced) is traditionally made in the early phases of operating-system development and is deeply reflected in its architecture, which in turn has an impact on many other parts of the kernel implementation.</p><p>In AUTOSAR-OS systems, these decisions have to be postponed until the application developer configures the operating system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">The Price of Configurability</head><p>In a previous paper <ref type="bibr" target="#b17">[17]</ref>, we analyzed the implementation of static configurability in the popular eCos operating system <ref type="bibr" target="#b18">[18]</ref>, which also targets small embedded systems.</p><p>The system implements configurability in the familiar way with #ifdef-based conditional compilation (in C++). Even though eCos does not support configurability of architectural concerns as required by AUTOSAR (such as the memory or timing protection model), we have found an "#ifdef hell", which illustrates that these techniques do not scale well enough. Maintainability and evolvability of the implementation suffer significantly. As an example, <ref type="figure">Figure 1</ref> shows the "#ifdef hell" in the constructor of the eCos mutex class, caused by just four variants of the optional protcol for the prevention of priority inversion. However, the configurability of this protocol does not only affect the constructor code -a total of 34 #ifdef-blocks is spread over 17 functions and data structures in four implementation files. As a solution, we proposed aspect-oriented programming (AOP) <ref type="bibr" target="#b15">[15]</ref> and analyzed the code size and performance impact of applying AOP to factor out the scattered implementation of configurable eCos features into distinct modules called aspects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Aspect-Oriented Programming</head><p>AOP describes a programming paradigm especially designed to tackle the implementation of crosscutting concerns -concerns that, even though conceptually distinct, overlap with the implementation of other concerns in the code by sharing the same functions or classes, such as the mutex configuration options in eCos.</p><p>In AOP, aspects encapsulate pieces of code called advice that implement a crosscutting concern as a distinct module. A piece of advice targets a number of join points (points in the static program structure or in the dynamic execution flow) described by a predicate called pointcut expression. Pointcut expressions are evaluated by the aspect weaver, which weaves the code from the advice bodies to the join points that are matched by the respective predicates.</p><p>As pointcuts are described declaratively, the target code itself does not have to be prepared or instrumented to be affected by aspects. Furthermore, the same aspect can affect various and even unforeseen parts of the target code. In the AOP literature <ref type="bibr" target="#b10">[10]</ref>, this is frequently referred to as the obliviousness and quantification properties of AOP.</p><p>The AOP language and weaver used in the eCos study and in the development of CiAO is AspectC++ <ref type="bibr" target="#b22">[22]</ref>, a source-to-source weaver that transforms AspectC++ sources to ISO C++ code, which can then be compiled by any standard-compliant C++ compiler. <ref type="figure" target="#fig_0">Figure 2</ref> illustrates the syntax of aspects written in AspectC++. The (excerpted) aspect Priority _ Ceiling implements the priority ceiling variant of the eCos mutex class. For this purpose, it introduces a slice of additional elements (the member variable ceiling) into the In AspectC++, pointcut expressions are built from match expressions and pointcut functions. The match expression "Cyg _ Mutex", for instance, returns a pointcut containing just the class Cyg _ Mutex. Match expressions can also be fed into pointcut functions to yield pointcuts that represent events in the control flow of the running program, such as the event where some function is about to be called (call() advice) or an object instance is about to be constructed (see construction("Cyg _ Mutex") in <ref type="figure" target="#fig_0">Figure 2</ref>). In most cases, the join points for a given pointcut can be derived statically by the aspect weaver so that the respective advice is also inserted statically at compile time without any run-time overhead.</p><p>The construction pointcut in the example is used to specify some after advice -that is, additional behavior to be triggered after the event occurrence. Other types of advice include before advice (speaks for itself) and around advice (replaces the original behavior associated with the event occurrence).</p><p>Inside the advice body, the type and pointer JoinPoint * tjp provide an interface to the event context. The aspect developer can use this join-point API to retrieve (and partly modify) contextual information associated with the event, such as the arguments or return value of the intercepted function call (tjp-&gt;arg(i), tjp-&gt;result()). The tjp-&gt;that() in <ref type="figure" target="#fig_0">Figure 2</ref> returns the this pointer of the affected object instance, which is used here to initialize the ceiling member variable (which in this case was introduced by the aspect itself).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Contribution and Outline</head><p>The results of applying AOP to eCos were very promising <ref type="bibr" target="#b17">[17]</ref>. The refactored eCos system was much better structured than the original; the number of configuration points per feature could be drastically reduced. At the same time, we found that there is no negative impact on the system's performance or code size.</p><p>However, we also found that not all configurable features could be refactored into a modular aspect-oriented implementation. The main reason was that eCos did not expose enough unambiguous join points. We took this as a motivation to work on "aspect-aware operating system design". This led to the development of fundamental design principles and the implementation of the CiAO 1 OS family for evaluation purposes. The idea was to build an operating system in an aspect-oriented way from scratch, considering AOP and its mechanisms from the very beginning of the development process. The resulting CiAO system is aspect-aware in the sense that it was analyzed, designed, and implemented with AOP principles in mind. In order to avoid evaluation results biased by the eCos implementation, CiAO was newly designed after the AUTOSAR-OS standard introduced above <ref type="bibr" target="#b1">[2]</ref>.</p><p>Our main goal is to evaluate the suitability of aspectoriented software development as a first-class concept for the design and implementation of highly configurable embedded system software product-lines. The research contributions of this work are the following:</p><p>‚Ä¢ Deeper insights on reasons for the #ifdef hell and the value of AOP in this context (Section 2).</p><p>‚Ä¢ Design principles for aspect-aware operating system development (Section 4).</p><p>‚Ä¢ CiAO: The first complete implementation of an operating system kernel developed with AOP concepts 2 (Section 5).</p><p>‚Ä¢ A discussion of our results from CiAO (Section 6) and general experiences with the approach (Section 7).</p><p>For each of the topics, there is a dedicated section in the remaining part of this paper. In addition to that, Section 3 discusses relevant related work. The paper ends with our conclusions in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Problem Analysis</head><p>Why exactly do state-of-the-art configurable systems like eCos exhibit badly modularized code termed as "#ifdef hell"? Is this an inherent property of highly configurable operating systems or just a matter of implementation means? In order to examine these questions, we took a detailed look at an abstract system specification, namely the AUTOSAR-OS standard introduced in Section 1. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ÒÆΩô ÒÆΩô</head><p>...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>"</head><p># <ref type="table" target="#tab_0">Table 1</ref>: Influence of configurable concerns (columns) on system services, system types, and internal events (rows) in AUTOSAR OS <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b19">19]</ref>; kind of influence: ‚äï = extension of the API by a service or type, = extension of an existing type, = modification after service or event, = modification before, = modification before and after</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Why #ifdef Hell Appears to Be Unavoidable</head><p>The AUTOSAR-OS standard proposes a set of scalability classes for the purpose of system tailoring. These classes are, however, relatively coarse-grained (there are only four of them) and do not clearly separate between conceptually distinct concerns. CiAO provides a much better granularity; each AUTOSAR-OS concern is represented as an individual feature in CiAO, subject to applicationdependent configuration. In order to be able to grasp all concerns and their interactions, we have developed a specialized analysis method termed concern impact analysis (CIA) <ref type="bibr" target="#b13">[13]</ref>. The idea behind CIA is to consider requirement documents together with domain-expert knowledge to develop a matrix of concerns and their influences in an iterative way. In the analysis of the AUTOSAR-OS standard, CIA yielded a comprehensive matrix, which is excerpted in <ref type="table" target="#tab_0">Table 1</ref>.</p><p>The rows show the AUTOSAR OS system services (API functions) and system abstractions (types) in groups that represent distinct features. AUTOSAR OS is a statically configured operating system with static task priorities; hence, at run time, only services that alter the status of a task (e.g., setting it ready or suspended) are available. Interrupt service routines (ISRs), in contrast, are triggered asynchronously; the corresponding system functionality allows the application to prohibit their occurrence collectively or on a per-source basis. AUTOSAR OS distinguishes between two categories of ISRs that are somewhat comparable to top halves and bottom halves in Linux: Category-1 ISRs are scheduled by the hardware only and must not interact with the kernel. Category-2 ISRs, in contrast, run under the control of the kernel and may invoke other AUTOSAR-OS services. The third type of control flows supported by the AUTOSAR-OS kernel are hooks. Hooks define a callback interface for applications to be notified about kernel-internal events, such as task switch events or error conditions (see Column 8 in <ref type="table" target="#tab_0">Table 1</ref>).</p><p>Resources are the means for AUTOSAR applications to ensure mutual exclusion to synchronize concurrent access to data structures or hardware periphery. They are comparable to mutex objects in other operating systems. In order to avoid priority inversion and deadlocks, AU-TOSAR prescribes a stack-based priority ceiling protocol, which adapts task priorities at run time. Hence, a task never blocks on GetResource(). The only way for application tasks to become blocked is by waiting for an AUTOSAR-OS event; another task or ISR that sets that event can unblock that task.</p><p>Alarms allow applications to take action after a specified period of time; a schedule table is an abstraction that encapsulates a series of alarms. Finally, tasks, ISRs, and data can be partitioned into OS applications, which define a spatial and temporal protection boundary to be enforced by the operating system.</p><p>The table lists selected identified concerns of AU-TOSAR OS (column headings) and how we can expect them to interact with the named entities of the specification (row headings); that is, the 44 system services (e.g., ActivateTask()) and the relevant system abstractions (e.g., TaskType) as specified in <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b1">2]</ref>. Furthermore, the lower third lists how we can expect concerns to impact system-internal transitions, which are not visible in the system API that is specified by the standard. Table 1 thereby provides an overview of how we can expect AUTOSAR-OS concerns to crosscut with each other in the structural space (abstractions, services) and behavioral space (control flow events) of the implementation.</p><p>The comprehensive table shows that a system that is built according to that specification will inherently exhibit extensive crosscutting between its concern implementations, leading to code tangling (many different concerns implemented in a single implementation module) and scattering (distribution of a single concern implementation across multiple implementation artifacts). This is because services like ReleaseResource() (see <ref type="table" target="#tab_0">Table 1</ref>, row ¬ñ) and types like TaskType (see <ref type="table" target="#tab_0">Table 1</ref>, row ¬ó), for instance, are affected by as many as nine different concerns! That means that these implementations will exhibit at least nine #ifdef blocks -in the ideal case that each concern can be encapsulated in a single block, completely independent of the other concerns (which is unrealistic, of course). In fact, there is not a single AUTOSAR-OS service that is influenced by only one concern, which means that a straight-forward implementation using the C preprocessor will have numerous #ifdefs in every implementation entity. Thus, "#ifdef hell" seems unavoidable for the class of special-purpose, tailorable operating systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Why AOP Is a Promising Solution</head><p>There are several properties inherent in AOP that are promising with respect to overcoming the drawbacks in #ifdef-based configuration techniques that were detailed above.</p><p>First, AOP introduces a new kind of binding between modules. In traditional programming paradigms, the caller module P (event producer) knows and has to know the callee module C (event consumer); that is, its name and interface (see <ref type="figure" target="#fig_3">Figure 3</ref>.a):   ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>// feature binds "itself"</head><p>} If module C is optional and configurable, this loose coupling is an ideal mechanism for integration, because the call is implicit in the callee module. Using the traditional mechanisms, the call has to be included in the base module P and therefore has to be explicitly omitted if the feature implemented by module C is not in the current configuration. This configurable omission is realized by #ifdefs in state-of-the-art systems, bearing the significant disadvantages described above. A similar advantage of advice-based binding applies to configurable static program entities like classes or structures; aspects can integrate the state and operations needed to implement the corresponding feature into those entities themselves through slice introductions.</p><p>Second, by offering the mechanism of quantification through pointcut-expression matching, AOP allows for a modularized implementation of crosscutting concerns, which is also one of its main proclaimed purposes. This mechanism provides a flexible and implicit instantiation of additional implementation elements at compile-time (see <ref type="figure" target="#fig_3">Figure 3</ref>.c), ideally suited for the integration of concern implementations into configurable base code where the number of junction points (i.e., AOP join points) is flexible, ranging from zero to n: advice execution("void %::caller()") : after() { &lt;additional feature&gt; // binds to any "caller()" } As we have seen in <ref type="table" target="#tab_0">Table 1</ref>, most concerns in an AUTOSAR-OS implementation have a crosscutting im-pact on many different points in the system in a similar way. An example is the policy that system services must not be called while interrupts are disabled (see <ref type="table" target="#tab_0">Ta- ble 1</ref>, column ¬ò). In the requirements specification of AUTOSAR OS, this policy is defined by requirement OS093:</p><p>If interrupts are disabled and any OS services, excluding the interrupt services, are called outside of hook routines, then the operating system shall return E _ OS _ DISABLEDINT. <ref type="bibr">[2, p. 40]</ref> This requirement can be translated almost "literally" to a single, modularized AspectC++ aspect: For convenience and the sake of separation of concerns, the aspect uses predefined named pointcuts, which are defined separately from the aspects in a global header file and specify which AUTOSAR-OS service belongs to which group: pointcut pcOSServices() = "% ActivateTask()" || ... pointcut pcISRServices() = ... ...</p><p>Using these named pointcuts, the aspect gives advice to all points in the system where any OS service but not the interrupt services are called:</p><formula xml:id="formula_0">call(pcOSServices() &amp;&amp; !pcISRServices()) ...</formula><p>The resulting set of join points is further filtered to exclude all events from within a hook routine:</p><formula xml:id="formula_1">... &amp;&amp; !within(pcHooks())</formula><p>Thus, we eventually get all calls outside of hook routines that are made to any service that is not an ISR service. The piece of around advice given to these join points performs a test whether the interrupts are currently disabled: If positive, the return code is set to the prescribed error code and the call is aborted; if negative, the call is performed as normal. (Around advice replaces the original processing of the intercepted event; however, it is possible to invoke the original processing explicitly with</p><formula xml:id="formula_2">tjp-&gt;proceed().)</formula><p>The complete concern is encapsulated in this single aspect. The result is an enhanced separation of concerns in the system implementation. Layered, configurable systems can especially benefit from AOP mechanisms by being able to flexibly omit parts of the system without breaking caller-callee relationships.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Related Work</head><p>There are several other research projects that investigate the applicability of aspects in the context of operating systems. Among the first was the Œ±-kernel project <ref type="bibr" target="#b6">[7]</ref>, in which the evolution of four scattered OS concern implementations (namely: prefetching, disk quotas, blocking, and page daemon activation) between versions 2 and 4 of the FreeBSD kernel is analyzed retroactively. The results show that an aspect-oriented implementation would have led to significantly better evolvability of these concerns. Around the same time, our own group experimented with AspectC++ in the PURE OS product line and later with aspect-refactoring eCos <ref type="bibr" target="#b17">[17]</ref>. Our results from analyzing the AspectC++ implementation of various previously hard-wired crosscutting concerns show that this new paradigm leads to no overhead in terms of resource consumption per se.</p><p>Not a general-purpose AOP language but an AOPinspired language of temporal logic is used in the Bossa project to integrate the Bossa scheduler framework into the Linux kernel <ref type="bibr" target="#b0">[1]</ref>. Another example for a specialpurpose AOP-inspired language is C4 <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b21">21]</ref>, which is intended for the application of kernel patches in Linux. The same goal of smarter patches (with a focus on "collateral evolutions" -changes to the kernel API that have to be caught up in dozens or hundreds of device drivers) is followed by Coccinelle <ref type="bibr" target="#b20">[20]</ref>. Although the input language for the Coccinelle engine "SmPL" is not called an AOP language, it supports the modular implementation of crosscutting kernel modifications (i.e., quantification). Other related work concentrates on dynamic aspect weaving as a means for run-time adaptation of operating-system kernels: TOSKANA provides an infrastructure for the dynamic extension of the FreeBSD kernel by aspects <ref type="bibr" target="#b9">[9]</ref>; KLASY is used for aspect-based dynamic instrumentation in Linux <ref type="bibr" target="#b25">[25]</ref>.</p><p>All these studies demonstrate that there are good cases for aspects in system software. However, both Bossa and our own work on eCos show that a useful application of AOP to existing operating systems requires additional AOP expressivity that results in run-time overheads (e.g., temporal logic or dynamic instrumentation). So far no study exists that analyzes the effects of using AOP for the development of an operating-system kernel from the very beginning. This paper explores just that.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Aspect-Aware Operating-System Development</head><p>The basic idea behind aspect-aware operating-system development is the strict separation of concerns in the implementation. Each implementation unit provides exactly one feature; its mere presence or absence in the config-ured source tree decides on the inclusion of the particular feature into the resulting system variant. Technically, this comes down to a strict decoupling of policies and mechanisms by using aspects as the primary composition technique: Kernel mechanisms are glued together and extended by aspects; they support aspects by ensuring that all relevant internal control-flow transitions are available as unambigious and statically evaluable join points.</p><p>However, this availability cannot be taken for granted. Improving the configurability of eCos even further did not work as good as expected because of join-point ambiguity <ref type="bibr" target="#b17">[17]</ref>. For instance, eCos does not expose a dedicated user API to invoke system services. This means that, on the join-point level, user kernel transitions are not statically distinguishable from the kernel-internal activation and termination of system services. The consequence is that policy aspects that need to hook into these events become more expensive than necessary -for instance, an aspect that implements a new kernel-stack policy by switching stacks when entering/leaving the kernel. The ideal implementation of the kernel-stack feature had a performance overhead of 5% for the actual stack switches, whereas the aspect implementation induced a total overhead of 124% only because of unambiguous join points. The aspect had to use dynamic pointcut functions to disambiguate at run time: It used cflow(), a dynamic pointcut function that induces an extra internal control-flow counter that has to be incremented, decremented, and tested at run time to yield the join points.However, in other cases it was not possible at all to disambiguate, rendering an aspect-based implementation of new configuration options impossible.</p><p>We learned from this that the exposure of all relevant gluing and extension points as statically evaluable and unambigious join points has to be understood as a primary design goal from the very beginning. The key premise for such aspect awareness is a component structure that makes it possible to influence the composition and shape of components as well as all run-time control flows that run through them by aspects <ref type="bibr" target="#b16">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Design Principles</head><p>The eCos experience led us to the three fundamental principles of aspect-aware operating-system development:</p><p>The principle of loose coupling. Make sure that aspects can hook into all facets of the static and dynamic integration of system components. The binding of components, but also their instantiation (e.g, placement in a certain memory region) and the time and order of their initialization should all be established (or at least be influenceable) by aspects.</p><p>The principle of visible transitions. Make sure that aspects can hook into all control flows that run through the system. All control-flow transitions into, out of, and within the system should be influenceable by aspects. For this they have to be represented on the join-point level as statically evaluable, unambiguous join points.</p><p>The principle of minimal extensions. Make sure that aspects can extend all features provided by the system on a fine granularity. System components and system abstractions should be fine-grained, sparse, and extensible by aspects.</p><p>Aspect awareness, as described by these principles, means that we moderate the AOP ideal of obliviousness, which is generally considered by the AOP community as a defining characteristic of AOP <ref type="bibr" target="#b11">[11]</ref>. CiAO's system components and abstractions are not totally oblivious to aspects -they are supposed to provide explicit support for aspects and even depend on them for their integration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Role and Types of Classes and Aspects</head><p>The relationship between aspects and classes is asymmetrical in most AOP languages: Aspects augment classes, but not vice versa. This gives rise to the question which features are best to be implemented as classes and which as aspects and how both should be applied to meet the above design principles. The general rule we came up with in the development of CiAO is to provide some feature as a class if -and only if -it represents a distinguishable instantiable concept of the operating system. Provided as classes are:</p><p>1. System components, which are instantiated on behalf of the kernel and manage its run-time state (such as the Scheduler or the various hardware devices).</p><p>2. System abstractions, which are instantiated on behalf of the application and represent a system object (such as Task, Resource, or Event).</p><p>However, the classes for system components and system abstractions are sparse and to be further "filled" by extension slices. The main purpose of these classes is to provide a distinct scope with unambiguous join points for the aspects (that is, visible transitions). All other features are implemented as aspects. During the development of CiAO we came up with three idiomatic roles of aspects:</p><p>1. Extension aspects add additional features to a system abstraction or component (minimal extensions), such as extending the scheduler by means for task synchronization (e.g., AUTOSAR-OS resources).</p><p>2. Policy aspects "glue" otherwise unrelated system abstractions or components together to implement some kernel policy (loose coupling), such as activating the scheduler from a periodic timer to implement time-triggered preemptive scheduling.</p><p>3. Upcall aspects bind behavior defined by higher layers to events produced in lower layers of the system, such as binding a driver function to interrupt events.</p><p>The effect of extension aspects typically becomes visible in the API of the affected system component or abstraction. Policy aspects, in contrast, lead to a different system behavior. We will see examples for extension and policy aspects in the following section. Upcall aspects do not contribute directly to a design principle, but have a more technical purpose: they exploit advice-based binding and the fact that AspectC++ inlines advice code at the respective join point for flexible, yet very efficient upcalls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Case Study: CiAO-AS</head><p>CiAO is designed and implemented as a family of operating systems and has been developed from scratch using the principles of aspect-aware operating-system development. Note, however, that the application developer does not have to have any AOP expertise to use the OS. A concrete CiAO variant is configured statically by selecting features from a feature model in an Eclipse-based graphical configuration tool <ref type="bibr" target="#b3">[4]</ref>. The CiAO-AS family member implements an operatingsystem kernel according to the AUTOSAR-OS standard 3 <ref type="bibr" target="#b1">[2]</ref>, including configurable protection policies (memory protection, timing protection, service protection). The primary target platform for CiAO is the Infineon TriCore, an architecture of 32-bit microcontrollers that also serves as a reference platform for AUTOSAR and is widely used in the automotive industry. <ref type="figure" target="#fig_5">Figure 4</ref> shows the basic structure of the CiAO-AS kernel. Like most operating systems, CiAO is designed with a layered architecture, in which each layer is implemented using the functionality of the layers below. The only exceptions to this are the aspects implementing architectural policies, which may affect multiple layers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Overview</head><p>On the coarse level, we have three layers. From bottom up these are: the hardware access layer, the system layer (the operating system itself), and the API layer. In CiAO, however, layers do not just serve conceptual purposes, but also are a means of aspect-aware development. With regard to the principle of visible transitions, each layer is represented as a separate C++ namespace in the implementation (hw::hal, os::krn, AS). Thereby, cross-layer control-flow transitions (especially into and out of os::krn) can be grasped by statically evaluable pointcut expressions. The following expression, for instance, yields all join points where a system-layer component accesses the hardware: pointcut pcOStoHW() = call("% hw::hal::%(...)") &amp;&amp; within("% os::krn::%(...)");</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">The Kernel</head><p>In its full configuration, the system layer bears three logical system components (displayed as columns in <ref type="figure" target="#fig_5">Fig- ure 4</ref>):</p><p>1. The scheduler (Scheduler) takes care of the dispatching of tasks and the scheduling strategy.</p><p>2. The synchronization facility (Synchronizer) takes care of the management of events, alarms, and the underlying (hardware / software) counters.</p><p>3. The OS control facility (OSControl) provides services for the controlled startup and shutdown of the system and the management of OSEK/AUTOSAR application modes.</p><p>However, as pointed out in Section 4.2, these classes are sparse or even empty. If at all, they implement only a minimal base of their respective concern. All further concerns and variants (depicted in dark grey in <ref type="figure" target="#fig_5">Figure 4)</ref> are brought into the system by aspects, most of which touch multiple system components and system abstractions. ... ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>};</head><p>Support for preemption and further abstractions is provided by additional extension aspects and policy aspects.</p><p>ResourceSupport is an example for an extension aspect. It extends the Task system abstraction Scheduler system component with support for resources. For this purpose, it introduces some state variables (occupied _ , originalPri _ ) and operations (getResource(), releaseResource()). <ref type="bibr" target="#b3">4</ref> The elements to introduce are given by respective extension slices: 4 ResourceSupport furthermore extends the API on the interface layer (it introduces the respective AUTOSAR-OS services Get-/ReleaseResource() and the ResourceType abstraction) so that applications can use the new functionality. For the sake of simplicity, this cross-layer extension is omitted here. FullPreemption is an example for a policy aspect. It implements the full-preemption policy as specified in <ref type="bibr" target="#b19">[19]</ref>, according to which every point where a higher-priority task may become ready is a potential point of preemption: The named pointcut pcPreemptionPoints() (defined in a global header file) specifies the potential preemption points. To these points, if present, the aspect FullPreemption binds the invocation of reschedule(). This demonstrates the benefits of loose coupling by the AOP mechanisms, which makes it easy to cope with conceptually different, but technically interacting features: In a fully-preemptive system without resource support, <ref type="bibr">Scheduler</ref>  <ref type="table">Table 2</ref>: Selected CiAO-AS kernel concerns implemented as aspects with number of affected join points. Listed are selected kernel concerns that are implemented as extension, policy, or upcall aspects, together with the related pieces of advice (not including order advice), the affected number of join points, and a short explanation for the purpose of each join point (separated by "|" into introductions of extension slices | advice-based binding).</p><p>Resource() implicitly triggers the advice. The separation of policy invocation from mechanism implementation makes it easy to integrate additional features, such as the ResourceSupport _ PCP aspect, which implements a stack-based priority ceiling protocol for resources. As AspectC++ inlines advice code at the matching join point, this flexibility does not cause overhead at run time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion of Results</head><p>By following the principles of aspect-aware operating system development, policies and mechanisms are cleanly separated in the CiAO implementation. This separation is a golden rule of system-software development, but in practice difficult to achieve. While on the design level it is usually possible to describe a policy in a well-separated manner from underlying mechanisms, the implementation often tends to be crosscutting. The reason is that many system policies, such as the preemption policy, not only depend on decisions but also on the specific points in the control flow where these decisions are made. Here, the modularization into aspects shows some clear advantages. <ref type="table">Table 2</ref> displays an excerpt of the list of AUTOSAR-OS concerns that are implemented as aspects in CiAO-AS. The first three columns list for each concern the number of extension, policy, and upcall aspects that implement the concern. (The resource-support aspect and the protectionhook aspect have both an extension and a policy facet.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Modularization of the System</head><p>An interesting point is the realization of synergies by means of AOP quantification. If for some concern the number of pieces of advice is lower than the number of affected join points, we have actually profited from the AOP concept of quantification by being able to reuse advice code over several join points. For 8 out of the 14 concerns listed in <ref type="table">Table 2</ref>, this is the case.</p><p>The net amount of this profit depends on the type of concern and aspect. Extension aspects typically crosscut heterogeneously with the implementation of other concerns, which means that they have specific pieces of advice for specific join points. These kinds of advice do not leave much potential for synergies by quantification. Policy aspects on the other hand -especially those for architectural policies -tend to crosscut homogeneously with the implementation of other concerns, which means that a specific piece of advice targets many different join points at once. In these cases, quantification creates significant synergies.</p><p>For all concerns, however, the implementation is realized as a distinct set of aspect modules, thereby reaching complete encapsulation and separation of concerns. Thus, any given feature configuration demanded by the application developer can be fulfilled by only including the implementation entities belonging to that configuration in the configured source tree to be compiled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Scalability of the System</head><p>Execution Time. The effects of the achieved configurability also become visible in the CPU overhead. <ref type="table" target="#tab_3">Table 3</ref> displays the execution times of the micro-benchmark sce-narios 5 (a) to (j) and the comprehensive application (k) on CiAO and a commercial OSEK implementation <ref type="bibr" target="#b5">6</ref> . For each scenario, we first configured both systems to support the smallest possible set of features (min colums in <ref type="table" target="#tab_3">Table 3</ref>). The differences between CiAO and OSEK are considerable: CiAO is noticeably faster in all test scenarios.</p><p>One reason for this is that CiAO provides a much better configurability (and thereby granularity) than OSEK. As the micro-benchmark scenarios utilize only subsets of the OSEK/AUTOSAR features, this has a significant effect on the resulting execution times. The smallest possible configurations of the commercial OSEK still contained a lot of unwanted functionality. The scheduler is synchronized with ISRs, for instance; however, most of the application scenarios do not include any ISRs that could possibly interrupt the kernel.</p><p>To judge these effects, we performed additional measurements with an "artifically enriched" version of CiAO that provides the same amount of unwanted functionality as OSEK (column full in <ref type="table" target="#tab_3">Table 3</ref>). This reduces the performance differences; however, CiAO is still faster in six out of eleven test cases. This is most notable in test case (k), which is a comprehensive application that actually uses the full feature set.</p><p>Another reason for the relative advantage of CiAO is that OSEK's internal thread-abstraction implementation is less efficient. This is mainly due to particularities of the TriCore platform, which renders standard context-switch implementations ported to that platform very inefficient. CiAO, however, has a highly configurable and adaptable thread abstraction, therefore not only providing for an upward tailorability (i.e., to the needs of the application), but also downward toward the deployment platform.</p><p>Memory Requirements. In embedded systems, tailorability is crucial -especially with respect to memory consumption, because RAM and ROM are typically limited to sizes of a few kilobytes. Since system software does not directly contribute to the business value of an embedded system, scalability is of particular importance here. Thus, we also investigated how the memory requirements of the CiAO-AS kernel scale up with the number of selected configurable features; the condensed results are depicted in <ref type="table" target="#tab_4">Table 4</ref>. Listed are the deltas in code, data, and BSS section size per feature that is added to the CiAO base system.</p><p>Each Task object, for instance, takes 20 bytes of data for the kernel task context (priority, state, function, stack, interrupted flag) and 16 bytes (bss) for the underlying CiAO thread abstraction structure. Aspects from the implementation of other features, however, may extend the size of the kernel task context. Resource support, for instance, crosscuts with task management in the implementation of the Task structure, which it extends by 8 bytes to accommodate the occupied resources mask and the original priority.</p><p>The cost of several features does not simply induce a constant cost, but depends on the number of affected join points, which in turn can depend on the presence of other features, as explained in Section 5.3 with the example of full preemption and resource support. This effect underlines again the flexibility of loose coupling by advice-based binding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experiences with the Approach</head><p>The CiAO results show that the approach of aspect-aware operating-system development is both feasible and beneficial for the class of configurable embedded operating systems. The challenge was to implement a system in which almost everything is configurable. In the following, we describe our experience with the approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Extensibility</head><p>We are convinced that the three design principles of aspect-aware operating-system development (loose coupling, visible transitions, minimal extensions) also lead to an easy extensibility of the system for new, unanticipated features. While it is generally difficult to prove the soundness of an approach for unanticipated change, we have at least some evidence that our approach has clear benefits  here:</p><p>In a specific real-time application project that we implemented using CiAO, minimal and deterministic eventprocessing latencies were crucial. The underlying hardware platform was the Infineon TriCore, which actually is a heterogeneous multi-processor-system-on-chip that comes with an integrated peripheral control processor (PCP). This freely-programmable co-processor is able to handle interrupts independently of the main processor. We decided to extend CiAO in a way that the PCP prehandles all hardware events (interrupts) in order to map them to activations of respective software tasks, thereby preventing the real-time problem of rate-monotonic priority inversion <ref type="bibr" target="#b8">[8]</ref>. This way, the CPU is only interrupted when there actually is a control flow of a higher priority than the currently executing one ready to be dispatched.</p><p>This relatively complex and unanticipated extension could nevertheless be integrated into CiAO by a single extension aspect, which is shown in <ref type="figure" target="#fig_13">Figure 6</ref>. The PCP _ Extension aspect is itself a minimal extension; its implementation profited especially from the fact that all other CiAO components are designed according to the principle of visible transitions. This ensures here that all relevant transitions of the CPU, such as when the kernel is entered or left (lines 9 and 14, respectively) or when the running CPU task is about to be preempted (line 17), are available as statically evaluable and unambigious join points to which the aspect can bind.</p><p>Note, that the aspect in <ref type="figure" target="#fig_13">Figure 6</ref> is basically the complete code for that extension, except for some initialization code (10 lines of code) and the PCP code, which is written in assembly language due to the lack of a C/C++ compiler for the PCP instruction set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">The Role of Language</head><p>We think that the expressiveness of the base language (in our case C++) plays an important role for the effectiveness of the approach. Thanks to modularization through namespaces and classes, C++ has some clear advantages over C with respect to visible transitions: the more of the base program's purpose and semantics is expressed in its syntactic structure, the more unambigious and "semantically rich" join points are available to which the aspects can bind.</p><p>Note, however, that even though CiAO is using C++, it is not developed in an object-oriented manner. We used C++ as a purely static language and stayed away from any language feature that induces a run-time overhead, such as virtual functions, exceptions, run-time type information, and automatic construction of global variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Technical Issues</head><p>Aspects for Low-Level Code. A recurring challenge in the development of CiAO was that the implementation of fundamental low-level OS abstractions, such as interrupt handlers or the thread dispatcher, requires more control over the resulting machine code than is guaranteed by the semantics of ISO C++. Such functions are typically (1) written entirely in external assembly files or (2) use a mixture of inline assembly and nonstandard language extensions (such as __ attribute __ ((interrupt)) in gcc). For the sake of visible transitions, we generally opted for (2). However, the resulting join points often have to be considered as fragile -if advice is given to, for instance, the context switch function, the transformations performed by the aspect weaver might break the programmer's implicit assumptions about register usage or the stack layout. The workaround we came up with for these cases is to provide explicit join points to which the aspects can bind instead. Technically, an explicit join point is represented by an empty inline function that is invoked from the fragile code when the execution context is safe. CiAO's context switch functionality, for instance, exposes four explicit join points to which aspects can bind: before _ CPURelease(), before _ LastCPURelease(), after _ CPUReceive(), and after _ FirstCPUReceive(). Because of function inlin-  Aspect-Aspect Interdependencies. In several cases we had to deal with subtle interdependencies between aspects that affect the same join points. For instance, the following aspect implements the ErrorHook feature, which exempts the application developer from manually testing the result code of OS services: Later we figured that, depending on the configuration, there are also other aspects that modify the result code. To fulfill its specification, ErrorHook has to be invoked after these other aspects. Whereas detecting such interdependencies was sometimes tricky (especially those that emerge only in certain configurations), they were generally easy to resolve by order advice: advice execution(pcOSServices() ... ) : order( "ErrorHook", !"ErrorHook");</p><p>This type of advice allows the developer to define a (partial) order of aspect invocation for a pointcut. The precedence of aspects is specified as a sequence of match expressions, which are evaluated against all aspect identifiers. In the above example, the aspect yielded by the expression "ErrorHook" has precedence (is invoked last of all aspects that give after advice to the pointcut) over all other aspects (the result of !"ErrorHook"). Very helpful was that order advice does not necessarily have to be given by one of the affected aspects, instead it can be given by any aspect. This made it relatively easy to encapsulate and deal with configuration-dependent ordering constraints.</p><p>Join-Point Traceability. An important factor for the development were effective tools for join-point traceability. From the viewpoint of an aspect developer, the set of join points offered by some class implementation constitutes an interface. However, these interfaces are "implicit at best" <ref type="bibr" target="#b23">[23]</ref>; a simple refactoring, such as renaming a method, might silently change the set of join points and thereby break some aspect. To prevent such situations, we used the Eclipse-based AspectC++ Development Toolkit (ACDT 7 ), which provides a join-point-set delta analysis (very helpful after updating from the repository) and visualizes code that is affected by aspects. Thereby, unwanted side effects of code changes could be detected relatively easy.</p><p>other features. A key prerequisite is, however, that the system's implementation exhibits enough unambigious and statically evaluable join points. This is achieved by the three design principles of aspect-aware operating-system development.</p><p>By following this design approach in the development of CiAO, we did not only achieve the complete separation of concerns in the code, but also excellent configurability and scalability in the resulting system. We hope that our results encourage developers who start from scratch with a piece of configurable system software to follow the guidelines described in this paper.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Syntactical elements of an aspect</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>C</head><label></label><figDesc>::callee(); // has to know C to bind feature }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The mechanisms offered by AOP: advice-based binding and implicit per-join-point instantiation of advice</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>aspect</head><label></label><figDesc>DisabledIntCheck { advice call(pcOSServices() &amp;&amp; !pcISRServices()) &amp;&amp; !within(pcHooks()) : around() { if(interruptsDisabled()) * tjp-&gt;result() = E _ OS _ DISABLEDINT; else tjp-&gt;proceed(); } };</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Structure of the CiAO-AS kernel</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Interactions between optional policies and extensions of the CiAO scheduler</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>slice struct ResourceSupport _ Sched { void getResource(Resource::Id resid) {...} void releaseResource(Resource::Id resid) {...} }; aspect ResourceSupport { advice "Task" : slice ResourceSupport _ Task; advice "Scheduler" : slice ResourceSupport _ Sched; };</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>pointcut</head><label></label><figDesc>pcPreemptionPoints() = "% Scheduler::activate(...)" || "% Scheduler::setEvent(...)" || "% Scheduler::releaseResource(...)"; aspect FullPreemption { advice execution(pcPreemptionPoints()) : after() { tjp-&gt;that()-&gt;reschedule(); } };</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>1</head><label></label><figDesc>aspect PCP _ Extension { 2 advice execution("void hw::init()") : after() { 3 PCP::init(); 4 } 5 advice execution("% Scheduler::setRunning(...)") : 6 before() { 7 PCP::setPrio(os::krn::Task::getPri(tjp-&gt;args&lt;0&gt;())); 8 } 9 advice execution("% enterKernel(...)") : after() { 10 // wait until PCP has left kernel (Peterson) 11 PCP _ FLAG0 = 1; PCP _ TURN = 1; 12 while ((PCP _ FLAG1 == 1) &amp;&amp; (PCP _ TURN == 1)) {} 13 } 14 advice execution("% leaveKernel(...)") : before() { 15 PCP _ FLAG0 = 0; 16 } 17 advice execution("% AST0::ast(...)") : around() { 18 // AST0::ast() is the AST handler that activates 19 // the scheduler (bound by an upcall aspect) 20 21 // wait until PCP has left kernel (Peterson) 22 PCP _ FLAG0 = 1; PCP _ TURN = 1; 23 while ((PCP _ FLAG1 == 1) &amp;&amp; (PCP _ TURN == 1)) {} 24 25 // proceed to aspect that activates scheduler 26 tjp-&gt;proceed(); 27 PCP _ FLAG0 = 0; 28 } 29 advice execution("% Scheduler::schedule(...)") : after() { 30 // write priority of running task to PCP memory 31 PCP::setPrio(Task::getPri( 32 Scheduler::Inst().getRunning())); 33 } 34 };</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: PCP co-processor extension aspect</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>aspect</head><label></label><figDesc>ErrorHook { advice execution(pcOSServices() ... ) : after() { if( * tjp-&gt;result() != E _ OK) invokeErrorHook( * tjp-&gt;result()); } };</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>1 Cyg _ Mutex::Cyg _ Mutex() { 2 CYG _ REPORT _ FUNCTION();</head><label>1</label><figDesc></figDesc><table>3 

locked 
= false; 

4 

owner 
= NULL; 

5 #if defined(CYGSEM _ PRI _ INVERSION _ PROTO _ DEFAULT) &amp;&amp; \ 

6 

defined(CYGSEM _ PRI _ INVERSION _ PROTO _ DYNAMIC) 

7 #ifdef CYGSEM _ PRI _ INVERSION _ PROTO _ DEFAULT _ INHERIT 

8 

protocol 
= INHERIT; 

9 #endif 
10 #ifdef CYGSEM _ PRI _ INVERSION _ PROTO _ DEFAULT _ CEILING 

11 

protocol 
= CEILING; 

12 

ceiling 
= CYGSEM _ PRI _ INVERSION _ PROTO _ DEFAULT _ PRI; 

13 #endif 
14 #ifdef CYGSEM _ PRI _ INVERSION _ PROTO _ DEFAULT _ NONE 

15 

protocol 
= NONE; 

16 #endif 
17 #else // not (DYNAMIC and DEFAULT defined) 
18 #ifdef CYGSEM _ PRI _ INVERSION _ PROTO _ CEILING 
19 #ifdef CYGSEM _ DEFAULT _ PRIORITY 

20 

ceiling = CYGSEM _ DEFAULT _ PRIORITY; 

21 #else 

22 

ceiling = 0; 
// Otherwise set it to zero. 

23 #endif 
24 #endif 
25 #endif // DYNAMIC and DEFAULT defined 

26 

CYG _ REPORT _ RETURN(); 

27 } 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 3 : Performance measurement results [clock ticks]</head><label>3</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 4 :</head><label>4</label><figDesc></figDesc><table>Scalability of CiAO's memory footprint. Listed 
are the increases in static memory demands [bytes] of 
selected configurable CiAO features. 

</table></figure>

			<note place="foot" n="1"> CiAO is Aspect-Oriented 2 The CiAO-OS family is freely available for research purposes from the authors.</note>

			<note place="foot" n="3"> Because of legal issues, we do not claim full conformance; we have not performed any formal conformance testing.</note>

			<note place="foot" n="5"> All variants were woven and compiled for the Infineon TriCore platform with AC++-1.0PRE3 and TRICORE-G++-3.4.3 using -O3 -fno-rtti -funit-at-a-time -ffunction-sections -Xlinker --gc-sections optimization flags. Memory numbers are retrieved byte-exact from the linker-map</note>

			<note place="foot" n="7"> http://acdt.aspectc.org/</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Summary and Conclusions</head><p>Operating systems for the domain of resource-constrained embedded systems have to be highly configurable. Typically, such configurability is implemented "in line" by means of the C preprocessor. However, due to feature interdependencies and the fact that system policies and system mechanisms tend to crosscut with each other in the implementation, this approach leads to "#ifdef hell" and a bad separation of concerns. Our analysis of the AUTOSAR-OS specification revealed that these effects can already be found in the requirements; they are an inherent phenomenon of complex systems. If fundamental architectural policies have to be provided as configurable features, "#ifdef hell" appears to be unavoidable.</p><p>We showed that a pragmatic application of aspectoriented programming (AOP) provides means for solving these issues: The advice mechanism of AOP effectively reverses the direction of feature integration; an (optional) feature that is implemented as an aspect integrates itself into the base code. Thanks to AOP's pointcut expressions, the integration of features through join points is declarative -it scales implicitly with the presense or absence of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We wish to thank the anonymous reviewers for EuroSys and USENIX for their helpful comments. Special thanks go to Robert Grimm, whose demanding and encouraging shepherding helped us tremendously to improve content and clarity of this paper.</p></div>
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On the automatic evolution of an OS kernel using temporal logic and AOP</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">√Öberg</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>S√ºdholt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meur</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-F</forename><forename type="middle">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">18th IEEE Int. Conf. on Automated Software Engineering (ASE &apos;03)</title>
		<meeting><address><addrLine>Montreal, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2003-03" />
			<biblScope unit="page" from="196" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Specification of operating system (version 2.0.1). Tech. rep., Automotive Open System Architecture GbR</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Autosar</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2006-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Autosar</forename><surname>Homepage</surname></persName>
		</author>
		<ptr target="http://www.autosar.org/" />
		<imprint>
			<biblScope unit="page" from="2009" to="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Variant management with pure::variants. Tech. rep., pure-systems GmbH</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Beuche</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
		<ptr target="http://www.pure-systems.com/fileadmin/downloads/pv-whitepaper-en-04.pdf" />
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="2009" to="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Challenges in automotive software engineering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Broy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28th Int. Conf. on Software Engineering (ICSE &apos;06)</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="33" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Designing and implementing Choices: An object-oriented system in C++</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Campbell</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Islam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Madany</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raila</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page">9</biblScope>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Back to the future: A retroactive study of aspect evolution in operating system code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Coady</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kiczales</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
		<imprint>
			<biblScope unit="page">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Int</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Conf</surname></persName>
		</author>
		<title level="m">on Aspect-Oriented Software Development (AOSD &apos;03)</title>
		<editor>M. Ak¬∏sitAk¬∏sit</editor>
		<meeting><address><addrLine>Boston, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003-03" />
			<biblScope unit="page" from="50" to="59" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Predictable interrupt management for real time kernels over conventional PC hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Del</forename><surname>Foyo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">E L</forename><surname>Mejia-Alvarez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And De Niz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th IEEE Int. Symp. on Real-Time and Embedded Technology and Applications (RTAS &apos;06)</title>
		<meeting><address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="14" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">TOSKANA: a toolkit for operating system kernel aspects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engel</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Freisleben</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Transactions on AOSD II</title>
		<editor>A. Rashid and M. Aksit</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="182" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Aspect-Oriented Software Development</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Filman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Elrad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aksit</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<publisher>AW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Aspect-oriented programming is quantification and obliviousness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Filman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Friedman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">W&apos;shop on Advanced SoC (OOPSLA &apos;00)</title>
		<imprint>
			<date type="published" when="2000-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">patch(1) considered harmful</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fiuczynski</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Grimm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Coady</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walker</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th W&apos;shop on Hot Topics in Operating Systems (HotOS &apos;05</title>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Concern impact analysis in configurable system software-the AUTOSAR OS case</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hofer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lohmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schr√∂der-Preikschat</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">7th AOSD W&apos;shop on Aspects, Components, and Patterns for Infrastructure Software (AOSD-ACP4IS &apos;08)</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008-03" />
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Singularity: Rethinking the software stack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hunt</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larus</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="37" to="49" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Aspect-oriented programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kiczales</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lamping</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mendhekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Maeda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Loingtier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Irwin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th Eur. Conf. on OOP (ECOOP &apos;97</title>
		<editor>M. Aksit and S. Matsuoka</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997-06" />
			<biblScope unit="volume">1241</biblScope>
			<biblScope unit="page" from="220" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Aspect Awareness in the Development of Configurable System Software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lohmann</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
		<respStmt>
			<orgName>Friedrich-Alexander University Erlangen-Nuremberg</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A quantitative analysis of aspects in the eCos kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lohmann</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Scheler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Tartler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Spinczyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schr√∂der-Preikschat</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGOPS/EuroSys Eur. Conf. on Computer Systems 2006 (EuroSys &apos;06)</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006-04" />
			<biblScope unit="page" from="191" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Embedded Software Development with eCos. New Riders</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Massa</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Operating system specification 2.2.3. Tech. rep., OSEK/VDX Group</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Osek/Vdx</forename><surname>Group</surname></persName>
		</author>
		<ptr target="http://portal.osek-vdx.org/files/pdf/specs/os223.pdf" />
		<imprint>
			<date type="published" when="2005-02" />
			<biblScope unit="page" from="2009" to="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Documenting and automating collateral evolutions in Linux device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Padioleau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Muller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGOPS/EuroSys Eur. Conf. on Computer Systems 2008 (EuroSys &apos;08</title>
		<meeting><address><addrLine>Glasgow, Scotland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On the feasibility of an AOSD approach to Linux kernel extensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reynolds</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fiuczynski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Grimm</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">7th AOSD W&apos;shop on Aspects, Components, and Patterns for Infrastructure Software (AOSD-ACP4IS &apos;08)</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008-03" />
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The design and implementation of AspectC++. Knowledge-Based Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Spinczyk</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lohmann</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Special Issue on Techniques to Produce Intelligent Secure Software</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="636" to="651" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The paradoxical success of aspect-oriented programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steimann</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st ACM Conf. on OOP, Systems, Languages, and Applications (OOPSLA &apos;06)</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="481" to="497" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The two percent solution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Turley</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<ptr target="http://www.embedded.com/story/OEG20021217S0039" />
		<imprint>
			<date type="published" when="2002-12" />
			<biblScope unit="page" from="2009" to="2012" />
		</imprint>
	</monogr>
	<note>embedded.com</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A dynamic aspect-oriented system for OS kernels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yanagisawa</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kourai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Chiba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And Ishikawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th Int. Conf. on Generative Programming and Component Engineering (GPCE &apos;06)</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006-10" />
			<biblScope unit="page" from="69" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">The Apertos reflective operating system: the concept and its implementation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yokote</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">7th ACM Conf. on OOP, Systems, Languages, and Applications (OOPSLA &apos;92)</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="414" to="434" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
