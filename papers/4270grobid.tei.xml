<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:08+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. GreyOne: Data Flow Sensitive Fuzzing GREYONE: Data Flow Sensitive Fuzzing</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shuitao</forename><surname>Gan</surname></persName>
							<email>ganshuitao@gmail.com.chaoz@tsinghua.edu.cn</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chao</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shuitao</forename><surname>Gan</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">State Key Laboratory of Mathematical Engineering and Advanced Computing</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chao</forename><surname>Zhang</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Institute for Network Science and Cyberspace</orgName>
								<orgName type="institution">Tsinghua University</orgName>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Beijing National Research Center for Information Science and Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peng</forename><surname>Chen</surname></persName>
							<affiliation key="aff4">
								<orgName type="laboratory">ByteDance AI lab 5 National Research Center of Parallel Computer Engineering and Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bodong</forename><surname>Zhao</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Institute for Network Science and Cyberspace</orgName>
								<orgName type="institution">Tsinghua University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaojun</forename><surname>Qin</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">State Key Laboratory of Mathematical Engineering and Advanced Computing</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dong</forename><surname>Wu</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">State Key Laboratory of Mathematical Engineering and Advanced Computing</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zuoning</forename><surname>Chen</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">State Key Laboratory of Mathematical Engineering and Advanced Computing</orgName>
								<orgName type="laboratory" key="lab2">Institute for Network Sciences and Cyberspace of Tsinghua University; Beijing National Research Center for Information Science and Technology; Peng Chen, ByteDance Inc.; Bodong Zhao, Institute for Network Science and Cyberspace, Tsinghua University; Xiaojun Qin and Dong Wu, State Key Laboratory of Mathematical Engineering and Advanced Computing; Zuoning Chen, National Research Center of Parallel Computer Engineering and Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. GreyOne: Data Flow Sensitive Fuzzing GREYONE: Data Flow Sensitive Fuzzing</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the 978-1-939133-17-5</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Data flow analysis (e.g., dynamic taint analysis) has proven to be useful for guiding fuzzers to explore hard-to-reach code and find vulnerabilities. However, traditional taint analysis is labor-intensive, inaccurate and slow, affecting the fuzzing efficiency. Apart from taint, few data flow features are utilized. In this paper, we proposed a data flow sensitive fuzzing solution GREYONE. We first utilize the classic feature taint to guide fuzzing. A lightweight and sound fuzzing-driven taint inference (FTI) is adopted to infer taint of variables, by monitoring their value changes while mutating input bytes during fuzzing. With the taint, we propose a novel input prioritiza-tion model to determine which branch to explore, which bytes to mutate and how to mutate. Further, we use another data flow feature constraint conformance, i.e., distance of tainted variables to values expected in untouched branches, to tune the evolution direction of fuzzing. We implemented a prototype of GREYONE and evaluated it on the LAVA data set and 19 real world programs. The results showed that it outperforms various state-of-the-art fuzzers in terms of both code coverage and vulnerability discovery. In the LAVA data set, GREYONE found all listed bugs and 336 more unlisted. In real world programs, GREYONE on average found 2.12X unique program paths and 3.09X unique bugs than state-of-the-art evolutionary fuzzers, including AFL, VUzzer, CollAFL, Angora and Honggfuzz, Moreover, GREY-ONE on average found 1.2X unique program paths and 1.52X unique bugs than a state-of-the-art symbolic exeuction assisted fuzzer QSYM. In total, it found 105 new security bugs, of which 41 are confirmed by CVE.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Evolutionary mutation-based fuzzing (e.g., AFL <ref type="bibr" target="#b42">[44]</ref>) has become one of the most popular vulnerability discovery solutions, widely used and studied by the community. A core task of such fuzzers is determining the evolution direction, as well as where and how to mutate seed inputs, in order to efficiently explore hard-to-reach code and satisfy sophisticated data-flow constraints to trigger potential vulnerabilities.</p><p>A common solution is utilizing symbolic execution to solve control-flow constraints and help fuzzers to explore code, as proposed in Driller <ref type="bibr" target="#b35">[37]</ref>, QSYM <ref type="bibr" target="#b41">[43]</ref> and DigFuzz <ref type="bibr" target="#b43">[45]</ref>. However, symbolic execution is too heavy weight and cannot scale to large applications, and unable to solve many complicated constraints, e.g., one-way functions. Researchers also tried to improve fuzzers with deep learning <ref type="bibr" target="#b27">[29]</ref> and reinforcement learning <ref type="bibr" target="#b5">[7]</ref>, by predicating which byte to mutate and what mutation actions to take. However, they are still in early stage and the improvements are not significant.</p><p>Instead, data flow analysis 1 (e.g., dynamic taint analysis) has proven to be useful for guiding fuzzing. TaintScope <ref type="bibr" target="#b38">[40]</ref> utilized it to locate checksums. VUzzer <ref type="bibr" target="#b28">[30]</ref> uses it to identify which bytes and what values are used in branch instructions. Angora <ref type="bibr" target="#b8">[10]</ref> uses it to draw the shape of input bytes related to path constraints. These solutions utilize taint to determine where and how to mutate in different ways, and showed good performance in some applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Questions to Address</head><p>However, traditional dynamic taint analysis has several limitations. First, it is labor-intensive and requires lots of manual efforts. For example, VUzzer <ref type="bibr" target="#b28">[30]</ref> at first only supports x86 platform. In general, these solutions have to interpret each instruction in native or intermediate representation form, with custom taint propagation rules. They also have to build taint models for external function calls or system calls. Second, it is inaccurate. For example, some tainted data values may affect control flow that further affects other data, forming implicit data flows. It causes either under-taint if the implicit flows are ignored, or over-taint if such flows are all counted <ref type="bibr" target="#b17">[19]</ref>. Lastly, it is extremely slow (usually several times overheads), making fuzzing inefficient. These seriously limit dynamic taint analysis' application and efficiency in fuzzing. Therefore, the first research question to address is: RQ1: How to perform lightweight and accurate taint analysis for efficient fuzzing?</p><p>With the inferred taint attributes, VUzzer <ref type="bibr" target="#b28">[30]</ref> mutates input bytes used in branch instructions and imprecisely replaces them with expected values (e.g., magic number). REDQUEEN <ref type="bibr" target="#b2">[4]</ref> further identifies all direct copies of inputs, i.e., input bytes that are directly used in branch constraints (e.g., magic number and checksum), and replaces them with expected values. However, they could neither solve branch constraints related to indirect copies of inputs, i.e., input bytes that are transformed and indirectly used in branch constraints, nor prioritize which branch to explore and which bytes to mutate. Thus, the second research question to address is: RQ2: How to efficiently guide mutation with taint?</p><p>Existing evolutionary fuzzers in general evolve towards increasing code coverage. For example, AFL <ref type="bibr" target="#b42">[44]</ref> adds test cases that find new code to the seed queue, and selects one at a time from the queue to mutate. Many other solutions, e.g., AFLfast <ref type="bibr" target="#b4">[6]</ref> and CollAFL <ref type="bibr" target="#b12">[14]</ref>, have been proposed to further improve the way to select seed, accelerating the evolution speed. However, they only considered control flow features rather than data flow features, e.g., taint attributes or constraint conformance, and may waste energies during mutation to explore hard-to-reach branches. Thus, the third research question to address is: RQ3: How to tune fuzzers' evolution direction with data flow features?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Our Solution</head><p>We proposed a novel data flow sensitive fuzzing solution GREYONE, to address the aforementioned questions.</p><p>Fuzzing-driven Taint Inference (FTI). We first propose FTI to infer taint of variables by conducting a pilot fuzzing phase, during which we systematically mutate each input byte (one at a time) and monitor variables' values. If a variable's value changes while an input byte is mutated, we could infer the former is tainted and depends on the latter. This inference is sound, i.e., without over-taint issues. It is also immune to under-taint issues caused by implicit flows or external calls 2 . Experiments showed that, FTI is more accurate than traditional taint analysis, e.g., able to find 2 to 4 times more dependencies (with no false positives). Furthermore, it avoids the labor-intensive efforts of composing taint propagation rules and is very fast at runtime. This lightweight and sound solution could scale to large programs, and provide supports for other application scenarios beyond fuzzing.</p><p>Taint-Guided Mutation. Input bytes contribute differently to code coverage. We utilize taint provided by FTI to sort input bytes. More specifically, we prioritize input bytes that affect more untouched branches to mutate, and prioritize untouched branches that depend on more prioritized input bytes to explore. When exploring a branch, we mutate its dependent input bytes in priority order, by precisely replacing direct copies of inputs with expected values (and minor variations).</p><p>Conformance-Guided Evolution. Lots of fuzzers (e.g., AFL) use control flow features, e.g., code coverage, to guide evolution. To efficiently explore hard-to-reach branches (e.g., those related to indirect copies of inputs), we propose to use complementary data flow features to tune the evolution direction. Note that, for each tainted variable used in untouched branches, we need to flip some bits to match the expected values. The amount of efforts required is related to the constraint conformance, i.e., the distance of tainted variables to the values expected in untouched branches.</p><p>We use this data flow feature to tune the fuzzer's evolution direction. First, we add test cases with higher conformance to the seed queue, making the fuzzer gradually improve the overall conformance and eventually satisfy the constraints of untouched branches. Then, we prioritize seeds with higher conformance to be selected from the queue for mutation, accelerating the exploration of new branches. This evolution could satisfy the constraints at a faster pace, like the gradient descent used in Angora <ref type="bibr" target="#b8">[10]</ref>. But it could avoid getting stuck in local minimum and brings long-term stable improvements. Furthermore, we rebase ongoing mutations onto new seeds with higher conformance on-the-fly. Experiments showed that it thus significantly improves the mutation efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Results</head><p>We implemented a prototype of GREYONE and evaluated it on the LAVA-M dataset <ref type="bibr" target="#b10">[12]</ref> and 19 open source applications.</p><p>Our taint analysis engine FTI outperforms the classic taint analysis solution DFSan <ref type="bibr" target="#b0">[2]</ref>. On average, it finds 1.3X more untouched branches that are tainted (i.e., depending on input bytes), and generates 1X more unique paths during fuzzing.</p><p>GREYONE outperforms 6 state-of-the-art evolutionary fuzzers, including AFL and CollAFL <ref type="bibr" target="#b12">[14]</ref>, in terms of both code coverage and vulnerability discovery. In the LAVA data set, GREYONE finds all listed bugs and 336 more unlisted bugs. In real world applications, GREYONE finds 2.12X unique paths, 1.53X new edges, 6X unique crashes and 3.09X bugs, than the second best counterpart.</p><p>In addition, GREYONE demonstrates very good performance in bypassing complicated program constraints, even better than the state-of-the-art symbolic execution assisted fuzzer QSYM <ref type="bibr" target="#b41">[43]</ref>. In the real world applications, GREYONE finds 1.2X unique paths, 1.12X new edges, 2.15X unique crashes and 1.52X bugs than QSYM.</p><p>In total, GREYONE has found 105 unknown vulnerabilities in these applications. After reporting to upstream vendors, we Co nfo rm an ce -G uid ed Ev olu tio n On-the-fly Mutation Rebase <ref type="figure">Figure 1</ref>: Architecture of GREYONE. learned that 25 of them are known by vendors (but not public). Among the remaining 80 bugs, 41 are confirmed by CVE.</p><p>To summarize, we make the following contributions:</p><p>• We propose a taint-guided mutation strategy, able to prioritize which branch to explore and which input bytes to mutate, and determine how to (precisely) mutate.</p><p>• We propose a new conformance-guided evolution solution to tune the direction of fuzzing, by taking into consideration data flow features including taint attributes and constraint conformance.</p><p>• We implement a prototype GREYONE, evaluate it on <ref type="bibr" target="#b17">19</ref> widely-tested open source applications, showing that it outperforms various state-of-the-art fuzzers.</p><p>• We find 105 unknown vulnerabilities in 19 applications, and help the vendors improve the products.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Design of GREYONE</head><p>As shown in <ref type="figure">Figure 1</ref>, the overall workflow of GREYONE is similar to AFL, consisting of steps like seed generation/updating, seed selection, seed mutation and testing/tracking. First, we introduce a new step into the fuzzing loop, i.e., fuzzing-driven taint inference (FTI), to infer taint of variables. We conduct a pilot fuzzing by performing byte-level mutation on the input seed and testing them. During the pilot fuzzing, we monitor program variables' value changes. Once a variable's value changes, we could induce that it is tainted and depends on the mutated input bytes. Besides, we could also identify all tainted variables that use direct copy of inputs.</p><p>Second, with the taint attributes provided by FTI, we further guide the fuzzer to mutate seeds in a more efficient way. We prioritize which input bytes to mutate and which branch to explore. In addition, we determine how to mutate input bytes, including direct and indirect copies of inputs.</p><p>Lastly, we tune the fuzzing direction with conformanceguided evolution. In addition to code coverage, we track tainted variables' constraint conformance during testing, and add test cases with higher conformance to the seed queue, making the fuzzer gradually increase the conformance and reach untouched branches. Then, we prioritize seeds with higher conformance to select from the queue, accelerating the evolution. Furthermore, once we find a new seed with higher conformance, we rebase ongoing mutations onto this new seed on-the-fly, promoting the mutation efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Fuzzing-driven Taint Inference</head><p>As shown in <ref type="bibr" target="#b8">[10,</ref><ref type="bibr" target="#b28">30]</ref>, taint analysis could guide fuzzers towards efficient mutation and help explore hard-to-reach branches. However, traditional solutions are labor-intensive, slow and inaccurate. GREYONE introduces a lightweight and sound solution, i.e., fuzzing-driven taint inference (FTI).</p><p>Intuition. If a variable's value changes after we mutate one input byte, we could infer that the former depends on the latter, either explicitly or implicitly. Furthermore, mutating this input byte could change the constraints of branches that use this variable, leading to new branch exploration.</p><p>Interference Rule for FTI. Assume we have a program variable var (at a given line of instruction) and a seed input S, and another input S[i] which is derived by mutating the i-th byte of the input S, let v(var, S) be the value of var when given the input S. We claim the variable var depends on the i-th byte of input S, if the following condition holds.</p><formula xml:id="formula_0">v(var, S) = v(var, S[i])<label>(1)</label></formula><p>Moreover, if either operand variable of a branch instruction br depends on the i-th byte of input S, we claim this branch br depends on this input byte. In other words, if the data flow from the input byte to the branch does not satisfy the non-intererence rule <ref type="bibr" target="#b14">[16]</ref>, the latter depends on the former.</p><p>Unlike traditional instruction-level taint analysis, e.g., TaintInduce <ref type="bibr" target="#b44">[46]</ref>, this rule captures high-level dependency and is more accurate. As discussed later, it has fewer false positives (i.e., over-taint) and false negatives (i.e., under-taint).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association 29th USENIX Security Symposium 2579</head><p>Algorithm 1 Fuzzing-driven Taint Inference.</p><p>Input: seed Output: {br.taint[seed] | br ∈ branches(P)} 1: // Target program is instrumented to collect information, as P 2: State = Execute(P , seed)</p><p>3: for each candidate mutation method Opr do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4:</head><p>for each available mutation operand Opd do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5:</head><p>for each position pos in the seed do end for 17: end for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Taint Inference</head><p>Following the aforementioned intuition and interference rule, FTI infers the taint attributes in a pilot fuzzing phase, which could be integrated with the deterministic fuzzing stage of AFL, with the following three steps, as shown in Algorithm 1.</p><p>Byte-Level Mutation. We mutate the seed inputs one byte at a time, with a set of predefined mutation rules (e.g., singlebit flipping, multiple-bits flipping and arithmetic operations). For each seed input S and each input offset pos, a set of new test cases BLM(S, pos) could be derived in this way.</p><p>Note that, we do not mutate multiple bytes at the same time, 3 due to the following reasons. First, we cannot precisely determine which byte is responsible for the potential value change if multiple bytes are mutated, causing either undertaint or over-taint issues. Second, single-byte mutation yields fewer test cases and introduces fewer performance overheads. Variable Value Monitoring. We then feed the generated test cases to test, and monitor program variables' values during testing. To support the monitoring, we instrument the target applications with special value tracking code.</p><p>Note that, we could monitor all program variables in this way. However, for the purpose of fuzzing, we only monitor variables that are used in path constraints. First, it is much faster to monitor fewer variables. Second, only these variables will affect the path exploration, and it is sufficient to only monitor them in order to explore all branches.</p><p>Taint Inference. Lastly, after testing each set of test cases BLM(S, pos), we check whether the value of each variable used in path constraints keeps intact or not. If the value of a variable var changes, we could infer that var is tainted and depends on the pos-th byte of the input seed S.</p><p>As shown in Listing 1, which is extended from REDQUEEN <ref type="bibr" target="#b2">[4]</ref>, we could detect the value of variable var1 used in the branch at Line 20 changes, when we mutate either the 20th, 21st, 22nd or 23rd byte of the input. Therefore, var1 depends on these four bytes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Comparison with Traditional Taint Analysis.</head><p>Comparing to traditional taint analysis, FTI requires fewer manual efforts, and is much more lightweight and accurate.</p><p>Manual Efforts. Traditional taint analysis (e.g., <ref type="bibr" target="#b18">[20]</ref>) requires labor-intensive efforts. In general, each instruction/statement has to be either interpreted with custom instructionspecific taint propagation rules, or lifted/translated to an intermediate representation form and then analyzed with general taint propagation rules. FTI is architecture independent and requires no extra efforts to port to new platforms.</p><p>Speed. FTI is very fast. First, it is based on static code instrumentation, rather than dynamic binary instrumentation. Second, it only monitors values of variables used in path constraints, not all program variables. Third, it does not need to interpret individual instructions with custom rules.</p><p>Accuracy. FTI is more accurate than traditional taint analysis solutions. Its inference rule is sound. If a variable is reported to depend on a specific input byte, then it is most likely to be true. In other words, it has no over-taint issues.</p><p>It also has fewer under-taint issues. In practice, most undertaint issues are caused by ubiquitous implicit data flows and loss in external functions or system calls. FTI is immune to these cases. However, FTI may still have under-taint issues due to incomplete fuzzing caused by byte-level mutation. <ref type="figure" target="#fig_0">Figure 2</ref> demonstrated how FTI works. Unlike traditional dynamic taint analysis, which focuses on instructions and suffers from over-taint and under-taint issues, FTI could improve the accuracy with fewer efforts.</p><p>Head-to-Head Comparison. Note that, several recent works have similar ideas or comparable results. TaintIn-  duce <ref type="bibr" target="#b44">[46]</ref>could infer taint propagation rules for each instruction without manual efforts. But it is extremely slow in taint rule inferring stage, due to its mutation on each instruction.</p><p>ProFuzzer <ref type="bibr" target="#b40">[42]</ref> mutates one input byte at a time too. But it monitors the coverage changes rather than value changes, unable to infer taint dependency. MutaFlow <ref type="bibr" target="#b24">[26]</ref> monitors changes in sink APIs and could tell whether a parameter is tainted. But it focuses on APIs rather than variables, and cannot provide precise taint information for variables. Furthermore, it lacks a systematic testing, such as the pilot fuzzing performed by FTI, and thus has much more under-taint issues.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.3">Identify Direct Copies of Inputs.</head><p>It is common that, some input bytes will be directly copied to variables, and compared against expected constants or computed values in branch instructions, as shown at Line 2 (magic number), Line 6 (checksum) and Line 10 (length check) in Listing 1. These input bytes should be replaced with the exact values (or with minor variations like ±1) expected in the branches, to bypass the hard-to-reach path constraints. FTI could identify all direct copies of inputs in an efficient way. For each tainted variable used in branch instructions, we could match it against its dependent input bytes. If their values are equal, we report the variable as a direct copy of input. Otherwise, we report it as an indirect copy of input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Taint-Guided Mutation</head><p>Mutation-based fuzzers will mutate seed inputs in certain ways and generate new test cases, to explore new code and trigger potential vulnerabilities. GREYONE utilizes taint provided by FTI to prioritize which bytes to mutate and which branch to explore, as well as determine how to mutate. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Prioritize Bytes to Mutate</head><p>As pointed by <ref type="bibr" target="#b27">[29]</ref>, not all inputs bytes are equal. Some bytes should be prioritized to mutate, to get a better fuzzing yields. We argue that, if an input byte could affect more untouched branches, then it should be prioritized over other input bytes, because mutating this input byte is more likely to trigger untouched branches, and trigger more complicated program behaviors since more branch states have changed. As shown in <ref type="figure" target="#fig_1">Figure 3</ref>, each input byte at offset pos of a seed input S may affect multiple variables, and then affect multiple branches among which some are not explored by any test case. We define a byte's weight as the count of untouched branches depending on this byte, as follows. where, IsUntouched returns 1 if the branch br is not explored by any test case so far, otherwise 0. And the function DepOn returns 1 if the branch br depends on the pos-th input byte, according to FTI, otherwise 0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Prioritize Branches to Explore</head><p>As shown in <ref type="figure" target="#fig_1">Figure 3</ref>, a program path may have multiple untouched neighbour branches. Similarly, some untouched branches should be prioritized to explore in order to get a better fuzzing yields. We argue that, an untouched branch that depends on more high-weight input bytes should be prioritized over other untouched branches.</p><p>If an untouched branch depends on more high-weight input bytes, to explore this branch, we will mutate its dependent input bytes. As aforementioned, mutating these high-weight input bytes is more likely to trigger untouched branches (including branches different from the one to explore).</p><p>Accordingly, for a seed S, we evaluate the weight of an untouched branch br in the according path as the sum of all its dependent input bytes' weight, as follows.</p><formula xml:id="formula_1">W br (S, br) = ∑ pos∈S DepOn(br, pos) * W byte (S, pos) (3)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">Determine Where and How to Mutate</head><p>With the weight of input bytes and unexplored branches, we could further determine the seed mutation policy.</p><p>Where to mutate? Given a seed and the program path it exercises, we will explore the untouched neighbor branches along this path one by one, in descending order of branch weight according to Equation 3.</p><p>When exploring a specific untouched neighbor branch, we will mutate its dependent input bytes one by one, in descending order of byte weight according to Equation 2.</p><p>How to mutate direct copies of input? As aforementioned, direct copies of inputs should match the values expected in untouched branches. Thus, during mutation we replace the direct copy of input bytes with the exact expected values (for magic number and checksum etc.) and values with minor variations (e.g., ±1 for length checks etc.).</p><p>The core question left is how to get the expected values. There are two cases. If a constant value (e.g., magic number) is expected, we record this constant value with FTI. If a runtimecomputed value (e.g., checksum) is expected, we first feed a malformed input to test, and get the expected runtime value with FTI. Then we use the recorded value (and with minor variations) to patch the dependent input bytes.</p><p>Note that, REDQUEEN <ref type="bibr" target="#b2">[4]</ref> could also mutate direct copies of input bytes. Unlike GREYONE, REDQUEEN could not precisely locate the exact position of dependent bytes. It has to mutate the seed hundreds of times to get a colorized version with higher entropy, which exercises the same path. The colorized version is tested again, and compared with the original seed, to locate the potential positions of dependent bytes. The colorization process is very slow, and the number of candidate positions could be large too. As a result, it wastes more time to precisely mutate the dependent bytes than GREYONE.</p><p>How to mutate indirect copies of input? If some input bytes affect an untouched branch but their direct copy is not used in the branch, we will mutate these bytes one by one, in descending order of byte weight according to Equation 2.</p><p>More specifically, we will apply random bit flipping and arithmetic operations on each dependent byte. Different from the byte-level mutation used in FTI, multiple dependent bytes could be mutated together in this phase.</p><p>As discussed later, our conformance-guided evolution solution will rebase the mutation onto better seeds on-the-fly, which could greatly improves the mutation of indirect copies.</p><p>Mitigate the under-taint issue. As aforementioned, FTI may have under-taint issues due to incomplete testing. Thus, for any untouched branch, its dependent input bytes reported by FTI could be incomplete. In order to explore that branch, we have to mutate the missing dependent input bytes as well.</p><p>More specifically, in addition to mutate the dependent input bytes reported by FTI, we also randomly mutate their adjacent bytes with a small probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Conformance-Guided Evolution</head><p>A wide range of fuzzers (e.g., AFL) use control flow features, e.g., code coverage, to guide evolution direction of fuzzing. To efficiently explore hard-to-reach branches (e.g., those related to indirect copies of inputs), we propose to use complementary data flow features to tune the evolution direction of fuzzing.</p><p>We note that, for each tainted variable used in untouched branches, we need to flip some bits of its dependent input bytes to make it match the expected value. Some test cases require fewer efforts (i.e., bit flipping) than others. The amount of efforts required is related to the constraint conformance, i.e., the distance of tainted variables to the values expected in untouched branches. Seeds with higher conformance are more likely to yield test cases exercising untouched branches.</p><p>Based on this observation, we use the seed's constraint conformance to tune the evolution direction of fuzzing. We modify the seed updating and seed selection policies accordingly, to drive the fuzzer towards this direction. The test cases generated during fuzzing are more likely to have higher conformance and eventually satisfy the hard-to-reach constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Conformance Calculation</head><p>The constraint conformance indicates how much the target (e.g., seed) matches with the path constraints.</p><p>Conformance of an untouched branch. Given an untouched branch br, which relies on two operands var1 and var2, we define its constraint conformance as follows.</p><formula xml:id="formula_2">C br (br, S) = NumEqualBits(var1, var2)<label>(4)</label></formula><p>where, the function NumEqualBits returns the number of equal bits between the two arguments. Note that, for a branch in a switch statement, the two variables it relies on are the switch condition and the case value.</p><p>Conformance of a basic block. Given a seed S and a basic block bb it has explored, bb may have multiple untouched neighbor branches (e.g., switch statements). We define the constraint conformance of bb as the maximum conformance of all its untouched neighbor branches:</p><formula xml:id="formula_3">C BB (bb, S) = MAX br∈Edges(bb) IsUntouched(br) * C br (br, S) (5)</formula><p>Conformance of a test case. Given a test case S, its constraint conformance is defined as the sum of the conformance score of all basic blocks it has explored.</p><formula xml:id="formula_4">C seed (S) = ∑ bb∈Path(S) C BB (bb, S)<label>(6)</label></formula><p>Note that, seeds with higher constraint conformance are likely to have (1) more untouched neighbor branches, and (2) individual untouched branches with higher constraint conformance. Further mutations could thus quickly trigger more untouched branches or target individual untouched branches.  <ref type="figure">Figure 4</ref>: Dynamics of seed queue updating.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Conformance-Guided Seed Updating</head><p>In addition to test cases that find new code, we also add test cases with higher constraint conformance to the seed queue.</p><p>In order to efficiently support this new seed updating scheme, we proposed a novel seed queue structure. Two-Dimensional Seed Queue. Traditional seed queues are usually kept in a linked list, where each node represents a seed that explores a unique path <ref type="bibr" target="#b2">4</ref> . We extend each node to include multiple seeds that explore the same path and have the same conformance but different block conformance, to form a two-dimensional seed queue, as shown in <ref type="figure">Figure 4</ref>.</p><p>Seed queue Updates. <ref type="figure">Figure 4</ref> also shows how we update the seed queue, in the following three cases.</p><p>• A. New path. If the test case finds new code, then it will be added to the seed queue as a new node, same as other coverage-guided fuzzers (e.g., AFL).</p><p>• B. Same path but higher conformance. If the test case does not find any new code, but has a higher conformance than seeds in the corresponding node (with same path) in the queue, then this node will be replaced with a new node consisting of only this test case.</p><p>• C. Same path and conformance, but different basic block conformance. If the test case explores the same path and has the same conformance as seeds in the corresponding node in the queue, but has a distribution of basic block conformance different from seeds in that node, then we will append this test case to that node.</p><p>It is worth noting that, in the last case, since the test case has a unique distribution of basic block conformance, it could derive new test cases to quickly trigger untouched neighbor branches of some basic blocks, and thus is useful.</p><p>Comparison. This seed updating policy makes the fuzzer gradually improve the overall conformance, and satisfies the constraints of untouched branches with a fast pace, at a speed <ref type="bibr" target="#b2">4</ref> In AFL, it represents a unique edge hit or a new edge hit count range comparable to the gradient descent algorithm used in Angora <ref type="bibr" target="#b8">[10]</ref>. But it could avoid getting stuck in local minimum like Angora, and brings long-term stable improvements.</p><p>Note that, honggfuzz <ref type="bibr" target="#b36">[38]</ref> also compares the equality of operands in branch statements. If a branch's equality increases, it adds the test case to the seed queue. However, it does not exclude compare instructions related to touched branches, which are useless to branch exploration. Further, a basic block may have multiple compare instructions inside, but not all of them are related to branches. Lastly, it lacks the efficient two-dimensional seed queue structure proposed in this paper, limiting its efficiency as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.3">On-the-fly Mutation Rebase</head><p>Once we find a test case exercising the same program path as previous seeds but has a higher conformance, i.e., case B as aforementioned, we not only add this test case to the seed queue by replacing the corresponding node with a new node, but also replace all uses to the seeds being replaced.</p><p>Especially, if the seed being replaced is used by an ongoing mutation, we will rebase the mutation onto the new seed, since the new seed is better. This operation could be done on-the-fly, as illustrated in red line in <ref type="figure">Figure 1</ref>. Experiments showed that, this optimization technique is very effective. For example, it promotes the speed of finding the same number of bugs in the LAVA data set by three times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.4">Conformance-Guided Seed Selection</head><p>Many works <ref type="bibr" target="#b4">[6,</ref><ref type="bibr" target="#b12">14]</ref> have proved that seed selection policies could accelerate the evolution of fuzzing. We propose to prioritize seeds with higher conformance during seed selection.</p><p>More specifically, we iterate the linked list of the seed queue, and select linked nodes that have higher conformance with a higher probability. Then a random seed in this linked node will be selected for further mutation.</p><p>With this scheme, seeds with higher conformance are more likely to be selected. Further mutations are more likely to yield test cases with higher conformance, which could satisfy the hard-to-reach constraints of untouched branches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Implementation</head><p>We implemented a prototype of GREYONE with over 20,000 lines of C/C++ code. The current prototype supports analyzing applications with LLVM bytecode. Here, we present some of its implementation details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Modularized Framework</head><p>As shown in <ref type="figure">Figure 1</ref>, GREYONE consists of several core components, e.g., seed updating, seed selection, seed mutation</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association 29th USENIX Security Symposium 2583</head><p>and testing. We implemented a set of extensible interfaces to support various policies and future improvements.</p><p>Test Case Scoring. Evolutionary fuzzers usually put some test cases to a seed pool for further mutation according to a certain test case scoring algorithm. We implemented a general interface of test case scoring, able to support both the coverage-guided seed updating policy adopted by AFL and the conformance-guided policy adopted by GREYONE.</p><p>Seed Prioritization. Fuzzers usually prioritize seeds to select and assign different energy to mutate according to a certain seed scoring algorithm. We implemented a general interface of seed scoring, able to support the conformance-guided seed selection policy adopted by GREYONE and policies used by other fuzzers (e.g., CollAFL <ref type="bibr" target="#b12">[14]</ref> and AFLfast <ref type="bibr" target="#b4">[6]</ref>).</p><p>Seed Mutation Algorithms. In addition to the mutation operators (e.g., byte flipping) implemented by other fuzzers (e.g., AFL), we also add supports to byte-level mutation used by FTI, and direct-copy mutation in which the fuzzer is told the exact offset and exact value to use.</p><p>State Manager. The fuzzer usually requires special data structures to support efficient communication between components and efficient decision making. We constructed many tree-based and hash-table-based structures to store these information, including control flow graph, code coverage, seed conformance, variables' taint attributes and variables' values.</p><p>Selective Testing. In addition to code coverage tracking, GREYONE has two more modes during testing: (1) variable value monitoring mode used for FTI; (2) conformance-guided tracking mode for evolution tuning. To efficiently schedule these different testing modes, we extend the fork server used by AFL to switch between them on demand. For example, during fuzzing, if a seed has spent too much mutation energy or the conformance does not increase for a while, then we will switch from conformance tracking mode to regular coverage tracking mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Static Analysis and Instrumentation.</head><p>To support the policies proposed in the paper, we need to first analyze the target applications with static analysis, as well as collect some information at runtime. We perform some basic inter-procedural control flow analysis with the help of Clang, and get the control flow graph and other necessary information.</p><p>Coverage Tracking. As pointed by CollAFL <ref type="bibr" target="#b12">[14]</ref>, there is a serious hash collision issue in traditional coverage tracking solutions (e.g., AFL). We reproduce the mitigation solution of CollAFL in GREYONE.</p><p>Conformance Tracking. To support conformance tracking, we instrument each branch statement (including conditional branches and switch statements) to count the number of equal bits of its operands (by operations like __builtin_popcount).</p><p>Variable Value Monitoring FTI relies on variable value monitoring during fuzzing. We instrument the application to record the values of variables used in path constraints. More specifically, we assign unique IDs to all such variables, and store their values in a bitmap (with the ID as key), similar to the bitmap storing code coverage used by AFL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Evaluation</head><p>In this section, we evaluated the efficiency of GREYONE, and showed its improvements compared to other fuzzers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Experiment Setup</head><p>Following the guidance in <ref type="bibr" target="#b19">[21]</ref>, we conducted the experiments carefully, to draw conclusions as objective as possible.</p><p>Baseline fuzzers to compare. We compared GREY-ONE against several well-known evolutionary mutation-based fuzzers, including AFL <ref type="bibr" target="#b42">[44]</ref>, VUzzer <ref type="bibr" target="#b28">[30]</ref>, Angora <ref type="bibr" target="#b8">[10]</ref>, CollAFL <ref type="bibr" target="#b12">[14]</ref> , Honggfuzz <ref type="bibr" target="#b36">[38]</ref>, and QSYM <ref type="bibr" target="#b41">[43]</ref>  <ref type="bibr" target="#b3">5</ref> . They are chosen based on the following considerations. First, AFL was the most popular baseline fuzzer studied in the community. Second, Angora and VUzzer also utilized taint to guide fuzzing. Third, CollAFL provides more accurate coverage information, which is also utilized by GREYONE. In addition, CollAFL proposed a seed selection policy relying on control flow features, different from GREYONE. Further, Honggfuzz is a core fuzzing engine in Google's OSS-Fuzz platform <ref type="bibr" target="#b31">[33]</ref>, and also uses light-weight data tracking to identify good seeds. Lastly, QSYM is a popular symbolic execution assisted fuzzer, and we can use it to evaluate GREYONE' capability on bypassing complicated program constraints.</p><p>Target applications to test. We chose target applications considering several factors, including popularity, frequency of being tested, development activeness, and functionality diversity. Finally, we chose 19 popular open source Linux applications (in latest version when tested), including wellknown development tools (e.g., readelf, nm, c++filt), image processing libraries (e.g., libtiff), document process- <ref type="bibr" target="#b3">5</ref> CollAFL is not open source. We implemented a copy following its design. Another work REDQUEEN <ref type="bibr" target="#b2">[4]</ref> is also related, but it is disclosed only one month ago and not open source. Thus we are unable to compare with it. ing libraries (e.g., libwpd), terminal processing libraries (e.g., libncurses), audio or video processing libraries (e.g., ibsndfile), code processing tools (e.g., cflow, bison, nasm), graphics processing libraries (e.g., libcaca and libsixel), and data processing libraries (e.g., libsass and libxsmm) etc. Furthermore, we also evaluated GREYONE on the LAVA-M data set <ref type="bibr" target="#b10">[12]</ref> as other fuzzers. Performance metrics. We chose vulnerability discovery and code coverage as two major metrics used to compare the efficiency of each fuzzer with GREYONE. For code coverage, we mainly considered path coverage (i.e., number of seeds in the queue) and edge coverage (i.e., number of edge hit) similar to <ref type="bibr" target="#b12">[14,</ref><ref type="bibr" target="#b40">42]</ref>. For vulnerability discovery, we tracked the growth trend of unique crashes detected by different fuzzers. We further utilized tools including afl-collect <ref type="bibr" target="#b1">[3]</ref>, AddressSanitizer <ref type="bibr" target="#b32">[34]</ref> and UBSan <ref type="bibr" target="#b21">[23]</ref> to deduplicate redundant crashes and identify unique vulnerabilities. Note that, fuzzers have different representations of fuzzing states (e.g., bitmap). We therefore slightly modify them to get unified fuzzing states and perform fair comparison.</p><p>Initial seeds. Note that, our taint analysis engine FTI relies on byte-level mutation. It will perform poorly if no initial seeds are given, lowering the efficiency of GREYONE. Therefore, we did not test target applications with empty seeds. Instead, we test each target application with 10 initial seeds.</p><p>For each target application, we randomly downloaded about 100 input files from the Internet, according the required input file formats. Then, we use the tool afl-cmin shipping with AFL <ref type="bibr" target="#b42">[44]</ref>, to filter out a minimal subset of inputs that have the same code coverage. Finally, we randomly selected 10 inputs from these distilled inputs, and used them as the initial seeds.</p><p>Randomness mitigation. Since mutation-based fuzzers all rely on random mutation, there could be performance jitter during testing. We took two actions to mitigate the randomness issue. First, we perform each experiment for 5 times, and evaluate the average performance as well as the minimal and maximal performance. Second, we test target applications for more time, until the fuzzers reach a relatively stable state (i.e., the order of fuzzers' performance does not change anymore). Experiments showed that the fuzzers will get stable after testing these applications for 60 hours. So, we tested each application for 60 hours in our experiment. Experiment environment. We run each fuzzer instance on each target application in the same configuration. More specifically, each instance is run in a virtual machine running Ubuntu 17.04 with one Intel CPU @2.9GHz and 8GB RAM. <ref type="table" target="#tab_4">Table 1</ref> shows the number of unique vulnerabilities (accumulated in 5 runs) found by 6 different fuzzers in the 19 real world applications. Each application is of the latest version at the time of testing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Vulnerability Discovery</head><p>In total, AFL, CollAFL, Honggfuzz, VUzzer and Angora has found 21, 34, 18, 6 and 12 vulnerabilities in all applications respectively. GREYONE found 105 unique vulnerabilities in total and covered all vulnerabilities found by other fuzzers. In other words, GREYONE found 209% more vulnerabilities than the second best fuzzer (i.e., CollAFL). Especially, out of these 19 applications, three applications including nm, tiff2pdf and libsass are reported as vulnerable only by GREYONE. In summary, GREYONE significantly outperforms other 5 fuzzers in terms of vulnerability discovery.</p><p>The last three columns of <ref type="table" target="#tab_4">Table 1</ref> show the number of  vulnerabilities that are previously unknown, known by vendors only and confirmed by CVE respectively. We reported the 105 vulnerabilities we found to upstream vendors, and learned that 25 of them are known by the vendors (but not the public). Among the remaining 80 unknown vulnerabilities, 41 vulnerabilities are confirmed by CVE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Unique Crashes Evaluation</head><p>In general, the more unique crashes a fuzzer finds, the more vulnerabilities it could find too. Thus, the number of unique crashes is also an important metric for fuzzers. Due to the randomness, we evaluated not only the average but also the maximum number of unique crashes found in 5 runs. <ref type="table" target="#tab_5">Table 2</ref> shows the detailed evaluation results. GREYONE outperforms all other fuzzers in all applications. Especially in tiff2pdf, nm, and libsass, only GREYONE reported unique crashes and other fuzzers all failed.</p><p>Among the 5 runs, GREYONE on average found 716 unique crashes in all applications, which is 501% more than the second best fuzzer (i.e., CollAFL). In the maximum run, GREY-ONE found 1447 unique crashes in all applications, which is 631% more than the second best fuzzer.</p><p>To better examine the efficiency of each fuzzer, we also evaluated the growth trend of unique crashes found by them, as shown in <ref type="figure" target="#fig_9">Figure 14</ref> in the Appendix. It shows that, GREY-ONE had a steady and stronger growth trend on all applications. Furthermore, GREYONE is also the first fuzzer that reported crashes in almost all applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Code Coverage Evaluation</head><p>Since a fuzzer can only find vulnerabilities in code that it has explored, code coverage is therefore an important metric for coverage-guided fuzzers. <ref type="table" target="#tab_6">Table 3</ref> shows the average number of unique paths and edges found by each fuzzer for ten applications. In addition, the improvement of GREYONE compared to the second best fuzzer is also evaluated and showed in the table.</p><p>In terms of path coverage, GREYONE outperforms the second best fuzzer by at least 25% in 9 out of ten applications. In the last application c++filt, GREYONE outperforms the second best by 8%. In terms of new edge coverage, GREY-ONE outperforms the second best fuzzer in all applications, on average by 25.5%.</p><p>We also evaluated the growth trend of code explored by fuzzers, and presented the path coverage in <ref type="figure" target="#fig_1">Fig 13 and</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Evaluation on LAVA-M</head><p>To directly compare the results with other papers, we tested applications in the LAVA-M data set for 24 hours (rather than 60 hours) and repeated 5 times.  Figure 5: The growth trend of unique crashes found in LAVA-M by AFL, CollAFL, Angora and GREYONE.</p><p>Bug finding. <ref type="table" target="#tab_7">Table 4</ref> shows the number of bugs (average in 5 runs) detected by each fuzzer within 24 hours. GREYONE finds 2601 bugs in all applications, including all listed bugs in LAVA-M. Moreover, it found 327, 4, 4 and 1 unlisted bugs in these four applications respectively, showing that GREYONE is very effective and much better than other fuzzers.</p><p>First, AFL and CollAFL have the worst performance, because they are not sensitive to data flow features and thus unfit for detecting bugs in LAVA-M. Second, Honggfuzz analyzes all operands used in branches, but lacks the ability to isolate untouched branches and lacks efficient seed updating and selection policies. Therefore its evolution speed is slow and the overall efficiency is poor. Third, VUzzer is very slow and can only handle simple constraints (e.g., magic number). Thus it shows minor improvements comparing to AFL. Further, CollAFL-br-LAF integrates the Intel-laf solution, which splits long string comparisons, fit for detecting certain bugs in LAVA-M. Lastly, Angora shows an extraordinary result as well, due to its gradient descent algorithm. However, it may get stuck in local minimum and fail to find certain bugs.</p><p>Unique crashes. <ref type="figure">Figure 5</ref> shows the growth trend of unique crashes found by various fuzzers. Thanks to the accurate taint-guided mutation and stable conformance-based evolution, GREYONE shows a strong and stable growth trend in finding unique crashes. It finds about 1X more unique crashes than the second best fuzzer Angora.</p><p>AFL and CollAFL barely could satisfy the complicated path constraints, becasue they are insensitive to data flow features. Interestingly, Anogra shows a fast growth in the beginning and reaches a bottleneck after a few hours. Again, it shows gradient descent is effective at generating interesting test cases. However, it will be trapped soon, due to the inaccuracy of taint and local optimum issue of gradient descent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Heuristic Constraints Solving</head><p>Note that, GREYONE could bypass a wide range of complicated constraints, by utilizing FTI. In order to further evaluate its effectiveness, we compare it with a state-of-the-art symbolic execution assisted fuzzer QSYM.</p><p>To perform fair comparison, we setup similar environments for QSYM and GREYONE. First, we followed the same configuration in the original paper <ref type="bibr" target="#b41">[43]</ref> to evaluate QSYM. More specifically, QSYM works together with a master AFL and a slave AFL instance, occupying three CPU cores and 256GB memory. On the other hand, we setup GREYONE to work with a slave AFL by simply sharing their seed queues, occupying only two CPU cores and 8GB memory. <ref type="table" target="#tab_8">Table 5</ref> shows the head-to-head comparison results, in 5 runs with 60 hours each time. Although GREYONE takes fewer computing resources, it outperforms QSYM in terms of both code coverage and vulnerabilities discovery. On average, GREYONE found 1.2X unique paths, 1.12X edges, 2.15X unique crashes and 1.52X vulnerabilities than QSYM.</p><p>To further demonstrate the effectiveness of constraints solving, we tracked the growth trend of paths coverage and presented in <ref type="figure" target="#fig_4">Figure 6</ref>. We could find GREYONE cover more paths in a faster pace than QSYM in most subjects.</p><p>According to the above evaluation, the heuristic constraint solving capability provided by GREYONE outperforms symbolic constraint solver when applied to hybrid fuzzing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Further Analysis</head><p>We further evaluated GREYONE's ability of data flow analysis and the outcome of applying such data flow features to fuzzing, to better understand the improvements of GREYONE.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Performance of FTI</head><p>Our taint analysis engine FTI provides support for further taint-guided mutation and conformance-guided evolution, playing an important role in GREYONE. In this section, we evaluated the efficiency and performance of FTI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Completeness of Taint Inference</head><p>As aforementioned, FTI is sound and has no over-taint issues. However, it may have under-taint issues due to its incomplete testing in the pilot fuzzing. We hereby evaluated the undertaint issues FTI is facing. Note that, it is infeasible to get the ground truth of the accurate taint information, even if the source code is given, due to challenges like implicit data flows and external dependencies. As a result, we directly compare FTI with another dynamic taint analysis (DTA) engine, to roughly estimate under-taint.</p><p>Experiment Setup. There are several taint analysis engines available <ref type="bibr" target="#b0">[2,</ref><ref type="bibr" target="#b18">20]</ref>, we chose DFSan <ref type="bibr" target="#b0">[2]</ref> as the DTA engine to compare with, since it is the official engine shipped with the LLVM <ref type="bibr" target="#b20">[22]</ref> compilation framework and has good runtime performance and platform support.</p><p>As aforementioned, solutions like DFSan not only suffer from implicit data flows, but also external dependencies. For example, if an external library is not processed with DFSan, the taint propagation will be broken once it flows into the library. To mitigate this issue, we built taint models for all external libraries used in the experiment. Therefore, DFSan could get more taint information than its default configuration.</p><p>Then, we built a variation of GREYONE, named as GREY-ONE-DTA by replacing its taint analysis engine with DFSan.  Further we tested GREYONE and GREYONE-DTA on 11 real world applications and 4 applications from LAVA-M. For each application, we randomly selected hundreds of unique program paths that have been explored by both GREYONE and GREYONE-DTA. Then we examined all untouched branches in these paths, and counted the number of untouched branches that are related to input bytes (i.e., tainted). <ref type="figure" target="#fig_5">Figure 7</ref> shows the proportion of tainted untouched branches reported by GREYONE of version FTI and DTA. Note that, FTI has no over-taint issues, but DTA may have over-taint issues (e.g., due to wrong taint propagation in XOR instructions etc.). From the figure, we can learn that:</p><p>• DTA still has serious under-taint issues in all applications, even though we have mitigated some (caused by external dependencies). All the tainted untouched branches reported by FTI-only are missed by DTA. Most of these under-taint issues are caused by implicit data flows.</p><p>• FTI has fewer under-taint issues. It also finds much more taint (without over-taint) than DTA, even if DTA could have over-claimed. For example, DTA could only identify 25% of taint reported by FTI in the application fig2dev. On average, FTI could find 1.3X times more tainted untouched branches than DTA. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Overhead of Taint Inference</head><p>As aforementioned, for each seed, FTI first performs bytelevel mutation to generate new test cases. It then tests the target applications and tracks the code coverage. During testing, FTI monitors the value changes and infers taint for all untouched branches in the path explored by the original seed. <ref type="figure" target="#fig_6">Figure 8</ref> shows the average speed of analyzing one seed by FTI. The bar named tracking-path-only represents the time used for byte-level mutation and fuzzing. The bar FTI also includes the time of taint inference including value monitoring. It shows that taint inference introduces less than 25% overheads. <ref type="figure" target="#fig_7">Figure 9</ref> further shows the time of inferring taint for one branch instruction in the path. On average, FTI spends 0.15 seconds on inferring taint for one branch instruction..</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Improvements Breakdown</head><p>GREYONE adopts two major data flow features, i.e., taint and constraint conformance, and several schemes to improve the efficiency of fuzzing. We hereby breakdown the improvements of each scheme. a) Taint Inference. <ref type="figure" target="#fig_8">Figure 10</ref> shows the code coverage brought by GREYONE and GREYONE-DTA, which replaces the taint inference engine FTI with another engine DFSan. It shows that, on average, FTI could double the code coverage on all targets, comparing to GREYONE-DTA. Thus, our taint analysis engine FTI is useful. b) Bytes prioritization. GREYONE uses taint to guide mutation, by prioritizing input bytes to mutate, and determine the way to mutate. We hereby measured the improvements brought by byte prioritization. As shows in <ref type="table" target="#tab_9">Table 6</ref>, after disabling bytes prioritization, GREYONE-BP could explore much less code and find fewer vulnerabilities on all applications. On average, it has 14% fewer unique paths and 42% fewer unique crashes than GREYONE. <ref type="figure">Figure 11</ref>: Improvements brought by byte prioritization and conformance-guided evolution, in terms of code coverage and unique crashes found in two applications.</p><p>We further tracked the growth trend of unique paths and unique crashes. <ref type="figure">Figure 11</ref> shows that, in terms of code coverage, with byte prioritization, GREYONE could find about 20% more paths in applications tiff2pdf and libwpd. In terms of unique crashes, with byte prioritization, GREYONE could find unique crashes faster, and find much more. Especially, when testing the application tiff2pdf, GREYONE could not find any crashes in 60 hours if byte prioritization is turned off.</p><p>c) Conformance-guided Evolution. GREYONE utilizes conformance to guide the evolution direction of fuzzing. We also evaluated the improvements of this scheme, in a way similar to byte prioritization. As shows in <ref type="table" target="#tab_9">Table 6</ref>, after disabling conformance-guided, GREYONE-CE explores much less code and find fewer vulnerabilities on all applications, even worse than GREYONE-BP. On average, it has 21.9% fewer unique paths and 63.2% fewer unique crashes than GREYONE.</p><p>Specially, without conformance-guided evolution, GREY-ONE found 30% fewer paths in all applications, and failed to find any unique crashes in Tiff2pdf and libwpd. d) Selective execution.The advantage of selective mechanism is to avoid selecting the correspondent instance to execute when the new seed is mutated too many bytes or has low probability to generate better conformance. By taking this strategy, the most intuitive effect to fuzzing is to improve the overall execution speed. To show the promotion, we conducted two selective mode in GREYONE, one was the default set, the other was only to select the instance with monitoring conformance to execute. As shown in <ref type="figure" target="#fig_0">Fig 12,</ref> we tested 14 subjects and evaluated the average execution speed on each subject. Comparing to AFL, GREYONE with selective mechaz <ref type="figure" target="#fig_0">Figure 12</ref>: The speed impact brought by selective execution in GREYONE (60 hours).</p><p>nism can reach a speed at over 80%, while GREYONE without selective mechanism could only reach a speed at less than 65%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>Evolutionary mutation-based fuzzing achieved a great success in practice, due to its scalability and efficiency. The representative solution AFL <ref type="bibr" target="#b42">[44]</ref> takes achieving higher code coverage as evolution direction, and mutates seeds in a nearly random manner. Many other solutions, including taint analysis, have been proposed to improve mutation-based fuzzing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Taint Inference</head><p>Taint analysis is a fundamental technique for many applications including fuzzing. Traditional taint analysis solutions <ref type="bibr" target="#b0">[2,</ref><ref type="bibr" target="#b18">20]</ref> heavily rely on manual efforts of compose taint propagation rules for each instruction, and suffer from serious under-taint and over-taint problems.</p><p>Improvements to traditional taint analysis. Many alleviated schemes are proposed to mitigate the inaccuracy issue for traditional taint analysis. Dytan <ref type="bibr" target="#b9">[11]</ref> keeps track of indirect taint propagation to mitigate the under-taint issue, but brings lots of false positives. DTA++ <ref type="bibr" target="#b17">[19]</ref> locates implicit control flow branch and diagnose under-taint using offline symbolic execution. However, it suffers from solving complicated conditions and high performance overheads. TAINTIN-DUCE <ref type="bibr" target="#b44">[46]</ref> adopts a testing-based solution to infer taint propagation rules automatically. But it is very heavy-weight, and cannot solve the inaccuracy issues.</p><p>Mutation-based inference. Some recent works proposed mutation-based taint inference which have better performance in certain applications. Sekar <ref type="bibr" target="#b29">[31]</ref> adopts black-box testing and leverages predefined mutation rules to infer taint, able to detect injection attacks. MutaFlow <ref type="bibr" target="#b24">[26]</ref> monitors changes of security-sensitive APIs by mutating sensitive source APIs, able to detect vulnerable information flow. These two focus on local program behaviors and are limited to information flow detection. In fuzzing applications, REDQUEEN <ref type="bibr" target="#b2">[4]</ref> uses random mutation to colorize inputs, to infer taint related to direct copy of inputs. Fairfuzz <ref type="bibr" target="#b22">[24]</ref> and ProFuzzer <ref type="bibr" target="#b40">[42]</ref> monitor the pattern of control flow changes among multiple runs, to infer partial type of mutated bytes. None of these solutions have ever considered the variables' value changes after mutation, Thus, they all fail to provide accurate taint information. In this paper, we propose a fuzzing-driven taint inference solution FTI. We perform a systematic byte-level mutation to perform a pilot fuzzing. During fuzzing, we monitor variables' value changes and infer taint attributes accordingly. This solution is automated, lightweight and more accurate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Seed Mutation</head><p>Many studies <ref type="bibr" target="#b8">[10,</ref><ref type="bibr" target="#b11">13,</ref><ref type="bibr" target="#b28">30,</ref><ref type="bibr" target="#b42">44]</ref> have shown that, seed mutation is one of the most hot and hard direction to increase the efficiency and accuracy of fuzzing. Many approaches are proposed to try to solve how and where to mutate. a) Static-analysis-based optimization. <ref type="bibr">Steelix [25]</ref> and Laf-intel-pass <ref type="bibr">[1]</ref> statically decompose those long constant comparisons into multiple shorter comparisons. So that the dumb random fuzzer could satisfy the path constraints with a much higher probability. However, it brings too many semantic-equivalent paths to explore, and cannot handle nonconstant comparisons. SYMFUZZ <ref type="bibr" target="#b6">[8]</ref> leverages static symbolic analysis to detect dependencies among input bits, and uses it to compute an optimal mutation ratio. However, this process is slow, and the calculated dependency between bits do not show many improvements for mutation. b) Learning-based model. Rajpal et.al. <ref type="bibr" target="#b27">[29]</ref> presents a RNN-based model to predict best locations to mutate in seeds, based on the history mutations and their corresponding code coverage feedback. Konstantin et.al. <ref type="bibr" target="#b5">[7]</ref> uses deep reinforcement learning to model the fuzzing loop and choose the best mutation actions in the following fuzzing iteration. These solutions are in early stage and have not shown significant improvements yet. NEUZZ <ref type="bibr" target="#b33">[35]</ref> identifies the significance of program smoothing and uses an incremental learning technique to guide mutation. c) Symbolic-based solution. This type of solutions essentially utilize symbolic execution to solve the complicated path constraints that are hard to be satisfied by mutation-based fuzzing. Driller <ref type="bibr" target="#b35">[37]</ref> periodically picks paths that are stuck in mutation-based fuzzing, and uses symbolic execution to solve the constraints of those paths. QSYM <ref type="bibr" target="#b41">[43]</ref> ports symbolic execution to native X86 instructions and relaxes the path constraints to solve, providing a better analysis performance and reducing the speed of constraint solving. DigFuzz <ref type="bibr" target="#b43">[45]</ref> designs a probabilistic path prioritization model to quantify each path's difficulty and prioritize them for concolic execution. All of these symbolic-based solution cannot scale to large applications due to the open challenge of constraint solving. d) Taint-based mutation. Several fuzzers utilize taint to guide mutations. Dowser <ref type="bibr" target="#b15">[17]</ref> and BORG <ref type="bibr" target="#b25">[27]</ref> use taint to locate buffer boundary violations and buffer over-read vulnerabilities respectively. BuzzFuzz <ref type="bibr" target="#b13">[15]</ref> uses DTA to track the regions of external seed inputs that affect sensitive library or system calls. TaintScope <ref type="bibr" target="#b38">[40]</ref> leverages fine-grained DTA to identify checksum branch. VUzzer <ref type="bibr" target="#b28">[30]</ref> is able to track branches that compare variables against constants, e.g., magic numbers, and guides the mutation accordingly. Angora <ref type="bibr" target="#b8">[10]</ref> performs shape inference and gradient descent computation based on DTA. These solutions suffer from inaccurate taint, limiting the efficiency in complicated programs.</p><p>In addition, the high overhead of DTA greatly limits the application of DTA in large applications. Among the lightweight taint-guide mutation solutions, Fairfuzz <ref type="bibr" target="#b22">[24]</ref> and Profuzzer <ref type="bibr" target="#b40">[42]</ref> could not obtain accurate taint attributes of variables, inefficient at exploring hard-to-reach branches. In addition, they would repeatedly mutate some input bytes, even if the relevant branches have already been explored, since they are insensitive to branch states. REDQUEEN <ref type="bibr" target="#b2">[4]</ref> focuses on identifying direct copy of inputs and branches that use them, unable to handle the prevalent uses of indirect copy of inputs.</p><p>Our solution GREYONE utilizes the lightweight and sound taint inference solution FTI to get more taint attributes (with-out over-taint) as well as the precise relationship between input offsets and branches, to prioritize which branch to explore and which bytes to mutate, as well as determine how to precisely mutate them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Seed Updating and Selection</head><p>Seed updating and selection could adjust the evolution direction of fuzzing. A good solution would improve the efficiency of fuzzers in finding more code and bugs <ref type="bibr" target="#b26">[28]</ref> and in moving towards potentially vulnerable target code <ref type="bibr" target="#b3">[5,</ref><ref type="bibr" target="#b7">9,</ref><ref type="bibr" target="#b37">39]</ref>.</p><p>Few works focus on seed updating, but many seed selection solutions are proposed in the past years. These solutions in general collect more and more auxiliary control flow information to guide the seed selection. At the beginning, AFL <ref type="bibr" target="#b42">[44]</ref> prioritizes those seeds with smaller size and shorter execution time, to generate more test cases in a given time period. Then, AFLFAST <ref type="bibr" target="#b4">[6]</ref> points out the importance of seed selection, and prioritizes seeds that are rarely picked to mutate and that explore cold paths. From then on, kinds of control flow characteristics are used to guide seed selection, e.g., by prioritizing deeper path <ref type="bibr" target="#b28">[30]</ref> or untouched neighbour branches <ref type="bibr" target="#b12">[14]</ref>.</p><p>However, these solutions did not consider any data flow features, and thus are inefficient at exploring paths with complicated constraints. Honggfuzz <ref type="bibr" target="#b36">[38]</ref> and LibFuzzer <ref type="bibr" target="#b30">[32]</ref> took a weak data flow feature to guide seed selection. More specifically, they evaluate the distance between operands of all branches, and use it to guide seed selection. GREYONE improves this strategy by evaluating the constraint conformance on all tainted untouched branches only. It also utilizes a novel two-dimension seed queue structure to provide support for efficient seed updating and selection. It is able to avoid the local minimum problem faced by the learning-based solution used in Angora <ref type="bibr" target="#b8">[10]</ref>. Further, GREY-ONE applies a novel on-the-fly mutation rebase to further accelerate the evolution of fuzzing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Performance Optimization</head><p>Performance is an important factor of efficient fuzzing. Several solutions have been proposed to improve the fuzzing performance, by boosting the parallel execution <ref type="bibr" target="#b39">[41]</ref> or instrumentation <ref type="bibr" target="#b16">[18,</ref><ref type="bibr" target="#b34">36]</ref>. The recent work Untracer <ref type="bibr" target="#b34">[36]</ref> removes unnecessary instrumentation in basic blocks that have been explored and reduces the overhead. GREYONE also optimizes the instrumentation, to select more light-weight testing mode on demand, and switch between different fuzzing mode, to improve the speed of fuzzing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this paper, we propose a novel data flow sensitive fuzzing solution GREYONE. It infers taint during the fuzzing process by monitoring variable value changes, and further guides seed mutation with the inferred taint. It also applies a data flow feature conformance to tune the evolution direction of fuzzing, driving the fuzzer to quickly reach unexplored branches and trigger potential vulnerabilities. It outperforms various stateof-the-art fuzzers in terms of both code coverage and vulnerability discovery, while its taint analysis is more lightweight and accurate than others.   For example, in the application readelf, GREYONE fell behind Angora at the beginning. But it caught up with Angora at 40 hours, and maintained a strong and steady growth trend, far surpassing Angora finally.</p><p>Among other fuzzer tools, Angora could achieve high code coverage in a very short time in some applications, e.g., readelf and nm It proves that its gradient descent based mutation is effective. However, it may fall into local minimum soon, leading to very poor code coverage on most applications, e.g., libwpd, fig2dev, libncurses, abd c++filt.</p><p>Randomness. As shown in <ref type="figure" target="#fig_10">Fig 15,</ref> the randomness in fuzzing does not affect the conclusion, the worst run of GREY-ONE still shows better code coverage than the best run of other fuzzers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Growth Trend of Unique Crashes</head><p>In this section, we present the growth trend of unique crashes and the effects of randomness.</p><p>Unique Crashes. As shown in <ref type="figure" target="#fig_9">Fig 14,</ref> GREYONE has a strong growth trend on each application. Comparing to other fuzzers, GREYONE could find more unique crashes in almost all applications. It also finds crashes faster than other fuzzers in all applications except readelf. Similar to growth trend of paths, Angora could find more crashes than GREYONE in earlier stage on the subject readelf, but is surpassed by GREYONE after 50 hours.</p><p>Randomness. The number of unique crashes is more sensitive to randomness than code coverage, because crashes are rare comparing to program path. However, we can see that worst run of GREYONE in general still shows better code coverage than the best run of other fuzzers.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Illustration of the procedure for FTI, along with a sample program with over-taint and under-taint issues.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Dependency between inputs, variables and branches.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>W byte (S, pos) = ∑ br∈Path(S) IsUntouched(br) * DepOn(br, pos) (2)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>edge coverage in Fig 16. It shows that GREYONE has an impressive stronger growth trend than all other fuzzers in all applications.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: The growth trend of number of unique paths (average of 5 runs) detected by QSYM-* and GREYONE-*.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Proportion of tainted untouched branches reported by FTI-only, DTA-only and both FTI and DTA.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Average speed of analyzing one seed by FTI.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Average speed of inferring taint for one branch instruction, given input seeds of 1KB size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Code coverage improvement brought by FTI.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: The growth trend of number of unique crashes (5 runs) detected by AFL, CollAFL-br, Angora and GREYONE.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: Path randomness.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 16 :</head><label>16</label><figDesc>Figure 16: Edge coverage.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 1 : Number of vulnerabilities (accumulated in 5 runs) detected by 6 fuzzers, including AFL, CollAFL-br, VUzzer, Honggfuzz, Angora, and GREYONE, after testing each application for 60 hours.</head><label>1</label><figDesc></figDesc><table>Vulnerabilities by GREYONE 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><head>Table 2 : Number of unique crashes (average and maximum count in 5 runs) found in real world programs by various fuzzers.</head><label>2</label><figDesc></figDesc><table>AFL 
CollAFL-br 
Angora 
GREYONE 
Applications 
Average 
Max 
Average 
Max 
Average 
Max 
Average 
Max 
tiff2pdf 
0 
0 
0 
0 
0 
0 
6 
12 
libwpd 
0 
0 
1 
3 
0 
0 
21 
58 
fig2dev 
8 
12 
11 
20 
0 
0 
40 
79 
readelf 
0 
0 
0 
0 
21 
27 
28 
38 
nm 
0 
0 
0 
0 
0 
0 
16 
72 
c++filt 
18 
30 
7 
32 
0 
0 
268 
575 
ncurses 
7 
18 
12 
23 
0 
0 
28 
37 
libsndfile 
4 
13 
8 
20 
0 
0 
23 
33 
libbson 
0 
0 
0 
0 
0 
0 
6 
12 
tiffset 
22 
46 
43 
49 
0 
0 
83 
122 
libsass 
0 
0 
0 
0 
0 
0 
8 
12 
cflow 
9 
47 
17 
35 
0 
0 
32 
185 
nasm 
5 
15 
20 
42 
6 
12 
157 
212 
Total 
73 
181 
119 
229 
27 
39 
716 (+501%) 
1447 (+631%) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="true"><head>Table 3 :</head><label>3</label><figDesc>Number of unique paths and edges (average in 5 runs) found in real world programs by various fuzzers. Numbers in red are path/edge coverages of the second best fuzzer.</figDesc><table>Path Coverage 
Edge Coverage 
Applications 
AFL 
CollAFL-br 
Angora 
GREYONE (INC) 
AFL 
CollAFL-br 
Angora 
GREYONE (INC) 
tiff2pdf 
2638 
3278 
3344 
5681(+69.9%) 
6261 
6776 
6820 
8250(+20.9%) 
readelf 
4519 
4782 
5212 
6834(+32%) 
6729 
6955 
7395 
8618(+14.5%) 
fig2dev 
697 
764 
105 
1622(+112%) 
934 
1754 
489 
2460(+40.2%) 
ncurses 
1985 
2241 
1024 
2926(+30.6%) 
2082 
2151 
1736 
2787(+28.2%) 
libwpd 
4113 
3856 
1145 
5644(+37.2%) 
5906 
5839 
4034 
7978(+35.1%) 
c++filt 
9791 
9746 
1157 
10523(+8%) 
6387 
6578 
3684 
7101(+8%) 
nasm 
7506 
7354 
3364 
9443(+25.8%) 
6553 
6616 
4766 
8108(+22.5%) 
tiffset 
1373 
1390 
1126 
1757(+26%) 
3856 
3900 
3760 
4361(+11.8%) 
nm 
2605 
2725 
2493 
4342(+59%) 
5387 
5526 
5235 
8482(+53.5%) 
libsndfile 
911 
848 
942 
1185(+25.8%) 
2486 
2392 
2525 
2975(+17.8%) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>Table 4 : The number of bugs found by various fuzzer tools on LAVA-M in 24 hours.</head><label>4</label><figDesc></figDesc><table>LAVA-M 
AFL 
CollAFL-br 
Honggfuzz 
VUzzer 
CollAFL-br+laf 
QSYM 
Angora 
GREYONE 
Listed bugs 
who 
0 
2 
4 
49 
245 
1252(+43) 
1438(+95) 
2136(+327) 
2136 
md5sum 
1 
3 
3 
12 
37 
57(+0) 
57(+0) 
57(+4) 
57 
base64 
2 
2 
6 
15 
44 
44(+4) 
44(+4) 
44(+4) 
44 
uniq 
1 
1 
4 
24 
21 
28(+1) 
28(+1) 
28(+1) 
28 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>Table 5 :</head><label>5</label><figDesc></figDesc><table>Number of unique paths, unique edge, unique crashes (average count in 5 runs with 60 hours each time) and total 
vulnerabilities (5 runs with 60 hours each time) found in real world programs by QSYM-* (QSYM+master AFL+ slave AFL) 
and GREYONE-* (GREYONE +slave AFL). 

Average Unique Paths 
Average Unique Edges 
Average Unique Crashes 
Total Vulnerabilities 
Applications 
QSYM-* 
GREYONE-* 
QSYM-* 
GREYONE-* 
QSYM-* 
GREYONE-* 
QSYM-* 
GREYONE-* 
Readelf 
9028 
12312(+36.38%) 
7822 
8847(+13.10%) 
46 
77 
4 
4 
Nm 
4218 
5822(+38.03%) 
6773 
8599(+26.96%) 
3 
18 
1 
2 
C++filt 
10988 
12122(+10.32%) 
6898 
7155(+3.73%) 
158 
299 
4 
4 
Tiff2pdf 
4856 
5698(+17.34%) 
7431 
8088(+8.84%) 
0 
3 
0 
2 
Tiffset 
1897 
2205(+16.24%) 
4285 
4404(+2.78%) 
25 
66 
2 
2 
Libwpd 
8279 
10589(+31.27%) 
9947 
11702(+17.64%) 
12 
24 
1 
2 
libsndfile 
1375 
1650(+20%) 
2691 
3033(+12.71%) 
32 
46 
1 
2 
Fig2dev 
1218 
1616(+32.68%) 
1843 
2241(+21.60%) 
15 
38 
6 
10 
Nasm 
9184 
9529(+3.76%) 
7433 
8104(+9.03%) 
87 
231 
8 
11 
libncurses 
2837 
3291(+16%) 
2749 
2950(+7.31%) 
36 
88 
3 
5 
Average Improvement 
-
+20.34% 
-
+12.53% 
-
+115% 
-
+52% 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="true"><head>Table 6 : Number of unique paths and crashes (average in 5 runs with 60 hours one run) found in real world programs by GREYONE, GREYONE-CE and GREYONE-BP, where GREYONE-CE is the mode of GREYONE disabling conformance-guided evolution and GREYONE-BP is the mode of GREYONE disabling bytes prioritization.</head><label>6</label><figDesc></figDesc><table>Unique Paths 
Unique Crashes 
Applications 
GREYONE 
GREYONE-CE 
GREYONE-BP 
GREYONE 
GREYONE-CE 
GREYONE-BP 
Readelf 
6834 
6222(-9%) 
5757(-15.8%) 
28 
21(-25%) 
25(-10.7%) 
Nm 
4342 
3432(-21%) 
3886(-10.5%) 
16 
4(-75%) 
7(-56.3%) 
C++filt 
10523 
9870(-6.2%) 
9932(-5.6%) 
268 
127(-52.6%) 
225(-16%) 
Tiff2pdf 
5681 
4107(-27.8%) 
4598(-19%) 
6 
0(-100%) 
0(-100%) 
Tiffset 
1757 
1345(-23.4%) 
1434(-18.4%) 
83 
28(-66.3%) 
49(-41%) 
Libwpd 
5644 
4220(-25.2%) 
4982(-11.7%) 
21 
0(-100%) 
7(-66%) 
libsndfile 
1185 
1069(-10%) 
1081(-8.2%) 
23 
7(-69.6%) 
9(-60.9%) 
Fig2dev 
1622 
999(-38.4%) 
1211(-25.3%) 
40 
24(-40%) 
33(-17.5%) 
Nasm 
9443 
6578(-30.3%) 
7979(-15.5%) 
157 
28(-82.2%) 
79(-49.7%) 
libncurses 
2926 
2112(-27.8%) 
2543(-13%) 
28 
22(-21.4%) 
25(-10.7%) 
Average Reduction 
-
-21.9% 
-14.3% 
-
-63.2% 
-42.9% 

</table></figure>

			<note place="foot" n="1"> The paper focuses on fuzzing, and dynamic taint analysis is more accurate than its static counterpart. So we only focus on dynamic taint analysis.</note>

			<note place="foot" n="2"> FTI could suffer from under-taint issues due to incomplete pilot fuzzing.</note>

			<note place="foot" n="3"> This may cause incomplete testing.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>We would like to thank the anonymous reviewers for their insightful and valuable comments. This research was supported in part by National Nuclear High-Base Project(2018ZX01028102), National Natural Science Foundation of China under Grant 61772308, 61972224 and U1736209, and BNRist Network and Software Security Research Program under Grant BNR2019TD01004 and BNR2019RC01009.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A APPENDIX</head><p>Due to the space limit, we present some of the evaluation results here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Growth Trend of Code Coverage</head><p>In this section, we present the evaluation result of the code coverage growth trend and the effects of randomness.</p><p>Code Coverage. <ref type="figure">Figure 13</ref> and <ref type="figure">Fig. 16</ref> show the average growth trend of paths and edges detected by each fuzzer in five runs. It shows that GREYONE has a stronger growth trend than other fuzzers in all applications. Unlike other fuzzers, GREYONE keeps a steady growth trend for a long time.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dataflowsanitizer</surname></persName>
		</author>
		<ptr target="https://clang.llvm.org/docs/DataFlowSanitizerDesign.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Utilities for automated crash sample processing</title>
		<ptr target="https://github.com/rc0r/afl-utils" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Redqueen: Fuzzing with input-to-state correspondence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aschermann</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Schumilo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Blazytko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gawlik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Holz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Directed greybox fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bohme</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V.-T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roychoudhury</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Coverage-based greybox fuzzing as markov chain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Böhme</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V.-T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roychoudhury</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2016 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1032" to="1043" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Böttinger</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Singh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
		<idno type="arXiv">arXiv:1801.04589</idno>
		<title level="m">Deep reinforcement fuzzing</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Program-adaptive mutational fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cha</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brumley</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security and Privacy (SP), 2015 IEEE Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="725" to="741" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Hawkeye: towards a desired directed grey-box fuzzer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2018 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2095" to="2108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Angora</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1803.01307</idno>
		<title level="m">Efficient fuzzing by principled search</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Dytan: a generic dynamic taint analysis framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clause</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Orso</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 international symposium on Software testing and analysis</title>
		<meeting>the 2007 international symposium on Software testing and analysis</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="196" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Lava: Large-scale automated vulnerability addition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dolan-Gavitt</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hulin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Leek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Mambretti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ulrich</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Whelan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security and Privacy (SP)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="110" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Peach fuzzing platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eddington</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Peach Fuzzer</title>
		<imprint>
			<biblScope unit="page">34</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Collafl: Path sensitive fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pei</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE Symposium on Security and Privacy (SP)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="679" to="696" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Taint-based directed whitebox fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ganesh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Leek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rinard</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st International Conference on Software Engineering</title>
		<meeting>the 31st International Conference on Software Engineering</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="474" to="484" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Security policies and security models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Goguen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meseguer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">1982 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1982" />
			<biblScope unit="page" from="11" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Dowsing for overflows: a guided fuzzer to find buffer boundary violations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haller</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Slowinska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Neugschwandtner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="49" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Lightweight instrumentation for coverage-guided fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hsu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-C</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-Y</forename><surname>Hsiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Huang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-K</forename><surname>Instrim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Network and Distributed System Security (NDSS), Workshop on Binary Analysis Research</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Dta++: dynamic taint analysis with targeted control-flow propagation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Mccamant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Poosankam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Song</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">libdft: Practical dynamic data flow tracking for commodity systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kemerlis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">P</forename><surname>Portokalidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Jee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keromytis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Acm Sigplan Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="121" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Evaluating fuzz testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klees</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ruef</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hicks</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2018 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2123" to="2138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">LLVM related publications. Official LLVM web site</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lattner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<ptr target="http://llvm.org" />
		<imprint/>
	</monogr>
	<note>Retrieved on 2010-12-04</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Type casting verification: Stopping an emerging attack vector</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="81" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Fairfuzz: A targeted mutation strategy for increasing greybox fuzz testing coverage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lemieux</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering</title>
		<meeting>the 33rd ACM/IEEE International Conference on Automated Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="475" to="485" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Steelix: program-state based binary fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chandramohan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-W</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tiu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering</title>
		<meeting>the 2017 11th Joint Meeting on Foundations of Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="627" to="637" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Detecting information flow by mutating input data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Avdiienko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Soremekun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">O</forename><surname>Böhme</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zeller</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering</title>
		<meeting>the 32nd IEEE/ACM International Conference on Automated Software Engineering</meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="263" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">The borg: Nanoprobing binaries for buffer overreads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neugschwandtner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Milani Comparetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Haller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th ACM Conference on Data and Application Security and Privacy</title>
		<meeting>the 5th ACM Conference on Data and Application Security and Privacy</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="87" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Automated domain-independent detection of algorithmic complexity vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Petsios</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Keromytis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jana</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Slowfuzz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conf. on Computer and Communication Security</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Not all bytes are equal: Neural byte sieve for fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajpal</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Singh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
		<idno>abs/1711.04596</idno>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Application-aware Evolutionary Fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rawat</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Vuzzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed System Security Symposium</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">An efficient black-box technique for defeating web application attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sekar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Continuous fuzzing with libfuzzer and addresssanitizer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Serebryany</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cybersecurity Development (SecDev)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="157" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Oss-fuzz -google&apos;s continuous fuzzing service for open source software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Serebryany</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Addresssanitizer: A fast address sanity checker</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Serebryany</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bruening</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Potapenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vyukov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the 2012 USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="309" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Efficient fuzzing with neural program smoothing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">She</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pei</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jana</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Neuzz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEESP</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Full-speed fuzzing: Reducing fuzzing overhead through coverage-guided tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Nagy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEESP</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Driller: Augmenting fuzzing through selective symbolic execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephens</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Grosen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Salls</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dutcher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cor-Betta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vigna</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Swiecki</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Honggfuzz</surname></persName>
		</author>
		<ptr target="http://code.google.com/p/hong-gfuzz" />
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Qtep: Qulity-aware test case prioritization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nam</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE 2017 Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A checksum-aware directed fuzzing tool for automatic software vulnerability detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Taintscope</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Designing new operating primitives to improve fuzzing performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="2313" to="2328" />
		</imprint>
	</monogr>
	<note>CCS &apos;17, ACM</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Profuzzer: On-the-fly input type probing for better zero-day vulnerability discovery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">You</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The growth trend of number of unique paths (average in 5 runs) detected by AFL, CollAFL-br</title>
		<imprint>
			<publisher>Angora and GREYONE</publisher>
			<date type="published" when="2019" />
			<biblScope unit="volume">13</biblScope>
		</imprint>
	</monogr>
	<note>IEEE Security and Privacy</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">{QSYM}: A practical concolic execution engine tailored for hybrid fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yun</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th {USENIX} Security Symposium ({USENIX} Security 18</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="745" to="761" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">American fuzzy lop</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zalewski</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<ptr target="http://lcamtuf.coredump.cx/afl/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Send hardest problems my way: Probabilistic path prioritization for hybrid fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhao</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xuan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Inferring taint rules without architectural semantics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zheng</forename><surname>Leong Chua</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
