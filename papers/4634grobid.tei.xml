<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:26+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Lowering the USB Fuzzing Barrier by Transparent Two-Way Emulation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rijnard</forename><surname>Van Tonder</surname></persName>
							<email>rvantonder@ml.sun.ac.za</email>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">MIH Media Lab</orgName>
								<orgName type="laboratory" key="lab2">MIH Media Lab, Stellenbosch University</orgName>
								<orgName type="institution">Stellenbosch University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herman</forename><surname>Engelbrecht</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">MIH Media Lab</orgName>
								<orgName type="laboratory" key="lab2">MIH Media Lab, Stellenbosch University</orgName>
								<orgName type="institution">Stellenbosch University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Lowering the USB Fuzzing Barrier by Transparent Two-Way Emulation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>USB</term>
					<term>emulation</term>
					<term>fuzzing</term>
					<term>man-in-the- middle</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Increased focus on the Universal Serial Bus (USB) attack surface of devices has recently resulted in a number of new vulnerabilities. Much of this advance has been aided by the advent of hardware-based USB emulation techniques. However, existing tools and methods are far from ideal, requiring a significant investment of time, money, and effort. In this work, we present a USB testing framework that improves significantly over existing methods in providing a cost-effective and flexible way to read and modify USB communication. Amongst other benefits, the framework enables man-in-the-middle fuzz testing between a host and peripheral. We achieve this by performing two-way emulation using inexpensive bespoke USB testing hardware, thereby delivering capabilities of a USB analyzer at a tenth of the cost. Mutation fuzzing is applied during live communication between a host and peripheral, yielding new security-relevant bugs. Lastly, we comment on the potential of the framework to improve current exploitation techniques on the USB channel.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Exploration of the USB attack surface has drawn attention among security researchers as far back as 2005 <ref type="bibr" target="#b4">[7]</ref>, and while USB bugs and exploits have been sporadically reported since 2009 <ref type="bibr" target="#b11">[14]</ref>, it is only in the last two years that considerable headway has been made. This is evidenced by a slew of new vulnerability reports in 2013, registering far more USB security advisories than previous years combined. <ref type="bibr">1</ref> These bugs are exhibited mostly in USB drivers of operating systems, and often lead to memory corruption vulnerabilities.</p><p>Perhaps the primary reason for the discovery of recent bugs is the maturity of cost-effective USB hardware which enables the injection of input into the USB channel <ref type="bibr" target="#b5">[8]</ref>. One such piece of hardware, the Facedancer <ref type="bibr">[2]</ref>, is a bespoke USB testing device that emulates a USB device with the aid of software. This approach lends itself well to finding bugs throughout the USB software stack, including core drivers, third-party drivers, and application software which handle USB data. Dedicated USB equipment, such as USB analyzers, are arguably the most effective for this task, but often prove to be prohibitively expensive. Other viable approaches for testing specific USB software without the use of hardware have also been demonstrated <ref type="bibr" target="#b3">[6]</ref>. Here, fuzz testing (or fuzzing) is made possible by emulating the presence of USB devices in a guest operating system. Unfortunately, this carries the limitation that USB software has to function within the constraints of the virtual operating system. Because the USB protocol interacts closely with hardware devices, this makes it difficult to achieve full USB functionality.</p><p>We therefore argue that a hardware-based approach should be preferred when exploring the USB attack surface. The cost-effectiveness and flexibility of a hardware-based approach, however, affect our ability to explore it efficiently. In practice, it is difficult to achieve both these goals with currently available solutions, which are discussed in depth in Section 5.</p><p>This paper presents a novel approach for finding bugs in USB software that is both cost-effective and highly flexible. The goal of the design is to allow one to tap into USB communication between a host and peripheral device. The data should not only be readable (affording functionality analogous to a bus-pirate device), but also modifiable, as typically made possible by a USB analyzer. Moreover, this is achieved with two bespoke USB emulation devices which establish two-way communication that is transparent to the host and peripheral. The attributes of the Transparent Two-Way Emulation (TTWE) framework thus enable us to perform man-in-the-middle fuzzing. Beyond supplying USB analyzer capabilities at a tenth of the cost, the framework also allows full control over the software that handles USB communication, unlike traditional bundled USB analyzer software. While the framework makes use of affordable hardware, it is a hybrid approach, and relies on a software component. This software component enables the desired flexibility and efficiency when exploring the USB attack surface, since its role is to transparently mediate USB communication between a host and peripheral.</p><p>In this paper we discuss the architecture of the framework, demonstrate the practical application thereof, and show that it is effective at finding USB bugs that may have security implications. The contributions of this work in particular are:</p><p>1. A USB testing framework that (a) Is flexible, by allowing man-in-the-middle modification of USB host/peripheral communication through software, (b) Is cost-effective in affording USB analyzer functionality by combining two inexpensive USB controllers, and (c) Lowers the knowledge requirement for USB testing by exposing existing host/device communication; no prior knowledge of the USB protocol is required to test (or fuzz) software.</p><p>2. Bug-finding results and analysis, for which we deliver an interpretation of the effectiveness in finding bugs using this approach.</p><p>3. Enhanced USB testing methods where we suggest further applications that the TTWE framework affords, such as cataloging USB host/peripheral responses.</p><p>As a departure point for discussing the framework architecture, an overview of the USB protocol is provided in Section 2. We proceed by discussing the architecture in depth, and the necessary logic for achieving the testing framework in Section 3. This is followed by our bugfinding results in Section 4 and an analysis of the framework in Section 5. Finally, we discuss related work and conclude in Sections 6 and 7, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>This section aims to give a high-level overview of the USB specification so that the framework implementation can be understood. In particular, the USB specification makes use of varying transfer types; transfers contain requests, descriptors, or data which are sent over endpoints to facilitate communication between a host and peripheral. We explain these in turn before considering the design of the framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Requests and Descriptors</head><p>The USB specification defines eleven standard requests.</p><p>A request from the host, such as get descriptor, expects to receive a descriptor from the peripheral, while other requests such as set address require the peripheral to perform an action. The peripheral responds with descriptors of varying types, containing the respective information. Requests and descriptors allow the USB host to learn about the capabilities of the peripheral, and are also used to load the appropriate software driver.</p><p>The USB specification defines eleven standard descriptor types, including device, configuration, and endpoint descriptors. Other descriptors may exist, like the Human Interface Device (HID) descriptor for keyboards and other input devices. A complete listing of requests and descriptors are available in the USB Device Working Group documentation <ref type="bibr">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Endpoints</head><p>USB endpoints provide a way for the host and peripheral to agree on the direction and address for a given transfer. The address is a number between 0 and 15. Endpoint 0 is a special address; it is a bi-directional endpoint that is used during control transfers (see Section 2.3 below). All USB devices must support communication on endpoint 0. Control transfers require bi-directional communication between host and peripheral, and therefore endpoint 0 uses both an IN and OUT direction. Endpoints for non-control transfers carry data that is particular to the peripheral. These endpoints, numbered 1 through 15, are unidirectional; an endpoint can either support an IN or an OUT direction, but not both. If bi-directional communication is required outside of endpoint 0, then separate endpoints are needed. For example, a USB massstorage device may designate in its endpoint descriptor that it will use endpoint 1 with an IN direction, and endpoint 2 with an OUT direction.</p><p>Endpoint directions are always specified from the perspective of the host. Furthermore, endpoint addresses are always defined by the peripheral's USB controller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Transfer types</head><p>Four USB transfer types exist: control, bulk, interrupt, and isochronous. Transfer types are used for different purposes; in this paper, we distinguish simply between control and non-control transfers. Control transfers establish initial communication between a host and peripheral, whereas non-control transfers typically carry data specific to peripheral functionality. For instance, a massstorage USB device would transfer file data using a bulk transfer, and a keyboard would transfer keystrokes using an interrupt transfer. In both instances, these peripherals would first establish basic communication with control transfers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Control transfers</head><p>Control transfers constitute the means by which a host learns about the peripheral attached to it. Control transfers comprise requests and descriptors as discussed in Section 2.1. The host enumerates the peripheral by sending requests, and the peripheral responds either with data (in a descriptor) or by performing an appropriate action. Control transfers only take place over endpoint 0. Once enumeration over endpoint 0 is complete, the host and peripheral can start exchanging data over non-control endpoints.</p><p>Control transfers have additional structure in the form of stages: setup, data, and status stages. Depending on the request, different stages take place. For instance, a peripheral will respond with a descriptor in the data stage in response to a get descriptor request. In a set address request, however, there is no data stage, and the peripheral will only respond with a status stage, indicating whether it was successful (ACK), is still busy (NAK), or failed (STALL). In Section 3.2 we consider how these considerations play a role in the implementation of the framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Non-control transfers</head><p>Non-control transfers (bulk, interrupt, and isochronous transfers) take place after the host has enumerated the peripheral. In summary, bulk transfers are used for large, time-insensitive data, isochronous for time-critical, real-time data, and interrupt transfers for periodic, low-bandwidth data. On most USB controller chips, bulk and interrupt transfers are treated the same; it is up to the host to signal when data is to be sent or received. Furthermore, non-control transfers may rely on additional, peripheral-specific protocols. One example includes mass-storage devices that commonly use the SCSI (Small Computer System Interface) protocol. Some examples of data that is sent using non-control transfers are provided in the </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Framework Architecture</head><p>We remind the reader that the goal of the framework is to allow one to tap into USB communication between a host and peripheral device in order to read and modify the data being transferred. In this section we consider a conceptual overview of the framework, proceeded by the hardware and software requirements to achieve effective operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Design</head><p>With the aid of two bespoke hardware testing devices, namely, two Facedancer devices <ref type="bibr">[2]</ref>, we are able to expose USB communication to a Mediating Computer (MC) with a man-in-the-middle strategy. These devices are essentially USB controllers that can act as either a USB host or device; detail of their hardware is given in 3.2. On its own, the Facedancer device can perform USB host or device emulation via software driven commands from a computer.</p><p>In our design, and with reference to <ref type="figure" target="#fig_0">Figure 1</ref>, we place one Facedancer in Peripheral Emulation Mode to interact with a USB HOST, and a second Facedancer acting in Host Emulation Mode to interact with a USB PERIPHERAL. By monitoring the hardware interrupts triggered on the Facedancer USB controllers, the MC is able to mediate communication by forwarding requests from the HOST, and responses from the PERIPHERAL. The HOST is under the impression that it is communicating with an authentic USB peripheral, but in fact it is an emulated USB peripheral whose responses are precisely that of the authentic USB PERIPHERAL monitored by the Facedancer in Host Emulation Mode. Similarly, the PERIPHERAL device is under the impression that it is communicating with an authentic host, whose requests are in fact emulated by continuously monitoring the authentic HOST using the Facedancer in Peripheral Emulation Mode.</p><p>The MC monitors the host by checking whether the Facedancer has received host requests or data, and also forwards device responses to the host via the Facedancer. This operation is performed by a USB client driver on the MC. In likewise manner, a USB Host driver monitors the Facedancer, and forwards host requests. The USB client and host driver exchange data via named pipes on the MC-this allows the USB data to be exposed and manipulated by any intermediary software, such as a mutation fuzzer, before the data continues on its normal course.</p><p>Whereas understanding the design is straightforward, there are a number of caveats which present themselves when implementing the framework; we address these in the next section. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Implementation</head><p>The design addresses the conceptual way in which we are able to mediate and tap into USB communication. There are, however, aspects of the USB protocol that do not translate readily to the framework design. These aspects include a) endpoint address numbering, and b) USB handshaking that pertain to control transfers without data stages. In this section we discuss the hardware and software requirements of the framework, and furthermore emphasize the role of software in overcoming the caveats mentioned.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Hardware</head><p>The functionality of the Facedancer device is central to the operation of the framework. Currently, the Facedancer is an affordable device 2 with attractive USB testing abilities for the purposes of our framework. However, any device with similar functionality can serve as a substitute; the framework is not specific to the Facedancer. For this reason, we briefly mention the major hardware components that bring about the required functionality. <ref type="bibr">3</ref> As shown in <ref type="figure" target="#fig_1">Figure 2</ref>, the main hardware components of the Facedancer are an FTDI USB/serial adapter chip, a 16-bit microcontroller, and a MAX3421E USB controller chip. USB emulation can be performed by sending software-driven USB data and commands to the microcontroller via the FTDI adapter. The microcontroller drives the USB controller, which may be placed in either host or peripheral mode by toggling a mode bit in one of the controller registers. Recall that in <ref type="figure" target="#fig_0">Figure 1</ref> </p><note type="other">, we place one Facedancer's USB controller in host mode, and the other in peripheral mode. The microcontroller listens for responses from the USB controller, which are in turn forwarded back to the computer driving emulation. Basic firmware is required for the microcontroller to perform these actions; such firmware is readily available for the Facedancer components [1].</note></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Software</head><p>The USB host and client drivers monitor the respective USB controller interrupts to determine when data can be sent and received. The drivers process the endpoint source and destination of data once it is available, and this data is sent between the drivers on dedicated named pipes. Another important responsibility of the software is handling special cases of the USB protocol. Problems that arise due to endpoint numbering are addressed by an endpoint hijacking approach. Complications in USB handshaking are handled by emulating certain aspects of the handshake procedure.</p><p>Endpoint Hijacking When a host receives an endpoint descriptor from a device in response to a get configuration request, it is informed of the endpoint address(es) that the device intends to use for noncontrol transfers. For example, consider the USB device in <ref type="figure" target="#fig_0">Figure 1 (depicted as a mass-storage stick)</ref>, which requires a bulk IN endpoint with address 1, and a bulk OUT endpoint with address 2. Recall from Section 2.2 that the direction is always from the perspective of the host, but the endpoint addresses, directions, and transfer types are specified in an endpoint descriptor which are fixed by the peripheral's USB controller, When the MAX3421E USB controller operates in Host Emulation Mode, it is able to send and receive on any endpoint number. However, when the MAX3421E USB controller of the Facedancer in <ref type="figure" target="#fig_1">Figure 2</ref> is operated in Peripheral Emulation Mode, its endpoint capabilities are fixed in hardware, and cannot be changed. These capabilities are as follows:</p><formula xml:id="formula_0">Endpoint Address Direction Transfer Type EP0 IN/OUT Control EP1 OUT Non-control EP2 IN Non-control EP3 IN Non-control</formula><p>Consider that an authentic USB peripheral may have different endpoint capabilities, which are also fixed. It is thus possible that endpoint addresses can be mismatched between the emulated peripheral's USB controller and the authentic USB peripheral's. In our case, the USB controller supports only an OUT direction on EP1, yet the authentic peripheral specifies that it must use EP1 with an IN direction. To overcome this problem, we "hijack" and modify the endpoint descriptor with the MC. When the MC detects an endpoint descriptor being sent from the authentic peripheral in response to a get endpoint descriptor from the host, it creates a new mapping whereby everything received on EP1IN of the USB host emulator will be sent on EP3IN of the USB peripheral emulator. Similarly, a mapping is created for the EP2OUT/EP1OUT pipe.</p><p>With the endpoint mapping in place, the authentic host and device can continue communication on the perceived information pipes. Since the USB specification does not mandate the capabilities of endpoints other than endpoint 0, the nature of the endpoint addressing scheme in our framework is thus obscured from the host and device, allowing a transparent data channel. With this scheme we can cope with any manner of endpoint addressing that a peripheral may require, provided the USB controller supports the same number of endpoints.</p><p>Emulating Handshaking A further consideration in our framework concerns USB control transfers which do not have a data stage. These control transfers include set address, set configuration, set interface, and clear feature requests. Because these transfers do not have a data stage, the peripheral would simply respond with a status packet, such as an ACK. The framework makes provision for mediating data transfers across the pipes, but for status packets, one of two work-around solutions is required:</p><p>1. After forwarding the host request, blindly acknowledge it with the peripheral emulator, without knowing the authentic peripheral's status result.</p><p>2. Communicate the authentic peripheral's status result once available. This requires extra logic so that custom status messages can be communicated between emulator drivers.</p><p>We opted for the former approach. This allows us to asynchronously ACK requests, and assume that the request will be successfully processed by the authentic peripheral. This poses the question, what if the request is not processed successfully, and the authentic peripheral responds with something other than an ACK? In such an event, subsequent requests from the host would not receive a response, and the breakdown of communication would become apparent on the host and client driver software. During testing, we observed this communication breakdown when we neglected to blindly ACK the aforementioned requests. After doing so, we did not encounter the scenario again in obtaining the results of Section 4, so the approach proved sufficient for such purposes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Results</head><p>In this section we discuss the preliminary results of our framework in exposing USB communication, as well as USB testing and fuzzing. The first significant result is the ability to expose USB communication between an authentic host and device, enabling man-in-the-middle attacks without requiring prior knowledge of the USB protocol. The second significant result is the discovery of new bugs in USB software. Due to the recent implementation of our USB framework, a limited time of approximately one week was spent fuzzing various hosts. Despite this brief period of dedicated testing, we discovered security-relevant bugs. As vulnerability disclosure is still being coordinated at the time of writing, critical details have been omitted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">USB Enumeration &amp; Functionality</head><p>Device Enumeration We have been able to successfully mediate communication between host and peripheral pairs, allowing the host to fully enumerate a vari-ety of USB peripheral classes. These include the USB HID, mass-storage, printer, and imaging device classes. Because of the generic manner in which enumeration is performed, we expect most device classes to work with this framework in a plug-and-play manner.</p><p>Device Functionality USB mass-storage functionality can be achieved successfully after device enumeration takes place. This means that we can perform mount, browse, read, and write actions on the mass-storage device from the host while tapping into USB communication. Consider <ref type="table" target="#tab_1">Table 1</ref>   Other communication in this table corresponds to standard USB enumeration behavior. We were able to achieve functionality in this fashion by writing additional software for the Facedancer that handles, for example, the granularity of bulk transfers in 512-byte blocks. If we wanted to support HID functionality, it would require writing additional software that simply monitors the interrupt endpoints on the Facedancer. Thus, achieving device functionality after enumeration may require additional code, but fortunately this is a software restriction, not a hardware one. Furthermore, this additional implementation in software pertains only to endpoint types, and is not device or vendor specific.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">USB Fuzzing</head><p>USB Printer Driver We discovered a bug in a popular operating system's core USB printer driver, which causes a kernel panic and system crash. Analysis of the crash dump revealed that this is due to an arbitrary memory read, resulting after heap corruption on the host. At present this bug causes a denial-of-service, but it may also allow arbitrary code execution. The bug was found by rudimentary fuzzing techniques-bytes were randomly mutated in flight during USB device enumeration. Initially, the bug was found by using a real printer; this was important since the host issued different requests depending on the printer's malformed responses. In particular, the bug is only triggered in response to a host request for a specific string descriptor. After inducing a system crash on the host, we could analyze the printer response and replay it, this time using only peripheral emulation.</p><p>USB Host Printer denial-of-service Another bug was discovered in a popular operating system which would cause an application to hang as soon as the user attempts to print something. This was not specific to any application, and would occur in word-processing programs, browsers, editors, and so forth. We could thus envision a scenario where an attacker may use a malicious USB device to perform a denial-of-service attack on a locally accessible computer. As long as the device remained in the computer, the user would need to forcibly terminate the application from which they attempted to print. It was found that this bug was a result of the host waiting in a busy-loop for certain USB ACK responses from the peripheral. Again, this bug was found with the aid of a real printer. After discovering the cause, we could reproduce the attack by replaying it using pure emulation. As before, the bug was triggered by refraining from responding to a specific host request.</p><p>USB Host Printer denial-of-service A certain printer which supports printing from a USB mass-storage device was found to contain a bug which causes the printer to crash. By using a real USB mass-storage device and fuzzing the printer host, the bug is triggered by a malformed SCSI response. As with previous bugs, we were able to replay the responses so that the printer could be crashed at will.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Analysis</head><p>Preliminary results indicate that our framework is effective, having detected novel bugs that would otherwise require much more effort to find using traditional emulation techniques. There are a number of improvements that the framework delivers over traditional solutions.</p><p>Flexibility While the framework allows platformindependent man-in-the-middle attacks on the USB protocol, this important feature is also possible with a USB analyzer <ref type="bibr" target="#b2">[4]</ref>. However, Davis <ref type="bibr" target="#b6">[9]</ref> mentions the limitations of the software provided with the tools: they lack a proper software API, requiring the user to make use of a custom scripting language <ref type="bibr" target="#b7">[10]</ref>. Our framework does not place restrictions on the user's ability to manipulate USB data. The host and client emulation drivers are implemented in Python and expose the raw USB data over Unix pipes. If desired, other forms of inter-process communication (IPC) such as Unix sockets could also be employed. We opted for named pipes due to the simplicity of having host and peripheral emulation drivers attach to these endpoints, instead of implementing extra IPC functionality in the drivers themselves. Moreover, the user is not restricted to Python, and if desired, may implement drivers that interact with the Facedancer in any preferred language. A further advantage of our framework is the ability to immediately replay USB communication from either a host or peripheral in an emulated fashion-the user need not write additional scripts to generate USB traffic.</p><p>Cost Effective Despite the software limitation of the USB analyzer, its capabilities go beyond that of other tools and pure software solutions. Davis <ref type="bibr" target="#b8">[11]</ref> attested in 2013 that it is the preferred device for finding USB bugs, although at a cost of approximately $1,400. In contrast, the hardware required by the Facedancer's in our solution would cost approximately $150 <ref type="bibr">[3]</ref>.</p><p>Background Knowledge Requirement As mentioned, a USB analyzer would typically require understanding of the USB protocol for generating USB traffic, as well as knowledge of a custom scripting language. Similarly, a single bespoke testing device such as the Facedancer requires knowledge of the USB protocol so that it can be programmed to respond appropriately to requests. For rudimentary fuzzing purposes, our solution requires very little knowledge about the underlying protocol, since the Facedancers simply relay device responses. By exposing the raw communication, users are able to capture, modify, and replay data between host and device.</p><p>Limitations There is a notable delay in USB communication between the host and peripheral due to the emulation devices. Currently, the average delay between USB control transfers is 300 milliseconds, granting enough time to perform USB enumeration in our setup. However, it was found that general mass-storage actions, as discussed in Section 4, take an extended amount of time. For example, it may take a few minutes to mount a mass-storage device, or list its contents. This delayed behavior can therefore impact the speed of fuzzing throughput on certain aspects of USB code.</p><p>One way to address the delay in communication may be to optimize the interrupt handling code in the Facedancer client and host drivers. Currently, the authentic peripheral is polled until a response is received, which is then forwarded to the host. Some hosts have a shorter timeout for peripheral responses, and may reissue redundant requests if the data is not relayed when it's immediately available; fine-grained tuning of poll intervals could thus quicken transmission. This could also be explored in tandem with communicating the entire handshaking process instead of performing blind ACKs for some requests, as mentioned in Section 3.2.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>The Facedancer <ref type="bibr">[2]</ref> presents recent advances in the arena of USB software testing by way of device emulation techniques. Bratus et al. demonstrate how this technique enables "efficient injection of arbitrary traffic" into the USB bus, while being affordable <ref type="bibr" target="#b5">[8]</ref>.</p><p>Software-only techniques for USB testing have been considered, where USB devices are emulated in a guest operating system environment <ref type="bibr" target="#b3">[6]</ref>. Similar fuzzing in various virtualized OS environments by Jodeit et al. <ref type="bibr" target="#b9">[12]</ref> has triggered bugs in virtualization software and USB drivers. Although this technique has proven its ability to find bugs, its effectiveness is limited to the capabilities of the virtualization software. According to Jodeit et al., a further limitation includes the difficulty in reproducing crashes.</p><p>Davis's use of USB analyzers has produced a number of CVE (Common Vulnerabilities and Exposures) identifiers relating to USB security on Windows, Solaris, and OS X <ref type="bibr" target="#b6">[9,</ref><ref type="bibr" target="#b8">11]</ref>. Davis also demonstrates the Frisbee USB testing automation by using USB analyzers within the confines of a cumbersome scripting language <ref type="bibr" target="#b7">[10]</ref>. Still, this has proven to be one of the best approaches to date.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this work we presented a framework that exposes USB communication between a host and peripheral in a flexible, cost-effective way. The framework contributes to the growing demands of USB testing software by enabling man-in-the-middle attacks, and allowing users to fuzz host and device USB software. We detected novel bugs that resulted by modifying USB data during realtime communication, and found that the bugs can be reproduced by replaying the captured responses in an emulated fashion.</p><p>We believe there are a number of additional applications for the TTWE framework beyond those covered in this paper. For one, the framework could be used to capture authentic host/peripheral USB communication which may be catalogued to serve as seed values for randomized fuzzing. This ability could speed up fuzzing, and in some instances substitute for the need of a physical device. Secondly, we envision that the framework can be leveraged in exploitation techniques such as Mulliner's mass-storage TOCTTOU attack <ref type="bibr" target="#b10">[13]</ref>. In lieu of maintaining two emulated mass-storage filesystems as per the original approach, and having to "switch between the original and modified filesystem image" in order to exploit the "read-it-twice" condition, one could instead modify the data on the fly from a single filesystem image at the exact moment that modification is desired. Such an ability is made evident from the discussion in Section 4.1.</p><p>The prospects of vulnerability discovery and exploitation of the USB attack surface are expected to increase as the tools for doing so improve. To echo the words of Joshua Wright, "Security will not get better until tools for practical exploration of the attack surface are made available" <ref type="bibr" target="#b12">[15]</ref>. We believe that the TTWE framework makes practical exploration of the USB attack surface flexible and affordable, thereby contributing to the effort of securing USB software.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Acknowledgements</head><p>A hearty thank you to Willem Bester for taking the time outside of his regular duties to deliver insightful comments during the review of this work. The authors also wish to thank Naspers for their financial support during the course of this research.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The TTWE Framework Architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The Facedancer hardware design for performing USB device emulation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>which presents mass-storage functionality by Two-Way Emulation on a Linux host. The orange row indicates the peripheral's endpoint de- scriptor, sent in the IN direction (DIR) on endpoint (EP) 0. The bold values 1 and 130 are the endpoint addresses that are to be hijacked and modified on the fly. The end- point address corresponds to the lower nibble of the hex- adecimal representation of these values: 1h and 2h re- spectively, with direction specified in the most signifi- cant bit (0h, or OUT, and 1h, or IN respectively). The subsequent yellow rows indicate the start of SCSI data transmitting on the desired endpoints EP1OUT and EP3IN after enumeration. Finally, the green row indicates a set configuration request by the host in the OUT di- rection; here, the host would receive a blind ACK, and the request is forwarded to the mass-storage device.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>table below .</head><label>below</label><figDesc></figDesc><table>Peripheral Type Action 
Transfer Type 
Keyboard 
Key presses 
Interrupt 
Mouse 
Navigation and clicks Interrupt 
Mass-storage 
File operations 
Bulk 
Printer 
File transfer 
Bulk 
Microphone 
Audio recording 
Isochronous 
Speaker 
Audio playback 
Isochronous 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 1 : Mass-storage device functionality by TTWE on a Linux Host</head><label>1</label><figDesc></figDesc><table></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<ptr target="https://goodfet.svn.sourceforge.net/svnroot/goodfet.Accessed25/05/2014" />
	</analytic>
	<monogr>
		<title level="j">Facedancer Firmware Source</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Goodfet</forename><surname>Facedancer</surname></persName>
		</author>
		<ptr target="https://goodfet.sourceforge.net/hardware/facedancer21/.Accessed25/05/2014" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mqp</forename><surname>Electronics</surname></persName>
		</author>
		<ptr target="http://www.mqp.com/usb500.htm.Ac-cessed25/05/2014" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mwr</forename><surname>Infosecurity</surname></persName>
		</author>
		<idno>25/05/2014</idno>
		<ptr target="https://labs.mwrinfosecurity.com/blog/2011/07/14/usb-fuzzing-for-the-masses/" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Plug and root, the USB key to the kingdom</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barrall</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dewey</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Black Hat Briefings</title>
		<imprint>
			<date type="published" when="2005-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Perimeter-crossing buses: A new attack surface for embedded systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bratus</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Goodspeed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">C</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Speers</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th Workshop on Embedded Systems Security (WESS) (sept. 2013)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">USB -Undermining security barriers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Davis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Black Hat Briefings</title>
		<imprint>
			<date type="published" when="2011-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fuzzing USB devices using frisbeelite</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Davis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NGS Secure Research</title>
		<imprint>
			<date type="published" when="2012-01" />
		</imprint>
	</monogr>
<note type="report_type">Tech. rep.</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">USB driver vulnerabilities whitepaper</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Davis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2013-01" />
		</imprint>
		<respStmt>
			<orgName>NCC Group</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Tech. rep</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">USB device drivers: A stepping stone into your kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jodeit</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johns</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 European Conference on Computer Network Defense</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Read it twice! A massstorage-based tocttou attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mulliner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michele</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th USENIX Workshop on Offensive Technologies</title>
		<imprint>
			<date type="published" when="2012-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Linux kernel USB device driver -buffer overflow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">D</forename><surname>Vega</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009-10" />
		</imprint>
	</monogr>
<note type="report_type">Tech. rep., MWR InfoSecurity</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wright</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<ptr target="http://code.google.com/p/zigbee-" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
				<idno>CVE-2013-1285 CVE-2012-2693 CVE-2011-0712 CVE-2010-4656 CVE-2009-4067</idno>
		<title level="m">CVE advisories related to USB software bugs</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
				<ptr target="http://goodfet.sourceforge.net/hardware/facedancer21/" />
		<title level="m">$75 at the time of writing 3 A complete bill of materials for the Facedancer may be</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
