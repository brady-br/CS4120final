<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:05+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">PeX: A Permission Check Analysis Framework for Linux Kernel PeX: A Permission Check Analysis Framework for Linux Kernel</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 14-16, 2019</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tong</forename><surname>Zhang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Virginia</forename><surname>Tech</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenbo</forename><surname>Shen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhejiang</forename><surname>University</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongyoon</forename><surname>Lee</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmed</forename><forename type="middle">M</forename><surname>Azab</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruowen</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tong</forename><surname>Zhang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Virginia</forename><surname>Tech</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenbo</forename><surname>Shen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongyoon</forename><surname>Lee</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmed</forename><forename type="middle">M</forename><surname>Azab</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruowen</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Changhee Jung</orgName>
								<orgName type="laboratory">Stony Brook University Changhee Jung Purdue University</orgName>
								<orgName type="institution" key="instit1">Stony Brook University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Samsung Research America</orgName>
								<orgName type="institution" key="instit4">Zhejiang University</orgName>
								<orgName type="institution" key="instit5">Samsung Research America</orgName>
								<orgName type="institution" key="instit6">Samsung Research America</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">PeX: A Permission Check Analysis Framework for Linux Kernel PeX: A Permission Check Analysis Framework for Linux Kernel</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 28th USENIX Security Symposium</title>
						<meeting>the 28th USENIX Security Symposium <address><addrLine>Santa Clara, CA, USA</addrLine></address>
						</meeting>
						<imprint>
							<date type="published">August 14-16, 2019</date>
						</imprint>
					</monogr>
					<note>This paper is included in the 978-1-939133-06-9 Open access to the Proceedings of the 28th USENIX Security Symposium is sponsored by USENIX. https://www.usenix.org/conference/usenixsecurity19/presentation/zhang-tong</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Permission checks play an essential role in operating system security by providing access control to privileged functionali-ties. However, it is particularly challenging for kernel developers to correctly apply new permission checks and to scalably verify the soundness of existing checks due to the large code base and complexity of the kernel. In fact, Linux kernel contains millions of lines of code with hundreds of permission checks, and even worse its complexity is fast-growing. This paper presents PeX, a static Permission check error detector for LinuX, which takes as input a kernel source code and reports any missing, inconsistent, and redundant permission checks. PeX uses KIRIN (Kernel InteRface based Indirect call aNalysis), a novel, precise, and scalable indirect call analysis technique, leveraging the common programming paradigm used in kernel abstraction interfaces. Over the inter-procedural control flow graph built by KIRIN, PeX automatically identifies all permission checks and infers the mappings between permission checks and privileged functions. For each privileged function, PeX examines all possible paths to the function to check if necessary permission checks are correctly enforced before it is called. We evaluated PeX on the latest stable Linux kernel v4.18.5 for three types of permission checks: Discretionary Access Controls (DAC), Capabilities, and Linux Security Modules (LSM). PeX reported 36 new permission check errors, 14 of which have been confirmed by the kernel developers.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background: Permission Checks in Linux</head><p>This section introduces DAC, Capabilities, and LSM in Linux kernel. <ref type="table" target="#tab_0">Table 1</ref> lists practically-known permission checks in Linux. Unfortunately, the full set is not well-documented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Discretionary Access Control (DAC)</head><p>DAC restricts the accesses to critical resources based on the identity of subjects or the group to which they belong <ref type="bibr" target="#b32">[36,</ref><ref type="bibr" target="#b42">46]</ref>. In Linux, each user is assigned a user identifier (uid) and a group identifier (gid). Correspondingly, each file has properties including the owner, the group, the rwx (read, write, and execute) permission bits for the owner, the group, and all other users. When a process wants to access a file, DAC grants the access permissions based on the process's uid, gid as well as the file's permission bits. For example in Linux, inode_permission (as listed in <ref type="table" target="#tab_0">Table 1</ref>) is often used to check the permissions of the current process on a given inode. More precisely speaking, however, it is a wrapper of posix_acl_permission, which performs the actual check. In a sense, DAC is a coarse-grained access control model. Under the Linux DAC design, the "root" bypasses all permission checks. This motivates fine-grained access control scheme-such as Capabilities-to reduce the attack surface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Capabilities</head><p>Capabilities, since Linux kernel v2. <ref type="bibr">2 (1999)</ref>, enable a finegrained access control by dividing the root privilege into small sets. As an example, for users with the CAP_NET_ADMIN capability, kernel allows them to use ping, without the need to grant the full root privilege. Currently, Linux kernel v4.18.5 supports 38 Capabilities including CAP_NET_ADMIN, CAP_SYS_ADMIN, and so on. Functions capable and ns_capable are the most commonly used permission checks for Capabilities (as listed in <ref type="table" target="#tab_0">Table 1</ref>). Both determine whether a process has a particular capability or not, while ns_capable performs an additional check against a given user namespace. They internally use security_capable as the basic permission check.</p><p>Capabilities are supposed to be fine-grained and distinct <ref type="bibr">[4]</ref>. However, due to the lack of clear scope definitions, the choice of specific Capability for protecting a privileged function has been made based on kernel developers' own understanding in practice. Unfortunately, this leads to frequent use of CAP_SYS_ADMIN (451 out of 1167, more than 38%), and it is just treated as yet another root <ref type="bibr" target="#b2">[5]</ref>; grsecurity points out that 19 Capabilities are indeed equivalent to the full root <ref type="bibr">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Linux Security Module (LSM)</head><p>LSM <ref type="bibr" target="#b47">[51]</ref>, introduced in kernel v2. <ref type="bibr">6 (2003)</ref>, provides a set of fine-grained pluggable hooks that are placed at various security-critical points across the kernel. System administrators can register customized permission checking callbacks to the LSM hooks so as to enforce diverse security policies. The latest Linux kernel v4.18.5 defines 190 LSM hooks. One common use of LSM is to implement Mandatory Access Control (MAC) <ref type="bibr" target="#b5">[8]</ref> in <ref type="bibr">Linux (e.g., SELinux [40, 41]</ref>, AppArmor <ref type="bibr" target="#b1">[3]</ref>). MAC enforces more strict and non-overridable access control policies, controlled by system administrators. For example, when a process tries to read the file path of a symbolic link, security_inode_readlink is invoked to check whether the process has read permission to the symlink file. The SELinux callback of this hook checks if a policy rule can grant this permission (e.g., allow domain_a type_b:lnk_file read). It is worth noting that the effectiveness of LSM and its MAC mechanisms highly depend on whether the hooks are placed correctly and soundly at all security-critical points. If a hook is missing at any critical point, there is no way for MAC to enforce a permission check.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Examples of Permission Check Errors</head><p>This section illustrates different kinds of permission check errors, found by PeX and confirmed by the Linux kernel developers. We refer to those functions, that validate whether a process (a user or a group) has proper permission to do certain operations, as permission checks. Similarly, we define privileged functions to be those functions which only a privileged process can access and thus require permission checks.   arg is user space controllable.      8) without any Capability check. These two functions share three similarities. First, both of them are reachable from the userspace by ioctl system call. Second, both call sg_scsi_ioctl with a userspace parameter, void __user *arg. Last, there is no preceding Capability check on all possible paths to them (though scsi_ioctl performs two checks).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Capability Permission Check Errors</head><p>The kernel is supposed to sanitize userspace inputs and check permissions to ensure that only users with appropriate permissions can conduct certain privileged operations. As SCSI (Small Computer System Interface) functions manipulate the hardware, they should be protected by Capabilities. At first glance, scsi_ioctl seems to be correctly protected (while scsi_cmd_ioctl misses two Capability checks).</p><p>However, delving into sg_scsi_ioctl ends up with a different conclusion. As shown in <ref type="figure" target="#fig_0">Figure 1c</ref>, sg_scsi_ioctl calls blk_verify_command, which in turn checks CAP_SYS_RAWIO. Considering all together, scsi_ioctl checks CAP_SYS_ADMIN once but CAP_SYS_RAWIO "twice", leading to a redundant permission check. On the other hand, scsi_cmd_ioctl checks      only CAP_SYS_RAWIO, resulting in a missing permission check for CAP_SYS_ADMIN. In particular, PeX detects this bug as an inconsistent permission check because the two paths disagree with each other, and further investigation shows that one is redundant and the other is missing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">LSM Permission Check Errors</head><p>The example of LSM permission check errors is related to how LSM hooks are instrumented for two different system calls readlinkat and ioctl. <ref type="figure" target="#fig_14">Figure 2a</ref> shows the LSM usage in the readlinkat system call. On its call path, vfs_readlink (Line 7) is protected by the LSM hook security_inode_readlink (Line 4) so that a LSM-based MAC mechanism, such as SELinux or AppArmor, can be realized to allow or deny the vfs_readlink operation. <ref type="figure" target="#fig_14">Figure 2b</ref> presents two sub-functions for the system call ioctl. Similar to the above case, ioctl calls ksys_ioctl, which includes its own LSM hook security_file_ioctl (Line 4) before do_vfs_ioctl (Line 6). This is proper design, and there is no problem so far. However, it turns out that there is a path from do_vfs_ioctl to xfs_readlink_by_handle (Line 10), which eventually calls the same privileged function vfs_readlink (see Line 7 in <ref type="figure" target="#fig_14">Figure 2a</ref> and Line 13 in <ref type="figure" target="#fig_14">Figure 2b</ref>  the 'ioctl allow rule' may exploit the ioctl system call to trigger the vfs_readlink operation, which should only be permitted by the different 'read allow rule'.</p><p>The above two Capability and LSM examples show how challenging it is to ensure correct permission checks. There are no tools available for kernel developers to rely on to figure out whether a particular function should be protected by a permission check; and, (if so) which permission checks should be used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Challenges</head><p>This section discusses two critical challenges in designing static analysis for detecting permission errors in Linux kernel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Indirect Call Analysis in Kernel</head><p>The first challenge lies in the frequent use of indirect calls in Linux kernel and the difficulties in statically analyzing them in a scalable and precise manner. To achieve a modular design, the kernel proposes a diverse set of abstraction layers that specify the common interfaces to different concrete implementations. For example, Virtual File System (VFS) <ref type="bibr" target="#b8">[12]</ref> abstracts a file system, thereby providing a unified and transparent way to access local (e.g., ext4) and network (e.g., nfs) storage devices. Under this kernel programming paradigm, an abstraction layer defines an interface as a set of indirect function pointers while a concrete module initializes these pointers with its own implementations. For example, as shown in <ref type="figure" target="#fig_15">Figure 3a</ref>, VFS abstracts all file system operations in a ker-nel interface struct file_operations that contains a set of function pointers for different file operations. When a file system is initialized, it initializes the VFS interface with the concrete function addresses of its own. For instance, <ref type="figure" target="#fig_15">Figure 3b</ref> shows that ext4 file system sets the write_iter function pointer to ext4_file_write_iter, while nfs sets the pointer to nfs_file_write.</p><p>However, kernel's large code base challenges the resolution of these numerous function pointers within kernel interfaces. For example, the kernel used in our evaluation (v4.18.5) includes 15.8M LOC, 247K functions, and 115K indirect callsites. This huge code base makes existing precise pointer analysis techniques <ref type="bibr">[23-25, 35, 43]</ref> unscalable. In fact, Static Value Flow (SVF) <ref type="bibr" target="#b39">[43]</ref>, i.e., the state-of-the-art analysis that uses flow-and context-sensitive value flow for high precision, failed to scale to the huge Linux kernel. That is because SVF is essentially a whole program analysis, and its indirect call resolution thus requires tracking all objects such as functions, variables, and so on, making the value flow analysis unscalable to the large-size Linux kernel. In our experiment of running SVF for the kernel on a machine with 256GB memory, SVF was crashed due to an out of memory error 1 .</p><p>Alternatively, one may opt for a simple "type-based" function pointer analysis, which would scale to Linux kernel. However, the type-based indirect call analysis would suffer from serious imprecision with too many false targets, because function pointers in the kernel often share the same type. For example, in <ref type="figure" target="#fig_15">Figure 3a</ref>, two function pointers read_iter and write_iter share the same function type. Type based pointer analysis will even link write_iter to ext4_file_read_iter falsely, which may lead to false permission check warnings.</p><p>PeX addresses this problem with a new kernel-interface aware indirect call analysis technique, detailed in §5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The Lack of Full Permission Checks, Privileged Functions, and Their Mappings</head><p>The second challenge lies in soundly enumerating a set of permission checks and inferring correct mappings between permission checks and privileged functions in Linux kernel.</p><p>Though some commonly used permission checks for DAC, Capabilities, and LSM are known <ref type="table" target="#tab_0">(Table 1)</ref>, kernel developers often devise custom permission checks (wrappers) that internally use basic permission checks. Unfortunately, the complete list of such permission checks has never been documented. For example, ns_capable is a commonly used permission check for Capabilities, but it calls ns_capable_common and security_capable in sequence. It is the last security_capable that performs the actual capability check. In other words, all the others are "wrappers" of the "basic" permission check security_capable. This example 1 SVF internally uses LLVM SparseVectors to save memory overhead by only storing the set bits. However, it still blows up both the memory and the computation time due to the expensive insert, expand and merge operations.</p><p>shows how hard it is for a permission check analysis tool to keep up with all permission checks.</p><p>To make matters worse, Linux kernel has no explicit documentation that specifies which privileged function should be protected by which permission checks. This is different from Android <ref type="bibr" target="#b0">[2]</ref>, which has been designed with the permission-based security model in mind from the beginning. Take the Android LocationManager class as an example; for the getLastKnownLocation method, the API document states explicitly that permission ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION is required <ref type="bibr" target="#b4">[7]</ref>.</p><p>Unfortunately, existing static permission error checking techniques are not readily applicable in order to address these problems. Automated LSM hook verification <ref type="bibr" target="#b40">[44]</ref> works only with clearly defined LSM hooks, which would miss many wrappers in the kernel setting. Many other tools require heavy manual efforts such as user-provided security rules <ref type="bibr" target="#b16">[20,</ref><ref type="bibr" target="#b52">56]</ref>, authorization constraints <ref type="bibr" target="#b29">[33]</ref>, annotation on sensitive objects <ref type="bibr" target="#b17">[21]</ref>. These manual processes are particularly errorprone when applied to huge Linux code base. Alternatively, some works such as <ref type="bibr" target="#b14">[18,</ref><ref type="bibr" target="#b28">32]</ref> rely on dynamic analysis. However, such run-time approaches may significantly limit the code coverage being analyzed, thereby missing real bugs.</p><p>Moreover, all of above existing works cannot detect permission checks soundly. Their inability to recognize permission checks or wrappers leads to missing privileged functions or false warnings for those that are indeed protected by wrappers. Since the huge Linux kernel code base makes it practically impossible to review them all manually, reasoning about the mapping is considered to be a daunting challenge.</p><p>In light of this, PeX presents a novel static analysis technique that takes as input a small set of known permission checks to identify their basic permission checks and leverages them as a basis for finding other permission check wrappers ( §6.2). In addition, PeX proposes a dominator analysis based solution to automatically infer the mappings between permission checks and privileged functions ( §6.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">KIRIN Indirect Call Analysis</head><p>PeX proposes a precise and scalable indirect call analysis technique, called KIRIN (Kernel InteRface based Indirect call aNalysis), on top of the LLVM <ref type="bibr" target="#b23">[27]</ref> framework. KIRIN is inspired by two key observations: (1) almost all (95%) indirect calls in the Linux kernel are originated from kernel interfaces ( §4.1) and (2) the type of a kernel interface is preserved both at its initialization site (where a function pointer is defined) and at the indirect callsite (where a function pointer is used) in LLVM IR. For example in <ref type="figure" target="#fig_15">Figure 3b</ref>, the kernel interface object ext4_file_operations of the type struct file_operations is statically initialized where ext4_file_write_iter is assigned to the field of <ref type="bibr">write_iter</ref>  infer that ext4_file_write_iter is one of potential call targets. Based on this observation, PeX first collects indirect call targets at kernel interface initialization sites ( §5.1) and then resolves them at indirect callsites ( §5.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Indirect Call Target Collection</head><p>In Linux kernel, a kernel interface is often defined in a C struct comprised of function pointers ( §4.1): e.g., struct file_operations in <ref type="figure" target="#fig_15">Figure 3a</ref>. Many kernel interfaces (C structs) are statically allocated and initialized as with ext4_file_operations and nfs_file_operations in <ref type="figure" target="#fig_15">Figure 3b</ref>. Some interfaces may be dynamically allocated and initialized at run time for reconfiguration.</p><p>For the former, KIRIN scans all Linux kernel code linearly to find all statically allocated and initialized struct objects with function pointer fields. Then, for each struct object, KIRIN keep tracks of which function address is assigned to which function pointers field using an offset as a key for the field. For instance, <ref type="figure" target="#fig_16">Figure 4a</ref> shows the LLVM IR of statically initialized ext4_file_operations. KIRIN finds that the kernel interface type is struct file_operations (Line 1), and ext4_file_write_iter is assigned to the 5th field write_iter (Line 7). Therefore, KIRIN figures out that write_iter may point to ext4_file_write_iter, not ext4_file_read_iter (even though they have the same function type).</p><p>For the rest dynamically initialized kernel interfaces, KIRIN performs a data flow analysis to collect any assignment of a function address to the function pointer inside a kernel interface. KIRIN's field-sensitive analysis allows the collected targets to be associated with the individual field of a kernel interface. 1 struct usb_driver * driver = container_of(intf-&gt;dev.driver, struct usb_driver, drvwrap.driver);</p><p>,! ,! 2 retval = driver-&gt;unlocked_ioctl(intf, ctl-&gt;ioctl_code, buf);</p><p>,!</p><p>(a) C code of a container_of usage, followed by an indirect call.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Indirect Callsite Resolution</head><p>KIRIN stores the result of the above first pass in a key-value map data structure in which the key is a pair of kernel interface type and an offset (a field), and the value is a set of call targets. At each indirect callsite, KIRIN retrieves the type of a kernel interface and the offset from LLVM IR, looks up the map using them as a key, and figures out the matched call targets. For example, <ref type="figure" target="#fig_16">Figure 4b</ref> shows the LLVM IR snippet in which an indirect call file→f_op→write_iter is made inside of vfs_write. When an indirect call is made (Line 4), KIRIN finds that the kernel interface type is struct file_operations (Line 1) and the offset is 5 (Line 2). In this way, KIRIN reports that ext4_file_write_iter (assigned at Line 7 in <ref type="figure" target="#fig_16">Figure 4a</ref>) is one of potential call targets that are indirectly called by dereferencing write_iter. When applying KIRIN to Linux kernel, we found in certain callsites, the kernel interface type is not presented in the LLVM IR, making their resolution impossible. For example, the macro container_of is commonly used in order to get the starting address of a struct object by using a pointer to its own member field. <ref type="figure" target="#fig_18">Figure 5a</ref> shows an example of using container_of (Line 1). It calculates the starting address of usb_driver through its own member drvwrap.driver. Based on the address, the code at Line 2 makes an indirect call by using a function pointer unlocked_ioctl that is another member of the struct usb_driver object. <ref type="figure" target="#fig_18">Figure 5b</ref> shows the original macro container_of (Lines 1-3) and resulting LLVM IR (Line 4). The problem of this macro is that it involves a pointer manipulation, the LLVM IR of which voids the struct type information, i.e., the second argument of the macro. To solve this problem, KIRIN redefines container_of in a way that the struct type is preserved in the LLVM IR (on which KIRIN works), as in <ref type="figure" target="#fig_0">Fig- ure 5c (Lines 1-5</ref>). This adds back the kernel interface type struct.usb_driver in the LLVM IR (Line 6), thereby enabling KIRIN to infer the correct type of driver and resolve the targets for unlocked_ioctl.</p><p>Our experiment ( §7.2) shows that KIRIN resolves 92% of total indirect callsites for allyesconfig. PeX constructs a more sound (less missing edges) and precise (less false edges) call graph than other existing workarounds (e.g., <ref type="bibr" target="#b18">[22]</ref>). <ref type="figure">Figure 6</ref> shows the architecture of PeX. It takes as input kernel source code (in the LLVM bitcode format) and common permission checks <ref type="table" target="#tab_0">(Table 1)</ref>, analyzes and reports all detected permission check errors, including missing, inconsistent, and redundant permission checks. In addition, PeX produces the mapping of permission checks and privileged functions, which has not been formally documented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Design of PeX</head><p>At a high-level, PeX first resolves indirect calls with our new technique called KIRIN ( §5). Next, PeX builds an augmented call graph-in which indirect callsites are connected to possible targets-and cuts out only the portion reachable from user space ( §6.1). Based on the partitioned call graph, PeX then generates the interprocedural control flow graph (ICFG) where each callsite is connected to the entry and the exit of the callee <ref type="bibr" target="#b13">[17]</ref>. Then, starting from a small set of (userprovided) permission checks, PeX automatically detects their wrappers ( §6.2). After that, for a given permission check, PeX identifies its potentially privileged functions on top of the ICFG ( §6.3), followed by a heuristic-based filter to prune obviously non-privileged functions ( §6.4). Finally, for each privileged function, PeX examines all user space reachable paths to it to detect any permission checks error on the paths ( §6.5). The following section describes these steps in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Call Graph Generation and Partition</head><p>PeX generates the call graph leveraging the result of KIRIN ( §5), and then partitions it into two groups.</p><p>User Space Reachable Functions: Starting from functions with the common prefix SyS_ (indicating system call entry points), PeX traverses the call graph, marks all visited functions, and treats them as user space reachable functions. The user reachable functions in this partition are investigated for possible permission check errors.</p><p>Kernel Initialization Functions: Functions that are used only during booting are collected to detect redundant checks. The Linux kernel boots from the start_kernel function, and calls a list of functions with the common prefix __init. PeX performs multiple call graph traversals starting from start_kernel and each of the __init functions to collect them.</p><p>Other functions such as IRQ handlers and kernel thread functions are not used in later analysis since they cannot be directly called from user space. The partitioned call graph serves as a basis for building an interprocedural control flow graph (ICFG) <ref type="bibr" target="#b27">[31]</ref> used in the inference of the mapping between permission checks and privileged functions ( §6.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Permission Check Wrapper Detection</head><p>Sound and precise detection of permission check errors requires a complete list of permission checks, but they are not readily available ( §4.2). One may name some commonly used permission checks, as in <ref type="table" target="#tab_0">Table 1</ref>. However, they are often the wrapper of basic permission checks, which actually perform the low-level access control, and even worse there could be other wrappers of the wrapper.</p><p>PeX solves this by automating the process of identifying all permission checks including wrappers. PeX takes an incomplete list of user-provided permission checks as input. Starting from them, PeX detects basic permission checks, by performing the forward call graph slicing <ref type="bibr" target="#b22">[26,</ref><ref type="bibr" target="#b33">37,</ref><ref type="bibr" target="#b41">45]</ref> over the augmented call graph. For a given permission check function, PeX searches all call instructions inside the function for the one that passes an argument of the function to the callee. In other words, PeX identifies the callees of the permission check function which take its actual parameter as their own formal parameter. Similarly, PeX then conducts backward call graph slicing <ref type="bibr" target="#b22">[26,</ref><ref type="bibr" target="#b33">37,</ref><ref type="bibr" target="#b41">45]</ref> from these basic permission checks to detect the list of their wrappers. PeX refers to only those callers that pass permission parameters as wrappers, excluding other callers just using the permission checks. <ref type="figure" target="#fig_19">Figure 7</ref> shows an example of the permission check wrapper detection. Given a known permission check ns_capable (Lines 10-13), PeX first finds security_capable (Line 4) as a basic permission check, and then based on it, PeX detects another permission check wrapper has_ns_capability (Lines <ref type="bibr" target="#b10">[14]</ref><ref type="bibr" target="#b11">[15]</ref><ref type="bibr" target="#b12">[16]</ref><ref type="bibr" target="#b13">[17]</ref><ref type="bibr" target="#b14">[18]</ref><ref type="bibr" target="#b15">[19]</ref><ref type="bibr" target="#b16">[20]</ref>. Note that the parameter cap is passed from both the parents ns_capable_common and has_ns_capability to the child security_capable; and the result of security_capable is returned to them. Our evaluation ( §7.3) shows that based on 196 permission checks in <ref type="table" target="#tab_0">Table 1</ref>, PeX detects 88 wrappers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Privileged Function Detection</head><p>It is important to understand the mappings between permission checks and privileged functions for effective detection of any permission check errors therein. However, the lack of clear mapping in Linux kernel complicates the detection of permission check errors ( §4.2).</p><p>To address this problem, PeX leverages an interprocedural dominator analysis <ref type="bibr" target="#b27">[31]</ref> that can automatically identify the privileged functions protected by a given permission check. PeX conservatively treats all targets (callees) of those call instructions, that are dominated by each permission check ( §6.2) on top of the ICFG ( §6.1), as its potential privileged functions. The rationale behind the dominator analysis is based on the following observation: since there is no single path that allows the dominated call instruction to be reached without visiting the dominator (i.e., the permission check),  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Privileged Function Detection</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>INPUT:</head><p>pc f uncs -all permission checking functions OUTPUT:</p><p>pv f uncs -privileged functions 1: procedure PRIVILEGED FUNCTION DETECTION 2:</p><p>for f ← pc f uncs do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3:</head><p>for u ← User( f ) do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4:</head><p>CallInst ← CallInstDominatedBy(u) Inter-procedural analysis, for full program path</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5:</head><p>callee ← getCallee(CallInst)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6:</head><p>pv f uncs.insert(callee)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7:</head><p>end for 8: end for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>9:</head><p>return pv f uncs 10: end procedure the callee is likely to be the one that should be protected by the check on all paths 2 .</p><p>Algorithm 1 shows how PeX uses the dominator analysis to find potential privileged functions pvfuncs for a given list of permission check functions pcfuncs. For each permission check function f (Line 2), PeX finds all users of f, i.e., the callsite invoking f (Line 3). For each user (callsite) u, PeX performs interprocedural dominator analysis over the ICFG to find all dominated call instructions (Line 4). All their callees are then added to pvfuncs (Lines 5-6).</p><p>Note that the call graph generated by KIRIN ( §5) has resolved most of the indirect calls, which allows PeX to perform-on top of the resulting ICFG-more sound privileged function detection. For example, our experiment ( §7.3) shows that KIRIN can identify ecryptfs_setxattr (reachable via indirect calls over the ICFG) as a privileged function and detect its missing permission check bug <ref type="table" target="#tab_11">(Table 6</ref>, LSM-17). Note that if some other unsound workaround such as <ref type="bibr" target="#b18">[22]</ref> had been used, this bug could not have been detected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Non-privileged Function Filter</head><p>The conservative approach in §6.3 may lead to too many potential privileged functions. In this step, PeX applies heuristicbased filters to prune out false privileged functions. In the current prototype, the filter contains a set of kernel library functions which are not privileged functions, e.g., kmalloc, strcmp, kstrtoint. Though PeX is currently designed to avoid false negatives (and thus leverages a small set of library filters only), one can add more aggressive filters to purge more false privileged functions. With releasing PeX, we expect a good opportunity for the kernel development community to contribute to the design of non-privileged function filters where domain knowledge is helpful.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Permission Check Error Detection</head><p>This last step is validating the use of privileged functions to detect any potential permission check errors. For a given mapping between a permission check and a privileged function, PeX performs a backward traversal of the ICFG, starting from the privileged functions with the corresponding permission check in mind. Note that PeX validates every possible path to each privileged function of interest.</p><p>Algorithm 2 shows PeX's permission check error detection algorithm. Recall that PeX treats user reachable kernel functions and kernel initialization functions separately and detects different forms of errors ( §6.1). Lines 2-12 shows how PeX detects missing, redundant, and inconsistent checks in user reachable kernel functions. For each privileged function f (Line 5) in a mapping, PeX finds all possible paths allpath from user entry points to that privileged function f over the ICFG (Line 6). Line 7-18 checks each path p for the preceding permission check function, the lack of which should be reported as a bug. If the call to the privileged function (pvcall) is not preceded by the corresponding permission check func- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>20:</head><p>end for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>21:</head><p>for f ← kinit f uncs do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>22:</head><p>if f uses any pc f uncs then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>23:</head><p>report <ref type="formula">(</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Implementation and Evaluation</head><p>PeX was implemented using LLVM <ref type="bibr" target="#b23">[27]</ref>/Clang-6.0. It contains about 7K lines of C/C++ code. Clang was modified to preserve the kernel interface type at allocation/initialization sites by using an identified struct type instead of using unnamed literal struct type. We also automated the generation of the single-file whole vmlinux LLVM bitcode vmlinux.bc using wllvm <ref type="bibr" target="#b9">[13]</ref>. This avoids building each kernel module separately or changing kernel build infrastructures, as observed in prior kernel static analysis works <ref type="bibr" target="#b18">[22,</ref><ref type="bibr" target="#b45">49]</ref>. We evaluated PeX on the latest stable Linux kernel v4.18.5. In summary, KIRIN resolves 86%-92% of indirect callsites depending on its compilation configurations. PeX reported 36 permission check errors warnings to the Linux community, 14 of which have been confirmed as real bugs.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Evaluation of KIRIN</head><p>We compared the effectiveness and efficiency of KIRIN with type-based approach and SVF-based K-Miner approach. K-Miner <ref type="bibr" target="#b18">[22]</ref> works around the scalability problem in SVF by analyzing the kernel on a per system call basis, rather than taking the entire kernel code for analysis. K-Miner generates a (small-size) partition of kernel code which can be reached from a given system call, and (unsoundly) applies SVF for that partition. For comparison, we took K-Miner's implementation from the github <ref type="bibr" target="#b3">[6]</ref> and added the logic to count the number of resolved indirect callsites and the average number of targets per callsite. As K-Miner was originally built on LLVM/Clang-3.8.1, we recompiled the same kernel v4.18.5 using wllvm with the same kernel configurations. <ref type="table" target="#tab_7">Table 3</ref> summaries evaluation results of KIRIN, comparing it to the type-based approach and K-Miner approach in terms of the percentage of indirect callsite (ICS) resolved, the average number of targets per ICS, and the total analysis time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Resolution Rate</head><p>For K-Miner, we observe somewhat surprising results: it resolves only 1% of all indirect callsites. After further inves-tigation, we noticed that SVF runs on each partition whose code base is smaller than the whole kernel, its analysis scope is significantly limited and unable to resolve function pointers in other partitions, leading to the poor resolution rate.</p><p>Besides, we found out that K-Miner does not work for allyesconfig which contains a much larger code base than defconfig. Note that K-Miner evaluated its approach only for defconfig in the original paper <ref type="bibr" target="#b18">[22]</ref>. The K-Miner approach turns out to be not scalable to handle allyesconfig which ends up encountering out of memory error even for analyzing a single system call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Resolved Average Targets</head><p>For KIRIN, the number of average indirect call targets per resolved indirect callsite is much smaller than that of the type-based approach as shown in the second row of <ref type="table" target="#tab_7">Table 3</ref>. The reason is that the type-based approach classifies all functions (not only address-taken functions) into different sets based on the function type. This implies that all functions in the set are regarded as possible call targets of that function pointer. For example, as shown in <ref type="figure" target="#fig_15">Figure 3a</ref>, two functions ext4_file_read_iter and ext4_file_write_iter share the same type. As a result, the type-based approach incorrectly identifies both functions as possible call targets of the function pointer f_ops→write_iter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.3">Analysis Time</head><p>The total analysis times of each ICS resolution approach are shown in the last row of <ref type="table" target="#tab_7">Table 3</ref>. As expected, the typebased approach is the fastest, finishing analysis in 1 minute for both configurations. KIRIN runs slower than the typebased approach. However, the analysis time of KIRIN (≈1 minute) is comparable to that of the type-based approach for defconfig, while KIRIN takes 6.6 minutes for allyesconfig. For a fair comparison with K-Miner, care must be taken when we collect its indirect call analysis time. For a given system call, we measured K-Miner's running time from the beginning until it produces the SVF point-to result, which does not include the later bug detection time. To obtain the total analysis time of K-Miner, we summed up the running times of all system calls. The result shows that SVF based KMiner takes about 9,869 minutes to finish analyzing all system calls of defconfig, which is much slower than KIRIN's. Given the small number of input DAC, CAP, and LSM permission checks (3, 3, and 190 each), PeX's permission check  detection ( §6.2) was able to identify 19, 16 and 53 permission check wrappers. For example, PeX detects wrappers such as nfs_permission and may_open for DAC; sk_net_capable and netlink_capable for Capabilities; and key_task_permission and __ptrace_may_access for LSM. <ref type="table" target="#tab_8">Table 4</ref> also shows the number of potentially privileged functions detected by PeX ( §6.3) and the number of remaining privileged functions after kernel library filtering ( §6.4). We found that there are typically 1-to-1 or 2-to-1 mapping between permission checks and privileged functions. Overall, PeX reports 221, 850, and 1017 warnings (grouped by privileged functions) for DAC, CAP, and LSM, respectively. <ref type="table" target="#tab_11">Table 6</ref> shows the list of 36 bugs we reported, 14 of which have been confirmed by Linux kernel developers. Kernel developers ignored some bugs and decided not to make changes because they believe that the bugs are not exploitable. We discuss them in detail in §7.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">PeX Result</head><p>Comparison. To highlight the effectiveness of KIRIN, we repeated the end-to-end PeX analysis using type-based (PeX+TYPE) and K-Miner-style (PeX+KM) indirect call analyses. <ref type="table" target="#tab_10">Table 5</ref> shows the resulting number of warnings and detected bugs when the 36 bugs-shown in <ref type="table" target="#tab_11">Table 6</ref>-are used as an oracle for false negative comparison.</p><p>For allyesconfig, PeX+TYPE and PeX+KM could not complete the analysis within the 12-hour experiment limit. PeX+TYPE generated too many (false) edges in ICFG and suffered from path explosion during the last phase of PeX analysis; only 19 bugs were reported before the timeout. In the mean time, PeX+KM timed out on an earlier pointer analysis phase, thereby failing to report any bug.</p><p>When defconfig is used for comparison, PeX+TYPE and PeX+KM were able to complete the analysis. In this setting, PeX+KIRIN (original) and PeX+TYPE both report 21 bugs (a subset of 36 bugs detected with allyesconfig). Though PeX+TYPE can capture them all (as type-based analysis is sound yet imprecise), it generates up to 3x more warnings, placing a high burden on the users side for their manual review. On the other hand, as an unsound solution, PeX+KM produces a limited number of warnings, resulting in the detection of only 6 bugs missing the rest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Manual Review of Warnings</head><p>The manual review process of reported warnings is to determine whether a privileged function identified by PeX ( §6.3) is a true privileged function or not. As long as one can confirm that a function is indeed privileged, reported warnings regarding its missing, inconsistent, and redundant permission checks should be true positives from PeX's point of view.</p><p>Though kernel developers with domain knowledge may be able to discern them with no complication, we (as a thirdparty) try to understand whether a given function can be used to access critical resources (e.g., device, file system, etc.). As a result, we conservatively reported 36 bug warnings to the community; we suspect that there could be more true warnings missed due to our lack of domain knowledge. We plan to release PeX and the list of potential privileged functions, hoping kernel developers will contribute to identify privileged functions and fix more true permission errors.</p><p>Certain static paths reported by PeX may not be feasible dynamically during program execution, resulting in false positives. One may devise a solution solving path constraints as in symbolic execution engines <ref type="bibr" target="#b12">[16]</ref> to address this problem, PeX currently does not do so. <ref type="figure" target="#fig_14">Figure 2b</ref> is one of the confirmed missing LSM checks (LSM-21). We discuss two more confirmed cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Discussion of Security Bug Findings</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5.1">Missing Check</head><p>The CAP-4 missing check in kernel random device driver is particularly critical and triggered active discussion in the kernel developer community (including Torvalds). Random number generator serves as the foundation of many cryptography libraries including OpenSSL, and thus the quality of the random number is very critical. This security bug allows attackers to manipulate entropy pool, which can potentially corrupt many applications using cryptography libraries. Specifically, a problematic path starts from evdev_write and reaches the privileged function credit_entropy_bits, which can control the entropy in the entropy pool, while bypassing the required CAP_SYS_ADMIN permission check.</p><p>The LSM-21 missing check in xfs_file_ioctl led to another interesting discussion among kernel developers <ref type="bibr" target="#b6">[9]</ref>. With this interface, a userspace program may perform lowlevel file system operations, but security_inode_read_link LSM hook was missing. An adversary could exploit this interface and gain access to the whole file system that is not allowed by LSM policy. Interestingly, however, the privileged function performed CAP_SYS_ADMIN Capability permission check. This created disagreement between kernel developers: one group argues that the LSM hook is necessary, while another thinks that CAP_SYS_ADMIN is sufficient. We agree with the former because LSM is designed to limit the damage of a compromised process to the system, even the ones of root user <ref type="bibr" target="#b36">[40]</ref>. We believe that LSM permission checks should still be enforced as always for better security even when the current user is root.</p><p>Kernel developers decided not to fix 9 of our reports because they believe these bugs are not exploitable. As discussed earlier, PeX in the current form neither validates if a suspicious static path is dynamically reachable, nor generates a concrete exploit to demonstrate the security issue; we believe both are good future works. Nonetheless, we have one complaint to share.</p><p>For the LSM-19 and LSM-20 cases, PeX found that the LSM hooks security_kernel_read_file and security_kernel_post_read_file were used to protect the privileged functions kernel_read_file and kernel_post_read_file in some program paths. We reported missing LSM hooks in load_elf_binary and load_elf_library for these privileged functions. However, the kernel developers responded that those hooks are used to monitor loading firmware/kernel modules only (not other files), and thus no patch is required. Here, the implication we found is three-fold. First, the permission check names are ambiguous and misleading. Second, we were not able to find any documentation of such LSM specification regarding the protection of firmware/kernel modules. Last, PeX actually found a counter-example in IMA where the same checks are indeed used for loading other files (neither firmware nor kernel modules). Consequently, we suggest changing the function name and documenting the clear intention to avoid any confusion and to prevent system administrators from creating an LSM policy that does not work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5.2">Inconsistent Check</head><p>The CAP-13 inconsistent check has been discussed in <ref type="figure">Fig</ref> Upon further investigation, we were interested in learning the practices in using multiple capabilities together. scsi_ioctl in <ref type="figure" target="#fig_0">Figure 1a</ref> checks both CAP_SYS_ADMIN and CAP_SYS_RAWIO. However, in a different network subsystem (not shown), we found that too_many_unix_fds performs a weaker permission check with the CAP_SYS_ADMIN or CAP_SYS_RAWIO condition. We believe this OR-based weaker check is not a good practice because this in effect makes CAP_SYS_ADMIN too powerful (like root), diminishing the ben- efit of fine-grained capability-based access control. The CAP-14 and CAP-15 inconsistent error reports were acknowledged but ignored by the kernel developers for the following reason. For the same privileged function prctl_set_mm_exe_file, which is used to set an executable file, PeX discovered one case requiring CAP_SYS_RESOURCE in user namespace, and another case checking CAP_SYS_ADMIN in init namespace. Kernel developers responded that each case is fine by design for that specific context. PeX does not consider the precise context in which prctl_set_mm_exe_file is used (similar to aforementioned security_kernel_read_file used for loading kernel modules), leading to an imprecise report, but we believe that both CAP-14 and CAP-15 are worthwhile for further investigation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5.3">Redundant Check</head><p>A redundant check occurs in two forms. First, for userreachable functions, it happens when a privileged function is covered by the same permission checks multiple times. We reported three cases. The CAP-16 case was discussed in <ref type="figure" target="#fig_0">Fig- ures 1a and 1c</ref> with two CAP_SYS_RAWIO checks, which was ignored by kernel developers. On the other hand, for the LSM-35 and LSM-36 cases found in the ocfs2 file system, the other kernel developer group confirmed and promised to fix the bugs. Second, any permission check in kernel-initialization functions is marked as redundant because the boot thread is executed under root. PeX detected tens of such cases, but we did not report them as they are less critical.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related Work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Hook Verification and Placement</head><p>There is a series of studies on checking kernel LSM hooks. Automated LSM hook verification work <ref type="bibr" target="#b52">[56]</ref> verifies the complete mediation of LSM hooks relying manually specified security rules. While <ref type="bibr" target="#b16">[20]</ref> automates LSM hook placements utilizing manually written specification of security sensitive operations. However, required manual processes are errorprone when applied to huge Linux code base. Edwards et al. <ref type="bibr" target="#b14">[18]</ref> proposed to use dynamic analysis to detect LSM hook inconsistencies. While PeX is using static analysis, can achieve better code coverage.</p><p>AutoISES <ref type="bibr" target="#b40">[44]</ref> is the most closely related work to PeX. AutoISES regards data structures, such as the structure fields and global variables, as privileged, applies static analysis to extract security check usage patterns, and validates the protections to these data structures. The difference between AutoISES and PeX is three-fold. First, PeX is privileged function oriented while AutoISES is more like data structure oriented.</p><p>Second, AutoISES is designed for LSM only, whose permission checks (hooks) are clearly defined, and therefore it is not applicable to DAC and Capabilities due to their various permission check wrappers. In contrast, PeX works for all three types of permission checks. Third, AutoISES uses typebased pointer analysis to resolve indirect calls, while PeX uses KIRIN to resolve indirect calls in a more precise manner.</p><p>There are also works <ref type="bibr" target="#b17">[21,</ref><ref type="bibr" target="#b28">32,</ref><ref type="bibr" target="#b29">33]</ref> that extend authorization hook analysis to user space programs, including X server and postgresql. However, their approaches canot be applied to the huge kernel scale. Moreover, all of above works either do not analyze indirect calls at all, or apply over approximate indirect call analysis techniques, such as type-based approach or field insensitive approach. To the contrary, PeX uses KIRIN, a precise and scalable indirect call analysis technique, which can also benefit these works by finding more accurate indirect call targets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Kernel Static Analysis Tools</head><p>Coccinelle <ref type="bibr" target="#b30">[34]</ref> is a tool that detects a bug of pre-defined pattern based on text pattern matching on the symbolic representation of bug cases. This is basically intra-procedural analysis. Building upon Coccinelle, <ref type="bibr">Wang et al. proposed</ref> another pattern matching based static tool which detects potential double-fetch vulnerabilities in the Linux kernel <ref type="bibr" target="#b44">[48]</ref>.</p><p>Sparse <ref type="bibr">[11]</ref> is designed to detect the problematic use of pointers belonging to different address space (kernel space or userspace). Later, Sparse was used to build a static analysis framework called Smatch <ref type="bibr" target="#b7">[10]</ref> for detecting different sorts of kernel bugs. However, Smatch is also based on intraprocedural analysis, thus it can only find shallow bugs. <ref type="bibr">Double-Fetch [52]</ref>, Check-it-again <ref type="bibr" target="#b45">[49]</ref> focus on detecting time of check to time of use (TOCTTOU) bugs. Dr. Checker <ref type="bibr" target="#b25">[29]</ref> is designed for analyzing Linux kernel drivers. It adopts the modular design, allowing new bug detectors to be plug-in easily. KINT <ref type="bibr" target="#b46">[50]</ref> applies taint analysis to detect integer errors in Linux kernel while UniSan <ref type="bibr" target="#b24">[28]</ref> leverages the same analysis to detect uninitialized kernel memory leakages to the userspace. Chucky <ref type="bibr" target="#b49">[53]</ref> also uses a taint analysis to analyze missing checks in different sources in userspace programs and Linux kernel. However, Chucky can handle only kernel file system code due to the lack of pointer analysis. Note that to resolve indirect call targets, all these works leverage a type-based approach, which is not as accurate as KIRIN, thus suffering from false positives.</p><p>MECA <ref type="bibr" target="#b50">[54]</ref> is an annotation based static analysis framework, and it can detect security rule violations in Linux.</p><p>APISan <ref type="bibr" target="#b51">[55]</ref> aims at finding API misuse. It figures out the right API usage through the analysis of existing code base and performs intra-procedural analysis to find bugs. To achieve the former, APISan relies on relaxed symbolic execution which is complementary to the techniques used in PeX.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Permission Check Analysis Tools</head><p>Engler et al. propose to use programmer beliefs to automatically extract checking information from the source code. They apply the checking information to detect missing checks <ref type="bibr" target="#b15">[19]</ref>. RoleCast <ref type="bibr" target="#b38">[42]</ref> leverages software engineering patterns to detect missing security checks in web applications. TESLA <ref type="bibr" target="#b10">[14]</ref> implements temporal assertions based on LLVM instrument, in which the FreeBSD hooks are checked by inserted assertions dynamically. Different from TESLA, PeX uses KIRIN to analyze jump targets of all kernel function pointers statically, achieving better resolution rate and code coverage. JIGSAW <ref type="bibr" target="#b43">[47]</ref> is a system that can automatically derive programmer expectations on resources access and enforce it on the deployment. It is designed for analyzing userspace programs, cannot be applied to kernel directly.</p><p>JUXTA <ref type="bibr" target="#b26">[30]</ref> is a tool designed for detecting semantic bugs in filesystem while PScout <ref type="bibr" target="#b11">[15]</ref> is a static analysis tool for validating Android permission checking mechanisms. <ref type="bibr">Kratos [39]</ref> is a static security check framework designed for the Android framework. It builds a call graph using LLVM and tries to discover inconsistent check paths in the framework. However, Android has well-documented permission check specifications <ref type="bibr" target="#b0">[2]</ref>, i.e., privileged functions and the permission required for them are both clearly defined. In contrast, the Linux kernel has no such documentation, which makes it impossible to apply PScout and Kratos to Linux kernel permission checks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion</head><p>This paper presents PeX, a static permission check analysis framework for Linux kernel, which can automatically infer mappings between permission checks and privileged functions as well as detect missing, inconsistent, and redundant permission checks for any privileged functions. PeX relies on KIRIN, our novel call graph analysis based on kernel interfaces, to resolve indirect calls precisely and efficiently.</p><p>We evaluated both KIRIN and PeX for the latest stable Linux kernel v4.18.5. The experiments show that KIRIN can resolve 86%-92% of all indirect callsites in the kernel within 7 minutes. In particular, PeX reported 36 permission check bugs of DAC, Capabilities, and LSM, 14 of which have already been confirmed by the kernel developers. PeX source code is available at https://github.com/lzto/pex, along with the identified mapping between permission checks and privileged functions. We believe that such a mapping allows kernel developers to validate their code with PeX and encourages them to contribute to PeX by refining the mapping with their domain knowledge.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 shows</head><label>1</label><figDesc>Figure 1 shows real code snippets of Capability permission check errors in Linux kernel v4.18.5. Figure 1a shows the kernel function scsi_ioctl, in which sg_scsi_ioctl (Line 7) is safeguarded by two Capability checks, CAP_SYS_ADMIN and CAP_SYS_RAWIO (Line 5). To the contrary, scsi_cmd_ioctl in Figure 1b calls the same function sg_scsi_ioctl (Line</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>sg_scsi_ioctl (Line 8) is called without capability checks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>15 return -EPERM; 16 } (c) sg_scsi_ioctl calls blk_verify_command, which checks CAP_SYS_RAWIO capability.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Capability check errors discovered by PeX.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>1</head><label>1</label><figDesc>static int do_readlinkat(int dfd, const char __user * pathname, char __user * buf, int bufsiz) → 2 { 3 ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Both pathname and buf (Line 1 and Line 7) are user controllable. 1 int ksys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg) → 2 { 3 ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>13 error = vfs_readlink(dentry, hreq-&gt;ohandle, olen); 14 ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>15 }</head><label>15</label><figDesc>(b) Kernel LSM usage in system call ioctl. It calls security_file_ioctl (Line 4) to protect do_vfs_ioctl (Line 6). hreq-&gt;ohandle and olen are also user controllable.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: LSM check errors discovered by PeX.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Indirect call examples via the VFS kernel interface.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Indirect callsite resolution for vfs_write.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>1</head><label>1</label><figDesc>#define container_of(ptr, type, member) ({ 2 void * __mptr = (void * )(ptr); 3 ((type * )(__mptr -offsetof(type, member))); }) \ \ 4 %unlocked_ioctl = getelementptr inbounds i8 * , i8 ** %add.ptr76, i64 3 ,! (b) Original container_of and the LLVM IR for the callsite. 1 #define container_of(ptr, type, member) ({ 2 type * __res; 3 void * __mptr = ((void * )((void * )(ptr) - offsetof(type, member))); ,! 4 memcpy(&amp;__res, &amp;__mptr, sizeof(void * ));(c) Modified container_of and the LLVM IR for the callsite.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Fixing container_of missing struct type problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Permission check wrapper examples.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>- ure 1 .</head><label>1</label><figDesc>One program path in Figures 1a and 1c has two CAP_SYS_RAWIO checks and one CAP_SYS_ADMIN check, while another path in Figures 1b and 1c has only one CAP_SYS_ADMIN check. PeX detects this bug as an inconsistent check, but from the viewpoint of correction, which requires adding CAP_SYS_RAWIO, this may also be viewed as a missing check. There is a separate redundant check error in CAP_SYS_RAWIO.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><head>Table 1 : Commonly used permission checks in Linux.</head><label>1</label><figDesc></figDesc><table>Type 
Total # Permission Checks 
DAC 
3 
generic_permission, sb_permission, inode_permission 
Capabilities 3 
capable, ns_capable, avc_has_perm_noaudit 
LSM 
190 
security_inode_readlinkat, security_file_ioctl, etc.. 

• New Techniques: We proposed and implemented PeX, a 
static permission check analysis framework for Linux ker-
nel. We also developed new techniques that can perform 
scalable indirect call analysis and automate the process of 
identifying permission checks and privileged functions. 
• Practical Impacts: We analyzed DAC, Capabilities, and 
LSM permission checks in the latest Linux kernel v4.18.5 
using PeX, and discovered 36 new permission check bugs, 
14 of which have been confirmed by kernel developers. 
• Community Contributions: We will release PeX as an 
open source project, along with the identified mapping be-
tween permission checks and privileged functions. This 
will allow kernel developers to validate their codes with 
PeX, and to contribute to PeX by refining the mappings 
with their own domain knowledge. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Algorithm 2 Permission Check Error Detection</head><label>2</label><figDesc></figDesc><table>INPUT: 
pc − pv -permission check function to privileged function mapping 
pc f uncs -all permission check functions 
kinit f uncs -kernel init functions 

1: procedure PERMISSION CHECK ERROR DETECTION 
2: 

for pair ← pc − pv do 

3: 

pv f uncs ← pair.pv 
privileged functions 

4: 

pc f unc ← pair.pc 
permission check functions 

5: 

for f ← pv f uncs do 

6: 

all path ← getAllPathUseFunc( f ) get all user reachable paths that 
call the privileged function f 

7: 

for p ← all path do 

8: 

pvcall ← PrivilegeFunctionCallInPath(p) 

9: 

if pvcall not Preceded by pc f unc then 

10: 

if pvcall not Preceded by any pc f uncs then 

11: 

report(p) 
Report missing checks 

12: 

else 

13: 

report(p) 
Report inconsistent check 

14: 

end if 

15: 

else if pvcall Preceded by multiple same pc f unc then 

16: 

report(p) 
Report redundant checks 

17: 

end if 

18: 

end for 

19: 

end for 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Table 2 : Input Statistics for Kernel v4.18.5.</head><label>2</label><figDesc></figDesc><table>defconfig allyesconfig 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Indirect Call Pointer Analysis. 

defconfig 
allyesconfig 
KIRIN TYPE KM 
KIRIN TYPE KM 
% of ICS resolved 
86 
100 
1 
92 
100 
na 
# of avg target 
3.6 
10K 
3.6 
6.2 
81K 
na 
analysis time (min) 
1 
1 
9,869 
6.6 
1 
na 

7.1 Evaluation Methodology 

We evaluated PeX with two different kernel configurations: (1) 

defconfig, the (commonly-used) default configuration, and 
(2) allyesconfig with all non-conflict configuration options 
enabled. The use of allyesconfig not only stress-tests PeX 
(including KIRIN) with a larger code base than defconfig, 
but also covers the majority of kernel code, allowing PeX to 
detect more bugs. In addition, we used 3 DAC, 3 Capabilities, 
and 190 LSM permission checks(Table 1) as input permission 
checks, from which PeX finds other wrappers. For the non-
privileged function filter, we collected 1827 library functions 
from lib directory in the kernel source code. All experiments 
were carried out on a machine running Ubuntu 16.04 with 
two Intel Xeon E5-2650 2.20GHz CPU and 256GB DRAM. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>Table 4 summarizes</head><label>4</label><figDesc>PeX's intermediate program analyses. As allyesconfig subsumes defconfig in static analysis, we focus on discussing allyesconfig results here. Overall, PeX finishes all analyses within a few hours and reports about two thousand groups of warnings, which are classified by privileged functions. One may implement a multi-threaded version of PeX to further reduce the analysis time.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="true"><head>Table 4 : PeX Results.</head><label>4</label><figDesc></figDesc><table>defconfig 
allyesconfig 
DAC CAP LSM DAC CAP LSM 
# of input checks 
3 
3 
190 
3 
3 
190 
# of detected wrappers 
11 
13 
34 
19 
16 
53 
# of priv func detected 
174 
869 
2030 
631 
3770 10915 
# of priv func after filter 
116 
582 
1635 
537 
3245 10260 
# of warnings grouped 
by priv func 
72 
210 
853 
221 
850 
1017 

total time (min) 
6 
8 
11 
83 
247 
169 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>Table 5 :</head><label>5</label><figDesc></figDesc><table>Comparison of PeX warnings when used with differ-
ent indirect call analyses. 

defconfig 
allyesconfig 
DAC CAP LSM Bugs DAC CAP LSM Bugs 
KIRIN 
72 
210 
853 
21 
221 
850 
1017 36 
TYPE 
218 
348 
1319 
21 
164 
964 
4364 19 (PeX Timeout) 
KM 
54 
196 
241 
6 
na 
na 
na 
na (SVF Timeout) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="true"><head>Table 6 : Bugs Reported By PeX. Confirmed or Ignored.</head><label>6</label><figDesc></figDesc><table>Type-# 
File 
Function 
Description 
Status 
DAC-1 
fs/btrfs/send.c 

btrfs_send 

missing DAC check when traversing a snapshot 
C 
DAC-2 
fs/ecryptfs/inode.c 

ecryptfs_removexattr(),_setxattr() 

missing xattr_permission() 
C 
DAC-3 
fs/ecryptfs/inode.c 

ecryptfs_listxattr() 

missing xattr_permission() 
C 
CAP-4 
drivers/char/random.c 

write_pool(), credit_entropy_bits() 

missing CAP_SYS_ADMIN 
C 
CAP-5 
drivers/scsi/sg.c 

sg_scsi_ioctl() 

missing CAP_SYS_ADMIN or CAP_RAW_IO 
I 
CAP-6 
drivers/block/pktcdvd.c 

add_store(), remove_store() 

missing CAP_SYS_ADMIN 
I 
CAP-7 
drivers/char/nvram.c 

nvram_write() 

missing CAP_SYS_ADMIN 
I 
CAP-8 
drivers/firmware/efi/efivars.c 

efivar_entry_set() 

missing CAP_SYS_ADMIN 
C 
CAP-9 
net/rfkill/core.c 
rfkill_set_block(), rfkill_fop_write() missing CAP_NET_ADMIN 
C 
CAP-10 block/scsi_ioctl.c 

mmc_rpmb_ioctl() 

missing verify_command or CAP_SYS_ADMIN 
I 
CAP-11 drivers/platform/x86/thinkpad_acpi.c acpi_evalf() 
missing CAP_SYS_ADMIN 
I 
CAP-12 drivers/md/dm.c 

dm_blk_ioctl() 

missing CAP_RAW_IO 
I 
CAP-13 block/bsg.c 

bsg_ioctl 

inconsistent/missing CAP_SYS_ADMIN 
C 
CAP-14 kernel/sys.c 

prctl_set_mm_exe_file 

inconsistent capability check 
I 
CAP-15 kernel/sys.c 

prctl_set_mm_exe_file 

inconsistent capability and namespace check 
I 
CAP-16 block/scsi_ioctl.c 

blk_verify_command 

redundant check CAP_SYS_RAWIO 
I 
LSM-17 fs/ecryptfs/inode.c 

ecryptfs_removexattr(), _setxattr() 

missing security_inode_removexattr() 
C 
LSM-18 mm/mmap.c 

remap_file_pages 

missing security_mmap_file() 
I 
LSM-19 fs/binfmt_elf.c 

load_elf_binary() 

missing security_kernel_read_file 
I 
LSM-20 fs/binfmt_elf.c 

load_elf_library() 

missing security_kernel_read_file 
I 
LSM-21 fs/xfs/xfs_ioctl.c 

xfs_file_ioctl() 

missing security_inode_readlink() 
C 
LSM-22 kernel/workqueue.c 

wq_nice_store() 

missing security_task_setnice() 
C 
LSM-23 fs/ecryptfs/inode.c 

ecryptfs_listxattr() 

missing security_inode_listxattr 
C 
LSM-24 include/linux/sched.h 

comm_write() 

missing security_task_prctl() 
C 
LSM-25 fs/binfmt_misc.c 

load_elf_binary() 

missing security_bprm_set_creds() 
I 
LSM-26 drivers/android/binder.c 

binder_set_nice 

missing security_task_setnice() 
I 
LSM-27 fs/ocfs2/cluster/tcp.c 

o2net_start_listening() 

missing security_socket_bind 
I 
LSM-28 fs/ocfs2/cluster/tcp.c 

o2net_start_listening() 

missing security_socket_listen 
I 
LSM-29 fs/dlm/lowcomms.c 

tcp_create_listen_sock 

missing security_socket_bind 
I 
LSM-30 fs/dlm/lowcomms.c 

tcp_create_listen_sock 

missing security_socket_listen 
I 
LSM-31 fs/dlm/lowcomms.c 

sctp_listen_for_all 

missing security_socket_listen 
I 
LSM-32 net/socket.c 

kernel_bind 

missing security_socket_bind 
I 
LSM-33 net/socket.c 

kernel_listen 

missing security_socket_listen 
I 
LSM-34 net/socket.c 

kernel_connect 

missing security_socket_connect 
I 
LSM-35 fs/ocfs2/cluster/tcp.c 

o2net_start_listening() 

redundant security_socket_create 
C 
LSM-36 fs/ocfs2/cluster/tcp.c 

o2net_open_listening_sock() 

redundant security_socket_create 
C 

</table></figure>

			<note place="foot" n="2"> This does not necessarily mean that the permission check dominates all call instructions of ICFG which invoke the resulting privileged function. As long as some call instructions are dominated by the check, their callees are treated as privileged functions.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors would like to thank anonymous reviewers for their insightful comments. This research is partially supported by the NSF under Grant No. CSR-1814430 and CSR-1750503.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Android Permission Overview</title>
		<ptr target="https://developer.android.com/guide/topics/permissions/overview" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Apparmor</surname></persName>
		</author>
		<ptr target="https://gitlab.com/apparmor/apparmor/wikis/home/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<ptr target="https://lwn.net/Articles/486306/" />
		<title level="m">CAP_SYS_ADMIN: the new root</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Data-flow analysis for the linux kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K-Miner</forename></persName>
		</author>
		<ptr target="https://github.com/ssl-tud/k-miner" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Locationmanager</surname></persName>
		</author>
		<ptr target="https://developer.android.com/reference/android/location/LocationManager#getLastKnownLocation(java.lang.String" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<ptr target="https://en.wikipedia.org/wiki/Mandatory_access_control" />
	</analytic>
	<monogr>
		<title level="j">Mandatory access control</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Re: Leaking path in xfs&apos;s ioctl interface(missing lsm check) by stephen smalley</title>
		<ptr target="https://lkml.org/lkml/2018/9/26/668" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Smatch: pluggable static analysis for c</title>
		<ptr target="https://lwn.net/Articles/691882/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Virtual file system</title>
		<ptr target="https://en.wikipedia.org/wiki/Virtual_file_system" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Whole Program LLVM: a wrapper script to build wholeprogram llvm bitcode files</title>
		<ptr target="https://github.com/travitch/whole-program-llvm" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Tesla: temporally enhanced system logic assertions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">M</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Watson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Khilan</forename><surname>Chisnall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilias</forename><surname>Gudka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brooks</forename><surname>Marinos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Davis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth European Conference on Computer Systems</title>
		<meeting>the Ninth European Conference on Computer Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page">19</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Pscout: analyzing the android permission specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kathy</forename><forename type="middle">Wain</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yee</forename><surname>Au</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yi</forename><forename type="middle">Fan</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhen</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Lie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 ACM conference on Computer and communications security</title>
		<meeting>the 2012 ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="217" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Unassisted and automatic generation of highcoverage tests for complex systems programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristian</forename><surname>Cadar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Dunbar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawson</forename><forename type="middle">R</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="209" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Demand-driven computation of interprocedural data flow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evelyn</forename><surname>Duesterwald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajiv</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mary</forename><forename type="middle">Lou</forename><surname>Soffa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages</title>
		<meeting>the 22nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="37" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Runtime verification of authorization hook placement for the linux security modules framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antony</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trent</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaolan</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM Conference on Computer and Communications Security</title>
		<meeting>the 9th ACM Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="225" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Bugs as deviant behavior: A general approach to inferring errors in systems code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawson</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">Yu</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seth</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andy</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Chelf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGOPS Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="57" to="72" />
			<date type="published" when="2001" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Automatic placement of authorization hooks in the linux security modules framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vinod</forename><surname>Ganapathy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trent</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Somesh</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM conference on Computer and communications security</title>
		<meeting>the 12th ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="330" to="339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Towards automated authorization policy enforcement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vinod</forename><surname>Ganapathy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trent</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Somesh</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Second Annual Security Enhanced Linux Symposium. Citeseer</title>
		<meeting>Second Annual Security Enhanced Linux Symposium. Citeseer</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Uncovering memory corruption in linux</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Gens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><surname>Schmitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lucas</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmadreza</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>K-Miner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the 2018 Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The ant and the grasshopper: fast and accurate pointer analysis for millions of lines of code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Hardekopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Calvin</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="290" to="299" />
			<date type="published" when="2007" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Exploiting pointer and location equivalence to optimize pointer analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Hardekopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Calvin</forename><surname>Lin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="265" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Flow-sensitive pointer analysis for millions of lines of code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Hardekopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Calvin</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Annual IEEE/ACM International Symposium on Code Generation and Optimization</title>
		<meeting>the 9th Annual IEEE/ACM International Symposium on Code Generation and Optimization</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="289" to="298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Program slicing in understanding of large programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bogdan</forename><surname>Korel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juergen</forename><surname>Rilling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Program Comprehension, 1998. IWPC&apos;98. Proceedings., 6th International Workshop on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="145" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Llvm: A compilation framework for lifelong program analysis &amp; transformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Lattner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vikram</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Code Generation and Optimization: Feedback-directed and Runtime Optimization, CGO &apos;04</title>
		<meeting>the International Symposium on Code Generation and Optimization: Feedback-directed and Runtime Optimization, CGO &apos;04</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page">75</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Unisan: Proactive kernel memory initialization to eliminate data leakages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kangjie</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengyu</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenke</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2016 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="920" to="932" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">checker: A soundy analysis for linux kernel drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aravind</forename><surname>Machiry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chad</forename><surname>Spensky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jake</forename><surname>Corina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Stephens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giovanni</forename><surname>Vigna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th {USENIX} Security Symposium ({USENIX} Security 17)</title>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1007" to="1024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Cross-checking semantic correctness: The case of finding file system bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Changwoo</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanidhya</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Byoungyoung</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengyu</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles</title>
		<meeting>the 25th Symposium on Operating Systems Principles</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="361" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Advanced Compiler Design Implementation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Muchnick</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Morgan Kaufmann Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Leveraging choice to automate authorization hook placement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Divya</forename><surname>Muthukumaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trent</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vinod</forename><surname>Ganapathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 ACM conference on Computer and communications security</title>
		<meeting>the 2012 ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="145" to="156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Producing hook placements to enforce expected access control policies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Divya</forename><surname>Muthukumaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nirupama</forename><surname>Talele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trent</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gang</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Engineering Secure Software and Systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="178" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Documenting and automating collateral evolutions in linux device drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoann</forename><surname>Padioleau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julia</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gilles</forename><surname>René Rydhof Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Acm sigops operating systems review</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="247" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Wave propagation and deep propagation for pointer analysis. In Code Generation and Optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fernando</forename><surname>Magno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Quintao</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Berlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CGO 2009. International Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="126" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Trusted computer system evaluation criteria</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lili</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Feng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mi</forename><surname>Kyung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Han</forename><forename type="middle">Ratul</forename><surname>Mahajan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985" />
		</imprint>
		<respStmt>
			<orgName>National Computer Security Center. Citeseer</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Listt: An investigation into unsound-incomplete yet practical result yielding static taintflow analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjay</forename><surname>Rawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laurent</forename><surname>Mounier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marie-Laure</forename><surname>Potet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Availability, Reliability and Security</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="498" to="505" />
		</imprint>
	</monogr>
	<note>Ninth International Conference on</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Access control: principle and practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ravi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierangela</forename><surname>Sandhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Samarati</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE communications magazine</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="40" to="48" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Kratos: Discovering inconsistent security policy enforcement in the android framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuru</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhuoqing</forename><forename type="middle">Morley</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhiyun</forename><surname>Ott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Qian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Security enhanced (se) android: Bringing flexible mac to android</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Smalley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Craig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="volume">310</biblScope>
			<biblScope unit="page" from="20" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Implementing selinux as a linux security module</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Smalley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Vance</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wayne</forename><surname>Salamon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NAI Labs Report</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">43</biblScope>
			<biblScope unit="page">139</biblScope>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Rolecast: finding missing security checks when you do not know what checks are</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sooel</forename><surname>Son</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kathryn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vitaly</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shmatikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="1069" to="1084" />
			<date type="published" when="2011" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Svf: interprocedural static value-flow analysis in llvm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yulei</forename><surname>Sui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jingling</forename><surname>Xue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Compiler Construction</title>
		<meeting>the 25th International Conference on Compiler Construction</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="265" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Autoises: Automatically inferring security specification and detecting violations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lin</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaolan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiao</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weiwei</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="379" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">A survey of program slicing techniques. Centrum voor Wiskunde en Informatica</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Tip</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">A guide to understanding discretionary access control in trusted systems</title>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="volume">3</biblScope>
		</imprint>
		<respStmt>
			<orgName>National Computer Security Center (US ; National Computer Security Center</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Jigsaw: Protecting resource access by inferring programmer expectations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hayawardh</forename><surname>Vijayakumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xinyang</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathias</forename><surname>Payer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trent</forename><surname>Jaeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="973" to="988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">How double-fetch situations turn into double-fetch vulnerabilities: A study of double fetches in the linux kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pengfei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens</forename><surname>Krinke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gen</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Dodier-Lazaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Check it again: Detecting lacking-recheck bugs in os kernels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenwen</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kangjie</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pen-Chung</forename><surname>Yew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM conference on Computer and communications security</title>
		<meeting>ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Improving integer security for systems with kint</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haogang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhihao</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nickolai</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M Frans</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="163" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Linux security module framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Crispin</forename><surname>Cowan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Smalley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Kroah-Hartman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Ottawa Linux Symposium</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">8032</biblScope>
			<biblScope unit="page" from="6" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Precise and scalable detection of double-fetch bugs in os kernels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meng</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chenxiong</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kangjie</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Chucky: Exposing missing checks in source code for vulnerability discovery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabian</forename><surname>Yamaguchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Wressnegger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugo</forename><surname>Gascon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konrad</forename><surname>Rieck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 ACM SIGSAC conference on Computer &amp; communications security</title>
		<meeting>the 2013 ACM SIGSAC conference on Computer &amp; communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="499" to="510" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Meca: an extensible, expressive system and language for statically checking security properties</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junfeng</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ted</forename><surname>Kremenek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yichen</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawson</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th ACM conference on Computer and communications security</title>
		<meeting>the 10th ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="321" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Apisan: Sanitizing api usages through semantic cross-checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Changwoo</forename><surname>Insu Yun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xujie</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yeongjin</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mayur</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Naik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="363" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Using cqual for static analysis of authorization hook placement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaolan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antony</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trent</forename><surname>Jaeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="33" to="48" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
