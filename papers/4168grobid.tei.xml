<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:01+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Vetting Single Sign-On SDK Implementations via Symbolic Reasoning Vetting Single Sign-On SDK Implementations via Symbolic Reasoning</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 15-17. 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ronghai</forename><surname>Yang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wing</forename><forename type="middle">Cheong</forename><surname>Lau</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiongyi</forename><surname>Chen</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kehuan</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ronghai</forename><surname>Yang</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">The Chinese University of Hong Kong</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Sangfor Technologies Inc</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wing</forename><forename type="middle">Cheong</forename><surname>Lau</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">The Chinese University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiongyi</forename><surname>Chen</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">The Chinese University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kehuan</forename><surname>Zhang</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">The Chinese University of Hong Kong</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">The Chinese University of Hong Kong</orgName>
								<orgName type="institution" key="instit2">Sangfor Technologies Inc</orgName>
								<orgName type="institution" key="instit3">The Chinese University of Hong Kong https</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Vetting Single Sign-On SDK Implementations via Symbolic Reasoning Vetting Single Sign-On SDK Implementations via Symbolic Reasoning</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 27th USENIX Security Symposium</title>
						<meeting>the 27th USENIX Security Symposium <address><addrLine>Baltimore, MD, USA</addrLine></address>
						</meeting>
						<imprint>
							<date type="published">August 15-17. 2018</date>
						</imprint>
					</monogr>
					<note>Open access to the Proceedings of the 27th USENIX Security Symposium is sponsored by USENIX. This paper is included in the</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Encouraged by the rapid adoption of Single Sign-On (SSO) technology in web services, mainstream identity providers, such as Facebook and Google, have developed Software Development Kits (SDKs) to facilitate the implementation of SSO for 3rd-party application developers. These SDKs have become a critical foundation for web services. Despite its importance, little effort has been devoted to a systematic testing on the implementations of SSO SDKs, especially in the public domain. In this paper, we design and implement S3KVetter (Single-Sign-on SdK Vetter), an automated, efficient testing tool, to check the logical correctness and identify vulnerabilities of SSO SDKs. To demonstrate the efficacy of S3KVetter, we apply it to test ten popular SSO SDKs which enjoy millions of downloads by application developers. Among these carefully engineered SDKs, S3KVetter has surprisingly discovered 7 classes of logic flaws, 4 of which were previously unknown. These vulnerabilities can lead to severe consequences, ranging from the sniffing of user activities to the hijacking of user accounts.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Single Sign-On (SSO) protocols like OAuth2.0 and OpenID Connect have been widely adopted to simplify user authentication and service authorization for thirdparty applications. According to a survey conducted by Janrain <ref type="bibr" target="#b25">[29]</ref>, 75% users choose to use SSO services, instead of traditional passwords, to login applications. As a conservative estimate in <ref type="bibr" target="#b45">[49]</ref>, 405 out of Top-1000 applications support SSO services, indicating that SSO login has already become a mainstream authentication method and still continues its strong adoption.</p><p>Motivated by the prevalence of SSO services, mainstream Identity Providers (IdPs) like Google and Facebook, have provided their Software Development Kits (SDKs) to facilitate the implementation of third party services (e.g. IMBD and Uber), which are referred to as the Relying Parties (RP) under the SSO framework.</p><p>To further enhance flexibility, some high-profile open source projects <ref type="bibr" target="#b0">[3,</ref><ref type="bibr" target="#b17">21]</ref> have integrated SSO SDK modules from different IdPs so that an RP application can readily support multiple IdPs at the same time. These SDKs are the core component of SSO services and have enjoyed millions of downloads (see <ref type="table" target="#tab_2">Table 1</ref>).</p><p>Typically, an SSO SDK provider would release the source code of its SDK and provide documentations, together with simple usage examples. It then leaves the rest to the RP developers. Without fully understanding the SDK internals, most RP developers simply follow the sample codes to invoke the SDK functions. As such, one important question is that: Is an SSO SDK itself secure? Note that if the internals of a SDK already contain vulnerabilities, then all RP applications using the vulnerable SDK become susceptible. Given the popularity of these SDKs and the nature of SSO services, any security breach can lead to critical implications. For example, an attacker may be able to log into billions of user accounts <ref type="bibr" target="#b44">[48]</ref>.</p><p>The goal of this work is to systematically test whether an SSO SDK is vulnerable by itself. We will focus on the logic vulnerabilities of a SDK, which allow an attacker to log into RP applications as a victim. To the best of our knowledge, this is the first work to analyze the SSO SDKs. Most existing work on SSO security does not analyze the code of the SSO system, let alone the SDK. More specifically, there are mainly two types of work in the literature. The first type reasons about the specification of the standard SSO protocols <ref type="bibr" target="#b19">[23,</ref><ref type="bibr" target="#b35">39]</ref> by different methods including model checking <ref type="bibr" target="#b1">[5,</ref><ref type="bibr" target="#b3">7,</ref><ref type="bibr" target="#b11">15,</ref><ref type="bibr" target="#b15">19]</ref>, cryptographic proof <ref type="bibr" target="#b7">[11]</ref> and manual analyses <ref type="bibr" target="#b30">[34]</ref>. The other type aims to discover vulnerabilities of real-world SSO implementations via network traffic analysis <ref type="bibr" target="#b39">[43,</ref><ref type="bibr" target="#b40">44,</ref><ref type="bibr" target="#b43">47,</ref><ref type="bibr" target="#b44">48]</ref> and large-scale automated testing <ref type="bibr" target="#b14">[18,</ref><ref type="bibr" target="#b29">33,</ref><ref type="bibr" target="#b45">49,</ref><ref type="bibr" target="#b47">51]</ref>. The former does not care about the SSO implementation, and the latter treats the implementation as a black box. Consequently, both cannot detect logic flaws buried deep in the SSO SDKs.</p><p>To this end, this paper introduces S3KVetter, a tool which automatically identifies vulnerabilities in the SSO SDK internals. Our key insight is to leverage dynamic symbolic execution, a widely used technique for program analysis (e.g., <ref type="bibr" target="#b5">[9,</ref><ref type="bibr" target="#b18">22]</ref>), to track feasible execution paths and the associated predicates of the SSO SDK under test. For each path, S3KVetter then utilizes a theorem prover <ref type="bibr">1</ref> to check whether the predicates violate SSO security properties. Although these techniques have been heavily studied, they cannot be directly applied to SSO-like applications due to the multi-party nature and multiple-lock-step operations of SSO services. We have thus developed new techniques including request order scheduling and multi-party coordination for this kind of multi-party applications.</p><p>We have implemented a full-featured prototype of S3KVetter and applied it to check 10 popular SSO SDKs. These SDKs are all carefully engineered and enjoy a large number of downloads (see <ref type="table" target="#tab_2">Table 1</ref>). They support different SSO protocols (OAuth2.0 or OpenID Connect) and various grant flows (authorization code flow and implicit flow). To our surprise, S3KVetter has discovered, among these security-focused SDKs, 7 classes of serious logic vulnerabilities and 4 of them are previously unknown. The security impact can range from sniffing user activities at the RP, to the total hijacking of the victim's RP account. In summary, we have made the following contributions:</p><p>• Measurement study and new findings. We have systematically conducted an in-depth security analysis on 10 commercially deployed SSO SDKs, the first of this kind. We discover 7 types of serious logic vulnerabilities, 4 of which are previously unknown. We demonstrate these vulnerabilities can lead to critical security implications. Our findings show that the overall security quality of SSO SDKs (and thus their deployment) is worrisome.</p><p>• Effective vulnerability detection for distributed systems via symbolic reasoning. We have designed and implemented S3KVetter to perform security analysis of SDK internals based on dynamic symbolic execution and a theorem prover. In particular, we develop a set of new techniques, including symbolizing request orders and multi-party coordination, to improve symbolic execution for multi-party distributed systems with multiple-lock-step interactions. The remainder of this paper is organized as follows: Section 2 introduces the background. Section 3 presents <ref type="bibr">1</ref> We will use the terms theorem prover, constraint solver and Satisfiability Module Theories (SMT) solver interchangeably. the overview of S3KVetter. Section 4 discusses its detailed design. Additional implementation considerations are given in Section 5. We evaluate the performance of S3KVetter in Section 6 and detail the discovered vulnerabilities in Section 7. We discuss the lessons learned in Section 8 and summarize related works in Section 9. We conclude the paper in Section 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>OAuth2.0 <ref type="bibr" target="#b19">[23]</ref> and OpenID Connect <ref type="bibr" target="#b35">[39]</ref> (OIDC) have become the de facto SSO standard protocols. Therefore, in this paper, we only focus on these two protocols 2 . In an SSO ecosystem, there are three parties: a User, a Relying Party server (RP server) and an Identity Provider server (IdP server) <ref type="bibr" target="#b0">3</ref> . The goal of SSO services is to allow the user to log into the RP via the IdP. To achieve this goal, the IdP issues an access token (as in the case of OAuth2.0), and sometimes together with an id token (as in the case of OIDC), to the RP so that the latter can retrieve the user identity information hosted by the IdP. To complete the process, both SSO protocols have developed multiple authorization grant flows, but only two of them, namely, the authorization code flow and the implicit flow, are commonly deployed in practice. While S3KVetter supports both protocols and both authorization flow types for the web and mobile platforms, we use the authorization code flow of OAuth2.0 under the web platform as the running example throughout this paper.</p><p>2.1 Authorization Code Flow of OAuth2.0   the information of the user hosted by the IdP ; V. (Step 10-11) The user can then access his information hosted by the RP. Refer to Appendix A for detailed descriptions of the individual steps in <ref type="figure" target="#fig_1">Fig. 1</ref>. Notice that, from the perspective of the RP, the messages exchanged in <ref type="figure" target="#fig_1">Fig. 1</ref> are typically handled by the SSO SDK. While we will use <ref type="figure" target="#fig_1">Fig. 1</ref> as an illustrative example throughout this paper, our work actually goes beyond <ref type="figure" target="#fig_1">Fig. 1</ref>. For example, we will discuss the vulnerability associated with MAC key (Section 7.4) that is not presented in <ref type="figure" target="#fig_1">Fig. 1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Overview</head><p>In this paper, we focus on analyzing the authentication issues of an SSO SDK. In particular, we use S3KVetter to analyze whether the implementation of a target SDK contains errors that would allow an attacker to login as victims. It is worth to note that S3KVetter can also be extended to study the security of other multi-party applications like payment services as discussed in Section 6.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Threat Model</head><p>We assume the attacker has the following capabilities: (1) The attacker can lure the victim to visit a malicious RP (mRP) <ref type="bibr">4</ref> . <ref type="formula">(2)</ref> The attacker can setup an external machine and use his/her own account to freely communicate with the client, IdP and RP server. (3) If the victim does not use HTTPS, the attacker can eavesdrop the communication of the victim's client device. Besides that, the attacker does not have any other advantages (e.g., he/ she does not have the source code or binary executable of the remote IdP server). <ref type="figure" target="#fig_2">Fig. 2</ref> presents the high-level system architecture of S3KVetter, which contains three components: an extended concolic (dynamic symbolic) execution engine, a predicate translator and a theorem prover. The concolic execution engine aims to explore the target SSO SDK exhaustively and output all the feasible program paths in the form of a predicate tree. To support formal reasoning, the predicate translator then expresses this predicate tree using a precise syntax that lends itself to precise semantics. Finally, taking the translated predicate tree and our manually developed list of security properties as inputs, the theorem prover reasons about each program path for security property violation. If there is no satisfiable solution, then the SDK is considered to be secure. Otherwise, the theorem prover outputs the concrete inputs (in the form of SSO handshake messages and parameters) that can trigger the violation.  <ref type="figure" target="#fig_3">3</ref> shows the setup of the overall system in which S3KVetter simulates the client device to communicate with the RP server (i.e., SDK) and IdP server. S3KVetter also acts as the attacker to intercept and manipulate the victim's messages (e.g., via malicious RP or eavesdropping). These messages are then fed to the SDK for symbolic exploration. Since the open-source SDK is freely available online, the analyst can build a local RP server to symbolically explore the SDK.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>System Architecture</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Design of S3KVetter</head><p>In this section, we present the innovations introduced by S3KVetter to tackle the special technical challenges of testing multi-party systems with multiple-lock-step operations. We will also illustrate how conventional dynamic symbolic execution schemes, without our extensions, can incur false positives, miss bugs, or get stuck at shallow, non-core error-processing paths, when analyzing multiparty protocols/ systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Symbolic Exploration of SDKs</head><p>Based on dynamic symbolic execution, S3KVetter can track how the operations on specific symbolic fields/ variables affect the final computation result. We leverage these messages to build a so-called symbolic predicate tree. One example is presented in <ref type="figure" target="#fig_4">Fig. 4</ref>, which represents the conditional-checkings of the RequestOAuthLib SDK <ref type="bibr" target="#b0">[3]</ref>, a popular SSO SDK. Here, the nonleaf nodes in the tree represent symbolic constraints enforced by the corresponding path, and the leaf nodes represent the final computation results (e.g., an access token or the identity of a logged-in user in the context of SSO). For the ease of presentation, we have simplified the tree by omitting numerous branches, nodes and removing multiple constraints (shown as dashed lines in the figure). This SDK involves 649 different execution paths <ref type="bibr" target="#b1">5</ref> , which would require laborious manual effort by testers/ developers to generate. By contrast, S3KVetter, leveraging high-coverage symbolic execution, automatically explores different corner-case situations.</p><p>Intuitively, the symbolic predicate tree has captured rich semantic information: The leftmost path in <ref type="figure" target="#fig_4">Fig. 4</ref> corresponds to the case where the user skips Req0 (i.e.,</p><p>Step 1 in <ref type="figure" target="#fig_1">Fig. 1</ref>) and directly sends Req1 (Step 5) to the SDK. Upon receiving Req1, the SSO SDK under test first checks whether the communication uses HTTPS, followed by verifying the existence of a code parameter in the URI. If these conditions are satisfied, the SDK will send an access-token request (Step 7) to the IdP server. Such semantic information is essential and effective for vulnerability detection. For example, this leftmost path does not check the state variable but still allows a user to login successfully. This corresponds to the vulnerability of use-before-assignment of the state variable, as to be detailed in Section 7.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Symbolizing Request Orders</head><p>An SSO system requires multiple interactions with the user to complete a task (e.g., authentication and authorization). To be realistic, S3KVetter should allow attackers to randomly and symbolically select execution orders such as making out-of-order requests, skipping/ replaying requests. Although existing symbolic execution studies <ref type="bibr" target="#b6">[10,</ref><ref type="bibr" target="#b27">31,</ref><ref type="bibr" target="#b36">40]</ref> have proposed different techniques to support asynchronous event/ request orders, they require expert-level domain knowledge of the application under test to provide all the possible external events (e.g., atomic rule updates and flow independence reduction for OpenFlow application <ref type="bibr" target="#b6">[10]</ref>). In short, their approaches cannot be readily generalized for other applications. more thoroughly, S3KVetter should allow attackers to randomly, symbolically select execution orders such as making out-of-order requests, skipping/ replaying requests.</p><p>We develop a general and simple scheduling algorithm, which does not require any application-specific heuristic from the analyst, to systematically explore execution paths by generating inputs and schedules (i.e., request orders) one by one. The algorithm first guides S3KVetter to run the SDK under test with the sample input and the normal schedule. Then the algorithm does the following loop to sweep possible schedules and feasible program paths: (1) it tries to explore all the feasible program paths of the SDK under the selected schedule; (2) it then generates a new schedule with the goal to explore different program paths.</p><p>The remaining issue is to generate a new schedule based on the normal one. Recall that we are interested in the authentication property only, which is typically completed by the last request in the call-flow. Therefore, all of our generated schedules end with the last request. We use <ref type="figure" target="#fig_8">Fig. 5</ref>, which contains three requests Req0, Req1 and Req2, to illustrate how to generate a new schedule as follows:</p><p>1. Develop the power set of the normal execution order and exclude the empty set or those subsets which do not contain the last request. The resultant schedule includes: {Req2}, {Req1,Req2}, {Req0, Req2}, {Req0, Req1, Req2} 2. Consider the ordering in the remaining subsets. For example, a subset {Req0, Req1, Req2} can mean two possible execution orders: {Req0, Req1, Req2} and {Req1, Req0, Req2}. Note that we keep the order of the last request (i.e., Req2). 3. Put all the well-ordered subsets into a scheduling queue. For <ref type="figure" target="#fig_8">Fig 5,</ref> we have 5 schedules in total. The intuition behind this scheme is that S3KVetter</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Req0</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Req1</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Req2</head><p>Req2 Req2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Req1</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Req2</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Req0</head><p>Req2 <ref type="table" target="#tab_2">Req0   Req1   Input  Schedule 1 Schedule 2 Schedule 3 Schedule 4</ref> Time Sequence to bypass logic checks to break multi-step operation <ref type="figure" target="#fig_8">Figure 5</ref>: Scheduling for out-of-order requests attempts to skip any important logic check, break the multi-step operations or replay requests (as can be seen in <ref type="figure" target="#fig_8">Figure 5</ref>). For example, the schedule of {Req1, Req2} guides S3KVetter to skip the first request, a key milestone of the SSO business process, which leads to the discovery of the vulnerability of use-before-assignment of the state variable (Section 7.3). Another important feature is to break/ subvert the order of requests (e.g., {Req1, Req0, Req2}), which can lead to the so-called "failure to revoke authorization" problem <ref type="bibr" target="#b45">[49]</ref>. Finally, the replay function is achieved since every schedule (e.g., {Req2}, {Req1,Req2}) will start to explore the SDK with the same requests (where Req2 is replayed).</p><p>Note that S3KVetter will not generate a complete set of request orderings since an attacker, in theory, can generate infinite number of request orderings, e.g., by repeating each request arbitrary number of times. However, according to our experience, the scheduler we incorporated into S3KVetter can generate a rich set of promising patterns/ request orderings. Nonetheless, with the framework of S3KVetter, it is relatively straightforward to incorporate additional patterns, if any, developed in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Coordinating among Multiple Parties Silently</head><p>SSO applications need to communicate among multiple parties. Unfortunately, existing symbolic execution frameworks are not designed for distributed multi-party systems. To fill this gap, researchers actually have developed different approaches, but none of them work perfectly for SSO-like applications. The key problem of existing solutions is that different parties have different views of the entire system status if we break the request orders. The case becomes worse in the existence of onetime-use parameters (e.g., code, state, etc.). Below we illustrate the limitations of existing approaches.</p><p>The first approach is to concretely run the external functions. However, since the IdP server typically imposes limit on API access rate, a large number of invocations of the external functions can easily hit the control threshold and lead to unexpected responses. Worse still, the widely used one-time-use parameters cannot be correctly generated/ processed in the case of symbolizing request orders. We take the code variable as the example to illustrate the problem. With Req0 (i.e., Step 1 of <ref type="figure" target="#fig_1">Fig. 1</ref>), S3KVetter can get a code from the IdP in Step 4 (note that S3KVetter simulates the client device). If S3KVetter skips this request and directly sends Req1, to exchange for an access token in Step 6, S3KVetter has no choice but to either use an old value or locally generate a seemingly legitimate code. For both cases, the IdP returns error since the code should be generated by the IdP server and can only be used for once. As such, the first approach will get stuck in non-core error-processing paths.</p><p>The second solution is to check the return type of the external function and then returns a random value of this type without executing the external functions (e.g., DART <ref type="bibr" target="#b18">[22]</ref>). However, this solution can lead to false positives. Consider the example above, even when a code is already used, DART may still return an access token string (instead of an error message) to the SDK. In this case, the testing tool may report a false positive: An attacker can use an old code to login. The third approach (e.g., <ref type="bibr">KLEENet [40]</ref>) is to symbolically explore the external functions as well. However, this is not a viable approach for our case as we do not have the source code or binary of the remote IdP server to support symbolic exploration.</p><p>Solution. Due to the different views perceived by different parties, some requests with nonce parameters, which are considered to be legitimate by the RP, may be rejected by the IdP. To tackle such inconsistency, S3KVetter concretely simulates, and more importantly, modifies, the entire external world for the SDK under test. Specifically, S3KVetter analyzes the IdP behaviors and directly responds to the RP SDK as if it is the IdP. Instead of strictly following the IdP's behaviors, S3KVetter modifies the response so that every party has the same synchronized view on the global system state. To be more specific, S3KVetter simulates a slightly different IdP as follows:</p><p>1. Once a nonce parameter is consumed, S3KVetter, unlike the real-world IdP server, will first generate a new nonce value internally. 2. When S3KVetter starts to explore another path, it will first check whether the previously generated nonce value satisfies the constraints of the path to be explored or not. If so, directly use this new value. 3. Otherwise, S3KVetter checks the local SDK conditions related to this nonce. Therefore, it uses the value solved by the constraint solver and stores the previously generated value for later use. Since S3KVetter drives the SDK execution, the status of the SDK is closely tracked by S3KVetter. Therefore, S3KVetter can internally force its simulated remote IdP Code Example: <ref type="figure">Fig. 6</ref> illustrates how S3KVetter can coordinate multiple parties with the code example. Through Path1, the RP can obtain the user information with a fresh code. Upon completion of Path1, the used code is invalidated. But at the same time, S3KVetter dynamically generates a new random code . When exploring Path2 (where we skip Req0), S3KVetter finds that code satisfies the path constraint (code = None) and therefore provides the code for the SDK. Now this code is pre-generated and becomes valid. For Path3, S3KVetter finds that this path requires len(code) = 0. As such, S3KVetter provides an empty value solved by the constraint solver for the SDK (and puts another onthe-fly generated code aside).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementations:</head><p>The implementation requires to model the IdP server so that S3KVetter, in most cases, can rely on the SDK as the real IdP. One key observation is that IdPs typically follow the specification and provide similar functions. Therefore, we just need to model one IdP server, and the resultant model can work for multiple SDKs. The implementation involves two major steps. The first step is to infer and model the real-world IdP behaviors, which turns out to be not that challenging. On one hand, we follow existing work <ref type="bibr" target="#b1">[5,</ref><ref type="bibr" target="#b42">46]</ref> to perform blackbox differential fuzzing analysis (i.e., under different input arguments and app settings) for a better understanding of the conditional checking enforced by real IdPs. On the other hand, we also refer to the prototype IdP implementations provided by some open source projects <ref type="bibr" target="#b13">[17]</ref>. Second, we implement stub methods for all the common network API methods of Python (e.g., requests, urllib, etc.). Upon any network requests, our instrumented functions are invoked instead and reply the SDK on behalf of the IdP server.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Translating the Predicate Tree</head><p>To support formal reasoning, we should translate the extracted tree (e.g., <ref type="figure" target="#fig_4">Fig. 4</ref>) to a set of Boolean logic formulae. Given the simple syntax of logic languages (e.g., SMT-Lib v2.0), the translation is relatively straightforward. We also observe that every node in the predicate tree can be readily represented as a logic formula. Observe from <ref type="figure" target="#fig_4">Fig. 4</ref> that the node which checks whether uri contains a code parameter can be represented as (str.contains uri code) in the language of SMT-Lib. To get the final computation result (i.e., reach the leaf node), all the node logic formulae from the root to the target leaf node should be satisfied. Therefore, a program path can be represented as the conjunction of all the node logic formulae along this path. Similarly, we can use the disjunction of all the path logic formulae to represent the entire predicate tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Reasoning Predicates</head><p>The goal of S3KVetter is to detect flawed SDK implementations by checking the logic in the SDK internals. To achieve this goal, we may proceed in two ways. The first is to model all the incorrect logic patterns. However, it is difficult to generate such an exhaustive list. Therefore, we take an alternative approach by modeling the correct logic that should be enforced by the SDK. Then we can check whether the SDK under test follows these logical conditions or not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Defining Security Property</head><p>An SSO system involves interactions among the user, the RP server and the IdP server, where any weak communication links (i.e., 11 steps in <ref type="figure" target="#fig_1">Fig. 1</ref>) can lead to logic flaws. It is difficult to develop the security requirements for each link since neither protocol specification nor developer documentation explicitly defines the security goal for each method/ API call. Typically, the developer guidelines instruct a party to complete a set of operations and hope that the final security guarantee can be automatically reached by these operations. It is therefore more intuitive to define the final security goal (i.e., authentication property) for the RP server, which is the focus of this paper.</p><p>In particular, we have one key observation to secure the Single Sign-On service: An RP server should login a user if and only if the exact user has actually authorized this specific RP. To be more specific, an RP server can accept a user's login request in Step 5 of <ref type="figure" target="#fig_1">Fig. 1</ref> if and only if the exactly same user has authenticated and/or authorized this specific RP in Step 3. Given this insight, we develop the predicates which must be satisfied by a secure SSO transaction, as presented in Listing 1.</p><p>The clause in Line 1 (Clause 1) asserts that the user stored by the RP session should be the owner of the received access token, so does the code and refresh token (if exist) in the second and third clauses. Clause 4 and Clause 5 assert that the access token and refresh token (if any) should be correctly passed to the intended RP, not to any other RPs (which would then use this token to log into this RP illegally). Clause 6 reflects the requirements that the final logged-in user should be the one who authenticates/ authorizes with the IdP. We know that S3KVetter simulates the IdP behavior. Therefore, the IdP's session data can be readily accessed by S3KVetter. By checking against the required list of security properties, one can effectively expose the presences of numerous vulnerabilities. Any violation of a security property can lead to a vulnerability in practice. For example, if Clause 1 does not hold, then it means the RP does not use the access token to identify the user, which can make profile attacks <ref type="bibr" target="#b43">[47]</ref> possible. A more elaborated example is Clause 6, which can be violated in two different cases: (1) it is possible that an attacker eavesdrops the victim's code and uses it to sign into the RP (i.e., RPsession.uid = victim and IdPsession.uid = attacker) ; (2) it can also be the result of a CSRF attack, in which the attacker makes the victim's browser to send the RP a crafted request with the attacker's code (i.e., RPsession.uid = attacker and IdPsession.uid = victim).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementations of S3KVetter</head><p>We have implemented a full-featured prototype of S3KVetter in Python with 5064 lines of code. While its current implementation only focuses on SSO SDKs written in Python, our techniques can be naturally applied to SDK developed in other languages. To avoid reinventing the wheel, we have integrated and extended several open-source programs as supporting modules for S3KVetter. In Module 1 of <ref type="figure" target="#fig_2">Fig. 2</ref>, we extend PyExZ3 <ref type="bibr" target="#b2">[6]</ref>, a concolic execution engine for Python, to enhance the extraction of program predicates from production-level SDKs. We also substitute the default constraint solver of PyExZ3 (Z3) with CVC4 because the latter has better support for our heavily-used string operations with negligible performance penalty 7 . For Module 2 in <ref type="figure" target="#fig_2">Fig. 2</ref>, we choose SMT-Lib v2.0 which uses first-order logic with quantifier to represent the translated predicate tree. The logic language provided by SMT-Lib is not only expressive enough but also widely accepted by most theorem provers. This also allows us to directly use CVC4 in Module 3 of <ref type="figure" target="#fig_2">Fig. 2</ref> to reason about the program predicates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>To determine the effectiveness of our approach, we perform evaluations on ten popular Single-Sign-On SDKs. S3KVetter shows considerable improvement in terms of code coverage when comparing to an unmodified symbolic execution engine (without our proposed extensions and heuristics). More importantly, we uncover four types of previously unknown vulnerabilities and provide new insights of SSO services. <ref type="table" target="#tab_2">Table 1</ref> shows the statistics of the SDKs under test. These SDKs are carefully selected from official references and high-profile open source SDKs in Github. In particular, they have covered the two most popular protocols (i.e., OAuth2.0 and OpenID Connect) and both of the widely used authorization grant flows, namely, the implicit flow and the authorization code flow. The number of downloads for each SDK was retrieved on Oct 2017 from PyPI statistics <ref type="bibr">[2]</ref> -a website which provides runtime statistics of PyPI published packages. Note that these statistics provide a conservative estimate on the usage of these SDKs: only the installation of released version via pip counts. If developers install a SDK directly from its source code (e.g., via official webpage or Git), the suggested way for many IdPs (e.g., Facebook, Weichat, Renren, Douban), then the installation will not be included in the statistics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Dataset</head><p>Regarding the lines of code, some libraries (e.g., Request-OAuthLib and OAuthLib) are considerably larger. This is because those SDKs provide generalized, full-featured and specification-compliant support for multiple IdPs. In contrast, some small SDKs only implement simple and basic functions for a specific IdP. • 1 : Facebook SDK supports OIDC, and the other SDKs support OAuth2.0 protocol.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Experiment Setup and Performance</head><p>We run S3KVetter on an LXC instance of a Ubuntu 14.04 machine with 8 core CPU and 64GB memory. The testing of each SSO SDK can be completed within 5 seconds. Such runtime efficiency of S3KVetter can be attributed to the following 2 design decisions: Firstly, we internally simulate the external parties and thus spare S3KVetter from executing the most time-consuming network requests. Secondly, we concretely execute noncore methods. As such, the number of paths to be explored as well as the complexity of path constraint to be solved are significantly reduced. Without these two heuristics, it can take several minutes for testing even a small SDK.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Program Coverage</head><p>S3KVetter is able to overcome the fundamental weakness of traditional symbolic execution when dealing with multi-party, asynchronous distributed systems. By that, we mean that, when a conventional symbolic execution engine is unable to obtain correct/ meaningful results (e.g., code) from external parties (and thus gets stuck in error-processing paths), S3KVetter can either "generate" valid results, or schedule to other paths, to continue exploring meaningful paths beyond the error-processing paths. Therefore, as shown in <ref type="table" target="#tab_2">Table 1</ref>, S3KVetter can achieve 2%-13% higher statement coverage and 2%-19% higher branch coverage for the SDKs under test. Such coverage data is measured by coverage.py <ref type="bibr">[1]</ref>. While increasing the code coverage by modifying a limited set of inputs is increasingly harder for higher values, even small increases in code statements can significantly discover more program paths. Despite the improvement, we note that S3KVetter is far from achieving 100% coverage. This is in line with our expectation for two reasons: Firstly, a SDK often contains functions beyond the scope of SSO (e.g., advertisement, notification, etc.). For example, Facebook has developed over 80 functions in their Graph API to support data ingestion and interchange for the Facebook's platform. These functions therefore are not considered by S3KVetter. Secondly, only a limited set of inputs (e.g., Step 1, 5 and 10 in <ref type="figure" target="#fig_1">Fig. 1)</ref> can be controlled by an attacker. With such limited capability, the attacker can only reach part of the code statements. Since S3KVetter cannot reach more paths than the attacker, incomplete coverage is expected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Vulnerabilities Discovered</head><p>As presented in <ref type="table" target="#tab_3">Table 2</ref>, S3KVetter has found 7 types of vulnerabilities among these SDKs. While some vulnerabilities have been well studied in the literature, four of them are uncovered by S3KVetter for the first time. The damages of these newly discovered vulnerabilities vary depending on the specific implementations. The security impact can range from sniffing user activities at the RP, to the hijacking of the victim's RP account. There is only one requirement for the exploitation of these vulnerabilities 8 : the attacker needs to setup a malicious RP (mRP) and lure a victim user to login to the mRP. Once this condition is satisfied, the attacker can remotely control the victim's account of any RP which uses the vulnerable SSO SDK. We detail these newly discovered vulnerabilities in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.1">Detection Accuracy</head><p>We have manually verified all the reported vulnerabilities and found no false positive. However, S3KVetter can contain false negatives (like the state-of-the-art symbolic analysis techniques) for two main reasons. Firstly, our developed security property only focuses on the authentication issues. Yet, there may be other important properties. Secondly, S3KVetter may not be able to explore all execution paths due to the following limitations: • The underlying SMT solver assumes a query does not have a feasible solution when it takes too long to solve. However, it can be the case that the constraint under query is too complex. We cannot cover those feasible paths related to such a complex constraint.</p><p>• PyExZ3 uses class inheritance to track program execution. However, if the SDK explicitly casts the input data to native data type, PyExZ3 will lose the control for this variable (We seldom observe such cases in practice though).</p><p>• We concretely run non-core methods (e.g., URLencode) and do not check whether these non-core methods contain bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Usability</head><p>It is straightforward to apply S3KVetter on an SSO SDK. Only two manual steps are required by an analyst. Firstly, the analyst should build a sample app, based on the SDK under test, so that S3KVetter can actually execute/ explore the app and thus the target SDK. Thanks to the widely available developer documentation and official sample codes, this step is relatively straightforward. Secondly, the analyst should mark which functions can be reached by which part of the attacker's input <ref type="bibr" target="#b5">9</ref> . Although there can be thousands of functions in a SDK , the attacker usually can only reach very few of them. For example, only three functions of the Request-OAuthLib SDK can be directly invoked by an attacker. Given the small number of these functions, it becomes trivial to identify which part of the user inputs is symbolic. For instance, the Request-OAuthLib SDK authenticates a user only based on the variable of request.url. Therefore, only this variable is marked as symbolic (one example can be found in Appendix B). The other variables like cookies and HTTP headers, though controllable by an attacker, are treated as concrete since they are not processed by the SDK of interest. <ref type="bibr" target="#b5">9</ref> While we assume an attacker can control all packets sent to the RP server, only part of these packets would be processed by the SDK.</p><p>To apply S3KVetter on other multi-party systems, one additional manual step is to develop the required security properties (i.e., the counterpart of Listing 1) for the specific domain of applications. Fortunately, the required security properties are high-level in nature and do not need to be developed by a domain expert. For example, the list of the required security properties for payment services can be developed by codifying the following statement: A merchant M should accept an order if and only if the user has paid to the cashier in the correct amount for that specific order associated with merchant M.</p><p>Note that the developed scurity property is not necessarily an exhaustive list of all protocol states. In fact, the analyst is free to specify the properties of interest. For instance, if an SSO system only supports the implicit call-flow (where the code variable is not involved), Clause 2 in Listing 1 is no longer needed. Note also that S3KVetter is agnostic to how the security properties are derived. While other researchers have managed to automatically extract the required security properties from the source code <ref type="bibr" target="#b1">[5]</ref> or protocol specification <ref type="bibr" target="#b12">[16]</ref>, their results are complementary to ours and can be adopted to further extend the capabilities of S3KVetter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">Comparison with Existing Testing</head><p>Tools for SSO To the best of our knowledge, there is no existing work (except <ref type="bibr" target="#b45">[49]</ref>) which performs comprehensive blackbox fuzzing/ testing on SSO SDKs.</p><p>• <ref type="bibr" target="#b14">[18,</ref><ref type="bibr" target="#b29">33,</ref><ref type="bibr" target="#b47">51]</ref> build tools to check specific, previously known vulnerabilities (e.g.,CSRF), but could not discover new ones.</p><p>• While our earlier work on model-based security testing for OAuth2.0 (OAuthTester) <ref type="bibr" target="#b45">[49]</ref> has the potential, at least in theory, to discover all the vulnerabilities listed in <ref type="table" target="#tab_3">Table 2</ref>, our testing shows that OAuthTester can only detect two out of the seven types of vulnerabilities (TLS and state misuse) listed. This is because some vulnerabilities discovered by S3KVetter can only be triggered under very specific conditions. Without the source code, it is very difficult for blackbox-testers (like <ref type="bibr" target="#b45">[49]</ref>) to uncover such fine-grain, condition-specific problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Case Study of Vulnerabilities Discovered</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Access token Injection</head><p>As the result of SSO, an access token is issued to the RP. Based on the access token, the RP can identify the user. The authenticity of the access token is therefore a critical security requirement. As such, many IdPs (e.g., Facebook, Sina) have provided an access token-debug API for RPs to verify the access tokens they received. This API is heavily used by RPs running the implicit flow <ref type="bibr" target="#b9">[13]</ref> but seldom by those implementing the authorizationcode flow. This is because an access token obtained via the authorization-code flow is generally believed to be secure by SDK developers or IdPs. Such belief is based on the fact that, under the authorization-code flow, the access token is exchanged over a secure TLS connection routed directly between the IdP and RP, without passing through the mobile (client) device which may be controlled/ tampered by the attacker. However, we will show that an access token obtained using the authorizationcode flow can still be insecure under the presence of the so-called "access token injection" vulnerability. This vulnerability is caused by the ill-conceived design of SSO SDKs. For any RP using a SDK with the "access token injection" vulnerability, an attacker can remotely inject any access token of her choice to the vulnerable RP. As a result, as long as the attacker can obtain a valid (but different) access token of Alice (e.g., by luring Alice to login to a malicious RP controlled by the attacker), the attacker can log into the vulnerable RP as Alice. self.mac_key = resp.get('mac_key')</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Vulnerability Analysis</head><p>Below, we use OAuthLib <ref type="bibr" target="#b17">[21]</ref>, a popular SDK with more than 6 million downloads, to illustrate this vulnerability. When the IdP passes the code parameter to the RP in</p><p>Step 5 of <ref type="figure" target="#fig_1">Fig. 1</ref>  <ref type="figure">Figure 7</ref>: Exploit for access token injection is a secure channel and the state parameter to protect against CSRF attacks. Thereafter, it calls the function of populate attributes to populate/ store some commonly used variables for later use. However, if this function is not carefully designed, an attacker can control the value to be stored.</p><p>As presented in Listing 2, this SDK stores the value of code if it exists in the response resp (i.e., Step 5 in <ref type="figure" target="#fig_1">Fig 1)</ref>. Surprisingly, if the response resp contains access token, its value is also stored. More specifically, if an attacker feeds the URL input shown in Listing 3 to the RP in Step 5, an attacker-controlled access token is stored by the SDK and used for authentication later on. In this case, two security properties are violated. Firstly, Clause 4 is violated since the victim RP uses the access token issued to mRP. Secondly, Clause 6 is also violated: the IdP believes the current user is the attacker while the RP thinks she/ he is the victim.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Listing 3: An Exploit URL for Access Token Injection</head><p>https://RP.com?state=xxx&amp;code=fake code &amp;access token=victim access token at mRP</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.2">Exploit</head><p>The exploit only requires the attacker to obtain Alice's access token, e.g., via a malicious RP. As presented in <ref type="figure">Fig 7,</ref> the attack procedure is as follows:</p><p>1-4. The attacker logs into a victim RP using her own IdP account and her own device. 5. The attacker intercepts and substitutes the normal response with an invalid code as well as the victim Alice's access token of mRP. 6. After verifying the response, the SDK stores the code and Alice's access token. The SDK then makes a token exchange request with this fake code. 7. Since the code is invalid, the IdP returns error.</p><p>Therefore, the previously stored access token will not be overwritten. 8. The RP retrieves the user data using Alice's access token. 9. The IdP returns Alice's user information and thus the attacker can log into the victim RP as Alice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Refresh token Injection</head><p>For SSO protocols, an access token often has a short lifespan, just enough to cover the typical duration of a login session. Thereafter, the RP will need to prompt the user to perform re-authorization, which can degrade user experience. To avoid this problem, it is common for an IdP to issue another long-term "refresh token" to the RP, together with the initial access token. The RP can subsequently use the refresh token to request a new access token from the IdP without user intervention. As such, the mishandling of this refresh token can have severe security consequences similar to that of the access token. It is generally believed that the refresh token is secure since it is delivered over a secure channel (together with the access token) in Step 7 of <ref type="figure" target="#fig_1">Fig. 1</ref>. Meanwhile, some SDK developers have enough security expertise and realize the risk of directly storing the value from the end-user (e.g., the access token injection vulnerability). Therefore, these SDK developers attempt to pre-process the user input and stores it only after it has passed the security checkings.</p><p>Despite these seemingly strict security checks, we will show that the so-called refresh token injection vulnerability is still possible. This vulnerability enables an attacker to specify any refresh token of her choice and then login as the victim. Below, we use the Request-OAuthLib SDK, which supports auto-tokenrefresh mechanism, to illustrate the problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Vulnerability Analysis</head><p>This vulnerability, though superficially similar to the access token injection, is actually more complicated. The first step is similar: this SDK checks the refresh token in Step 5 of <ref type="figure" target="#fig_1">Fig. 1</ref>, and if exists, stores it in the variable of oauth. client.refresh token. The difference is that this SDK realizes such a variable is highly security sensitive and attempts to apply more secure measures to protect/ verify it (but still fails). Such attempts are presented in Listing 4 with much simplification for the ease of presentation.</p><p>Specifically, this SDK first checks whether there is a refresh token either in the arguments provided by the API caller or in the oauth.token object delivered via a secure server-to-server communication. Unfortunately, the former by default is None and the latter can be indirectly manipulated/ controlled by the attacker. For example, the attacker can feed an invalid code in Step 5 of <ref type="figure" target="#fig_1">Fig. 1</ref> so that the oauth.token object will not be overwritten by a refresh token exchanged with the IdP server. In this case, oauth.token will use its default value None. As such, the attacker can invoke the prepare refresh body function with an argument of refresh token = None. The prepare refresh body function therefore has no choice but to use the attackercontrolled variable of oauth. client.refresh token.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Exploit</head><p>There exist multiple exploits for this vulnerability. Below, we present one exploit which requires the least capability of the attacker (Eve): As long as Eve can obtain Alice's refresh token associated with a malicious RP (run by Eve), Eve can login as Alice to any RP which uses the vulnerable SDK (as shown in <ref type="figure">Fig. 8</ref>):</p><p>1-4. The attacker follows the normal protocol flow to log into the victim RP using her own IdP account with her own device. 5. When the IdP returns an authorization code, the attacker then injects the victim's refresh token. 6. Once the access token expires, the SDK will automatically renew the access token using Alice's refresh token. 7. The IdP then returns Alice's access token to the RP according to the refresh token. When the RP uses this newly obtained access token to retrieve the user data, the IdP will return the victim's information. The damage depends on how the user data is utilized. In the worst case where the user data is for authentication, the attacker can log into the vulnerable RP as the victim user.</p><p>Note that the above exploit only works for those IdPs (e.g., Fitbit) which do not require client secret in Step 6 of <ref type="figure">Fig. 8</ref>. For specification-compatible IdPs requiring this parameter, we need to assume a stronger threat model: the attacker can obtain the victim's refresh token issued for the vulnerable RP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Use-before-assignment of state</head><p>To thwart CSRF attacks, the OAuth2.0 specification <ref type="bibr" target="#b19">[23]</ref> strongly suggests the use of the state parameter, which should be generated and handled as a nonce. Note that the process of the state parameter is tightly related to  <ref type="figure">Figure 8</ref>: Exploit for refresh token injection session management, for which the application developers have multiple options. It is therefore difficult for the SDK, which is supposed to define the core functionality only, to consider the different operations among numerous session management tools. This may explain why 9 out of 10 SDKs (see <ref type="table" target="#tab_3">Table 2</ref>) are vulnerable to different existing attacks related to the state parameter: These SDK developers often rely on the RP developers to implement the state parameter by themselves. Unfortunately, as shown in <ref type="bibr" target="#b45">[49]</ref>, 55% RP implementations fail to handle this state parameter correctly.</p><p>Towards this end, the Request-OAuthlib SDK pays considerable attention to carefully implement the state parameter and has fixed all previously known vulnerabilities associated with this parameter. Unfortunately, the fix itself unexpectedly contains a new bug, making CSRF attack possible again (but in a different way). By leveraging the CSRF attack, the attacker can either spoof the victim's personal data <ref type="bibr" target="#b39">[43]</ref> or control the victim's RP account <ref type="bibr" target="#b45">[49]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.1">Vulnerability Analysis</head><p>Listing 5 presents the vulnerable code snippet when using the state parameter. It contains three key functions: init(), callback() and profile(), which correspond to Req0, Req1 and Req2 in <ref type="figure" target="#fig_1">Fig. 1,</ref> respectively. When the user clicks the "login with Facebook" button, the browser will send Req0 to the RP server and invokes the "init" function. This function generates an authorization URL (Line 5) which includes a random state parameter to prevent CSRF attacks: Upon receiving Req1, the "callback" function will be invoked to parse and verify auth response. In particular, it compares the state parameter generated in Line 4 and the one in the auth response in Line 17 (which was stored in the params variable). In case of mismatch, an error will occur.</p><p>At a first glance, the program appears to be correct. However, a so-called "use-before-assignment" vulnerability of the state variable exists. Specifically, if an attacker skips Req0 (thus "init" function does not get executed), and instead directly sends Req1 to invoke the ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>17</head><p>if state and params.get("state", None) !=state:</p><p>18 raise MismatchingStateError() "callback" function, then the first occurrence of state in Line 17 becomes the default value, i.e., None. As a result, the program will not check the second condition (params.get("state", None) ! = state). Instead, it directly exchanges for an access token (as long as the other fields in Step 6 of <ref type="figure" target="#fig_1">Fig. 1</ref> are valid).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.2">Exploit</head><p>This vulnerability allows an attacker to bypass the verification of the state parameter and thus makes CSRF attacks possible again. The exploit is presented in <ref type="bibr" target="#b39">[43]</ref> (Section 4.4). Specifically, an attacker performs the following steps:</p><p>1. Sign into an RP using her own account from the IdP, 2. Intercept the code on her browser (Step 5 in <ref type="figure" target="#fig_1">Fig 1)</ref> and then, 3. Embed the intercepted code in an HTML construct (e.g., img, iframe) that causes the browser to automatically send the intercepted code to the RP's sign-in endpoint when the exploit page is viewed by a victim user. This vulnerability can have high security implication, ranging from sniffing the victim's activity at the vulnerable RP via a "login CSRF" attack <ref type="bibr" target="#b4">[8]</ref>, to controlling the victim's RP account by account hijacking attack <ref type="bibr" target="#b22">[26]</ref>. When it is combined with the amplification attack via Dual-Role IdPs <ref type="bibr" target="#b45">[49]</ref>, the consequence can be even more severe. Refer to the above references for details of the corresponding exploits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Bypass MAC key Protection</head><p>SSO protocols support two usage types for an access token: the commonly used bearer token and the yet-to-bestandardized MAC token. <ref type="figure" target="#fig_1">Fig. 1</ref> shows the standard use of the bearer token: any party in possession of an access token can retrieve the user data hosted by the IdP. Therefore, if the access token is disclosed (e.g., via eavesdropping or insecure storage), an attacker can directly login as the token owner <ref type="bibr" target="#b9">[13]</ref>. To protect the access token against leakage, more and more IdPs (e.g., Facebook, Sina, etc.) start to support the MAC token.</p><p>The MAC token protocol is supposed to be more secure by signing the original bearer token. Specifically, in Step 7 of <ref type="figure" target="#fig_1">Fig. 1</ref>, MAC-token-enabled IdPs will return a random secret key 10 along with the access token to the RP. When making user-profile requests, the RP needs to compute a cryptographic hash message (e.g., HMAC-SHA-256) to prove its possession of the secret key. Only if both the hash value (MAC) and the access token are valid would the IdP return the user data to the RP. Unfortunately, some SDKs cannot implement this function correctly. As a result, the purpose of MAC token is totally broken.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.1">Vulnerability Analysis and Exploit</head><p>As presented in Listing 2, an attacker can specify any secret key of her choice using the following input: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Lessons Learned</head><p>Least privilege. We find that the aforementioned vulnerabilities are largely caused by the failure of the SDK developers in adhering to the principle of least privilege. Specifically, during each message exchange, the SDK 10 Previously, the secret key was the app secret, which is generated when the RP registers in the IdP platform. But the updated draft has made it a session secret and will be delivered upon every authorization request. developer should design a separate function to store the corresponding variable/ parameter so that the SDK can easily decide whether a variable/ parameter can be accessed and/or altered by the user or not. However, many SDK developers, for simplicity, store all key variables/ parameters using one single function. Furthermore, this function can be invoked by the user. As a result, even if the SDK developers attempt to filter out the userprovided variables, an intelligent attacker can still manipulate sensitive variables (e.g., access token, refresh token) that she should not be allowed to.</p><p>Less is more. Another observation is that the more IdPs/ functions a SDK supports, the more susceptible it would be. The reason is that, since the SSO specifications only serve as a high-level guideline, IdPs typically have various application-specific logic flows, unique APIs and security checks. To support multiple IdPs, a SDK will need to develop an additional layer to provide a new, generalized interface to glue various IdP-specific implementations together.</p><p>For example, the Request-OAuthLib SDK defines two objects (i.e., oauth. client and oauth.token) to manage the OAuth-related variables. When making requests to different IdPs, the SDK can thus retrieve the required variable from these two objects. Unfortunately, this generalized interface has enable the most important attack vector. would like to provide, the more vulnerable it can be. e.g., OAuthLib, Request-OAuthLib.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Related Work</head><p>SSO security analysis. Given the critical SSO services, extensive efforts have been devoted to their security analysis. Firstly, the protocol specification <ref type="bibr" target="#b19">[23,</ref><ref type="bibr" target="#b35">39]</ref> has been verified by different formal methods including model checking <ref type="bibr" target="#b1">[5,</ref><ref type="bibr" target="#b3">7,</ref><ref type="bibr" target="#b11">15,</ref><ref type="bibr" target="#b15">19,</ref><ref type="bibr" target="#b16">20,</ref><ref type="bibr" target="#b32">36]</ref>, manual analyses <ref type="bibr" target="#b24">[28,</ref><ref type="bibr" target="#b28">32]</ref> and cryptographic proof <ref type="bibr" target="#b7">[11]</ref>. These formal methods have uncovered different protocol design flaws. However, these methods are mainly used to prove the correctness (or find violations) of the specification. As a result, the discovered vulnerabilities may not be realistic and can be unexploitable (unlike ours). For example, al-though <ref type="bibr" target="#b15">[19]</ref> discovers the so-called 307 Redirect attack that allows an attacker to learn the victim's password in IdP, real-world SSO systems actually use 302 redirection instead.</p><p>Despite these theoretical works, the practical implementations of the protocols were often found to be incorrect due to the implicit assumptions enforced by the IdP SDKs <ref type="bibr" target="#b42">[46]</ref> or the incorrect interpretation of ambiguous specification <ref type="bibr" target="#b9">[13]</ref>. Towards this end, researchers start to analyze the security issues of real-world implementations. The most popular method relies on network traffic analysis <ref type="bibr">[25, 30, 43-45, 48, 49]</ref>, to infer a correct system model for guiding subsequent fuzzing. Another attempt was to analyze how the security issues of the underlying platform can affect the SSO security, as discussed in <ref type="bibr" target="#b9">[13,</ref><ref type="bibr" target="#b43">47]</ref>. Motivated by numerous types of vulnerabilities discovered by these methods, researchers have built different automatic tools <ref type="bibr" target="#b14">[18,</ref><ref type="bibr" target="#b29">33,</ref><ref type="bibr" target="#b47">51]</ref> to perform large-scale testing of SSO implementations against known classes of vulnerabilities. These studies do not consider the security of SDK internals and thus are different from ours in nature.</p><p>The work most similar to ours should be <ref type="bibr" target="#b42">[46]</ref> which identifies the implicit assumptions in order for an SSO SDK to be used in a secure way. However, their work requires labor-intensive code translation for each SDK. As a result, the scheme is not scalable and the resultant semantic model can be inaccurate. More importantly, they focus on how a SDK can be insecurely used while we concern the vulnerabilities of SDK internals, which can be exploited even if the RP developers strictly follow the Best Current Practices. can be insecure by itself.</p><p>SDK security analysis. Modern software is often developed on the top of SDKs. To detect the SDK usage errors, many different tools and methodologies have been proposed. Most of these works focus on checking whether the SDK follow a specification, which can be either manually specified (e.g., SSLint <ref type="bibr" target="#b20">[24]</ref>), extracted from code <ref type="bibr" target="#b1">[5]</ref> or learned from other libraries <ref type="bibr" target="#b31">[35,</ref><ref type="bibr" target="#b46">50]</ref>. However, all of them emphasize on the API invocation patterns. In contrast, relatively few efforts have been devoted to the security analysis on the SDK internals.</p><p>Asynchronous events studies. Previous research has shown that asynchronous events can lead to serious problems. <ref type="bibr">Petrov et al. [37]</ref> formulate a happens-before relation to strictly specify the web event orders (e.g., script loading should happen before execution) for detecting dangerous race-conditions in web applications. Such a happens-before relation was developed based on in-depth study of relevant specifications (e.g., those of HTML and Javascript) and browser behavior. As such, it is rather difficult to generalize their findings to cover other protocols. Furthermore, the happens-before relation cannot characterize the much more complicated security properties of multi-party SSO protocols. Another related work is CHIRON <ref type="bibr" target="#b23">[27]</ref>, which can detect semantic bugs of stateful protocol implementations by considering different request orders. However, CHIRON mainly focuses on two-party systems and cannot maintain a consistent system state for more general multiple party systems. As a result, the work cannot be readily applied to the 3-party SSO system.</p><p>Symbolic execution. Using systematic path exploration techniques, symbolic execution tools like KLEE <ref type="bibr" target="#b5">[9]</ref>, S2E <ref type="bibr" target="#b10">[14]</ref>, UC-KLEE <ref type="bibr" target="#b34">[38]</ref> are very effective in non-distributed software bug detection, especially for low-level memory corruption problems <ref type="bibr" target="#b37">[41]</ref> (but not for web apps). More recently, the symbolic execution approach <ref type="bibr" target="#b6">[10,</ref><ref type="bibr" target="#b27">31,</ref><ref type="bibr" target="#b36">40]</ref> has been extended to handle asynchronous apps (e.g., OpenFlow and sensor networks) where events of interest can occur at any time. However, previous extensions require expert-level domain knowledge and cannot be applied for general asynchronous apps. Researchers have also used symbolic execution to verify web applications (e.g., <ref type="bibr" target="#b8">[12,</ref><ref type="bibr" target="#b38">42]</ref>), but they did not consider challenges arise from multi-lock-step operations or the multi-party coordination. In contrast, S3KVetter has developed new techniques to test the implementations of multi-party protocols/ systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Conclusion</head><p>In this paper, we have presented S3KVetter, an automated testing tool which can discover logic bugs/ vulnerabilities buried deep in SSO SDKs by utilizing symbolic reasoning techniques. To better explore a 3-party SSO system, we developed new techniques for symbolic execution and realized them in S3KVetter. We have evaluated S3KVetter on ten popular SSO SDKs/ libraries which support different SSO protocols and modes of authorization grant flow. In addition to existing vulnerabilities, S3KVetter successfully discovers 4 new types of vulnerabilities, all of which can result in serious consequences including application account hijacking or user privacy leakage. Our findings demonstrate the efficacy of S3KVetter in performing systematic reasoning on SDKs and provide a reality-check on the implementation quality of popular "industrial-strength" SSO SDKs. We have reported the newly discovered vulnerabilities to all the affected vendors and have received various confirmations and acknowledgments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ITS/216/15), National Natural Science Foundation of</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Figure 1: OAuth 2.0 authorization code flow • Dash lines represent symbolic links that can be controlled by an attacker.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1</head><label>1</label><figDesc>Fig. 1 presents the authorization code flow of OAuth2.0. At a high level, the call flow consists of the following five phases: I. (Step 1-3) The user initiates the Single-Sign-On process with the RP and gives the IdP his approval regarding the permissions requested by the RP;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: S3KVetter architecture II. (Step 4-5) The IdP returns an intermediate proof (code) to the RP via the user; III. (Step 6-7) The RP approaches the IdP with this proof and its own credentials to exchange for an access token ; IV. (Step 8-9) The RP can then use this token to access the information of the user hosted by the IdP ; V. (Step 10-11) The user can then access his information hosted by the RP. Refer to Appendix A for detailed descriptions of the individual steps in Fig. 1. Notice that, from the perspective of the RP, the messages exchanged in Fig. 1 are typically handled by the SSO SDK. While we will use Fig. 1 as an illustrative example throughout this paper, our work actually goes beyond Fig. 1. For example, we will discuss the vulnerability associated with MAC key (Section 7.4) that is not presented in Fig. 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The Role of S3KVetter Fig. 3 shows the setup of the overall system in which S3KVetter simulates the client device to communicate with the RP server (i.e., SDK) and IdP server. S3KVetter also acts as the attacker to intercept and manipulate the victim's messages (e.g., via malicious RP or eavesdropping). These messages are then fed to the SDK for symbolic exploration. Since the open-source SDK is freely available online, the analyst can build a local RP server to symbolically explore the SDK.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: One example of symbolic predicate tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Figure 6: Illustration of multiparty coordination</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Listing 2 :</head><label>2</label><figDesc>Root Cause of Access Token Injection and Bypass MAC Key Protection in OAuthLib 1 def _populate_attributes(self, resp): 2 if 'code' in resp: 3 self.code = resp.get('code') 4 if 'access_token' in resp: 5 self.access_token = resp.get(' access_token') 6 if 'mac_key' in resp: 7</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Listing 4 :</head><label>4</label><figDesc>Attempts to Filter User Input 1 def refresh_token(self, refresh_token = None, ** kwargs): 2 # self.token is the oauth.token object 3 refresh_token = refresh_token or 4 self.token.get(@'refresh_token'@) 5 ... 6 body = self._client. prepare_refresh_body(body=body, refresh_token=refresh_token, scope =self.scope, ** kwargs)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Listing 5 :</head><label>5</label><figDesc>Root Cause of Use-before-Assignment of State Variable 1 oauth = OAuth2Session(client_id,...) 2 @app.route("/") 3 def init(): 4 auth_url, state = oauth. authorization_url(base_url) 5 return redirect(auth_url) 6 @app.route("/callback", methods=["GET"]) 7 def callback(): 8 token = oauth.fetch_token(token_url, secret, auth_response=request.url) 9 session['oauth_token'] = token 10 return redirect(url_for('.profile')) 11 @app.route("/profile", methods=["GET"]) 12 def profile(): 13 return oauth.get('https://idp/user') 14 15 def fetch_token(token_url, secret, auth_response): 16</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>1</head><label></label><figDesc>Fig. 9 presents the exploit, which is similar to Fig. 7 with two exceptions: At Step 5, besides an invalid code and the victim's access token, the attacker also feeds a MAC key of mRP. At Step 8, the RP retrieves the user data using the victim's access token and the MAC value computed by the MAC key. Since the access token and MAC key are paired, the IdP returns the victim's user data to the RP for authentication.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Figure 9: Exploit for MAC key injection</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><head>Table 1 : Statistics of SDK under Study</head><label>1</label><figDesc></figDesc><table>SDK Names 
Lines of 
code 

# of 
downloads 

Grant flow 
under study 

Baseline with unmodified PyExZ3 
Improved result with S3KVetter 
# of path 
discovered 

statement 
coverage 

branch 
coverage 

# of bugs 
discovered 

# of path 
discovered 

statement 
coverage 

branch 
coverage 

# of bugs 
discovered 
Facebook SDK 
976 
602,291 
implicit 
8 
45% 
37% 
2 
40 
58% 
56% 
2 
Request-OAuthLib 
15432 
4,785,778 
code 
322 
37% 
31% 
0 
649 
42% 
35% 
2 
OAuthLib 
17917 
6,476,894 
code 
640 
41% 
33% 
1 
1282 
46% 
39% 
5 
Sinaweibopy 
800 
28,019 
code 
2 
43% 
39% 
2 
6 
47% 
44% 
2 
OAuth2Lib 
971 
not found 
code 
2 
73% 
68% 
0 
4 
83% 
77% 
1 
Rauth 
9241 
487,275 
code 
2 
41% 
34% 
2 
14 
43% 
36% 
2 
Python-weixin 
2736 
1,404 
code 
2 
32% 
29% 
2 
6 
38% 
35% 
2 
Boxsdk 
15277 
77,074 
code 
2 
44% 
37% 
2 
12 
55% 
47% 
2 
Renrenpy 
251 
10,387 
code 
2 
54% 
46% 
1 
12 
56% 
50% 
1 
Douban-client 
2092 
30,601 
implicit 
1 
49% 
52% 
2 
2 
62% 
60% 
3 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><head>Table 2 : Summary of Discovered Vulnerabilities</head><label>2</label><figDesc></figDesc><table>SDK 
Existing classes of vulnerabilities 
New classes of vulnerabilities 
Token 
substitution 

no check of 
TLS 

misuse or 
no use of state 

use-before-assignment 
of state variable 

Bypass MAC 
key protection 

refresh token 
injection 

access token 
injection 
Facebook SDK 
N 
Y 
Y 
N.A 
N.A 
N 
N 
Request-OAuthLib 
N 
N 
N 
Y 
N.A 
Y 
N 
OAuthLib 
Y 
N 
Y 
N.A 
Y 
Y 
Y 
Sinaweibopy 
N 
Y 
Y 
N.A 
N.A 
N 
N 
OAuth2Lib 
N 
N 
Y 
N.A 
N.A 
N 
N 
Rauth 
N 
Y 
Y 
N.A 
N.A 
N 
N 
Python-weixin 
N 
Y 
Y 
N.A 
N.A 
N 
N 
Boxsdk 
N 
Y 
Y 
N 
N.A 
N 
N 
Renrenpy 
N 
N 
Y 
N.A 
N.A 
N 
N 
Douban-client 
Y 
Y 
Y 
N.A 
N.A 
N 
N 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>China (NSFC) under Grant No. 61572415, the CUHK Technology and Business Development Fund (project no. TBF18ENG001), and Hong Kong S.A.R. Research Grants Council (RGC) Early Career Scheme/General Re</head><label>China</label><figDesc></figDesc><table>-
search Fund No. 24207815 and 14217816. 
</table></figure>

			<note place="foot" n="2"> We use SSO to represent these two protocols, if not specified otherwise. 3 For the ease of presentation, we use the terms IdP server and IdP, as well as, RP server and RP interchangeably.</note>

			<note place="foot" n="4"> For the web platform, mRP is a malicious web page. For mobile platforms, mRP can be an APK file installed on the victim&apos;s mobile device. Regardless, mRP does not require any privileged permissions.</note>

			<note place="foot" n="5"> We only consider OAuth-related paths without counting those noncore paths, e.g., those related to encoding.</note>

			<note place="foot" n="6"> For ease of presentation, we use the line number to represent the clause. For example, the clause in the first line is denoted as Clause 1.</note>

			<note place="foot" n="7"> CVC4 and Z3 perform very similarly in different benchmarks during the Satisfiability Module Theories (SMT) competition [4].</note>

			<note place="foot" n="8"> For the use-before-assignment of the state variable, the requirement is even simpler: the victim just needs to visit a malicious web page.</note>

			<note place="foot" n="4"> ... 11 Otherwise, the constraint solver needs to remember all the operations on the entire symbolic input.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements and Responsible Disclosure</head><p>We thank our shepherd Prof. Cristina Nita-Rotaru and the anonymous reviewers for their valuable comments which help to improve the paper considerably. This work is supported in part by the Innovation and Technology Commission of Hong Kong (project no.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Marking Symbolic Variables</head><p>Given the marked sample app, S3KVetter must identify which (ranges of) symbolic input fields (e.g., the entire request.url or just the code in Listing 6) determine a path and then extracts all the path constraints related to these fields. To reduce the overhead for the constraint solver 11 , we maintain each input field as an individual symbolic variable (e.g., code, state) once these fields are split or decoded. Yet, we still allow byte-level access to the entire symbolic input (e.g., request.url) in case we cannot identify input fields correctly. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Requests-Oauthlib</surname></persName>
		</author>
		<ptr target="https://github.com/requests/requests-oauthlib" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">AUTHSCAN: automatic extraction of web authentication protocols from implementations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bai</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Venkatraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dong</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Deconstructing dynamic symbolic execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dependable Software Systems Engineering</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page">26</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Discovering concrete attacks on website authorization by formal analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bansal</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bhargavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maffeis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSF</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Robust defenses for cross-site request forgery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Jackson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mitchell</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Unassisted and automatic generation of high-coverage tests for complex systems programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cadar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dunbar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Klee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Operating System Design and Implementation (OSDI 08)</title>
		<meeting>Operating System Design and Implementation (OSDI 08)</meeting>
		<imprint>
			<biblScope unit="page" from="209" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A nice way to test openflow applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Canini</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Venzano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Peresini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kostic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rexford</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<idno>no. EPFL-CONF- 170618</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX Symposium on Networked Systems Design and Implementation (NSDI)</title>
		<meeting>the 9th USENIX Symposium on Networked Systems Design and Implementation (NSDI)</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Universally composable security analysis of OAuth v2.0. Cryptology ePrint Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chari</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jutla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Symbolic security analysis of ruby-on-rails web applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chaudhuri</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Foster</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">OAuth demystified for mobile application developers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">Y</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pei</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kotcher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tague</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="892" to="903" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">S2E: A platform for in-vivo multi-path analysis of software systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chipounov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Candea</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An expressive model for the web infrastructure: Definition and application to the Browser ID SSO system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K ¨ Usters</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">And</forename><forename type="middle">G</forename><surname>Schmitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symp. on Security and Privacy</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The unix process identity crisis: A standards-driven approach to setuid</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dittmer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tripunitara</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2014 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="1391" to="1402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ferrero</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Oauth2lib</surname></persName>
		</author>
		<ptr target="https://github.com/NateFerrero/oauth2lib" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Security evaluation of the OAuth 2.0 framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ferry</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>O&amp;apos;raw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Curran</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. &amp; Comput. Security</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="73" to="101" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A comprehensive formal security analysis of OAuth 2.0</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fett</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Usters</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schmitz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The Web SSO Standard OpenID Connect: In-Depth Formal Security Analysis and Security Guidelines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fett</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Usters</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schmitz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 30th Computer Security Foundations Symposium (CSF</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gazit</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Oauthlib</surname></persName>
		</author>
		<ptr target="https://github.com/idan/oauthlib" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Dart: directed automated random testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Godefroid</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Klarlund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Sigplan Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">The OAuth 2.0 authorization framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hardt</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>RFC 6749</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Vetting SSL usage in applications with SSLint</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Rastogi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Venkatakrish-Nan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security and Privacy (S&amp;P)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="519" to="534" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">The Achilles Heel of OAuth or Why Facebook Adds Special Fragment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Homakov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">The Most Common OAuth2 Vulnerability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Homakov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Analyzing operational behavior of stateful protocol implementations for detecting semantic bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hoque</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Chowdhury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Chau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">Y</forename><surname>Nitarotaru</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Application impersonation: problems of OAuth and API design in online social networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the second ACM conference on Online social networks</title>
		<meeting>the second ACM conference on Online social networks</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Social login continues strong adoption</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Janrain</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jing</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Covert Redirect</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vulnerability</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Deriving state machines from tinyos programs using symbolic execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kothari</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Govindan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th international conference on Information processing in sensor networks</title>
		<meeting>the 7th international conference on Information processing in sensor networks</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="271" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Do not trust me: Using malicious IdPs for analyzing and attacking Single Sign-On</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mainka</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mladenov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schwenk</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security and Privacy (EuroS&amp;P)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="321" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Sok: Single sign-on security-an evaluation of openid connect</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mainka</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mladenov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Schwenk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wich</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EuroS&amp;P</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">On the security of modern Single Sign-On protocols: OpenID Connect</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mladenov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Mainka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Krautwald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Feldmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schwenk</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<idno>1.0. CoRR</idno>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Mining preconditions of APIs in large-scale code corpus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nguyen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</title>
		<meeting>the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="166" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Formal verification of OAuth 2.0 using Alloy framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pai</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Singh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Communication Systems and Network Technologies (CSNT)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Race detection for web applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Petrov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Vechev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sridharan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dolby</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Sigplan Conference on Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="251" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Under-constrained symbolic execution: Correctness checking for real code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ramos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="49" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sakimura</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Bradley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>De Medeiros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mortimore</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<imprint/>
	</monogr>
	<note>OpenID Connect core 1.0</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Kleenet: discovering insidious interaction bugs in wireless sensor networks before deployment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sasnauskas</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Landsiedel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Alizai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Weise</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kowalewski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wehrle</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM/IEEE International Conference on Information Processing in Sensor Networks</title>
		<meeting>the 9th ACM/IEEE International Conference on Information Processing in Sensor Networks</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="186" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Augmenting fuzzing through selective symbolic execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephens</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Grosen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Salls</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dutcher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Corbetta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vigna</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Driller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium</title>
		<meeting>the Network and Distributed System Security Symposium</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Detecting logic vulnerabilities in e-commerce applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sun</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">The devil is in the (implementation) details: an empirical analysis of OAuth SSO systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sun</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Beznosov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Vulnerability assessment of OAuth implementations in Android applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACSAC</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Signing me onto your accounts through Facebook and Google: A traffic-guided security study of commercially deployed Single-Sign-On web services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">S&amp;P</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Explicating SDKs: Uncovering assumptions underlying secure authentication and authorization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gurevich</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Breaking and fixing mobile app authentication with OAuth2.0-based protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACNS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Signing into one billion mobile app accounts effortlessly with OAuth 2.0</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Black Hat</title>
		<meeting><address><addrLine>Europe</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Model-based security testing: An empirical study on OAuth 2.0 implementations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AsiaCCS</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">APISan: Sanitizing API usages through semantic cross-checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yun</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Naik</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th USENIX Security Symposium (USENIX Security</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Automated testing of web applications for Single Sign-On vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evans</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ssoscan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
