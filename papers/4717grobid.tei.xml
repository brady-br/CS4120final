<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:29+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automatic Generation of Compact Printable Shellcodes for x86</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dhrumil</forename><surname>Patel</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Dhirubhai Ambani Institute of Information and Communication Technology</orgName>
								<orgName type="department" key="dep2">Dhirubhai Ambani Institute of Information and Communication Technology</orgName>
								<orgName type="institution">Pennsylvania State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aditya</forename><surname>Basu</surname></persName>
							<email>aditya.basu@psu.edu</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Dhirubhai Ambani Institute of Information and Communication Technology</orgName>
								<orgName type="department" key="dep2">Dhirubhai Ambani Institute of Information and Communication Technology</orgName>
								<orgName type="institution">Pennsylvania State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anish</forename><surname>Mathuria</surname></persName>
							<email>anish_mathuria@daiict.ac.in</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Dhirubhai Ambani Institute of Information and Communication Technology</orgName>
								<orgName type="department" key="dep2">Dhirubhai Ambani Institute of Information and Communication Technology</orgName>
								<orgName type="institution">Pennsylvania State University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Automatic Generation of Compact Printable Shellcodes for x86</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Shellcode is a sequence of executable instruction(s) that can be used to exploit vulnerable processes by injecting it into a processes address space. A typical shellcode comprises of printable (ex. &apos;a&apos;, &apos;{&apos;, &apos;/&apos;, etc) and non-printable bytes (ex. DEL, INS, etc). A way to inject these shellcodes into a processes address space is by leveraging a buffer overflow exploit. However defensive filters will drop non-printable bytes from program inputs, thereby rendering the shellcode exploit useless. In order to bypass these defensive filters, shellcodes with only printable characters can be used. However it is a non-trivial task to write printable shellcodes. For this reason researchers have come up with tools to convert arbitrary shell-codes into functionally equivalent printable shellcodes. One of the popular tools is based on the Riley Eller algorithm. One drawback of this algorithm is that the resultant shell-code is much larger than the original shellcode. In this paper we present a new encoding scheme which produces a much more compact (about ~40% smaller) printable shellcode as compared to the Riley Eller algorithm.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A shellcode is a stream of executable assembly instructions. These instructions are specific to a given architecture and are typically carriers of exploits which can be injected into vulnerable programs. The injection can happen due to vulnerabilities such as buffer overflows <ref type="bibr" target="#b11">[15]</ref>.</p><p>The range of byte values used by an arbitrary shellcode is 0x00 − 0xFF. This range includes both printable and nonprintable (binary) bytes. A common defense to protect against shellcode injection is to drop non-printable bytes from an input string when only printable bytes are expected. Some examples of such input include name, email address, phone number, etc.</p><p>The range of printable characters is 0x21−0x7E. A general piece of executable code will contain a mix of printable and binary bytes. On x86 systems, the printable bytes 1 form <ref type="bibr" target="#b6">[10,</ref><ref type="bibr" target="#b12">16,</ref><ref type="bibr" target="#b14">18]</ref> a Turing complete instruction set. However to construct a shellcode (or executable byte sequence) with only printable bytes is a non-trivial task.</p><p>A well-known method to convert x86 shellcodes into printable bytes was developed by <ref type="bibr">Riley Eller [12]</ref>. This method (also called the "SUB encoder") is used in the pen testing tool -Metasploit <ref type="bibr" target="#b0">[1]</ref>. The "SUB encoder" uses SUB, AND, PUSH, and POP instructions to convert (or encode) any arbitrary shellcode into printable shellcode 2 . A significant drawback of the "SUB encoder" is the larger size of the printable shellcode produced as compared to the input shellcode. Every four bytes of the original shellcode are encoded into three SUB instructions and one PUSH instruction -representing a total of 16 bytes. Hence the final printable shellcode is four times the size of the original shellcode (see <ref type="bibr">§5.2)</ref>.</p><p>Another method to produce printable shellcodes was developed by Zsolt Geczi and Peter Ivanyi. They created a compiler that takes an arbitrary shellcode as input and returns a printable shellcode with equivalent functionality as output <ref type="bibr" target="#b9">[13]</ref>. Their compiler is not publicly available but their paper describes their methodology (see §2.2). Their approach also results in a significantly larger printable shellcode as compared to the original shellcode.</p><p>In this paper we present a new encoding scheme and a companion tool to generate compact printable shellcode. One of the main distinguishing features of our tool (as compared to other printable shellcode generators) is the use of a runtime looped decoder similar to <ref type="bibr" target="#b6">[10,</ref><ref type="bibr" target="#b14">18]</ref>. Every two consecutive bytes are encoded into three printable bytes. At runtime, a decoding loop takes these three successive bytes and transforms them back into the two bytes of the original shellcode. The advantage of this new method is the smaller size of the printable shellcode as compared to the existing approaches of the "SUB encoder" as well as the instruction replacement scheme of Geczi and Ivanyi.</p><p>Other tools exist to convert arbitrary shellcodes into alphanumeric shellcodes such as the <ref type="bibr">Rix compiler [16]</ref>, Alpha Freedom compiler <ref type="bibr" target="#b6">[10]</ref> and Jan Wever's ALPHA3 compiler <ref type="bibr" target="#b13">[17,</ref><ref type="bibr" target="#b14">18]</ref>. The alphanumeric byte range (0x30-0x39, 0x41-0x5A, and 0x61-7A) is a subset of the printable byte range (0x21-0x7E). Hence all alphanumeric shellcodes are also printable. However we can produce smaller shellcodes, if we leverage the entire printable byte range instead of just the alphanumeric byte range. Our new scheme takes this aspect into consideration.</p><p>Researchers have also demonstrated how to convert binary shellcodes to English sentences <ref type="bibr" target="#b10">[14]</ref> that are valid x86 code. <ref type="bibr">Ding et al. [11]</ref> have demonstrated automatic construction of a printable return-oriented programing payload. However these result in much larger shellcode size. Our goal on the other hand is to produce shorter, but valid printable shellcode.</p><p>Our research contributions are as follows.</p><p>• Develop a new encoding scheme to produce more compact printable shellcodes as compared to existing methods.</p><p>• Develop a companion tool (called psc) to demonstrate the real world use of the new encoding scheme and perform relevant evaluations (refer to §5.2).</p><p>• Make the tool available for public use.</p><p>The rest of this paper is organized as follows. Section 2 discusses the existing methods for generating printable shellcodes. Section 3 describes our new encoding scheme. Section 4 presents the implementation details of the companion tool psc. Sections 5 details the correctness and performance evaluation of psc. We conclude in section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>In this section, we briefly describe the existing methods for converting arbitrary shellcodes to printable shellcodes. The first method uses arithmetic and stack operations to encode byte sequences. In the second method, every non-printable instruction is replaced with equivalent printable instruction sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Riley Eller Algorithm</head><p>This method is described in detail in Riley Eller's article <ref type="bibr" target="#b8">[12]</ref>. It is based on the following observation: "Any dword (4 bytes) can be derived from two or three SUB instructions whose operands are printable bytes". We refer to this method as SUB encoding. This method creates the original shellcode on the stack using SUB and PUSH instructions.</p><p>Let's say we want to derive the last four bytes of the classic shellcode: execv /bin/sh. The corresponding byte sequence is 0x89e3cd80. We use register EAX because this makes the SUB instruction's opcode and register encoding printable. The value of EAX is initially set to zero.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Listing 1: SUB Encoding</head><p># Each of the constants below are within the printable range 0x21-0x7E.</p><p>sub $0x256d6d2d , %eax sub $0x256d6d25 , %eax sub $0x34574225 , %eax push %eax</p><p>Because EAX is originally set to zero, after the first subtraction the value in EAX is 0xda9292d3. After the second subtraction the value in EAX is 0xb52525ae and finally after the last subtraction, the value in EAX is 0x80cde389.</p><p>EAX now contains 0x80cde389 and when we push the value onto the stack, it gets stored in the little-endian format. Hence the byte sequence on the stack becomes 0x89e3cd80. We have now successfully recovered the last four bytes of the original shellcode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Source to Source Conversion</head><p>Geczi and Ivanyi <ref type="bibr" target="#b9">[13]</ref> take a different approach to convert any arbitrary shellcode into printable shellcode. They replace all non-printable instructions with a sequence of printable instruction(s). To do this, they wrote a compiler that takes assembly code as input and produces assembly code as output. Assembling the output code enjoys the following properties:</p><p>1. It is functionally equivalent to the input code, and 2. When the output code is assembled, the executable code produced contains only printable byte sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Example code fragments</head><p>1. There are multiple ways to set register values to zero using printable byte sequences. We list one such approach in Listing 2.</p><p>Listing 2: Set EAX to zero push $0x46464646 pop %eax xor $0x46464646 , %eax 2. The MOV instruction can be used to copy data from one register to another register, or copy a 32-bit constant value to a register. The binary encoding of this instruction with such operands is not printable. An alternative way to do this copy operation is via PUSH and POP instructions as listed below. Copying a 32-bit constant value in register can be done by first copying zero in register and then incrementing / decrementing it as required. This method is inefficient especially for large numbers.</p><p>The reader is referred to the paper <ref type="bibr" target="#b9">[13]</ref> for printable sequences of instructions for the following types of instructions: arithmetic instructions, CMP instruction, JMP instruction, etc.</p><p>The primary drawback of this method is the large size of the printable shellcode. For example, a 38 byte shellcode to print an 8x8 square became 9837 bytes -after converting it to printable shellcode <ref type="bibr" target="#b9">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Proposed Algorithms</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Encoding Algorithm</head><p>We encode two successive bytes of the original shellcode into three successive printable bytes. The algorithm to achieve this transformation is described below.</p><p>1. If the size of the original shellcode is odd, then append byte 0x90 (nop instruction).</p><p>2. Now take 2 successive bytes (or 16 bits) of the original shellcode. Let the bits be b 0 through b 15 , where b 0 and b 8 are the most significant bits of the first and second bytes respectively.</p><p>3. Using the bits b 0 − b 15 , set the following immediate (IMM) bytes:</p><formula xml:id="formula_0">• IMM byte #1 = 0, 0, 0, 0, b 0 , b 1 , b 2 , b 3 • IMM byte #2 = 0, 0, b 4 , b 5 , b 6 , b 7 , b 8 , b 9 • IMM byte #3 = 0, 0, b 10 , b 11 , b 12 , b 13 , b 14 , b 15</formula><p>4. Add 0x3F to all the IMM bytes of the above step. The resultant bytes form the encoded output.</p><p>5. Repeat steps (2) to (4) for all pairs of bytes in the original shellcode.</p><p>6. Append 0x26 (or '&amp;') to the output which serves as an end marker (explained below). By construction, the minimum possible value of any IMM byte is 0x00 and the maximum possible value is 0x3F (when all the last six bits are set to 1). Hence the range of any IMM byte is 0x00 − 0x3F.</p><p>After adding 0x3F to the IMM bytes, the new range becomes 0x3F − 0x7E. This new range is a subset of the ASCII printable range of 0x21 − 0x7E. Hence we are guaranteed to convert all the bytes of the original shellcode to printable bytes.</p><p>The purpose of the end marker is to indicate the end of input. We can choose any character between 0x21 − 0x3E as an end marker because this range does not overlap with the encoded output range of 0x3F − 0x7E. For our tool, we choose 0x26 <ref type="bibr">(or '&amp;')</ref> as the end marker.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Decoding Algorithm</head><p>We read three consecutive printable shellcode bytes and decode them into two consecutive bytes. The algorithm to achieve this is described below. We will use the C bitwise operations: (left shift), &amp; (and) , and (right shift).</p><p>1. Read three consecutive bytes of the encoded shellcode.</p><p>Let these be B 1 , B 2 and B 3 .</p><p>2. If B 1 = 0x26, then the original shellcode has been completely recovered. Go to step (6).</p><p>3. Let R 1 and R 2 be the decoded shellcode bytes. These bytes are computed from the encoded bytes as follows.</p><p>•</p><formula xml:id="formula_1">R 1 = (B 1 4) + ((B 2 &amp; 0x3 f ) 2) • R 2 = (B 2 6) + (B 3 &amp; 0x3 f )</formula><p>4. Write R 1 and R 2 to the memory location of the recovered shellcode.</p><p>5. Increment the (read) pointer to the memory location of the encoded shellcode by 3.</p><p>6. Repeat steps (1) to (4) for all bytes of the encoded shellcode.</p><p>7. Jump to the start of the decoded shellcode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Analysis</head><p>Let n be the size of the original shellcode. Then the following formula represents the size of the encoded shellcode (in bytes).</p><p>size of encoded payload (in bytes) =</p><formula xml:id="formula_2">3 2 n + 1, if n is even 3 2 (n + 1) + 1, if n is odd</formula><p>We replace every byte pair of the original shellcode with three printable bytes. Hence we multiply n with 3 2 . If n is odd, then to create a pair from the last byte of the original shellcode, we add a NOP instruction. This is why we use (n + 1) when n is odd. Finally, we add 1 to account for the end marker.</p><p>Note that the final shellcode will also have the decoder loop prepended to the encoded shellcode; thereby increasing its size. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Printable Shellcode Compiler</head><p>Printable Shellcode Compiler (or psc) is comprised of an encoder and a printable run-time decoder. The encoder converts a given shellcode into printable form using the encoding algorithm presented in §3.1. The encoded shellcode (which is printable) cannot be executed directly. At run-time, before the resultant encoded shellcode can be executed, it needs to be decoded. For this purpose, a decoder is prepended to the encoded shellcode. This forms the entire printable shellcode emitted by psc.</p><p>When the printable shellcode is executed, the decoder iterates over the encoded shellcode and recovers 3 the original shellcode. Once the original shellcode is completely recovered, the control jumps to the recovered shellcode.</p><p>For the encoding process, we wrote a C program (Appendix A lists the source code) that takes an arbitrary shellcode as input and prints out the printable encoded shellcode on the console. Now a bash script prepends this encoded shellcode with a custom xor patcher and the runtime decoder to obtain the final printable shellcode.</p><p>The encoded shellcode is then prepended with the decoder to obtain the final printable shellcode. The final layout of the printable shellcode is shown in <ref type="figure" target="#fig_0">figure 1</ref>.</p><p>The decoder is handwritten in x86 assembly. The decoder recovers the original shellcode by undoing all the transfor- <ref type="bibr" target="#b2">3</ref> The recovery is done in memory. §4.1 explains this recovery process in detail.  The decoder code contains a few non-printable bytes. We encode these non-printable bytes using the xor patching technique illustrated in <ref type="bibr" target="#b12">[16]</ref>. More details are presented in §4.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ECX: Read Pointer</head><p>GNU's Portable Assembler (as) is used to assemble the decoder and generate the executable binary. The total size of the decoder (including the custom xor patcher) is 146 bytes. The decoder is independent of the input shellcode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Decoder Implementation</head><p>The flowchart in <ref type="figure" target="#fig_1">Figure 2</ref> describes the execution flow of the decoder. The initialization involves setting up the registers ECX and EDX. Register ECX points to the encoded shellcode and register EDX points to the memory where the recovered shellcode is written. In the loop body, three consecutive bytes are read from the encoded shellcode. Next, the decoding process (refer §3.2) transforms these three bytes into two bytes which are part of the recovered shellcode. These two recovered shellcode bytes are then written to memory pointed by EDX. This continues till the end mark ('&amp;') is read from memory pointed to by ECX. Once the end mark is encountered, the control jumps to the recovered shellcode.</p><p>The entire decoder assembly is listed in Appendix B. The rest of this section describes the important features of the decoder. During initalization, registers ECX and EDX are set to the appropriate memory locations. It is assumed that the beginning address of the encoded shellcode is present in register EAX <ref type="bibr" target="#b3">4</ref> . Register EAX is used to derive the value of ECX and EDX. The encoded shellcode starts after 73 bytes (or 0x49 bytes) from the current instruction. Hence register ECX is initialized to EAX + 0x49. The recovered shellcode is smaller than the encoded shellcode because three consecutive bytes get decoded into two consecutive bytes. Hence after decoding three bytes of the encoded shellcode, we replace the first two bytes with the recovered bytes. This means that we effectively overwrite the encoded shellcode which has already been decoded. The loop body performs the actual decoding process. After every iteration, the current encoded byte is checked for the end mark <ref type="bibr">('&amp;')</ref>. If the end mark is read, then the control jumps to the end of the payload because the payload has been successfully decoded. Otherwise the loop continues with the next iteration. Registers EAX and EBX are set to zero 5 . In the decoder loop body, registers AL and BL are loaded with the first and second bytes of the encoded shellcode respectively. The XOR instruction is used instead of MOV to make the instruction printable. Subsequently bitwise operations are used to decode the first byte of the original shellcode. This is written back to memory via the EDX register. Again EAX and EBX registers are set to zero <ref type="bibr">6</ref> . Subsequently the second and third bytes are loaded into the BL and AL registers respectively. These values are used to recover the second byte of the original shellcode. Again this value is written back to memory using the EDX register. After the current pair of bytes is successfully decoded, the read (ECX) and write (EDX) pointers are incremented and the control transfers to the beginning of the loop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Listing 6: Loop Condition</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Listing 7: First Byte Recovery</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Listing 9: Update Read and Write Pointers</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Making the Decoder Printable</head><p>Not every instruction of the decoder loop is printable. So in order to make all bytes printable, we use a custom XOR patcher based on the ideas of <ref type="bibr">Rix [16]</ref>. The XOR patcher replaces every non-alphanumeric byte in the decoder loop with an alphanumeric byte <ref type="bibr" target="#b4">7</ref> and emits an alphanumeric XOR instruction to patch (or recover) the replaced byte at runtime. The idea behind the XOR patcher algorithm is described below.</p><p>1. If byte B is printable, then skip the byte.</p><p>2. If byte B is less than 0x80 and non-printable, then find a and b such that a ⊕ b = B and a &amp; b are printable bytes. Byte B is replaced with one of a or b and the other byte is used in the XOR instruction to recover the original byte at run time. This XOR instruction is placed at the start of the decoding loop.</p><p>3. If byte B is greater than 0x80 and ¬B is printable, then replace B with ¬B. Now note that ¬B = 0xff⊕B. Hence we can again use XOR instruction to recover B at runtime.</p><p>4. If byte B is greater than 0x80 and ¬B is not printable, then ¬B is less than 0x80. Now we use step (2) to patch the byte (i.e. ¬B) using XOR instructions. Next we use step (3) to perform NOT on the the recovered byte.</p><p>The entire printable decoder code is listed in Appendix B. As discussed in this section, the printable decoder code starts off by initializing the required registers. After initialization, the XOR patcher takes over and recovers the decoder loop. Now the decoder loop runs and recovers the original shellcode. Once the original shellcode is completely recovered, the control is transferred over to the recovered shellcode and the exploit payload runs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Correctness</head><p>When we run the printable shellcode, the decoder runs first and it recovers the original shellcode. After recovering the shellcode, the decoder transfers the control over to the recovered shellcode. To test the correctness of the printable shellcode we need to verify the recovered shellcode. The verification entails performing a byte by byte comparison of the original shellcode with the recovered shellcode. Hence a successful verification means that the recovered shellcode exactly matches the original shellcode.</p><p>In order to test this, once the shellcode is recovered we jump to a small verification routine instead of performing <ref type="bibr" target="#b4">7</ref> Note that alphanumeric byte set is a subset of the printable byte set. a jump to the recovered shellcode. This verification routine sends a SIGTERM signal to itself (the same process). Next a signal handler runs which is aware of the location of the original shellcode and the recovered shellcode. The signal handler performs the byte-by-byte comparison to verify the shellcode recovery. In case of a mismatch between the original shellcode and recovered shellcode, the signal handler prints the mismatched bytes on the console. Listing 10 shows the code that is executed after recovery of the shellcode. This code first issues a syscall to retrieve the pid of the current process. Next the kill syscall is issued to send a SIGTERM to the retrieved pid. After executing this code at run time, the control transfers to the signal handler which in turn performs the shellcode verification.  The shellcodes have been taken from a publicly available database <ref type="bibr">[6]</ref>. Note that to actually run these shellcodes, we need to prepend the decoder loop. <ref type="table" target="#tab_4">Table 2</ref> does this (or total shellcode size) comparison.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Performance</head><p>The size of the decoder for SUB Encoder and psc are 29 and 146 respectively. Let the size of the original shellcode be n. Then output shellcode size (total) under SUB Encoding scheme is given by 29 + 16n/4. Also as mentioned in §3.3, the output size under psc is given by 146 + 3n/2.</p><p>For smaller shellcodes (n &lt; 45), SUB encoding scheme produces the most compact printable shellcode. However for larger shellcodes (n &gt; 45), psc produces more compact shellcodes. When the original shellcode size, n &gt; 200, psc yields about 40% − 50% smaller printable shellcode (in terms of size) than the SUB Encoding method.</p><p>Comparing psc with alphanumeric shellcode generators such as Jan Wever's ALPHA3 <ref type="bibr" target="#b13">[17,</ref><ref type="bibr" target="#b14">18]</ref>, psc is again more competitive for larger shellcodes (n &gt; 236). ALPHA3 requires two bytes to encode every byte of the original shellcode. On the other hand psc requires only one and a half bytes to encode every byte. This results in half a byte worth of savings for every byte in the original shellcode when using psc. However the runtime decoder of ALPHA3 is only 28 bytes long. Hence for shorter shellcodes (n &lt; 236), ALPHA3 produces more compact shellcodes 8 . Note that by definition all alphanumeric shellcodes are also printable. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>Currently the Riley Eller Algorithm (SUB Encoder) or the Source to Source Conversion algorithm can be used to generate printable shellcodes. Of the two, the SUB Encoder pro-8 For n = 236, the shellcode sizes of both psc and ALPHA3 are equivalent. duces the most compact printable shellcodes. In this paper, we present a new encoding algorithm that uses looped decoding to reduce the size of these auto-generated printable shellcodes. Our algorithm encodes two successive bytes of the original shellcode into three printable shellcode bytes. However this compact representation increases the complexity of the decoding algorithm, thereby increasing the decoder code size. However unlike the existing algorithms, our decoder loops over the printable shellcode and hence this increased decoder size gets amortized over the size of the entire shellcode. Results shows that we produce about 40% − 50% smaller printable shellcodes as compared to the SUB encoder (better of the two existing algorithms). In addition we also present a companion tool psc to demonstrate the real world feasibility of our algorithm. Appendices A and B list the source code of our tool. As part of future work, we intend to extend psc and add support for 64-bit architecture (x86_64).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Layout of Printable Shellcode</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Execution Flow of Decoder</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>#</head><label></label><figDesc>if byte == &amp;, then end of shellcode # else execute next instruction cmpb $0x26 , 0 x49 (%ecx) je end_of_payload</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>#</head><label></label><figDesc>Read first byte xorb 0 x49 (%ecx) , %bl # Recover first 4 bits inc %ebx shlb $4 , %bl # Read second byte xorb 0 x4a (%ecx) , %al # Recover last 4 bits inc %eax andb $0x3c , %al shrb $2 , %al xorb %bl, %al # Put recover byte back in memory mov %al, 0 x49 (%edx)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Listing 8 :</head><label>8</label><figDesc>Second Byte Recovery # Read second byte xorb 0 x4a (%ecx) , %bl # Recover first 2 bits inc %ebx shlb $6 , %bl # Read third byte xorb 0 x4b (%ecx) , %al # Recover last 6 bits inc %eax andb $0x3f , %al xorb %bl, %al # Put recover byte back in memory mov %al, 0 x49 (%edx)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Listing 11 :</head><label>11</label><figDesc>C Signal Handler / * size of runtime decoder + signal handler invoker * / #define E 164 void handler_function () { int i , j; for(i = 0, j = E; i &lt; n -1; i++ , j ++) if( original [i] != shellcode [j ]) printf (" Byte Num %d = %d\n" , i , original [i ]) ; exit (0) ; } Listing 11 shows the signal handler used to verify the cor- rectness of the recovered shellcode. The arrays original and shellcode point to the original shellcode (in binary form) and its printable shellcode form respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>EDX : Write Pointer</head><label>EDX</label><figDesc></figDesc><table>Initializer 

B1 = 0x26 

Recover first byte, 
R1 ← (B1 &lt;&lt; 4) + (B2 &amp; 0x3F) &gt;&gt; 2 

Recover second byte, 
R2 ← (B2 &lt;&lt; 6) + (B3 &amp; 0x3F) 

Recovered 
Shellcode 

Loop 

YES 

NO 

Write R1 to [EDX] 
Write R2 to [EDX+1] 

EDX ← EDX +2 
ECX ← ECX + 3 

Let, B1 ← [ECX] 
B2 ← [ECX + 1] 
B3 ← [ECX + 2] 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 1 compares</head><label>1</label><figDesc>the encoding performance of Riley Eller SUB Encoder and psc. psc has better encoding performance in each case because the size of encoded shellcode is smaller.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Encoding Performance (in bytes) 
Shellcode 
Orig. SUB 
Enc. 

psc 

execve /bin/sh [8] 
20 
80 
31 
add root user no-password to 
/etc/passwd and exit() [2] 

83 
326 
127 

copy /etc/passwd to 
/tmp/outfile [5] 

97 
350 
148 

bind 4444/TCP to shell 
(/bin/bash) [3] 

100 
395 
151 

download file and execute 
it [7] 

135 
534 
205 

fork HTTP Server on port 
8800/TCP [9] 

166 
632 
250 

reverse shell 
(localhost:8080/TCP) over 
SSL [4] 

422 
1686 634 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Total Size Comparison (in bytes) 
Shellcode 
Orig. SUB 
Enc. 

psc 

execve /bin/sh 
20 
109 
177 
add root user no-password to 
/etc/passwd and exit() 

83 
355 
273 

copy /etc/passwd to 
/tmp/outfile 

97 
379 
294 

bind 4444/TCP to shell 
(/bin/bash) 

100 
424 
297 

download file and execute it 135 
563 
351 
fork HTTP Server on port 
8800/TCP 

166 
661 
396 

reverse shell 
(localhost:8080/TCP) over 
SSL 

422 
1715 780 

</table></figure>

			<note place="foot" n="1"> Actually only alphanumeric bytes (which an even smaller subset printable bytes) are sufficient to form a Turing complete instruction set 2 We refer to shellcodes containing only printable bytes as &quot;printable shellcodes&quot;</note>

			<note place="foot" n="4"> If the starting address is present is another register, then the code can be appropriately modified.</note>

			<note place="foot" n="5"> This is omitted from the listed code fragment to avoid repetition. Refer to Listing 2. 6 This is omitted from the listed code fragment to avoid repetition. Refer to Listing 2.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank the reviewers for their valuable insights and feedback. Availability psc, its related scripts, and tutorials can be found at https: //github.com/dhrumil29699/Printable-Encoder/.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Encoder</head><p>encoder.c implements the encoding algorithm mentioned in §3.1. The source code of encoder.c is listed below: #include&lt; stdio .h &gt; #include&lt; string .h &gt; int main (int argc ,char ** argv ) { if( argc != 2) { fprintf ( stderr ," ./ encoder \"0 xcd0x80 ..\"( Shellcode )"); } int n = strlen ( argv <ref type="bibr" target="#b0">[1]</ref>) /4; int k = n; n = n + n %2; int e_n = ((3* n) /2) +2; unsigned char encoded <ref type="bibr">[ e_n ]</ref>; char temp <ref type="bibr" target="#b3">[4]</ref>; int i ,j; j = 0; char end = 0 x26 ; // &amp; characeter at the end of shellcode    </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Metasploit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Encoder</surname></persName>
		</author>
		<ptr target="https://www.rapid7.com/db/modules/encoder/x86/opt_sub/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shellcode</surname></persName>
		</author>
		<ptr target="https://www.exploit-db.com/shellcodes/43669" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shellcode</surname></persName>
		</author>
		<ptr target="https://www.exploit-db.com/shellcodes/46166" />
		<imprint>
			<biblScope unit="volume">4444</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Shellcode: connect back with ssl connection</title>
		<ptr target="https://www.exploit-db.com/shellcodes/17371" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Shellcode: download file and execute it</title>
		<ptr target="https://www.exploit-db.com/shellcodes/39389" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Shellcode: execve /bin/sh</title>
		<ptr target="https://www.exploit-db.com/shellcodes/46809" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automatic generation of compact alphanumeric shellcodes for x86</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aditya</forename><surname>Basu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anish</forename><surname>Mathuria</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nagendra</forename><surname>Chowdary</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Systems Security (ICISS)</title>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="399" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Automatic construction of printable returnoriented programming payload</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenbiao</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiao</forename><surname>Xing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ping</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhi</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bing</forename><surname>Mao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">9th International Conference on Malicious and Unwanted Software: The Americas (MALWARE)</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="18" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Bypassing msb data filters for buffer overflow exploits on intel platforms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Riley</forename><surname>Eller</surname></persName>
		</author>
		<ptr target="http://julianor.tripod.com/bc/bypass-msb.txt" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Automatic translation of assembly shellcodes to printable byte codes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zsolt</forename><surname>Géczi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Iványi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
			<publisher>Pollack Periodica</publisher>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="3" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">English shellcode</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><surname>Mason</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sam</forename><surname>Small</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabian</forename><surname>Monrose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Macmanus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM Conference on Computer and Communications Security, CCS &apos;09</title>
		<meeting>the 16th ACM Conference on Computer and Communications Security, CCS &apos;09</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="524" to="533" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Smashing the stack for fun and profit</title>
		<ptr target="http://phrack.org/issues/49/14.html" />
		<imprint>
			<date type="published" when="1996" />
			<publisher>Phrack</publisher>
			<biblScope unit="volume">49</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Writing IA32 alphanumeric shellcode</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rix</surname></persName>
		</author>
		<ptr target="http://phrack.org/issues/57/15.html" />
		<imprint>
			<date type="published" when="2001" />
			<publisher>Phrack</publisher>
			<biblScope unit="volume">57</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">J</forename><surname>Wever</surname></persName>
		</author>
		<ptr target="https://github.com/SkyLined/alpha3" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Writing IA32 restricted instruction set shellcode decoder loops</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">J</forename><surname>Wever</surname></persName>
		</author>
		<ptr target="https://web.archive.org/web/20041208202128/http://www.edup.tudelft.nl/~bjwever/whitepaper_shellcode.html" />
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
