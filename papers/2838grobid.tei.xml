<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:53+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Beyond Storage APIs: Provable Semantics for Storage Stacks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ramnatthan</forename><surname>Alagappan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vijay</forename><surname>Chidambaram</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thanumalayan</forename><surname>Sankaranarayana</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pillai</forename><forename type="middle">Aws</forename><surname>Albarghouthi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Remzi</forename><forename type="middle">H</forename><surname>Arpaci-Dusseau</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Beyond Storage APIs: Provable Semantics for Storage Stacks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Applications are deployed upon deep, diverse storage stacks that are constructed on-demand. Although many storage stacks share a common API to allow portabil-ity, application behavior differs in subtle ways depending upon unspecified properties of the underlying storage stack. Currently, there is no way to test whether an application will behave correctly on a given storage stack: corruption or data loss could occur at any point in the application lifetime. We argue that we require an expressive language for specifying the complex storage guarantees required by different applications. The same language can be used to write a high-level specification capturing the design of different storage-stack layers. Given the required guarantees , and the storage-stack specifications, we can prove that stacks constructed dynamically (by composing different storage-stack layers) provide the guarantees required by the application.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Modern applications are deployed in a variety of environments <ref type="bibr" target="#b1">[2,</ref><ref type="bibr">13,</ref><ref type="bibr" target="#b10">15,</ref><ref type="bibr" target="#b19">24,</ref><ref type="bibr" target="#b26">31]</ref>: on laptops, on mobile phones, on tablets, and on private and public clouds. Each environment involves a different storage stack: for example, the laptop might use the btrfs file system on top of a SATA drive <ref type="bibr">[10]</ref>, while the mobile phone might use F2FS on top of an SSD <ref type="bibr" target="#b9">[11,</ref><ref type="bibr" target="#b21">26]</ref>. With the advent of softwaredefined storage, we believe applications will soon be able to request and automatically obtain customized storage stacks <ref type="bibr" target="#b15">[20,</ref><ref type="bibr" target="#b20">25,</ref><ref type="bibr" target="#b27">32]</ref>. Amazon EC2 already does this at a coarse level by allowing users to specify the storage they require for each virtual machine <ref type="bibr" target="#b0">[1]</ref>. The day is not far off when storage stacks will be constructed on the fly, mixing and matching different layers like block re-mappers, logical volume managers, and file systems <ref type="bibr" target="#b34">[39,</ref><ref type="bibr" target="#b35">40]</ref>.</p><p>Users would like their applications to run on different environments without modification <ref type="bibr" target="#b1">[2]</ref>. In addition to reducing development effort (and bugs), application portability avoids vendor lock-in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr">14]</ref>, where an application is tied to a particular stack because it uses features unique to that stack. To achieve application portability, many vendors strive to provide API compatibility with popular vendors like AWS <ref type="bibr" target="#b8">[9,</ref><ref type="bibr">12]</ref>. For example, OpenStack uses the same API as Amazon's cloud services to allow users like Intel, Yahoo, and Walmart to easily port their applications from services like Amazon EC2 to OpenStack Nova <ref type="bibr" target="#b8">[9]</ref>.</p><p>Unfortunately, while a common API guarantees that applications will execute on different stacks, it does not guarantee that they will do so correctly. Most API specifications simply describe what operations are offered by the storage stack. The specifications do not describe the semantics offered by the system: for example, whether two operations are persisted in order or whether an operation is persisted atomically. Yet, recent work has shown that application correctness hinges on storage-stack semantics <ref type="bibr" target="#b29">[34,</ref><ref type="bibr" target="#b30">35,</ref><ref type="bibr" target="#b38">43]</ref>. For example, LevelDB <ref type="bibr" target="#b17">[22]</ref> required the rename of a file to be persisted before the unlink of another file. If the storage stack does not order these operations, it results in data corruption <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b29">34]</ref>.</p><p>Testing whether an application will behave correctly on a storage stack is challenging for two reasons. First, the guarantees that an application requires from storage are not well-specified; if the developer has only been testing on one platform, they may not even realize that their application depends on certain features of the platform. Our work on application crash vulnerabilities suggests that the required guarantees are complex, and cannot be expressed in simple binary checks or numeric limits <ref type="bibr" target="#b29">[34]</ref>. Second, modern storage stacks are composed of many layers (e.g., the Windows IO stack has 18 stackable layers <ref type="bibr" target="#b33">[38]</ref>). Each layer builds upon the guarantees given by lower layers to provide guarantees to higher layers. To identify the guarantees given by a dynamically composed stack, we have to examine the guarantees given by each layer in the stack.</p><p>We tackle each challenge by borrowing techniques from the programming languages community. First, we propose to specify complex storage guarantees in a formal language (such as Isar <ref type="bibr" target="#b37">[42]</ref>). We suggest that the same language could be used to specify the high-level design of each layer of the storage stack. Second, proof assistants (such as Isabelle <ref type="bibr" target="#b28">[33]</ref>) can be used to prove that the stack provides the guarantees required by the application. Just as a statement could be proved given a collections of axioms and theorems, we propose that guarantees required by applications could be proved given the guarantees offered by each storage-stack layer.</p><p>We believe such verification will be essential for software-defined storage in clouds and datacenters. When storage stacks are constructed on the fly, the correspond-  ing high-level specifications for different layers can be retrieved, and the guarantees of the resulting stack can then be compared with application requirements. Such checking can be used to construct the optimal storage stack (in terms of resource utilization or other metrics) that will satisfy the given application requirements.</p><p>In the rest of the paper, we first present a small study of bugs that occur when applications are ported to different storage stacks ( §2). We then describe in detail the challenges in verifying that a storage stack provides required application guarantees ( §3). We describe our experience in specifying the design of a simple two-layer storage stack in Isar, and using Isabelle to prove that the put operation in a simple key-value store is atomic ( §4). Finally, we describe remaining challenges in realizing this vision ( §5), discuss related work ( §6), and conclude ( §7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Portability Bugs</head><p>We now present a small selection of portability bugs: bugs that occur when applications are ported to different storage stacks. To find these bugs, we searched the public bug databases of projects deployed on different storage stacks. For example, Android is installed on a variety of mobile phones and tablets; thus, we expected to find portability bugs in Android. We also investigated applications run on cloud platforms like Google AppEngine, and in distributed settings like NFS. In addition to examining public bugs, we also performed experiments that revealed bugs on widely-used environments that loosely coupled local storage with cloud or remote storage. <ref type="table" target="#tab_1">Table 1</ref> lists eight application bugs that are caused by the storage stack failing to provide a guarantee required by the application. For each bug, we specify the setup in which it occurs, its consequence, and the root cause.</p><p>The first five bugs are listed in the public bug databases on Android, Google App Engine, and MySQL. They result from the stack not supporting certain operations (#1, #2), placing unexpected limits on resources (#3, #4), or returning unexpected error codes (#5).</p><p>The last three bugs were revealed in our experiments. Our work on application crash vulnerabilities <ref type="bibr" target="#b29">[34,</ref><ref type="bibr" target="#b30">35]</ref> demonstrated that applications such as Git <ref type="bibr" target="#b25">[30]</ref> and SQLite <ref type="bibr" target="#b31">[36]</ref> require ordering guarantees from the storage stack. For example, SQLite requires that its journal writes are persisted before checkpoint writes. SQLite orders these writes using fsync(). On a local file-system, this works perfectly: the writes are persisted in the required order on local storage. If the local storage is then synced to a remote location or cloud storage (as is widely done with <ref type="bibr">Dropbox [6]</ref>), the order in which the files are uploaded matters: a network outage could result in the remote location seeing inconsistent application state. Dropbox transfers files roughly based on file size <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>, while rsync seemingly transfers files sorted by name <ref type="bibr" target="#b2">[3]</ref>. Based on this, we conducted the following experiment: run the application inside a folder synced using Dropbox or rsync; perform an application operation such as inserting into SQLite database; emulate network outage while Dropbox or rsync is in the middle of the sync process; inspect application state in remote location. All three experiments resulted in application inconsistency and/or data corruption. Similar bugs would be caused for any application that requires ordering from the stack <ref type="bibr" target="#b29">[34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Avoiding Portability Bugs</head><p>To avoid portability bugs, we need to verify that the stack provides the storage guarantees required by the application. The first challenge is in identifying the required storage guarantees. The developers may be unaware that they are depending upon guarantees from the storage stack: hundreds of Linux applications (written for ext3) depended on data written to a file being persisted before its rename, and lost data when ext4 no longer provided this guarantee <ref type="bibr" target="#b13">[18]</ref>. Tools like ALICE <ref type="bibr" target="#b29">[34]</ref> can help the developer identify storage guarantees required by the application. Assuming that the application developer is willing to identify and describe the storage guarantees required, there remain two challenges: specifying the guarantees, and checking that it is provided by the stack.</p><p>Specifying Storage Guarantees. For some portability bugs, specifying the required guarantee is simple: for example, one could have a binary check for O DIRECT support. Specifying a minimum limit on resources like path names or file descriptors is also straightforward. In other cases, the storage guarantees required are complex. For example, Mercurial and LevelDB require that a file append (e.g. "XYZ") results in a prefix of the append data being persisted (e.g., "X" or "XY") <ref type="bibr" target="#b29">[34]</ref>. Many guarantees are of the form "if not A then B else C should hold", and cannot be easily expressed in the form of binary checks or numerical limits. Specifying storage guarantees thus requires a rich, expressive language.</p><p>Computing and Verifying Stack Guarantees. Modern storage stacks are comprised of several layers <ref type="bibr" target="#b33">[38]</ref>. The storage media at the bottom provides some basic guarantees. The layer above the media builds on these guarantees to provide more guarantees to the layer immediately above; thus, guarantees are built up over the stack and the top-most layer (e.g., a database) provides guarantees to the application (e.g., atomic transactions). Software-defined storage can dynamically add or remove stack layers like block re-mappers; calculating how the addition or removal of a layer from the stack affects storage guarantees requires understanding how that layer works (at least at a high level) along with the layers above and below. Therefore, we cannot statically assign guarantees to layers -it must be dynamically calculated.</p><p>Thus, verifying correct application behavior on a storage stack is a hard problem, requiring more sophisticated techniques than simple API compatibility tests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Verifying Storage Guarantees</head><p>We now describe how we envision a system that can prove that a storage stack has certain guarantees. We start by <ref type="figure">Figure 1</ref>: System Architecture. The figure shows a typical workflow -the application specification, correctness requirements, and storage stack configuration are obtained as input, appropriate specifications from the prebuilt library are selected, and finally, the required guarantees are proved/disproved. specifying the guarantees required by the application at the topmost layer of the storage stack, the working logic of each layer, and the guarantees provided by the lowermost layer. Using the guarantees of the lowermost layer and the specification of each higher layer, we can progressively calculate the guarantee provided at each layer. Finally, we can verify whether the guarantees at the topmost layer satisfy the application's requirements. <ref type="figure">Figure 1</ref> provides a high-level overview of the system. Specifying guarantees at the topmost layer and the working logic of all layers is not straightforward. Subsection 4.1 explains how we use the Isar formal proof language <ref type="bibr" target="#b37">[42]</ref> for solving this, and why we think this can be performed with reasonable effort in the future. Subsection 4.2 explains how we use the Isabelle proof assistant <ref type="bibr" target="#b28">[33]</ref> for computing and verifying the guarantees for each layer. Subsection 4.3 describes our experience in using Isar and Isabelle to prove that a simple key-value store operating on raw block storage provides atomic put() operations. We have made the Isabelle scripts described in this section available online <ref type="bibr" target="#b32">[37]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Specifying Storage-Stack Layers</head><p>The working logic specification of each layer essentially describes how an operation exposed by that layer works. For example, a file-system layer will expose how it performs operations like rename or unlink and a block layer will expose how it reorders write requests. Isar allows expressing specifications in terms of functions, and these specifications can then be used by proof-assistant tools. We have found the Isar language to be sufficient for specifying the guarantees and the working logic of storage stacks we have investigated so far. While writing specifications is made possible by Isar, the specifications can be complex; we found specifying the working logic of non-trivial storage layers to be a difficult process. However, in the future, we envision a library of specifications of widely used filesystems, hypervisors, and storage devices: users can simply plug-in the specifications, instead of writing them anew.</p><p>Users can provide a specification of the application, and then provide correctness requirements in terms of application-level operations (e.g., transactions must be atomic). Given the application specification, Isabelle can translate correctness requirements into storage guarantees. Alternatively, the required guarantees can be automatically obtained by using tools like ALICE <ref type="bibr" target="#b29">[34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Computing Storage Guarantees</head><p>Proof assistants like Isabelle can be used to generate proofs for statements in the context of axioms and theorems. We treat the storage guarantees required by the application as statements to be proved; the storage guarantees of the stack provide the axioms using which the statement should be proved. For multi-layers stacks, the guarantees given by each layer function as axioms for the layer above; the guarantees given by the storage media form the axioms for the lower-most layer.</p><p>When Isabelle is unable to prove the given statement, its response (which sometimes includes a counterexample) can be parsed to identify which layer in the storage stack is preventing the high-level property from being provided. Currently, we write machine-checked proofs by hand in Isabelle; in section 5, we discuss opportunities and challenges in constructing proofs in an automatic way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Example: Key-Value Store</head><p>Consider a key-value store that runs directly on top of block storage. The block storage provides 4K-block atomic writes and in-order block operations. We want to verify that the key-value store provides atomic put() operations in the presence of system crashes.</p><p>We first write a specification for the key-value store operations. For example, the specification describes how the put() operation is performed. The key-value store in our example writes small key-value pairs to a single block directly, but uses journaling for large key-value pairs. A dedicated portion of the disk is used as a journal, the update is written initially to this area, and then checkpointed to the actual disk location. If a crash happens, the keyvalue store tries to recover from the journal.</p><p>We then specify the guarantees provided by the block storage: 4K-block writes are atomic and ordered. This forms the set of axioms on top of which Isabelle builds proofs. Finally, we specify the application requirements using Isar: put() must be performed atomically, even in the case of a crash. This forms the correctness requirements that we will try to prove using Isabelle.</p><p>We break the proof into two parts: one for small keyvalue pairs that fit into a single block and the other for large key-value pairs that do not fit into a single block. For theorem atomic_only_for_one_block: assumes A0: "disk.length &gt; index" assumes A1: "disk != NULL" shows "key.length + value.length &lt;= block_size ==&gt; isatomicupdate disk (kv_put disk key value index)"</p><p>Listing 1: Atomicity theorem for update that spans one block. The listing shows the pseudocode theorem for atomicity of put() operation. isatomicupdate is a function that checks if two disks differ only by one block. Note that this listing is pseudocode and not exact Isabelle/Isar syntax.</p><p>the first part, we prove that if the key-value pair is smaller than a block, it will be written atomically; Listing 1 shows the corresponding logical statement expressed in Isabelle.</p><p>For the reader, this statement might be intuitive, since the underlying block layer provides atomic 4K-block writes. Nonetheless, proving this seemingly simple statement requires lot of effort.</p><p>For the second part of the proof, we proved that an update done using the journaling technique is always atomic with one exception: the update being larger than the journal. The atomicity guarantee of a put() operation that updates two blocks can be logically expressed as follows:</p><formula xml:id="formula_0">(final[i]=initial[i] ∧ final[j]=initial[j]) ∨ (final[i]=key ∧ final[j]=value),</formula><p>where initial is the state of the disk before the put() started, final is any disk state resulting from a crash while performing the put(), and i and j are the indexes updated. The above logical statement should hold for all possible final disk states. We also proved that the update is durable if the checkpoint is complete. We discovered that the proof effort required significantly varies depending on how the requirements are specified. As we gain experience with Isabelle proofs, we will be able to prove guarantees with considerably lesser effort.</p><p>This simple example illustrates a few key features about our system. First, given the specification of different stack layers, our system can find dependencies across layers, thus finding corner cases that may not be obvious to a human. Second, the system can be incrementally extended: the specification of each layer does not need to know how the layer below works. A new file system requires only one new layer. We believe this supports our vision of building a library of high-level specifications that can be used to verify guarantees of different storage stacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Challenges</head><p>We discuss the challenges that remain in realizing our vision of achieving application portability across diverse storage stacks.</p><p>Obtaining Specifications. We assume that the developers of the storage-stack layers will provide specifications along with the source code. Figuring out the specifica-tions without developer support will be hard; we take heart from the fact there are only a few choices available for each layer. For example, most stacks use one among a few popular file systems. Thus, a modest amount of manual work can create a library that can reused by a large number of storage stacks.</p><p>Interplay Between Layers. When a layer uses functionality from a lower layer, Isabelle can use the guarantees given by the lower layer to prove guarantees at the upper layer. However, this is currently done by directly using lower-level functions in the specification of the upper layer. Modifying this so that the upper layer uses a generic intermediate layer (like VFS), with parameters that select different lower layers, remains a significant challenge.</p><p>Automatically Proving Guarantees. Given the storagestack specifications and the application's correctness requirements, we can use Isabelle to automatically figure out what guarantees need to hold across layers for the requirement to be proved. Isabelle still requires the user to specify different strategies (e.g., induction) to try and prove the goal. For the proofs we have developed, Isabelle required (non-trivial) guidance in terms of what strategies to employ. In the future, we would like to model specifications and requirements in a fragment of first-order logic, and use SMT solvers (automated theorem provers) such as Z3 <ref type="bibr" target="#b14">[19]</ref> to automatically prove guarantees. Unlike Isabelle, using Z3 limits what we could prove automatically -we plan to carefully investigate this. The advantage of using Z3 is that it allows automatic verification without user involvement for dynamically changing stacks.</p><p>Proofs Without Layer Specifications. We currently assume that all layer specifications are publicly available. However, companies may be hesitant to reveal their layer specification publicly. Thus, we would require a way to prove that a stack provides certain guarantees, without having the specifications of the layers that comprise the stack. Akin to zero-knowledge proofs <ref type="bibr" target="#b16">[21]</ref>, we would need each layer to verify that they provide certain guarantees, while hiding the details of how exactly they provide each guarantee. Each layer only needs to know the guarantees associated with the operations exported by a lower layer, and not how the operations are implemented. Hence, we would still be able to prove the guarantees provided by the stack overall. Achieving this would allow application correctness to be verified on stacks composed of layers developed by many different companies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>Recent work has applied verification techniques to build verified operating system kernels <ref type="bibr" target="#b24">[29]</ref>, end-to-end security <ref type="bibr" target="#b18">[23]</ref> and in-kernel interpreters <ref type="bibr" target="#b36">[41]</ref>. Various efforts in the past have modelled and verified file-system implementations specifically. <ref type="bibr">Keller et al.</ref> observe that modern file systems are modular; this facilitates specifying each module (or on-disk data structure) formally and then generating code and correctness proofs <ref type="bibr" target="#b23">[28]</ref>. Arkoudas et al. formally specify a simple abstract file system and prove the implementation correct by establishing a simulation relation between the abstract specification and the implementation <ref type="bibr" target="#b11">[16]</ref>. Similarly, Kang et al. show how a flash-based file system can be formally verified <ref type="bibr" target="#b22">[27]</ref>. While such work focuses on verifying the file system in isolation, we aim to verify end-to-end application correctness on different storage stacks (of which file systems are only one component). Our methodology matches closely with a recent work to verify network-wide invariants of SDN applications by <ref type="bibr">Ball et al. [17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>To truly realize the potential of software-defined storage, infrastructure providers must construct customized storage stacks on demand that satisfy customer requirements while optimizing metrics such as utilization. A key part of satisfying the customer is verifying that the application will execute correctly on the constructed stack. In this paper, we have shown why this is challenging: applications depend on subtle guarantees of the underlying storage stack, that are more complex than the simple functionalities defined by typical API documentation. Logically specifying these guarantees, and verifying whether different layers can provide these guarantees, is a complex and unsolved problem. While we have taken the first steps in solving this problem, significant challenges remain. We hope future research tackles these challenges, thus making applications truly portable across diverse storage stacks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Portability Bugs. The tables lists bugs that occur when the storage stack doesn't provide features or guarantees required by 

the application. For each bug, the table shows the environment, the consequence, and the underlying root cause. The root causes vary from easily 
detectable issues like O DIRECT not being supported, to deeper issues like ordering guarantees not provided by the stack. 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank the anonymous reviewers and ADSL lab members for their insightful comments and feedback. This material is based upon work supported by the NSF grants CNS-1421033, CNS-1319405, and CNS-1218405 as well as generous donations from Cisco, EMC, Facebook, Google, Huawei, IBM, Microsoft, NetApp, Samsung, Seagate, and VMWare. Vijay Chidambaram is supported by a Microsoft Research PhD Fellowship. Any opinions, findings, and conclusions, or recommendations expressed herein are those of the authors and do not necessarily reflect the views of the NSF or other institutions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Amazon Instance Storage</surname></persName>
		</author>
		<ptr target="http://docs.aws.amazon.com/AWSEC-2/latest/UserGuide/InstanceStorage.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Application portability in action: A demonstration of cloud foundry core</title>
		<ptr target="http://www.centurylinkcloud.com/blog/post/portability-in-action-a-demonstration-of-cloud-foundry-core" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<ptr target="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=640492" />
		<title level="m">Debian Bug report logs. rsync: should not reorder the file names on the command line</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dropbox</forename><surname>Datastore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Api</forename></persName>
		</author>
		<ptr target="http://www.dropbox.com/developers/blo-g/78/datastore-api-growth" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dropbox</forename><surname>Sync</surname></persName>
		</author>
		<ptr target="https://www.dropbox.com/en/help/9" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dropbox</forename><surname>Git On</surname></persName>
		</author>
		<ptr target="http://stackoverflow.com/questions/1960799/using-git-and-dropbox-together-effectively" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">How to Avoid Cloud Vendor Lock</title>
		<ptr target="http://www.linuxinsider.com/story/79417.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
				<ptr target="https://code.google.com/p/leveldb/issues/detail?id=189" />
		<title level="m">Possible bug: fsync() required after calling rename(</title>
		<imprint>
			<biblScope unit="volume">189</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Openstack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Api</forename><surname>Compatibility</surname></persName>
		</author>
		<ptr target="http://docs.openstack.org/admin-guide-cloud/content/instance-mgmt-ec2compat.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
				<ptr target="http://arstechnica.com/gadgets/2014/09/review-in-its-second-generation-the-moto-x-becomes-a-true-flagship/3/" />
	</analytic>
	<monogr>
		<title level="m">its second generation, the Moto X becomes a true flagship</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Xamarin</surname></persName>
		</author>
		<ptr target="http://xamarin.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Verifying a file system implementation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konstantine</forename><surname>Arkoudas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karen</forename><surname>Zee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Viktor</forename><surname>Kuncak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Formal Methods and Software Engineering</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="373" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Vericon: Towards verifying controller programs in software-defined networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikolaj</forename><surname>Bjørner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aaron</forename><surname>Gember</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shachar</forename><surname>Itzhaky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aleksandr</forename><surname>Karbyshev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mooly</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schapira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Asaf</forename><surname>Valadarsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th ACM SIG-PLAN Conference on Programming Language Design and Implementation, PLDI &apos;14</title>
		<meeting>the 35th ACM SIG-PLAN Conference on Programming Language Design and Implementation, PLDI &apos;14<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="282" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">That massive filesystem thread</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Corbet</surname></persName>
		</author>
		<ptr target="http://lwn.net/Articles/326471/" />
		<imprint>
			<date type="published" when="2009-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Z3: An efficient smt solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leonardo</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikolaj</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Construction and Analysis of Systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="337" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<ptr target="ttp://www.emc.com/collateral/white-papers/h11749-transform-data-center-with-vipr-software-defined-storage-wp.pdf" />
		<title level="m">Rethink Storage: Transform the Data Center with EMC ViPR Software-Defined Storage</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The knowledge complexity of interactive proof systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shafi</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Silvio</forename><surname>Micali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Rackoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="186" to="208" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Leveldb</surname></persName>
		</author>
		<ptr target="https://code.google.com/p/leveldb/" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Ironclad apps: End-to-end security via automated full-system verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Hawblitzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jon</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><forename type="middle">R</forename><surname>Lorch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arjun</forename><surname>Narayan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bryan</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danfeng</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Zill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Revisiting Storage for Smartphones</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hyojun</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nitin</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristian</forename><surname>Ungureanu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Conference on File and Storage Technologies (FAST &apos;12)</title>
		<meeting>the 10th Conference on File and Storage Technologies (FAST &apos;12)<address><addrLine>San Jose, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Emerging Trends in Software Defined Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Infostor</surname></persName>
		</author>
		<ptr target="http://www.infostor.com/storage-management/virtualization/emerging-trends-in-software-defined-storage-1.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Seoungbum Son, and Youjip Won. I/o stack optimization for smartphones</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sooman</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kisung</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seongjin</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 USENIX Conference on Annual Technical Conference, USENIX ATC&apos;13</title>
		<meeting>the 2013 USENIX Conference on Annual Technical Conference, USENIX ATC&apos;13<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="309" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Formal modeling and analysis of a flash filesystem in alloy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eunsuk</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Abstract state machines, B and Z</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="294" to="308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">File systems deserve verification too</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabriele</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Toby</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sidney</forename><surname>Amani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O&amp;apos;</forename><surname>Liam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zilin</forename><surname>Connor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leonid</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gerwin</forename><surname>Ryzhyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gernot</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Heiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="58" to="64" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">sel4: Formal verification of an os kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gerwin</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Elphinstone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gernot</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">June</forename><surname>Andronick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Cock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><surname>Derrin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dhammika</forename><surname>Elkaduwe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Engelhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rafal</forename><surname>Kolanski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Norrish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harvey</forename><surname>Tuch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><surname>Winwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGOPS 22Nd Symposium on Operating Systems Principles, SOSP &apos;09</title>
		<meeting>the ACM SIGOPS 22Nd Symposium on Operating Systems Principles, SOSP &apos;09<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="207" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linus</forename><surname>Torvalds</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Git</surname></persName>
		</author>
		<ptr target="http://git-scm.com/" />
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Blizzard: Fast, cloud-scale block storage for cloud-oblivious applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Mickens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edmund</forename><forename type="middle">B</forename><surname>Nightingale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><surname>Elson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Darren</forename><surname>Gehring</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bin</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Asim</forename><surname>Kadav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vijay</forename><surname>Chidambaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Osama</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krishna</forename><surname>Nareddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th USENIX Symposium on Networked Systems Design and Implementation (NSDI 14)</title>
		<meeting><address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-04" />
			<biblScope unit="page" from="257" to="273" />
		</imprint>
	</monogr>
<note type="report_type">USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Netapp</surname></persName>
		</author>
		<ptr target="http://www.netapp.com/us/technology/software-defined-storage/" />
		<title level="m">NetApp Software-Defined Storage</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Isabelle/HOL: a proof assistant for higher-order logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tobias</forename><surname>Nipkow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Lawrence C Paulson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wenzel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>Springer</publisher>
			<biblScope unit="volume">2283</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">All File Systems Are Not Created Equal: On the Complexity of Crafting Crash-Consistent Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vijay</forename><surname>Thanumalayan Sankaranarayana Pillai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ramnatthan</forename><surname>Chidambaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samer</forename><surname>Alagappan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><forename type="middle">C</forename><surname>Al-Kiswany</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Remzi</forename><forename type="middle">H</forename><surname>Arpacidusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Arpaci-Dusseau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th Symposium on Operating Systems Design and Implementation (OSDI &apos;14)</title>
		<meeting>the 11th Symposium on Operating Systems Design and Implementation (OSDI &apos;14)<address><addrLine>Broomfield, CO</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Towards Efficient, Portable Application-Level Consistency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vijay</forename><surname>Thanumalayan Sankaranarayana Pillai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joo</forename><surname>Chidambaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><forename type="middle">C</forename><surname>Young Hwang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Remzi</forename><forename type="middle">H</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Arpacidusseau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Workshop on Hot Topics in Dependable Systems (HotDep &apos;13)</title>
		<meeting>the 9th Workshop on Hot Topics in Dependable Systems (HotDep &apos;13)<address><addrLine>Farmington, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">SQLite transactional SQL database engine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sqlite</surname></persName>
		</author>
		<ptr target="http://www.sqlite.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">The ADvanced Systems Laboratory (ADSL)</title>
		<ptr target="http://research.cs.wisc.edu/adsl/Software/verifiedstoragestacks/" />
		<imprint/>
	</monogr>
	<note>Verified Storage Stacks</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Ioflow: A software-defined storage architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eno</forename><surname>Thereska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hitesh</forename><surname>Ballani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O&amp;apos;</forename><surname>Greg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Shea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antony</forename><surname>Karagiannis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Rowstron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Talpey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles</title>
		<meeting>the Twenty-Fourth ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="182" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Software-Defined Storage (SDS) and Storage Virtualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vmware</surname></persName>
		</author>
		<ptr target="http://www.vmware.com/software-defined-datacenter/storage" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vmware</surname></persName>
		</author>
		<ptr target="http://www.vmware.com/files/pdf/solutions/VMware-Perspective-on-software-defined-storage-white-paper.pdf" />
		<title level="m">The VMware Perspective on Software-Defined Storage</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Jitk: a trustworthy in-kernel interpreter infrastructure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xi</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Lazar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nickolai</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Chlipala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zachary</forename><surname>Tatlock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX conference on Operating Systems Design and Implementation</title>
		<meeting>the 11th USENIX conference on Operating Systems Design and Implementation</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="33" to="47" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Isar-a generic interpretative approach to readable formal proof documents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Wenzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theorem Proving in Higher Order Logics</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="167" to="183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Torturing Databases for Fun and Profit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mai</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dachuan</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Feng</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Lillibridge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elizabeth</forename><forename type="middle">S</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bill</forename><forename type="middle">W</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shashank</forename><surname>Singh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th USENIX Symposium on Operating Systems Design and Implementation (OSDI &apos;14)</title>
		<meeting><address><addrLine>Broomfield, CO</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-10" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
