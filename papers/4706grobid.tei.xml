<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:29+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automatic Wireless Protocol Reverse Engineering</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johannes</forename><surname>Pohl</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Applied Sciences Stralsund</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">Andreas Noack University of Applied Sciences</orgName>
								<address>
									<settlement>Stralsund</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Automatic Wireless Protocol Reverse Engineering</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>ARTIFACT EVALUATED PASSED</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Internet of Things manufacturers often implement their own wireless protocols in order to save licensing fees. Deviating from standard, however, sometimes paves the way for critical attacks such as stolen cars or house breaks without physical traces. For a security analysis of such proprietary protocols, researchers use Software Defined Radios and dedicated de-modulation tools. But when reverse engineering is necessary, researchers are left alone and need to find protocol fields manually in a time-consuming and tedious process. We contribute a framework designed for field inference of wireless protocols. In contrast to previous research, our algorithm operates on the physical layer and, moreover, takes wireless specifics such as Received Signal Strength Indicators into account. Furthermore, the algorithm is robust against errors that are common in wireless communication. Our contribution not only performs a bootstrap of completely unknown protocols but also considers prior knowledge such as participant addresses or known field positions in order to increase accuracy. An implementation is published as part of the open source software Universal Radio Hacker and is a first step towards a default security analysis for proprietary wireless protocols similar like a port-scan is for traditional security.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Global manufacturers flood the Internet of Things (IoT) market with a huge number of devices such as smart light bulbs or door locks. The wireless communication between devices often uses proprietary protocols designed under size and energy constraints whereby security is only a secondary factor. This leads to serious threats for customers ranging from stolen cars to burglars silently breaking into their houses.</p><p>The security investigation of unknown wireless protocols involves many challenges. Researchers capture the device communication with a Software Defined Radio (SDR) and, subsequently, demodulate the signal with dedicated software solutions <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b16">17]</ref>. Those tools provide communicated bits to researchers but leave them alone with reverse engineering of the actual protocol. This is a tedious process and a significant obstacle before the real security analysis begins.</p><p>The problem of automatic protocol reverse engineering is well studied by several authors as summarized in the survey of Narayan et al. <ref type="bibr" target="#b14">[15]</ref>. The published solutions work with high accuracy, but cannot be applied to the wireless setting for two reasons. First, most of them are designed for text-based protocols like HTTP while wireless IoT protocols are rather binary. Second, all of them work on the application layer, i.e., they rely on information from lower layers like IP addresses.</p><p>Since the related work is not designed for the specific wireless setting, we present an algorithm that can infer protocol fields from network traces of IoT devices. Our algorithm considers specifics of wireless communications like Received Signal Strength Indicator (RSSI) and uses statistical methods in combination with heuristics to find physical layer fields.</p><p>The main goal of our algorithm is to perform a bootstrap of an IoT protocol in order to simplify the subsequent manual analysis. Moreover, the algorithm is able to work with prior knowledge, that is, find missing fields with an incomplete protocol specification. We make the following contributions:</p><p>• An extendable framework for inferring message formats of physical layer protocols, prepared for the specifics of wireless protocols.</p><p>• A framework that performs a complete bootstrap of unknown protocols and also considers prior knowledge such as participant addresses to enhance accuracy.</p><p>• Heuristics for field semantics Preamble, Sync, Length, Address, Sequence Number and Checksum.</p><p>We provide an initial step to find security leaks in proprietary wireless protocols in the same way port scanning is a standard procedure for security analysis of conventional systems. Many IoT attacks can be evaluated once the physical structure of the protocol is known, for example, manipulating the sequence number of a message may lead to desynchronization of devices under certain conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Terminology and Design Assumptions</head><p>The main objective of protocol reverse engineering is to infer the protocol format that involves the message format and the protocol state machine. In this paper we focus on inferring the message formats and leave inferring the state machine for future work. The message format defines the order and type of fields in a message. A message field is a finite information sequence with known length and position, and a certain field semantic such as address, checksum or length in bytes. We further introduce the term label. We define label as an estimation for a field, that means a label aims to have same start, end and semantic as a field.</p><p>Problem Definition Our goal is to infer the message formats from captured messages (network traces) of a wireless communication. We make the following design assumptions:</p><p>• All protocol messages include a specific start of data sequence, that is, a sync word with length ≥ 1 bit, usually after the preamble.</p><p>• A single message does not contain more than one preamble and sync word. This could be different in practice if the physical pause between messages is very short. 1</p><p>• The number of captured messages will probably be limited due to legal transmission limits.</p><p>• Protocols are length-efficient binary protocols with no separators or redundancy and high entropy.</p><p>• Messages can be (partly) broken due to transmission and demodulation errors.</p><p>• We only have network traces and no additional data like source codes or program binaries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Automatic Wireless Reverse Engineering</head><p>The proposed algorithm is divided into two main phases. First, a preprocessing is performed to align messages. Second, field inference engines work on these aligned messages to infer protocol fields and message types. Refer to <ref type="figure">fig. 1</ref> for an overview. The algorithm also works for protocols that include nibble sized fields. This is an important difference to related approaches because as we work on the physical layer we cannot be sure that information is byte aligned. An example for a protocol with nibble fields is the Oregon Scientific RF Protocol <ref type="bibr" target="#b1">[2]</ref>. In the following sections we assume the protocol is completely unknown, that is, no prior knowledge is available. We show in section 3.8 how to consider prior knowledge. <ref type="bibr" target="#b0">1</ref> One solution is to add a message splitting functionality to our preprocessing from section 3.1. This works by iteratively applying our sync word finding and alignment procedures for full message and not stop after first occurrence. We could, however, not observe such short physical pauses for real devices so that this feature may not be needed in practice. Figure 1: Overview of proposed algorithm</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Raw data with messages and RSSI</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Preprocessing</head><p>The first step of the algorithm is to align messages based on possibly unknown sync words. We refer to this process as preprocessing. We split the preprocessing task into three steps. First, we identify the preamble of a message. Second, we derive the sync word(s) from the messages. Third, we create an alignment vector which stores the end of synchronization for each message. Splitting this task has an advantage: If sync words are known previously they can be entered by the user and our algorithm skips the first two steps. In case sync words are not known beforehand, they need to be extracted from captured messages. The basic idea is to search for the first differing bit behind the preamble. This basic approach has three problems:</p><p>1. The preamble length can vary between messages.</p><p>2. Protocols may use more than one sync word.</p><p>3. Bits may be flipped or missing due to transmission errors in certain messages.</p><p>We tackle the first problem by determining the preamble length for each individual message, the second one by looking for a synchronization length instead of a specific sync word and the third one by creating histograms over all messages in order to be robust against errors in single messages. We explain how we do this in the following sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Finding the preamble</head><p>The purpose of a preamble is to synchronize the receiver. Therefore, it consists of a fixed pattern of alternating zeros and ones. Formally, we can define a preamble as (a n b m ) k</p><p>with a, b ∈ {0, 1}, a = b and n, m, k ∈ N + . For example, a common preamble is 10101010 with n = m = 1 and k = 4. This formal representation of a preamble allows us to design a straight-forward algorithm for finding it. First, we get a by evaluating the first bit of the message. This also yield b because it is the inverse of a. Second, we look for the first occurrence of b to learn n and for the first occurrence of a behind the first b to learn m. Last, we count how often the pattern a n b m repeats in order to get k.</p><p>The algorithm is very prone to errors. Especially in wireless communications we must expect bits to be missing, wrongly inserted or even flipped. From error characteristic experiments with Software Defined Radios, we know that such errors mostly occur at the beginning of a message. We take this into account by shifting the start value until we find a preamble with sufficient length, that is, we skip more and more bits at the beginning of a message. In experiments k ≥ 2 turned out to be a good value for sufficient preamble length.</p><p>The preamble search is just a preparation for identifying sync words in the next step. Therefore, the preamble should not interfere with the sync word. This can, however, happen if the sync word starts in the same way as the preamble ends. Consider the example with (10) k in <ref type="figure">Figure</ref>  The first two messages share the eight bits preamble 10101010 while the third message has a ten bit preamble. The sync word for first and third message is 1001 while for second message it is 0110. In the first message, the algorithm finds position 10 as preamble end. This is wrong, because positions 9 and 10 are part of the sync word, therefore, the preamble size should be decreased by two (→ 8). For the second message, the algorithm finds position 8 as preamble end and shall not decrease the preamble length by two (= n + m).</p><p>How can the algorithm know whether to decrease the preamble length or not? The answer is, it cannot know at this point. Therefore, we save both lengths in two vectors that hold the lower l = (8, 6, 10) and upper u = (10, 8, 12) bounds for the preamble ends of each message, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Sync Word Identification</head><p>In the previous section we roughly estimated the preamble ends and now search for the specific sync word(s) in the protocol with the help of this information. Note that we just calculate the upper triangle of the difference matrix because the comparison order does not matter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Calculating Difference Matrix</head><p>Finding sync words With preamble end vectors l and u from section 3.1.1 and difference matrix D from section 3.1.2 we determine sync word candidates as follows: We iterate over all difference positions d i j in D greater than zero, whereby each position represents a possible ending of the synchronization word. For each sync end d i j &gt; 0, the raw preamble ends {l i , l j , u i , u j } for messages i and j indicate possible sync starts and we save all resulting sync word candidates. We perform these steps for every message pair and count the occurrence of sync word candidates yielding a histogram of possible sync words. After that the algorithm combines candidates with a common prefix in the histogram and determines the most probable sync length. 2 This way, the search for the sync word gets more robust against transmission errors and can even deal with different sync words. Finally, we take the most frequent sync length s L from the histogram and return all found sync words with length s L .</p><p>Message Alignment Once sync words are known, the algorithm aligns messages on them. If multiple sync words appear in a message, we align on the first occurring sync word. For further processing we remove the sync word and everything before from the messages and pass the aligned and cropped messages to the field inference engines. This way, the subsequent engines can work on reduced information and, more importantly, the messages are aligned on the sync word so that differential analyses are not biased by bit shifts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Field Inference Overview</head><p>Once messages are aligned properly, we can infer field semantics from captured messages. For this reason, our algorithm consists of dedicated Field Inference Engines that work with scoring functions to find the right label for a protocol field. In general, this process consists of three steps:</p><p>1. Assign messages to engine-specific clusters. For example, the length engine clusters messages based on their physical length in bytes.</p><p>2. Find common ranges, that is, identical sequences at same positions inside and/or between clusters.</p><p>(a) Score common ranges with an engine-specific scoring function.</p><p>(b) Return common ranges with highest score if they surpass a minimum score s min .</p><p>(c) If possible, merge the resulting ranges.</p><p>3. Add found labels to the current message type. If necessary, create new message types based on found labels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Common Ranges</head><p>The search for common ranges is a central part of every engine and must be robust against errors in single messages. We find common ranges by comparing the aligned messages column-wise and search for columns with equal values. In order to be tolerant against errors, we view a range as common if at least α percent of column values are equal for every message, whereby an α between 70% and 95% turned out to be a good compromise between accuracy and error-tolerance in practice. Having found a common range, we save its start, length and value together with the message indices this ranges applies to. An example is shown in <ref type="figure" target="#fig_2">fig. 3</ref>.  We describe the engine specific scoring functions and cluster features in the following sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Length Field Engine</head><p>A length field contains the size of following data, usually in bytes. In order to find length fields we cluster messages by their physical length in bytes. For each cluster we calculate the normalized histogram of common bits and identify ranges where at least eight bits are equal for α percent of the messages. In experiments α = 0.7 produced good results.</p><p>Next, we rule out equal valued ranges across clusters because values must differ for messages with other physical lengths. All remaining ranges are scored with the function:</p><formula xml:id="formula_1">s = 1 1 + k · p · e − 1 2 ( v−t σ ) 2 (2)</formula><p>whereby s is the score, t the target length, that is, the message length in bytes, p the start position of the common range and v the decimal interpreted value, whereby both little endian and big endian interpretations are tested. The constants σ and k are used to control the scoring function's decay, whereby in our experiments σ = 2 and k = 0.25 produce good results. The idea of the function is to yield lower scores for high start positions because we expect length fields rather to appear at the beginning of messages. We evaluate the scoring function for a sliding window over common range values with standard integer window sizes between 8 and 64 bits, in order to find usual sized length fields.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Address Field Engine</head><p>We split the address field search into three steps as shown in <ref type="figure">fig. 4</ref>. First, the engine assigns a participant to every message. Second, the engine searches possible addresses of involved participants. Finally, the engine finds positions of address fields based on these possible addresses.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Input</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Assign Participants</head><p>The engine begins with ensuring that every message has a participant (= sending device) assigned, whereby we assume the number of participants |P| to be known. The automatic assignment has two strategies: First, if prior knowledge is available and, more specifically, a source address label is present in the message while a participant with this address is known, this participant is assigned to the message.</p><p>The second strategy is more generic and relies on the Received Signal Strength Indicator (RSSI) of a message. During recording, devices are placed at different distances from SDR and/or have different transmitting powers. Therefore, it can be expected that messages of a certain participant have a similar RSSI. In order to assign participants, the RSSIs of all messages are clustered with |P| centers so that the highest RSSIs are in first cluster, the second highest in second cluster and so on. With this clustering we can assign a participant to a message by looking up the cluster index of the message's RSSI. Users can control to which cluster a participant gets assigned with a relative RSSI as shown in <ref type="figure" target="#fig_4">fig. 5</ref>. Note that only messages without an assigned participant are considered in this routine. A message can already have a participant assigned either through a prior run of this engine or through manual assignment by the user. The routine skips messages that already have a participant assigned.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">Find Address Candidates</head><p>Once each message has a participant, the next task of the engine is to find possible addresses for each participant. In order to find address candidates, we start by clustering the messages by participant and find common ranges within each participant cluster. As a result, we have a set of common ranges for each participant cluster. Then we compare the values of the individual common ranges pairwise for each pair of participants and search for longest common substrings (LCSs) in these values, for example, LCSs(CAFE1337, 1337CAFE) = <ref type="bibr">[CAFE, 1337]</ref>. If found, we add these substrings to address candidates of both participants. If no common substring is found we add both values as address candidates for both participants to cover, e.g., ACK messages with only one address.</p><p>The address for a participant can also be previously known either through a prior run of this engine or manual configuration by the user. The search of address candidate for participants with known address is skipped by the algorithm. Moreover, we can filter address candidates when at least one address is known beforehand: Since it can be assumed that addresses in a protocol have a common length, all possible addresses with a different length can be ruled out.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.3">Find Address Fields</head><p>The final step of this engine is to find address positions and infer address types, that is SRC or DST, based on the address candidates determined in the previous step.</p><p>Find possible ranges We start by iterating through the messages of each participant. For each message the system finds occurrences of address candidates and, if found, creates common range objects from their position in the message. If the same position was already found in another message, the index of the current message is added to the existing indices of the according common range object. The idea is to increase the score for a range if one of these two checks is successful. Therefore, we increase the score by N rng N P whereby N rng is the number of messages in this common range and N P the number of messages of the current participant. This way, common ranges that apply for more messages get a higher score. If both checks should be successful, the score is only increased once. Ranges will be eliminated when they do not surpass a minimum score. In our experiments a minimum score of 0.1 produces good results.</p><p>Assign participant addresses The next step is to assign addresses to all participants without a known address based on the previously scored ranges and the address candidates from section 3.4.2. We score an address candidate in the following way: If the algorithm finds the address candidate in a message together with another address candidate, we increase the score. The underlying idea is, that the source address (=participant address), is likely to be included in a message that contains multiple addresses. On the other hand, when the message only contains one address, this is probably rather a destination address. Finally, we assign for each participant the address candidate with the highest score.</p><p>Field type inference Having assigned the most likely address to each participant, the next step is to infer address fields from the found common ranges. In order to do this, we need to distinguish between source address (SRC) and destination address (DST). The rule is simple: If the common range value is equal to the participant address we infer a SRC, otherwise a DST label. Note, we only consider the highest scored ranges to prevent multiple SRC and DST labels being inferred. As a final step, we check for messages that were sent to broadcast: First, we find all messages M SRC that have a SRC but no DST label assigned. Second, we take the positions of DST labels from messages with SRC label. Finally, we evaluate the value of messages in M SRC at DST position and look if the address appears multiple times but not as SRC address. If this is the case, the algorithm takes this address as broadcast address.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Sequence Number Field Engine</head><p>Sequence numbers are increasing counters used for flow control and freshness in a protocol. We find sequence numbers with a matrix of decimal differences E between adjacent messages. For example, if we take four messages with five bytes as shown on the left in <ref type="figure" target="#fig_6">fig. 7</ref> the matrix E means, for example, that m 1 and m 2 have a decimal difference of 1 at the first byte. Moreover, all first bytes of the four messages differ by 1 so the first byte is a good candidate for the sequence number. In general, we look at columns of E that only contain constants or zeros because sequence numbers may remain constant between some messages. In order to deal with overflows such as 255 → 0 we take the decimal difference modulo 256 or, more generally, 2 n whereby n is the considered n gram length and, e.g., is 8 for byte and 4 for nibble protocols.</p><p>The score s for a column of E is set to</p><formula xml:id="formula_2">s = 0, if only zeros in column #(most_common_value =0)−#zeros #values , else</formula><p>Next, we create common range objects (section 3.2) from all columns surpassing minimum score s min resulting in sequence number candidates. For longer sequence numbers, these ranges must be merged. We merge two adjacent ranges if they apply to the same messages (rows). Note, this applies to both little and big endian sequence numbers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Checksum Field Engine</head><p>Manufacturers of IoT devices can choose from a large pool of checksum algorithms and variants whereby most of them can be fine-tuned with additional parameters. Hence, it can be difficult to detect the right algorithm with correct parameters for a checksum and, additionally, the correct range of data bits the checksum was applied to. Fortunately, many manufacturers use variants of the Cylic Redundancy Check (CRC) algorithm and most of them put the checksum field at the end of all protocol fields. For this engine, we assume that the protocol uses only one variant and parameter set for all messages.</p><p>We apply a checksum search algorithm that differentiates between CRC and other checksums. The CRC engine aims to test all CRC parameters for each the datarange from the beginning of the data up to the possible checksum field. For efficiency reasons we contribute an algorithm that relies on the homomorphic property of CRC that works as follows. In a caching phase ( <ref type="figure" target="#fig_7">fig. 8</ref>) we calculate all checksum values of the bit sequence 1(0) n−1 whereby n is the length of data up to the CRC field candidate.</p><formula xml:id="formula_3">1 0 0 0 0 0 . . . 0 cache[0]</formula><p>cache <ref type="bibr" target="#b0">[1]</ref> cache <ref type="bibr" target="#b1">[2]</ref> . . .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>cache[n]</head><p>CRC <ref type="formula" target="#formula_0">(1)</ref> CRC <ref type="formula" target="#formula_0">(10)</ref> CRC <ref type="formula" target="#formula_0">(100)</ref> CRC <ref type="formula">(</ref>  Sometimes there are several possible results for checksum algorithm, parameters and datarange. If this is the case, our algorithm outputs the result that works for the majority of tested messages. The Checksum Field Engine returns the position of the checksum field, the determined checksum variant and it's parameters and, additionally, the associated datarange the checksum covers. Note, the engine is not limited to CRCs but can also detect more specialized checksums, for example, the checksum algorithms used in the Wireless Short Packet Protocol <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Message Type Assignment</head><p>The engines from previous sections return a set of labels. In the next step, we group these labels into message types based on their messages indices. If the indices match and the fields do not overlap a new message type is created from these fields and messages as shown in the example in <ref type="figure">fig. 10</ref>. If two ranges with shared message indices overlap, we choose the range with the highest score. For multiple overlapping ranges, we choose the ranges that maximize the total score. Figure 10: Merging of found fields to infer message types</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Range: 0-42</head><p>Having created the message types, the start and end indices of the fields are updated so that they are absolute and not relative to the sync word anymore. In other words, we reverse the alignment transformation we made in section 3.1.2. Moreover, we add Preamble and Sync labels to the message types in this stage based the information gathered in section 3.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">Considering a priori knowledge</head><p>In previous sections we assumed that protocol specifications are completely unknown. There are various potential sources for (partial) protocol knowledge such as leaked documents or stickers with addresses printed on investigated devices. In this section, we show how to consider prior knowledge, that is, partially known message types and fields to improve accuracy. Note, this prior knowledge can also come from a previous run of our system, so that even totally unknown protocols profit.</p><p>We assume a priori knowledge to be correct but not necessarily complete, that is, messages may have a message type assigned where not all fields are labeled. This leads to the following rules when dealing with a priori knowledge:</p><p>1. Labels must not be changed.</p><p>2. Labels must not be removed from a message type.</p><p>3. Messages must keep their assigned message type.</p><p>The general idea of our solution is to run the previously mentioned engines for each message type. For a totally unknown protocol we assume all messages have a common message type which entails no labels, so that the previous description of our algorithm remains valid as a special case of this more general algorithm. Our system considers non-empty message types in the following way:</p><p>• Engines for fields that are already present in the message type are skipped.</p><p>• All previously labeled ranges are ignored by the engines.</p><p>• If a new message type needs to be created (section 3.7) the original message type is split, that is, it's labels are copied over to all newly created types.</p><p>Splitting message types may seem like a contradiction of rule 3, but after splitting the new message types include the same labels as the original message type so that only new knowledge is added and prior labels remain unchanged. Since our algorithm profits from prior knowledge, we run it until no new fields are found in an iteration. The general procedure is shown in listing 1. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experimental Validation</head><p>In this section we evaluate the accuracy and performance of our algorithm. For accuracy evaluation, we use 8 generated protocols with different fields and number of involved participants. An overview of the protocols is given in table 1.</p><p>The protocols vary strongly in field lengths and cover, for example, messages with long preamble (72 bits), short synchronization (4 bits), non-default preamble patterns (0x8888) or even no preamble at all. Moreover, the byte order of length and sequence number fields varies. The payload data for all protocols is randomly generated. A detailed description of these protocols is given in appendix A.</p><p>Given a set of messages M with expected fields E i for message i, we define the accuracy a as</p><formula xml:id="formula_4">a = 1 |M| · |M| ∑ i=1 |E i ∩ F i | |E i |<label>(3)</label></formula><p>whereby F i are the found fields for message i. In the following experiments we assume there is no prior knowledge available, that is, only the captured messages and the number of involved participants are presented to the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Test against number of messages</head><p>Wireless communication tends to be efficient and, therefore, not use many messages for a process such as switching on a light bulb. Furthermore, legal transmission windows limit the amount of messages a researcher can capture at a time.</p><p>In this experiment, we investigate the effect of the number of captured messages on the accuracy of our algorithm. It can be expected that the accuracy increases when more messages are available to the algorithm. Results are shown in <ref type="figure" target="#fig_10">fig. 11</ref>. The accuracy reaches 100% for all protocols when more than 17 messages are available to the algorithm. For six of the protocols the algorithm infers fields with 100% accuracy when at least 7 messages are available. Protocol 5 and 7 need more messages than other protocols to reach full accuracy because three or four participants are involved in their communication so more messages are needed to infer participant addresses and find position of address fields.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Test against errors</head><p>We investigate how messages with errors affect the accuracy of our algorithm because broken messages are common in wireless captures. In this experiment, we create broken messages by setting the bits to random values beginning at a random message position. This is the worst case for the algorithm because some data remains valid in broken messages.</p><p>To calculate the accuracy for this experiment, we only consider non-broken messages in eq. <ref type="formula" target="#formula_4">(3)</ref> because the algorithm will not label broken parts of messages and the goal of this experiment is to find out how resistant the algorithm is against errors, that is, how many intact messages are labeled correctly while having increasing number of broken messages.</p><p>We start for all protocols with a total of 30 messages, to ensure they are labeled with 100% accuracy when no message is broken. Then we start to increase the number of broken messages. The result of this experiment is shown in <ref type="figure" target="#fig_0">fig. 12</ref>. Results suggest, that the algorithm is quite robust against errors. The majority of protocols are labeled with more than 80% accuracy when 20% of messages are broken.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Performance measurement</head><p>We evaluate the performance of our algorithm for an increasing number of messages. In contrast to the previous section we use real-world smart-home protocols to measure the performance for practical protocols. We use three real world captures for evaluation. First, the communication of two EnOcean devices using the Wireless Short Packet Protocol <ref type="bibr" target="#b12">[13]</ref>. Second, a challenge-response procedure between a wireless door lock and a remote control from german manufacturer Homematic using the proprietary BidCoS protocol. Third, a communication of two RWE Smarthome devices using a unnamed proprietary protocol developed by eQ-3. We start with a number of eight messages because our algorithm finds all physical fields in these real-world protocols when using at least eight messages. For every performance measurement, the accuracy of field inference was 100% throughout these experiments. The measurements were taken on a computer with i7-6700K CPU@4.00GHz and 16GB RAM. For every number of messages we take the mean of 100 performance measurements. Results are shown in <ref type="figure" target="#fig_2">fig. 13</ref>. Results show that our algorithm performs in under one second even for 500 messages. While the algorithm is designed to work on few messages, it can also deal with a larger number of messages. Therefore, a typical protocol capture with around 10 messages can be bootstrapped by the algorithm without a visible delay for the end-user. Since engines of our algorithm work independently, the performance could be further improved by parallelization. The results, however, indicate this optimization is not required in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related Work</head><p>In their survey Narayan et al. <ref type="bibr" target="#b14">[15]</ref> describe several methods for automated reverse engineering of network protocols. Most of these algorithms are designed for application level protocols like HTTP. In fact, we are not aware of a single approach that focuses on the physical layer like our contribution. This is a harder problem because we cannot use information from lower OSI layers such as IP addresses.</p><p>Protocol Informatics (PI) <ref type="bibr" target="#b2">[3]</ref> is a pioneer work in this field. It uses the Needleman-Wunsch sequence alignment algorithm <ref type="bibr" target="#b15">[16]</ref> from bioinformatics to handle variable length fields like USER alice and USER bob in FTP whereby the username has a variable length. We do not use NeedlemanWunsch algorithm as we do not expect variable length fields or optional fields. We focus on physical layer binary protocols and use a histogram to measure similarity between messages because sequence alignment would be prone to transmission errors that are common in wireless communications especially if a Software Defined Radio is used for recording.</p><p>RolePlayer <ref type="bibr" target="#b11">[12]</ref> and ScriptGen <ref type="bibr" target="#b13">[14]</ref> are based on PI's sequence alignment algorithm and infer the protocol state machine to the level necessary for adaptive replay. While they are not designed purely for protocol reverse engineering they can mimic both sides of a communication by learning the protocol from network traces, for example, in order to emulate the command and control messages of a botnet.</p><p>Discoverer <ref type="bibr" target="#b10">[11]</ref> improved this initial work. The authors showed that Needleman-Wunsch algorithm is not suited for messages with the same format as it would not consider, e.g., length fields. Their method is based on token classes (text or binary) and Format Distinguisher (FD) fields such as \n or \t. A FD separates encapsulated protocols from each other, e.g., in CIFS/SMB protocol a NetBIOS header encapsulates an SMB header, which in turn may encapsulate a RPC message.</p><p>Based on these FD fields they perform a recursive clustering to the encapsulated protocols and finally merge results together. Note, for wireless IoT protocols a distinction between text or binary tokens is generally superfluous because these protocols use a binary format for efficiency. Furthermore, IoT protocols seldom rely on FD fields but rather preambles like 10101010.</p><p>Antunes et al. <ref type="bibr" target="#b0">[1]</ref> boil down the problem of protocol reverse engineering to building two finite automata: One automaton describes the protocol format and the other one the protocol state machine. The difficulty is to build the automata from a limited sample set of the language represented by the automaton. Their approach is designed for text protocols with a FIELD value structure such as USER bob. The space behind USER is an easy detectable. Physical layer protocols, however, do not consist of such a FIELD value structure.</p><p>The aforementioned approaches work on network traces. In contrast to that several authors <ref type="bibr">[6-8, 10, 18]</ref> investigate the execution trace of the binary that implements the network protocol. This is referred to as dynamic analysis and yields additional information. For example, four consecutive bytes can be identified as a DWORD, that is, a four-byte integer if the execution trace reveals that they are processed as a DWORD. We assume the program binary is not accessible for analysis and therefore can not build on this idea.</p><p>The most comparable works to our approach are FieldHunter <ref type="bibr" target="#b3">[4]</ref> and <ref type="bibr">WASp [9]</ref>. FieldHunter is designed to infer field types from network traces. Authors use statistical methods to identify interesting ranges in messages and propose heuristics to derive field types. FieldHunter is designed to work on both text-based and binary protocols but also operates on a higher OSI layer as it, for example, uses IP addresses to infer host identifiers. WASp is a tool to automatically analyze proprietary wireless byte protocols built on top of IEEE 802.15.4. Additionally, WASp automatically generates spoofed packets based on found rules. Compared to our work WASp relies on known field positions such as Preamble or Length from the IEEE 802.15.4 standard.</p><p>Compared to previous work our contribution is novel in two ways. First, our algorithm works on the physical layer without making any assumption about the underlying protocol. Second, it is designed for wireless protocols, especially those used in Internet of Things, and is optimized for smaller datasets, that is, 10-100 messages compared to previous approaches that work on 1000-10000 messages. The reason for this is that IoT communication cannot be as easily triggered as, say, DNS because there are duty cycles on certain frequencies and, moreover, you have to perform physical actions like pressing a button in order to trigger messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We propose a framework for automatic protocol reverse engineering especially aimed at proprietary wireless protocols under consideration of their specifics such as RSSI and preambles. Our solution can perform a bootstrap of an unknown protocol but is also able to take prior knowledge into account. We believe this will speed up and simplify security investigations of Internet of Things devices. The framework consists of dedicated engines for inferring protocol fields such as Length or Address and automatically creates message types based on newly found and previously known fields (section 3.7).</p><p>In experiments, all fields of test protocols (appendix A) are found with 100% accuracy if enough messages are captured. A major design goal of the algorithm is to be robust against errors. In experiments, field inference accuracy mostly stays above 80% when 20% of messages contain random errors.</p><p>We verified our algorithm with three real-world protocols (section 4.3) and it infers all physical fields when at least eighth messages are available. While this is a limited test set, we expect our solution to work on a variety of IoT wireless protocols as they share common structures, for example, preamble and synchronization determined by hardware chips.</p><p>Finding fields in the payload such as an on/off bit of a wireless socket or the temperature of a radiator valve is not in the scope of this paper so it has to be manually performed by the researcher. We believe, however, that finding preamble, synchronization, addresses, sequence number and checksum automatically will help security researchers because payloads can be quickly identified when other fields are labeled.</p><p>Future work is the suggestion of attacks based on the found fields and detection of cryptography in data payload as well. Ultimately, an automated security score could be calculated based on found cryptography and protocol complexity and, thereby, giving the researcher an initial idea about the protocol security right from the captured messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Availability</head><p>Our algorithm is available as open source software as part of the Universal Radio Hacker <ref type="bibr" target="#b16">[17]</ref> and integrated into its GUI as shown in <ref type="figure" target="#fig_13">fig. 14</ref>. All shown labels and message types in this screenshot were automatically found by the algorithm after hitting the Analyze button. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Protocols</head><p>In this section we describe the protocols used for experiments in section 4. The payload for each protocol was, if not stated otherwise, 8 byte for every even and 64 byte for every odd message. The payload data was randomly generated. The sending participant was changed cyclical after each message to ensure every participant sends a message. The only exception is for protocols that contain an ACK message type: for such protocols an ACK is sent by the receiver for every incoming message.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Protocol 1</head><p>There were 2 participants involved in communication: Alice (0xdead) and Bob (0xbeef). The protocol has one message type with the following fields:</p><p>• preamble: 0xaa</p><p>• synchronization: 0x1337</p><p>• length: 8 bit</p><p>• source address: 16 bit</p><p>• destination address: 16 bit</p><p>• sequence number: 8 bit</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Protocol 2</head><p>There were 2 participants involved in communication: Alice (0xdead01) and Bob (0xbeef24). The protocol has one message type with the following fields:</p><p>• preamble: 0xaaaaaaaaaaaaaaaaaa</p><p>• synchronization: 0x1337</p><p>• length: 8 bit</p><p>• source address: 24 bit</p><p>• destination address: 24 bit</p><p>• sequence number: 16 bit (big endian)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Protocol 3</head><p>There were 2 participants involved in communication: Alice (0x1337) and Bob (0xbeef). The protocol has 2 message types with the following fields:</p><p>• data -preamble: 0xaaaa</p><p>-synchronization: 0x9a7d</p><p>-length: 8 bit </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.5 Protocol 5</head><p>There were 3 participants involved in communication: Alice (0x1337), Bob (0xbeef) and Carl (0xcafe). The protocol has 2 message types with the following fields:</p><p>• data -preamble: 0xaaaa </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.6 Protocol 6</head><p>There were 2 participants involved in communication: Alice (0x24) and Bob (0xff). The protocol has one message type with the following fields:</p><p>• synchronization: 0x8e88</p><p>• length: 8 bit</p><p>• source address: 8 bit</p><p>• sequence number: 8 bit</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.7 Protocol 7</head><p>There were 4 participants involved in communication: Alice (0x313370), Bob (0x031337), Charly (0x110000) and Daniel (0x001100). The protocol has 3 message types with the following fields:</p><p>• data -preamble: 0xaaaa</p><p>-synchronization: 0x0420 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.8 Protocol 8</head><p>The protocol has 2 message types with the following fields: </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Messages with varying syncs and preambles</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>We calculate a difference matrix D where d i j denotes position of the first difference between message i and j. If there is no such difference, that is, messages are equal or one message is a prefix of the other we set d i j = 0. For example, when calculating the difference matrix for the messages in fig. 2 we get</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Example for common range of three messages</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Figure 4: Address Field Engine example for messages between Alice (address: AA) and Bob (address: BB)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Configuration of Relative RSSI</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Scoring</head><label></label><figDesc>Figure 6: Cross Swap check and ACK check example for Alice (CA FE) and Bob (13 37)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Matrix of decimal differences E (mod 256)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Filling the CRC cache</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Checking datarange using the cache</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>while new_fields_found and i &lt; max_iterations: 3 i = i + 1 4 for mt in existing_message_types: 5 new_fields = [] 6 for engine in engines: 7 if field_of_engine not in mt: 8 new_fields.extend(engine.run(mt)) 9 10 # Split message type if necessary 11 add_to_message_type(mt, new_fields) Listing 1: Iterative algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Accuracy for increasing number of messages</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Accuracy for increasing number of messages with error for a total of 30 messages with 100 runs per measurement</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Algorithm performance for real-world smart-home protocols with increasing number of messages</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Integration into URH</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>-</head><label></label><figDesc>source address: 16 bit -destination address: 16 bit -sequence number: 8 bit -payload: 10 byte -checksum: CRC8 CCITT • ack -preamble: 0xaaaa -synchronization: 0x9a7d -length: 8 bit -destination address: 16 bit -checksum: CRC8 CCITT A.4 Protocol 4 There were 2 participants involved in communication: Alice (0x1337) and Bob (0xbeef). The protocol has 3 message types with the following fields: • data -preamble: 0x8888 -synchronization: 0x9a7d -length: 8 bit -source address: 16 bit -destination address: 16 bit -payload: 8 byte -checksum: CRC16 CCITT • data2 -preamble: 0x8888 -synchronization: 0x9a7d -length: 8 bit -source address: 16 bit -destination address: 16 bit -payload: 64 byte -checksum: CRC16 CCITT • ack -preamble: 0x8888 -synchronization: 0x9a7d -length: 8 bit -destination address: 16 bit -checksum: CRC16 CCITT</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>-</head><label></label><figDesc>synchronization: 0x9a7d -length: 8 bit -source address: 16 bit -destination address: 16 bit -sequence number: 8 bit • ack -preamble: 0xaaaa -synchronization: 0x9a7d -length: 8 bit -destination address: 16 bit</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>-</head><label></label><figDesc>length: 8 bit -destination address: 24 bit -source address: 24 bit -payload: 8 byte -checksum: CRC16 CC1101 • ack -preamble: 0xaa -synchronization: 0x2222 -destination address: 24 bit -checksum: CRC16 CC1101 • kex -preamble: 0xaaaaaa -synchronization: 0x6767 -destination address: 24 bit -source address: 24 bit -payload: 64 byte -checksum: CRC16 CC1101</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>-</head><label></label><figDesc>preamble: 0xa -synchronization: 0x9 -length: 16 bit (little endian) -sequence number: 16 bit (little endian) -payload: 542 byte • data2 -preamble: 0xa -synchronization: 0x9 -length: 16 bit (little endian) -sequence number: 16 bit (little endian) -payload: 260 byte</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><head>Table 1 : Properties of tested protocols whereby × means field is not present and N P is the number of participants.</head><label>1</label><figDesc></figDesc><table># Comment 
N P Message 
Even/odd 
Size of field in bit (BE=Big Endian, LE=Little Endian) 
Type 
message data Preamble Sync Length SRC DST SEQ Nr CRC 
1 common protocol 2 
data 
8/64 byte 
8 
16 
8 
16 
16 
8 
× 
2 unusual field sizes 2 
data 
8/64 byte 
72 
16 
8 
24 
24 
16 (BE) 
× 
3 
2 
data 
10/10 byte 
16 
16 
8 
16 
16 
8 
8 
contains ack and 
CRC8 CCITT 
ack 
× 
16 
16 
8 
× 
16 
× 
8 
4 
2 
data 
8/64 byte 
16 
16 
8 
16 
16 
× 
16 
contains ack and 
CRC16 CCITT 
ack 
× 
16 
16 
8 
× 
16 
× 
16 
5 
3 
data 
8/64 byte 
16 
16 
8 
16 
16 
8 
× 
three participants 
with ack frame 
ack 
× 
16 
16 
8 
× 
16 
× 
× 
6 short address 
2 
data 
8/64 byte 
× 
16 
8 
8 
× 
8 
× 
7 
4 
data 
8/8 byte 
16 
16 
8 
24 
24 
× 
16 
ack 
× 
8 
16 
× 
× 
24 
× 
16 

four participants, 
varying preamble 
size, varying sync 
words 

kex 
64/64 byte 
24 
16 
× 
24 
24 
× 
16 
8 nibble fields + LE 1 
data 
542/260 byte 
4 
4 
16 (LE) 
× 
× 
16 (LE) 
× 

</table></figure>

			<note place="foot" n="2"> In theory, protocol sync words can vary in length. The algorithm can deal with this by choosing sync lengths whose frequencies are above a certain threshold. We think, however, that a varying sync word length is not common in practice, so we assume it to be constant for a protocol in this paper.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Reverse engineering of protocols from network traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">João</forename><surname>Antunes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nuno</forename><surname>Neves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paulo</forename><surname>Verissimo</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="169" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Oregon Scientific RF Protocol Description</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Network protocol analysis using bioinformatics algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ma</forename><surname>Beddoe</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Towards automatic protocol field inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ignacio</forename><surname>Bermudez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alok</forename><surname>Tongaonkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marios</forename><surname>Iliofotou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Mellia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maurizio</forename><forename type="middle">M</forename><surname>Munafò</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="page" from="40" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">GNU radio: Tools for exploring the radio frequency spectrum</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Blossom</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Enabling active botnet infiltration using automatic protocol reverse-engineering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Caballero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Poosankam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kreibich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Song</forename><forename type="middle">D</forename><surname>Dispatcher</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="621" to="634" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Automatic protocol reverse-engineering: Message format extraction and field semantics inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juan</forename><surname>Caballero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="451" to="474" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Polyglot : Automatic Extraction of Protocol Message Format using Dynamic Binary Analysis Polyglot : Automatic Extraction of Protocol Message Format using</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juan</forename><surname>Caballero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="317" to="329" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Dissecting Customized Protocols: Automatic Analysis for Customized Protocols based on IEEE 802.15.4</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kibum</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yunmok</forename><surname>Son</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juhwan</forename><surname>Noh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hocheol</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jaeyeong</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yongdae</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM Conference on Security &amp; Privacy in Wireless and Mobile Networks -WiSec &apos;16</title>
		<meeting>the 9th ACM Conference on Security &amp; Privacy in Wireless and Mobile Networks -WiSec &apos;16</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<biblScope unit="page" from="183" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Prospex: Protocol specification extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><forename type="middle">Milani</forename><surname>Comparetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gilbert</forename><surname>Wondracek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engin</forename><surname>Kirda</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="110" to="125" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Discoverer: Automatic Protocol Reverse Engineering from Network Traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weidong</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jayanthkumar</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Helen J</forename><surname>Wang</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="199" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Protocol-Independent Adaptive Replay of Application Dialog</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weidong</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vern</forename><surname>Paxson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Nicholas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Randy</forename><forename type="middle">H</forename><surname>Weaver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Katz</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="279" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Information technology -Home electronic system (HES) architecture -Part 3-11: Frequency modulated wireless short-packet (FMWSP) protocol optimised for energy harvesting -Architecture and lower layer protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Iso</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">ScriptGen: An automated script generation tool for honeyd</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Corrado</forename><surname>Leita</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ken</forename><surname>Mermoud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Dacier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="203" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Narayan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sandeep</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">Charles</forename><surname>Shukla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Clancy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">A Survey of Automatic Protocol Reverse Engineering Tools</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">A general method applicable to the search for similarities in the amino acid sequence of two proteins</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Saul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><forename type="middle">D</forename><surname>Needleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wunsch</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="443" to="453" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Universal Radio Hacker: A Suite for Analyzing and Attacking Stateful Wireless Protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johannes</forename><surname>Pohl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Noack</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th USENIX Workshop on Offensive Technologies (WOOT 18). USENIX Association</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gilbert</forename><surname>Wondracek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><forename type="middle">Milani</forename><surname>Comparetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engin</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scuola</forename><surname>Superiore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Automatic Network Protocol Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anna</forename></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="1" to="18" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
