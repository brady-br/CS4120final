<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:19+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Applying Hardware Transactional Memory for Concurrency-Bug Failure Recovery in Production Runs Applying Hardware Transactional Memory for Concurrency-Bug Failure Recovery in Production Runs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>July 11-13. 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuxi</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Chicago</orgName>
								<orgName type="institution" key="instit2">Karthikeyan Sankaralingam</orgName>
								<orgName type="institution" key="instit3">University of Wisconsin -Madison</orgName>
								<orgName type="institution" key="instit4">University of Chicago</orgName>
								<orgName type="institution" key="instit5">University of Wisconsin -Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shu</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Chicago</orgName>
								<orgName type="institution" key="instit2">Karthikeyan Sankaralingam</orgName>
								<orgName type="institution" key="instit3">University of Wisconsin -Madison</orgName>
								<orgName type="institution" key="instit4">University of Chicago</orgName>
								<orgName type="institution" key="instit5">University of Wisconsin -Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Chicago</orgName>
								<orgName type="institution" key="instit2">Karthikeyan Sankaralingam</orgName>
								<orgName type="institution" key="instit3">University of Wisconsin -Madison</orgName>
								<orgName type="institution" key="instit4">University of Chicago</orgName>
								<orgName type="institution" key="instit5">University of Wisconsin -Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuxi</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Chicago</orgName>
								<orgName type="institution" key="instit2">Karthikeyan Sankaralingam</orgName>
								<orgName type="institution" key="instit3">University of Wisconsin -Madison</orgName>
								<orgName type="institution" key="instit4">University of Chicago</orgName>
								<orgName type="institution" key="instit5">University of Wisconsin -Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shu</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Chicago</orgName>
								<orgName type="institution" key="instit2">Karthikeyan Sankaralingam</orgName>
								<orgName type="institution" key="instit3">University of Wisconsin -Madison</orgName>
								<orgName type="institution" key="instit4">University of Chicago</orgName>
								<orgName type="institution" key="instit5">University of Wisconsin -Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Chicago</orgName>
								<orgName type="institution" key="instit2">Karthikeyan Sankaralingam</orgName>
								<orgName type="institution" key="instit3">University of Wisconsin -Madison</orgName>
								<orgName type="institution" key="instit4">University of Chicago</orgName>
								<orgName type="institution" key="instit5">University of Wisconsin -Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karthikeyan</forename><surname>Sankaralingam</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Chicago</orgName>
								<orgName type="institution" key="instit2">Karthikeyan Sankaralingam</orgName>
								<orgName type="institution" key="instit3">University of Wisconsin -Madison</orgName>
								<orgName type="institution" key="instit4">University of Chicago</orgName>
								<orgName type="institution" key="instit5">University of Wisconsin -Madison</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Applying Hardware Transactional Memory for Concurrency-Bug Failure Recovery in Production Runs Applying Hardware Transactional Memory for Concurrency-Bug Failure Recovery in Production Runs</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2018 USENIX Annual Technical Conference (USENIX ATC &apos;18)</title>
						<meeting>the 2018 USENIX Annual Technical Conference (USENIX ATC &apos;18) <address><addrLine>Boston, MA, USA</addrLine></address>
						</meeting>
						<imprint>
							<date type="published">July 11-13. 2018</date>
						</imprint>
					</monogr>
					<note>Open access to the Proceedings of the 2018 USENIX Annual Technical Conference is sponsored by USENIX. This paper is included in the</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Concurrency bugs widely exist and severely threaten system availability. Techniques that help recover from concurrency-bug failures during production runs are highly desired. This paper proposes BugTM, an approach that leverages Hardware Transactional Memory (HTM) on commodity machines for production-run concurrency-bug recovery. Requiring no knowledge about where are concurrency bugs, BugTM uses static analysis and code transformation to insert HTM instructions into multi-threaded programs. These BugTM-transformed programs will then be able to recover from a concurrency-bug failure by rolling back and re-executing the recent history of a failure thread. BugTM greatly improves the recovery capability of state-of-the-art techniques with low run-time overhead and no changes to OS or hardware, while guarantees not to introduce new bugs.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction 1.Motivation</head><p>Concurrency bugs are caused by untimely accesses to shared variables. They are difficult to expose during in-house testing. They widely exist in productionrun software <ref type="bibr" target="#b26">[26]</ref> and have caused disastrous failures <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b40">40]</ref>. Production run failures severely hurt system availability: the restart after a failure could take long time and even lead to new problems if the failure leaves inconsistent system states. Furthermore, comparing with many other types of bugs, failures caused by concurrency bugs are particularly difficult to diagnose and fix correctly <ref type="bibr" target="#b50">[50]</ref>. Techniques that handle production-run failures caused by concurrency bugs are highly desired.</p><p>Rollback-and-reexecution is a promising approach to recover failures caused by concurrency bugs. When a failure happens during a production run, the program rolls back and re-executes from an earlier checkpoint. Due to the unique non-determinism nature of concurrency bugs, the re-execution could get around the failure.</p><p>This approach is appealing for several reasons. It is generic, requiring no prior knowledge about bugs; it improves availability, masking the manifestation of concurrency bugs from end users; it avoids causing system inconsistency or wasting computation resources, which of- This approach also faces challenges in performance, recovery capability, and correctness (i.e., not introducing new bugs), as we elaborate below.</p><p>Traditional rollback recovery conducts full-blown multi-threaded re-execution and whole-memory checkpointing. It can help recover almost all concurrency-bug failures, but incurs too large overhead to be deployed in production runs <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b39">39]</ref>. Even with support from operating systems changes, periodic full-blown checkpointing still often incurs more than 10% overhead <ref type="bibr" target="#b35">[35]</ref>.</p><p>A recently proposed recovery technique, ConAir, conducts single-threaded re-execution and register-only checkpointing <ref type="bibr" target="#b55">[55]</ref>. As shown in <ref type="figure" target="#fig_0">Figure 1</ref>, when a failure happens at a thread, ConAir rolls back the register content of this thread through an automatically inserted longjmp and re-executes from the return of an automatically inserted setjmp, which took register checkpoints. This design offers great performance (&lt;1% overhead), but also imposes severe limitations to failure-recovery capability. Particularly, with no memory checkpoints and re-executing only one thread, ConAir does not allow its re-execution regions to contain writes to shared variables (referred to as W s ) for correctness concerns, severely hurting its chance to recover many failures.</p><p>This limitation can be demonstrated by the real-world example in <ref type="figure">Figure 2</ref>. In this example, the NULL assignment from Thread-2 could execute between the write (A 1 ) and the read (A 2 ) on s→table from Thread-1, and cause failures. At the first glance, the failure could be recovered if we could rollback Thread-1 and re-execute both A 1 and A 2 . However, such rollback and re-execution cannot be allowed by ConAir, as correctness can no longer be guaranteed if a write to a shared variable is re-executed (W s in <ref type="figure">Figure 2</ref>): another thread t could have <ref type="bibr">1</ref> Certain instructions such as system calls will deterministically cause HTM abort and are referred to as trapping instructions. Deterministic aborts, such as those caused by trapping instructions, could cause software to hang if not well handled. We need to guarantee these cases do not happen and ensure software semantics remains unmodified.</p><p>Failure recovery challenges: In order for HTM to help recovery, we need to improve the chances that software executes in a transaction when a failure happens and we need to carefully design HTM-abort handlers to correctly process the corresponding transaction aborts.</p><p>BugTM addresses these challenges by its carefully designed and carefully inserted, based on static program analysis, HTM start, commit, and abort routines. Specifically, we have explored two BugTM designs: BugTM H and BugTM HS , as highlighted in <ref type="table">Table 1</ref>. They are both implemented as LLVM compiler passes that automatically instrument software in the following ways.</p><p>Hardware BugTM, short for BugTM H , uses HTM techniques 2 exclusively to help failure recovery. When a failure is going to happen, a hardware transaction abort causes the failing thread to roll back. The re-execution naturally starts from the beginning of the enclosing transaction, carefully inserted by BugTM H .</p><p>BugTM H provides better recovery capability than ConAir -benefiting from HTM, its re-execution region can contain shared variable writes. However, HTM costs more than setjmp/longjmp. Therefore, the performance of BugTM H is worse than ConAir, but much better than full-blown checkpointing, as shown in <ref type="figure">Figure 3</ref>.</p><p>Hybrid BugTM, short for BugTM HS , uses HTM techniques and setjmp/longjmp together to help failure recovery. BugTM HS inserts both setjmp/longjmp and HTM APIs into software, with the latter inserted only when beneficial (i.e., when able to extend re-execution regions). When a failure is going to happen, the rollback is carried out through transaction abort if under an active transaction or longjmp otherwise.</p><p>BugTM HS provides performance almost as good as ConAir and recovery capability even better than BugTM H by carefully combining BugTM H and ConAir.</p><p>We thoroughly evaluated BugTM H and BugTM HS using 29 real-world concurrency bugs, including all the bugs used by a set of recent papers on concurrency bug detection and avoidance <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b41">41,</ref><ref type="bibr" target="#b55">55,</ref><ref type="bibr" target="#b56">56,</ref><ref type="bibr" target="#b57">57]</ref>. Our evaluation shows that BugTM schemes can recover from many more concurrency-bug failures than state of the art, ConAir, while still provide good run-time performance -3.08% and 1.39% overhead on average for BugTM H and BugTM HS , respectively.</p><p>Overall, BugTM offers an easily deployable technique that can effectively tackle concurrency bugs in production runs, and presents a novel way of using HTM. Instead of using transactions to replace existing locks, BugTM automatically inserts transactions to harden the most failure-vulnerable part of a multi-threaded program, which already contains largely correct lock-based synchronization, with small run-time overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Transactional Memory (TM)</head><p>TM is a widely studied parallel programming construct <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b15">15]</ref>. Developers can wrap a code region in a transaction <ref type="bibr">(Tx)</ref>, and the underlying TM system guarantees its atomicity, consistency, and isolation. Hardware transactional memory (HTM) provides much better performance than its software counterpart (STM), and has been implemented in IBM <ref type="bibr" target="#b12">[12]</ref>, Sun <ref type="bibr" target="#b8">[8]</ref>, and Intel commercial processors <ref type="bibr">[1]</ref>.</p><p>In this paper, we focus on Intel Transactional Synchronization Extensions (TSX). TSX provides a set of new instructions: XBEGIN, XEND, XABORT, and XTEST. We will denote them as <ref type="bibr">StartTx, CommitTx, AbortTx, and TestTx,</ref> respectively for generality. Here, CommitTx may succeed or fail with the latter causing Tx abort. AbortTx explicitly aborts the current Tx, which leads to Tx re-execution unless special fallback code is provided. TestTx checks whether the current execution is under an active Tx.</p><p>There are multiple causes for Tx aborts in TSX. Unknown abort is mainly caused by trapping instructions, like exceptions and interrupts (abort code 0x00). Data conflict abort is caused by conflicting accesses from another thread that accesses (writes) the write (read) set of the current Tx (abort code 0x06). Capacity abort is due to out of cache capacity (abort code 0x08). Nested transaction abort happens when there are more than 7 levels Tx nesting (abort code 0x20). Manual abort is caused by AbortTx operation, with programmers specifying abort code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">ConAir</head><p>ConAir is a static code transformation tool built upon LLVM compiler infrastructure <ref type="bibr" target="#b22">[22]</ref>. It is a state-of-theart concurrency bug failure recovery technique as discussed in Section 1. We describe some techniques and terminologies that will be used in later sections below.</p><p>Recovery capability limitations ConAir does not allow its re-execution regions to contain any writes to shared variables. Many of its re-execution points (i.e., Figure 4: A real-world concurrency bug from MySQL setjmps) are put right after shared-variable writes, which prevent re-execution regions from growing longer and severely limit the recovery capability of ConAir.</p><p>ConAir fundamentally cannot recover any RAW 3 violations (e.g., the bug in <ref type="figure">Figure 2</ref>) and WAR violations, as <ref type="table" target="#tab_2">Table 2</ref> shows. The reason is that the (RA)W and W(AR) have to be re-executed for successful recoveries, but ConAir cannot re-execute shared-variable writes.</p><p>ConAir also cannot recover other types of concurrency bugs if a shared-variable write happens to exist between the failure location and the ideal re-execution point. For example, the RAR atomicity violation in <ref type="figure">Figure 4</ref> cannot be recovered by ConAir due to the write to * buf on Line 3. If Line 3 did not exist, ConAir could have rolled back Thread-1 to re-execute Line 2 and gotten around the failure. With Line 3, ConAir can only repeatedly re-execute the strcat on Line 4, with no chance of recovery.</p><p>Failure instruction f ConAir automatically identifies where failures may happen so that rollback APIs can be inserted right there. This identification is based on previous observations that &gt;90% of concurrency bugs lead to four types of failures <ref type="bibr" target="#b56">[56]</ref>: assertion violations, segmentation faults, deadlocks, and wrong outputs. BugTM will reuse this technique to identify potential failure locations, denoted as failure instructions f in the remainder of the paper. Specifically, ConAir identifies the invocations of __ assert _ fail or other sanity-check macros as failure instructions for assertion failures. ConAir then automatically transforms software to turn segmentation faults and deadlocks into assertion failures: ConAir automatically inserts assertions to check whether a shared pointer variable v is null right before v's dereference and check whether a pointer parameter of a string-library function is null right before the library call; ConAir automatically turns lock functions into time-out lock functions, with a long timeout indicating a likely deadlock failure, and inserts assertions accordingly. ConAir can help recover from wrong output failures as long as developers provide output specifications using assertions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">BugTM H 3.1 High-Level Design</head><p>We discuss our high-level idea about where to put Txs, and compare with some strawman ideas based on perfor-  mance and failure-recovery capability.</p><p>Strawman approaches One approach is to chunk software to many segments and put every segment inside a hardware <ref type="bibr">Tx [28]</ref>. This approach could avoid some atomicity violations, the most common type of concurrency bugs. However, it does not help recover from order violations, another major type of concurrency bugs. Furthermore, its excessive use of Txs will lead to unacceptable overhead for production-run deployment. Another approach is to replace all lock critical regions with Tx. However, this approach will not help eliminate many failures that are caused by missing lock.</p><p>Our approach In BugTM H , we selectively put hardware Txs around places where failures may happen, like the invocation of an __ assert _ fail, the dereference of a shared pointer, etc. This design has the potential to achieve good performance because it inserts Txs only at selected locations. It also has the potential to achieve good recovery capability because in theory it can recover from all common types of concurrency bugs, as shown in <ref type="table" target="#tab_2">Table 2</ref> and explained below. An atomicity violation (AV) happens when the atomicity of a code region C is unexpectedly violated, such as the bug shown in <ref type="figure">Figure 2</ref>. It contributes to more than 70% of non-deadlock concurrency bugs based on empirical studies <ref type="bibr" target="#b26">[26]</ref>, and can be further categorized into 4 sub-types depending on the nature of C, as demonstrated in <ref type="table" target="#tab_2">Table 2</ref>. Conflicting accesses would usually trigger a rollback recovery before the failure occurs, shown by the dashed arrow lines in <ref type="table" target="#tab_2">Table 2</ref>(a)(b)(c), benefiting from the strong atomicity guarantee of Intel TSX -a Tx will abort even if the conflicting access comes from non-Tx code. For the bug shown in <ref type="figure">Figure 2</ref> (an RAW atomicity violation), if we put the code region in Thread-1 inside a Tx, the interleaving NULL assignment from Thread-2 would trigger a data conflict abort in Thread-1 before the if statement has a chance to read the NULL. The reexecution of Thread-1 Tx will then re-assign the valid value to s → table for the if statement to read from, successfully avoiding the failure.</p><p>An order violation (OV) happens when an instruction A unexpectedly executes after, instead of before, instruction B, such as the bug in <ref type="figure" target="#fig_2">Figure 5</ref>. Different from AVs, conflicting memory accesses related to OVs may not all happen inside a small window. In fact, A may not have executed when a failure occurs in the thread of B. Consequently, the Tx abort probably will be triggered by a software failure, instead of a conflicting access, depicted by the dashed arrow in <ref type="table" target="#tab_2">Table 2</ref>(e). Fortunately, the rollback reexecution will still give the software a chance to correct the unexpected ordering and recover from the failure. Take the bug shown in <ref type="figure" target="#fig_2">Figure 5</ref> as an example. If we put a hardware Tx in Thread-1, when order violation leads to the assertion failure, the Tx will abort, rollback, and re-execute. Eventually, the pointer ptr will be initialized and the Tx will commit. Deadlock bugs occur when different threads each holds resources and circularly waits for each other. As shown in <ref type="table" target="#tab_2">Table 2</ref>(f), it can be recovered by Tx rollback and re-execution too, as long as deadlocks are detected.</p><formula xml:id="formula_0">1 //Thread-1 2 3 assert (ptr); //B 4 //should execute after A 1 //Thread-2 2 //ptr is NULL until 3 //initialized at A 4 ptr = malloc (K); //A</formula><p>Of course, BugTM H cannot recover from all failures, because some error-propagation chains cannot fit into a HTM Tx, which we will discuss more in Section 7.</p><p>Next, we will discuss in details how BugTM H surrounds failure sites with hardware Txs-how to automatically insert <ref type="bibr">StartTx, CommitTx, AbortTx,</ref> and fallback-/retry code into software, while targeting three goals: (1) good recovery capability; (2) good run-time performance; (3) not changing original program semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Design about AbortTx</head><p>BugTM H uses the same technique as ConAir to identify where failures would happen as discussed in Sec- </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Design about StartTx and CommitTx</head><p>Challenges We elaborate on two key challenges in placing <ref type="bibr">StartTx and CommitTx,</ref> and explain why we cannot simply insert well-structured atomic blocks (e.g., __ transaction _ atomic supported by GCC) into programs.</p><p>First, poor placements could cause frequent Tx aborts. Trapping instructions (e.g., system calls) and heavy TM nesting (&gt;7 level) deterministically cause aborts, while long Txs abort more likely than short ones due to timerinterrupts and memory-footprint threshold. These aborts hurt not only performance, but also recovery -deterministic aborts of a Tx will eventually force us to execute the Tx region 4 in non-transaction mode, leaving no hope for failure recovery.</p><p>Second, poor placements could cause unpaired execution of <ref type="bibr">StartTx</ref>  Where to <ref type="bibr">StartTx and CommitTx</ref> The design principle is to minimize the chance of aborts that are unrelated to concurrency bugs, tackling the first challenge above. BugTM H achieves this by making sure that its Txs do <ref type="bibr" target="#b3">4</ref> We will refer to the code region between our my _ xbegin and my _ xend as a Tx region, which may be executed in transactional mode.    not contain function calls, which avoids system calls and many trapping instructions, or loops, which avoids large memory footprints. The constraint of not containing function calls will be relaxed in Section 3.5.</p><p>Specifically, for every failure instruction f inside a function F, BugTM H puts a StartTx wrapper function right after the first function call instruction or loop-exit instruction or the entrance of F, whichever encountered first along every path tracing backward from f to the entrance of F. BugTM H puts CommitTx wrapper functions right before the exit of F, every function call in F, and every loop header instruction in F, unless the corresponding loop contains a failure instruction, in which case we want to extend re-execution regions for possible failures inside the loop.</p><p>Analysis for different failure instructions may decide to put multiple <ref type="bibr">StartTx (CommitTx)</ref> at the same program location. In these cases, we will only keep one copy.</p><p>For the toy example in <ref type="figure" target="#fig_4">Figure 7</ref>, the intra-procedural BugTM H identifies Line 2 to put a StartTx, and identifies Line 9 and 12 to put CommitTx, as shown in the figure. How to <ref type="bibr">StartTx</ref>   <ref type="figure">Figure 8</ref>; CommitTx will execute only when there exists an active Tx, as shown in <ref type="figure">Figure 9</ref>.</p><p>Overall, our design so far satisfies performance, correctness, and failure-recovery goals by guaranteeing a few properties. For performance, BugTM H guarantees that its Txs do not contain system/library calls or loops or nested Txs, and always terminate by the end of the function where the Tx starts. For correctness, BugTM H guarantees not to introduce crashes caused by unpairing CommitTx. For recovery capability, BugTM H makes the best effort in letting failures occur under active Txs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Design for fallback and retry</head><p>Challenges It is not trivial to automatically and correctly generate fallback/retry code for all Txs inserted by BugTM H . Since many Tx aborts may be unrelated to concurrency bugs, inappropriate abort handling could lead to performance degradation, hangs, and lost failurerecovery opportunities.</p><p>Solutions BugTM H will check the abort code and react to different types of aborts differently. Specifically, BugTM H implements the following fallback/retry strategy through its my _ xbegin wrapper <ref type="figure">(Figure 8)</ref>.</p><p>Aborts caused by AbortTx inserted by BugTM H indicates software failures. We should re-execute the Tx under HTM, hoping that the failure will disappear in retry (Line 14-17). To avoid endless retry, BugTM H keeps a retry-counter Retrytimes <ref type="figure">(Figure 8</ref>). This counter is configurable in BugTM H , with the default being 1000000.</p><p>Data conflict aborts (Line 14-17) are caused by conflicting accesses from another thread. They are handled in the same way as above, because they could be part of the manifestation of concurrency bugs.</p><p>Unknown aborts and capacity aborts (Line 9-13) have nothing to do with concurrency bugs or software failures. In fact, the same abort code may appear repeatedly during retries, causing performance degradation without increasing the chance of failure recovery. Therefore, the fallback code will re-execute the Tx region in non-transaction mode once these two types of aborts are observed in two consecutive aborts. Nested Tx aborts would not be encountered by BugTM H , because BugTM H Txs are non-nested.</p><p>The above wrapper function not only implements fallback/retry strategy, but also allows easy integration into the target software, as demonstrated in <ref type="figure" target="#fig_4">Figure 7</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Inter-procedural Designs and Others</head><p>The above algorithm allows no function calls or returns in Txs, keeping the whole recovery attempt within one function F. This is too conservative as many functions contain no trapping instructions and could help recovery.</p><p>To extend the re-execution region into callees of F, we put my _ xend before every system/library call instead of every function call. To extend the re-execution region into the callers of F, we slightly change the policy of putting my _ xbegin. When the basic algorithm puts my _ xbegin at the entrance of F, the inter-procedural extension will find all possible callers of F, treat the callsite of F in its caller as a failure instruction, and apply my _ xbegin insertion and my _ xend insertion in the caller.</p><p>We then adjust our strategy about when to finish a BugTM H Tx. The basic BugTM H may end a Tx too early: by placing my _ xend before every function exit, the re-execution will end in a callee function of F before returning to F and reaching the potential failure site in F. Our adjustment changes the my _ xend wrapper inserted at function exits, making it take effect only when the function is the one which starts the active Tx.</p><p>Finally, as an optimization, we eliminate Txs that contain no shared-variable reads the failure instruction f has control or data dependency on. In these cases, the execution and outcome of f is deterministic during reexecution, and hence the failure cannot be recovered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">BugTM HS</head><p>Rollback and re-execution techniques based on HTM (Section 3) and setjmp/longjmp <ref type="bibr" target="#b55">[55]</ref> each has its own strengths and weaknesses. The former allows reexecution regions to contain shared variable writes, which is a crucial improvement over the latter in terms of failure recovery capability. However, it also has higher overhead than the latter. Furthermore, some operations not allowed inside an HTM Tx (e.g. malloc, memcpy, pthread _ cond _ wait), could potentially be correctly re-executed through software techniques <ref type="bibr" target="#b37">[37,</ref><ref type="bibr" target="#b45">45]</ref>.</p><p>To combine the strengths of the above two approaches, we design BugTM HS . The high level idea is that we apply ConAir to insert setjmp and longjmp recovery code into a program first 5 ; and then, only at places where the growth of re-execution regions are stopped by shared-variable writes, we apply BugTM H to extend reexecution regions through HTM-based recovery.</p><p>Next, we will discuss in details how we carry out this high level idea to achieve the union of BugTM H and ConAir's recovery capability, while greatly enhancing the performance of BugTM H .</p><p>Where to setjmp and StartTx ConAir and BugTM H insert setjmp and StartTx using similar algorithms, easing the design of BugTM HS . That is, for every failure instruction f inside a function F, ConAir (BugTM H ) traverses backward through every path p that connects f with the entrance of F on CFG, and puts a setjmp wrapper function (StartTx wrapper function) right after the first appearance of a killing instruction. We will refer to this location as loc setjmp and loc StartTx , respectively. For ConAir, the killing instructions include the entrance of F, writes to any global or heap variables, and a selected set of system/library calls; for BugTM H , the killing instructions include the entrance of F, the loop-exit instruction, and all system/library calls <ref type="bibr" target="#b6">6</ref>  How to retry ConAir and BugTM H insert longjmp and AbortTx wrapper functions, which are responsible for triggering rollback-based failure recovery, using the same algorithm -right before a failure is going to happen as described in Section 2.2 and Section 3.2.</p><p>BugTM HS inserts its rollback function ( <ref type="figure" target="#fig_0">Figure 10)</ref> at the same locations. We design BugTM HS rollback wrapper to first invoke HTM-rollback (i.e., <ref type="bibr">AbortTx)</ref> if it is under an active transaction, which will allow a longer re-execution region and hence a higher recovery probability. The BugTM HS rollback wrapper invokes longjmp rollback if it is not under an active transaction. To make <ref type="bibr" target="#b6">6</ref> BugTM HS also combines the inter-procedural recovery of ConAir and BugTM H in a similar way. We skip details for space constraints. For examples shown in <ref type="figure">Figure 2</ref>, 4, and 7, BugTM HS would insert both setjmp and StartTx into the buggy code regions, because StartTx would provide longer re-execution regions in all three cases. However, if the * buf++ = ' '; statement does not exist in <ref type="figure">Figure 4</ref>, BugTM HS would not insert StartTx there. Consequently, if failures happen, longjmp will be used for recovery.</p><p>Overall, we expect BugTM HS to improve the performance of BugTM H and improve the recovery capability of both BugTM H and ConAir. This will be confirmed through experiments in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Failure Diagnosis</head><p>Previous recovery techniques like ConAir and naive system restart leave failure diagnosis completely to developers, which is often very time consuming. To address this limitation, we design BugTM HS to support failure diagnosis through the root-cause inference routine shown in <ref type="figure" target="#fig_0">Figure 11</ref> and extra logging during recovery.</p><p>The root-cause inference shown in <ref type="figure" target="#fig_0">Figure 11</ref> is mostly straightforward. The rationale of diagnosis based on the number of re-executions (Line 5 and 7) is the following. If the recovery success relies on a code region C in the failure thread to re-execute atomically, probably one reexecution attempt is sufficient, because another unserializable interleaving during re-execution is very rare. This case applies to RAR violation, as shown in Table 2. If the recovery success relies on something to happen in another thread, multiple re-executions are probably needed. This applies to WAW violations and order violations, as shown in <ref type="table" target="#tab_2">Table 2</ref>.</p><p>Note that, BugTM HS and BugTM H could detect and recover the software from concurrency bugs before explicit failures getting triggered. As shown in <ref type="table" target="#tab_2">Table 2</ref>, for several types of atomicity violation bugs, the retry would be triggered by HTM data-conflict aborts, instead of explicit failures. In these cases (Line 9), BugTM HS cannot affirmatively conclude that concurrency bugs have happened. It can only provide hints that certain types of atomicity violations may be the reason for HTM aborts. Along this line, future work could extend BugTM to contain more concurrency-bug detection capability, in addi- BugTM HS also logs memory access type (read/write), addresses, values, and synchronization operations during re-execution, which helps diagnosis with no run-time overhead and only slight recovery delay.</p><p>Of course, some real-world concurrency bugs are complicated. However, complicated bugs can often be decomposed into simpler ones. Furthermore, some principles still hold. For example, if the re-execution succeeds with just one attempt, it is highly likely that an atomicity violation happened to the re-execution region.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Methodology</head><p>Implementation BugTM is implemented using LLVM infrastructure (v3.6.1). We obtained the source code of ConAir, also built upon LLVM. All the experiments are conducted on 4-core Intel Core i7-5775C (Broadwell) machines with 6MB cache, 8GB memory running Linux version 2.6.32, and O3 optimization level.</p><p>Benchmark suite We have evaluated BugTM on 29 bugs, including all the real-world bug benchmarks in a set of previous papers on concurrency-bug detection, fixing, and avoidance <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b41">41,</ref><ref type="bibr" target="#b55">55,</ref><ref type="bibr" target="#b56">56,</ref><ref type="bibr" target="#b57">57]</ref>. They cover all common types of concurrency-bug root causes and failure symptoms. They are from server applications (e.g., MySQL database server, Apache HTTPD web server), client applications (e.g., Transmission BitTorrent client), network applications (e.g., HawkNL network library, HTTrack web crawler, Click router), and many desktop applications (e.g., PBZIP2 file compressor, Mozilla JavaScript Engine and XPCOM). The sizes of these applications range 50K -1 million lines of code. Finally, our benchmark suite contains 3 extracted benchmarks: Moz52111, Moz209188, and Bank.</p><p>The goal of BugTM is to recover from production-run failures, not to detect bugs. Therefore, our evaluation uses previously known concurrency bugs that we know how to trigger failures. In all our experiments, the evaluated recovery tools do not rely on any knowledge about specific bugs in their failure recovery attempts.</p><p>Setups and metrics We will measure the recovery capability and overhead of BugTM H and BugTM HS . We will also evaluate and compare with ConAir <ref type="bibr" target="#b55">[55]</ref>, the state of the art concurrency-bug recovery technique.  To measure recovery capability, we follow the methodology of previous work <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b55">55]</ref>, and insert sleeps into software, so that the corresponding bugs will manifest frequently. We then run each bug-triggering workload with each tool applied for 1000 times.</p><p>To measure the run-time overhead. We run the original software without any sleeps with each tool applied. We report the average overhead measured during 100 failurefree runs, reflecting the performance during regular execution. We also evaluate alternative designs of BugTM, such as not conducting inter-procedural recovery, not excluding system calls from Txs, not excluding loops, etc. Due to space constraints, we only show this set of evaluation results on Mozilla and MySQL benchmarks, two widely used client and server applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experimental Results</head><p>Overall, BugTM H and BugTM HS both have better recovery capability than ConAir, and both provide good performance. BugTM HS provides the best combination of recovery capability and performance among the three.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Failure recovery capability</head><p>Among all the 29 benchmarks, 9 cannot be recovered by any of the evaluated techniques, no matter ConAir or BugTM, and the remaining 20 can be recovered by at least one of the techniques (BugTM HS can recover all of these 20). <ref type="table" target="#tab_7">Table 3</ref> shows the result of 7 benchmarks where different tools show different recovery capability.</p><p>ConAir fails to recover from 6 out of 7 failures in Table 3, mainly because it does not allow shared-variable writes in re-execution regions. As a result, it cannot recover from any RAW or WAR atomicity bugs, and some RAR bugs, including the one in <ref type="figure">Figure 4</ref>.</p><p>BugTM H can successfully recover from all the 6 failures that ConAir cannot in <ref type="table" target="#tab_7">Table 3</ref>. BugTM H cannot recover from the Transmission bug, because recovering this bug requires re-executing malloc, a trapping operation for Intel TSX but handled by ConAir. In fact, malloc is allowed in some more sophisticated TM designs <ref type="bibr" target="#b37">[37,</ref><ref type="bibr" target="#b45">45]</ref>.</p><p>BugTM HS combines the strengths of BugTM H and ConAir, and hence can successfully recover from all 7  Unrecoverable benchmarks There are 9 benchmarks that no tools can help recover for mainly three reasons. Some of these issues go beyond the scope of failure recovery, yet others are promising to address in the future. First, two order violation benchmarks cause failures when the failure thread is unexpectedly slow. Therefore, re-executing the failure thread would not help correct the timing. Fortunately, both failures can be prevented by delaying resource deallocation, a prevention approach proposed before for memory-bug failures <ref type="bibr" target="#b29">[29,</ref><ref type="bibr" target="#b35">35]</ref>. Second, three benchmarks, Cherokee326, Apache25520, and MySQL169, cause failures that are difficult to detect (i.e., silent data corruption). Tackling them goes beyond the scope of failure recovery. Third, the remaining four failures cannot be recovered due to un-reexecutable instructions, which are promising to address. For example, Intel TSX does not support putting memcpy, cond _ wait, or I/O into its Txs. More sophisticated TMs with OS support <ref type="bibr" target="#b37">[37,</ref><ref type="bibr" target="#b45">45]</ref> could help recover these failures. Fortunately, BugTM HS wins most of the lost performance back, incurring 1.4% overhead on average and less than 3% for all but 3 benchmarks. In the worst cases, it incurs 4.2% and 5.3% overhead for two benchmarks in Mozilla JavaScript Engine (JSE), a browser component with little I/O. If we apply BugTM HS to the whole browser, the overhead would be much smaller, as JSE never takes &gt;20% of the whole page-loading time based on our profiling and previous work <ref type="bibr" target="#b31">[31]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Performance</head><p>Comparing BugTM HS with BugTM H , BugTM HS is faster mainly because it has greatly reduced the number of transactions at run time. For example, for the four benchmarks that incur the largest overhead under BugTM H (Moz-JS18025, Moz-JS142651, Click, and Moz-JS79054), BugTM HS reduces the #StartTx per 10µs from 9.4 -30.4 to 2.6 -12.6, and hence dropping the overhead from 8.11-11.9% to 2.6-5.3%.</p><p>Tx abort rate is less than 1% for all benchmarks, with more than 95% of all aborts being unknown aborts (timer interrupts, etc.). As Section 7.4 will show, abort rates and overhead are much worse in alternative designs. Recovery time &amp; Comparison with whole-program restart A successful BugTM failure recovery takes little time. In our experiments, the recovery of atomicity violations and deadlocks mostly takes less than 100 µ-seconds (median is 76 µ-seconds). The recovery of order violations takes slightly longer time, as it highly depends on how much sleep is inserted to trigger the failure. BugTM recovery is much faster than a system restart, which could take a few minutes or even more for complicated systems. It also avoids wasting already conducted computation and crash inconsistencies. For example, without BugTM, MySQL791 would crash the database after a  <ref type="table">Table 5</ref>: BugTM H vs. alternative designs (%: the overhead over baseline execution w/o recovery scheme applied; : failure recovered; : failure not recovered.) 0.00% to 11.9%. As TM researchers found before, performance in TM systems is often complicated <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b34">34]</ref>. An indicating metrics for our benchmarks is the frequency of dynamic StartTx. As shown in the #StartTx per 10µs column of <ref type="table" target="#tab_9">Table 4</ref>, BugTM H executes more than 1 StartTx per 10 micro second on average for 10 benchmarks, and incurs more than 1% overhead for 9 of them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Diagnosis</head><p>BugTM HS can provide diagnosis information for all the 20 benchmarks that it can help recover from. For 13 benchmarks, recoveries through longjmp or HTM rollback are initiated right before explicit failures, for which BugTM HS provides accurate root-cause diagnosis following <ref type="figure" target="#fig_0">Figure 11</ref>. For the other 7, the recoveries are triggered by HTM data-conflict aborts, for which BugTM HS correctly suggests that there might be RAR, RAW, or WAR atomicity violations behind these aborts but cannot provide more detailed root-cause information. BugTM HS provides the option to log memory accesses during failure recovery attempts initiated by longjmp. Evaluation shows that this extra logging incurs 1.01X -2.5X slowdowns to failure recovery with no overhead to regular execution. The 2.5X slowdown happens during a fast half-microsecond recovery. <ref type="table">Table 5</ref> shows the performance and recovery capability of three alternative designs of BugTM H . Due to space constraints, we only show results on benchmarks in MySQL database server and Mozilla browser suite (non-extracted). Since BugTM H is the foundation of BugTM HS , an alternative design that degrades the performance or recovery capability of BugTM H will also degrade BugTM HS accordingly as discussed below. Inter-procedural vs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Alternative designs of BugTM</head><p>Intra-procedural BugTM H uses the inter-procedural algorithm discussed in Section 3.5. This design adds 0.00 -4.3 % overhead to its intraprocedural alternative, as shown in <ref type="table">Table 5</ref>. In exchange, there are 4 benchmarks in <ref type="table">Table 5</ref> that require interprocedural re-execution of BugTM H to recover from. Among them, two can be recovered by ConAir and hence can still be recovered by intra-procedural BugTM HS ; the other two require inter-procedural BugTM HS to recover. Recovering MySQL2011, Moz-xpcom, Moz-JS79054 has to re-execute not only function F where failures occur, but also F's caller. As for Moz-JS142651, we need to re-execute a callee of F where a memory access involved in the atomicity violation resides.</p><p>Including trapping instructions in Txs Clearly, if BugTM H did not intentionally exclude system calls from its Txs, more Txs will abort. This alternative design hurts performance a lot, incurring around 100% overhead for three MySQL benchmarks shown in <ref type="table">Table 5</ref>. Such design also causes BugTM HS to incur more than 20% overhead on these benchmarks. Furthermore, these aborts may hurt recovery capability, as they will cause corresponding Tx regions to execute in non-transaction mode to avoid endless aborts and hence lose the opportunity of failure recovery. This indeed happens for two benchmarks in <ref type="table">Table 5</ref>. One of them will also fail to be recovered by BugTM HS under this alternative design.</p><p>Including loops in Txs could lead to more capacity aborts, which are indeed observed for all benchmarks in <ref type="table">Table 5</ref>. The overhead actually does not change much for most benchmarks. Having said that, it raises the overhead of MySQL791 from 1.98% to 11.5%.</p><p>More Txs We also tried randomly inserting more StartTx. The overhead increases significantly. For Moz-JS142651, when we double, treble, and quadruple the number of dynamic Txs through randomly inserted Txs, the overhead goes beyond 30%, 100%, and 800%. The impact to BugTM HS would also be huge accordingly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Discussion</head><p>As the evaluation and our earlier discussion show, BugTM does not guarantee to recover from all concurrency bug failures, particularly if the bug has a long error propagation before causing a failure. However, we believe BugTM, particularly BugTM HS , would provide a beneficial safety net to most multi-threaded software with little deployment cost or performance loss.</p><p>Several practices can help further improve the benefit of BugTM. First, as discussed in Section 7.1, some improvements of HTM design would greatly help BugTM to recover from more concurrency-bug failures. Second, developers' practices of inserting sanity checks into software would greatly help BugTM. With more sanity checks, fewer concurrency bugs would have long error propagation and hence more concurrency-bug failures would be recovered by BugTM. Third, different from locks, which protect the atomicity of a code region only when the region and all its conflicting code are all protected by the same lock, BugTM can help protect a code region regardless how other code regions are written. Consequently, developers could choose to selectively apply BugTM to parts of software where he/she is least certain about synchronization correctness.</p><p>Finally, BugTM can be applied to software that is already using HTMs. BugTM will choose not to make its HTM regions nesting with existing HTM regions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related Work</head><p>Concurrency-bug failure prevention The prevention approach works by perturbing the execution timing, hoping that failure-triggering interleavings would not happen. It either relies on prior knowledge about a bug/failure <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b27">27]</ref> to prevent the same bug from manifesting again, or relies on extensive off-line training <ref type="bibr" target="#b53">[53,</ref><ref type="bibr" target="#b51">51]</ref> to guide the production run towards likely failure-free timing. It is not suitable for avoiding production-run failures caused by previously unknown concurrency bugs. Particularly, the LiteTx work <ref type="bibr" target="#b51">[51]</ref> proposes hardware extensions that are like lightweight HTM (i.e., without versioning or rollback) to constrain production-run thread interleavings, proactively prohibiting interleavings that have not been exercised during off-line testing. BugTM and LiteTx are fundamentally different on how they prevent/recover-from concurrency-bug failures and how they use hardware support.</p><p>Automated concurrency-bug fixing Static analysis and code transformation techniques have been proposed to automatically generate patches for concurrency bugs <ref type="bibr" target="#b17">[17,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b25">25,</ref><ref type="bibr" target="#b47">47]</ref>. They work at off-line and rely on accurate bug-detection results. A recent work <ref type="bibr" target="#b16">[16]</ref> proposes a data-privatization technique to automatically avoid some read-after-write and read-after-read atomicity violations. When a thread may access the same shared variable with no blocking operations in between, this technique would create a temporary variable to buffer the result of the earlier access and feed it to the later read access. Although inspiring, this previous work is clearly different from BugTM. It does not handle many other types of concurrency bugs, including write-after-read and write-afterwrite atomicity violations and order violations. Furthermore, it relies on analyzing traces of previous execution of the program to carry out data privatization. The different usage contexts lead to different designs.</p><p>Failure recovery Rollback and re-execution have long been a valuable recovery <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b44">44]</ref> and debugging <ref type="bibr" target="#b7">[7,</ref><ref type="bibr" target="#b20">20,</ref><ref type="bibr" target="#b33">33,</ref><ref type="bibr" target="#b43">43]</ref> technique. Many rollback-reexecution techniques target full system/application replay and hence are much more complicated and expensive than BugTM.</p><p>Feather-weight re-execution based on idempotency has been used before for recovering hardware faults <ref type="bibr" target="#b6">[6,</ref><ref type="bibr" target="#b9">9]</ref>. Using it to help recover from concurrency-bug failures was recently pioneered by ConAir <ref type="bibr" target="#b55">[55]</ref>. BugTM greatly improved ConAir. BugTM H and ConAir use not only different rollback/reexecution mechanisms, but also completely different static analysis and code transformation. The setjmp and longjmp used by ConAir have different performance and correctness implications from <ref type="bibr">StartTx, CommitTx, and AbortTx,</ref> which naturally led to completely different designs in BugTM H and ConAir.</p><p>Recent work leverages TM to help recover from transient hardware faults <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b49">49]</ref>. Due to the different types of faults/bugs these tools and BugTM are facing, their designs are different from BugTM. They wrap the whole program into transactions, which inevitably leads to large overhead (around 100% overhead <ref type="bibr" target="#b21">[21,</ref><ref type="bibr" target="#b49">49]</ref>) or lots of hardware changes to existing HTM <ref type="bibr" target="#b24">[24]</ref>, and different design about how/where to insert Tx APIs. They use different ways to detect and recover from the occurrence of faults, and hence have different Tx abort handling from BugTM. They either rely on non-existence of concurrency bugs to guarantee determinism <ref type="bibr" target="#b21">[21]</ref> or only apply for single-threaded software <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b49">49]</ref>, which is completely different from BugTM.</p><p>Others Lots of research was done on HTM and STM <ref type="bibr" target="#b0">[2,</ref><ref type="bibr" target="#b1">3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b36">36,</ref><ref type="bibr" target="#b42">42]</ref>. Recent work explored using HTM to speed up distributed transaction systems <ref type="bibr" target="#b48">[48]</ref>, race detection <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b54">54]</ref>, etc. Previous empirical studies have examined the experience of using Txs, instead of locks, in developing parallel programs <ref type="bibr" target="#b38">[38,</ref><ref type="bibr" target="#b52">52]</ref>. They all look at different ways of using TM systems from BugTM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusions</head><p>Concurrency bugs severely affect system availability. This paper presents BugTM that leverages HTM available on commodity machines to help automatically recover concurrency-bug failures during production runs. BugTM can recover failures caused by all major types of concurrency bugs and incurs very low overhead (1.39%). BugTM does not require any prior knowledge about concurrency bugs in a program and guarantees not to introduce any new bugs. We believe BugTM improves the state of the art of failure recovery, presents novel ways of using HTM techniques, and provides a practical and easily deployable solution to improve the availability of multi-threaded systems with little cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Acknowledgments</head><p>We thank Wei Zhang and Linhai Song for their help in our experiments with ConAir. We are also grateful to the anonymous reviewers whose comments helped bring the paper to its final form. This project is funded by NSF (grants CNS-1563956, IIS-1546543, CNS-1514256, CCF-1514189, CCF-1439091) and CERES Center for Unstoppable Computing.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Single-threaded recovery for concurrency bugs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: A real-world OV bug (simplified from Transmission)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 if(</head><label>1</label><figDesc>Figure 6: BugTM H AbortTx wrapper function (my _ xabort) tion 2.2. BugTM H puts an AbortTx wrapper function my _ xabort right before every failure instruction f , so that a Tx abort and re-execution is triggered right before a failure manifests. my _ xabort uses a unique abort code 0xFF for its AbortTx operation (as shown in Figure 6), so that BugTM H can differentiate different causes of Tx aborts and handle them differently.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: A toy example adapted from Figure 2 (leftside) and its BugTM H transformation (right-side)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>4</head><label></label><figDesc>retry: if((status = _ xbegin()) == _ XBEGIN _ STARTED){ 5 //Tx starts 6 }else{ 7 //abort fallback handler, no active Tx at this point 8 Retrytimes++; 9 if(status==0x00||status==0x08){ 10 //unknown or capacity abort</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Figure 8: BugTM H StartTx wrapper function (my _ xbegin)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>1 if(</head><label>1</label><figDesc>Figure 9: BugTM H CommitTx wrapper function (my _ xend)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>1 if(</head><label>1</label><figDesc>Figure 10: BugTM HS rollback wrapper function sure that the program would not keep attempting hopeless recoveries, BugTM HS continues to use the HTMabort statistics in the StartTx wrapper function shown in Figure 8 and continues to keep the longjmp retry count threshold shown in Figure 10. For examples shown in Figure 2, 4, and 7, BugTM HS would insert both setjmp and StartTx into the buggy code regions, because StartTx would provide longer re-execution regions in all three cases. However, if the * buf++ = ' '; statement does not exist in Figure 4, BugTM HS would not insert StartTx there. Consequently, if failures happen, longjmp will be used for recovery. Overall, we expect BugTM HS to improve the performance of BugTM H and improve the recovery capability of both BugTM H and ConAir. This will be confirmed through experiments in Section 7.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>1</head><label></label><figDesc>Figure 11: Recovery-guided root-cause diagnosis tion to its failure recovery capability. BugTM HS also logs memory access type (read/write), addresses, values, and synchronization operations during re-execution, which helps diagnosis with no run-time overhead and only slight recovery delay. Of course, some real-world concurrency bugs are complicated. However, complicated bugs can often be decomposed into simpler ones. Furthermore, some principles still hold. For example, if the re-execution succeeds with just one attempt, it is highly likely that an atomicity violation happened to the re-execution region.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Common types of concurrency bugs and how BugTM H and ConAir attempt to recover from them. (R/W: 

read/write to a shared variable; thick vertical line: the execution of one thread; dashed arrowed line: the re-execution region of BugTM H ; thin 
arrowed line: the re-execution region of ConAir; explosion symbol: a failure; -: cannot recover; : sometimes can recover if the recovery does not 
require re-executing shared-variable writes; : mostly can recover. The recovery procedure under BugTM HS is a mix of BugTM H and ConAir 
and hence is not shown in table.) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head></head><label></label><figDesc>. BugTM HS slightly modifies the above algorithm. Along every path p, BugTM HS inserts the setjmp wrapper function at every loc setjmp , where ConAir would insert it. In addition, BugTM HS inserts the StartTx wrapper func- tion at loc StartTx , when loc StartTx is farther away from f than loc setjmp (i.e., offering longer re-execution). Note that BugTM HS inserts setjmp at every location loc setjmp where ConAir would have inserted setjmp because ev- ery loc setjmp might be executed without an active hard- ware transaction due to unexpected HTM aborts and others. When loc setjmp is same as loc StartTx , BugTM HS would only insert setjmp without inserting StartTx wrap- per function. Where to CommitTx BugTM HS inserts CommitTx wrap- per functions exactly where BugTM H inserts them. Note that, BugTM HS inserts fewer StartTx than BugTM H , and hence starts fewer Txs at run time. Fortunately, this does not affect the correctness of how BugTM HS inserts CommitTx, because the wrapper function makes sure that CommitTx executes only under an active Tx.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>RootCause ConAir BugTM H BugTM HS</head><label></label><figDesc></figDesc><table>MySQL2011 
AV RAR 
− 


MySQL38883 
AV RAR 
− 


Apache21287 
AV RAW 
− 


Moz-JS18025 
AV RAW 
− 


Moz-JS142651 AV RAW 
− 


Bank 
AV WAR 
− 


Transmission 
OV 

− 


Total 
1 
6 
7 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Recovery capability comparison (Moz-JS: 
Mozilla JavaScript Engine.) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>Run -time Overhead #setjmp #StartTx #StartTx per 10µs Abort% ConAir BugTM H BugTM HS BugTM HS BugTM H BugTM HS BugTM H BugTM HS BugTM H BugTM HS</head><label>Run</label><figDesc></figDesc><table>MySQL2011 
0.05% 
0.13% 
0.08% 
643425 2746031 
778024 
2.3 
0.7 
0.01 
0.01 
MySQL3596 
0.40% 
3.10% 
1.12% 
144212 
110476 
39913 
3.9 
1.4 
0.12 
0.20 
MySQL38883 
0.40% 
3.08% 
1.11% 
144119 
110471 
39904 
3.9 
1.4 
0.11 
0.19 
Apache21287 
0.55% 
3.77% 
3.00% 
40023 
72093 
45520 
22.8 
14.5 
0.08 
0.11 
Moz-JS18025 
0.57% 
9.03% 
2.62% 
3992 
6850 
1159 
16.3 
2.8 
0.29 
0.04 
Moz-JS142651 0.76% 
11.9% 
5.30% 
2145 
9666 
4007 
30.4 
12.6 
0.33 
0.17 
Bank 
0.15% 
2.18% 
2.95% 
6 
5 
5 
0.1 
0.1 
0.0 
0.0 
Moz-ex52111 
0.47% 
0.53% 
0.41% 
4 
3 
0 
0.0 
0.0 
0.0 
0.0 
Moz-ex209188 0.12% 
0.58% 
0.77% 
2 
1 
1 
0.0 
0.0 
0.0 
0.0 
MySQL791 
0.35% 
1.98% 
0.24% 
48998 
4948 
602 
2.5 
0.4 
0.35 
0.01 
MySQL16582 
0.15% 
3.03% 
0.99% 
269543 
153532 
31222 
3.8 
0.8 
0.03 
0.06 
Click 
0.57% 
8.11% 
3.60% 
4681 
5142 
2123 
18.7 
8.1 
0.96 
0.12 
FFT 
0.05% 
0.03% 
0.14% 
23 
25 
19 
0.0 
0.0 
0.0 
0.0 
HTTrack 
0.15% 
0.64% 
0.04% 
9212 
15649 
1572 
0.1 
0.0 
0.83 
0.11 
Moz-xpcom 
0.38% 
0.45% 
0.03% 
324 
1933 
154 
0.0 
0.0 
0.31 
0.51 
Transmission 
0.11% 
0.22% 
0.07% 
1093 
2123 
919 
0.1 
0.0 
0.56 
0.40 
zsnes 
0.05% 
0.03% 
0.44% 
10462 
11737 
372 
0.5 
0.0 
0.13 
0.23 
HawkNL 
0.09% 
0.00% 
0.15% 
10 
19 
16 
0.0 
0.0 
0.0 
0.07 
Moz-JS79054 
0.84% 
11.7% 
4.20% 
338 
1325 
360 
9.4 
2.6 
0.23 
0.44 
SQLite1672 
0.05% 
0.98% 
0.50% 
6 
3 
3 
0.1 
0.1 
0.0 
0.06 
Avg. 
0.31% 
3.08% 
1.39% 
-
-
-
-
-
-
-

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>Table 4 :</head><label>4</label><figDesc></figDesc><table>Overhead during regular execution and detailed performance comparison (red font denotes &gt;3% overhead; #: 
count of dynamic instances; Abort%: percentage of aborted dynamic Txs.) 

benchmarks in Table 3. It recovers the first 6 failures 
through HTM retries. It recovers from the Transmission 
failure through longjmp (it rolls back the malloc that can-
not be handled by HTM-retry through free). 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>Table 4 shows</head><label>4</label><figDesc></figDesc><table>the regular-run overheads of applying 
BugTM schemes to 20 benchmarks, all the benchmarks 
that are recoverable by BugTM HS . 
BugTM H incurs more overhead, about 3% on average, 
than ConAir does, about 0.3% on average, mainly be-
cause a Tx is much more expensive than a setjmp. 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>table is changed</head><label>is</label><figDesc></figDesc><table>but before this change 
is logged, leaving inconsistent persistent states. 
Understanding BugTM H overhead The overhead of 
BugTM H differs among benchmarks, ranging from BugTM H Intra-proc Trapping-Ins 

Loop 

Moz-xpcom 
0.45% 
0.44% 
0.54% 0.20% 
Moz-JS18025 
9.03% 
7.01% 
16.8% 11.3% 
Moz-JS79054 
11.7% 
11.4% 
14.0% 11.1% 
Moz-JS142651 11.9% 
7.6% 
19.6% 12.2% 
MySQL791 
1.98% 
1.50% 
11.4% 11.5% 
MySQL2011 
0.13% 
0.13% 
1.50% 0.06% 
MySQL3596 
3.10% 
3.05% 
108% 2.63% 
MySQL16582 3.03% 
0.16% 
93.1% 1.89% 
MySQL38883 3.08% 
3.04% 
106% 2.52% 

</table></figure>

			<note place="foot" n="2"> This paper&apos;s implementation is based on Intel TSX. However, the principles apply to other vendors&apos; HTM implementations.</note>

			<note place="foot" n="3"> (R/W)A(R/W) is short for (Read/Write)-after-(Read/Write).</note>

			<note place="foot" n="5"> Intel TSX allows setjmp/longjmp to execute inside Txs. 842 2018 USENIX Annual Technical Conference USENIX Association</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Unbounded transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Scott Ananian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krste</forename><surname>Asanovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bradley</forename><forename type="middle">C</forename><surname>Kuszmaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><forename type="middle">E</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sean</forename><surname>Lie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPCA</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tongxin</forename><surname>Bai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xipeng</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengliang</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">N</forename><surname>Scherer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">L</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A key-based adaptive transactional memory executor</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPDPS</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Performance pathologies in hardware transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jayaram</forename><surname>Bobba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><forename type="middle">E</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haris</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Yen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Dhruva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prithviraj</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">-</forename><forename type="middle">J</forename><surname>Hans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pramod</forename><forename type="middle">G</forename><surname>Boehm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">S</forename><surname>Joisha</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The runtime abort graph and its application to software transactional memory optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schreiber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CGO</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Idempotent processor architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karthikeyan</forename><surname>Marc De Kruijf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sankaralingam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MICRO &apos;11</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Eidetic systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Devecsery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xianzheng</forename><surname>Dou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Flinn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Early experience with a commercial hardware transactional memory implementation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dave</forename><surname>Dice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yossi</forename><surname>Lev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Moir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Nussbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marek</forename><surname>Olszewski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Encore: Lowcost, fine-grained transient fault recovery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shuguang</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shantanu</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amin</forename><surname>Ansari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Mahlke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MI-CRO &apos;11</title>
		<imprint>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Using hardware transactional memory for data race detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shantanu</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Florin</forename><surname>Sultan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srihari</forename><surname>Cadambi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Franjo</forename><surname>Ivancic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Rotteler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE IPDPS</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Christos Kozyrakis, and Kunle Olukotun. Transactional memory coherence and consistency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lance</forename><surname>Hammond</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vicky</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><forename type="middle">D</forename><surname>Carlstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">D</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Hertzberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Manohar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Honggo</forename><surname>Prabhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wijaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The ibm blue gene/q compute chip</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruud</forename><surname>Haring</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Ohmacht</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Gschwind</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Satterfield</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krishnan</forename><surname>Sugavanam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Coteus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><surname>Heidelberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Blumrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Wisniewski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="48" to="60" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Larus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rajwar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactional Memory. Morgan &amp; Claypool</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Language support for lightweight transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keir</forename><surname>Fraser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Transactional memory: Architectural support for lock-free data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maurice</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J Eliot B</forename><surname>Moss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Execution privatization for scheduler-oblivious concurrent programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Automated atomicity-violation fixing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoliang</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linhai</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Liblit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Automated concurrency-bug fixing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoliang</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongdong</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Liblit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Deadlock immunity: Enabling systems to defend against deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Horatiu</forename><surname>Jula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Tralamazza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristian</forename><surname>Zamfir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Candea</surname></persName>
		</author>
		<ptr target="https://code.google.com/archive/p/dimmunix/" />
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Debugging operating systems with time-traveling virtual machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Dunlap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of USENIX ATC</title>
		<meeting>USENIX ATC</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Haft: hardwareassisted fault tolerance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dmitrii</forename><surname>Kuvaiskii</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rasha</forename><surname>Faqeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pramod</forename><surname>Bhatotia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pascal</forename><surname>Felber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christof</forename><surname>Fetzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroSys</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">LLVM: A compilation framework for lifelong program analysis &amp; transformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Lattner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vikram</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CGO</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">An investigation of the therac-25 accidents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">G</forename><surname>Leveson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="18" to="41" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">En-HTM: Exploiting hardware transaction memory for achieving low-cost fault tolerance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianli</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qingping</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lanfang</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 Fourth International Conference on Digital Manufacturing &amp; Automation</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Grail: Context-aware fixing of concurrency bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peng</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Omer</forename><surname>Tripp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Learning from mistakes -a comprehensive study of real world concurrency bug characteristics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soyeon</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eunsoo</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Cooperative empirical failure avoidance for multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brandon</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luis</forename><surname>Ceze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Atom-aid: Detecting and surviving atomicity violations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brandon</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Devietti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karin</forename><surname>Strauss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luis</forename><surname>Ceze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Archipelago: Trading address space for reliability and security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Vitaliy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gene</forename><surname>Lvin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emery</forename><forename type="middle">D</forename><surname>Novark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Berger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Logtm: Log-based transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><forename type="middle">E</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jayaram</forename><surname>Bobba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michelle</forename><forename type="middle">J</forename><surname>Moravan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><forename type="middle">D</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">A</forename><surname>Wood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPCA</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">An indepth study of mobile browser performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Javad</forename><surname>Nejati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aruna</forename><surname>Balasubramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on World Wide Web, WWW &apos;16</title>
		<meeting>the 25th International Conference on World Wide Web, WWW &apos;16<address><addrLine>Republic and Canton of Geneva, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1305" to="1315" />
		</imprint>
	</monogr>
	<note>International World Wide Web Conferences Steering Committee</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Nasdaq&apos;s Facebook Glitch Came From Race Conditions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pcworld</surname></persName>
		</author>
		<ptr target="http://www.pcworld.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Quickrec: prototyping an intel architecture extension for record and replay of multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gilles</forename><surname>Pokam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klaus</forename><surname>Danne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristiano</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rolf</forename><surname>Kassa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Kranich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shiliang</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Justin</forename><forename type="middle">Emile</forename><surname>Gottschlich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nima</forename><surname>Honarmand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Dautenhahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><forename type="middle">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Josep</forename><surname>Torrellas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Understanding transactional memory performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmett</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISPASS</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Rx: Treating bugs as allergiesa safe method to survive software failure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Feng</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joe</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jagadeesan</forename><surname>Sundaresan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Transactional lockfree execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rajwar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Goodman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Txlinux: using and managing hardware transactional memory in an operating system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">J</forename><surname>Rossbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Owen</forename><forename type="middle">S</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hany</forename><forename type="middle">E</forename><surname>Ramadan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bhandari</forename><surname>Aditya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmett</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Is transactional programming actually easier? In PPoPP</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">J</forename><surname>Rossbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Owen</forename><forename type="middle">S</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmett</forename><surname>Witchel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Jockey: A user-space library for record-replay debugging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yasushi</forename><surname>Saito</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AADEBUG</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Software bug contributed to black</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Securityfocus</surname></persName>
		</author>
		<ptr target="http://www.securityfocus.com/news/8016" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Do I use the wrong definition? DefUse: Definition-use invariants for detecting concurrency and sequential bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yao</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soyeon</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zuoning</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenguang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weimin</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OOPSLA</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">An integrated hardwaresoftware approach to flexible transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arrvindh</forename><surname>Shriraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">F</forename><surname>Spear</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hemayet</forename><surname>Hossain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Virendra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sandhya</forename><surname>Marathe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">L</forename><surname>Dwarkadas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Triage: Diagnosing production run failures at the user&apos;s site</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengdu</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Spiros</forename><surname>Xanthos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Detecting and surviving data races using complementary schedules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaushik</forename><surname>Veeraraghavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Flinn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Satish</forename><surname>Narayanasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">xcalls: safe I/O in memory transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haris</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andres</forename><forename type="middle">Jaan</forename><surname>Tack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neelam</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Welc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroSys</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Applying transactional memory to concurrency bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haris</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andres</forename><forename type="middle">Jaan</forename><surname>Tack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Gadara: dynamic deadlock avoidance for mult-threaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yin</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terence</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manjunath</forename><surname>Kudlur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephane</forename><surname>Lafortune</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Mahlk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Fast in-memory transaction processing using rdma and htm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xingda</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiaxin</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yanzhe</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rong</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haibo</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Symptomtm: Symptom-based error detection and recovery using hardware transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gulay</forename><surname>Yalcin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Osman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adrian</forename><surname>Unsal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ibrahim</forename><surname>Cristal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mateo</forename><surname>Hur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Valero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE PACT</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="199" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">How do fixes become bugs? In FSE</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ding</forename><surname>Zuoning Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shankar</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lakshmi</forename><forename type="middle">N</forename><surname>Pasupathy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bairavasundaram</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Tolerating concurrency bugs using transactions as lifeguards</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jie</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Satish</forename><surname>Narayanasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Micro</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="263" to="274" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Exploring the emerging applications for transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiaqi</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenguang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xinmin</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weimin</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 Ninth International Conference on Parallel and Distributed Computing, Applications and Technologies</title>
		<meeting>the 2008 Ninth International Conference on Parallel and Distributed Computing, Applications and Technologies</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">AI: a lightweight system for tolerating concurrency bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mingxing</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yongwei</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shanxiang</forename><surname>Qi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jinglei</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weimin</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FSE</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Txrace: Efficient data race detection using commodity hardware transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tong</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongyoon</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Changhee</forename><surname>Jung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASP-LOS</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">ConAir: Featherweight concurrency bug recovery via singlethreaded idempotent execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ang</forename><surname>Marc De Kruijf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karthikeyan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sankaralingam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">ConSeq: Detecting concurrency bugs through sequential errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junghee</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ramya</forename><surname>Olichandran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><surname>Scherpelz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoliang</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Reps</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title level="m" type="main">ConMem: Detecting CrashTriggering Concurrency Bugs through an EffectOriented Approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chong</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junghee</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Reps</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<publisher>ACM TOSEM</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
