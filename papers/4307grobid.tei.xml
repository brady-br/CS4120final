<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:11+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. CopyCat: Controlled Instruction-Level Attacks on Enclaves COPYCAT: Controlled Instruction-Level Attacks on Enclaves</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Moghimi</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadia</forename><surname>Heninger</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">U</forename><surname>Leuven</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Sunar</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Moghimi</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Worcester Polytechnic Institute</orgName>
								<address>
									<settlement>Worcester</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">imec-DistriNet, KU Leuven</orgName>
								<address>
									<settlement>Leuven</settlement>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadia</forename><surname>Heninger</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>San Diego</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">imec-DistriNet, KU Leuven</orgName>
								<address>
									<settlement>Leuven</settlement>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Sunar</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Worcester Polytechnic Institute</orgName>
								<address>
									<settlement>Worcester</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Worcester Polytechnic Institute</orgName>
								<address>
									<addrLine>Jo Van Bulck</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Worcester Polytechnic Institute</orgName>
								<orgName type="institution" key="instit1">KU Leuven</orgName>
								<orgName type="institution" key="instit2">University of California</orgName>
								<address>
									<settlement>San Diego</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. CopyCat: Controlled Instruction-Level Attacks on Enclaves COPYCAT: Controlled Instruction-Level Attacks on Enclaves</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the 978-1-939133-17-5</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The adversarial model presented by trusted execution environments (TEEs) has prompted researchers to investigate unusual attack vectors. One particularly powerful class of controlled-channel attacks abuses page-table modifications to reliably track enclave memory accesses at a page-level granularity. In contrast to noisy microarchitectural timing leakage, this line of deterministic controlled-channel attacks abuses indispensable architectural interfaces and hence cannot be mitigated by tweaking microarchitectural resources. We propose an innovative controlled-channel attack, named COPYCAT, that deterministically counts the number of instructions executed within a single enclave code page. We show that combining the instruction counts harvested by COPYCAT with traditional, coarse-grained page-level leakage allows the accurate reconstruction of enclave control flow at a maximal instruction-level granularity. COPYCAT can identify intra-page and intra-cache line branch decisions that ultimately may only differ in a single instruction, underscoring that even extremely subtle control flow deviations can be deterministically leaked from secure enclaves. We demonstrate the improved resolution and practicality of COPYCAT on Intel SGX in an extensive study of single-trace and deter-ministic attacks against cryptographic implementations, and give novel algorithmic attacks to perform single-trace key extraction that exploit subtle vulnerabilities in the latest versions of widely-used cryptographic libraries. Our findings highlight the importance of stricter verification of cryptographic implementations , especially in the context of TEEs.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In the past years, we have seen a continuous stream of software-based side-channel attacks <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b81">82,</ref><ref type="bibr" target="#b82">83]</ref>. A first category of microarchitectural timing attacks commonly abuses optimizations in modern processors, where secret-dependent state is accumulated in various microarchitectural buffers during the victim's execution. If these buffers are not flushed before a context switch to an attacker domain, victim secrets can be reconstructed by observing timing variations by the attacker. The success of these attacks critically relies on subtle timing differences, making them inherently non-deterministic and prone to measurement noise <ref type="bibr" target="#b27">[28]</ref>. Usually, this class of stateful attacks can be eliminated by isolating leaky microarchitectural resources <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b65">66,</ref><ref type="bibr" target="#b78">79]</ref>.</p><p>Orthogonal to the first class of microarchitectural timing attacks, recent research on controlled-channel attacks <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b71">72,</ref><ref type="bibr" target="#b73">74,</ref><ref type="bibr" target="#b79">80]</ref> has abused the processor's privileged software interface to extract fully deterministic, noise-free side-channel access patterns from enclave applications. While the operating system (OS) was traditionally not considered to be under the attacker's control, this assumption fundamentally changed with the rise of trusted execution environments (TEEs), such as Intel SGX. Prior research <ref type="bibr" target="#b71">[72,</ref><ref type="bibr" target="#b79">80]</ref> has identified pagetable accesses and faults as privileged interfaces that can be exploited as no-noise controlled channels to deterministically reveal enclave memory accesses at a 4 KiB page-level granularity. The paging channel has drawn considerable research attention since it abuses an intrinsic property of the x86 processor architecture without relying on microarchitectural states. In particular, controlled-channel attacks have proven to be challenging to mitigate in a principled way, in spite of numerous defense proposals <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b49">50,</ref><ref type="bibr" target="#b55">56,</ref><ref type="bibr" target="#b59">60,</ref><ref type="bibr" target="#b60">61,</ref><ref type="bibr" target="#b64">65]</ref>.</p><p>In this work, we show that the resolution of deterministic controlled-channel attacks extends well beyond the relatively coarse-grained 4 KiB page-level granularity. We introduce COPYCAT, an innovative interrupt-counting channel that can precisely reconstruct the intra-page control flow of a secure enclave at a maximal, instruction-level granularity. Our attack leverages the SGX-Step <ref type="bibr" target="#b69">[70]</ref> framework to forcibly step into a victim enclave code exactly one instruction at a time. While high-frequency timer interrupts have previously been leveraged to boost microarchitectural timing attacks <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b70">71]</ref>, we exploit the architectural interrupt interface itself as a deterministic controlled channel. In short, our attacks rely on the key observation that merely counting the number of times a victim enclave can be inter-rupted directly reveals the number of executed instructions. We show that combining our fine-grained interrupt-based counting technique with traditional, coarse-grained page-table access patterns <ref type="bibr" target="#b71">[72,</ref><ref type="bibr" target="#b73">74]</ref> as a secondary oracle allows us to construct highly effective and deterministic attacks that track enclave control flow at a maximal, instruction-level granularity. Crucially, the improved temporal dimension of COPYCAT overcomes the spatial resolution limitation of prior controlledchannel attacks, invalidating a key assumption in some prior defenses <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b60">61]</ref> that presumes that adversaries can only deterministically monitor enclave memory accesses at a coarsegrained 4 KiB granularity. Furthermore, in contrast to previous high-resolution SGX side channels <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b70">71]</ref> that rely on timing differences from contention in some shared microarchitectural state, COPYCAT cannot be transparently mitigated by isolating microarchitectural resources.</p><p>To demonstrate the strength of COPYCAT, we develop single-trace attacks that allow efficient cryptographic key recovery from multiple widely-used cryptographic libraries. We extend the cryptanalysis of the binary Euclidean algorithm, which is used for modular inversion in most of the common libraries we examined, and give novel algorithms for efficiently recovering cryptographic keys from a single control flow trace for DSA and ECDSA digital signature generation and RSA key generation. The libraries we examined implemented numerous mitigations against side-channel attacks, including always-add-and-double for elliptic curve scalar multiplication and RSA exponent masking, but these protections were insufficient to protect against COPYCAT. We conclude that new classes of defenses will be necessary to protect against this type of high-granularity, deterministic, and noise-free attack.</p><p>Contributions. In summary, our main contributions are:</p><p>• We propose COPYCAT: a novel deterministic controlledchannel attack to leak runtime control flow from Intel SGX enclaves without noise at an instruction-level granularity.</p><p>• We explore the impact of COPYCAT on non-crypto applications by defeating a state-of-the-art compiler hardening technique against branch shadowing attacks.</p><p>• In an extensive empirical case study of side-channel vulnerabilities in widely-used cryptographic libraries including WolfSSL, Libgcrypt, OpenSSL, and Intel IPP, we verify the practicality and capability of these attacks, demonstrate several attacks, and report vulnerabilities in some of these libraries.</p><p>• We devise new algorithmic techniques to exploit these vulnerabilities in DSA, ECDSA, and ElGamal, as well as RSA key generation, which result in complete key recovery in the context of Intel SGX.</p><p>• Finally, we outline requirements and pitfalls for countermeasures and mitigations in hardware and software.</p><p>Responsible Disclosure. We reported the weaknesses in WolfSSL in Nov. 2019 and provided guidelines for mitigation, tracked via <ref type="bibr">CVEs 2019</ref><ref type="bibr">-1996{0,1,3} and CVE-2020</ref>. We reported our findings to OpenSSL and Libgcrypt teams in Feb. 2020. OpenSSL replaced BN_gcd with a constant-time implementation <ref type="bibr" target="#b9">[10]</ref> in version 1.1.1e. Libgcrypt issued a similar fix that will appear in version 1.8.6. We shared our attack with the Intel product security incident response team (iPSIRT), who acknowledged that COPY-CAT leaks side-channel information, but re-iterated that protecting against side channels requires the enclave developer to follow the constant-time coding best practices as advised by Intel <ref type="bibr" target="#b40">[41]</ref>. Section 7 elaborates further on mitigations and explains how fully preventing our attacks requires the meticulous application of constant-time programming paradigms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and Related Work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Side-Channel Attacks on Intel SGX</head><p>Recent Intel processors include software guard extensions (SGX) <ref type="bibr" target="#b39">[40]</ref> to allow trusted execution of critical code in socalled enclaves on top of a potentially compromised OS. SGX enclaves are isolated at runtime in a memory area that is transparently encrypted and can be remotely attested by the processor. Dedicated eenter and eexit instructions switch the processor in and out of "enclave mode".</p><p>Importantly, while the confidentiality and integrity of enclaved execution is always safeguarded by the processor, traditionally privileged OS software remains in charge of availability concerns. SGX enclaves live in the virtual address space of a conventional, user-space process. To allow for demandpaging and oversubscription of the physically available encrypted memory, enclave page-table mappings are verified but remain under the explicit control of the untrusted OS. Recent address translations may be cached in an internal translation lookaside buffer (TLB), which is flushed by the processor on every enclave transition. When delivering asynchronous interrupts or exceptions, the processor takes care to securely save and scrub CPU registers before exiting the enclave, which can be subsequently re-entered through the eresume instruction. Furthermore, in case of a page-fault event, the processor clears the lower bits representing the page offset in the reported address to ensure that the OS can only observe enclave memory accesses at a 4 KiB page-level granularity.</p><p>While Intel SGX provides strong architectural isolation, several studies have highlighted that enclave secrets may still leak through side-channel analysis. <ref type="table">Table 1</ref> summarizes how all previously demonstrated side-channel attacks fall into two categories: 1 (i) microarchitectural timing attacks, which may achieve a high granularity but are inherently prone to measurement noise, and (ii) fully deterministic controlled-channel attacks that only offer a relatively coarse grained 4 KiB <ref type="table">Table 1</ref>: Characterization of demonstrated Intel SGX microarchitectural side channels (top) and controlled channels (bottom). Our novel COPYCAT technique is highlighted at the bottom and combines noise-free interrupt counting measurements with deterministic page table accesses to reconstruct enclave-private control flow at a maximal, instruction-level granularity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Attack</head><p>Code/Data Granularity Noise page-level granularity. COPYCAT proposes the only generally applicable controlled-channel attack that is both fully deterministic and offers a maximal, instruction-level granularity.</p><p>Microarchitectural Contention. Microarchitectural timing side-channel attacks exploit the fact that various resources, such as caches <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b57">58]</ref>, DRAM row buffers <ref type="bibr" target="#b73">[74]</ref>, branch predictors <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b43">44]</ref>, dependency resolution logic <ref type="bibr" target="#b45">[46]</ref>, or execution ports <ref type="bibr" target="#b2">[3]</ref> are competitively shared between sibling CPU threads or not flushed when exiting the enclave. This contention causes measurable timing differences in the attacker domain, allowing the attacker to infer the private control flow or data access pattern of the enclave with varying degrees of granularity. In the context of a TEE such as Intel SGX, such attacks can be mounted with less noise and improved resolution because the adversary controls the OS. In particular, one line of work has developed interruptdriven attacks <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b69">70]</ref> that rely on frequent enclave preemption to sample side-channel measurements at an improved temporal resolution. This technique has been demonstrated to amplify side-channel leakage from the cache <ref type="bibr" target="#b46">[47]</ref>, the branch target buffer <ref type="bibr" target="#b43">[44]</ref>, and the directional branch predictor <ref type="bibr" target="#b33">[34]</ref>. Similar techniques have been applied to attack ARM TrustZone <ref type="bibr" target="#b53">[54]</ref>. Nemesis <ref type="bibr" target="#b70">[71]</ref> showed that while single stepping, the response time to service an interrupt may reveal which instruction is being executed in the pipeline. The SGX-Step framework <ref type="bibr" target="#b69">[70]</ref> has been leveraged in several other microarchitectural attacks <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b56">57,</ref><ref type="bibr" target="#b66">67,</ref><ref type="bibr" target="#b67">68,</ref><ref type="bibr" target="#b70">71]</ref> to reliably single-step enclaves at a maximal temporal resolution by means of precise and short timer interrupt intervals.</p><p>Controlled-Channel Attacks. Xu et al. <ref type="bibr" target="#b79">[80]</ref> first showed how privileged adversaries can revoke access rights on a specific enclave page and be deterministically notified by means of a page-fault signal when the enclave next accesses that page. They demonstrated several attacks on non-cryptographic applications by observing that page-fault sequences uniquely identify specific points in the victim's execution. Subsequent work <ref type="bibr" target="#b71">[72,</ref><ref type="bibr" target="#b73">74]</ref> developed stealthier techniques to extract the same information without provoking page faults. These attacks interrupt the victim enclave to forcefully flush the TLB and provoke page-table walks, which can later be reconstructed through "accessed" and "dirty" attributes or cache timing differences for untrusted page-table entries. Finally, <ref type="bibr">Gyselinck et al. [29]</ref> demonstrated an alternative controlledchannel attack that abuses legacy IA32 segmentation faults. Their attack offers an improved, byte-level granularity in the first MiB of the enclave address space, but only for the unusual case of a 32-bit enclave, and this behavior has since been fixed in recent microcode.</p><p>With COPYCAT, we contribute an improved attack technique to refine the resolution of existing controlled channels by precisely counting the number of executed enclave instructions between successive page accesses. Prior work has similarly suggested an additional temporal dimension for the paging channel by using interrupts to reconstruct strlen loop iterations <ref type="bibr" target="#b68">[69,</ref><ref type="bibr" target="#b69">70]</ref>, or by logging noisy wall-clock time <ref type="bibr" target="#b73">[74]</ref> for page-access events to improve stealthiness and reduce the number of TLB flushes. Recent work <ref type="bibr" target="#b41">[42]</ref> on enclave control flow obfuscation furthermore investigated using singlestepping in an SGX simulator to probabilistically identify software versions in an emulated enclave debug environment. In contrast to these specialized cases, COPYCAT explicitly recognizes instruction counting as a practical and generically applicable attack primitive that can deterministically capture the execution trace within a single enclave code page.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Cryptographic Signature Schemes</head><p>Signature schemes are extensively used for remote attestation and authentication of trusted enclaves such as Intel SGX <ref type="bibr" target="#b38">[39]</ref>. Moreover, TEEs like Intel SGX can promise trusted execution of these algorithms for a wide range of applications such as trusted key management <ref type="bibr" target="#b24">[25]</ref> and private contact discov-ery <ref type="bibr" target="#b61">[62]</ref>. In this section, we provide an overview of signing algorithms based on public-key cryptography (PKC) that are used in our attack demonstrations.</p><p>RSA. RSA keys <ref type="bibr" target="#b52">[53]</ref> are generated as follows:</p><p>1. Choose large prime numbers p and q, compute N = pq, 2. Compute the least common multiple λ(N) = lcm(p-1, q-1), 3. Choose e such that 1 &lt; e &lt; λ(N) and gcd(e, λ <ref type="formula">(</ref> As a result, attacks on RSA key generation have gained recent attention <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b4">5]</ref>. However, since the private key parameters are only computed once, an attack against RSA key generation must only require a single trace.</p><p>DSA and ElGamal. In the Digital Signature Algorithm (DSA) <ref type="bibr" target="#b25">[26]</ref>, the public parameters are a prime p, another prime divisor n of p − 1, and the group generator g. The private key x is chosen randomly such that 1 &lt; x &lt; n − 1, and the public key is y = g x ( mod p). To sign a message hash h:</p><p>1. Choose a random secret k such that 1 &lt; k &lt; n − 1, 2. Compute r = g k mod p mod n, 3. Compute s = k −1 (h + r · x) mod n. (r, s) is the output signature pair.</p><p>In the ElGamal signature scheme, an alternative to DSA, the first signature pair r is computed similarly, but the second pair is computed as</p><formula xml:id="formula_0">s = k −1 (h − r · x) mod (p − 1).</formula><p>ECDSA. Elliptic-curve DSA (ECDSA) is similar to DSA. The public parameters are an elliptic curve E with scalar multiplication operation ×, a point G on the curve, and the integer order n of G over E. The secret key d is a random integer satisfying 1 &lt; d &lt; n − 1, and the public key is Q = d ×G. Signature generation for a message hash h is as follows:</p><p>1. Choose a random secret k such that 1 &lt; k &lt; n − 1, 2. Compute (x, y) = k × G and r = x mod n,</p><formula xml:id="formula_1">3. Compute s = k −1 (h + r · d) mod n. (r, s) is the output signature pair.</formula><p>In DSA, ECDSA and ElGamal, it is critical for k to be uniquely chosen for each signature generation and to remain secret. Exposing one instance of k for a known signature results in a simple key recovery:</p><formula xml:id="formula_2">d = r −1 (s · k − h) mod n.</formula><p>Since k is an ephemeral value, a noisy side-channel attack against k cannot reduce the sampling noise using multiple runs of the attack. However, as discussed in Section 2.3, lattice attacks can recover the signing key from partial knowledge of k for many signatures. In Section 4.2 and Section 5, we show that we can recover the entire ephemeral k deterministically in a single trace of the computation of the modular inverse k −1 mod n. Single-trace attacks on signature generation illustrate vulnerabilities even in scenarios where an attacker cannot trigger multiple signature generation operations or can only collect a single trace.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Side-Channel Attacks on PKC Schemes</head><p>Public-key algorithms that execute variable operations for each bit of a secret input, like the square-and-multiply algorithm for modular exponentiation, and scalar multiplication based on Montgomery ladders, are susceptible to side-channel leakage. Such algorithms have been exploited in naive attacks <ref type="bibr" target="#b80">[81,</ref><ref type="bibr" target="#b81">82,</ref><ref type="bibr" target="#b83">84]</ref> where the victim is triggered many times to compensate for potential sampling noise. These attacks generally conclude with the recovery of most of the secret bits. Nowadays, most implementations have adopted constant-time algorithms like fixed-window scalar multiplication to mitigate such attacks <ref type="bibr" target="#b51">[52]</ref>.</p><p>Key Recovery using Partial Information. Key recovery from DSA and ECDSA with partial knowledge of the nonce k can be solved efficiently using lattices <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b48">49]</ref>. These attacks apply to the case when a few bits are leaked about the nonce for multiple signatures, and the adversary can sample many signatures. Researchers have applied lattice-based attacks to non-constant time algorithms that leak some information about k <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b54">55]</ref>. <ref type="bibr">Garcia et al. [27]</ref> demonstrate an attack that recovers the sequence of divisions and subtractions from the binary extended Euclidean algorithm (BEEA) for modular inversion. They observe that this sequence leaks some least significant bits of k and apply a lattice-based key recovery algorithm. In contrast, COPYCAT allows full key recovery from a single DSA signature trace, even for a compact BEEA implementation ( §4.2). We generalize this attack to another vulnerable modular inverse implementation used for DSA, ECDSA, and ElGamal ( §5).</p><p>Even subtle implementation flaws that leak the bit length of k are sufficient for multi-trace lattice-based key recovery <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b47">48]</ref>. In these cases, while the algorithm was implemented with enough care to avoid secret-dependent conditional statements, they leak the bit length by skipping the most significant zero bits of k. In Section 4.4, we exploit a countermeasure against this attack to precisely leak the nonce length, and recover the secret key using a lattice attack.</p><p>Single-Trace Attacks on RSA. Recent work has demonstrated a single-trace side-channel attack against RSA key generation that leaks the sequence of divisions and subtractions from the BEEA during the coprimality test gcd(e, p − 1) <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b74">75]</ref> or secret key generation d = e −1 mod λ(N) <ref type="bibr" target="#b17">[18]</ref>. These attacks recover the secrets (p − 1) or lcm(p − 1, q − 1) from this sequence when e is small enough to be brute forced, which is typically the case in practice 2 . The proposed mitigation is to increase the size of the input e by masking it with a random variable that may be hard coded <ref type="bibr" target="#b17">[18]</ref>. In Section 4.3, we use COPYCAT to recover all the branches from BEEA, not just the sequence of divisions and subtractions.We propose a novel algorithm that uses this information to recover the private factors p and q from e −1 mod λ(N). Our attack works even for large e, thwarting the above mitigations.</p><p>Furthermore, our algorithm is even able to recover the key from a modular inversion algorithm with multiple unknowns. We demonstrate a novel end-to-end single-trace attack on the CRT computation q −1 mod p. In a concurrent and independent work, Aldaya et al. <ref type="bibr" target="#b1">[2]</ref> outline a different key recovery algorithm for q −1 mod p that is not always successful. Our single-trace attacks on RSA in Section 4.3 use a branchand-prune algorithm inspired by Heninger and Shacham <ref type="bibr" target="#b30">[31]</ref>. Bernstein et al. applied a variant of branch-and-prune algorithm to recover RSA keys from a sliding-window modular exponentiation implementation <ref type="bibr" target="#b8">[9]</ref>. Similarly, Yarom et al. demonstrated an attack with intra-cache line granularity on a fixed-window implementation of modular exponentiation that recovers a fraction of the bits <ref type="bibr" target="#b82">[83]</ref>. In Section 5, we generalize our attack to implementations of BEEA used in other popular cryptographic libraries. We demonstrate attacks against gcd(p − 1, q − 1) in OpenSSL X.931 RSA and q −1 mod p and e −1 mod λ(N) in WolfSSL and Libgcrypt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">COPYCAT Attack</head><p>Attacker Model. We assume the standard Intel SGX root adversary model with full control over the untrusted OS <ref type="bibr" target="#b39">[40]</ref>. SGX's strong threat model is justified, for instance, by considering untrusted cloud providers under the jurisdiction of foreign nation states, or end users with an incentive to break DRM technology running on their own device. Following prior work, we assume a remote, software-only adversary who has compromised the untrusted OS, allowing the x86 APIC timer device to be configured to precisely interrupt the enclave <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b69">70]</ref> and modify page-table entries to learn enclaved memory accessed at a 4 KiB granularity <ref type="bibr" target="#b60">[61,</ref><ref type="bibr" target="#b71">72,</ref><ref type="bibr" target="#b79">80]</ref>. Like previous attacks, we further assume knowledge of the victim application, either through source code or the application binary. We assume the enclave code is free from memorysafety vulnerabilities <ref type="bibr" target="#b68">[69]</ref> and the Intel SGX platform is properly updated against transient-execution attacks <ref type="bibr" target="#b56">[57,</ref><ref type="bibr" target="#b66">67]</ref>.</p><p>The adversary's goal is to learn fine-grained control-flow decisions in the victim enclave. In contrast to noisy microar-2 e is commonly chosen as 2 16 + 1 = 65537. chitectural side channels <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b45">46,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b70">71]</ref>, we can also target victims who process a secret only once in a single run (as is the case in key generation) and hence victims who cannot be forced to repeatedly perform computations on the same secret multiple times. Crucially, in contrast to prior controlled-channel attacks <ref type="bibr" target="#b71">[72,</ref><ref type="bibr" target="#b79">80]</ref>, COPYCAT offers intrapage granularity and we assume that conditional control flow blocks in the victim enclave are aligned "to exist entirely within a single page" as officially recommended by Intel <ref type="bibr" target="#b38">[39]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Building the Interrupt Primitive</head><p>Debug features like the x86 single-step trap flag are explicitly disabled by the Intel SGX design <ref type="bibr" target="#b39">[40]</ref> while in enclave mode. Recent research, however, has demonstrated that root adversaries may abuse APIC timer interrupts to forcibly pause a victim enclave at fixed time intervals. We build our interrupt primitive on top of the open-source SGX-Step <ref type="bibr" target="#b69">[70]</ref> framework, which offers a maximal temporal resolution by reliably interrupting the victim enclave at most one instruction at a time. SGX-Step comes in the form of a Linux kernel driver and runtime library to configure APIC timer interrupts and untrusted page-table entries directly from user space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Deterministic</head><p>Single-Stepping. We first establish a suitable value for the platform-specific SGX_STEP_TIMER_INTERVAL parameter using the SGX-Step benchmark tool on our target processor. This ensures that the victim enclave always executes at most one instruction at a time. Previous studies <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b69">70,</ref><ref type="bibr" target="#b70">71]</ref> have reported reliable single-stepping results with SGX-Step for enclaves with several hundred thousand instructions where in the vast majority of cases (&gt; 97%) the timer interrupt arrives within the first enclave instruction after eresume, i.e., single-step, and in all other cases the interrupt arrives within eresume itself, i.e., zero-step before an enclave instruction is ever executed. Furthermore, zero-step events can be filtered out by observing that the "accessed" bit in the untrusted page-table entry mapping the enclave code page is only ever set by the processor when the interrupt arrived after eresume and the enclave instruction has indeed been retired <ref type="bibr" target="#b70">[71]</ref>. Hence, to achieve noiseless and deterministic single-stepping for revealing code and data accesses at an instruction-level granularity, we rely on the observation that a properly configured timer never causes a multi-step, and we discard any zero-step events by querying the "accessed" bit in the untrusted page-table entry mapping the current enclave code page. The experimental evaluation in Section 4 confirms that our single-stepping interrupt primitive indeed behaves fully deterministically when using COPYCAT to count several millions of enclave instructions.</p><p>Before entering single-stepping mode, we first use a coarsegrained page-fault state machine to easily advance the enclaved execution to a specific function invocation on the tar-geted code page. Such page-fault sequences have priorly been shown to uniquely locate specific execution points in large binaries <ref type="bibr" target="#b60">[61,</ref><ref type="bibr" target="#b74">75,</ref><ref type="bibr" target="#b79">80]</ref>. Once the specific code page of interest has been located, COPYCAT starts counting instructions until detecting the next code or data page access to reveal instruction-level control flow.</p><p>Effects of Macro Fusion. Interestingly, we found that COPYCAT can also be used to study a microarchitectural optimization in recent Intel Core processors, referred to as macro fusion <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b76">77]</ref>. The idea behind this optimization technique is to combine certain adjacent instruction pairs in the front-end into a single micro-op that executes with a single dispatch and hence frees up space in the processor pipeline.</p><p>Intel documents that fusion only takes place for some welldefined compare-and-branch instruction pairs <ref type="bibr">[38, §3.4.2.2]</ref>, which are additionally not split on a cache line boundary <ref type="bibr">[38, §2.4.2.1]</ref>. We experimentally found that for fusible instruction pairs, COPYCAT consistently counts only one interrupt, even though the enclave-private program counter has been advanced with two assembly instructions forming the fused pair. Our experimental observations on Kaby Lake confirm Intel's documented limitations, e.g., test;jo can be fused (interrupted once) but not cmp;jo (interrupted twice); and fusible pairs that are split across an exact cache line boundary are not fused (interrupted twice). Importantly, we found that macro fusion does not impact the reliability of COPYCAT as a deterministic attack primitive. That is, we consistently observed in all of our attacks that macro fusion depends solely on the architectural program state, i.e., opcode types and their alignments, and hence a given code path always results in the same, deterministic number of interrupts.</p><p>To the best of our knowledge, COPYCAT contributes the first methodology to independently research and reverseengineer macro fusion optimizations in Intel processors. While our observations confirm that macro fusion behaves as specified, we consider a precise understanding of macro fusion of particular importance for compile-time hardening techniques that balance conditional code paths ( §7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Instruction-Level Page Access Traces</head><p>Leakage Model. COPYCAT complements the coarsegrained 4 KiB spatial resolution of previous page fault-driven attacks with a fully deterministic temporal dimension. By interrupting after every instruction and querying page-table "accessed" bits, COPYCAT adversaries obtain an instructiongranular trace of page visits performed by the enclave. This trace may reveal private branch decisions whenever a secretdependent execution path does not access the exact same set of code and data pages at every instruction offset in both branches. Importantly, even when both execution paths access the same sequence of code and data pages, and hence remain indistinguishable for a traditional page-fault adversary <ref type="bibr" target="#b79">[80]</ref>, we show below that compilers may in practice still emit unbalanced instruction counts between page accesses in both branches. Sections 6 and 7 elaborate further on the limitations of this leakage model and the precise requirements for static code balancing solutions.</p><p>If/Else Statement. Conditional branches are pervasive in all applications <ref type="bibr" target="#b29">[30,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b79">80]</ref>, but even side-channel hardened cryptographic software may assume that carefully aligned if/else statements or tight loops cannot be reliably reconstructed ( §4). <ref type="figure" target="#fig_1">Figure 1</ref> provides a minimal example of an if statement that has been hardened using a balancing else branch, e.g., as in the Montgomery Ladder algorithm. The corresponding assembly code, as compiled by gcc, indeed only differs in a single x86 instruction that can fit entirely within the same page and cache line. This if branch is hence indistinguishable for a page-fault or cache adversary. While finer-grained, branch prediction side channels may still be able to reconstruct the branch outcome, these attacks typically require several runs of the victim and can be trivially addressed by flushing the branch predictor on an enclave exit. <ref type="figure" target="#fig_1">Figure 1</ref> illustrates how COPYCAT can deterministically reconstruct the branch outcome merely by counting the number of instructions executed on the P 0 code page containing the if branch before control flow is eventually transferred to the P 1 code page containing the add function, as revealed by probing the "accessed" bit in the corresponding page-table entry. The example furthermore highlights that even if all of the code were to fit on a single code page P 0 = P 1 , COPYCAT adversaries could still distinguish both branches by comparing the relative position of the data access to the stack page S performed by the call instruction. In particular, while traditional page-fault adversaries always see the same page fault sequence (P 0 , S, P 1 ), independent of the secret, COPYCAT enriches this information with precise instruction counts, resulting in distinguishable instruction-level page access traces (P 0 , P 0 , S, P 1 ) vs. (P 0 , P 0 , P 0 , S, P 1 ). Switch-Case Statement. As a further example, <ref type="figure" target="#fig_2">Figure 2</ref> illustrates precise control-flow recovery in a switch-case statement, where the code blocks again fall entirely within a single page and cache line, and where the same data is accessed in every case. While traditional page-fault adversaries always observe an identical, input-independent access sequence to the code and data pages, and the tight sequence of conditional jumps poses a considerable challenge for branch prediction adversaries <ref type="bibr" target="#b43">[44]</ref>, COPYCAT deterministically reveals the entire control flow through the relative position of the data access in the instruction-granular page access traces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Defeating Branch Shadowing Defenses</head><p>To highlight the importance of COPYCAT for noncryptographic applications, we employ its improved resolution to defeat a state-of-the-art compiler defense <ref type="bibr" target="#b31">[32]</ref> against branch predictor leakage. This again shows that COPYCAT changes the attack landscape and requires orthogonal mitigations when compared to microarchitectural side channels.</p><p>Branch Shadowing Mitigation. Lee et al. <ref type="bibr" target="#b43">[44]</ref> first proposed Zigzagger, an automated compile-time approach to defend against branch-shadowing attacks by rewriting conditional branches using cmov and a tight trampoline sequence of unconditional jump instructions. However, the security of their compiler transformation critically relies on the trampoline sequences being non-interruptible, and several proof-ofconcept attacks on Zigzagger have been demonstrated using precise interrupt capabilities <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b69">70,</ref><ref type="bibr" target="#b70">71]</ref>. In response, Hosseinzadeh et al. <ref type="bibr" target="#b31">[32]</ref> designed an improved compiler mitigation that employs runtime randomization to dynamically shuffle jump blocks on the trampoline area, thereby effectively hiding branch targets and making branch shadowing attacks probabilistically infeasible. <ref type="figure" target="#fig_3">Figure 3</ref> illustrates how conditional branches are redirected through randomized jump locations <ref type="bibr" target="#b0">1</ref> on the trampoline page, while ensuring that all jumps <ref type="bibr" target="#b1">2</ref> outside of the trampoline are always executed in the Crucially, while such subtle deviations would indeed very likely not be exploitable through timing, as originally envisioned by the mitigation, we experimentally validated that the unbalanced paths can be fully deterministically distinguished by COPYCAT adversaries. Second, even when the code paths are perfectly balanced, <ref type="figure" target="#fig_3">Figure 3</ref> illustrates that merely counting the number of instructions executed on the trampoline page deterministically reveals whether the victim is executing balancing dummy code in a trampoline block or the actual if block on the instrumented code page. Note that the compiler carefully maintains a constant jump order when moving back and forth between the trampoline area and the instrumented code, ensuring that the execution remains oblivious to classical page-fault adversaries <ref type="bibr" target="#b60">[61,</ref><ref type="bibr" target="#b79">80]</ref> who will always observe the exact same sequence of pages regardless of the actual code blocks being executed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Unleashing COPYCAT on WolfSSL</head><p>WolfSSL is a prominent, FIPS-certified solution officially supporting Intel SGX <ref type="bibr" target="#b77">[78]</ref>. In a case study on the WolfSSL cryptographic library, we show that COPYCAT enables attacks that were not previously possible without a deterministic and fine-grained leakage model. In Section 4.1, we outline our controlled-channel attack using COPYCAT to precisely recover the full execution trace of WolfSSL's implementation of the binary extended Euclidean algorithm (BEEA), which is used for modular inversion of cryptographic secrets in DSA, ECDSA, and RSA. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">COPYCAT on BEEA</head><p>Computing the modular inverse or greatest common divisor (GCD) using the binary extended Euclidean algorithm (BEEA) has previously exposed cryptographic implementations to side-channel attacks <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b74">75]</ref>. The BEEA, as shown in Algorithm 1, is not constant time and can leak various bits of its input. However, previous attacks are limited to recovering only partial and noisy information about the secret input. This limitation stems from low spatial resolution and the presence of noise. For instance, a cache-or page-level attacker who can distinguish which arithmetic subroutines have been invoked cannot determine the outcome of the comparison at line 13 since both directions of the branch generate exactly the same sequence of memory access patterns. In addition, the arithmetic functions may fit within the same page and become indistinguishable for a page-level adversary. Alternatively, a cache attacker may try to track the outcome of these branches within the same page by tracking the corresponding instruction cache lines for the BEEA subroutine. However, a compact implementation of this algorithm can fit multiple branches within the same cache line. While some microarchitectural attacks on the instruction stream may leak some of these low-level branch outcomes, they are all prone to various amounts of noise <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b70">71]</ref>. WolfSSL supports two different BEEA implementations in subroutines fp_invmod_slow and fp_invmod. <ref type="bibr" target="#b3">4</ref> The former is a straightforward implementation, and the latter is a compact implementation that only supports odd moduli. We analyze both implementations and show how to use COPYCAT to recover the runtime control flow of these implementations deterministically and without noise. Algorithm 1 Modular inversion using the BEEA. In the optimized compact implementation when the modulus is odd, highlighted (blue) statements are removed.</p><p>1: procedure MODINV(u, modulus v) 2: </p><formula xml:id="formula_3">b i ← 0 d i ← 1, u i ← u, v i = v, a i ← 1, c i ← 0 3</formula><formula xml:id="formula_4">u i ← u i − v i , b i ← b i − d i , a i ← a i − c i 15: else 16: v i ← v i − u i , d i ← d i − b i , c i ← c i − a i 17:</formula><p>return d i S), including their internal subroutines, shows that they span 2, 895 bytes. Hence, it is reasonable to assume that they can fit into a single 4 KiB page, thus preventing a page-level attacker from distinguishing them at runtime altogether. In addition, even assuming they do not align within the same page, reconstructing the exact execution flow is still impossible. For example, the transition from S to D can result from multiple different code paths. The instructions for fp_invmod_slow can fit into fewer than 6 cache lines with multiple basic blocks 5 overlapping within the same line.</p><p>WolfSSL also supports a modified version of BEEA, fp_invmod specialized to the case of odd modulus, which is used for RSA q −1 mod p ( §4.3) and DSA k −1 mod n ( §4.2). The control flow and overall layout for fp_invmod are similar to the above implementation but it is more compact, as some of the arithmetic statements have been removed. fp_invmod can fit into fewer than 4 cache lines with multiple overlapping basic blocks.</p><p>Recovering BEEA Control-Flow Transfers. We analyzed the runtime control flow of fp_invmod_slow by matching its disassembly with the execution trace we recovered from running COPYCAT. <ref type="figure" target="#fig_5">Figure 4</ref> shows the control flow transfers at page-level granularity for the page corresponding to fp_invmod_slow and the page corresponding to arithmetic functions (Circles). Additionally, the weight of each arrow shows the number of instructions that are executed for fp_invmod_slow before accessing the page corresponding to arithmetic functions. The division loop for u i (u-loop) and v i (v-loop) have a similar control flow. In addition, the two blocks of substitutions after the comparison of u &gt; v have similar control flow for both the left S1 and right S2 direction.  <ref type="figure" target="#fig_1">3,8,5,4,4,13,11,3,8,5,4,4,8,11,3,8,11,3,8,13,4,3,3,8,11,3,11</ref> Only certain transitions are viable from these blocks to division loops during the computation of the modular inverse. For example, S2 always goes to v-loop and S1 always goes to u-loop. Since these instruction counts are distinguishable for transitions that are related to conditional statements, we can use a trace consisting of a vector of these weights in the graph to infer the outcome of the conditional statement. With a trace including the weights of instruction counts collected between two consecutive accesses to the page that holds the arithmetic operations (A, C, D, S), we apply a set of divide-and-conquer rules to reconstruct the control flow for fp_invmod_slow. These rules start by translating the recovered weights to corresponding generic blocks. For example, every time the algorithm executes an iteration of a division loop (u/v-loop), we observe either the sequence D → D → D, or the sequence D → A → S → D → D. Each of these sequences generates a consistent set of weights. Similarly, S1 or S2 always generates a sequence like C → S → S → S. After translating these generic blocks, we can use the remaining transitions to distinguish the exact blocks, i.e., we can recover whether a S1 or S2 followed by a set of division loops is equal to a transition from S1 to u-loop or transition from S2 to v-loop. These rules are summarized as follow: • Rule 2: ?</p><formula xml:id="formula_5">• Rule 1: ? 11 − →? 3 − →? = D → D → D.</formula><formula xml:id="formula_6">13 − →? 4 − →? 3 − →? 3 − →? = D → A → S → D → D. • Rule 3: ? 5 − →? 4 − →? 4 − →? = C → S → S → S.</formula><p>• Rule 4: S? 13 − →? = S2 → v-loop.</p><p>• Rule 5: S?</p><formula xml:id="formula_7">8 − →? = S1 → u-loop.</formula><p>We first replace some of the weights according to Rules 1, 2, and 3, which identify if we are in a division loop (uloop or v-loop) or a comparison and substitution block (S?). Then based on the other transitions (Rule 4 and 5), we can determine which state of the comparison and substitution block we have moved from, and which division loop we have moved to within the trace. An example sequence from the execution of fp_invmod_slow and its translation to the control flow transitions is given in <ref type="figure" target="#fig_6">Figure 5</ref>.</p><p>For the compact implementation in fp_invmod, we apply the same approach. <ref type="figure" target="#fig_7">Figure 6</ref> shows the control flow for this implementation after runtime analysis using COPYCAT. Similarly, we define a set of rules to translate the trace of instruction counts to control flow transfers of BEEA. Based on <ref type="figure" target="#fig_7">Figure 6</ref>, we modify the first three rules as follows to support control-flow recovery based on the same approach: 6</p><p>• Rule 1: ?</p><formula xml:id="formula_8">7 − →? = D → D. • Rule 2: ? 8 − →? 3 − →? 3 − →? = D → S → D. • Rule 3: ? 5 − →? 4 − →? = C → S → S.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Single-Trace Attack on DSA Signing</head><p>In contrast to previous attacks on BEEA that leak partial information about the nonce <ref type="bibr" target="#b26">[27]</ref>, COPYCAT recovers virtually the entire control flow from the execution of this implementation with 100 percent precision. As a result, we can perform a single-trace attack on the DSA signing operation. In Section 5, we generalize this attack and expose multiple vulnerabilities in the Libgcrypt library.</p><p>DSA Key Recovery. WolfSSL uses fp_invmod to compute the modular inversion of k inv = k −1 mod n, where n is an odd prime. Since we can recover the exact control flow of this computation and the modulus n is public, we simply step through the execution trace of Algorithm 1, applying each step of the computation according to the recovered trace to compute k inv bit by bit. After recovering k inv , recovering the full nonce and private key is trivial:</p><formula xml:id="formula_9">k = k −1 inv mod n, x = r −1 (sk − h) mod n.</formula><p>Evaluation. To attack 160-bit DSA, we used a combination of pages in a page-level controlled-channel attack to first reach the beginning of the modular inversion operation for DSA. Then we start COPYCAT over the code page for fp_invmod. We executed this attack for 100 different signing operations. On average, this attack issues 22,000 IRQs and takes 75 ms to iterate over an average of 6,320 steps for each signature generation. Out of 100 experiments, our single-trace attack successfully recovered the full control flow and the key using the algorithm above, implying that COPYCAT reliably reconstructs the entire execution flow. As a result, a single-trace attack on DSA can be executed without the need for multiple signatures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Single-Trace Attacks on RSA KeyGen</head><p>During RSA key generation, WolfSSL checks if a potential prime p is coprime with e by checking if gcd(e, p − 1) is equal to 1. This step uses the textbook greatest common divisor (GCD) algorithm, which simply performs a series of divisions. This algorithm appears to be less vulnerable to control-flow-based key recovery. However, in a later stage, WolfSSL computes d = e −1 mod λ(N) and the CRT parameter q −1 mod p using the BEEA. WolfSSL always generates the CRT parameters during RSA key generation. <ref type="bibr" target="#b6">7</ref> Key Recovery from a q −1 mod p Trace. Compared to k −1 mod n, this attack is more challenging since in this case, both operands p and q are unknown. We give a novel and efficient attack that recovers the private RSA parameters p and q using COPYCAT. We use the relationship of the public modulus N = pq and the execution trace of the BEEA on q −1 mod p, which provides enough information to recover the factorization of N. The main idea is that the BEEA algorithm works sequentially from the least significant bits of p and q. Thus if we iteratively guess bits of p and q starting from the least significant bits, we can verify that a guess matches the relevant steps of the BEEA execution trace, as well as the constraint that N = pq for the bits guessed so far, and eliminate guesses that do not. This algorithm resembles the branch-and-prune algorithm of <ref type="bibr" target="#b30">[31]</ref>, with new constraints.</p><p>We propose Algorithm 2 to recover p and q using only knowledge of N and the execution trace of the BEEA on q −1 mod p. The algorithm starts by initializing a list of hypotheses for values of the least significant bits of q and p. Each Algorithm 2 Recovering p and q from trace of q −1 mod p.</p><p>1: procedure RECOVER_PQ(trace t, modulus N)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2:</head><p>h ← (−test_t(t, 1, 1), 1, 1, 1) <ref type="bibr">3:</ref> while h do <ref type="bibr">4:</ref> steps, b, p, q ← hpop(h) <ref type="bibr">5:</ref> if p.q = N then return p, q 6:</p><formula xml:id="formula_10">g ← (p, q), (p + 2 b , q), (p, q + 2 b ), (p + 2 b , q + 2 b ) 7:</formula><p>for p s , q s in g do <ref type="bibr">8:</ref> if mod(p s .q s , 2 b+1 ) = mod(N, 2 b+1 ) then <ref type="bibr">9:</ref> hpush(h, (−test_t(trace, p s , q s ), b + 1, p s , q s )) hypothesis keeps track of the current step, bit position b, and the hypothesized values of p s = p mod 2 b and q s = q mod 2 b . Among the four possible assignments for the (b + 1) st bits of p and q in Step 7, there will be two choices satisfying the constraint that pq ≡ N mod 2 b+1 . For these new guesses, we evaluate the BEEA algorithm up to the number of bits guessed so far, and check this deterministic algorithm evaluation on the guess against the ground truth execution trace t. We then do a depth-first search prioritized by the number of steps in which the algorithm executed correctly, and terminate when we have found a candidate for which pq = N holds.</p><p>Evaluation. We executed an attack similar to Section 4.2 to collect traces from the modular inversion of q −1 mod p, as it is computed by fp_invmod_slow. We tried this attack on 100 different 2048-bit RSA key generations. On average, we iterate over 39,400 steps by issuing 106490 IRQs in 365 ms. However, the average time to collect a trace can take up to a second depending on how fast the prime numbers are chosen. The attack takes 20 seconds to recover the key from a trace. All 100 trials of the attack successfully recovered the keys.</p><p>Key Recovery from an e −1 mod λ(N) Trace. In contrast to previous attacks on this computation <ref type="bibr" target="#b17">[18]</ref>, we propose a different algorithmic attack that takes advantage of the fact that COPYCAT can recover the entire control flow of this algorithm. As a result, a single-trace attack can be carried out for any value of e, both large or small. This shows that the proposed masking countermeasure in <ref type="bibr" target="#b17">[18]</ref> is insecure against our strong COPYCAT adversary.</p><p>Our goal is to recover the RSA primes p and q using the trace of the BEEA for d = e −1 mod λ(N). The modulus N and the public exponent e are known, while λ(N) is secret. We present a modified branch-and-prune technique in Algorithm 3 that recovers the factors p and q for a large fraction of generated RSA keys.</p><p>The main idea is to iteratively guess bits of p and q starting from the least significant bits, then verify that pq = N and the relevant steps of the BEEA execution trace match the guess so far. However, the BEEA is computed on e and λ(N) = (p − 1)(q − 1)/ gcd(p − 1, q − 1). We do not know gcd(p − 1, q − 1) and must guess it for this algorithm, but with high probability it only has small factors and can be brute forced.</p><p>Algorithm 3 Recovering p and q from trace of e −1 mod λ.</p><p>1: procedure RECOVER_PQ(trace t, e, modulus N)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2:</head><p>h ← (−test_t(t, 0, e), 1, 1, 1) <ref type="bibr">3:</ref> while h do <ref type="bibr">4:</ref> steps, b, p, q ← hpop(h) <ref type="bibr">5:</ref> if p.q = N then return p, q 6:</p><formula xml:id="formula_11">g ← (p, q), (p + 2 b , q), (p, q + 2 b ), (p + 2 b , q + 2 b ) 7:</formula><p>for p s , q s in g do <ref type="bibr">8:</ref> if mod(p s .q s , 2 b+1 ) = mod(N, 2 b+1 ) then For simplicity, we specialize to the case of gcd(p−1, q−1) = 2 i for small integer i below, but the analysis can be extended to other candidate small primes with more brute force effort.</p><p>For each guess 2 i for gcd(p − 1, q − 1), we iteratively generate guesses for p s and q s , compute φ s = (p s − 1)(q s − 1) and then λ s = φ s /2 i . We compare the execution trace t to the execution trace for λ s and e. The algorithm either returns p and q or it fails to recover p and q if φ/λ(N) = 2 i .</p><p>Analysis. The algorithm will succeed whenever φ/λ = 2 i for small i. For non-powers of 2 the test against the BEEA execution trace in Step 15 will likely fail, and cause this branch to be pruned. Since p = 2p + 1 and q = 2q + 1 for some p , q ∈ Z, we have λ(N) = lcm(p − 1, q − 1) = 2lcm(p , q ). From the prime number theorem <ref type="bibr" target="#b58">[59]</ref>, the probability that two random integers are coprime converges to ∏ p∈primes (1 − 1/p 2 ) = 6 π 2 ≈ 61% as the size of the integers increases. In other words, if we run Algorithm 3 for only i = 1, it will succeed 61% of the time when p and q are actually coprime. If we allow p and q to have even factors we obtain a probability of ∏ p∈primes,p&gt;2 (1 − 1/p 2 ) = 8 π 2 ≈ 81%. This means that even for a modest number of iterations, e.g. = 8, we have nearly 81% success probability. These estimates are confirmed by our experiments.</p><p>Evaluation. We tried this attack on 100 different key generation efforts (2048-bit key). On average, we iterate over 81,090 steps by issuing 230,050 interrupts per attack in 800ms. The average time to collect a trace is about a second and the attack takes about 30 seconds to successfully recover the key for 81% of the keys when lcm((p − 1)(q − 1)) ≡ (p − 1)(q − 1)/2 i .</p><p>Revisiting Masking Protection. Earlier attacks required brute forcing over e <ref type="bibr" target="#b74">[75]</ref>. Our algorithm works for arbitrary, even full length e. Thus increasing the size of e by choosing a bigger public exponent or masking is not sufficient to  Listing 1: wc_ecc_mulmod_ex implements scalar multiplication using a bit-by-bit always-add-and-double algorithm. The function protects against both timing and cache attacks by executing dummy instructions. For brevity, error checking and code sections that are not relevant to our attack are removed. mitigate our attack. Aldaya et al. <ref type="bibr" target="#b4">[5]</ref> proposed masking e by computing b = (er) −1 mod λ(N) for a random r such that gcd(r, λ(N)) = 1. The private key then can be computed as d = rb mod λ(N). In this proposal, it is even suggested that r can be hard coded. We tested our attack for a hard coded (known) choice of r and verified that key recovery works in this case. Alternatively, if r is not hard coded but we have a trace for the initial gcd(r, λ(N)) computation using binary gcd, we can again decode it (with the knowledge of N) to recover r. With r recovered, the attack proceeds as before, i.e. from the execution trace of b = (er) −1 mod λ(N) we recover p and q by running Algorithm 3 with er supplied as input instead of e. Since Algorithm 3 is agnostic with respect to the size of e, it will handle the full size er and recover p and q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Breaking ECDSA Timing Protection</head><p>WolfSSL uses the subroutine wc_ecc_mulmod_ex (Listing 1) to compute the scalar multiplication k × G while generating the signature. This subroutine has built-in mitigations against side-channel attacks and implements an always-add-and-double algorithm by arithmetizing the conditional check for the add. As a result the scalar operations add at Line 15/18 and double at Line 16/19 will both be executed for all scalar bits. This prevents an adversary learning the nonce k bit by bit. The second countermeasure that is implemented in this implementation aims to protect against attacks exploiting the bit length of the nonce <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b47">48]</ref>. This is done by executing a sequence of dummy operations for each leading zero bit. While these dummy operations mitigate side channels like data cache attacks, page-level attacks, and timing attacks, we can use COPYCAT to distinguish the branch outcome at Line 13 and leak the bit length of nonce k.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Recovering Dummy</head><p>Operations. We analyze wc_ecc_mulmod_ex using COPYCAT. In this analysis, we count the number of instructions that are executed between consecutive accesses to the page that holds the ecc_projective_dbl_point subroutine. The trace shows that for one transition of basic blocks, we can observe 49 steps when the function is processing the dummy operations. As soon as the subroutine switches to the real operations, this step count will change to 46. As a result, we can use this information to determine the number of dummy executions of the always-add-and-double sequence from a set of traces. Since we only need to observe the first few bits in order to recover the length of the nonce, we shortened our trace collection to observe only the first 7 bits.</p><p>Lattice Attack using the Nonce Bit Length. We generated many signature traces, recovered the nonce lengths, and filtered for signatures with short nonces <ref type="bibr" target="#b12">[13]</ref>. We followed the approach of Howgrave-Graham and Smart <ref type="bibr" target="#b32">[33]</ref> and Benger et al. <ref type="bibr" target="#b7">[8]</ref> to formulate the key recovery as a lattice problem.</p><p>Evaluation. We executed this attack for 10,000 signing operations. Our attack recovered the number of leading zero bits with 100% accuracy. On average, each attack issues 3244 IRQs to count 2542 steps of the scalar multiplication operation. <ref type="table" target="#tab_3">Table 2</ref> shows the results for key recovery using various nonce bit lengths. Since the nonce length is recovered without noise, the lattice attack is quite efficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">COPYCAT-Based Side-Channel Analysis</head><p>Now that we have empirically verified through real-world attacks that COPYCAT can recover the runtime control flow of all the branches deterministically, we analyze similar cryptographic implementations in other open-source libraries including the latest Libgcrypt 1.8.5, OpenSSL 1.1.1d, and Intel IPP Crypto <ref type="bibr" target="#b34">[35]</ref>. OpenSSL and Intel IPP Crypto are particularly important for products using Intel SGX. Intel has an official wrapper around OpenSSL, called Intel SGX-SSL <ref type="bibr" target="#b36">[37]</ref>.</p><p>Algorithm 4 Modular inversion using a variant of BEEA.</p><p>1: procedure MODINV(u, modulus v) 2:</p><formula xml:id="formula_12">u 1 ← 1, u 2 ← 0, u 3 ← u 3: v 1 ← v, v 2 ← u 1 − u, v 3 ← v 4:</formula><p>if isOdd(u) then 5:</p><formula xml:id="formula_13">t 1 ← 0,t 2 ← −1,t 3 ← −v 6: else 7: t 1 ← 1,t 2 ← 0,t 3 ← u 8:</formula><p>while t 3 = 0 do 9:</p><p>while isEven(t 3 ) do <ref type="bibr">10:</ref> if isOdd(t 1 ) or isOdd(t 2 ) then 11:</p><formula xml:id="formula_14">t 1 ← t 1 + v,t 2 ← t 2 − u 12: t 1 ← t 1 /2,t 2 ← t 2 /2,t 3 ← t 3 /2 13: if t 3 &gt; 0 then 14: u 1 ← t 1 , u 2 ← t 2 , u 3 ← t 3 15: else 16: v 1 ← v − t 1 , v 2 ← −u − t 2 , v 3 ← −t 3 17: t 1 ← u 1 − v 1 ,t 2 ← u 2 − v 2 ,t 3 ← u 3 − v 3 18: if t 1 &lt; 0 then t 1 ← t 1 + v,t 2 ← t 2 − u return u 1</formula><p>The current version of Intel SGX-SSL is based on the stable OpenSSL 1.1.1d. Intel IPP Crypto is the official cryptographic library by Intel, and it is deployed in many Intel products including Intel SGX SDK <ref type="bibr" target="#b38">[39]</ref>. <ref type="table" target="#tab_4">Table 3</ref> summarizes our findings in this paper regarding vulnerable code paths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Libgcrypt Analysis</head><p>Libgcrypt uses a custom implementation of the extended Euclidean algorithm to compute modular inverses (Algorithm 4). This algorithm is based on an exercise from The Art of Computer Programming [43, Vol II, §4.5.2, Alg X]. The algorithm is an adaptation of Algorithm X to use the efficient divide by 2 reduction steps in the Binary Euclidean Algorithm. The algorithm computes a vector (u 1 , u 2 , u 3 ) such that uu 1 + vu 2 = u 3 = gcd(u, v) using auxiliary vectors (v 1 , v 2 , v 3 ), (t 1 ,t 2 ,t 3 ). The iterations preserve the invariants ut 1 + vt 2 = t 3 , uu 1 + vu 2 = u 3 and uv 1 + vv 2 = v 3 . This algorithm is used in numerous places for secret operations.</p><p>k −1 mod n in DSA, ECDSA and ElGamal. The DSA, ECDSA and ElGamal signature schemes all require computing k −1 mod n. In Libgcrypt, all of these computations are performed using Algorithm 4. We derive a single-trace attack similar to Section 4.2 that recovers all the branches of this algorithm during this computation. This trivially leaks k −1 for each of these algorithms in a single-trace attack. As a result, they are all vulnerable to the attack described in Section 4.2. Note that no masking countermeasure is used for DSA and ElGamal, and we discuss below how the masking countermeasure for ECDSA is insecure.</p><p>ECDSA Masking Countermeasure. We identified two vulnerabilities in how masking is applied during ECDSA signing in Libgcrypt, as shown in Listing 2, which leaves it  (e −1 mod Λ(N)) → generate_{std,fips,x931}</p><formula xml:id="formula_15">(k × G) → wc_ecc_sign_hash Greatest Common Divisor (fp_gcd) Euclidean (Divisions) N/A N/A (k −1 mod n) → wc_DsaSign (q −1 mod p) → wc_MakeRsaKey W o lf S S L Modular Inverse (fp_invmod) BEEA (e −1 mod Λ(N)) → wc_MakeRsaKey Greatest Common Divisor (mpi_gcd) Euclidean (Divisions) N/A N/A (k −1 mod n) → {dsa,</formula><p>Greatest Common Divisor (BN_gcd) BEEA The second vulnerability is that since b needs to be inverted in this blinding scheme, Libgcrypt computes the b −1 mod n using the same vulnerable implementation (Listing 3). Therefore, a single-trace attack can also recover the blinding value. RSA Input Masking. To avoid timing attacks, RSA decryption and signing in Libgcrypt use masking on the input ciphertext or message. For a random variable r and input ciphertext c, the decryption is performed on m b = (cr e ) d mod n = c d r mod n. The message can then be unblinded by computing m = m b r −1 = c d mod n. Unfortunately, the r −1 mod n is also computed using the vulnerable modular inverse function. As a result, a single-trace attack can recover the blinding factor, rendering this countermeasure ineffective.</p><formula xml:id="formula_16">gcd(q − 1, p − 1) → RSA_X931_derive_ex O p e n S S L Modular Inverse (BN_mod_inverse_no_branch) BEEA w/ Branches N/A N/A N/A ? gcd(q − 1, e) → cpIsCoPrime N/A Greatest Common Divisor (ippsGcd_BN) Modified Lehmer's GCD ? gcd(p − 1, q − 1) → isValidPriv1_rsa N/</formula><p>RSA Key Generation. Three RSA key generation subroutines in Libgcrypt: generate_std, generate_fips and generate_x931 all use the vulnerable mpi_invm function to compute both q −1 mod p and e −1 mod λ(N), and are vulnerable to the attacks described in Section 4.3.</p><formula xml:id="formula_17">1 if (!BN_sub(r1, rsa−&gt;p, BN_value_one())) goto err; / * p−1 * / 2 if (!BN_sub(r2, rsa−&gt;q, BN_value_one())) goto err; / * q−1 * / 3 if (!BN_mul(r0, r1, r2, ctx)) goto err; / * (p−1)(q−1) * / 4 if (!BN_gcd(r3, r1, r2, ctx)) goto err;</formula><p>Listing 4: RSA_X931_derive_ex uses BN_gcd to compute λ(N), exposing p and q to our attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Analysis of OpenSSL</head><p>After many iterations and multiple attacks <ref type="bibr" target="#b26">[27,</ref><ref type="bibr" target="#b74">75]</ref>, OpenSSL implemented a constant-time modular inversion function, BN_mod_inverse_no_branch for DSA, ECDSA, and RSA key generation. In various critical primitives, this function is also used to compute the GCD. However the legacy binary GCD function is still supported in the latest OpenSSL code base, version 1.1.1d, in the function BN_gcd (cf. Appendix Algorithm 5). The subroutine RSA_X931_derive_ex, which is responsible for generating RSA keys according to the X.931 standard, uses this function during the computation of λ(N) = lcm(p − 1, q − 1) = (p − 1)(q − 1)/gcd(p − 1, q − 1), as shown in Listing 4. Thus we can apply our attack technique from Section 4.3 to recover the RSA private key from the computation of gcd(p − 1, q − 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Analysis of Intel IPP Crypto</head><p>The Intel IPP Crypto library uses a conventional Euclidean algorithm to compute modular inverses. This algorithm per-forms a series of division operations in a loop. While COPY-CAT can recover the precise number of division operations, this leakage does not seem to be exploitable during the RSA key generation <ref type="bibr">[48, §6]</ref>.</p><p>On the other hand, for computing the GCD, Intel IPP Crypto uses a modified version of Lehmer's GCD algorithm <ref type="bibr" target="#b62">[63]</ref>. Lehmer's GCD algorithm and Intel's modified implementation are not constant time, and have secret-dependent branches <ref type="bibr" target="#b35">[36]</ref>. This GCD implementation is only used during RSA key generation, where only a single-trace attack results in a vulnerability. Our analysis in Section 4.3 does not directly apply to this algorithm, and we leave the analysis and potential exploitability of this implementation for future work. This potential oversight in Intel's GCD implementation once more illustrates the intricacies of applying Intel's own recommended constant-time programming guidelines <ref type="bibr" target="#b40">[41]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">More Single-Trace Attack Evaluations</head><p>Attack on DSA, ECDSA and ElGamal (Libgcrypt). We replicated the attack in Section 4.2 using synthetic traces from Algorithm 4. We ran the attack on 100 different k −1 mod n and recovered k inv and the secret key in all cases. The attack applies to ElGamal as well by computing the private key</p><formula xml:id="formula_18">x = r −1 (h − sk) mod (p − 1).</formula><p>Attack on RSA Key Generation (Libgcrypt, OpenSSL). We replicated synthetic traces of branches from OpenSSL's binary GCD algorithm executed on gcd(q − 1, p − 1). We applied Algorithm 2 with a modified test function modeling this algorithm, and applied a heuristic to match the appropriate number of trace steps to the bits guessed so far. We ran the attack using synthetic traces for 100 different 256-bit RSA keys. This key size is chosen to efficiently verify the correctness of our algorithm. Our attack successfully recovered every key. We similarly replicated the same attack as Section 4.3 with a test function following Algorithm 4. Similarly, we ran the attack using synthetic traces for 100 different 256-bit RSA keys and the attack was successful in all cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Limitations and Future Work</head><p>Vulnerable Code Patterns. COPYCAT interrupts a victim enclave precisely one instruction at a time and relies on a secondary page-table oracle to assign a spatial resolution to each instruction-granular observation. Our attack is thus only effective when the victim code contains a secret-dependent branch that accesses a different code or data page at the same instruction offset in both execution paths. In contrast to previous controlled-channel attacks <ref type="bibr" target="#b60">[61,</ref><ref type="bibr" target="#b71">72,</ref><ref type="bibr" target="#b79">80]</ref>, our notion of instruction-granular page access traces allows the sequence of code and data page visits in both branches to be identical.</p><p>We essentially only need a "marker" page that is accessed at a different relative instruction offset in the secret-dependent execution path. We found that in practice compilers generate code with different page accesses at different instruction offsets in both branches for a variety of reasons, including data or stack accesses, arithmetic operations, and subroutine calls. The evaluation of the previous sections clearly shows that the instruction-granular page access traces extracted by COPYCAT are strictly stronger, and can hence target more vulnerable code patterns, than the page fault sequences exploited by prior controlled-channel attacks. In order to not be vulnerable to COPYCAT, secret-dependent code paths should ideally be avoided altogether, or they should be explicitly aligned in such a way that both branches always access the exact same set of code and data pages for every instruction among both execution paths.</p><p>Automation Opportunities. The case-study attacks presented in this paper relied on careful manual inspection of the victim enclave source code and binary layout to identify vulnerable secret-dependent code patterns. We expect that dynamic analysis and symbolic execution approaches could further improve the effectiveness of our attacks, and increase confidence for defenders, by automating the discovery of vulnerable code patterns <ref type="bibr" target="#b72">[73,</ref><ref type="bibr" target="#b75">76]</ref> and possibly even the synthesis of proof-of-concept exploitation code. While the requirements for vulnerable code patterns are relatively clearcut, as described above, we expect that it may be particularly challenging to automatically track the propagation of secrets and distinguish between non-secret and secret-dependent control flows <ref type="bibr" target="#b10">[11]</ref>.</p><p>Comparison to Branch Prediction Leakage. <ref type="table">Table 1</ref> identified branch prediction side channels <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b43">44]</ref> as an alternative attack vector to spy on enclave control flow at an instruction-level granularity with reasonable accuracy. In contrast to COPYCAT, however, microarchitectural leakage from branch predictors is inherently noisy and typically requires multiple runs of the victim enclave, ruling out this class of side channels for the noiseless single-trace attacks on key generation algorithms presented in this paper. Furthermore, in contrast to the architectural interrupt and paging interfaces exploited by COPYCAT, branch prediction side-channel leakage can be eradicated relatively straightforwardly by flushing branch history buffers when exiting the enclave, similar to the microcode updates Intel already distributed to flush branch predictors on enclave entry in response to Spectre threats <ref type="bibr" target="#b18">[19]</ref>.</p><p>In addition to being deterministic, our attack is significantly easier to scale and replicate, considering that branch predictors feature a complex design that may change from one microarchitecture to the other. BranchScope <ref type="bibr" target="#b23">[24]</ref>, for instance, relies on finding a heuristic through reverse engineering to probe a specific branch. This heuristic is dependent on (i) the state of other components like global and tournament predictors; and (ii) the exact binary layout of the victim program.</p><p>Previous attacks focus on distinguishing one or a small number of branches and we believe that replicating BranchScope to probe multiple branches across various targets (e.g., BEEA) would be challenging and may even be practically infeasible. COPYCAT, in contrast, is much easier to replicate, and we showed in Section 4 that our attack scales to probing the entire execution path in a single run.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Mitigation Strategies</head><p>Interrupt Detection. COPYCAT relies on the ability to single-step enclaved execution, which is within Intel SGX's threat model <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b69">70]</ref>. While SGX enclaves remain explicitly interrupt-unaware by design, some research proposals <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b59">60]</ref> retrofit hardware support for transactional memory to detect suspicious interrupt rates as a side-effect of an ongoing attack. However, such features are not commonly available on offthe-shelf SGX hardware, and they would not fundamentally address the attack surface as COPYCAT adversaries are likely to develop stealthier attack techniques <ref type="bibr" target="#b71">[72,</ref><ref type="bibr" target="#b73">74]</ref> that remain under the radar of heuristic defenses. Nevertheless, following a long line of microarchitectural attacks <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b69">70,</ref><ref type="bibr" target="#b70">71]</ref> abusing interrupts, our study provides strong evidence that interrupts may also amplify deterministic controlled-channel leakage and should be taken into account in the enclaved execution threat model. We advocate for architectural changes in the Intel SGX design and further research to rule out interruptdriven attack surface <ref type="bibr" target="#b16">[17]</ref>.</p><p>Self-Paging. Recent work <ref type="bibr" target="#b49">[50]</ref> proposes modifications to the Intel SGX architecture to rule out page-fault controlled channels by delegating paging decisions to the enclave. The proposed design modifies the processor to no longer report the faulting page base address to the untrusted OS and to not update "accessed" and "dirty" page-table attributes when in enclave mode. While these modifications would indeed thwart the deterministic spatial dimension of the COPYCAT instantiations described in this paper, we expect that adversaries may adapt by resorting to alternative side-channel oracles to construct instruction-granular page access patterns. A particularly promising avenue in this respect would be to combine COPYCAT interrupt counting with the distinct timing differences observed for unprotected page-table entries that were brought into the CPU cache during enclaved execution <ref type="bibr" target="#b71">[72]</ref>.</p><p>Static Code Balancing. We encourage future research in improved compile-time hardening techniques that may automatically rewrite conditional branches to always ensure a constant interrupt counting pattern, regardless of the executed code. The key requirement for such a defense would be to ensure that the adversary not only observes a secret-independent sequence of pages but also always counts the same number of instructions between page transitions. To achieve such a guarantee, the compiler would also have to be explicitly aware of macro fusion, as explained in Section 3.1, when balancing the observed instruction counts. We expect further challenges when dealing with secret-dependent loop bounds, as in our attacks of Section 4. To handle data accesses, control-flow balancing techniques could potentially be combined with existing solutions for data location randomization <ref type="bibr" target="#b13">[14]</ref>.</p><p>Constant-Time Implementation. The best practice for cryptographic implementations is to avoid secret-dependent branches and memory lookups. WolfSSL applied such a countermeasure to mitigate our attack on ECDSA <ref type="bibr">(CVE-2019- 19960</ref>). Bernstein and Yang proposed a constant-time GCD algorithm that can be used for applications like modular inversion <ref type="bibr" target="#b9">[10]</ref>. However, constant-time implementations are not easy for generic non-cryptographic applications <ref type="bibr" target="#b63">[64]</ref>. While there are tools and techniques to test <ref type="bibr" target="#b75">[76]</ref>, verify <ref type="bibr" target="#b5">[6]</ref>, and generate <ref type="bibr" target="#b11">[12]</ref> constant-time code, the scalability and performance of these approaches is still far from settled.</p><p>Cryptographic Countermeasures. While it is preferable to avoid secret-dependent branches altogether, specific countermeasures can be applied to some cryptographic schemes. As we discuss in Section 5, masking the input of the modular inversion can mitigate our demonstrated attack if it is applied properly and the blinding value itself is not leaked. WolfSSL applies this solution to mitigate our attack on DSA <ref type="bibr">(CVE-2019-19963)</ref>. However, as we showed in Section 5 and Section 4.3, these countermeasures should be applied carefully in the presence of a powerful adversary.</p><p>Some operations have more secure alternative implementations. In particular, for the attack on q −1 mod p RSA-CRT key generation <ref type="bibr">(CVE-2020-7960</ref>), Fermat's Little Theorem computes q p−2 mod p. As a result, the implementation can avoid modular inversion for this operation, and instead rely on a constant-time modular exponentiation implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>Our works show that deterministic controlled-channel adversaries are not restricted to observing enclave memory accesses at the level of coarse-grained 4 KiB pages, but can also precisely reconstruct intra-page control flow at a maximal, instruction-level granularity. We demonstrated the practicality and improved resolution of COPYCAT by discovering highly dangerous single-trace key extraction attacks in several real-world, side-channel hardened cryptographic libraries. In contrast to known microarchitectural leakage sources, the more fundamental threat of deterministic controlled-channel leakage cannot be dealt with by merely flushing or partitioning microarchitectural state and instead requires research into more principled solutions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Compute d = e −1 mod λ(N). (N, e) are public and (p, q, λ(N), d) are private. RSA imple- mentations commonly use the Chinese remainder theorem (CRT) to reduce computation time, and generate additional private values d P = d mod (p − 1), d Q = d mod (q − 1), and q inv = q −1 mod p. A signature is the value s = h d mod N where h is a hashed and padded message. Signature verifi- cation checks if h ≡ s e mod N. To prevent side-channel at- tacks on signature generation, most implementations blind the input h with a random r before computing the modular exponentiation: s b = (hr e ) d mod N = h d r mod N. Later, the unblinded signature can be computed as s = s b r −1 mod N.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Balanced if/else statement (top), compiled to assembly (left). Precise page-aligned, intra-cache line conditional control flow can be deterministically reconstructed with instruction-granular COPYCAT page access traces (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Conditional data assignments in a page-aligned switch statement (left) deterministically leak through their relative positions in the precise, instruction-granular page access traces extracted by COPYCAT (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Compiler mitigation [32] for branch prediction side channels. COPYCAT reveals control flow via the number of instructions executed on the trampoline page (red, dashed).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Binary Layout of Modular Inversion.</head><label></label><figDesc>After compilation, the subroutines fp_iseven and fp_isodd are simply in- lined within the same page as their caller fp_invmod_slow. However, the arithmetic functions A=fp_add, C=fp_cmp, D=fp_div_2, and S=fp_sub are external calls and reside in a new page. Analyzing these arithmetic functions (A, C, D, 4 fp_invmod_slow and fp_invmod can be found at line 885 and 1015 of https://github.com/wolfSSL/wolfssl/blob/48c4b2fedc/ wolfcrypt/src/tfm.c, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Control flow of the BEEA as implemented by fp_invmod_slow. Each circle (D=div, C=cmp, S=sub, A=add) represents a call to a function in the page that holds these arithmetic functions. We count the exact number of instructions between two consecutive invocations that hit this page. The instruction counts reveal branch outcomes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: An example cut of a trace that is recovered from fp_invmod_slow. First, the weights are replaced according to Rules 1, 2, and 3. Then other transitions (Rules 4 and 5) are used to recover the whole control flow sequence.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Control flow of BEEA in fp_invmod.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>φ</head><label></label><figDesc>= (p s − 1)(q s − 1) 10: for i = 1, . . . , 2 do 11: if p s q s &gt; N or mod(φ, 2 i ) = 0 then 12: continue 13: λ = φ/2 i 14: newsteps = test_t_lamda(t, λ, e) 15: if newsteps &gt;= b + 1 then: 16: hpush(h, (−newsteps, b + 1, p s , q s )) return fail</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>1</head><label></label><figDesc>int wc_ecc_mulmod_ex(mp_int * k, ecc_point * G, ecc_point * R, mp_int * a, mp_int * modulus, int map, void * heap) { ... 2 for (;;) { 3 if (−−bitcnt == 0) { / * grab next digit as required * / 4 if (digidx == −1) { 5 break; 6 } 7 buf = get_digit(k, digidx); 8 bitcnt = (int)DIGIT_BIT; 9 −−digidx; 10 } 11 i = (buf &gt;&gt; (DIGIT_BIT − 1)) &amp; 1; / * grab the next msb from the multiplicand * / 12 buf &lt;&lt;= 1; 13 if (mode == 0) { 14 mode = i; / * timing resistant − dummy operations * / 15 err = ecc_projective_add_point(M[1], M[2], M[2], a, modulus, mp);...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>16 err = ecc_projective_dbl_point(M[2], M[3], a, modulus, mp);... 17 }... 18 err = ecc_projective_add_point(M[0], M[1], M[i^1], a, modulus, mp);... 19 err = ecc_projective_dbl_point(M[2], M[2], a, modulus, mp);... 20 } / * end for * /...}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>elgamal}.c::sign,_gcry_ecc_ecdsa_sign (q −1 mod p) → generate_{std,fips,x931} L ib g c ry p t Modular Inverse (mpi_invm) Modified BEEA [43, Vol II, §4.5.2]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>vulnerable to attacks against Algorithm 4 and a single-trace at- tack during the computation of k −1 mod n. Using a randomly chosen blinding variable b, Libgcrypt computes the blinded signature as s b = k −1 (hb + bdr) mod n. To compute the un- blinded signature, it computes s = s b b −1 mod n. The first vul- nerability is that k −1 mod n is not blinded, so a single-trace attack on this operation simply recovers the nonce k. This blinding should be modified to s b = (kb) −1 (h + xr) mod n, and this can be unblinded by computing s = s b b mod n. 1 mpi_mulm (dr, b, skey−&gt;d, skey−&gt;E.n); 2 mpi_mulm (dr, dr, r, skey−&gt;E.n); / * dr = d * r mod n (blinded) * / 3 mpi_mulm (sum, b, hash, skey−&gt;E.n); 4 mpi_addm (sum, sum, dr, skey−&gt;E.n); / * sum = hash + (d * r) mod n (blinded) * / 5 mpi_mulm (sum, bi, sum, skey−&gt;E.n); / * undo blinding by b^−1 * / 6 mpi_invm (k_1, k, skey−&gt;E.n); / * k_1 = k^(−1) mod n * / 7 mpi_mulm (s, k_1, sum, skey−&gt;E.n); / * s = k^(−1) * (hash+(d * r)) mod n * / Listing 2: The masking protection for ECDSA leaves the k −1 mod n operation vulnerable to our single-trace attack.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>1</head><label></label><figDesc>do { _gcry_mpi_randomize (b, qbits, GCRY_WEAK_RANDOM); 2 mpi_mod (b, b, skey−&gt;E.n); 3 } while (!mpi_invm (bi, b, skey−&gt;E.n)); Listing 3: _gcry_ecc_ecdsa_sign computes the modular inverse of the blinding factor b using a vulnerable function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>:</head><label></label><figDesc></figDesc><table>while isEven(u i ) do 

4: 

u i ← u i /2 

5: 

if isOdd(b i ) then 

6: 

b i ← b i − u, a i ← a i + v 

7: 

b i ← b i /2, a i ← a i /2 

8: 

while isEven(v i ) do 

9: 

v i ← v i /2 

10: 

if isOdd(d i ) then 

11: 

d i ← d i − u, c i ← c i + v 

12: 

d i ← d i /2, c i ← c i /2 

13: 

if u i &gt; v i then 

14: 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 2 : Minimum number of signature samples for each bias class to reach 100% recovery success for the lattice-based key recovery on wc_ecc_mulmod_ex of ECDSA, with lattice reduction time L-TIME and trace collection time T-TIME.</head><label>2</label><figDesc></figDesc><table>LZBS DIM L-TIME SIGNATURES IRQS T-TIME 

4 
75 
30 sec 
1,200 
3.9M 13.3 sec 
5 
58 
5 sec 
1,856 
6.0M 20.4 sec 
6 
46 
3 sec 
2,944 
9.6M 33.7 sec 
7 
42 
2 sec 
5,376 
17.5M 
1 min 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 3 : An overview of applicability of COPYCAT on cryptographic libraries: WolfSSL, Libgcrypt, OpenSSL, IPP Crypto.</head><label>3</label><figDesc></figDesc><table>Operation (Subroutine) 
Implementation 
Secret 
Branch 
Exploitable Computation → Vulnerable Callers 
Single-Trace 
Attack 

Scalar Multiply (wc_ecc_mulmod_ex) 
Montgomery Ladder w/ Branches 




</table></figure>

			<note place="foot" n="1"> Transient-execution attacks [57, 67, 68] are orthogonal to metadata leakage through side channels and require recovery of the trusted computing base through complementary microcode and compiler mitigations.</note>

			<note place="foot" n="3"> Branch shadowing mitigation: https://github.com/SSGAalto/ sgx-branch-shadowing-mitigation</note>

			<note place="foot" n="5"> A basic block is a code sequence that has no branches in and out. 476 29th USENIX Security Symposium USENIX Association</note>

			<note place="foot" n="6"> Rule 4 and 5 remain the same.</note>

			<note place="foot" n="7"> wc_MakeRsaKey at https://github.com/wolfSSL/wolfssl/blob/ 48c4b2fedc/wolfcrypt/src/rsa.c#L3726 invokes BEEA multiple times during RSA Key generation.</note>

			<note place="foot" n="486"> 29th USENIX Security Symposium USENIX Association</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank our reviewers for their suggestions that helped improving the paper. This work is partially funded by the Research Fund KU Leuven, a generous gift from Intel, and by the US National Science Foundation under grants no. <ref type="bibr">1513671, 1651344, 1814406, and 1913210</ref>. Jo Van Bulck is supported by a grant of the Research Foundation -Flanders (FWO).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Appendix</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 OpenSSL GCD Algorithm</head><p>Algorithm 5 shows the binary GCD algorithm in OpenSSL.</p><p>Algorithm 5 OpenSSL Binary GCD Algorithm. a ← a − b, a ← a/2</p><p>8:</p><p>else a is odd, b is even 10:</p><p>12:</p><p>else a is even, b is even 17:</p><p>return a</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Branch Shadow-Resistant Code Attack</head><p>Listing 5 provides an elementary example function with secret-dependent branches. We provide the corresponding assembly output in Listing 6, as produced by the LLVMbased, open-source compiler mitigation pass <ref type="bibr" target="#b31">[32]</ref> against branch shadowing attacks, described in Section 3.3. We passed the -mllvm -x86-branch-conversion and -mllvm -x86-bc-dummy-instr options to enable both rewriting of conditional branches via the trampoline area and protection against timing attacks via dummy instruction balancing. Note that the randomizer is not integrated in the open-source release, and all code blocks on the trampoline area would still have to be randomly re-shuffled at runtime to protect against branch-shadowing attacks. To achieve sufficient entropy, trampoline areas have to be larger than 4 KiB <ref type="bibr" target="#b31">[32]</ref>, and hence the trampoline will occupy at least one separate page. We reveal control flow in the instrumented code of Listing 6 using COPYCAT as follows. In the case where the secret-dependent if condition is true, the indirect branch at line 20 will execute the single-instruction jmp_if block on the trampoline page, followed by 4 instructions on the instrumented code page, totaling 5 instructions before reaching the end_if marker. In contrast, if the if condition is false, the indirect branch at line 20 will transfer to the skip_if block on  We experimentally verified that COPYCAT adversaries can deterministically learn the if condition by merely counting instructions and observing page accesses. Moreover, because the dummy instructions do not result in exactly balanced instruction counts, as explained above, merely counting the total amount of executed instructions even suffices in itself without having to distinguish accesses to the trampoline page.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On the Power of Simple Branch Prediction Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Onur</forename><surname>Aciiçmez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Çetin</forename><surname>Kaya Koç</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Pierre</forename><surname>Seifert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">When one vulnerable primitive turns viral: Novel single-trace attacks on ECDSA and RSA. IACR TCHES</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alejandro</forename><surname>Cabrera Aldaya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Billy</forename><forename type="middle">Bob</forename><surname>Brumley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Sohaib ul Hassan, Cesar Pereida García, and Nicola Tuveri. Port Contention for Fun and Profit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alejandro</forename><surname>Cabrera</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aldaya</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Security and Privacy (S&amp;P)</title>
		<meeting><address><addrLine>Billy Bob Brumley</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alejandro</forename><surname>Cabrera Aldaya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cesar</forename><forename type="middle">Pereida</forename><surname>García</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luis Manuel Alvarez</forename><surname>Tapia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Billy</forename><forename type="middle">Bob</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cache-Timing Attacks on RSA Key Generation. IACR TCHES</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">SPA vulnerabilities of the binary extended Euclidean algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alejandro</forename><surname>Cabrera Aldaya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alejandro J Cabrera</forename><surname>Sarmiento</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Santiago</forename><surname>Sánchez-Solano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptographic Engineering</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">François Dupressoir, and Michael Emmi. Verifying Constant-Time Implementations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jose</forename><surname>Bacelar Almeida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Barbosa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gilles</forename><surname>Barthe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">On Subnormal Floating Point and Abnormal Timing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Andrysco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kohlbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keaton</forename><surname>Mowery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ranjit</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sorin</forename><surname>Lerner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Security and Privacy (S&amp;P)</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Just a Little Bit&quot; : A Small Amount of Side Channel Can Go a Long Way</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Naomi</forename><surname>Benger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joop</forename><surname>Van De Pol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nigel</forename><forename type="middle">P</forename><surname>Smart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHES</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>Ooh Aah</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Sliding right into disaster: Left-to-right sliding windows leak</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joachim</forename><surname>Daniel J Bernstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Breitner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leon</forename><forename type="middle">Groot</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadia</forename><surname>Bruinderink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tanja</forename><surname>Heninger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christine</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Van Vredendaal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Yarom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHES</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Fast constant-time gcd computation and modular inversion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bo-Yin</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR TCHES</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Verifying ConstantTime Implementations by Abstract Interpretation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sandrine</forename><surname>Blazy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Pichardie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alix</forename><surname>Trieu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Vale: Verifying High-Performance Cryptographic Assembly Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barry</forename><surname>Bond</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Hawblitzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manos</forename><surname>Kapritsos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><forename type="middle">R</forename><surname>Lorch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bryan</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashay</forename><surname>Rane</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinath</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laure</forename><surname>Thompson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Hardness of Computing the Most Significant Bits of Secret Keys in Diffie-Hellman and Related Schemes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ramarathnam</forename><surname>Venkatesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">SGX: Automated and Adjustable Side-Channel Protection for SGX using Data Location Randomization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ferdinand</forename><surname>Brasser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srdjan</forename><surname>Capkun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandra</forename><surname>Dmitrienko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tommaso</forename><surname>Frassetto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kari</forename><surname>Kostiainen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACSAC</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Software Grand Exposure: SGX Cache Attacks Are Practical</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ferdinand</forename><surname>Brasser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Urs</forename><surname>Müller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandra</forename><surname>Dmitrienko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kari</forename><surname>Kostiainen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srdjan</forename><surname>Capkun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX WOOT</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Remote Timing Attacks are Still Practical</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Billy</forename><forename type="middle">Bob</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicola</forename><surname>Tuveri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Symposium on Research in Computer Security</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Provably Secure Isolation for interruptible Enclaved Execution on Small Microprocessors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matteo</forename><surname>Busi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Job</forename><surname>Noorman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Letterio</forename><surname>Galletta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierpaolo</forename><surname>Degano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE CSF</title>
		<meeting><address><addrLine>Tobias Mühlberg, and Frank Piessens</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2020-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Side-channel analysis of the modular inversion step in the RSA key generation algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alejandro</forename><surname>Cabrera Aldaya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alejandro J Cabrera</forename><surname>Raudel Cuiman Márquez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Santiago</forename><surname>Sarmiento</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sánchez-Solano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Circuit Theory and Applications</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">SgxPectre: Stealing Intel Secrets from SGX Enclaves Via Speculative Execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">H</forename><surname>Lai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE European Security and Privacy (Euro S&amp;P)</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Racing in Hyperspace: Closing Hyper-Threading Side Channels on SGX with Contrived Data Races</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoxing</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenhao</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tianyu</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanchuan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yinqian</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaofeng</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Security and Privacy (S&amp;P)</title>
		<editor>Ten-Hwang Lai, and Dongdai Lin</editor>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Detecting Privileged Side-Channel Attacks in Shielded Execution with DéJà Vu</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanchuan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaokuan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yinqian</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Asia CCS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">CacheQuote: Efficiently Recovering Long-term Secrets of SGX EPID via Cache Attacks. IACR TCHES</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fergus</forename><surname>Dall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabrielle</forename><forename type="middle">De</forename><surname>Micheli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadia</forename><surname>Heninger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad</forename><surname>Moghimi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">HybCache: Hybrid Side-Channel-Resilient Caches for Trusted Execution Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ghada</forename><surname>Dessouky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tommaso</forename><surname>Frassetto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">BranchScope: A New Side-Channel Attack on Directional Branch Predictor</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dmitry</forename><surname>Evtyushkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Riley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cse</forename><surname>Nael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ece</forename><surname>Abu-Ghazaleh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dmitry</forename><surname>Ponomarev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Self-Defending Key Management Service with Intel R Software Guard Extensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fortanix</surname></persName>
		</author>
		<ptr target="https://bit.ly/2yWxuuD" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Federal Information Processing Standards Publications, volume FIPS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Gallagher</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="186" to="189" />
		</imprint>
	</monogr>
	<note>Digital Signature Standard (DSS)</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Constant-Time Callees with Variable-Time Callers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cesar</forename><forename type="middle">Pereida</forename><surname>García</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Billy</forename><forename type="middle">Bob</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A survey of microarchitectural timing attacks and countermeasures on contemporary hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qian</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Cock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gernot</forename><surname>Heiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptographic Engineering</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Off-Limits: Abusing Legacy x86 Memory Segmentation to Spy on Enclaved Execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jago</forename><surname>Gyselinck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raoul</forename><surname>Strackx</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Engineering Secure Software and Systems</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">High-Resolution Side Channels for Untrusted Operating Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Hähnel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weidong</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Peinado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Reconstructing RSA Private Keys from Random Key Bits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadia</forename><surname>Heninger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual International Cryptology Conference</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Mitigating Branch-Shadowing Attacks on Intel SGX using Control Flow Randomization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shohreh</forename><surname>Hosseinzadeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hans</forename><surname>Liljestrand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ville</forename><surname>Leppänen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Paverd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd Workshop on System Software for Trusted Execution</title>
		<meeting>the 3rd Workshop on System Software for Trusted Execution</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nigel</forename><forename type="middle">P</forename><surname>Nick A Howgrave-Graham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Smart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lattice Attacks on Digital Signature Schemes. Designs, Codes and Cryptography</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Bluethunder: A 2-level Directional Predictor Based Side-Channel Attack against SGX. IACR TCHES</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tianlin</forename><surname>Huo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaoni</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenhao</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chunliang</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pei</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jian</forename><surname>Zhai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mingshu</forename><surname>Li</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title/>
		<ptr target="https://github.com/intel/ipp-crypto" />
	</analytic>
	<monogr>
		<title level="j">Intel. Intel IPP Crypto Library</title>
		<imprint/>
	</monogr>
	<note>commit ad2ad95</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Intel Lehmer&apos;c GCD Implementation sources/ippcp/pcpbnarithgcd</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<ptr target="https://github.com/intel/ipp-crypto/blob/b6848dc/sources/ippcp/pcpbnarithgcd.c#L54" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sgx</forename><surname>Intel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ssl</surname></persName>
		</author>
		<ptr target="https://github.com/intel/intel-sgx-ssl" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Intel R 64 and IA-32 Architectures Optimization Reference Manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<ptr target="https://intel.ly/2UbLwk2" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Intel Software Guard Extensions Developer Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<ptr target="https://intel.ly/3dr6PFV" />
		<imprint>
			<date type="published" when="2017-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Intel R 64 and IA-32 Architectures Software Developer&apos;s Manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<ptr target="https://intel.ly/2UeQjBm" />
		<imprint>
			<date type="published" when="2019-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Guidelines for Mitigating Timing Side Channels Against Cryptographic Implementations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<ptr target="https://intel.ly/2WDDS3y" />
		<imprint>
			<biblScope unit="page">2020</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">SGX-LEGO: Finegrained SGX controlled-channel attack and its countermeasure. computers &amp; security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deokjin</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daehee</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minjoon</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yunjong</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonghwan</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seokjin</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brent Byunghoon</forename><surname>Kang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="volume">82</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Donald E Knuth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Seminumerical Algorithms</title>
		<imprint>
			<publisher>Addison-Wesley Professional</publisher>
			<date type="published" when="2014" />
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Inferring Fine-grained Control Flow Inside SGX Enclaves with Branch Shadowing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sangho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming-Wei</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prasun</forename><surname>Gera</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hyesoon</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Peinado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">CATalyst: Defeating Last-Level Cache Side Channel Attacks in Cloud Computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fangfei</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qian</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Mckeen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Rozas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gernot</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruby B</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">MemJam: A False Dependency Attack Against Constant-Time Crypto Implementations in SGX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad</forename><surname>Moghimi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Sunar</surname></persName>
		</author>
		<editor>CT-RSA</editor>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">CacheZoom: How SGX Amplifies the Power of Cache Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad</forename><surname>Moghimi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gorka</forename><surname>Irazoqui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHES</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">TPM-FAIL: TPM meets Timing and Lattice Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Moghimi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Sunar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadia</forename><surname>Heninger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Phong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Igor</forename><forename type="middle">E</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shparlinski</surname></persName>
		</author>
		<title level="m">The Insecurity of the Elliptic Curve Digital Signature Algorithm with Partially Known Nonces. Designs, codes and cryptography</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Autarky: Closing Controlled Channels with Self-Paging Enclaves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meni</forename><surname>Orenbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Baumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Silberstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroSys</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Make Sure DSA Signing Exponentiations Really Are Constant-Time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cesar</forename><forename type="middle">Pereida</forename><surname>García</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Billy</forename><forename type="middle">Bob</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Fast and Regular Algorithms for Scalar Multiplication over Elliptic Curves. IACR Cryptology ePrint Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthieu</forename><surname>Rivain</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">A Method for Obtaining Digital Signatures and Public-Key Cryptosystems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adi</forename><surname>Ronald L Rivest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leonard</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Adleman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Communications of the ACM</title>
		<imprint>
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Hardware-Backed Heist: Extracting ECDSA Keys from Qualcomm&apos;s TrustZone</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keegan</forename><surname>Ryan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keegan</forename><surname>Ryan</surname></persName>
		</author>
		<title level="m">Return of the Hidden Number Problem. IACR TCHES</title>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="page" from="146" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">ZeroTrace: Oblivious Memory Primitives from Intel SGX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sajin</forename><surname>Sasy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergey</forename><surname>Gorbunov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher W</forename><surname>Fletcher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">ZombieLoad: CrossPrivilege-Boundary Data Sampling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Moghimi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julian</forename><surname>Stecklina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Prescher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Malware Guard Extension: Using SGX to Conceal Cache Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><surname>Weiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clémentine</forename><surname>Maurice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DIMVA</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">An elementary proof of the prime-number theorem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Atle</forename><surname>Selberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics</title>
		<imprint>
			<date type="published" when="1949" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">T-SGX: Eradicating Controlled-Channel Attacks Against Enclave Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming-Wei</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sangho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Peinado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Preventing Page Faults from Telling Your Secrets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shweta</forename><surname>Shinde</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zheng</forename><surname>Leong Chua</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Viswesh</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prateek</forename><surname>Saxena</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Asia CCS</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Signal</surname></persName>
		</author>
		<ptr target="https://bit.ly/2MmP8uy" />
	</analytic>
	<monogr>
		<title level="j">Private Contact Discovery Service</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">An analysis of Lehmer&apos;s Euclidean GCD algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Sorenson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1995 international symposium on Symbolic and algebraic computation</title>
		<meeting>the 1995 international symposium on Symbolic and algebraic computation</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="254" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Path ORAM: An Extremely Simple Oblivious RAM Protocol</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emil</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marten</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ling</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiangyao</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinivas</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raoul</forename><surname>Strackx</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1712.08519</idno>
		<title level="m">The Heisenberg Defense: Proactively Defending SGX Enclaves against Page-Table-Based SideChannel Attacks</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">SMT-COP: Defeating SideChannel Attacks on Execution Units in SMT Processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Townley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dmitry</forename><surname>Ponomarev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM International Conference on Parallel Architectures and Compilation Techniques</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Foreshadow: Extracting the Keys to the Intel SGX Kingdom with Transient Out-of-Order Execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marina</forename><surname>Minkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ofir</forename><surname>Weisse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Baris</forename><surname>Kasikci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Thomas F Wenisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raoul</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Strackx</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">LVI: Hijacking Transient Execution through Microarchitectural Load Value Injection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Moghimi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marina</forename><surname>Minkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yarom</forename><surname>Yuval</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Sunar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Security and Privacy (S&amp;P)</title>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">A Tale of Two Worlds: Assessing the Vulnerability of Enclave Shielding Runtimes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Oswald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eduard</forename><surname>Marin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abdulla</forename><surname>Aldoseri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Flavio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Piessens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">SGX-Step: A Practical Attack Framework for Precise Enclave Execution Control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raoul</forename><surname>Strackx</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd Workshop on System Software for Trusted Execution</title>
		<meeting>the 2nd Workshop on System Software for Trusted Execution</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Nemesis: Studying Microarchitectural Timing Leaks in Rudimentary CPU Interrupt Logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raoul</forename><surname>Strackx</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Telling Your Secrets without Page Faults: Stealthy Page Table-Based Attacks on Enclaved Execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nico</forename><surname>Weichbrodt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rüdiger</forename><surname>Kapitza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raoul</forename><surname>Strackx</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">CacheD: Identifying Cache-Based Timing Channels in Production Software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shuai</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiao</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danfeng</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dinghao</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Leaky Cauldron on the Dark Land: Understanding Memory Side-Channel Hazards in SGX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenhao</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoxing</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaorui</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yinqian</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaofeng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vincent</forename><surname>Bindschaedler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haixu</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carl A</forename><surname>Gunter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Single trace attack against RSA key generation in Intel SGX SSL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><surname>Weiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raphael</forename><surname>Spreitzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lukas</forename><surname>Bodner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Asia CCS</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">MicroWalk: A Framework for Finding Side Channels in Binaries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Wichelmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad</forename><surname>Moghimi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Sunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACSAC</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<monogr>
		<title level="m" type="main">Macro-Operation Fusion (MOP Fusion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wikichip</surname></persName>
		</author>
		<ptr target="https://en.wikichip.org/wiki/macro-operation_fusion" />
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<title level="m" type="main">WolfSSL Intel SGX + FIPS 140-2!</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wolfssl</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">vCAT: Dynamic Cache Management using CAT Virtualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meng</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linh</forename><surname>Thi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xuan</forename><surname>Phan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hyon-Young</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Insup</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Real-Time and Embedded Technology and Applications Symposium (RTAS</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">ControlledChannel Attacks: Deterministic Side Channels for Untrusted Operating Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanzhong</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weidong</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Peinado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Security and Privacy (S&amp;P)</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<monogr>
		<title level="m" type="main">Recovering OpenSSL ECDSA Nonces Using the FLUSH+RELOAD Cache Side-channel Attack. IACR Cryptology ePrint Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Naomi</forename><surname>Benger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">FLUSH+RELOAD: A High Resolution, Low Noise, L3 Cache Side-Channel Attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katrina</forename><surname>Falkner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">CacheBleed: A Timing Attack on OpenSSL Constant-time RSA</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadia</forename><surname>Heninger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptographic Engineering</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Cross-VM Side Channels and Their Use to Extract Private Keys</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yinqian</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ari</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ristenpart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
