<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:06+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Context-based Online Configuration-Error Detection</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ding</forename><surname>Yuan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>San Diego</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yinglian</forename><surname>Xie</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Microsoft Research Silicon Valley</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rina</forename><surname>Panigrahy</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Microsoft Research Silicon Valley</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junfeng</forename><surname>Yang</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Columbia University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chad</forename><surname>Verbowski</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">Microsoft Corporation</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arunvijay</forename><surname>Kumar</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">Microsoft Corporation</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Context-based Online Configuration-Error Detection</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Software failures due to configuration errors are commonplace as computer systems continue to grow larger and more complex. Troubleshooting these configuration errors is a major administration cost, especially in server clusters where problems often go undetected without user interference. This paper presents CODE-a tool that automatically detects software configuration errors. Our approach is based on identifying invariant configuration access rules that predict what access events follow what contexts. It requires no source code, application-specific semantics, or heavyweight program analysis. Using these rules, CODE can sift through a voluminous number of events and detect deviant program executions. This is in contrast to previous approaches that focus on only diagnosis. In our experiments, CODE successfully detected a real configuration error in one of our deployment machines , in addition to 20 user-reported errors that we reproduced in our test environment. When analyzing month-long event logs from both user desktops and production servers, CODE yielded a low false positive rate. The efficiency of CODE makes it feasible to be deployed as a practical management tool with low overhead.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Software configuration errors impose a major cost on system administration. Configuration errors may result in security vulnerabilities, application crashes, severe disruptions in software functionality, unexpected changes in the UI, and incorrect program executions <ref type="bibr" target="#b5">[7]</ref>. While several approaches have attempted to automate configuration error diagnosis <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b17">20,</ref><ref type="bibr" target="#b22">26,</ref><ref type="bibr" target="#b25">29]</ref>, they rely solely on manual efforts to detect the error symptoms <ref type="bibr" target="#b17">[20,</ref><ref type="bibr" target="#b22">26,</ref><ref type="bibr" target="#b25">29]</ref>. As usual, manual approaches incur high overhead (e.g., requiring users to write errordetection scripts for each application) and are unreliable (e.g., security policy errors may show no user-visible symptoms). These drawbacks often lead to long delays between the occurrence and the detection of errors, causing unrecoverable damage to system states.</p><p>In this paper, we aim to automatically detect configuration errors that are triggered by changes in config-uration data. These types of errors are commonplace and can be introduced in many ways, such as operator mistakes, software updates or even software bugs that corrupt configuration data. For example, a software update may turn off the "AutoComplete" option for a Web browser, which, as a result, can no longer remember usernames or passwords. An accidental menu click by a user may corrupt a configuration entry and cause an application toolbar to disappear. A seemingly benign user operation that disables the ActiveX control can unexpectedly disable the remote desktop application.</p><p>We consider configuration data because it captures important OS and application settings. Further, the data is typically accessed through well defined interfaces such as Windows Registries. We can thus treat the applications and the OS as black boxes, transparently intercepting and checking configuration accessing events (called events hereafter). This approach is lightweight: it does not require modifying the OS <ref type="bibr" target="#b10">[13]</ref> or using virtual machines <ref type="bibr" target="#b25">[29]</ref>.</p><p>We focus on Windows, where applications use the Registry to store and access configuration data. In particular, we log all Registry events and analyze them online to automatically detect errors. While Windows has the largest OS market share 1 and is also the focus of many previous efforts <ref type="bibr" target="#b22">[26]</ref>, our methodologies can be generalized to other types of OS and configuration data.</p><p>Analyzing configuration-access events automatically for error detection faces three practical challenges. First, we need to efficiently process a huge number of events. A typical Windows machine has on average 200 thousand Registry entries <ref type="bibr" target="#b22">[26]</ref>, with 10 6 to 10 8 access events per day <ref type="bibr" target="#b19">[23]</ref>. Commonly used learning techniques (e.g., <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b24">28]</ref>) rarely scale to this level.</p><p>Second, we must automatically handle a large set of diverse applications. Different applications may have drastically different configuration access patterns. These patterns may evolve with user behavior changes or software updates.</p><p>Finally, our analysis must effectively detect errors without generating a large number of false positives. Configuration data is highly dynamic: there are, on average, 10 4 writes to Registry per day per machine, and 10 2 of them are writes to frequently accessed Registries that have never changed before. Application runtime behaviors such as user inputs, caching, and performance optimizations may all add noise and unpredictability to configuration states, making it difficult to distinguish between real errors and normal updates.</p><p>In this paper we present CODE, an automatic online configuration-error detection tool for system administrators. CODE is based on the observation that the seemingly unrelated events are actually dependent. The events externalize the control flow of a program and typically occur in predictable orders. Therefore, a sequence of events provides the context of a program's runtime behavior and often implies what follows. Further, the more frequently a group of events appear together, the more correlated they should be.</p><p>Thus, rather than analyzing each event in isolation, CODE extracts repetitive, predictable event sequences, and constructs invariant configuration access rules in the form of context → event that a program should follow. CODE then enforces these rules and reports out-ofcontext events as errors. By tracking sequences, CODE also enables richer error diagnosis than looking at each individual event. Once CODE detects an error, it also suggests a possible fix based on the context, the expected event, and the error event.</p><p>We implemented CODE as a stand-alone tool that runs continuously on a single desktop for error detection. It can also be extended to support centralized configuration management in data center environments. Our evaluation, using both real user desktops and production servers, shows that the context-based approach has four desirable features:</p><p>• Application independent: CODE requires no source code, application semantics, or heavyweight program analysis to generate contexts; it can automatically construct rules to represent more than 80% of events for most processes we studied.</p><p>• Effective: CODE successfully detected all reproduced real-world configuration errors and 96.6% of randomly injected errors in our experiments. CODE also detected a real configuration error on a coauthor's desktop.</p><p>• Configurable false positive rate: Since CODE reports only out-of-context events instead of new events, it will not report normal configuration changes as alarms. Further, the false positive rate is configurable.</p><p>In our experiments it reports an average of 0.26 warning per desktop per day and 0.06 per server per day.</p><p>• Low overhead: CODE keeps only a small number of rules for detection and processes events as they arrive online. The CPU overhead is small (less than 1% over 99% of the time). The memory overhead is less than 0.5% for data-center servers with 16GB memory.</p><p>We explicitly designed CODE to detect configuration errors; our goal is not to catch all errors or malicious attacks. We view our focus on frequent event sequences as a good tradeoff. The high access frequencies indicate that errors in these events are more critical. Moreover, our detection takes place at the time when erroneous configurations are accessed and manifest. Hence, these errors are the ones that actually affected normal program executions, and CODE naturally concentrates on them.</p><p>This paper is organized as follows. We first discuss related work in Section 2 and introduce Windows Registry and a motivation example in Section 3. We then present an overview of CODE in Section 4. We next describe its rule learning (Section 5) and error detection (Section 6). We show our evaluation results in Section 7. Finally, we discuss our limitations and future work (Section 8) before we conclude (Section 9).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>To our best knowledge, CODE is the first automatic system for online configuration error detection. Below we discuss related work on configuration-error diagnosis and sequence-analysis based intrusion detection. Configuration error diagnosis. Several diagnosis tools have been developed to assist administrators in diagnosing software failures. ConfAid <ref type="bibr" target="#b1">[2]</ref> uses information-flow tracking to analyze the dependencies between the error symptoms and the configuration entries to identify root causes. Autobash <ref type="bibr" target="#b17">[20]</ref> leverages OS-level speculative execution to causally track activities across different processes. Chronus <ref type="bibr" target="#b25">[29]</ref> uses virtual machine checkpoints to maintain a history of the entire system states. KarDo <ref type="bibr" target="#b11">[14]</ref> automatically applies the existing fix to a repeated configuration error by searching for a solution in a database. SherLog <ref type="bibr" target="#b28">[33]</ref> uses static analysis to infer the execution path based on the runtime log messages to diagnose failures.</p><p>Another family of tools compares the configuration data in a problematic system with those in other systems to pinpoint the root cause of a failure <ref type="bibr" target="#b9">[12,</ref><ref type="bibr" target="#b22">26,</ref><ref type="bibr" target="#b23">27]</ref>. They focus on the snapshots of configuration states, and use statistical tools to compare either historical snapshots or snapshots across machines. While it may seem feasible to extend these state-based approaches for error detection, our experiments showed that such approaches will generate a large number of false positives due to the noise in configuration states (e.g., constant state modifications or legitimate updates). In contrast, CODE reasons about actions rather than states for error detection.</p><p>The existing systems discussed so far have enhanced off-line diagnosis of configuration errors. However, they all require users or administrators to detect configuration errors. In contrast, CODE focuses on automatic error detection (it can further aid error diagnosis). The importance of having an automatic detection system is also recognized in <ref type="bibr" target="#b16">[19]</ref>. Due to the complex dependencies of modern computer systems, detecting faulty configuration states as early as possible helps to isolate the damage and localize the root cause of a failure, especially in server clusters or data centers with thousands of userunmonitored machines. Software resilience to configuration errors Candea et al. proposed a tool called ConfErr for measuring a system's resilience to configuration errors <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b8">11]</ref>. ConfErr automatically generates configuration mistakes using human error models rooted in psychology and linguistics. ConfErr and CODE differ in their purposes. ConfErr can help improve software resilience to configuration errors and thus prevent errors from occurring, while CODE can be used to detect and diagnose configuration errors once they occur and is thus complementary. Sequence analysis. A large number of intrusion detection systems (IDS) identify intrusions with abnormal system call sequences (e.g., <ref type="bibr" target="#b4">[6,</ref><ref type="bibr" target="#b7">9,</ref><ref type="bibr" target="#b20">24,</ref><ref type="bibr" target="#b27">32]</ref>). They construct models of legal system call sequences by analyzing either the source code or the normal executions in an off-line learning phase. A deviation from the learned models is flagged as an intrusion.</p><p>By analyzing event sequences to identify predictable patterns, CODE shares similar benefits to run-time system-call analysis. However, our focus on configuration events instead of system calls leads to significantly different design decisions. Configuration access patterns constantly evolve, so off-line analysis used in IDS systems risks overfitting and producing outdated rules. Further, while IDS systems have to prevent sophisticated attacks <ref type="bibr" target="#b21">[25]</ref> using conservative, non-deterministic models, CODE explicitly focuses on the potentially more critical frequent sequences using simple, deterministic rules. More importantly, the heavyweight learning algorithms that IDS systems commonly use make them difficult to scale to the volume of configuration access events, thus these systems are often unable to adapt to dynamic environments online. In contrast, the focus of identifying only invariant rules enables CODE to adopt and adapt much more efficient sequence-analysis methods to operate online.</p><p>Prior work (e.g., <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b12">15]</ref>) has also used event transitions to build program behavior profiles. They mostly focus on depth-2 transitions on code call graphs. In contrast, CODE's event transition rules can consist of all possible lengths of prefixes, thus are more flexible and expressive when representing event sequences as contexts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Background and A Motivating Example</head><p>In this section, we first introduce Windows Registry, the default configuration store for Windows applications. We then present a motivating configuration-error example and show how CODE can automatically detect and diagnose this error using contexts.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Windows Registry</head><p>Windows Registry is a centralized repository for software, hardware, and user settings on Windows machines. This repository makes it easy for different system components to share and track configurations. Windows Registry is organized hierarchically, closely resembling a file system. Each Registry entry is uniquely identified by a Registry key and a Registry value. A Registry key resembles a directory and a Registry value a file name. A key may contain multiple subkeys and values. Given a key/value pair, Windows Registry maps it to Registry data, which resembles the content of a file. Hereafter, we will refer to Registry keys, Registry values, and Registry data as Keys, Values, and Data. <ref type="table">Table 1</ref> shows a Windows Registry entry example. Its Key is a hierarchical path name with root Key HKEY LOCAL MACHINE, which stores settings generic to all users. The Key in the example stores settings about the Perl application. The Value/Data specifies that the Perl executable is located at C:\Perl\bin\perl.exe. Windows Registry supports about 30 operations (e.g., Createkey and OpenKey), each with a return value indicating the success or failure of the operation. <ref type="table">Table 1</ref> shows a successful QueryValue operation (given a Key/Value pair, fetch associated Data).</p><p>Previous studies have shown that a significant fraction of configuration errors are due to Windows Registry corruptions <ref type="bibr" target="#b5">[7]</ref>. Software bugs, user mistakes, or application updates can all trigger unexpected Registry modifications that lead to software errors. In many cases, even a single entry corruption may result in serious application failures ranging from user-interface changes (e.g., a menu or icon missing) to software crashes.</p><p>While Windows Registry facilitates configuration access, it remains challenging to detect and diagnose configuration errors due to the complex and dynamic nature of Windows Registry. The number of Registry entries is huge-about 200K for an average machine, and this number is increasing <ref type="bibr" target="#b22">[26]</ref>. Furthermore, Registry updates are highly frequent. As shown in <ref type="table" target="#tab_1">Table 2</ref>, the number of updates can be as high as tens of thousands per process per day. Despite several recent proposals for automatic mis-configuration diagnosis, configuration-error detection remains an open problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">A Motivating Example</head><p>In this example, we illustrates how CODE can detect and diagnose a real-world configuration error that disables the Windows automatic update feature (i.e., switch the OS to the manual update mode).</p><p>Given that Windows update often runs as a background task, users who normally leave automatic-update on will hardly notice that their computers have stopped checking for updates. Previous tools do not help in this case because they diagnose configuration errors only after users detect them. Consequently, this error may go undetected, leaving security vulnerabilities not patched and machines compromised. Early detection is thus critical to alert users to reset this important safety feature.</p><p>This configuration error was reported when a user removed a program that he or she thought was extraneous <ref type="bibr">[30]</ref>. The program removal adds a Value "NoAutoUpdate" and Data 1 under the Key</p><formula xml:id="formula_0">K = [HKLM\Software\Policies\Microsoft\Windows\ WindowsUpdate\AU]</formula><p>Since an average process can have over 2000 Registry modifications (i.e., writes) per day during its normal execution <ref type="table" target="#tab_1">(Table 2)</ref>, we need to determine which modifications are relevant to detection. One approach is to monitor and report modifications to only frequently accessed Keys. However, our experiments show that this approach would generate 154 false alarms per desktop/day, an unacceptably high number.</p><p>In our detection, CODE identifies that a rule involving a frequent sequence of exactly 45 Registry accesses is violated. By examining this sequence and its occurrence timestamps, we find that these events are issued by an svchost.exe process, which synchronizes with an update server and checks for available updates periodically (once per hour for Windows laptops). If there are updates available, the checking process will proceed to download and install the updates. <ref type="figure" target="#fig_0">Figure 1</ref> shows this 45-event sequence. It begins with an OpenKey operation on registry Key "HKLM\...\WindowsUpdate", which stores all the information about Windows update. Next, svchost.exe accesses this Key and all its Values. For example, the second and third operations show that svchost.exe queries the URLs of the windows update server and the status reporting server.</p><p>At the 28th event, svchost.exe queries the Value "NoAutoUpdate" (highlighted in <ref type="figure" target="#fig_0">Figure 1</ref>). Since this Value does not exist during normal execution, the QueryValue operation will return "Value not found" and svchost.exe continues to check other automatic update options. However, after the Value "NoAutoUpdate" is created with Data 1, the operation returns "Success", causing svchost.exe to prematurely stop without further checks.</p><p>Since the 45-event sequence occurs frequently in normal execution, CODE will learn a set of rules from this sequence. In particular, it will identify the first 27 events as the context for the 28th event. Thus, in the error case, CODE successfully detects the deviation. In addition, CODE knows (1) the context, the expected event and the event actually happened and <ref type="formula">(2)</ref> what process and the time at which the process created the problematic Value. It can thus pinpoint the root cause and recover the error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">System Overview</head><p>From a high level, our approach identifies predictable configuration-access rules from program executions for error detection and diagnosis. From the example described in Section 3, we see that each Windows update check triggers a sequence of 45 Registry accesses. This entire sequence is deterministic and thus predictable. This behavior is not surprising, as configuration-access patterns are usually reflective of a program's control flow. When a program runs the same code blocks with same/similar user inputs, the set of external events tend to be same/similar and in order.</p><p>We focus on only these predictable event sequences in our detection. For each event in such a sequence, its preceding event subsequence provides the context for the current program execution point. A deviation from the predicable event sequence suggests that the corresponding program's control flow might have changed, which may indicate the existence of configuration errors. In this case, the expected sequence and the actually observed one are further used to diagnose the error's root cause. However, not all configuration-access events are predictable. A program's runtime behavior such as caching, optimizations, or the use of temporary files may all affect the program's control flow. Correspondingly, accessing the configuration data will be less predictable. We may observe a large number of temporary events, and even the same set of events may exhibit completely different timing orders. The challenge is how to differentiate the two cases and identify only predictable patterns from a voluminous number of events.</p><p>Given the complexity and dynamics of Windows Registry, CODE must meet the following two requirements to realize online detection and diagnosis:</p><p>• Efficient: The tool should have low timing complexity in order to process events as they arrive in real time. The number of Registry events to process is on the order of 10 6 to 10 8 per machine per day.</p><p>• Effective: As an online tool, CODE needs to distinguish true errors from volatile or benign changes.</p><p>We implement CODE as a stand alone tool, monitoring each host independently (Section 8 discusses our deployment of CODE as a centralized manager for data centers). We structure CODE into two parts: an event collection module and an analysis module <ref type="figure" target="#fig_1">(Figure 2</ref>). Both run simultaneously as a pipeline. The collection module writes Registry operations to disk and the analysis module reads them back for learning, detection, and diagnosis. We chose this architecture to keep the collection module simple; otherwise, it may perturb the monitored processes. We chose files as the communication method between the two modules (instead of sockets) for flexible control over analysis frequency (e.g., every few seconds to minutes).</p><p>The core of the event collection module is a Windows kernel module written in C++, similar to FDR <ref type="bibr" target="#b19">[23]</ref>. It intercepts all Registry operations and stores them in a buffer in highly compressed forms. It then writes them to disk periodically. <ref type="bibr" target="#b1">2</ref> Each event contains the following fields: event time-stamp, program name represented by the entire file system path to the executable, command line arguments, process ID, thread ID, Registry Key, Value, Data, operation type (e.g., OpenKey and QueryValue) and operation status.</p><p>The analysis module is implemented in C#. It includes a learning component and a detection/diagnosis component. Both learning and detection are done by analyzing the event sequences at a per-thread level because they faithfully follow the program's control flow in execution. For compact representation, we fingerprint a Registry event to generate a Rabin hash <ref type="bibr" target="#b15">[18]</ref> by considering all of its fields excluding the time-stamp, the process ID, and the thread ID. The learning component takes the Registry event sequences as input, and generates a set of event transition rules. <ref type="figure" target="#fig_2">Figure 3</ref> shows an example rule. In this example, a, b, and c each represents a unique Registry event. This rule means if we have observed events a, b, and c in sequence, then the next event is determined to be d. In other words, event sequence abc is the context of event d if and only if abc will be always followed by d with no exceptions (We do not consider non-deterministic cases where abc can be followed by other events such as e, as majority of the important errors can be captured by deterministic cases in our experience).</p><p>We further require the number of occurrences of the rule sequence to exceed a certain threshold for it to be deemed as a rule. We use the complete command line that launched a process to group the set of threads sharing the common executable name and input arguments 3 . The frequency of a rule is thus measured over all the event sequences across a process group. Finally, the set of learned rules are updated periodically by epochs and stored in a rule repository as illustrated in <ref type="figure" target="#fig_1">Figure 2</ref>. We define an epoch as a time period where we observe a fixed number of events, so that the rules learned from one epoch can be applied immediately in the next epoch.</p><p>The detection component takes the set of learned rules and applies them to detect errors as new events arrive.</p><p>In case of a rule violation, the detection module performs a set of checks to facilitate diagnosis based on the rule sequence, the expected event, the Registry write that caused the error, and the actually observed event. In the next two sections, we describe the details of rule learning and error detection/diagnosis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Learning Configuration Access Rules</head><p>This section describes how CODE generates event transition rules from input Registry-access sequences. These input sequences consist of registry accesses at thread granularity for each process group (i.e., all processes that share the same executable name and command-line arguments). <ref type="figure" target="#fig_1">Figure 2</ref> shows the three steps of this procedure: (1) generate frequent event sequences, (2) construct a trie (i.e., a prefix tree) to represent the event transition states, and (3) derive invariant event transition rules based on the trie. For efficient detection, CODE represents the set of output rules in the form of a trie with labeled edges, and each process group has a separate trie.</p><p>Throughout the process, CODE has time complexity linear in the number of events processed. Although CODE generates a set of frequent event sequences independently from each epoch, meaning that a sequence has to appear frequently enough within one epoch to be learned by CODE, it maintains the labeled tries in memory across epoches and updates them incrementally. We will show in Section 7.3 that the generated trie sizes are small for most of the programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Frequent Sequence Generation</head><p>The first step of generating frequent sequences is the most critical, since it provides the candidate event sets for generating rules as well as the potential context lengths. To identify frequent event sequences, one option is to generate hash values for fixed-length event subsequences, and then count their frequencies. We may potentially leverage data structures such as bloom filters <ref type="bibr" target="#b2">[3]</ref> to optimize space usage. However, this option is not desirable because it is difficult to pre-determine the event subsequence lengths. Although we may choose several popular lengths (e.g., 2, 4, 8), the semantically meaningful event sequences can be very large (as illustrated in Section 3) and can have varied lengths. Popular techniques such as suffix trees <ref type="bibr" target="#b13">[16]</ref> are not applicable either. They typically require the entire input sequence to be available. Furthermore, their space-time requirements are not efficient enough to deal with a large number of Registry events arriving in real time.</p><p>In order to generate the longest applicable frequent subsequences efficiently, CODE adopts the Sequitur <ref type="bibr" target="#b14">[17]</ref> algorithm. Given a sequence of symbols, Sequitur identifies repeated sequence patterns and generates a set of grammar rules to hierarchically represent the original sequence. <ref type="figure">Figure 4</ref> shows an example input sequence and the hierarchical grammar rules derived by Sequitur. The lower case letters represent the input symbols, and we use upper case letters to denote the derived symbols.</p><p>During learning, the default epoch size is 500K events, which can span from hours to days for different processes. <ref type="bibr" target="#b3">4</ref> For each epoch, CODE does not need to store the complete input sequence because the hierarchical representation makes the original sequence more compact. In practice, the number of symbols to store in memory is roughly on the order of the number of distinct Registry events, which is around only 1% of the total events <ref type="bibr" target="#b19">[23]</ref>.</p><p>Compared with other methods, Sequitur has a linear time complexity and reads only one pass of data in streaming mode. Although it may generate sub-optimal frequent sequences, we found it acceptable in our application, as low time complexity is an important requirement. To apply Sequitur in our context, we make the following two modifications to the algorithm: Analyzing multiple sequences simultaneously. The incoming events processed by CODE contain not a single event sequence, but multiple sequences. These sequences come from different processes and different threads in the same process group. In addition, we observe that events belonging to the same task often occur in a bursty manner. Mixing events from these semantically different tasks as one sequence would create unnecessary noise. We thus segment them into per-thread perburst sequences (the default time interval between two bursts is one second), as shown in <ref type="figure">Figure 5</ref>.</p><p>The original Sequitur algorithm, however, analyzes only one sequence at a time. We thus modify it to take multiple sequences. We could maintain a separate gram-  mar table (needed for Sequitur) for each sequence, but this approach would miss common subsequences shared across different threads in the same group. For example, in <ref type="figure">Figure 5</ref>, both threads share the subsequence abcd. Thus a grammar table is shared among all sequences. This sharing also reduces CODE's memory usage. With grammar table sharing, one complication arises when a sequence S x completely contains another one S y . To avoid storing the same sequence twice, Sequitur would replace the redundant copy of S y in S x with a pointer to S y . However, we cannot expand S y if new events come in, because this expansion may make S y no longer a subsequence of S x . To solve this problem, we give S y a fresh name S ′ y each time we expand it. Flattening the hierarchy: The second modification is to flatten the default hierarchical symbols output by Sequitur to event symbols in order to construct the trie later (illustrated by <ref type="figure">Figure 4</ref>). To ensure each learned sequence is not too short, we select a flattened event sequence only if its length is above a pre-defined length threshold l (by default l = 4) and its sequence is above a pre-defined frequency threshold s (by default s = 5). We call the frequency of an event sequence as its support.</p><p>Although the rule flattening process is relatively straightforward, correctly computing the support (i.e., frequency) of the expanded sequences is a more involved task. In <ref type="figure">Figure 4</ref>, R 1 appears at both R 2 and R 3 , and R 2 further appears at R 3 . CODE takes a top-down approach to traverse the hierarchical representations for computing the correct support. The final output of this step is a set of frequent event sequences with support greater than s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Event Trie Construction</head><p>After CODE generates the frequent sequences from input events, it proceeds to construct an event trie in the form of a prefix tree to store all the frequent sequences from all threads of each process group. <ref type="figure" target="#fig_5">Figure 6</ref> shows the construction of an example trie. In a trie, each node represents a Registry access event (encoded as a Rabin hash), and each directed edge represents the transition between the two corresponding events in temporal order.</p><p>The adoption of a trie representation serves a couple of important purposes. First, it represents the temporal transition relationships between different events, providing the basis for deriving event transition rules. Second, we found that many frequent event sequences have common prefixes. Hence a prefix tree explicitly encodes the divergence of different event paths from a single point.</p><p>We further optimize the trie data structure to make it more compact. An observation is that many event sequences share suffixes as well. In practice, merging common suffixes is very effective in reducing the trie size (by half). Meanwhile, this optimization still preserves the event transition relationship and ensures the correctness of the derived rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Rule Derivation</head><p>With a trie, CODE proceeds to derive event transition rules that all threads from the same process group have to follow. We look at only the rules that were never violated. Our approach is to identify those event transitions a → b that are deterministic given the sequence of events from the root to a. We define such an edge as a rule edge. Clearly, only edges from nodes with only one outgoing edge are rule edge candidates.</p><p>However, simply counting outgoing edges is incomplete. For example, given a frequent sequence abcd, we can construct a trie of 4 nodes, and the edge from c → d appears to be a rule edge. However, there may exist a sequence abce that did not occur frequently enough to be selected as a popular sequence. In this case, the transition c → d is not deterministic.</p><p>For each newly created rule edge, CODE determines whether it is truly a deterministic transition by checking it against the upcoming event sequences in the next epoch. <ref type="figure" target="#fig_5">Figure 6</ref> shows this edge-marking process. Doing so defers the use of this edge for detection. It is worth noting that for each event, CODE identifies all possible matches based on the preceding subsequences. Additionally, CODE also starts from the root every time to capture subsequences that begin with the current event. During the edge-marking process in <ref type="figure" target="#fig_5">Figure 6</ref>, if the incoming event e is following sub-sequence abc, we will un-mark the two c → d transitions from rule edge in the trie.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Error Detection and Diagnosis</head><p>This section describes how CODE detects configuration errors using the learned rules and further outputs diagnosis information. Since the labeled trie structure captures the rules as deterministic event transitions and is efficient at matching sequences, we conveniently reuse this data structure for error detection without explicitly representing the rules. The detection algorithm is thus simple and similar to the edge-marking process in <ref type="figure" target="#fig_5">Figure 6</ref>, except when we see a violation, we report a warning rather than un-marking the transition. This online detection method ensures that we can detect a configuration error as early as possible, before it affects other system states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">False Positive Suppression</head><p>In the rule-learning process, the support threshold s can be used to configure the false positive rate. A larger s usually implies a smaller false positive rate, but we may also miss some real errors. We further evaluate this parameter in Section 7.2.</p><p>Additionally, we use three techniques to reduce CODE's false positive rate. First, before CODE reports a warning, it performs an additional check to ensure that the violated (i.e., expected) event does not appear in the near future. So if abc → e is a rule that is violated by observing abc followed by f , then we monitor the events for a delay buffer (set to 1 sec) to check if e appears; if it does, we suppress the warning. The idea behind this check is that since we are looking for corruptions of Registry Keys/Values, if f is indeed a corruption of the Key/Value corresponding to the Registry in event e, then e should not appear again. Otherwise it is perhaps simply a benign program flow change.</p><p>Second, if multiple alarms are generated in a 1 second delay buffer, CODE only reports the first one as the others are likely manifestations of the same root cause. We found the first alarm is always the true root cause in our experiments (see Section 7.1.1).</p><p>The third technique is cooperative false positive suppression: aggregate warnings from all machines, and report only unique ones. We consider two warnings identical if they warn about the same Key, Value, and Data. We canonicalized user names when comparing Registry Keys (More canonicalization would help, but it is beyond the scope of this paper). This technique effectively reduced the number of false positives by 30% in our experiments, though it can be turned off for privacy concerns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Error Diagnosis</head><p>CODE also provides rich diagnosis information after error detection. When a process violates a rule context → event, CODE knows precisely the context, the expected event, the violating event, and the violating process. Such information can help diagnosis in a few ways.</p><p>First, CODE allows the operator to understand how the Registry in the expected event was changed by tracking which process, at what time, modified the entry that caused the error. To do so, CODE uses a modification cache to store the last modification operations (along with timestamps) on the Registries in the rules. Because the rules track only frequently accessed Registries and the majority of the accesses to these Registries are readonly events, we need only a small cache. In practice, the size of the modification cache is always smaller than 2,000 events for all the machines that we used in our experiments. The typical size of 200 events is enough for the majority of them.</p><p>Second, the expected event and its context often provide enough information regarding the program's anomalous behavior to the administrator. They also provide the candidate Registry entries for recovery. In the "auto-update error" example in Section 3.2, the expected event has empty Data for Value NoAutoUpdate, while the violating event has "1" as the Data. Further the expected event belongs to a sequence where svchost.exe is checking for auto-update setting. Such information provides hints to the administrators about the root causes.</p><p>Finally, CODE returns all the processes whose rule repositories involve the corrupted Registry. Operators can use this information to examine whether the same configuration error might affect other programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Evaluation</head><p>We deployed CODE on 10 actively used user desktops and 8 production servers. In our month-long deployment, we set the data collection interval to every one hour. We ran the analysis module separately off-line on the collected registry-event logs. This allowed us to conveniently examine the logs in detail. For the off-line analysis, it took about 12 hours to process each machine's one-month log. We also evaluated the same version of CODE using one minute intervals to measure its online analysis performance.</p><p>To demonstrate the value of using context, we also implemented a state-based approach that does not use context for error detection and compared it with CODE.</p><p>Instead of looking at sequences, this approach tracks commonly used Registry Key/Value entries and raises an alarm if the Data field has not been observed before. To ensure a fair comparison, we applied the same parameters used by CODE as well as the set of false positive suppression heuristics described in Section 6 whenever applicable. Below we present our evaluation results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Detection Rate and Coverage</head><p>We first evaluate CODE using real-world configuration errors and randomly injected Key corruptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Error name</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Description</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Doubleclick</head><p>When double clicking any folder in explorer, "Search Result" window pops up. Advanced IE advanced options missing from menu. IE Search Search dialog will always be on the left panel of IE that can't be closed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Brandbitmap</head><p>The animated IE logo disappears. Title IE title changed to some arbitrary strings. Explorer Policy Windows start menu becomes blank. Shortcut</p><p>In explorer, clicking the shortcut to a file no longer works. Password IE can no longer remember the user's password. IE Offline IE would launch in offline mode and user's homepage can't be displayed. Outlook trash Outlook asks to permanently delete items in the "Deleted Items" folder every time it exits. <ref type="table">Table 3</ref>: Description of the 10 reproduced errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Detection of Real-Errors</head><p>The real world error discovered by CODE was caused by Hotbar Adware <ref type="bibr">[21]</ref>, which unexpectedly infected one co-author's desktop. This adware adds graphical skins to Internet Explorer (IE), and modifies a group of Registries related to the Key "HKLM\Software\Classes\Mime\Database\Content type\ App". CODE successfully detected rule violations at the IE start-up time. CODE further provided diagnostic information to help remove the IE tool bars created by the adware.</p><p>Additionally, we manually reproduced 20 real-user reported errors to evaluate CODE. These errors were selected from a system-admin support database. The only criteria we used in our selection was whether these errors were triggered by modifications to Windows Registry and were reproducible. <ref type="bibr">5</ref> The error reproduction process exactly followed the set of user actions that triggered the software failures as described in the failure report. The 20 errors involved nine different programs, including popular ones such as Internet Explorer, Windows <ref type="bibr">Ex- plorer, Outlook, Firefox.</ref> CODE successfully detected all these reproduced errors. Due to space constraints, we do not describe all of them, but list the 10 representative ones in <ref type="table">Table 3</ref>. To further evaluate the effectiveness of CODE across different environments, we reproduced these 10 errors in 5 different OS environments (one of them was a virtual machine). Not all of these 10 errors can be reproduced on all 5 machines; out of all combinations, we were able to reproduce 41 cases.</p><p>Among these 41 cases, CODE detected 40 cases and missed only 1 case <ref type="table">(Table 4)</ref>. Further investigation on the missing case showed CODE had over-fitted the context for that error; that is, the context learned was longer than that observed after the reproduction. We suspect there might exist two different program flows that preceded the access to the corresponding Registry Key, and CODE learned a longer context than what was observed during detection. <ref type="bibr">5</ref> Some errors require special hardware setup or specific software versions to reproduce.</p><p>Machine OS and Server 03 Vista xp-sp2 xp-sp3 xp-VM IE version IE 6 IE 7 IE7 IE 7 IE 6 Doubleclick 1 (1) 1 <ref type="formula">(1) 1 (3) 1 (3)</ref>   <ref type="formula">(1) 1 (2) 1 (3)</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">(3) Explorer Policy</head><p>1 <ref type="formula">(1) 1 (2) 1 (2) 1 (5) 1 (2)  Shortcut</ref> 1 <ref type="formula">(1) 1 (1) 1 (3) 1 (1)</ref>  <ref type="table">Table 4</ref>: Detection results of reproduced real errors. The first number in each box is the rank of the root cause event, and the second number in the parenthesis is the total number of violations observed in detection. N/A means we couldn't reproduce that error on that machine, and "-" is the case CODE missed. <ref type="table">Table 4</ref> lists the total number of violations before CODE aggregated the warnings within the one second delay buffer. In all these cases, the root cause event was the first event that occurred. The other violations all happened in a burst right after the first one. By aggregating warnings ( Sect. 6.1), only the first alarm is reported.</p><formula xml:id="formula_1">1 (2) Password N/A 1 (2) 1 (1) 1 (2) 1 (2) IE Offline 1 (1) 1 (1) 1 (2) - 1 (1) Outlook Trash 1 (2) 1 (2) 1 (2) 1 (2) N/A</formula><p>Indeed, manual inspection suggests those additional violations are not false positives but are highly correlated to the root cause. For example, the Outlook Trash error is triggered by modifying the Data of Key "HKCU\Software\Microsoft\Office\11.0\Outlook\</p><p>Preferences\Emptytrash" to 1. This error caused an alert window to pop up on each exit of Outlook, asking whether to permanently delete all items in the "Deleted Items" folder.</p><p>This alert window is related to another Registry Key "\HKCU\ Software\Microsoft\Office\11.0\Outlook\Common\Alerts", whose settings were changed during the error, causing CODE to report additional violations.</p><p>Based on the diagnosis information output by CODE, we can easily recover all the reproduced errors by changing the corrupted Registry entries back to the expected ones. However, due to the complex dependencies between today's system components, we expect automatic recovery to be a challenging topic for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.2">Exhaustive Key Corruption</head><p>To evaluate the coverage of CODE's error detection, we manually deleted every Registry Key that is frequently accessed (≥ 2 times) by a process on a virtual machine. Note that this does not imply CODE can detect configuration errors caused by only Registry deletions. Any change to Registries such as modifications or new Key/Value creations, can be detected by CODE so long as a future access to these modified Registries violates a learned rule. For example, the AutoUpdate error in Section 3.2 was caused by modification to a Registry Data.</p><p>The process we chose is Internet Explorer (IE), which has both the maximum number of Registries and distinct Registry Key accesses on a typical desktop machine. We ran a program that simulates user browsing activities by periodically launching an IE browser, visiting a Web site, and then closing the browser. After running this program for two hours (for the learning phase), we deleted every Registry Key that IE accessed more than twice during the two hours, one at at time. After each corruption, we ran the program twice that simulates a user's Web visit and let CODE perform detection. We then recovered the corrupted Key before proceeding to the next Key corruption.   <ref type="table" target="#tab_3">Table 5</ref> summarizes the statistics and the results. Among the 387 successfully corrupted Keys, CODE detected 374 (96.6%) of them. Note not every frequently accessed Key can be corrupted. Among 783 of the frequent Keys, we successfully found and corrupted only 387 of them. The remaining Keys were temporary to the life time of a particular IE instance. Since our experiment periodically launched a new IE instance, those temporary Keys no longer existed at the deletion time.</p><p>In total, CODE failed to detect 13 of the corrupted Keys, among which, 12 are Keys or sub-Keys of the following 4 Keys:</p><formula xml:id="formula_2">• HKEY LOCAL MACHINE\software\ classes\rlogin • HKEY LOCAL MACHINE\software\ classes\telnet • HKEY LOCAL MACHINE\software\ classes\tn3270 • HKEY LOCAL MACHINE\software\ classes\mailto</formula><p>These Keys store settings about the dynamically linked libraries for handling four application-layer protocols and they are periodically queried by IE. During the exhaustive Key-corruption experiment, we deleted a Registry Key "AutoProxyTypes" that stores settings about automatic Internet sign-up and proxy detection. The deletion of this Key may have triggered persistent program behavior changes in IE, which switched to an alternative configuration option that did not rely on the above four Keys to perform Internet sign-up and proxy detection. This example also suggests that recovering from errors triggered by configuration changes may require more than reversing these modifications.  To further understand the predictability of using contexts for detection, we measure the number of the Registry accesses that fall into contexts, where our detection is applicable. <ref type="table" target="#tab_5">Table 6</ref> shows that out of the total 2,090,777 accesses to the frequent Keys, 2,083,912 (99.7%) of them fall into some contexts, and thus may be captured by CODE. Furthermore, 83.4% of the frequent accesses belong to a single non-overlapping context. This means that their access happened in only one deterministic way. On average, for each frequent Registry access, it has 1.74 contexts. For those Registry accesses that have more than one context, most of them are related to the settings of dynamically linked modules that may be shared by different components in IE, resulting in more than one context.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">False Positive Rate</head><p>We evaluated the false positive rate of CODE using month-long Registry access logs from the following two sets of machines: (1) 8 production servers with similar hardware and workloads and (2) 10 desktops used by two interns, four researchers, one research lab manager, and three part-time vendors, giving us a diverse set of workloads. Other than the Hotbar Adware, we were unaware of any other configuration errors reported for the log-collection time period.  <ref type="table" target="#tab_6">Table 7</ref>: Summary of false positive rates (in terms of the number of warnings/machine/day) across 10 desktops and 8 servers. The meta-data for the IE Cache entities is changed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.8% Session</head><p>The statistics for a user login session are updated.</p><p>3.8% Environment Environment variable changes.</p><p>2.5% <ref type="table">Table 8</ref>: Top 5 reasons for causing false positives on one machine. The "Percentage" column shows, using the 5 categories, the percentage of alarms that can be summarized over all alarms from all machines.</p><p>average 153.83 warnings/desktop/day and 13.67 warnings/server/day. This difference can be explained by several reasons. First, many modifications to frequently accessed Registries do not occur in any frequent sequences (i.e., no context). Second, multiple Registry modifications often belong to a single sequence where CODE reports only the first modification as a warning while the state-based the approach reports all of them. Finally, some modified Registries will never be accessed again after the modification. While the state-based approach reports all such cases as warnings, CODE does not because it reports a warning only when the modified Registry is read again. We further examine the time distribution of the warnings generate by CODE. <ref type="figure" target="#fig_8">Figure 7</ref> shows that for the desktop that generated the largest number of warnings (0.96/machine/day in <ref type="table" target="#tab_6">Table 7</ref>), only 4 processes reported a total of 29 warnings during the 740 hours (more than 30 days). Most warnings are clustered in time, and are likely caused by the same configuration modification event. We analyzed the different causes of the false positives on user desktops and found that they can be categorized into a few types ( <ref type="table">Table 8</ref> summarizes the top five causes). Some of them (File Association and Environment Variable) are intended configuration changes issued by users; the others (Most Recently Used List, IE Cache, and Session Information) are temporary-data changes. By using regular expressions to filter the Registry Keys that fall into these top five causes, we can potentially reduce the false positive rate to 0.14 warnings/desktop/day.</p><p>We also observed a significant overlap in the false positives generated across different machines. Without the cooperative false positive suppression heuristic that merges false positives across machines, the false positive rate in an isolated detection would have increased from 0.26 to 0.36 warnings/desktop/day.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Analysis Sensitivity</head><p>We study CODE's sensitivity to workload and the support threshold (i.e., the number of occurrences for a frequent event sequence to be learned as a rule) in this section. Workload sensitivity. <ref type="table" target="#tab_6">Table 7</ref> shows that CODE's false positive rate is four times lower on servers than on user desktops. This is because server workloads are less interactive, and thus, their Registry access logs are less noisy. To evaluate the workload sensitivity, we measure the false positive rate of different programs for all the machines in our experiment. Among all the programs running on the servers, only 2 ever reported warnings; for programs running on desktops, 12 reported warnings. The program Windows Explorer (explorer.exe) generated the maximum number of warnings, contributing to 1/3 of the total alarms followed by Internet Explorer (iexplore.exe) and Windows Login (winlogon.exe). Windows Explorer is like the Unix shell for Windows and is highly interactive. While CODE currently uses the same support threshold 5 for learning frequent sequences, we can adjust the false positive rate by setting a larger support threshold. Support-threshold sensitivity. As discussed above, an important parameter is the support threshold for separating frequent and infrequent sequences. We evaluated this sensitivity using the desktop with the highest false positive rate (0.96/machine/day in <ref type="table" target="#tab_6">Table 7</ref>). <ref type="figure">Figure 8</ref> shows the result. As was expected, using a larger threshold decreased the false positive rate. Users and administrators can tune this parameter to trade-off detection rate vs. false positive rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Impact of Software Updates</head><p>Software updates are frequent on modern computers. Their activities may be intrusive and change a program's configuration-access patterns. We study the impact of software updates on the false positive rate in this section.</p><p>We used the logs collected from the 10 desktop machines for our analysis. We treat a warning as a software-update related false positive if the corresponding Registry was last modified by one of the Windows software update processes (e.g., ccmexec.exe, svchost.exe, update.exe) and Windows software installation processes (e.g., msiexec.exe).</p><p>Among the 78 false positives reported by CODE, only 5 were due to software updates, averaging to 0.017 warn- We further examine the most intrusive update we found in the logs: an update from Office Service Pack 2 to Service Pack 3 <ref type="bibr">[5]</ref>. This upgrade includes more than 200 patches. It affected 7 of the Office applications, created and modified more than 20,000 keys, but caused only one false positive warning. A closer look revealed that while this update created many keys, the majority of them were temporary keys for bookkeeping and were deleted right after the update, causing no warnings. This update additionally modified or deleted 61 existing keys; only 10 keys overlapped with the rules CODE learned and they were all captured in one rule, causing the only warning. These 10 keys specified the daylight saving start dates of 10 countries and were frequently queried by Outlook 6 , resulting in a CODE rule. When the Office update changed these keys, CODE detected a rule violation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Performance Evaluation</head><p>When we deploy CODE in online mode, where it periodically (every minute) processes Registry events arriving in real time, the CPU overhead is very small-less than 1% over 99% of the time, with a peak usage between 10%-25% (on an AMD 2.41GHz due-core machine). The current memory usage is between 500 MB-900 MB.</p><p>The memory overhead is largely caused by maintaining sets of tries, one for each process group. <ref type="figure">Figure 8 (b)</ref> plots the trie size growth over time in log scale for an IE process. The trie size is about 2000-3000 and converges roughly after 1 day. In contrast, the number of Registry events can be up to hundreds of millions. Even the number of distinct events is one order magnitude larger than the trie size, suggesting CODE is effective in reducing the event complexity.</p><p>We proceed to examine the trie sizes for different processes in <ref type="figure">Figure 8 (c)</ref>. For the majority of the processes, their trie sizes are consistently small, on the order of hundreds to tens of thousands of events. The total trie size across all processes on a machine is still small, on average 529,500 per user desktop and 97,042 per server. Given each trie node requires around 12 bytes (8 byte Rabin hash + 4 byte pointer), maintaining all the tries requires around 1MB-6MB in the ideal, optimized case. We suspect a large portion of the current memory overhead is caused by both caching the event sequences during the learning phase and the C# overhead. Such overhead can be potentially reduced by using sampled epoches to reduce the learning frequency, and by re-implementing the analysis module in C++. <ref type="figure">Figure 8</ref> (c) also shows the percentage of unique events included in the tries defined as event coverage. This metric roughly tracks the Registry-access predictability. We found that most of the processes have over 80% of event coverage. In particular, the snmp.exe process running on the server is highly predictable, where a trie with 27 unique events can represent 99.77% of all its Registry access events.</p><p>One of our goals is to use CODE to monitor server clusters or data center machines for detecting abnormal configuration changes. A typical server cluster consists of machines with similar hardware, software settings, running similar workloads. In this scenario, CODE could offload the analysis task from each server to a small number of centralized management servers.</p><p>We run CODE in a centralized mode, constructing a single centralized trie that consists of all the rules from Trie Size (%) Memory MB (%) 1 machine 98,042 503 2 machines 119,503 (21.9%) 510 (1.4%) 4 machines 134,892 (12.9%) 560 (9.8%) 8 machines 139,918 (3.7%) 600 (7.1%) <ref type="table">Table 9</ref>: The size and memory usage of a centralized trie constructed by analyzing events from multiple machines. The trie size is monitored after 3 days, and the memory usage is the average usage in one day.</p><p>multiple machines. <ref type="table">Table 9</ref> shows the growth of the trie size and the memory usage as we increase the number of machines to monitor. As we see, the trie size grows by only 3.7% when the number of machines to monitor increases from 4 to 8. This suggests that rules learned from multiple machines can be applied to other similarly configured machines (i.e., with similar hardware, software and workload). For centralized configuration-error detection, the memory overhead is on average about 0.4% per machine for 16GB-memory servers. We leave it as future work to fully generalize the CODE approach to perform centralized data-center management.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Discussion</head><p>Limitations: Not all configuration errors can be detected by CODE. By focusing on changes to configuration data and their access patterns, CODE may not detect errors introduced at system or software installation/setup time.</p><p>To detect these errors, we can extend CODE to process event sequences across machines, so that errors on one machine can be detected by comparing Registry event sequences from another properly installed machine. Previous work <ref type="bibr" target="#b22">[26]</ref> has also showed encouraging results by cross referencing static configuration states in a similar way. If a configuration error is caused by an event without any context, CODE cannot detect it either. However, in our evaluation, we have not encountered such errors. We have evaluated CODE on only Windows Registry, but we believe CODE's underlying techniques can potentially be generalized to other configuration formats, such as Unix's configuration files under /etc/. However, in Unix, different applications manage their own configuration data in their own format, so it might require perapplication instrumentation to collect the configuration data access trace. CODE can be deployed as both a stand-alone tool running on end user's desktops and a centralized management tool used by system administrators to monitor multiple machines in a data-center or a corporate network. We expect CODE to work better in the latter scenario for the following reasons. First, end users might have no clue on how to deal with warnings for filtering false positives. Second, with centralized management, an end user desktop can be spared from the 500-900MB memory overhead (the event collection component still needs to run on end user machines, but it has a negligible overhead <ref type="bibr" target="#b19">[23]</ref>). Third, our cooperative false positive suppression feature requires the sharing of canoncalized configuration entries, which is easier to perform in a centralizedmanagement setting. Future work: Our experiments showed that the noise in event logs varied greatly from program to programafter all, these programs have different purposes, workloads, and users. Currently CODE treats all programs uniformly in learning. However, we envision harnessing program-specific knowledge to further improve our detection accuracy and reduce false positives. In particular we may set a higher support threshold for a noisier program. Another possibility is to rank errors based on the importance of the programs affected by these errors. For example, a warning from system.exe (the Windows kernel process) may be more important than a warning from explore.exe.</p><p>In a distributed setting, CODE can collect a much larger, unbiased set of logs to improve the quality of its rules. In particular, for managing server clusters, the homogeneity of the machines may also help reduce CODE's memory overhead and false positive rates (see Section 6, 7.2, and 7.3). One challenge is canonicalization: the rules CODE learns may contain machine-specific information (e.g. machine names, IP addresses, and user names). We manually added user-name canonicalization in CODE. As future work, we plan to develop automatic or semi-automatic techniques to infer more machinespecific configuration data for canonicalization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion</head><p>We presented CODE, an online, automatic tool for configuration error detection. Our observation is rather simple: key configuration access events form highly repetitive sequences. These sequences are much more deterministic than each individual event, thus can serve as contexts to predict future events. Based on this observation, CODE uses a context-based analysis to efficiently analyze a massive amount of configuration events. We implemented CODE on Windows and used it to detect Windows Registry errors. Our results showed that CODE could successfully detect real-world configuration errors with a low false positive rate and low runtime overhead.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Registry access sequence of Windows update.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The CODE system architecture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Example of a rule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Figure 4: An example of Sequitur hierarchical rules. We also show the flattened rule in the parenthesis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Constructing a trie from frequent event sequences and identifying its rule edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Number of warnings per hour generated by the desktop that had the most number of warnings.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Average and maximum number of Registry update 
operations/process/day (across 115 processes on a regular user 
desktop over one month period). 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 5 : Summary of the Key corruption experiment.</head><label>5</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table 6 : Event context statistics.</head><label>6</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Table 7 shows the false positive rates of CODE.</head><label>7</label><figDesc></figDesc><table>Over 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head></head><label></label><figDesc>the new access patterns introduced by software updates as new rules, rather than considering them as false positives. For example, after a large Office update on a desktop, the trie size of the corresponding program increased by 10% within one day. Otherwise, the trie size was relatively stable.</figDesc><table>0.6 

0.7 

0.8 

0.9 

1 

1.1 

1.2 

1.3 

1.4 

2 
3 
4 
5 
6 
7 
8 
9 
10 

Number of alarms 

Support Threshold 

Number of alarms 

0 
1 
2 
3 
4 
5 
6 
7 

10 

2 

10 

4 

10 

6 

10 

8 

10 

10 

X: 6.026 
Y: 3055 

Time (days) 
Number of events in log scale 

Total events 
Distinct events 
Trie Size 

671 million 

2726 
3055 

489 million 

10 

1 

10 

2 

10 

3 

10 

4 

10 

5 

0 

20 

40 

60 

80 

100 

Trie size (number of nodes) 
Event coverage (%) 

Desktop processes 
Server processes 

infopath.exe 

aclient.exe 

searchindex.exe 

cqmghost.exe 
snmp.exe 

(a) 
(b) 
(c) 

Figure 8: (a) Sensitivity of false positive rate vs. support threshold. (b) The growth of the trie size and the number of events over 
time for IE (desktop) in log scale. (c) Trie size vs. event coverage for different processes on two machines. 

ing per desktop/day or 0.139 per update across total 36 
updates from these machines. These 5 warnings were 
caused by two environment variable updates, one display 
icon update, one DLL update, and one daylight saving 
start date update. This small false-positive number is not 
surprising, as software updates tend to fix bugs and add 
new functionalities, but do not change the existing fre-
quent configuration-access patterns. 
CODE learned </table></figure>

			<note place="foot">* This work was done when the authors were at Microsoft Research Silicon Valley.</note>

			<note place="foot" n="1"> Specifically, Windows has 91% of client operating system market [22, 31] and 74% of server market [10].</note>

			<note place="foot" n="2"> The overhead is negligible, even when flushing the buffer every minute [23]. 3 Different arguments often lead to different program execution paths for different tasks. Applications that launch at machine boot time often start with fixed arguments. In Windows, many applications have a graphical icon on the desktop that launches the application with fixed arguments each time.</note>

			<note place="foot" n="4"> After learning, the detection takes place in real time.</note>

			<note place="foot" n="6"> Outlook queries these keys to determine how to display the calendar items based on the current time zone.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank the anonymous reviewers and our paper shepherd Dilma Da Silva for their valuable feedbacks. We also thank Marcos K. Auguilera for his detailed comments for improving the paper. We thank Professor Yuanyuan Zhou, the UCSD Opera research group and Marti Motoyama for discussion and paper proofreading.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Mining sequential patterns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Srikant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh International Conference on Data Engineering (ICDE)</title>
		<meeting>the Eleventh International Conference on Data Engineering (ICDE)</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="3" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Automating configuration troubleshooting with dynamic information flow analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Attariyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Flinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX conference on Operating systems design and implementation (OSDI)</title>
		<meeting>the 9th USENIX conference on Operating systems design and implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Space/time trade-offs in hash coding with allowable errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">H</forename><surname>Bloom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. of ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="422" to="426" />
			<date type="published" when="1970" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Toward quantifying system manageability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth conference on Hot topics in system dependability (HotDep)</title>
		<meeting>the Fourth conference on Hot topics in system dependability (HotDep)</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Automatic software fault diagnosis by exploiting application signatures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Ruan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shaikh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd conference on Large installation system administration conference (LISA)</title>
		<meeting>the 22nd conference on Large installation system administration conference (LISA)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="23" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Why PCs are fragile and what we can do about it: A study of Windows registry problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ganapathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Lao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-R</forename><surname>Wen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DSN&apos;04</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Improved error reporting for software that uses black-box components</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Rossbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">V</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Ramadan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 ACM SIGPLAN conference on Programming language design and implementation (PLDI)</title>
		<meeting>the 2007 ACM SIGPLAN conference on Programming language design and implementation (PLDI)</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="101" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Intrusion detection using sequences of system calls</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Hofmeyr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Somayaji</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Security</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="151" to="180" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">ConfErr: A tool for assessing resilience to human configuration errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Upadhyaya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Conference on Dependable Systems and Networks With FTCS and DCC (DSN)</title>
		<meeting>IEEE International Conference on Dependable Systems and Networks With FTCS and DCC (DSN)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="157" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Discovering correctness constraints for self-management of system configuration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kiciman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Conference on Autonomic Computing (ICAC)</title>
		<meeting>the 1st International Conference on Autonomic Computing (ICAC)</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Debugging operating systems with time-traveling virtual machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">W</forename><surname>Dunlap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the annual conference on USENIX Annual Technical Conference</title>
		<meeting>the annual conference on USENIX Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Enabling configurationindependent automation by non-expert users</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kushman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Katabi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX conference on Operating systems design and implementation (OSDI)</title>
		<meeting>the 9th USENIX conference on Operating systems design and implementation (OSDI)</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Pr-miner: automatically extracting implicit programming rules and detecting violations in large software code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGSOFT Softw. Eng. Notes</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="306" to="315" />
			<date type="published" when="2005-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A space-economical suffix tree construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Mccreight</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Identifying hierarchical structure in sequences: A linear-time algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">G</forename><surname>Nevill-Manning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">H</forename><surname>Witten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fingerprinting by random polynomials</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
		<idno>TR-15-81</idno>
	</analytic>
	<monogr>
		<title level="m">Harvard University Report</title>
		<imprint>
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Using computers to diagnose computer problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Redstone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th conference on Hot Topics in Operating Systems (HotOS)</title>
		<meeting>the 9th conference on Hot Topics in Operating Systems (HotOS)</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">AutoBash: improving configuration management with operating system causality analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-Y</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Attariyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Flinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of twenty-first ACM SIGOPS symposium on Operating systems principles</title>
		<meeting>twenty-first ACM SIGOPS symposium on Operating systems principles</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="237" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
				<ptr target="http://gs.statcounter.com/#os-ww-monthly-200910-200910-bar" />
		<title level="m">Top 5 OSes on Oct 09</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Flight data recorder: Monitoring persistent-state interactions to improve systems management</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Verbowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kiciman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Daniels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Roussev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting>the 7th USENIX Symposium on Operating Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Intrusion detection via static analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2001 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2001 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="156" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Mimicry attacks on host-based intrusion detection systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Soto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM conference on Computer and communications security (CCS)</title>
		<meeting>the 9th ACM conference on Computer and communications security (CCS)</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="255" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Automatic misconfiguration troubleshooting with PeerPressure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Platt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting>the 6th USENIX Symposium on Operating Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Strider: A black-box, state-based approach to change and configuration management and support</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Verbowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dunagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Yuan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th USENIX conference on System administration</title>
		<meeting>the 17th USENIX conference on System administration</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="159" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Hidden markov models and the BaumWelch algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">R</forename><surname>Welch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>IEEE Info. Theory Society Newsletter</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Configuration debugging as search: Finding the needle in the haystack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Whitaker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename><surname>Gribble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting>the 6th USENIX Symposium on Operating Systems Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Operating system market share</title>
		<ptr target="http://marketshare.hitslink.com/operating-system-market-share.aspx?qprid=8" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Automated known problem diagnosis with event traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Lao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-R</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-Y</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st ACM SIGOPS/EuroSys European Conference on Computer Systems (EuroSys)</title>
		<meeting>the 1st ACM SIGOPS/EuroSys European Conference on Computer Systems (EuroSys)</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="375" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Sherlog: error diagnosis by connecting clues from run-time logs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Mai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pasupathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architecture Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the International Conference on Architecture Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<biblScope unit="page" from="143" to="154" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
