<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:29+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">D-TIME: Distributed Threadless Independent Malware Execution for Runtime Obfuscation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jithin</forename><surname>Pavithran</surname></persName>
							<email>jithinpavithran96@gmail.com</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Indian Institute of Technology Madras</orgName>
								<orgName type="institution" key="instit2">Indian Institute of Technology Madras</orgName>
								<orgName type="institution" key="instit3">Indian Institute of Technology Madras</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milan</forename><surname>Patnaik</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Indian Institute of Technology Madras</orgName>
								<orgName type="institution" key="instit2">Indian Institute of Technology Madras</orgName>
								<orgName type="institution" key="instit3">Indian Institute of Technology Madras</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chester</forename><surname>Rebeiro</surname></persName>
							<email>chester@cse.iitm.ac.in</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Indian Institute of Technology Madras</orgName>
								<orgName type="institution" key="instit2">Indian Institute of Technology Madras</orgName>
								<orgName type="institution" key="instit3">Indian Institute of Technology Madras</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">D-TIME: Distributed Threadless Independent Malware Execution for Runtime Obfuscation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>ARTIFACT EVALUATED PASSED</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>An important aspect of malware design is to be able to evade detection. This is increasingly difficult to achieve with powerful runtime detection techniques based on behavioural and heuristic analysis. In this paper, we propose D-TIME, a new distributed threadless independent malware execution framework to evade runtime detection. D-TIME splits a malware executable into small chunks of instructions and executes one chunk at a time in the context of an infected thread. It uses a Microsoft Windows feature called Asynchronous Procedure Call (APC) to facilitate chunk invocation; shared memory to coordinate between chunk executions ; and a novel Semaphore based Covert Broadcasting Channel (SCBC) for communication between various chunk executions. The small size of the chunks along with the asyn-chronous nature of the execution makes runtime detection difficult, while the coordinated execution of the chunks leads to the intended malign action. D-TIME is designed to be self-regenerating ensuring high resilience of the system. We evaluate D-TIME on a Microsoft Windows system with six different malware and demonstrate its undetectability with 10 different anti-virus software. We also study the CPU usage and its influence on Performance Counters.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Fighting malware is crucial to secure computer systems. The battle can only be won if one starts to think from the other side. An important characteristic of malware is to evade detection. Over the years a variety of techniques have been developed by malware authors to hide their software from anti-malware scanners.</p><p>Primitive evasion techniques, for instance, encrypted the malign code <ref type="bibr" target="#b24">[40]</ref> [42] <ref type="bibr" target="#b31">[47]</ref>, used a single instruction <ref type="bibr" target="#b14">[30]</ref>  <ref type="bibr" target="#b15">[31]</ref>, or adopted customized hypervisors <ref type="bibr" target="#b0">[1]</ref>. Though these evasion techniques could hide the static content of the malware, detecting the use of such obfuscation was trivial <ref type="bibr" target="#b11">[27]</ref>  <ref type="bibr" target="#b13">[29]</ref> [41] <ref type="bibr" target="#b27">[43]</ref>. Modern techniques evolved to use polymorphic and metamorphic malware <ref type="bibr" target="#b34">[50]</ref> [52] which generate semantically equivalent versions of themselves. Static Figure 1: Illustration of D-TIME execution. Emulators get spawned as APCs in different threads under multiple processes. Chunk are executed in the emulator one at a time. Even though APCs are asynchronously triggered, robust inter-emulator communications using shared and heap memory help coordinate chunk execution to achieve the desired malign intent.</p><p>detection techniques are found to be ineffective for these malware programs compared to behavioural and heuristic techniques <ref type="bibr" target="#b7">[23]</ref>  <ref type="bibr" target="#b9">[25]</ref>, which look at runtime aspects like the sequence of API calls made <ref type="bibr" target="#b2">[3]</ref> [35] <ref type="bibr" target="#b35">[51]</ref>, characteristics of instructions executed <ref type="bibr" target="#b28">[44]</ref> [45] <ref type="bibr" target="#b30">[46]</ref> and the control flow structure <ref type="bibr" target="#b3">[4]</ref> [24] <ref type="bibr" target="#b10">[26]</ref>.</p><p>To counter behavioural and heuristic detection, attackers came up with a variety of approaches. A number of process injection techniques like DLL-injection and PE-injection were deployed to inject the malign thread into legitimate processes <ref type="bibr" target="#b1">[2]</ref>. These techniques camouflage the malware as a thread in the victim process. Inserting unused system calls and sleep statements were other simple methods used to evade behavioural and heuristic detection. Anti-virus software detected these techniques by isolating the program execution and filtering out the fictitious statements.</p><p>A recent powerful evasion technique distributes malware execution across multiple processes in the system. This hides the detectable behavioural patterns of the malware, making them almost undetectable. For example, in MalWASH <ref type="bibr" target="#b17">[33]</ref>, Ispoglou and Payer distribute the sequence of API calls made by the malware across multiple processes. This renders dynamic detection techniques based on aspects like the sequence of API calls and control flow unsuccessful. However, MalWASH has two major drawbacks. First, MalWASH creates multiple threads under benign processes and uses them as platforms for the distributed execution of malware. While this makes the malicious binary undetectable, the execution platforms themselves are exposed <ref type="bibr" target="#b16">[32]</ref>. They have a common definitive signature that can be easily detected. Second, MalWASH requires administrative privileges to execute, thus reducing the scope of its use substantially.</p><p>In this paper we introduce D-TIME, a Distributed Threadless Independent Malware Execution framework, which like MalWASH provides a distributed environment for malware execution. However, unlike MalWASH, D-TIME distributes the malware execution without creating any new threads. Instead, pre-existing benign threads are used. The execution is in small bursts at a time, which are asynchronously triggered from random benign threads. This makes D-TIME considerably more stealthy. Further, D-TIME executes with normal user privileges and therefore has a wider usability. D-TIME takes a malware executable as input and splits it into small instruction blocks called chunks. In the target system, these chunks are injected into threads of infected processes using a Microsoft Windows feature called APC. An APC or Asynchronous Procedural Call is a function that gets executed asynchronously in the context of a target thread <ref type="bibr">[17]</ref>. Several APCs are injected into multiple target threads. Each APC is used to execute a hypervisor called emulator, which in turn executes a chunk from the malware executable. Emulators coordinate among themselves, regenerate and execute chunks sequentially so that collectively, the entire malicious action is performed. In order to achieve coordination, D-TIME uses communication channels and a novel covert channel called Semaphore based Covert Broadcasting Channel (SCBC ).</p><p>For example <ref type="figure">Figure 1</ref> shows two processes which are infected in the target system. Each process has two infected threads which trigger the emulator executions as APCs at random instances in the infected thread's context. Each emulator spawned, executes one chunk of the malware, while the communication channels ensures that collectively, emulators execute the chunks in the required sequence.</p><p>The use of APCs in D-TIME has significant advantages over MalWASH. While MalWASH needs dedicated threads to serve as execution platforms, D-TIME executes chunks of the malware in the context of the infected threads. This makes D-TIME considerably more stealthy. Further, the small chunk size and the asynchronous nature of the APC execution increases the difficulty of detection. In addition, since APCs can be invoked by user processes, D-TIME, unlike MalWASH can run without elevated privileges.</p><p>Following are the major contributions of this paper:</p><p>• We propose the first fully distributed, decentralised, threadless malware execution framework using APCs. The framework is generalisable to a large class of malware and can effectively evade detection.</p><p>• We introduce SCBC, a new robust covert channel using semaphores. Unlike most covert channels, SCBC is a persistent and broadcasting channel with high integrity of communication.</p><p>• We test D-TIME using 6 different classes of malware and evaluate the detectability with 10 state-of-the-art anti-virus software. We also evaluate the CPU usage and its effect on Performance Counters.</p><p>• We suggest countermeasures that can be incorporated in Operating Systems to detect and prevent malware that use D-TIME.</p><p>The paper is organized as follows. Section 2 discusses the necessary pre-requisites required to understand D-TIME. A brief survey of the related works is presented in Section 3. Section 4 provides an overview of D-TIME while the implementation details are discussed in Section 5. Section 6 shows the results of our evaluation of D-TIME. We discuss the countermeasures in Section 7 and we conclude the paper in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>In this section we provide the necessary background on Windows Asynchronous Procedure Calls (APCs). D-TIME depends considerably on APCs for its functioning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Asynchronous Procedural Call (APC)</head><p>An Asynchronous Procedure Call (APC) <ref type="bibr">[17]</ref> is a function that executes asynchronously in the context of a particular thread. Every thread in Windows maintains a queue called APC-queue. Any thread in the system can queue a function in the APC-queue of a target thread where the target thread may be of another process. The queued function will be asynchronously executed in the context of the target thread.</p><p>APCs can be broadly classified as kernel-mode APCs and user-mode APCs. Kernel-mode APCs are generated by the system and gets executed by means of a software interrupt. User-mode APCs are generated by applications. They do not interrupt the thread but instead are queued in the APC-queue of the target thread. They will be unqueued and executed when the thread goes to an Alertable Wait State <ref type="bibr" target="#b4">[5]</ref>. In other words, the user-mode APC is a polite way to interrupt a thread. Once a thread enters an Alertable Wait State, it will execute all the queued APCs in a FIFO manner. An APC can be queued using the Windows API:</p><formula xml:id="formula_0">DWORD QueueUserAPC( PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData );</formula><p>where pfnAPC defines the pointer to the function to be called as APC, hThread is the handle of the target thread, and dwData is the single parameter that is passed to the APC function. In this paper, we restrict our discussions to User-mode APCs. The techniques discussed can be directly adopted for Kernel-mode APCs but would need superuser privileges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Related Work</head><p>Runtime behavioural and heuristic techniques for detecting malware have been researched extensively. However, very few published works propose means to evade these techniques. One of the most common technique to evade runtime detection is by process injection, where the malign code is injected into legitimate processes. In <ref type="bibr" target="#b1">[2]</ref>, the authors describe 10 process injection techniques for Microsoft Windows. Of these, injection using APCs is one of the most powerful. Here, a payload is queued as an APC function in the target thread. The payload when executed creates a new thread under the process that executes the malware code.</p><p>Feature distributed malware <ref type="bibr" target="#b23">[39]</ref> was the first significant attempt to distribute malware execution. The authors, Min and Varadharajan, split the malware into sub-modules based on their functionality. These modules were then injected into appropriate processes. For example, the sub-module that leaks data can be injected into a web-browser. Later, Ispoglou and Payer, propose MalWASH <ref type="bibr" target="#b17">[33]</ref> and showed that a fine-grained distribution can evade behavioural detection effectively. They split the malware binary into chunks of instructions and distributed the execution of these chunks in multiple processes. The objective in MalWASH was to distribute detectable patterns in malware, such as the sequence of API calls, across processes. To construct a distributed execution environment, MalWASH creates threads in multiple benign processes and executes a piece of payload called emulator in them. These emulator-threads coordinate among themselves to execute the chunks in the required order causing the malicious action. However, MalWASH requires administrative privileges to execute and the creation of threads required by MalWASH is easy to get detected by anti-virus software. Similar to MalWASH, D-TIME distributes and executes chunks of malware code across processes. Unlike MalWASH, D-TIME uses APCs to trigger chunk execution. Thus, D-TIME does not create threads but instead executes in the context of benign threads. This makes D-TIME much more difficult to detect compared to MalWASH. Further, D-TIME executes in user mode therefore has much wider usability compared to MalWASH.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The D-TIME Architecture</head><p>D-TIME has two phases. An Offline phase, where the malware code is split into chunks and an Online phase, where the chunks are executed in the target system using emulators. The emulators are injected into infected threads in the target system as APCs and are executed asynchronously when the thread goes to an Alertable Wait State (refer Section 2.1). The first emulator to execute in the system creates a communication channel, which is used for coordinating among emulators. Each subsequent emulator that executes (1) uses the communication channel to determine the next chunk to be executed. (2) It retrieves the required chunk from a secondary storage or from a shared memory and executes it. (3) It then updates that the chunk has been executed to the other emulators using the communication channel. (4) It finally spawns more emulators using the QueueUserAPC API (refer Section 2.1) in other infected threads in the system. The net effect is that the malware gets executed in chunks, one chunk after the other triggered randomly, in the context of different benign threads. This section provides the details of the D-TIME architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Offline Processing</head><p>The primary objective of this phase is to craft chunks from the malware binary. Each of these chunks is executed by an emulator during the online phase. As an example, consider <ref type="figure" target="#fig_0">Figure 2a</ref> which shows a code snippet with a conditional statement. Depending on the truth value of the condition in Line 2 of the code snippet, either Line 4 or Line 6 will be executed. The offline phase in D-TIME splits this binary code into three chunks: Chunk 1, Chunk 2, and Chunk 3 as shown in <ref type="figure" target="#fig_0">Fig- ure 2b</ref>. Each chunk comprises of some malware instructions along with a few additional management instructions that are inserted to facilitate invocation of the subsequent chunks. The additional instructions in chunks (shown in red) determines the next chunk to be executed. This is stored in the ebx register which is used by the emulator to identify the next chunk to execute. For example, at the end of Chunk 1, if the value in the ebx register is 2, then Chunk 2 should be executed, while a value of 3 would require Chunk 3 to be executed next.</p><formula xml:id="formula_1">1 ... ; 2 cmp [a], [b] ; if(a==b){ 3 jne jmp a_unequal_b ; 4 mov [a], 0 ; a = 0 5 jmp a_unequal_b: ; } 6 mov [c], [d] ; c = d 7 ... ;</formula><p>(a) Code snippet from original malware ; end of chunk 1</p><formula xml:id="formula_2">1 -------------Chunk 1 ------------------------- 2 ... 3 cmp [a], [</formula><formula xml:id="formula_3">-------------Chunk 2 ------------------------- 1 mov [a], 0 2 mov ebx, 3 3 END: 4 nop ; end of chunk 2 -------------Chunk 3 ------------------------- 1 mov [c], [d] 2</formula><p>... To create chunks from the malware code, we used the techniques from <ref type="bibr" target="#b17">[33]</ref> which proposed 3 approaches: Basic Block splitting (BBS), Below Antivirus Signature Threshold (BAST), and Paranoid mode. BBS splits the binary at the basic block level. In the Paranoid mode, each instruction of the original malware is placed in a separate chunk. While the Paranoid mode achieves the finest splitting possible, the BBS mode has the largest chunks. The BAST mode provides a flexible chunk size based on a configurable parameter. The chunk size can vary from a single instruction (like the Paranoid mode) to an entire basic block (like the BBS mode).</p><p>The size of the chunks affects the stealthiness as well as the performance of D-TIME. Small chunks distribute the malware better reducing the number of malicious instructions executed per emulator at the cost of performance overhead. Small chunks would require a larger number of emulators to be invoked to complete the malware execution thus resulting in higher performance impact.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Online Processing</head><p>The online phase is done in a compromised system. The exploit used for the compromise varies with the target and is beyond the scope of this paper. Alike <ref type="bibr" target="#b17">[33]</ref>  <ref type="bibr" target="#b18">[34]</ref> [39] <ref type="bibr" target="#b24">[40]</ref>, D-TIME is only concerned with obfuscating the malware to prevent runtime detection.</p><p>The online phase comprises of three main components: (1) the emulators, (2) communication channels across the emulators, and (3) a Semaphore based Covert Broadcasting Channels (SCBC). Each emulator is comprised of a virtualisation layer which fetches and executes one chunk of the malware and posts the execution status over the communication channel. It also queues more emulator APCs in other infected threads. The next emulator to be triggered, will fetch and execute the subsequent chunk of the malware so that over a period of time, all the malware chunks are executed in the prescribed order.</p><p>In order to facilitate the distributed execution of the malware chunks, a communication channel is used. The channel is typically implemented using shared memory and comprises of synchronization primitives and the execution context of the malware. The synchronization primitive ensures that no two emulators simultaneously execute the same chunk. The context of the malware includes the state of registers, stack, heap, as well as an identifier for the next chunk to be executed. Thus when each emulator is triggered, it can identify the chunk to be executed, restore the state and execute the chunk.</p><p>The first emulator in the entire system creates the shared memory with a pre-defined name, DTIME_COMM_CHANNEL. This name should be changed randomly every time D-TIME executes on a system in order to prevent detection based on the channel name. When an emulator executes in a new infected process, it uses this name to connect to the shared memory. In each process, the shared memory gets mapped to a different virtual address range. Upon attaching, the first emulator receives the address range of the shared memory for the process. Since the emulator is a function, on function return the information about this address range is lost. This causes a problem since subsequent emulators executing in the same process will be unable to determine the address range of the shared memory. Thus, we need a way to efficiently transfer the shared memory address to all future emulators in that process.</p><p>To solve this problem, we propose a persistent covert channel using Semaphores for broadcasting the shared memory address to all the emulators that execute in the process. We call this the Semaphore based Covert Broadcasting Channel (SCBC). At a high level, the first emulator to execute will create a semaphore and set the count of the semaphore to a value defined by the address of the shared memory. Any other emulator can then read the semaphore count to identify the shared memory address. The details of the implementation of SCBC is discussed in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation aspects of D-TIME</head><p>D-TIME provides an environment for a distributed, decentralized system, where emulators are triggered asynchronously to execute malware chunks in different threads under multiple processes. There are several complications that arise from such an asynchronous emulator execution and the requirement of achieving a specific order of chunk executions. In this section, we will go over each component of D-TIME and their implementation challenges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">D-TIME Communication Channels</head><p>The communication channel for D-TIME needs to be robust so that it coordinates the distributed emulator executions and at the same time be stealthy so that it is not detected by anti-virus programs. D-TIME uses shared memory as a communication channel to implement specific chunk ordering. In order to reduce the number of accesses to the shared memory, there by reducing the chances of getting detected, we distinguish communication between the emulators within the process and emulators in different processes.</p><p>For communication between processes, we use a shared memory based on Inter Process Communication (IPC) <ref type="bibr">[12]</ref> primitives. We call this as the Primary Channel. For communication between the emulators within a process, we use memory in the heap which we call the Secondary Channel. The shared and heap memories are common in various applications and therefore their use in D-TIME cannot be easily detected. The emulators use a pre-defined name such as DTIME_COMM_CHANNEL to connect to the Primary channel using Windows APIs like OpenFileMapping <ref type="bibr">[13]</ref>. Once connected, the shared memory region is mapped in the virtual memory address space of the process. The secondary channels are local to each process and therefore are efficiently realised in the heap. D-TIME can have a single primary channel or multiple primary channels. In the latter case, a subset of the infected processes share a primary channel. For example, in <ref type="figure" target="#fig_1">Figure 3</ref>, Processes 1 and 2 share Primary Channel 1, while Processes 2 and 3 share Primary Channel 2. Communication between Process 1 and 3 is facilitated by Process 2 by synchronising the contents of both shared memories. This may seem like an overhead in D-TIME, but the advantage we achieve is that it leads to more resilient design. Any channel if removed by a defender, can be rebuilt using the other existing channels. Such resiliency will not be obtained if a single primary channel is used. In this case, if this channel is removed by the defender, the entire D-TIME infrastructure will collapse. Emulators spawn in threads across processes communicate using primary channels which are implemented using shared memory where as emulators spawn under the threads within the same process use secondary channels which are implemented using heap memory.</p><p>Without loss of generality, we discuss a single primary channel architecture in the rest of the paper, to keep the discussion simple.</p><p>Primary Channel (Shared Memory IPC): The shared memory is accessed by all emulators. It holds the following two tables: (1) Malware Thread <ref type="table">Table (MTT)</ref> and <ref type="formula">(2)</ref> Infected Thread <ref type="table">Table (ITT).</ref> MTT is needed for multi-threaded malware. Each row in this table corresponds to one thread of the malware and contains the identifier of the chunk to be executed next, a context structure containing the value of registers after the execution of the chunk for the thread, and a mutex for serialising chunk executions. The mutex should be locked by the emulator before executing a chunk and unlocked after the execution. Thus, at any given instant, only one emulator will be allowed to execute chunks corresponding to a thread of the malware. The ITT contains the number of queued emulators waiting to be executed under each infected thread. This count is maintained to control the number of emulators queued per thread and thus the frequency of emulator execution. An uncontrolled queuing of emulators to threads will flood the system with emulators and will lead to overconsumption of CPU resources and therefore can be easily detected. Reducing the number of queued emulators would slow down the execution of malware but makes it much more stealthy.</p><p>Secondary Channel (Heap Memory): The emulator to execute first in each process will allocate memory in the heap for use as a secondary channel. This memory is used to broadcast data to emulators spawned within the process.</p><p>As discussed in Section 4.2, the problem that arises is that the emulators need to identify the address of the heap as well as the shared memory. A naïve way to solve this problem is to ensure that the heap and shared memory are always at the same location in every process. However, this is not scalable. In the next section, we discuss an elegant solution for this problem using the Semaphore based Covert Broadcasting Channel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Semaphore based Covert Broadcasting</head><p>Channel (SCBC)</p><p>Semaphore based Covert Broadcasting Channel is based on the simple idea of using the semaphore counter as a shared integer variable. The sender creates a semaphore and sets the semaphore counter to the integer data that needs to be transmitted. The receivers can now retrieve this counter to complete the communication. SCBC serve as a persistent channel for D-TIME. A Windows semaphore is only destroyed <ref type="bibr" target="#b22">[38]</ref> when all of its clients detach it by calling CloseHandle [6] API. The emulator that creates SCBC will not detach the semaphore. Even though the emulator exits after a brief execution, the parent process is still alive. Thus the semaphore lives on. The semaphore is later retrieved by other emulators using the OpenSemaphore <ref type="bibr">[14]</ref> API by providing the pre-defined name of the semaphore.</p><p>SCBC reduces a semaphore to a simple shared integer variable and has the following advantages over other known covert channels: High integrity: The integer data transmitted is always received correctly. Broadcasting: There could be multiple listeners for the channel. Persistent: The sender and receivers need not be alive at the same time. Convenience: It is easy to implement and as convenient as using a shared variable. The following section discusses the implementation of SCBC in Windows.</p><p>SCBC Implementation in Windows: Microsoft Windows provides APIs to create <ref type="bibr">[7]</ref>, acquire <ref type="bibr">[19]</ref> [20] and release <ref type="bibr">[18]</ref> semaphores. However, a direct API is not available for retrieving the value of the semaphore. We, therefore, read the semaphore value indirectly using the ReleaseSemaphore [18] API, which provides the previous value of the semaphore after incrementing it. Thus, we first call the wait API <ref type="bibr">( WaitForSingleObject [20]</ref> or <ref type="bibr">WaitForMultipleObjects [19]</ref> 1 ) to decrement the counter by acquiring the semaphore, then we call ReleaseSemaphore API to obtain the previous count. One added to the previous count is the broadcasted number. The wait API call prior to the release API call balances the counter increment done by the latter. But this alone is not sufficient when we have multiple listeners. More than one listener could call the wait function before any of them call the release function. This will cause inconsistency in the counter value. However, the issue is easily solved by associating a mutex with the semaphore. Every listener is required to first lock the mutex to read the <ref type="bibr" target="#b0">1</ref> We may use multiple semaphores to broadcast multiple integers simultaneously. WaitForMultipleObjects can acquire all the semaphores together. SCBC is a convenient covert channel for the first emulator to broadcast the memory address to other emulators. SCBC along with the primary and secondary channels provide the communication channels for emulators to coordinate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1: Execution Steps of D-TIME Emulator</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Emulator</head><p>The emulator is the most important component of D-TIME. It gets injected at random memory locations in infected processes and gets executed in the context of threads under these processes. Thus, the emulator should be written as a position independent function <ref type="bibr" target="#b32">[48]</ref> to facilitate error-free execution. Our implementation of the emulator is a combination of assembly and C++ code. We build on from the emulator in <ref type="bibr" target="#b17">[33]</ref>.</p><p>While <ref type="bibr" target="#b17">[33]</ref> has long living emulator threads executing chunks in a loop, our emulators are short-lived APCs which execute only one chunk in its execution lifetime. The steps involved in the emulator execution are briefly described in Algorithm 1. The rest of this section discusses the details of these steps.</p><p>Due to the position independent nature, the emulator will be unaware of the address of functions in Dynamic Linked Libraries (DLLs). Thus, the address of essential functions in the host process needs to be fetched at runtime (Line 1 in Algorithm 1). Every process in Windows stores all its metadata in a Process Environment Block (PEB) <ref type="bibr">[15]</ref> structure. This data structure is available at the segment register offset fs: <ref type="bibr">[0x30]</ref>. The PEB data structure contains the address of PEB_LDR_DATA <ref type="bibr">[16]</ref> structure which contains a list of modules (DLLs) loaded by the process and their addresses. Once we have the base address of DLLs in the host process, the locations of functions in the DLLs can be easily retrieved.</p><p>Once the function addresses are obtained, the emulator determines if it is the first emulator to get executed in the process. The first emulator is supposed to initialise the communication channels for the process. To identify if the emulator is the first one, it checks for the existence of the SCBC for the process by attempting to open the mutex associated with the SCBC (refer Section 5.2) using the OpenMutexA API (Line 2). If the attempt succeeds (Line 5 to 11), it means that the channels were already initialised and the base address of the shared memory can be obtained from the semaphore counter. Otherwise, the initialisation is not done yet. In such a case, the emulator creates the mutex in a locked state (Line 13). The locked state of the mutex implies that the initialisation is under progress. Thus, other emulators if spawned during this time will have to wait for the initialisation to complete. With the mutex in locked state, the emulator initialises the communication channels by attaching the shared memory region and creating a heap memory region ( <ref type="bibr">Lines 14, 15)</ref>. After initialising the communication channels, the base address of heap memory is stored in shared memory. Then the SCBC semaphore is created and the counter value is set to the base address of the shared memory. The SCBC mutex is then released allowing other emulators to read the address and connect to the channels. These are done in Lines 16 to 19 in Algorithm 1.</p><p>After connecting to the communication channels, it finds out the next malware thread to be scheduled by running the threadScheduler function (Line 22). threadScheduler schedules threads in the malware in a round robin fashion. If chunks of all threads are already under execution or if the malware has exited, the scheduler returns an invalid thread number (-1). Otherwise, a valid thread number is returned and the emulator can attempt to execute the next chunk. However, only one emulator will execute the chunk of a malware thread at a time. Thus, the emulator locks the mutex for the thread from Malware Thread Table (MTT) to earn the execution rights (refer Section 5.1) (Lines 24).</p><p>If the emulator gets to lock the mutex from MTT, it can now execute the next chunk. The emulator retrieves the identifier of the next chunk from MTT and copies the chunk into a section of the emulator's own body which otherwise is filled with nop instructions (Line 27). The copied chunk is then subjected to address resolution (Line 28). For example, the value of jmp targets are modified to suit the address range occupied. After address relocation, the context is set for the malware execution by copying the register values from context structure under MTT to respective registers (Lines 29 to 31). Then the emulator jumps to the first instruction of the relocated chunk to execute the chunk (Line 32). If the chunk execution demands a call to a function in DLLs, the emulator determines the address of the API on the fly and the call is made. After the execution of a chunk, the emulator obtains the identifier of the next chunk to be executed from ebx register (Line 33). The next chunk identifier, as well as the register values, are updated in MTT (Lines 34 to 36). Then the emulator releases the mutex to lose the chunk execution rights (Line 37).</p><p>As the last step, the emulator queues itself to other threads. The Infected Threads Table is looked up and the emulator is queued to threads devoid of pending emulators. The pending emulator counts are incremented along with queuing. Then the emulator decrements the pending emulator count for the current thread and exits (Lines 42 to 52).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Challenges in Implementing D-TIME</head><p>Distributing the malware execution creates a number of implementation challenges. For example, the stack, heap, files descriptors, and socket descriptors of the malware should be shared among emulators. Also, the consistency of process specific information provided by functions such as GetCurrentProcessId should be ensured. In this section, we discuss some of these important challenges.</p><p>Implementing Stack and Heap: We use an approach similar to <ref type="bibr" target="#b17">[33]</ref> in order to implement the stack and heap for the malware. Stack is local to a thread while heap is a process local resource. Thus, we allocate one shared memory region for each malware thread and use it as stack and another shared memory region for the entire malware and use it as heap. Just prior to a chunk execution, the emulator will use the stack registers such as esp and ebp to point to appropriate locations in this created stack region. These details are stored in the MTT. To support the usage of heap memory, a compact version of standard heap APIs such as malloc and HeapAlloc are provided in the emulator. All calls to the heap related functions are redirected to these customised implementations.</p><p>Handling files and sockets: A file or a socket created by a process is only accessible to the specific process. This poses a challenge in D-TIME since a file or socket may be opened in one chunk and accessed (read or written) in another chunk. Thus a socket or file descriptor created should  <ref type="figure">Figure 4</ref>: CPU usage of D-TIME infected processes at steady state for different chopping mechanisms. Four victim processes are used for each case.</p><p>be shared among all the emulators. The programming interface to files <ref type="bibr" target="#b20">[36]</ref> and sockets <ref type="bibr" target="#b21">[37]</ref> in Microsoft Windows are through handles. A handle opened by a process can be duplicated for other processes using the DuplicateHandle <ref type="bibr">[8]</ref> API. As soon as a chunk execution creates a handle, the emulator duplicates the handle for all the infected processes. This information is then broadcasted over the primary channel. Emulators spawned in other processes can now use these duplicated handles to access the respective file or socket.</p><p>The above technique is useful in dealing with most of the Microsoft Windows APIs since most of them use handles. However, some rarely used handles like search handle returned by <ref type="bibr">FindFirstFile [9]</ref> used to search through files in a directory cannot be duplicated. Similarly, Graphical Device Interface (GDI) <ref type="bibr" target="#b5">[21]</ref> objects used to create graphical windows cannot be shared across processes. Custom implementations for APIs using these objects needs to be provided. Alternatively, the emulators can decide to execute all chunks requiring these APIs in the same process.</p><p>Providing process specific information: Any process specific information requested by chunks should be coherent across emulators. The information provided by APIs like GetCurrentProcessId <ref type="bibr">[11]</ref>, GetCurrentDirectory [10], etc. will be different for distinct victim processes. The coherency is maintained by redirecting these calls to custom APIs provided in the emulator. For example, D-TIME can decide to choose the process id of one of the infected process to be the pid of the malware. This id shall be returned when the chunk attempts to call GetCurrentProcessId.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation and Results</head><p>In this section, we discuss the results of our experiments and analysis of D-TIME. We selected six different malware samples for demonstrating the Proof of Concept (PoC). These samples capture the common behaviour of malware as described in <ref type="bibr" target="#b6">[22]</ref>. The sample set includes an offline key-logger (M1) which logs keystrokes in a file and a remote key-logger (M2) which sends keystrokes over the network; a backdoor (M3), which provides command line control for the remote attacker; a malware that periodically captures screenshots (M4); a malware that monitor the system and kills applications like TaskManager (M5), and a ransomware (M6). All the malware were written in C++ and compiled for 32-bit Intel x86 platform. The executables were obfuscated with D-TIME and tested on Microsoft Windows 10 Operating System.</p><p>The chunks obtained after obfuscation were injected into common software such as Chrome (version 74.0.3729.131), Skype(version 8.45.0.41), VLC (version 3.0.6), Acrobat Reader <ref type="bibr">(version 19.10.20099.322322)</ref>, Opera (version 58.0.3135.132) and Calculator (version 1803). Since the emulator was written and compiled for a 32 bit architecture, 32 bit versions of the software were used as targets.</p><p>The key to remain stealthy is to minimally influence the normal behaviour of the targets. We therefore evaluated D-TIME for its affect on the performance of the system under various configurations. We also tested D-TIME against the current state-of-the-art detection techniques using popular anti-virus software. This section provides details of the evaluation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Effect of different Splitting Algorithms</head><p>D-TIME works with different splitting algorithms: BBS, BAST, and Paranoid mode, described in Section 4.1. <ref type="table" target="#tab_2">Table 1</ref> shows the statistics of chunks in the 6 PoCs for different splitting mechanisms. The average chunk size is highest in BBS mode and lowest in Paranoid mode. Each splitting mechanism has different performance impacts. These variations are shown in <ref type="figure">Figure 4</ref>. Evidently, chopping mechanisms with higher granularity causes higher performance impact. When the chunks are small, the total number of chunks is higher. Thus it demands more emulator executions, increasing the execution overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Performance Impact</head><p>A malware can be considered to be more stealthy if it only has a minimal impact on CPU usage. We measured the CPU usage of victim processes under D-TIME infection. The test was conducted in multiple configurations and the results are given in <ref type="figure">Figures 5, 6</ref> and 7. In all configurations, the victim processes were observed to continue to serve their benign purpose even after D-TIME infection. <ref type="figure">Figure 5</ref> shows the CPU usage of processes on startup, during normal activities, when idle and when infected by D-TIME. The CPU usage of the victim processes are found to settle to an average of 20% after a few initial transients. <ref type="figure">Figure 6</ref> shows the variation in the average CPU usage of victims for different number of infected processes. Clearly, the CPU usage of a victim reduces as the number of infected processes increase. It is heavily depended on the malware chunks as well. For example, the keylogger, which loops on tiny chunks demand a higher frequency of emulator executions causing a higher CPU usage compared to Screenshooter, which is looping over bigger chunks. This trend is much more clear in the discussions of Section 6.1. <ref type="figure">Figure 7</ref> shows the average CPU usage of two victim processes for different distributions of infected threads. We infected 7 threads across Chrome and Opera distributing the threads as (5, 2), (4, 3), (3, 4), and (2, 5) respectively in each process. For example, 5 threads in Chrome and 2 threads in Opera are infected in the first configuration. The distribution of CPU usage of processes is found to be similar to the distribution of the number of threads. Thus, varying the number of </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Detectability</head><p>To test detectability, we executed D-TIME against 10 popular anti-virus software in the industry, listed in </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Countermeasures</head><p>In this section we discuss detection and removal techniques for D-TIME. We also suggest countermeasures to prevent such attacks.</p><p>Prevention Techniques: The best way to prevent D-TIME is by improving the Operating System design to prevent the attack. D-TIME is built upon the Microsoft Windows feature called APC and a covert channel named SCBC. Adding restrictions to these features can help prevent the attack.</p><p>• Queue Privilege Class (QPC): We recommend that every thread has a list called QPC, containing the identifiers of threads which can queue APCs in its APC-Queue. This restricts arbitrary threads from queuing APC on the target.</p><p>• Limiting Recursive Queuing: The D-TIME framework is heavily depended on the self-regeneration of emulators by queuing themselves as APCs in other threads recursively. Such recursive APC queuing is unlikely to be legitimate thus restricting the maximum depth of recursive queuing of APCs can prevent the attack.</p><p>• Restricting handle duplication: The Operating System shall restrict inter-process duplication as well as sharing of handles. This can considerably restrict D-TIME and all other forms of distributed malware.</p><p>• Reducing covert channels: SCBC exist in the system since the semaphore counter value can be read by the clients. The ability to make repeated wait and release calls helps the attacker to reuse a semaphore for multiple broadcasts. By restricting the access to semaphore like resources, covert channels like SCBC can be prevented.</p><p>Detection Techniques: Detecting D-TIME using behavioural and heuristic methods is intricate if not impractical. Such an analysis would require the anti-virus software to find connections between D-TIME executions across processes and threads. This is a hard problem due to the small size of the chunks executed.</p><p>A possible way of detecting D-TIME is by detecting its communications channels. However, D-TIME design is flexible to accommodate new channel designs. D-TIME can also change the communications channels dynamically at runtime. This can make the detection of side-channels a more challenging problem.</p><p>Another approach of detecting D-TIME would be by tracking CPU usage by processes and performance counters in the system. Typically, only a very few processes (usually one or two) will have a considerably high CPU usage in the operating system at a time. We notice that almost all the D-TIME infected processes have similar CPU usage pattern. This similarity of CPU usage can be used as an indication of D-TIME infection. Similarly, the rate of context switches shows a sudden increase which remains steady under D-TIME infection. This too may be used as a means of detecting D-TIME.</p><p>Removal of D-TIME: Removing D-TIME from an infected system is difficult. The defender should remove all the emulators or communication channels simultaneously to take out D-TIME. A single emulator and a channel left in the system is sufficient to bring D-TIME back to its original state due to the regenerating nature of emulators.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>This paper describes D-TIME, a malware execution framework that can evade behavioural and heuristic runtime detection by executing small chunks of malware injected in benign threads in a distributed fashion. A well coordinated execution of these chunks helps achieve the malicious action. D-TIME makes use of the Asynchronous Procedure Call (APC) feature present in Microsoft Windows, to execute chunks in arbitrary threads. It also uses the value stored in a semaphore to create a covert channel between the various chunk executions.</p><p>We evaluated D-TIME for its stealth with 10 state-of-the-art anti-virus software, CPU usage, and Performance Counters. All ten anti-virus software were unable to detect D-TIME. We seen an average increase in the CPU utilization by 20% when a D-TIME infected process executes.</p><p>While most Performance Counters evaluated were also unable to capture any specific runtime signature of D-TIME, there was a slight increase in the number of context switches. A heuristic based queuing protocol may be devised to reduce the number of unused emulators leading to a lower rate of context switches and lesser impact on the CPU usage. Similarly, minimizing the rate at which emulators are spawned would also achieve the same effect.</p><p>The success of D-TIME highlights the need for stronger malware detection techniques that should cater to distributed malware. It also emphasizes the need for Operating Systems design to be more aligned to security polices like the principle of minimum disclosure.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Example of malware code snippet getting split into chunks. A snippet containing a conditional clause is split into 3 chunks. The additional instructions added in chunk 1 and 2 (shown in red) store the identifier of the next chunk in ebx. The emulator uses this information to ensure the required order of chunk execution</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Design of communication channels for inter-emulator communication in D-TIME. Emulators spawn in threads across processes communicate using primary channels which are implemented using shared memory where as emulators spawn under the threads within the same process use secondary channels which are implemented using heap memory.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :Figure 6 :Figure 7 :Figure 8 :</head><label>5678</label><figDesc>Figure 5: CPU usage vs Time graph for processes during startup, normal activities, when idle and while infected by D-TIME obfuscated keylogger. In each victim process, all threads up to a maximum of 16 threads were infected.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>1 Fetch Addr of essential functions in DLLs 2 success ← Attempt to open SCBC mutex 3 if success then 4 success ←Attempt to lock SCBC mutex 5 if sucess then</head><label>1</label><figDesc></figDesc><table>6 

Open SCBC Semaphore 

7 

CommChannel Addr ← Semaphore-counter 

8 

else 

9 

Wait for mutex (alternatively go to 42) 

10 

go to 4 

11 

end 
12 else 

13 

Create and lock SCBC mutex 

14 

Attach shared memory 

15 

Create heap memory 

16 

Store heap memory addr. in shared memory 

17 

Create SCBC Semaphore 

18 

SCBC Semaphore counter ← Shared memory addr 

19 

Unlock SCBC Mutex 
20 end 
21 success ← False 
22 i ← threadScheduler() 
23 if i != -1 then 

24 

success ← Attempt to lock MTT[i].mutex 

25 

if success then 

26 

Next Chunk id ← MTT[i].nextChunk 

27 

Retrieve next chunk 

28 

Do re-locations in chunk 

29 

for r in {eax, ebx, ..., ebp, esp} do 

30 

r ← MTT[i].context.r 

31 

end 

32 

Execute chunk 

33 

MTT[i].nextChunk ← ebx 

34 

for r in {eax, ebx, ..., ebp, esp} do 

35 

MTT[i].context.r ← r 

36 

end 

37 

Release MTT[i].mutex 

38 

end 
39 else 

40 

go to 52 
41 end 
42 for i ← 1 to No. o f in f ected threads do 

43 

if MTT[i].threadId = currentThreadId then 

44 

MTT[i].queueCount--

45 

else 

46 

if MTT[i].count&lt; QueueT hreashold then 

47 

Queue APC in MTT[i].threadId 

48 

MTT[i].queueCount++ 

49 

end 

50 

end 
51 end 
52 Exit 

semaphore count. The mutex will be released once the value 
is retrieved. 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 1 : Statistics of chunks obtained in different chopping mecha- nisms. Size (in bytes) of the original malware, number of chunks, and average size (in bytes) of chunks for each three chopping algorithms. The BAST mode threshold is set to 16 bytes. All sizes are in bytes.</head><label>1</label><figDesc></figDesc><table>BBS 
BAST 
Paranoid 
Malware 
Size 
Count Avg Count Avg Count Avg 
M1 Offline-Keylogger 10,240 39 80.21 62 66.26 206 49.38 
M2 Online-Keylogger 10,240 47 78.46 84 62.64 233 49.52 
M3 Backdoor 
10,240 96 90.15 165 70.26 450 52.42 
M4 Screenshooter 
11,264 34 99.29 114 59.52 400 47.02 
M5 Window-Monitor 8,704 11 76.92 21 61.23 64 48.54 
M6 Ransomeware 
11,264 61 74.06 107 61.57 328 48.64 

Offline-keylogger 
Remote-keylogger 
Window-monitor 
0 

10 

20 

30 

40 

50 

60 

CPU Usage in % 

BBS Mode 
BAST Mode 
Paranoid Mode 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><head>Table 2 : Anti-virus software used for testing D-TIME.</head><label>2</label><figDesc></figDesc><table>Antivirus 
Version 
BitDefender 
23.0.22.97 
Norton 
22.17.0.183 
Kaspersky 
19.0.0.1088 
WEBROOT 
9.0.24.49 
McAfee 
17.8 
ESET 
12.1.34.0 
Avast 
19.4.2374 
AVG 
19.4.3089 
Windows Defender 4.18.1903.4 
Avira 
1.2.133.21088 

threads is a practical method of manipulating the CPU usage 
of D-TIME. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table 2 .</head><label>2</label><figDesc></figDesc><table>The 
</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Availability</head><p>The source code of our PoC is available at https://github .com/JithinPavithran/d-time.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendices A Reverse Engineering User-mode APC</head><p>Though APC is a widely used feature in Microsoft Windows, very less documentation is available on its internals. The internals is complicated and requires a deep knowledge of the Microsoft Windows internals to understand them. In this section, we discuss a high level overview of how User-mode APCs are dispatched by abstracting out the details for an easy understanding.</p><p>User-mode APCs are triggered when the target thread enters Alertable Wait State, which internally results in a call to System Service Dispatcher (SSD). SSD is an interface in Microsoft Windows for many system services. Its job is to load eax register with the identifier of the requested service and switch to ring 0 by means of sysenter instruction. sysenter transfers the control to nt!KiFastCallEntry which in turn executes the requested service. Once the service execution is completed, before resuming to ring 3, nt!KiFastCallEntry checks for any pending User-mode APC that is queued. If there are pending User-mode APCs, nt!KiDeliverApc is called to deliver these APCs. After doing the essential queue management steps such as dequeuing the first APC, nt!KiDeliverApc takes the help of nt!KiInitializeUserApc to modify the user-mode stack, user-mode context and ring 0 eip such that the thread gets hijacked to call KiUserApcDispatcher when it returns to ring 3. When the thread resumes in ring 3, it executes KiUserApcDispatcher which triggers the User-mode APC function. After the execution, KiUserApcDispatcher calls ntdll!NtContinue to set the user-mode context and pre-APC eip to resume the execution from wait call which resulted in the Alertable Wait State. ntdll!NtContinue is actually implemented as an executive service which results in a call to nt!NtContinue which checks the APC-Queue for any User-mode APC and calls nt!KiDeliverApc again to deliver the next APC. When there are no more APCs, nt!NtContinue transfer the control back to the normal mode to resume execution from the pre-APC instruction.</p><p>The repeated transfer of control between ring 0 and ring 3 causes a considerable number of context switches during the delivery of user-mode APC. The kernel-mode APCs complete the delivery in ring 0 and does not cause the overhead of context switches. However, administrative privileges are required to queue kernel-mode APCs.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Five reasons to use vmprotect</title>
		<ptr target="https://vmpsoft.com/.Accessed" />
		<imprint>
			<biblScope unit="page" from="2019" to="2024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
				<ptr target="https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process" />
		<title level="m">Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques</title>
		<imprint>
			<biblScope unit="page" from="2019" to="2024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Secur</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A virus detection scheme based on features of control flow graph</title>
	</analytic>
	<monogr>
		<title level="m">2011 2nd International Conference on Artificial Intelligence, Management Science and Electronic Commerce (AIMSEC)</title>
		<imprint>
			<date type="published" when="2011-08" />
			<biblScope unit="page" from="943" to="947" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I/O</forename><surname>Alertable</surname></persName>
		</author>
		<ptr target="https://docs.microsoft.com/en-us/windows/desktop/fileio/alertable-i-o" />
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2019" to="2024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gdi</forename><surname>Windows</surname></persName>
		</author>
		<ptr target="https://docs.microsoft.com/en-us/windows/desktop/gdi/windows-gdi" />
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2019" to="2024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A view on current malware behaviors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ulrich</forename><surname>Bayer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Imam</forename><surname>Habibi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Davide</forename><surname>Balzarotti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engin</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Kruegel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LEET</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A survey on heuristic malware detection techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Bazrafshan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hashemi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M H</forename><surname>Fard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hamzeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 5th Conference on Information and Knowledge Technology</title>
		<imprint>
			<date type="published" when="2013-05" />
			<biblScope unit="page" from="113" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Control flow graphs as malware signatures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guillaume</forename><surname>Bonfante</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthieu</forename><surname>Kaczmarek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeanyves</forename><surname>Marion</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International workshop on the Theory of Computer Viruses</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">From the design of a generic metamorphic engine to a blackbox classification of antivirus detection techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Marie</forename><surname>Borello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Éric</forename><surname>Filiol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ludovic</forename><surname>Mé</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal in Computer Virology</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="277" to="287" />
			<date type="published" when="2010-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Detecting self-mutating malware using control-flow graph matching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danilo</forename><surname>Bruschi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lorenzo</forename><surname>Martignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mattia</forename><surname>Monga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="129" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Deobfuscation of virtualization-obfuscated software: a semanticsbased approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Coogan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gen</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saumya</forename><surname>Debray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM conference on Computer and communications security</title>
		<meeting>the 18th ACM conference on Computer and communications security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="275" to="284" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On the feasibility of online malware detection with performance counters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Demme</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Maycock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jared</forename><surname>Schmitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adrian</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Waksman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simha</forename><surname>Sethumadhavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Salvatore</forename><surname>Stolfo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="559" to="570" />
			<date type="published" when="2013" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An analysis of x86 singleinstruction compiling as an obfuscation technique</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Dessau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Kajberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Department of Applied Mathematics and Computer Science</title>
		<imprint>
			<biblScope unit="volume">324</biblScope>
		</imprint>
		<respStmt>
			<orgName>Technical University of Denmark</orgName>
		</respStmt>
	</monogr>
	<note>Richard Petersens Plads, Building. compute@compute.dtu.dk, 2016. DTU supervisor: Christian D. Jensen, cdje@dtu.dk, DTU Compute</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">mov is turing-complete</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Dolan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cl. Cam. Ac. Uk</title>
		<imprint>
			<biblScope unit="page" from="1" to="4" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Break Me00 The MoVfuscator Turning mov into a soul crushing RE nightmare Christopher Domas</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Domas</surname></persName>
		</author>
		<ptr target="https://www.youtube.com/watch?v=R7EEoWg6Ekk" />
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="2019" to="2024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Evasive malware detection using groups of processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandra</forename><surname>Gheorghe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Radu</forename><surname>Mondoc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Octavian Cre¸tcre¸</forename><surname>Portase</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cre¸t</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICT Systems Security and Privacy Protection</title>
		<editor>Sabrina De Capitani di Vimercati and Fabio Martinelli</editor>
		<meeting><address><addrLine>Cham</addrLine></address></meeting>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="32" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">malWASH: Washing Malware to Evade Dynamic Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kyriakos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathias</forename><surname>Ispoglou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Payer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">10th USENIX Workshop on Offensive Technologies (WOOT 16)</title>
		<meeting><address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Abusing file processing in malware detectors for fun and profit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Shmatikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2012 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2012-05" />
			<biblScope unit="page" from="80" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Code graph for malware detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2008 International Conference on Information Networking</title>
		<imprint>
			<date type="published" when="2008-01" />
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">File Management Functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael Satran John</forename><surname>Kennedy</surname></persName>
		</author>
		<ptr target="https://docs.microsoft.com/en-us/windows/desktop/fileio/file-management-functions" />
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2019" to="2024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Getting Started with Winsock</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael Satran John</forename><surname>Kennedy</surname></persName>
		</author>
		<ptr target="https://docs.microsoft.com/en-us/windows/desktop/winsock/getting-started-with-winsock" />
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2019" to="2024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael Satran John</forename><surname>Kennedy</surname></persName>
		</author>
		<ptr target="https://docs.microsoft.com/en-us/windows/desktop/ipc/interprocess-communications" />
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2019" to="2024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Design and analysis of a new feature-distributed malware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Varadharajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 IEEE 13th International Conference on Trust, Security and Privacy in Computing and Communications</title>
		<imprint>
			<date type="published" when="2014-09" />
			<biblScope unit="page" from="457" to="464" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Polypack: an automated online packing service for optimal antivirus evasion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jon</forename><surname>Oberheide</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Bailey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Farnam</forename><surname>Jahanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd USENIX conference on Offensive technologies</title>
		<meeting>the 3rd USENIX conference on Offensive technologies</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="9" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Evolution of computer virus concealment and anti-virus techniques: a short survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maslin</forename><surname>Babak Bashari Rad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Suhaimi</forename><surname>Masrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ibrahim</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1104.1070</idno>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Camouflage in malware: from encryption to metamorphism</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maslin</forename><surname>Babak Bashari Rad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Suhaimi</forename><surname>Masrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ibrahim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Computer Science and Network Security</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="74" to="83" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Unpacking virtualization obfuscators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rolf</forename><surname>Rolles</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd USENIX Workshop on Offensive Technologies.(WOOT)</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Opcode graph similarity and metamorphic detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neha</forename><surname>Runwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Richard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Stamp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal in Computer Virology</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="37" to="52" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Opcode sequences as representation of executables for data-mining-based unknown malware detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Igor</forename><surname>Santos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Felix</forename><surname>Brezo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xabier</forename><surname>Ugarte-Pedrero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pablo</forename><forename type="middle">G</forename><surname>Bringas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Sciences</title>
		<imprint>
			<biblScope unit="volume">231</biblScope>
			<biblScope unit="page" from="64" to="82" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Detecting unknown malicious code by applying classification techniques on opcode patterns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Asaf</forename><surname>Shabtai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Moskovitch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clint</forename><surname>Feher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shlomi</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Elovici</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Security Informatics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Impeding malware analysis using conditional code obfuscation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Monirul I Sharif</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathon</forename><forename type="middle">T</forename><surname>Lanzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenke</forename><surname>Giffin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Practical malware analysis, chapter 19</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Sikorski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Honig</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<publisher>No Starch Press</publisher>
			<biblScope unit="page" from="408" to="409" />
			<pubPlace>us</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Unsupervised anomaly-based malware detection using hardware features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adrian</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simha</forename><surname>Sethumadhavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Salvatore</forename><forename type="middle">J</forename><surname>Stolfo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Angelos Stavrou, Herbert Bos, and Georgios Portokalidis</title>
		<meeting><address><addrLine>Cham</addrLine></address></meeting>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="109" to="129" />
		</imprint>
	</monogr>
	<note>Research in Attacks, Intrusions and Defenses</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Hunting for metamorphic engines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wing</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Stamp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal in Computer Virology</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="211" to="229" />
			<date type="published" when="2006-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Imds: Intelligent malware detection system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yanfang</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dingding</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongyi</forename><surname>Ye</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007-01" />
			<biblScope unit="page" from="1043" to="1047" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Malware obfuscation techniques: A brief survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilsun</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kangbin</forename><surname>Yim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 International conference on broadband, wireless computing, communication and applications</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="297" to="300" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
