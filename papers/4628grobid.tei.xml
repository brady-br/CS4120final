<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:26+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ATTACKING THE LINUX PRNG ON ANDROID WEAKNESSES IN SEEDING OF ENTROPIC POOLS AND LOW BOOT-TIME ENTROPY</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014-07-25">25 th July, 2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kaplan</surname></persName>
							<email>davidka@il.ibm.com</email>
							<affiliation key="aff0">
								<orgName type="institution">IBM Security Systems</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sagi</forename><surname>Kedmi</surname></persName>
							<email>sagik@il.ibm.com</email>
							<affiliation key="aff0">
								<orgName type="institution">IBM Security Systems</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roee</forename><surname>Hay</surname></persName>
							<email>roeeh@il.ibm.com</email>
							<affiliation key="aff0">
								<orgName type="institution">IBM Security Systems</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Avi</forename><surname>Dayan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM Security Systems</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">ATTACKING THE LINUX PRNG ON ANDROID WEAKNESSES IN SEEDING OF ENTROPIC POOLS AND LOW BOOT-TIME ENTROPY</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2014-07-25">25 th July, 2014</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Android is the most prevalent Linux-based mobile Operating System in the market today. Many features of the platform security (such as stack protection, key generation , etc.) are based on values provided by the Linux Pseudorandom Number Generator (LPRNG) and weaknesses in the LPRNG could therefore directly affect platform security. Much literature has been published previously investigating and detailing such weaknesses in the LPRNG. We build upon this prior work and show that-given a leak of a random value extracted from the LPRNG-a practical, inexpensive attack against the LPRNG internal state in early boot is feasible. Furthermore, the version of the Linux kernel vulnerable to such an attack is used in the majority of Android-based mobile devices in circulation. We also present two real-world exploitation vectors that could be enabled by such an attack. Finally, we mention current mitigations and highlight lessons that can be learned in respect to the design and use of future PRNGs for security features on embedded platforms.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. Introduction</head><p>Embedded uses of the Linux kernel are becoming increasingly prevalent. These systems make use of randomness in order to provide platform security features such as ASLR, stack canaries, key generation, and randomized IP packet identification. Such features require that the sources of randomness are robust and therefore cannot be easily predicted by an attacker. There have been a number of published works on the weaknesses in the Linux Random Number Generator (LPRNG). In their paper, Mining Your Ps and Qs: Detection of Widespread Weak Keys in Network Devices, Heninger et al. <ref type="bibr" target="#b0">[1]</ref> describe observed catastrophic key generation failures likely due to the fact that embedded systems that generate these keys do so off PRNGs that fail in robustness at the time of the key generation. In their paper they describe an observable deterministic flow of the LPRNG due to low boot-time entropy. Becherer et al. <ref type="bibr" target="#b1">[2]</ref> describe an attack against the LPRNG of an Amazon EC2 AMI image which enables a search for an ssh key-pair generated off the LPRNG.</p><p>Our contribution -Whereas Heninger et al. <ref type="bibr" target="#b0">[1]</ref> have previously observed the effects of low boot-time entropy on real-world RSA key-pair generation and have further studied the cause in respect to weaknesses of the LPRNG on embedded devices, in our paper we present a formal mathematical method for modeling these weaknesses. This allows us to quantify the effort required to enable active probabilistic attacks on the LPRNG internal state.</p><p>Using an algorithm functionally similar to that of the simulation technique postulated by Becherer et al. <ref type="bibr" target="#b1">[2]</ref> in their presentation (modified for our embedded environment), we show how the mapping of a target embedded system's boot flow combined with an active leak of a LPRNG value at some point during a lowentropy part of the boot flow could allow a remote attacker to recreate the internal state of the LPRNG. We further demonstrate that it is possible to perform a practical, optimized search for the LPRNG seeding data at boot even when entropy is injected from external sources (on vulnerable kernels).</p><p>While work by Ding et al. <ref type="bibr" target="#b2">[3]</ref> also describes weaknesses in the Boot-time entropy of Android, we present a Proof of Concept attack against a popular mobile platform in use today. For this Proof of Concept, we have identified a suitable remote active leak in a popular, vulnerable version of the Linux kernel. In addition, we have identified another leak which can be used locally by malware on most versions of Android.</p><p>We will demonstrate our attack via two practical resultant attack scenarios:</p><p>In the first scenario, we demonstrate an IPv6 Denial of Service attack against the randomly generated fragment identifier in Linux kernel version 3.0.31.</p><p>In the second scenario, we show how the Android stack canary protection could be bypassed, thereby enabling exploitation via buffer overflow vulnerability attack vectors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. Background</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Use of Linux Kernel In Android</head><p>The Android platform is based on the Linux kernel and as of Linux kernel 3.3/3.4 most Android patches have been merged into the mainline kernel itself. Being a largely open-source platform, albeit developed by Google, many mobile manufacturers have built devices running it. According to Net Applications, Android is continually gaining global market share, holding at around 37.75% at time of writing <ref type="bibr" target="#b3">[4]</ref>. Android's main problem however is one of fragmentation. There is no centralized body responsible for maintaining a single build or code-base and manufacturers have carte blanche to do as they wish. Furthermore, devices are generally abandoned by their manufacturers -it is rare that software updates are issued to older devices.</p><p>It is obvious that fragmentation leads to a security nightmare. While Google does a good job of patching vulnerabilities in the latest versions of the Android code-base, manufacturers generally don't roll out these releases to their customers. This is true even of the flagship devices once a certain amount of time has passed.</p><p>Exacerbating the problem, kernel versions for various Android releases often are incongruent with the Android platform version. For example, we found that some modern devices are running the latest version of Android (4.4 KitKat) on an older kernel which was released with Android 4.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. The Linux Random Number Generator</head><p>The Linux Random Number Generator consists of two Pseudorandom Number Generators; a blocking RNG which is exposed to user-space via the /dev/random device and blocks requests based on a count of estimated entropy persisted by the kernel and a nonblocking PRNG which is exposed both to user-space via the /dev/urandom device and to kernel-space via the exported get_random_bytes() function.</p><p>The LPRNG maintains three entropy pools. The input pool acts as the main entropy store and feeds both the blocking pool and the non-blocking pool used by the PRNGs. Our research focuses on the non-blocking PRNG -i.e. the non-blocking pool -and its associated pulls (extraction of a value) from the input pool. We do not consider the blocking pool at all as it is generally unused during Kernel boot.</p><p>When a value is requested from the non-blocking pool, the PRNG determines whether the prerequisite entropy is preset in the input pool. If sufficient entropy is available in the input pool, the pool is mixed in to the non-blocking pool (i.e. entropy is transferred to the non-blocking pool) via a Twisted Generalized Feedback Shift Register (TGFSR) mixing function. In order to extract the value, the pool is hashed (SHA1), mixed back into itself and hashed once more. The mixing of the hash back into the pool is intended to provide forward security (meaning that nothing can be known about previous values given a compromise of the internal pool state). Data is extracted in blocks of 80 bits and the final bits are truncated to match the requested pull value size.</p><p>All pools are initially seeded by mixing in the current system time in nanosecond resolution (ktime_t) to their uninitialized pool states. Entropy can be further added to the input pool in a number of ways (relevant to Linux kernels prior to 3.4.9):</p><p>Input Randomness -provided by input devices such as mouse, keyboard, touch screen. Interrupt Randomness -provided by triggered interrupts (generally disabled by modern kernels).</p><p>Each of the above can trigger entropy generation off the current system cycle count coupled together with data provided by the source event.</p><p>The kernel persists a counter for each pool which holds the amount of entropy in the pool as estimated by the kernel. This value is incremented when entropy is mixed into the pool and decremented when values are pulled from the pools. It is important to note that the entropy count as recorded by the kernel does not correlate to the actual amount of entropy of the pools. In this paper, we refer to the entropy counter value as persisted by the kernel as the Kernel Entropy Count (KEC).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. Attack</head><p>As an attacker, we would like to be able to ascertain a random value sourced from the PRNG at a certain point in the boot flow, meaning that we need to discern the internal state of the entropy pools at that point. The Shannon entropy of an attack at that point can be generalized as H(A) = H(p in , p nb ) where p in and p nb are the input pool state and the non-blocking pool state respectively. In order to discern p in and p nb , we must construct an attack which can provide us with knowledge of the following components: 1) Input pool seed 2) Non-blocking pool seed 3) External entropic injections Our attack consists of performing an optimized search for the values of these components.</p><p>The LPRNG is most susceptible to attack during early boot. An example boot flow can be observed in Algorithm 1. The kernel makes extensive use of the nonblocking pool and extracts random values via the get_random_bytes() function. In order to perform our attack, we require knowledge of a value pulled from the non-blocking pool, ideally as close to the seeding of the pools as possible. By combing through all calls made by the kernel to get_random_bytes() in earlyboot, an attacker may be able to identify areas which could potentially leak the necessary value to the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Example Initialization of PRNG Pools and</head><p>It is also necessary for us to know the order of the pulls from the non-blocking pool up until the point of our value leak. This will allow us to generate the correct state for the pulls at the point of leak locally during our attack. The most significant 4 bytes of ktime_t is often predictable. For example, an attacker could measure the time taken to reach the RNG initialization function since boot adding it to the btime value queried off /proc/stat from user-space (a localized attack scenario). Alternatively, as mentioned by Heninger et al., this value can potentially be leaked remotely via TCP timestamps.</p><p>As mentioned, the least significant 4 bytes of ktime_t represent nanoseconds. Theoretically this should unpredictably hold one of 10 9 possible values to provide just under 30 bits of entropy with each pool being seeded independently from a repeat call to ktime_get_real(). However, performing statistical analysis on this value across a range of samples shows a significant bias due to low variance across boots on embedded devices, greatly dropping the effective entropy provided by ktime_t. Our attack is predicated on this statistical analysis yielding a significant bias with which we can use to infer likely seed candidates.</p><p>As described in Section III, the kernel provides a number of interfaces for injecting entropy into the input pool. However a pull from the non-blocking pool will never cause a pull from the input pool until the input pool has a sufficiently high entropy count to allow such a pull (KEC of at least 192 bits). During early-boot of embedded devices, generally only a small amount of entropy is injected into the input pool and the KEC is low.</p><p>Considering a case where there is a sufficiently high KEC of the input pool prior to an extraction from the non-blocking pool, the entropy of the input pool, H(p in ), is bounded by the entropy mixed in through the seeding of the pool -in addition to the entropy added from external sources;</p><formula xml:id="formula_0">H(p in ) ≤ H(s in ) + H(ext).</formula><p>It follows therefore that the entropy of the attack, H(A), is bounded by to the entropy of the input pool seed combined with the entropy of the non-blocking pool seed -in addition to the entropy added from external sources; H(A) ≤ H(p in )+H(s nb ). This can be optimized further as we can consider the seed of the non-blocking pool to be dependent on the seed of the input pool. This is due to the fact that the non-blocking pool seeding ktime_t can be assumed to be an offset from the input pool seeding ktime_t. The seed of the nonblocking pool is therefore dependent on the seed of the input pool such that H(A) ≤ H(p in ) + H(o nb ) where o nb is the offset of the non-blocking pool seed from s in ;</p><formula xml:id="formula_1">o nb = s nb − s in . Generally H(o nb ) H(s nb ).</formula><p>The KEC of the input pool as recorded by the kernel is based off time deltas for each entropy source across calls to add_timer_randomness() which is responsible for injecting entropy into the pool (as all injected entropic sources call add_timer_randomness()). As the boot process is generally short, it seems unlikely that there will be sufficient time deltas across the available entropy sources in order to accumulate an KEC of 192 bits and therefore the input pool may not be mixed into the nonblocking pool during early boot. The only exception to this might be the add_interrupt_randomness() source which holds a state per IRQ; however this source is deprecated in the Linux kernel version under observation in this paper. In such a case, the entropy of the attack, H(A), is exactly equal to the independent entropy of the non-blocking pool seed; H(A) = H(s nb ).</p><p>In order to determine the candidates for s in and o nb , we perform statistical analysis on samples of these values across boots on a target device. This analysis also yields the related Shannon entropies H(s in ) and H(o nb ) -giving an indication as to whether our attack would be feasible on the particular target device under investigation.</p><formula xml:id="formula_2">As H(A) ≤ H(p in ) + H(o nb ) = H(s in ) + H(o nb ) + H(ext)</formula><p>, in order to continue with our attack, we now need to consider entropy injected from external entropy sources, H(ext).</p><p>Entropy is injected via the add_timer_randomness() call, mixing in a 12 byte sample of the current cycles, jiffies and a value passed from the entropy source, num. The sample structure which will be mixed into the input pool looks as follows (kernel 3.0. The num value can be observed by instrumenting the boot flow. One cannot consider the entropy injection to fully be deterministic as there is an observed variance in entropy addition due to jiffies and cycles. However, both jiffies and cycles are time-dependent, enabling a probabilistic approach to determine the most likely flow resulting in a particular entropy injection. We generalize jiffies and cycles as our time component.</p><p>In order to determine the time value most likely to be mixed into the input pool, we map the flow from boot until the point which we require a prediction of the next value pulled from the non-blocking pool. Calls to add_timer_randomness() are often called in quick succession and can be considered to be grouped together, forming what we term a set of calls. For each set, we record the variance of time across each of the calls in the set.</p><p>The flow from the first call to add_timer_randomness() in a set to the last call we term a path. This path is described in offsets from the first value of a component of time in the set. For example, the path <ref type="bibr">[00112]</ref> for the jiffies component of time describes a set of 5 calls where the first two calls have a value of jiffies, the next two calls have a value of jiffies + 1 and the final call, jiffies + 2. We map the paths of the call sets across our range of samples to extract the most likely paths for each respective set. Taking, for example, a set of 6 calls, path A , where path A =</p><p>[000111] P = 0.7</p><formula xml:id="formula_3">[000011] P = 0.3 , yielding</formula><p>H(path A ) = 0.88 bits of entropy. Entropy injected due to all entropy paths is H(paths) = ∑ n k=1 H(path k ) where n is the number of sets and the paths are assumed to be independent.</p><p>Once we have mapped the paths, we consider the variance of time of the first call in each path in respect to the value of time of the final call in the previous path (i.e. the dependency of the paths). We term this offset the distance, ∆, between the paths. This distance is the therefore the offset between two sets of calls. The distances between two paths, path B and path A , is ∆ BA . Entropy injected due to variance between sets is H(∆s) = ∑ n k=1 H(∆h k ) where n is the number of sets.</p><p>The only remaining unknown is the initial value of the time which could be dependent on s in resulting in a lower entropy for H(time|s in ).</p><p>Therefore, total entropy due to external entropy injection is H(ext) ≤ H(paths) + H(∆s) + H(time).</p><p>If the series of pulls before the leak is constant, the formalization of the attack is now complete. We can generalize further if there is some variance in the pulls before the leak. Let L = ((n 1 , e 1 ), (n 2 , e 2 ), . . . , (n k , e k )) be a vector denoting a series of pulls, where n i is the number of pulled bytes, and e i denotes the input pool bytes mixed into the non-blocking pool before the pull, (paths, ∆s,time). The last pair (n k , e k ) denotes the pull of the leak. In the case of a constant series of pulls before the leak, H(L) = H(ext). A leak resulting from user-space applications will have a H(L) dependent on variance due to concurrency.</p><p>A complete attack is therefore yielded in H(A) ≤ H(s in ) + H(o nb ) + H(L). In order to optimize the search, we attempt candidate values (s in , o nb , L) in descending order of inferred probabilities. Let N be the number of attempts until a success, then the expected number of candidates attempted is E(N) = ∑ n k=1 k · p k where {p k } n k=1 are the ordered inferred probabilities (p 1 ≥ p 2 ≥ · · · ≥ p n ) of the candidates. Further search optimization follows if one leak path,</p><formula xml:id="formula_4">L 1 , is a prefix of another L 2 , i.e. L 1 = ((n 1 , e 1 ), (n 2 , e 2 ), . . . , (n k 1 , e k 1 )) and L 2 = ((n 1 , e 1 ), (n 2 , e 2 ), . . . , (n k 1 , e k 1 ), . . . , (n k 2 , e k 2 )).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. Random Value Leak</head><p>In order to perform our attack, we require a leak of a random value pulled from the non-blocking pool during early boot. We were able to identify a number of areas which could potentially leak the necessary value to the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Stack Canary/Auxilliary Vector of Zygote</head><p>On Android, application processes are spawned by forking the Zygote (app_process) process (which is executed on boot).</p><p>Zygote initializes an instance of the Dalvik Virtual Machine and preloads the necessary Java classes and resources. It also exposes a socket interface for application spawn requests. When it receives such a request, the Zygote process forks itself to create a new app process with a preinitialized address space layout. This method for spawning processes introduces a known weakness described by <ref type="bibr">Ding et al. [3]</ref> to the stack canary protection mechanism due to the fact that forked processes are not execve()'d and therefore the stack canary value and auxiliary vector is inherited from parent process.</p><p>As detailed in Section VII-B, on Android versions prior to 4.3, stack canaries are generated from a 4-byte pull from the LPRNG and, as all apps are forked() from Zygote, they share the same, parent, canary value. As any application can simply inspect its own memory space and extract this canary value, this constitutes a leak that we can use to attack the LPRNG state.</p><p>On Android versions 4.3 and above, canary values are generated directly from the AT_RANDOM of the auxiliary vector which can be leaked in a similar fashion. In fact, leaking the AT_RANDOM value is possible on versions prior to 4.3 as well as the auxiliary vector exists within the process memory space regardless of whether or not it is used for the stack canary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. IPv6 Fragment Identifier</head><p>An IPv6 packet of size greater than Maximum Transmission Unit (MTU) size of the network interface is split up into fragments and transmitted. In order to defend against packet fragmentation attacks, the kernel assigns a random value to the packet identifier <ref type="bibr" target="#b4">[5]</ref>. This hinders the ability of an attacker to guess the fragment identifier. In kernel versions ≥ 3.0.2 &lt; 3.1, the identifier value is calculated off a value pulled from the nonblocking pool in early-boot (simplified in Algorithm 2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 IPv6 fragment generation</head><p>1: on boot persist 2: hashidentrnd ← GETRANDOMBYTES <ref type="formula">(4)</ref> 3:</p><p>4: on generate fragment ident (simplified) 5: hash ← JHASH2(address, hashidentrnd) 6: ident ← hash + 1</p><p>In order to leak our random value, we can send an IPv6 packet of size greater than MTU size to an address we control and capture the fragment identifier (see <ref type="figure">Figure V</ref>.1). For the first packet sent to a destination address, the identifier is usually a hash (jhash2) of the random value pulled at boot (hashidentrnd) incremented by 1. We therefore can calculate the value of hashidentrnd given the ability to reverse the jhash2 hashing function.</p><p>We are able to actively leak this fragment identifier remotely by sending an IPv6 ICMP "Echo request" with data size greater than target device interface MTU. As the "Echo request" requires the target to respond with an "Echo reply" with exactly the same data -and the size is greater than the interface MTUa fragmented packet will be returned by the target.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Attacker Target</head><p>Echo request fragment 0</p><p>Echo request fragment n . . .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reassemble packet</head><p>Generate identifier Echo reply fragment 0 Record identifier Echo reply fragment n . . . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. IPv6 Private Temporary Address</head><p>The kernel has the ability to create a private temporary IPv6 address for an interface. The lower 64 bits of the address are randomized (EUI-64) and appended to a valid IPv6 address suffix to create a valid private address. This functionality is enabled via setting /proc/sys/net/ipv6/conf/all/use_tempaddr to 2 (the default on Ubuntu 13.10 and 14.04 and potentially on many other modern distributions). Unfortunately, this functionality -while supported by the kernel -is disabled on our Samsung Galaxy S2 target phone.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. Experiment</head><p>The attack was built against our target device -a Samsung Galaxy S2 running Android 4.2 (Jelly Bean) and kernel 3.0.31.</p><p>We make use of the IPv6 Fragment Identifier leak as described in Section V-B. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Input-and non-blocking pool entropy</head><p>In order to define the parameters for the optimized search, we sampled approximately 2,500 input/nonblocking seed pairs, by adding printk() debug statements to the RNG initialization function, booting the device, dumping the output of kernel ring buffer with dmesg (which we enabled by modifying the initramfs) and rebooting (the effect of the printk() would need to be compensated for when calculating the search parameters in order to perform a blind, real-world attack).</p><p>Interestingly, we observed that the most-significant 4 bytes of ktime_t on the ARM systems we tested were always zero. We therefore only needed to consider the least significant 4 bytes (nanoseconds). Probability mass functions were generated off the sampled seeds to determine the search ranges for both the input pool seed, s in , and the offset of the non-blocking pool seed, o nb .</p><p>Input pool seed -by experimentation we determined the optimum bin size to be 11.4 bits. The Shannon entropy of the pool, H(s in ) ∼ = 18 bits (See <ref type="figure" target="#fig_1">Figure VI.1)</ref>.</p><p>Non-blocking pool seed -again by experimentation, the bin size was selected to be 3.3 bits. The Shannon entropy of the pool, H(o nb ) ∼ = 10 bits (See <ref type="figure">Figure VI.</ref>2).</p><p>Total Shannon entropy due to pool seeds is therefore H(s in ) + H(o nb ) ∼ = 28 bits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. External entropy injection</head><p>On our S2 device we observed that the input pool will never be mixed into the non-blocking pool due to the fact that insufficient entropy is injected at boot and the KEC 192-bit threshold is never reached before the leak of the random value. As an attack based on the non-blocking pool only is trivial (H(A) = H(p nb ) = H(s nb )), we modified the source code in order to artificially increase the KEC prior to the leak in order to make sure that the input pool had a KEC of at least 192 bits. We did this by adding 16 calls to rand_initialize_irq() and add_interrupt_randomness() to the initialization function of the s3c-udc USB driver which is executed by the kernel early in the boot flow. This modification allows us to demonstrate an attack on the input pool seed as well. Whilst not necessary for a real-world attack against the Galaxy S2 in early-boot, we wished to prove that an optimized search for the seeds is feasible even with additional external entropic addition -together with the entropy added via the seeding of the input pool itself. The modified flow, including external entropy sources can be seen in Algorithm 3. To continue with our attack, we now need to consider entropy injected from external entropic sources via the sample structure of the add_timer_randomness() call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 3 Modified Flow Including Injected Entropy</head><p>On our target device, the 32 bit sample.cycles value is always zero. The 32 bit num variable is a deterministic value set by the caller of add_timer_randomness() which we obtain by instrumenting the kernel boot flow. We therefore only need to consider sample.jiffies as our generalized time value. Interestingly, the 16 most significant bits are always 0xffff. As a result, there is an upper bound of 16 bits of entropy per call to add_timer_randomness() to which there are 28 calls in our flow. In practice, however, the entropy is significantly less due to the fact that add_timer_randomness() is called in quick succession in three separate groupings (sets); the first (which we artificially added by modifying the kernel) with 16 calls, the second with 10 calls and the third with 2 calls. As the calls are executed in quick succession in each set, we observe that the variance of jiffies across each of the calls in each respective set is small; i.e. each call in a set has ji f f ies + x where x ∈ {0, 1}.</p><p>We mapped the paths of the call sets across our range of 2,500 samples to extract the most likely paths for each respective set:</p><p>The first set consisting of our artificially injected 16 calls has Pr path A [00000000000000] = 1, therefore entropy H(path A ) = 0.</p><p>The second set of calls provides some variance: Total additional entropy due to injected run-time entropy paths is therefore H(paths) = H(path B ) ∼ = 0.79 bits.</p><formula xml:id="formula_5">path B =         </formula><p>As described in our generalized attack, we now consider the distance between each respective path. The distances between path B and path A , and path C and path B are defined as ∆ BA and as ∆ CB respectively. of the jiffies itself. In order to determine this value, we generated a PMF across our sample set (which can be seen in <ref type="figure">Figure VI.</ref>3). Considering this PMF independently, its entropy would be H( ji f f ies) = 4.3 bits, however one can clearly observe a direct correlation between the jiffies value and the input seed value ( <ref type="figure" target="#fig_1">Figure VI.1)</ref>. Experimentally, we found that jiffies increments every 5ms. Furthermore, we observed that the time between the seeding of the input pool (s in ) and the first addition of external entropy is fairly constant with a drift of &lt; 5 ms yielding a deterministic relative function ji f f ies = f (s in ). Therefore we can consistently predict (H( ji f f ies|s in ) = 0) the jiffies value for any given input seed according to:</p><formula xml:id="formula_6">ji f f ies = base + s in /t tick = 0x15a4 + s in /5M</formula><p>We investigated whether we could perhaps further optimize by considering the relation between the distances and the paths -and between the initial jiffies value -in order to determine whether there is a statistically significant dependency which could allow us to determine a likelihood of a certain distance/initial jiffies value being present for any specific configuration of path B . Looking at the distance and jiffies offset for incidences of the most likely path ( <ref type="bibr">[0000000111]</ref>) only, we notice that the total entropy is improved by a mere ∼ 0.09 bits which is statistically insignificant over our sample set.</p><p>As the leak in this experiment occurs in kernel-space and before execution concurrency, H(L) = H(ext).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Constructing the attack</head><p>Based on the above, total Shannon entropy for our attack is H(A) = 30.84 bits. The KEC is greater than 192 bits and therefore one can clearly see that the actual entropy is significantly less than that recorded by the kernel. We compute the ranges of candidates to attempt. Each candidate is comprised of s in , o nb , path, and ∆. In order to optimize the search, we attempt candidate values in descending order of inferred probabilities. The resultant ordered list of candidate ranges is further split into 400 sets of 50 candidate ranges each in order to assist with parallelization of the search. Each candidate range is 14.82 bits in size, giving a coverage of ≈ 80% (see <ref type="figure" target="#fig_8">Figure VI.4)</ref>. Let N * be the number of attempts of our search algorithm until it stops, then the expected number of candidates attempted is E(</p><formula xml:id="formula_7">N * ) = ∑ ψ k=1 k · Pr[N * = k]</formula><p>where ψ is the 8th decile of N:</p><formula xml:id="formula_8">N * = n &lt; ψ Pr[N = n] ψ Pr[N ≥ ψ]</formula><p>Therefore the expected number of attempts E(N * ) ∼ = 2 26.5 . We performed the search with the sets distributed over 8 1.6 GHz virtual CPU cores in 10 Windows Azure XL Virtual Machine instances (for a total of 80 concurrent executions). We observed that each core executes ∼ 86, 000 <ref type="bibr">(2 16.4</ref> ) tests per second with time to cover all 400 sets &lt; 3 minutes (accounting for overhead in range distribution instructions to cloud servers). The cost of running the 10 8-core Windows Azure VM instances is 5¢per core per hour yielding a total cost of attack (given 5 minutes of up-time) of a mere 34¢.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Newer devices</head><p>The Samsung Galaxy S2 -while still present in large quantities in the market (3.8% share at time of writing <ref type="bibr" target="#b5">[6]</ref>) -is now an aging device. However our attack can most likely be applied to a majority of Android devices in the market today (given a suitable information leak). This is due to the fact that over 90% of all Android devices at the time of writing <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">8]</ref> are running Android 4.3 or older and therefore (while we have no concrete data to support this) could be running a vulnerable kernel. Furthermore, we investigated whether our attack could work on some of the newer devices as well (with the latest version of Android -4.4 KitKat).</p><p>The PRNG kernel code of the stock Samsung Galaxy S4 (Exynos version) running Android 4.4 may still be vulnerable to attack using the method described above. Shannon entropy H(s in ) = 16 bits (Figure VI.5) and H(o nb ) = 12 bits ( <ref type="figure" target="#fig_9">Figure VI.6</ref>) over 647 samples. However we noticed that the init process on our 4.4 ROM writes to the LPRNG thereby adding entropy to the non-blocking pool (as described in Section VIII). It should however be possible to perform an attack against a S4 device running Android 4.3 using the AT_RANDOM leak as described in Section V-A. Looking at the available kernel sources for the Motorola G (Android 4.3), we noticed that it too uses a vulnerable version of the PRNG code. We did not investigate whether there is a leak that could enable the attack.</p><p>The latest version of the kernel sources available in the git repository (at the time of writing) for the Google Nexus 5 (Hammerhead) include a newer version of the LPRNG code which includes some of the mitigations detailed in Section VIII. We did not spend significant time investigating the resultant PRNG flow and therefore cannot comment on the impact of these mitigations on our attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. Exploitation Vectors</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. IPv6 fragmentation attacks</head><p>Atlasis <ref type="bibr" target="#b9">[9]</ref> describes a number of potential attacks using IPv6 fragmentation. Our search algorithm allows us to generate an expected fragment identifier for any destination address. We can use these identifiers to perform an off-path Denial of Service (DoS) against a target (specifically the S2 running vulnerable kernel 3.0.41) as will be described below.</p><p>For our Proof of Concept, we perform a DoS against a fragmented "Echo reply" packet (ping reply). Two parties, our target T (S2 mobile phone) and peer X wish to communicate over IPv6. Attacker, A, wishes to disrupt the communication. The nature of the communication is such that IPv6 packets will be fragmented (size &gt; MTU). In this case, X wishes to send an "Echo request" (ping) to T and A wishes to disrupt the reply. The full flow of the attack is as follows (Figure VII.1):</p><p>1) Prior to communication between T and X, Attacker A sends an "Echo request" with size &gt; MTU to target T 2) T responds with a fragmented "Echo reply" 3) A uses the fragment identifier from the reply to perform a search for seed data as described in Section VI 4) A then calculates the fragment identifier for a packet from T to destination X 5) A spoofs an "Echo reply" fragment from T and sends it to X with invalid data, IPv6 fragment offset and M flag set to 0 (last fragment) 6) X sends a fragmented "Echo request" to T 7) T responds with an "Echo reply" 8) X does not reassemble the fragmented packets correctly as the invalid fragment from attacker A is spliced in thereby causing the ICMPv6 "Echo reply" checksum to fail; X therefore drops the "Echo reply."</p><p>Theoretically, should the attacker be able to construct a fragment with data such as to cause the checksum to be valid, the above attack flow could be used to perform a fragment injection attack. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Stack canary bypass</head><p>A stack canary is a protection mechanism to mitigate buffer overflow vulnerabilities. A stack canary consists of a persisted random value which is placed on the stack at a point where a buffer could potentially harm the integrity of the data or code execution. Code then checks that the value on the stack matches the expected persisted value. Should a mismatch occur, execution is halted or transferred to an appropriate error handling routine. The GNU Compiler Collection (GCC) compiler generates code which pushes the canary value (__stack_chk_guard) onto the stack after the return address but before any local variables (see <ref type="figure">Figure VII.</ref>2). This value is checked when the function returns. On Android 4.2.2 and below (relevant to our Galaxy S2 running Android 4.1.2), the canary value is con-structed using a value pulled from the /dev/urandom device exposed by the LPRNG module.</p><p>When Android's libc.so (Bionic) is loaded, the dynamic linker (/system/bin/linker), calls __guard_setup() which assigns the stack canary pointer as follows: On Android 4.3 and above (relevant to the Galaxy S4 stock ROM which we tested), the stack canary value is constructed using the auxiliary vector. The auxiliary vector is a list of key-value pairs that the kernel's ELF binary loader (/fs/binfmt_elf.c in the kernel source) populates when a new executable image is loaded into a process. AT_RANDOM is one of the keys that is placed in process's auxiliary vector; its value is a pointer to a 16 random byte value provided by the kernel. The dynamic linker uses this value to initialize the stack canary protection.</p><p>An executable image is loaded into a process using the execve system call. The entry point of the execve system call is the sys_execve() function. This function delegates its work to the do_execve() routine.  On libc.so load, the dynamic linker calls the C runtime initializer __libc_preinit() which then calls __libc_init_common(). The latter is responsible for assigning the stack canary pointer as follows:</p><p>As can be seen from the above, the stack canary is the 4 upper bytes of AT_RANDOM. The kernel generates an AT_RANDOM for each process, therefore each process will have a unique stack canary value.</p><p>Our attack allows us to generate a likely candidate for the stack canary of a process executed on boot. Once we have performed a successful search for the random pool seeds (and therefore can re-create the pool states locally), we can then extract bytes from our local non-blocking pool in the order that they are extracted on boot. This allows us to call get_random_bytes() the prerequisite amount of times up until the point where the target process's canary is to be pulled from the pool. For the initial processes executed (such as /sbin/ffu and /system/bin/e2fsck) we can generate canary values with a probability that tends to determinism. As further processes are executed in time however, the probability that we are able to generate the correct value is impacted. This is due to the variance in process execution order due to concurrency -which affects us in two ways: Firstly, the scheduler is able to schedule execution concurrently across a number of logical threads and therefore it's difficult to consistently predict the order in which each process will perform an extraction from the non-blocking pool. Secondly, there is a race condition that can occur within the extraction of AT_RANDOM from the non-blocking pool itself <ref type="bibr" target="#b0">[1]</ref>. The race condition is due to the fact that entropy is extracted in 10 byte blocks. AT_RANDOM is 16 bytes long, so two extractions of 10 bytes each need to be performed in order to pull the 16 bytes from the non-blocking pool. As two processes may be scheduled to execute concurrently, the extraction from the non-blocking pool by the second process could conceivably take place before the extraction of the final 10 bytes of AT_RANDOM but after the extraction of the first 10 bytes. Any attack that is predicated on prediction of the canary value for a process will therefore need to take this variance into consideration.</p><p>In order to determine the effect of concurrent execution on a process in early boot on the S2, we recorded canary values for fixed seeds &amp; entropy across 503 samples. The probability that the most likely canary value occurs for each process can be seen in <ref type="figure">Figure VII</ref> As an example of an early boot service that has been found vulnerable, in September 2013 we privately disclosed a buffer overflow vulnerability in Android 4.3's keystore service to Google <ref type="bibr">(CVE-2014-3100</ref>) (Hay and Dayan <ref type="bibr" target="#b10">[10]</ref>). This vulnerability was fixed in Android 4.4 and subsequently publicly disclosed in June 2014. For the practical exploitation of this vulnerability, one would need to bypass the stack canary protection. As described above, our attack could potentially be used to ascertain the stack canary value (with a certain probability due variance as a result of concurrency) for the keystore process as it is launched in early boot.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. Mitigation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. State persistence</head><p>It is widely recommended that entropy is persisted across boots by pulling prior to device shutdown and mixing the pulled value on next boot. We observed that numerous Linux distributions do in fact do this, however this measure is of limited effectiveness. This is the due to fact that this value is usually persisted on the filesystem and is pulled from a user-space script. Therefore, the PRNG can still be attacked prior to the entropy being mixed in in user-space; for example in an attack such as our fragment injection attack as described in Section VII-A, or by attacking the stack canary of the processes executed prior to script execution. There has been some discussion regarding applying the persisted state in kernel-space (perhaps passed by the bootloader) <ref type="bibr" target="#b11">[11]</ref>. In our opinion such a move could provide good mitigation in certain use-cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Trusted external entropy injection</head><p>There is a move to use trusted external sources such as web-based sources in order to add entropy to the pools on boot (such as Ubuntu's Pollinate service, or random.org's randbyte api) and doing so is to be encouraged. However the kernel network stack is usually brought up only after the kernel RNG code and the external entropy request is usually mixed in from userspace. On devices such as those using Qualcomm's MSM, Samsung's Exynos, and other SoCs with RNG support, the HWRNG is provided via a kernel device driver and exposed over /dev/hw_random. A user-space daemon/script is often used to mix in entropy pulled from the HWRNG on these devices into the LPRNG by reading from /dev/hw_random and writing to /dev/random at regular intervals <ref type="bibr" target="#b12">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Hardware RNG inputs</head><p>If the SoC supports the CONFIG_ARCH_RANDOM kernel flag (meaning that there is either support in the instruction set or via a HWRNG IP block), the LPRNG module will mix in HWRNG values during initialization of the entropy pools. This solves the problem of low boot-time entropy.</p><p>Though a number of modern, commonly used ARMbased SoCs do have an HWRNG, random values are generally not pulled from the HWRNG by the LPRNG device itself (rather, it is exposed through a device as explained above). This is true for the kernels of the Google Nexus 4/5 and Samsung Galaxy S4/S5 which we investigated.</p><p>The LG G2 and G3 kernels includes code (/arch/arm/mach-msm/early_random.c) which utilizes hardware-generated random numbers via a call to TrustZone during early boot. This could also mitigate issues with low boot-time entropy.</p><p>We believe that our research may still be relevant in a world of HWRNGs. It is conceivable that some HWRNGs may be susceptible to external manipulation (such as by changing their physical properties to influence the robustness of their randomness) <ref type="bibr" target="#b13">[13,</ref><ref type="bibr" target="#b14">14]</ref>. Also, some implementations might make use of microcode as part of their implementation and it is conceivable that there might be instances of microcode that could be vulnerable to exploitation (the impact of which is demonstrated by Hornby <ref type="bibr" target="#b15">[15]</ref>). There has been some discussion on whether the risk of instruction compromise should be mitigated via hashing the RDRAND value into the entropy pools instead of XOR-ing it in <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b17">17]</ref>.</p><p>D. Changes to the PRNG in latter Kernels 1) Device randomness entropic source: In Kernel 3.4.9 a new entropic source for adding device randomness was added. The add_device_randomness() function calculates a time value ( ji f f ies ⊕ cycles) and mixes it -together with a value provided by the caller -in to both the input and non-blocking pools. The time value may be deterministic or predictable using the same techniques as described in our attack above, however the use of the call to mix in an unpredictable value to the pools could be interesting. According to the Kernel developers, this entropy source was added in order to provide a method for differentiating entropy flows across multiple devices and not to specifically add entropy itself. The effectiveness of this measure depends on how it's used. Any use which adds a value which can be discerned by an attacker would not prevent an attack. For example, adding the MAC address of a specific device would only be effective if an attacker could not discerned that MAC address (which might be possible both remotely and locally). On the flip side using an applications processor chip-id of reasonable length which might only be determinable locally by a privileged process could potentially provide a higher level of protection; or alternatively adding the value of an uninitialized device register could also be useful (provided that there is no way to externally predict or influence the value of the register).</p><p>2) Improvements to add_timer_randomness(): The add_timer_randomness() function now mixes in early boot entropy into the non-blocking pool if there is insufficient entropy in the pool (&lt; 128 bits). This removes the effect of completely ignoring external entropy sources prior to the input pool having accumulated sufficient entropy in order to have been mixed in to the non-blocking pool. Nevertheless the resultant effect on entropy may still be predictable or deterministic for the same reasons as before.</p><p>3) Return of interrupt randomness entropic source: The interrupt randomness addition routine has been rewritten and now can actively be used by the kernel. We have not investigated the effectiveness of the new implementation. 4) x86 RDSEED: RDSEED is an x86 instruction set extension which will be introduced in Intel Broadwell CPUs <ref type="bibr" target="#b18">[18]</ref>. It is guaranteed to always pull from a True Random Number Generator (TRNG) and is therefore useful for seeding PRNGs. Patches have been submitted to <ref type="bibr">Linux kernel 3.15</ref> to support this instruction <ref type="bibr" target="#b19">[19]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. Conclusion</head><p>In this paper we demonstrated a practical remote attack on the LPRNG as used in Android in the majority of Android devices in use today. We modified the kernel in order to show that an attack at early boot is feasible even when considering limited entropy sources. Additionally, we briefly commented on current/future mitigations.</p><p>Even though weaknesses in the LPRNG are well known and have been discussed in various publications, we believe that our research is helpful in quantifying the issue and demonstrating how such an attack could be built. We hope that our work will encourage device vendors and PRNG developers alike to give thought as to how their chosen random number generators actually function and highlight the risks of ineffective implementations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Disk Randomness -provided by disk activities.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure IV. 1 .</head><label>1</label><figDesc>Figure IV.1. Boot flow depicting seeding of pools, injection of external entropy into the input pool and value extraction from the non-blocking pool</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure V. 1 .</head><label>1</label><figDesc>Figure V.1. IPv6 remote fragment leak</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure VI. 1 .</head><label>1</label><figDesc>Figure VI.1. PMF depicting sampled input pool seed value (showing a clear bias) on Galaxy S2. 1000 bins of 19 bits</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure VI. 2 .</head><label>2</label><figDesc>Figure VI.2. PMF depicting sampled non-blocking pool seed offset from input seed on Galaxy S2. 1000 bins of 3.3 bits</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>[ 0000000111 ]</head><label>0000000111</label><figDesc>P = 0.822 [0000000011] P = 0.155 [0000000001] P = 0.022 others P = 0.001 with H(path B ) ∼ = 0.79. The third set is observed to be Pr path C [00] = 1, therefore H(path C ) = 0.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>ShannonFigure VI. 3 .</head><label>3</label><figDesc>Figure VI.3. PMF depicting sampled jiffies</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure VI. 4 .</head><label>4</label><figDesc>Figure VI.4. Probability of a match within 2000 sets of 50 candidate ranges of size 2 15.8</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure VI. 6 .</head><label>6</label><figDesc>Figure VI.5. PMF depicting sampled input pool seed value on a Galaxy S4. 1000 bins of 14.5 bits</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure VII. 1 .</head><label>1</label><figDesc>Figure VII.1. IPv6 ping DoS</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure VII. 2 .</head><label>2</label><figDesc>Figure VII.2. Example stack layout depicting canary placement</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure VII. 3</head><label>3</label><figDesc>illustrates the flow from do_execve() to the point where the 16 random bytes of AT_RANDOM are generated and placed in the memory of the user-space process.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure VII. 3 .</head><label>3</label><figDesc>Figure VII.3. Auxiliary vector AT_RANDOM generation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure VII. 4 .</head><label>4</label><figDesc>Figure VII.4. Probability of most likely candidate for boot processes on Galaxy S2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>Hardware Random Number Generators (HWRNGs) are becoming increasingly available on modern plat- forms. In 2012 Intel added support for a new instruction, RDRAND, in their Ivy Bridge CPUs. RDRAND is the output of a 128-bit HW PRNG that is compliant to NIST SP 800-90A. Furthermore, other device vendors provide HWRNGs as IP blocks on their SoCs. The Linux kernel supports the RDRAND Intel instruc- tion (via ARCH_RANDOM) which the kernel RNG code uses to mix values into the entropy pools.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>The flow of the search can be seen in Algorithm 4. For each candidate, the algorithm generates an ident which is compared against the expected (i.e. leaked) value, forming the 'test'.</head><label>The</label><figDesc></figDesc><table>Algorithm 4 Seed Search with IPv6 Fragment Identifier 
Leak 
1: function TESTCANDIDATE(hashidentrnd) 

2: 

ident ← JHASH2(address, hashidentrnd) 

3: 

ident ← ident + 1 

4: 

f ound ← ident == expected 

5: 

return f ound 
6: end function 

7: 

8: for all s in , o nb , path B , ∆ BA , ∆ CB do 

9: 

RESETPOOLS 

10: 

INITPRNG(s in , o nb ) 

11: 

ADDINTERRUPTRANDOMNESS 

12: 

GETRANDOMBYTES(8) 

13: 

ADDDISKRANDOMNESS(path B , ∆ BA ) 

14: 

ADDINPUTRANDOMNESS(∆ CB ) 

15: 

GETRANDOMBYTES(4) 

16: 

hashidentrnd ← GETRANDOMBYTES(4) 

17: 

f ound ← TESTCANDIDATE(hashidentrnd) 

18: 

if f ound then 
match found 

19: 

break 

20: 

end if 
21: end for 

</table></figure>

			<note place="foot" n="1"> _ _ s t a c k _ c h k _ g u a r d = * r e i n t e r p r e t _ c a s t &lt; u i n t p t r _ t * &gt;( g e t a u x v a l (AT_RANDOM) ) ;</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Mining your Ps and Qs: detection of widespread weak keys in network devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadia</forename><surname>Heninger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zakir</forename><surname>Durumeric</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Wustrow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Halderman</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=2362793.2362828" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st USENIX conference on Security symposium</title>
		<meeting>the 21st USENIX conference on Security symposium</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>Security&apos;12, page 35. USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Cloud Computing Security: Raining on the Trendy New Parade</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Becherer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Stamos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Wilcox</surname></persName>
		</author>
		<ptr target="https://www.isecpartners.com/media/12952/cloud-blackhat-2009-isec.pdf" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Android Low Entropy Demystified</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhuo</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chao</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Communications (ICC)</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Market share for mobile, browsers, operating systems and search engines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Netmarketshare</surname></persName>
		</author>
		<ptr target="http://marketshare.hitslink.com/" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">ipv6: make fragment identifications less predictable&quot; has been added to the 3.0-stable tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Gregkh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Patch</surname></persName>
		</author>
		<ptr target="http://permalink.gmane.org/gmane.linux.kernel.stable/16086" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Android phone market share</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Appbrain</surname></persName>
		</author>
		<ptr target="http://www.appbrain.com/stats/top-android-phones" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Appbrain</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Android SDK version market shares</title>
		<ptr target="http://www.appbrain.com/stats/top-android-sdk-versions" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dashboards</surname></persName>
		</author>
		<ptr target="https://developer.android.com/about/dashboards/index.html?utm_source=ausdroid.net" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Fragmentation (Overlapping) Attacks One Year Later</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antonios</forename><surname>Atlasis</surname></persName>
		</author>
		<ptr target="https://www.troopers.de/wp-content/uploads/2013/01/TROOPERS13-Fragmentation_Overlapping_Attacks_Against_IPv6_One_Year_Later-Antonios_Atlasis.pdf" />
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Android Keystore Stack Buffer Overflow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roee</forename><surname>Hay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Avi</forename><surname>Dayan</surname></persName>
		</author>
		<ptr target="http://www.slideshare.net/ibmsecurity/android-keystorestackbufferoverflow" />
		<imprint>
			<date type="published" when="2014-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Add devicetree scanning for randomness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Re</surname></persName>
		</author>
		<ptr target="https://lkml.org/lkml/2014/2/12/508" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>RFC/PATCH 0/3</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Code Aurora Forum</title>
		<ptr target="https://github.com/CyanogenMod/android_external_qrngd/blob/cm-10.2/qrngd.c" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Frequency Injection Attack on True Random Number Generators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Theodore</forename><surname>Markettos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Simon W Moore</surname></persName>
		</author>
		<idno type="doi">doi:10.1007/978-3-642-04138-9\_23</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Workshop on Cryptographic Hardware and Embedded Systems</title>
		<meeting>the 11th International Workshop on Cryptographic Hardware and Embedded Systems</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="317" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Influence of the temperature on true random number generators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Soucarros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Canovas-Dumas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Clediere</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Elbaz-Vincent</surname></persName>
		</author>
		<idno type="doi">doi:10.1109/HST.2011.5954990</idno>
	</analytic>
	<monogr>
		<title level="m">Hardware-Oriented Security and Trust (HOST)</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="24" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Prototyping an RDRAND Backdoor in Bochs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taylor</forename><surname>Hornby</surname></persName>
		</author>
		<ptr target="https://defuse.ca/files2/poc/pocorgtfo03.pdf" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ingo</forename><surname>Molnar</surname></persName>
		</author>
		<idno>PATCH 07/10</idno>
		<ptr target="http://thread.gmane.org/gmane.linux.kernel/1323386/focus=1332780" />
		<title level="m">random: add new get_random_bytes_arch() function</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">PATCH] random: use the architectural HWRNG for the SHA&apos;s IV in extract_buf(</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Theodore</forename><surname>Ts&amp;apos;o</surname></persName>
		</author>
		<ptr target="https://groups.google.com/forum/#!topic/linux.kernel/QgrTQMMufaM" />
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Mechalas</surname></persName>
		</author>
		<ptr target="https://software.intel.com/en-us/blogs/2012/11/17/the-difference-between-rdrand-and-rdseed" />
		<title level="m">The Difference Between RDRAND and RDSEED</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Linux 3.15 Random To Support Intel&apos;s RDSEED</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Larabel</surname></persName>
		</author>
		<ptr target="http://www.phoronix.com/scan.php?page=news_item&amp;px=MTY1NDY" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
