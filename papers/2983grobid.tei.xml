<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:56+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Customizing Progressive JPEG for Efficient Image Storage</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eddie</forename><surname>Yan</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaiyuan</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xi</forename><surname>Wang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karin</forename><surname>Strauss</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luis</forename><surname>Ceze</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">‡microsoft</forename><surname>Research</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Washington</forename></persName>
						</author>
						<title level="a" type="main">Customizing Progressive JPEG for Efficient Image Storage</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Modern image storage services, especially those associated with social media services, host massive collections of images. These images are often replicated at many different resolutions to support different devices and contexts, incurring substantial capacity overheads. One approach to alleviate these overheads is to resize them at request time. However, this approach can be inefficient , as reading full-size source images for resizing uses more bandwidth than reading pre-resized images. We propose repurposing the progressive JPEG standard and customizing the organization of image data to reduce the bandwidth overheads of dynamic resizing. We show that at a PSNR of 32 dB, dynamic resizing with progressive JPEG provides 2.5× read data savings over baseline JPEG, and that progressive JPEG with customized encode parameters can further improve these savings (up to 5.8× over the baseline). Finally, we characterize the decode overheads of progressive JPEG to assess the feasibility of directly decoding progressive JPEG images on energy-limited devices. Our approach does not require modifications to current JPEG software stacks.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Images are ubiquitous on the modern web. With the rapid expansion of social media services, the largest social media networks now host billions of images <ref type="bibr" target="#b5">[8]</ref>. Image hosts face the challenge of handling the massive rates at which users upload images, especially as scaling of cost per gigabyte slows <ref type="bibr" target="#b4">[7]</ref>. This issue is compounded by the need to store each image at multiple resolutions to support different contexts or devices. In 2010, Facebook stored up to 4 different versions of each image <ref type="bibr" target="#b1">[4]</ref>, later reporting that dynamic resizing was also performed <ref type="bibr" target="#b5">[8]</ref>. dynamic resizing saves capacity by generating low resolution copies of images on the fly without committing them to storage.</p><p>Faced with a similar problem, Flickr <ref type="bibr">[1]</ref> switched to dynamic resizing and reported that doing so helped to eliminate the need for storage capacity upgrades for an entire year. While dynamic resizing is an attractive method for reducing storage overheads, it introduces two main trade-offs. First, computation is traded for capacity: when an uncached image is requested, the image must be decoded and resized. Second and perhaps more importantly, bandwidth is traded for capacity: reading the entire source image for resizing can waste bandwidth. Bandwidth can be precious in cold storage scenarios that sacrifice performance for cost and density <ref type="bibr" target="#b2">[5]</ref> or when an access misses in the cache.</p><p>This paper proposes repurposing progressive JPEG to reduce both read bandwidth and storage overheads. The progressive JPEG standard specifies a variant of JPEG images originally designed for bandwidth-constrained networks. In a progressive JPEG image, image data is partitioned and arranged by frequency content instead of by vertical position in an image (scanline), allowing for a lossy preview before the entire image has been downloaded. We demonstrate that by repurposing progressive JPEG, a significant portion of read bandwidth can be saved by reading only the necessary image data for resizing. Additionally, we show that tuning encode-time parameters to match predefined image sizes can further reduce read bandwidth.</p><p>Finally, we characterize the cost of decoding custom progressive JPEG directly on the client relative to decoding resized baseline images. We find that the computation-bandwidth trade-off favors transcoding images on the server side, where the computational costs are comparable to a baseline dynamic resizing scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background: Progressive JPEG</head><p>The progressive JPEG standard was originally designed to allow partially transmitted images to be previewed <ref type="bibr" target="#b14">[17]</ref>. Progressive JPEG works by exploiting the fact that partitioning image data in the frequency domain from low to high frequency roughly corresponds to partitioning image data from coarse to fine details. By ini-  tially decoding only low frequency data, a preview can be rendered with an incomplete image file.</p><p>As with baseline JPEG images, progressive JPEG encoding involves transforming image data to the frequency domain with a discrete cosine transform (DCT). In the frequency domain, intensity values become frequency coefficients; in the case of JPEG, there are 64 coefficients for each 8 × 8 pixel region. Progressive JPEG partitions frequency coefficients into groups called scans. <ref type="figure" target="#fig_1">Figure 1</ref> shows a sketch of the progressive JPEG encode process and partitioning of scans. A single scan can contain a single coefficient, an approximation of a single coefficient, multiple coefficients, or approximations of multiple coefficients; the fundamental property is that scans contain refinements of image data. Only the first scan is necessary to display a low quality image preview.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Approach</head><p>In order to resize a baseline JPEG image to a reduced resolution, the full image must be read. We repurpose progressive JPEG, reading only the scans necessary for a specific image quality for the resized image. To further reduce the amount of data that must be read, we tune progressive JPEG parameters to match predefined image resolutions. We specify resolutions relative to source images (e.g. 10% of a 500×500 image is a 50×50 image).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Defining Image Quality</head><p>Using progressive JPEG and dynamic resizing in place of static baseline images requires an image quality metric and quality threshold to determine when have we read enough image data. For each resolution, we define image quality using the peak signal-to-noise ratio (PSNR). To compute the PSNR, the reduced resolution image (which may be lossier) is compared against a source image scaled to the same resolution. For our experiments, we choose a PSNR threshold of 32 dB as the cutoff where no additional image data (or scans) of a progressive JPEG image needs to be read. Our technique of customizing progressive JPEG is orthogonal to the choice of quality metric and threshold, but higher quality thresholds will reduce savings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Tuning Progressive JPEG Encoding</head><p>We used the jpegtran <ref type="bibr" target="#b8">[11]</ref> transcoder, which allows the groupings of frequency coefficients and their successive approximations in scans to be customized. We implement a greedy algorithm that enumerates groupings of coefficients (scan configurations) and chooses a configuration based on the resulting PSNR value. Configurations are enumerated by adding coefficient approximations until the PSNR target is met; this process is repeated for all predefined resolutions.</p><p>The algorithm is characterized by the following pseudocode which finds the next coefficient approximation to include; some details such as color channels are omitted. We tune the coefficient depth (c depth) parameter used by the greedy algorithm, as it can reduce the search time by pruning the enumerated configurations. We find that reducing this parameter leads to more space-efficient configurations, perhaps by pruning configurations that are locally optimal (in terms of PSNR) but inefficient.</p><p>An artifact of the jpegtran encoder is that it is limited to at most 100 scans in a given image. This limit also effectively constrains the maximum approximation depth (a depth) parameter for images where more scans are needed for approximation refinements. However, to our benefit, the encoder also supports specifying multiple frequency coefficients (within the same color channel) that share the same approximation level in a single scan. This feature allows us to work around the 100 scan limit in many cases; we implement a simple algorithm that identifies the longest intervals of coefficients that share approximation levels and merges these coefficients into   single scans. "Merging" can also be done with the first (DC) coefficients across channels. Merging allows us to encode images using configurations that would otherwise exceed the 100 scan limit of the encoder. Still, when this limit is exceeded, we reduce the maximum approximation depth used by the greedy algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Proposed Read-Write Process</head><p>We envision a read/write scheme <ref type="figure" target="#fig_3">(Figure 2</ref>) where, at write time, files are losslessly transcoded using a custom scan configuration as they are added to the system. At read time, only the necessary scans are read before the resulting image is transcoded to baseline JPEG. The mapping between the requested resolution and how many scans to read (offset within the file) is a result of the custom progressive JPEG configuration process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Evaluation</head><p>We evaluate the storage overheads (capacity, bandwidth) required for the four storage schemes shown in <ref type="table" target="#tab_0">Table 1</ref>. For each approach, we evaluate the storage overheads when three image resolutions in addition to the original may be requested: 10%, 25%, and 50%. For our custom progressive JPEG scheme, we also evaluate the compute overheads relative to dynamic resizing with baseline JPEG images. This comparison attempts to answer the question of whether it is beneficial to offload resizing from the image host to the requesting client-an option not possible with dynamic resizing on baseline images.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Compute Overheads</head><p>Many existing JPEG decoders support progressive JPEG and custom progressive JPEG, raising the question of whether progressive JPEG images should be served directly to clients without transcoding to baseline JPEG. However, decoding progressive JPEG images is more computationally expensive than decoding (equivalent) baseline images <ref type="bibr" target="#b9">[12]</ref>. We therefore consider the computational overheads of two schemes: (1) the preferred scheme where custom progressive JPEG images are transcoded to baseline images on the server side, and (2) where custom progressive JPEG images are served directly to the client, offloading computation from the server. Offloading transcode (2) is not possible when using baseline images as it would be equivalent to sending the entire source image. For server side transcode (1), we calculate the overhead by measuring the time to decode a custom progressive JPEG image versus a full baseline source image for resizing. For client side decode (2), we calculate overhead by measuring the time it takes to decode a custom progressive JPEG versus a previously resized baseline image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Dataset and Encoder</head><p>We perform our evaluation with the MIRFLICKR <ref type="bibr" target="#b6">[9]</ref> dataset, using 24,988 JPEG images with an average resolution of 462×399. We use the original images as the source baseline JPEG images and the ImageMagick convert <ref type="bibr" target="#b7">[10]</ref> tool to generate resized baseline images. For progressive JPEG images, we use jpegtran with the -optimize and -progressive flags. For progressive JPEG images with custom scan configurations, we use jpegtran with the -progressive and -scans <ref type="bibr">[file]</ref> flags. In all cases, jpegtran performs transcoding losslessly. We also iteratively reduce the quality level parameter until the PSNR drops below 32 dB to avoid inflating the capacity usage of static baseline images. Still, the quality level of the resized baseline images is not strictly equivalent; we compute PSNR on progressive images before they have been re-encoded to baseline images. For many (static baseline) images resized to 10% at a quality setting of 100, we observed that the PSNR was below 32 dB despite acceptable visual quality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Results</head><p>Overall, we find that dynamic resizing dramatically reduces storage overheads significantly (by 41%). Additionally, using custom progressive JPEG for dynamic resizing yields the most efficient use of storage bandwidth. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Storage Capacity</head><p>Unsurprisingly, storing baseline images along with resized images uses the most storage capacity <ref type="figure" target="#fig_5">(Figure 3</ref>). Progressive JPEG is slightly more space-efficient than baseline JPEG <ref type="bibr" target="#b12">[15]</ref>, though all dynamic resizing approaches are similar in storage utilization. Normalized to dynamic baseline JPEG, dynamic custom progressive JPEG incurs 0.3% storage overhead while dynamic progressive JPEG provides 6.0% storage savings. Custom progressive JPEG likely suffers the small additional overhead due to the increased number of scans.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Read Bandwidth</head><p>We consider the case where the requested resolutions of images are not cached 1 . We estimate the read bandwidth requirements of each method using the amount of data read necessary to achieve a satisfactory PSNR for all 24,988 images. Here, baseline pre-resized images are omitted because their PSNR values were not comparable; pre-resized images should offer competitive if not better bandwidth savings relative to custom progressive JPEG. A substantial portion of read bandwidth can be saved just by using progressive JPEG for dynamic resizing: 59% for 10% resolution, with similar improvements for other scales. Customizing progressive JPEG improves savings to 83% for the 10% resolution case. The savings in read bandwidth <ref type="figure" target="#fig_5">(Figure 3</ref>) from custom progressive JPEG can largely be explained as a PSNR-read size trade-off. This trade-off is evident for default progressive JPEG, which overshoots the quality target (reading enough scans to meet the quality target results in an average PSNR of around 37-38 dB). Interestingly, the progressive schemes seem to require roughly the same amount of read data for all three image scales; this may be a limitation of using PSNR to define image quality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Compute Overheads</head><p>For lower resolutions, the decode overheads <ref type="figure" target="#fig_6">(Figure 4</ref>) of custom progressive JPEG may be prohibitive (up to 13.6× slower than baseline JPEG) on the client side. However, the computational cost of decoding a baseline source image is comparable (1.0-2.4×) to that of decoding a custom progressive JPEG image. Given this compute-bandwidth trade-off, it makes more sense to transcode custom progressive JPEG images on the server than to decode custom progressive JPEG on the client.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion</head><p>We find that customizing progressive JPEG provides a substantial advantage in terms of read size over default progressive JPEG for our quality target. One caveat is that customizing progressive JPEG relies on trading image quality for read size; there is no inherent improvement to the JPEG standard. Rather, custom progressive JPEG facilitates partitioning images at a fine granularity so that this partitioning matches quality specifications closely. In this sense, default progressive JPEG can be viewed as an lower-bound on the bandwidth savings of custom progressive JPEG: 2.5× at a 37-38 dB threshold. Decoding progressive JPEG images is also more computationally expensive (by up to 13.6×) than decoding their baseline counterparts, enough so that it does not make sense to push decoding to the client. Still, decoding progressive JPEG images partially for transcoding on the server is comparable in terms of compute to decoding full baseline images, so transcoding on the server with custom progressive JPEG remains a reasonable approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Efficient image storage is an active field of research. Recent work has aimed to reduce overheads due to metadata for small files <ref type="bibr" target="#b1">[4]</ref> as well as develop SSD friendly caching algorithms <ref type="bibr" target="#b13">[16]</ref>. Related work has also investigated the quality-density trade-off for approximate storage, showing that matching the importance of image data with the reliability of storage can improve storage efficiency <ref type="bibr" target="#b3">[6]</ref>. Using custom progressive JPEG limits metadata overheads when only storing a single version of each image and can improve caching behavior as different versions of an image share data. Grouping scans of progressive JPEG is related to ordering image data from most to least important, but the binary format used here is not amenable to storage on approximate storage media.</p><p>Progressive JPEG images can also be partially deleted gracefully by discarding high frequency data firstimproving storage elasticity. The concept of motifs: descriptions of computation needed to reconstruct a file discussed in <ref type="bibr" target="#b10">[13,</ref><ref type="bibr" target="#b11">14]</ref> is implicitly implemented by a dynamic resizing storage scheme as only the highest quality version of an image is stored while lower quality versions are implicitly defined by motifs.</p><p>Dynamic resizing has precursors in image processing systems such as zimg <ref type="bibr">[2]</ref> that allow clients to upload and request images with added operations such as cropping and scaling. To the best of our knowledge, these systems do not vary the amount of data read based on quality via a progressive frequency domain encoding. Dynamic resizing has also been used by Flickr <ref type="bibr">[1]</ref> and Facebook <ref type="bibr" target="#b5">[8]</ref>: in addition to storing multiple versions of each photo, Facebook incorporates "Resizers" when the requested version requires additional processing. Finally, progressive JPEG has been recently used by <ref type="bibr">Facebook [3]</ref> to reduce data consumption and speed up the apparent loading of images on the client side; the latter is achieved by rendering an acceptable quality scan before all scans have been transmitted. However, this approach does not involve dynamic resizing or customizing progressive JPEG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Limitations and Future Work</head><p>A limitation of our current implementation is the cost of evaluating custom scan configurations. Our na¨ıvena¨ıve implementation takes days to process 24,988 images on 8 cluster nodes (12 cores/12 threads per node) with Westmereclass CPUs. We suspect that this time can drastically reduced without sacrificing significant bandwidth savings by aggressively pruning the search space or applying machine learning techniques to choose scan configurations. Note that while the customization process for progressive JPEG is currently expensive, it only needs to be performed once, at write time.</p><p>The PSNR metric is limited in its relevance to perceived visual quality <ref type="bibr" target="#b15">[18]</ref>. We often found that the PSNR of higher resolution resizes was higher than that of lower resolution resizes even with less image data read-this issue may be mitigated with conservative PSNR thresholds. To the best of our knowledge, there is no standard, widely used method of computing the image quality of a resized image derived from a source image.</p><p>Finally, an issue when using progressive JPEG for dynamic resizing is the minimum resolution of the resized images. Progressive JPEG is less efficient in terms of read bandwidth for resizes smaller than 10% of the source image, which may limit savings when the source images are much higher in resolution than their resized versions. This threshold is due to JPEG's use of 8 × 8 macroblocks: even a single frequency coefficient represents at least 1 64 of the total image data. Even when approximations are used, this approach may require more read bandwidth than pre-resized images. Still, using progressive JPEG should be more space-efficient than baseline JPEG for dynamic resizing.</p><p>Future Work We expect that a solution to reduce the cost of enumerating custom JPEG scan configurations will be to prune the search space to a much smaller subset of likely "good" configurations. It may be possible to obtain comparable results by only trying a few custom scan configurations per image-with this subset being determined by identifying the best configurations when na¨ıvelyna¨ıvely re-encoding a larger dataset of images. Along these lines, even choosing from a larger pool of configurations may be tractable if a machine learning model is applied to each image to choose the best configuration.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Sketch of Progressive JPEG Encoding: 1. Images are divided into 8×8 macroblocks. 2. Intensity values are transformed to the frequency-domain using a DCT. Red arrows indicate the low to high frequency order of coefficients. 3. Highlighted regions denote scans.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>for coeff ∈ (0, max coeff(config) + c depth) do if approx[coeff] = 0 then continue; end if //approx[] is initialized to a depth temp approx = approx[coeff] -1; temp config = config + (coeff, temp approx); psnr = calc psnr(source image, temp config); if psnr &gt; best psnr then best coeff = (coeff, temp approx); best psnr = psnr; end if end for return best coeff;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Sketch of a dynamic resizing scheme using custom progressive JPEG. Given an input image and predefined target resolutions (a), a suitable scan configuration is found. This process produces a mapping (b) of resolutions to scans (file offsets in bytes). Given a requested image and resolution (c), the necessary scans are read and the image transcoded.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>scheme stored data baseline (static) stores source, pre-resized images baseline (dynamic) stores source images progressive (dynamic) (ours, na¨ıvena¨ıve) stores source images in progressive format custom progressive (dynamic) (ours, preferred) stores source images in tuned progressive format</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Storage utilization (left) and read sizes measured by the amount of data read to achieve a PSNR of at least 32 dB (right). Note that the PSNR of the resulting images with each scheme can be different despite this lower-bound: default progressive JPEG overshoots the quality target. Overall, dynamic resizing schemes provide similar and substantial storage savings over static resizing. Custom progressive JPEG provides the most bandwidth savings (up to 5.8× vs. baseline).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Relative overhead of transcoding on the server (left) and relative overhead of decoding custom progressive JPEG on the client (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 1 :</head><label>1</label><figDesc>Description of each evaluated scheme. The first two schemes represent baselines used by current systems.</figDesc><table></table></figure>

			<note place="foot" n="1"> If the requested resolutions were already cached, we would expect performance to be identical under each scheme.</note>

			<note place="foot" n="9"> Conclusion Faced with growing demand for storage, image hosting services are increasingly turning to dynamic image resizing to improve the efficiency of image storage. We showed that progressive encodings can dramatically reduce the amount of data that needs to be read for resizing images-potentially saving over 80% of read bandwidth when tuned encode-time parameters used. Finally, we give an estimate of progressive JPEG decode overheads which suggests that while serving custom progressive images directly to energy-constrained devices is difficult to justify, transcoding custom progressive JPEG on the server side incurs acceptable overheads.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank the members of the Sampa group and the anonymous reviewers for their feedback. This work was supported in part by a gift from Intel Corporation and by DARPA under contract FA8750-16-2-0032.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Faster photos in Facebook for iOS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
		<ptr target="https://code.facebook.com/posts/857662304298232/faster-photos-in-facebook-for-ios/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Finding a needle in Haystack: Facebook&apos;s photo storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Beaver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sobel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vajgel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">T</forename><surname>Al</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI (2010)</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Feeding the pelican: using archival hard drives for cold storage racks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Donnelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ogus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rowstron</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th USENIX Workshop on Hot Topics in Storage and File Systems</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Highdensity image storage using approximate memory cells</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guo</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Strauss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Malvar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="413" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An economic perspective of disk vs. flash media in archival storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gupta</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Wildani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename><surname>Rosenthal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">F</forename><surname>Strong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hospodor</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE MASCOTS</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An analysis of Facebook photo caching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Huang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Birman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Van Renesse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles</title>
		<meeting>the Twenty-Fourth ACM Symposium on Operating Systems Principles</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="167" to="181" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The MIR Flickr retrieval evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Huiskes</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lew</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MIR &apos;08: Proceedings of the 2008 ACM International Conference on Multimedia Information Retrieval</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Imagemagick</forename><surname>Studio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Llc</forename><surname>Imagemagick</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Independent Jpeg Group And</forename><surname>Others</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Libjpeg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">JPEG image compression faq</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lane</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
		<ptr target="http://www.faqs.org/faqs/jpeg-faq/part1/index.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Elastic cloud storage via file motifs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sigurbjarnarson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ragnarsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">O</forename><surname>Vigfusson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Harmonium</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th USENIX Workshop on Hot Topics in Storage and File Systems</title>
		<meeting><address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Enabling space elasticity in storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sigurbjarnarson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ragnarsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">O</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vig-Fusson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Balakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">9th ACM International on Systems and Storage Conference (SYSTOR)</title>
		<meeting><address><addrLine>Haifa, Israel</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Even faster web sites: performance best practices for web developers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Souders</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>Reilly Media, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Advanced photo caching on flash for Facebook</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ripq</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th USENIX Conference on File and Storage Technologies</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="373" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The JPEG still picture compression standard</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wallace</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions on consumer electronics</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="xviii" to=" xxxiv" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">No-reference perceptual quality assessment of JPEG compressed images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Sheikh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bovik</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Image Processing</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002" />
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
