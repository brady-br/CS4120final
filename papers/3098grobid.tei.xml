<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T03:00+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">NVM Compression -Hybrid Flash-Aware Application Level Compression</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dhananjoy</forename><surname>Das</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dulcardo</forename><surname>Arteaga</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nisha</forename><surname>Talagala</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Torben</forename><surname>Mathiasen</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Lindström</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nisha</forename><surname>Das</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Torben</forename><forename type="middle">Mathiasen}@sandisk</forename><surname>Talagala</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Com</surname></persName>
						</author>
						<title level="a" type="main">NVM Compression -Hybrid Flash-Aware Application Level Compression</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>This paper describes NVM Compression, a novel hybrid technique that combines application level compression with flash awareness for optimal performance and storage efficiency. Utilizing new interface primitives exported by Flash Translation Layers (FTLs), we leverage the garbage collection available in flash devices to optimize the capacity management required by compression systems. We implement NVM Compression in the popular open source database MariaDB based on Oracle MySQL TM and use variants of commonly available POSIX file system interfaces to provide the extended FTL capabilities to the user space application. The experimental results show that the hybrid approach of NVM Compression can improve compression performance by 2-3x, deliver compression performance for flash devices that is within 5% of uncompressed performance (and sometimes exceed uncompressed performance due to less data writes), improve storage efficiency by 19% compared to legacy Row compression method, reduce data writes by up to 4x when combined with other flash aware techniques such as Atomic Writes, and deliver further advantages in power efficiency and CPU utilization.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Data compression is a well known capacity optimization method and used extensively in storage systems. Compression has historically been applied at various layers in the I/O stack, from user space applications like databases <ref type="bibr" target="#b26">[26]</ref> to some file systems <ref type="bibr" target="#b36">[35,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b29">29]</ref> and block level implementations <ref type="bibr" target="#b20">[20]</ref>. Some storage devices also have built in compression using both software and hardware methods to accelerate compression operations <ref type="bibr" target="#b4">[5]</ref>. Compression can arguably be best suited for application implementation, as the data layout and application access pattern details are well known <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b17">17,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b41">40]</ref>. However, compression dec 2014 SanDisk Corporation. All rights reserved.</p><p>INFLOW '14, October 5, Broomfield, CO USA. signs can add complexity since variable data sizes must be accommodated. Implementing compression at application level therefore implies that the application must now take on the burden of variable data size management in addition to its other duties.</p><p>Compression is also extremely attractive for flash based systems to both improve cost/capacity and to improve lifetime by reducing media writes. In the case of flash specifically, the Flash Translation Layer (FTL) is an appealing location to integrate compression due to its already sophisticated data management <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b38">37]</ref>. A Flash Translation Layer (FTL) is responsible for the mapping of Logical Block Address (LBA) to physical block locations. One can thus extend existing mapping structures and garbage collection to perform the block management required by compression. While compression integrated solely at an FTL or within a flash device can be ideal for flash, the benefits of application level compression that come from better understanding of application patterns can be lost.</p><p>In this paper we explore NVM Compression, a flash aware high speed compression technique. NVM Compression employs a hybrid design that allows applications to retain control of compression techniques while integrating FTL exported primitives to gain the benefits that can come from flash awareness. We explore this hybrid design in the context of the MySQL open source relational database. The legacy MySQL compression was designed for spinning media. When applied to flash, several issues emerge which have resulted in poor performance and limited adoption of MySQL compression across the broad MySQL deployment base. We seek to improve MySQL's compressed performance on flash with NVM Compression.</p><p>The paper makes the following contributions:</p><p>• We describe the design and implementation of a novel compression mechanism that combines the advantages of application level awareness and FTL integration.</p><p>• We describe ways to integrate such an approach into an operating system stack through a combination of new interface primitives and file system support.</p><p>• We include a detailed performance study showing that this approach can improve compression performance by 2-3x, deliver compression performance for flash devices that is within 5% of uncompressed performance (and sometimes exceed uncompressed performance due to less data writes),improve storage efficiency by 19% compared to legacy Row compression method, reduce data writes by upto 4x when combined with other flash aware techniques such as Atomic Writes, and deliver further advantages in power efficiency and CPU utilization.</p><p>The rest of the paper is organized as follows. In Section 2 we describe Background and Related Work. Section 3 outlines the existing compression design in MySQL and our high level approach. Section 4 describes NVM Compression in detail. Section 5 contains a performance evaluation. Section 6 discusses the results and future work. Section 7 provides a brief summary. Section 8 concludes with acknowledgments for the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head><p>Compression has been widely studied and implemented in storage systems, memory systems and many forms of applications <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b17">17,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b18">18,</ref><ref type="bibr" target="#b41">40]</ref>. In this section we focus on two areas of background, compression implementations leveraging Flash Translation Layers, and the existing default compression implementation in MySQL, our target for our hybrid NVM Compression work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">FTL Integrated Compression</head><p>Some flash devices implement compression internally <ref type="bibr" target="#b4">[5]</ref> and a number of studies have demonstrated how compression can be integrated into the FTL <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b38">37]</ref>. These studies show that the indirection maps inside the FTL can be a convenient place to add the block management required for compression. They also show that that data compression can reduce data writes and improve write amplification. However, choosing an appropriate compression block size can be difficult since the application knowledge is not accessible at the device level and all types of blocks look identical. Larger block sizes generate more efficient compression but can cause excessive reads or add garbage collection cost if the application access size turns out to be smaller than the compression block size chosen by the FTL. Internal fragmentation can also be a problem if the application I/O pattern does not match the assumptions made by the FTL when mapping compressed blocks into flash pages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">MySQL ROW-Compression</head><p>In contrast to FTL based compression, application level compression presents a different set of benefits and challenges.</p><p>We explore these through a detailed description of MySQL's existing compression mechanism, RowCompression.   <ref type="figure" target="#fig_1">Figure 1</ref>, Row Compression compresses data rows by replacing repeated patterns across the rows with shorter symbols. Uncompressed 16KB pages are stored in memory in the buffer pool while compressed pages are stored in both memory and on media. Each of the compressed blocks contains compressed data and a Modifylog-region where further block changes (inserts and updates) are logged. The size of the compressed block is set by an admin command and is fixed at database table-create time. As the table content changes, deltas are appended to the mlog until it runs out of space, at which point the compressed data is de-compressed, the mlog entries applied, and the resulting data-block is re-compressed.</p><p>The re-compression operation opens up the possibility of an Compression Insert Failure, where the newly compressed block is too big to fit in the predefined fixed compressed block size. This failure leads to a node (page) split where attempts are made to fit this block into an alternate location in the block map. This can lead to a need to rebalance the block map. <ref type="figure" target="#fig_2">Figure 2</ref> shows the steps involved to handle a compression insert failure. First, an adjacent page needs to be read and decompressed. Entries are then inserted into these pages and the allocation maps are rebalanced until all the data is successfully inserted.</p><p>Depending on the workload and the frequency of insert failures, performance may suffer since insert failures consume CPU cycles and add other data management overhead. This complexity leads to much of the performance issues seen today in MySQL Row-Compression deployments. Substantial work has been done in the last several years to attempt to solve this problem <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b27">27]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">NVM COMPRESSION: APPROACH</head><p>The goals of our compression solution, NVM Compression, are to deliver high speed and high efficiency flash compression that combines the benefits of application level data knowledge and the FTL's awareness and operation of flash management. Application level solutions benefit from knowing the meaningful units of data access. In the case of MySQL, this is a database block. FTLs benefit from the inherent presence of an indirection map that translates log- ical addresses to physical addresses, and the existing high performance garbage collection that coalesces available free space. To combine these benefits, we create an architecture where the compression is performed at the application level while the free space and the compressed data block are managed at the FTL level. <ref type="figure">Figure 3</ref> shows the high level approach. The database operates on a virtual storage space which is always the size of the uncompressed data. Data is compressed at the natural application unit -i.e. a database block. As data is compressed, it is written back in place at the same virtual address, leaving a "hole", i.e. an empty location, in the remainder of the space allocated for the fully uncompressed block. For example, if a 16KB database block was expected to be stored at storage address A, and after compression becomes 3.5KB, 3.5KB of data will be stored at address A, and the remaining 12.5KB of allocated virtual space will contain a hole and be empty.</p><p>NVM compression model relies upon the FTL to perform thin provisioning, i.e. allocate physical capacity only to the populated virtual addresses. The virtual address "holes" are unpopulated, i.e. no physical media blocks are mapped to the unpopulated virtual address space. This is done by exporting a "Sparse Address Space" from the FTL similar to that used in <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b37">36,</ref><ref type="bibr" target="#b22">22,</ref><ref type="bibr" target="#b33">33]</ref>. Under this model, the FTL will have populated virtual addresses and some empty virtual addresses. FTL garbage collection will naturally coalesce the populated addresses, thus allow for re-provisioning of the available physical space to be used for new writes.</p><p>As database records are overwritten, the size of compressed data content can change. In particular, blocks may compress to smaller sizes than they did previously. Since, in the NVM Compression design, re-compressed blocks are always rewritten to the same virtual locations, it becomes necessary to "punch a hole" in the address space, i.e. create a hole in the virtual address space where previously there may have been data. In our above example, if, after record updates, the database block which was previously 3.5KB (7 512B sectors) now compresses to 2.5KB (5 512B sectors), the operations will be as follows. First the updated content will be written to addresses A through A+4, reflecting the new 2.5KB or 5 sectors of data. Second, a hole will be punched at address A+5 to A+6, reflecting the fact that those virtual addresses no longer contain valid data. Once this is done, the FTL can then garbage collect the 1KB of data previously stored to those locations.</p><p>To benefit from the FTL thin provisioning as discussed above, we need a way to expose that capability to layer above, in this case, a user space application:</p><p>• We expose native characteristics of flash translation layers through a series of primitives that are exported by the FTL. This is similar in approach to other flash specific optimizations for KV stores, File Systems and Caches as described in <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b37">36,</ref><ref type="bibr" target="#b22">22]</ref>.</p><p>• We modify the MySQL database to utilize these flash primitives to create a new compression design.</p><p>• In order to allow the database to operate on regular files (as is the norm for nearly all MySQL deployments), we modify a file system to effectively export the primitives from the flash translation layer to the user space application.</p><p>• To ease the integration process, we also map these primitives to existing Linux system calls.</p><p>Specifically, NVM Compression uses three FTL exposed primitives: a Sparse address space, Persistent TRIMs, and Atomic writes. These flash characteristics are then exported by the NVMFS file system (Non-Volatile Memory File System) <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b34">34]</ref>, a POSIX compliant file system that is developed specifically to efficiently access flash and export native flash control to user space applications. NVMFS is an extension of the work done in <ref type="bibr" target="#b19">[19]</ref>. MySQL is then modified to support a new compression mode, NVM compression, which uses the primitives on files stored in the NVMFS file system. builds upon this work which is described in more detail in <ref type="bibr" target="#b24">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">NVM COMPRESSION: DESIGN</head><p>As described in the previous section, NVM Compression design has three elements:</p><p>• The primitives exported by the FTL that enable access to its thin-provisioning.</p><p>• Export primitives through NVMFS file system.</p><p>• Use of the primitives in an application level compression engine. <ref type="figure" target="#fig_3">Figure 4</ref> shows the layered architecture. The FTL exports a sparse address space for thin provisioning. The NVMFS file system then offers sparse files to the user space application, in addition FTL primitives are plumbed to user space through system calls (existing Linux system calls). The MySQL storage engine then implements compression using these capabilities. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">FTL Primitives</head><p>The primitives exported by the FTL enable upstream software to use its indirection maps and garbage collection for variable length data management. The exported capabilities, summarized in table 1, are the sparse address space and the commands to allocate and delete contents of virtual addresses. We also leverage previous work in Atomic Writes to further improve efficiency and performance.</p><p>The sparse address space exported by the FTL works as follows. While SSDs normally expose a block device of the same size as the SSD capacity, a sparse address space allows the user to store data at a much larger range of addresses than the physical capacity allows. In our specific implementation, the FTL exposes an address space of 2PB over a physical space of single digit TB. Data is inserted at specified address by using a conventional WRITE() operation and deleted using a persistent trim operation PTRIM().</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Primitive Detail Sparse</head><p>Sparse address space allows consuming applications to offload data allocation management to the FTL. PTRIM Persistent TRIMs enable guaranteed deletes of a data block at a given virtual address. Atomics</p><p>Atomic-write guarantees transactional writes, removing the need for applications to double buffer writes to ensure atomicity.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">File System Export of Primitives</head><p>The above mentioned primitives are exported by the FTL as low level block device IOCTLs. The NVMFS file system reexports the functionality as file level interfaces as described in <ref type="table" target="#tab_1">Table 2</ref>. NVMFS <ref type="bibr" target="#b19">[19]</ref> is a POSIX compliant file system that relies upon the same primitives described in <ref type="table" target="#tab_0">Table 1</ref>. In this paper we only focus on the elements of NVMFS that support NVM Compression. Other design details of NVMFS can be found here <ref type="bibr" target="#b34">[34]</ref>.</p><p>The sparseness required for NVM Compression is provided through sparse files in NVMFS. The files are pre-allocated to be the size required for uncompressed data. As data is compressed during database operation, holes are created within the file through the fallocate(PUNCH HOLE) operation.</p><p>Its important to note that the NVM Compression design does not specifically require NVMFS and also work on other file systems such as EXT4 and XFS. However, NVMFS is able to process operations like Persistent TRIM very efficiently since its design is also based on the FTL sparse address space (see <ref type="figure" target="#fig_4">Figure 5)</ref>. NVMFS offloads the complexity of remapping and translation to the FTL, leveraging the capabilities of the underlying flash device. This architecture implies NVMFS does not need any additional data operations to optimize file system layouts for sparse files.</p><p>NVMFS exports the Persistent TRIM capability through the fallocate(PUNCH HOLE) Linux system call operation. This operation is converted by NVMFS into a PTRIM primitive to the underlying FTL. Atomic Writes are exported as conventional writes which are configured to be atomic by default when issued to specific files. Such writes issued by the application are passed by NVMFS directly into the FTL as atomic operations. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">MySQL NVM Compression Design</head><p>The final component of NVM Compression is within the InnoDB/XtraDB storage engine. Unlike Row Compression where deltas are applied within the page in an Mlog, in NVM Compression mode, InnoDB compresses the page as a whole and stores it on media in a new page format. Much like the uncompressed format, the NVM Compression format includes checksums, page numbers, log sequence numbers etc. A new field is defined to indicate the page is "page compressed" and to indicate which compression algorithm is used (we have implemented LZ4 and LZ0 in addition to the LZ77 originally used by Row Compression) <ref type="bibr" target="#b39">[38,</ref><ref type="bibr" target="#b40">39]</ref>.</p><p>The compressed page is stored with the resulting size in the virtual address allocated to the uncompressed block and a PTRIM operation is issued for the remainder of the address range (using fallocate(PUNCH HOLE)) to inform NVMFS and the FTL that the remainder of the virtual addresses are now empty.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">TRIM operation</head><p>As data becomes compressed and holes are generated in virtual space, PTRIM operations are issued to the flash device through NVMFS using the fallocate(PUNCH HOLE) operation. This is done in the asynchronous I/O callback handler for the database block write. We study this aspect of NVM Compression performance further in the Evaluation in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">MT-Flush operation</head><p>The MySQL storage engines cache database blocks in an in-memory buffer pool. The buffer-pool hosts parts of the on-flash table-spaces and the system-space and is key to the performance of query and update requests. Buffer pool pages are flushed asynchronously using POSIX AIO, with various flush selection policies in effect including LRU and percentile dirty policies.</p><p>NVM page compression is designed to enable compression only at point of dirty page flush. Since compression can add to the latency of an individual block flush, the Multiple Threaded Flush (MT-Flush) framework was added to improve page flushing performance. The framework considers the number of available CPU cores and splits the buffer pool across a series or worker threads to optimally perform flush operation in parallel (and consequent data compres-  <ref type="figure" target="#fig_5">Figure 6</ref> depicts the producer consumer framework used to perform parallel compress and flush operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Double Write Buffer</head><p>Finally, using NVMFS exported atomic writes, MySQL InnoDB flushes dirty data only once to media in an atomic operation eliminating usage of the double write buffer. Atomic writes in MySQL is covered in detail here <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EVALUATION</head><p>In this section we evaluate NVM Compression across various metrics ranging from performance to energy efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">System level Benchmarks</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">LinkBench</head><p>LinkBench <ref type="bibr" target="#b6">[7]</ref> is a database benchmark developed to emulate the workload of Facebook's production MySQL deployment. Linkbench conducts a range of operations to add, modify, delete, retrieve and perform other operations on graph nodes. The default LinkBench dataset (referred to as a 1x workload) comprises 10 million node ids with a dataset size of 10GB on media. A dataset with 100 million nodes is referred to as a 10x workload. Since the 10x workload allows only a partial amount of the data to fit in the buffer pool, it is a more realistic test of the I/O subsystem. The Linkbench experiments were conducted on dual socket server with 12 physical 3.4GHz cores (24 with HT-enabled) and 128GB RAM, running RHEL 6.4 kernel 2.6.32. The flash device used is a SanDisk ioDrive.   for some operations (Update Node, Deleted Node and Get Node).</p><p>The above results confirm that the hybrid NVM Compression approach can deliver benefits by removing some of the complexities inherent in the Row Compression scheme. However, NVM Compression is also able to keep up with, and occasionally outperform, the Uncompressed configuration. To better understand this, we measured the write behavior of all three configurations. <ref type="figure" target="#fig_1">Figure 10</ref> highlights the data written per linkbench operation measured across 30 second intervals during a six hour run. NVM Compression writes far less data than uncompressed, which leads to better performance in the flash device over time since less garbage collection has to occur. We also found, that although RowCompression stores less total data than Uncompressed, it also generates more data writes per unit of operation than Uncompressed or NVM Compression, which likely is a result of insert failures leading to node splits and allocation map rebalance 2 requiring additional writes thereby further contributes to its poor performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">OLTP Workload</head><p>Next we study compression performance for an On-Line Transaction Processing (OLTP) benchmark. This TPCClike workload involves a mix of five concurrent transaction types executed on-line or queued for deferred execution. The database is comprised of nine tables with a wide range of record and population sizes. Results are measured in terms of transactions per minute (tpmC). Tests were performed on a dual socket server with 16 2.4 GHz cores (32 with HTenabled) and 128GB RAM running RHEL 6.4 kernel 2.6.32. The flash device used is a SanDisk ioDrive. MariaDB was configured to use a 75GB buffer pool with 1000 warehouses. The test ran for 1 hour with measurements every 10s.</p><p>The results are as seen in <ref type="figure" target="#fig_1">Figure 11</ref>. We observed 86% improvement in new order transaction performance between Row compression and NVM compression. The difference between NVM Compression and Uncompressed was 12% for the relatively short run.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Storage Capacity Efficiency</head><p>Storage efficiency is extremely dependent on the data content. However we can make some general observations regarding NVM Compression storage efficiency as compared to Row Compression. <ref type="figure" target="#fig_1">Figure 12</ref> shows a sample of the storage efficiency of the two compression techniques when running the Linkbench 10x workload. In this case, NVM Compression generates 19% better storage efficiency. Since the compression algorithm used is the same in both cases (LZ77), and the starting database block size and block content is the same, the benefit comes from the design difference. Row Compression forces a compressed block size of 8KB for a 16KB database block, limiting the maximum possible storage efficiency to 2x. NVM Compression will allow block sizes as small as a single 512B sector. Given this, NVM Compression will always have storage efficiencies as good or better than Row Compression.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Power and CPU Efficiency</head><p>Recent reports <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b21">21]</ref> show the importance of lowering energy consumption and its role in managing Total Cost of Ownership (TCO) <ref type="bibr" target="#b8">[9]</ref>. Both direct power consumption and cooling costs contribute to TCO. For example <ref type="bibr" target="#b9">[10]</ref> argues for energy consumption proportional to work accomplished. Since NVM-Compression enables lower data volumes to be written to flash, there is an opportunity to reduce power consumption through both lower application writes to the flash device and lower garbage collection writes within the flash device.</p><p>SanDisk cards have internal statistics that capture the buswatts consumed and internal-temp of the card. Using these stats, we compute the temperature and power consumption for both NVM-Compressed and Uncompressed workloads. <ref type="figure" target="#fig_1">Figure 13</ref> shows the normalized data using z-score of the    <ref type="table" target="#tab_3">Table 3</ref> shows a brief summary of the power consumed when running the same Linkbench 10x workload for six hours. NVM-Compressed consistently outperforms UnCompressed by a small amount, 6% OP/sec. Meanwhile, the Uncompressed workload consumes slightly more power and dissipates slightly more heat, about 3-16%.</p><p>We also measured the CPU utilization of both runs, as a means of assessing the power efficiency of the rest of the system under each workload. The CPU utilization was similar on both workloads, with the uncompressed generating slightly higher CPU consumption. This is likely due to the trade-off between CPU consumption for compression computations vs. CPU consumption for additional write activity generated by the uncompressed workload.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">File System Impact</head><p>Due to lack of time we were unable to repeat the above experiments on file systems other than NVMFS. Howeverin order to understand the potential value of the NVMFS approach to exporting sparse and primitives, we performed some micro-benchmark experiments. The micro-benchmark evaluates the performance of different file systems when a workload like MySQL NVM compression is running on top of them. This workload comprises series of writes of size 16KB (default page size) follow by trim operation of smaller size.</p><p>We evaluate NVMFS, XFS, and EXT4 on a microbenchmark that simulates the I/O patterns of NVM Compression. The test fills the entire file with zeros and then spawns two threads with the first thread issuing a series of 16KB writes  <ref type="figure" target="#fig_1">Figure 14</ref> shows the total runtime of the benchmark.</p><p>We can see that NVMFS performance increases linearly proportional to the size of the trim operation. The other file systems perform poorly when trim size is 1KB because they do read modify writes for trims smaller than 4KB. The figure also shows the amount of reads generated to the flash device. XFS and EXT4 perform some read operations due to read modify trims while NVMFS does not show any reads at all. The graph with the amount of writes to the physical device, we can see the fact NVMFS issues less amount of writes for the same number of TRIM operations. This data suggests that NVMFS performs TRIMs more efficiently than EXT4 and XFS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">DISCUSSION</head><p>The measurement results show that NVM Compression can substantially outperform Row Compression and in many cases deliver performance similar to that of Uncompressed. NVM Compression also opens up a number of other optimization opportunities which we have yet to explore.</p><p>First, the only aspect of application awareness which is leveraged in NVM Compression is knowledge of the application block size. The MySQL implementation for the NVM Compression is a thin layer at the very bottom of the database storage engine with the rest of the database being largely agnostic. While the paper focused on the InnoDB implementation, all three primary forms of MySQL (SkySQL, Oracle and Percona) have now integrated NVM Compression into their respective distributions <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b3">4]</ref>, demonstrating that the technique is extensible beyond InnoDB. We believe that the technique should be extensible to other apps beyond MySQL since most applications have a well defined notion of storage block size and block format. It may also be possible to integrate a single NVM Compression capability into the I/O stack with appropriate hints from applications.</p><p>Another interesting and encouraging observation is that the FTL Primitives leveraged for NVM Compression have also been used to optimize KV stores, file systems and caches for flash <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b31">31,</ref><ref type="bibr" target="#b37">36,</ref><ref type="bibr" target="#b22">22]</ref>. These primitives are also included in a number of pending standards proposals <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b32">32]</ref> here. The related work also covers details on different ways to implement such primitives within an FTL and demonstrates that costs within the FTL are far less than the overall benefits achieved.</p><p>Our approach involved using FTL primitives which were reexported to the user space application by the file system through existing Linux system calls. This simplified application development, but also opens up several possibilities. Other file systems can support the existing NVM Compression code in MySQL simply by offering suitably efficient implementations of these system calls.</p><p>In fact, a file system only implementation, where the FTL offers no primitives, is also possible. The MySQL portion of NVM Compression will also function on devices that do not provide all of the primitives, albeit at reduced efficiency and at some performance cost. Since compression generates variable block sizes, the block management has to be performed at one of the three layers. The MySQL component of NVM Compression can also function above sparse files offered by file systems that do their own block management. This alternative is less efficient since the file system would then perform redundant work above the FTL. By using NVMFS which itself relies upon the FTL for block management, we optimize each layer for best combined efficiency.</p><p>Finally, the decoupling of compression from capacity management suggests that different compression algorithms can be intermixed within the same database with relative ease since the same generic FTL garbage collection techniques would manage the capacity. We believe this is a fruitful area for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">SUMMARY</head><p>NVM-Compression is designed to combine the best of application level compression and flash aware integration. The compression itself is performed at application level, enabling application workload intelligence, like ideal block size, to be used. The block management and high speed garbage collection of flash are leveraged through FTL primitives. File system support ensures that standard database deployment practices, such as placing tables in files, are preserved. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENTS</head><p>We thank the anonymous reviewers for the valuable feedback and comments, which has helped guide and improve the content and presentation of this paper. We also thank the members of the Advanced Development Group at SanDisk Corp. for their insightful comments.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>MySQL is a very popular open source database. It pro- vides rich set of RDBMS features and supports various dif- ferent storage-engine options. InnoDB and XtraDB are the two most popular storage engines used by the MySQL com- munity today. MySQL data records are stored in one or more files in preconfigured page size units with the default</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Traditional MySQL row-compression</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Row Compression: Insert Failures</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: NVM Compression Design</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Non-Volatile Memory File System (NVMFS)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: MT-Flush Framework</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 shows</head><label>7</label><figDesc>Figure 7 shows the throughput for the Linkbench 10x workload with NVM Compression compared to both Row Compression and Uncompressed. The results show a 2.25x improvement using NVM Compression compared to the default Row Compression. We can also see that the throughput of NVM Compression is within 5% of the throughput of Uncompressed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 and</head><label>8</label><figDesc>Figure 8 and 9 shows the average and 99th percentile latencies for each Linkbench operation type when run with a 10x workload. The average latencies of NVM Compression are generally comparable to those of Uncompressed. Row Compression throughput is much lower compared to NVM Compression and Uncompressed. The 99th percentile latencies for NVM Compression are 2.5x to 5.5x lower than that for the default Row Compression. The NVM Compression latencies are also close to that of the Uncompressed workload, with lower latencies than the Uncompressed workload</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Linkbench 10x Throughput</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: 99 th percentile Latencies (10x Workload)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: TPCc-like 1000 warehouses</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Normalized Temperature</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: File System Impact</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><head>Table 1 : NVM Primitives</head><label>1</label><figDesc></figDesc><table>System Call Inter-
faces 

Functionality 

fallocate(offset, len) 
Pre-allocation and extend-
ing files/table space. 
fallocate(PUNCH HOLE) 
Unmap/Punch hole op-
eration (issue persistent 
TRIMs). 
io submit() 
AIO Transparent atomic 
writes. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 2 : System Call Interfaces</head><label>2</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Power Consumption 

current temperature of the flash drives during the workload 
run. When NVM compression is used, the average temper-
ature is reduced up to 16% as compared to Uncompressed 
while the performance is nearly the same. 

</table></figure>

			<note place="foot">Prior work in MySQL had utilized a flash specific primitive, Atomic Writes, to remove double writes to database files and improve performance and endurance. NVM Compression</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<ptr target="http://www.percona.com/doc/percona-server/5.5/performance/innodb_doublewrite_path.html" />
		<title level="m">Configuration of the doublewrite buffer</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Mariadb 10.0 fusion-io</title>
		<ptr target="http://bazaar.launchpad.net/~maria-captains/maria/10.0-FusionIO" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Mysql with innodb page-io compression</title>
		<ptr target="http://labs.mysql.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Percona server with xtradb</title>
		<ptr target="http://code.launchpad.net/~gl-az/percona-server/5.6-pagecomp_mtflush" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<ptr target="http://www.lsi.com/company/technology/duraclass/pages/durawrite.aspx" />
		<title level="m">Sandforce: Durawrite data reduction</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Report to Congress on server and data center energy efficiency public law 109-431</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Agency</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<pubPlace>United States Environmental Protection Agency</pubPlace>
		</imprint>
	</monogr>
<note type="report_type">Tech. rep.</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Linkbench: A database benchmark based on the facebook social graph</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">G</forename><surname>Armstrong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ponnekanti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Borthakur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Callaghan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2013 ACM SIGMOD International Conference on Management of Data<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1185" to="1196" />
		</imprint>
	</monogr>
	<note>SIGMOD &apos;13, ACM</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">E2compr: Transparent file compression for linux</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ayers</surname></persName>
		</author>
		<ptr target="http://e2compr.sourceforge.net" />
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Price of Performance: An Economic Case for Chip Multiprocessing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Barroso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Queue</title>
		<imprint>
			<biblScope unit="page" from="48" to="53" />
			<date type="published" when="2005-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The case for energy-proportional computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Barroso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Hölzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="33" to="37" />
			<date type="published" when="2007-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">ZFS -The Last Word in File Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bonwick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moore</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">The effect of page size on innodb compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Callaghan</surname></persName>
		</author>
		<ptr target="https://www.facebook.com/note.php?note_id=10150348315455933" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Making innodb compression adaptive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Callaghan</surname></persName>
		</author>
		<ptr target="https://www.facebook.com/note.php?note_id=10150345355665933" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Sbc-4 spc-5 atomic writes and reads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">T</forename><surname>Committee</surname></persName>
		</author>
		<ptr target="http://www.t10.org/cgi-bin/ac.pl?t=d\&amp;f=14-043r4.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Compressing relations and indexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Goldstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Shaft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings., 14th International Conference on</title>
		<meeting>14th International Conference on</meeting>
		<imprint>
			<date type="published" when="1998-02" />
			<biblScope unit="page" from="370" to="379" />
		</imprint>
	</monogr>
	<note>Data Engineering</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Data compression and database performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Graefe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">D</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc</title>
		<meeting>null</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Acm/Ieee-Cs</forename><surname>Symp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">On Applied Computing</title>
		<imprint>
			<biblScope unit="page" from="22" to="27" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Data compression support in databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">R</forename><surname>Iyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Conference on Very Large Data Bases</title>
		<meeting>the 20th International Conference on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="695" to="704" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Performance measurements of compressed bitmap indices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Very Large Data Bases</title>
		<meeting>the 25th International Conference on Very Large Data Bases<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="278" to="289" />
		</imprint>
	</monogr>
	<note>VLDB &apos;99</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Dfs: A file system for virtualized flash storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">K</forename><surname>Josephson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Bongo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Flynn</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
		<idno>FAST &apos;10</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th USENIX Conference on File and Storage Technologies</title>
		<meeting>the 8th USENIX Conference on File and Storage Technologies</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Transparent online storage compression at the block-level</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Klonatos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Makatos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Marazakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Flouris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bilas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Storage</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">33</biblScope>
			<date type="published" when="2012-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Estimating total power consumption by servers in the U.S. and the world</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">G</forename><surname>Koomey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007-02" />
		</imprint>
		<respStmt>
			<orgName>Lawrence Derkley National Laboratory</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Tech. rep</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Nvmkv: A scalable and lightweight flash aware key-value store</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Marmol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sundararaman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Talagala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rangaswami</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Devendrappa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ramsundar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ganesan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th USENIX Workshop on Hot Topics in Storage and File Systems</title>
		<meeting><address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-06-14" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Getting innodb compression ready for facebook scale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Ordulu</surname></persName>
		</author>
		<ptr target="http://www.percona.com/live/mysql-conference-2012/sessions/getting-innodb-compression-ready-facebook-scale" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Beyond block i/o: Rethinking traditional storage primitives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Ouyang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">W</forename><surname>Nellans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wipfel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Flynn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">K</forename><surname>Panda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HPCA</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="301" to="311" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Power-efficient data compression support for nand flash-based consumer electronics devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Consumer Electronics</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1148" to="1156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Data compression in oracle</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Poess</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Potapov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Conference on Very Large Data Bases</title>
		<meeting>the 29th International Conference on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="937" to="947" />
		</imprint>
	</monogr>
	<note>VLDB &apos;03, VLDB Endowment</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Innodb compression improvements in mysql 5</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Rana</surname></persName>
		</author>
		<ptr target="https://blogs.oracle.com/mysqlinnodb/entry/innodb_compression_improvements_in_mysql" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Database compression: A performance enhancement tool</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Haritsa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Seshadri</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 7th Intl. Conf. on Management of Data (COMAD)</title>
		<meeting>of 7th Intl. Conf. on Management of Data (COMAD)</meeting>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Richard Russon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Fledel</surname></persName>
		</author>
		<imprint/>
	</monogr>
<note type="report_type">Ntfs documentation</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The linux b-tree filesystem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Rodeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bacik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mason</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Btrfs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Storage</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">32</biblScope>
			<date type="published" when="2013-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Flashtier: A lightweight, consistent and durable storage cache</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th ACM European Conference on Computer Systems</title>
		<meeting>the 7th ACM European Conference on Computer Systems<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="267" to="280" />
		</imprint>
	</monogr>
	<note>EuroSys &apos;12, ACM</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Nvm programming model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Snia</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename></persName>
		</author>
		<ptr target="http://snia.org/sites/default/files/NVMProgrammingModel_v1.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Snapshots in a flash with iosnap</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sundararaman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Talagala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arpaci-Dusseau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth European Conference on Computer Systems</title>
		<meeting>the Ninth European Conference on Computer Systems<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page">14</biblScope>
		</imprint>
	</monogr>
	<note>EuroSys &apos;14, ACM</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Native flash support for applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Talagala</surname></persName>
		</author>
		<ptr target="http://www.flashmemorysummit.com/English/Collaterals/Proceedings/2012/20120823_S304B_" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Talagala</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Woodhouse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Jffs</surname></persName>
		</author>
		<title level="m">The Journalling Flash File System</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Hec: Improving endurance of high performance flash-based cache devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Plasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gillis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Talagala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Systems and Storage Conference</title>
		<meeting>the 6th International Systems and Storage Conference<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">11</biblScope>
		</imprint>
	</monogr>
	<note>SYSTOR &apos;13, ACM</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A flash compression layer for smartmedia card systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename><surname>Yim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Bahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Transactions on Consumer Electronics</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2004" />
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">A universal algorithm for sequential data compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ziv</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lempel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TRANSACTIONS ON INFORMATION THEORY</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="337" to="343" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Compression of individual sequences via variable-rate coding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ziv</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lempel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Super-scalar ram-cpu cache compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zukowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Heman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Nes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Boncz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Engineering, 2006. ICDE &apos;06. Proceedings of the 22nd International Conference on</title>
		<imprint>
			<date type="published" when="2006-04" />
			<biblScope unit="page" from="59" to="59" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
