<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T01:55+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Exposing iClass Key Diversification</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Flavio</forename><forename type="middle">D</forename><surname>Garcia</surname></persName>
							<email>flaviog@cs.ru.nl</email>
							<affiliation key="aff0">
								<orgName type="department">Institute for Computing and Information Sciences</orgName>
								<orgName type="institution">Radboud University Nijmegen</orgName>
								<address>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gerhard</forename><surname>De</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute for Computing and Information Sciences</orgName>
								<orgName type="institution">Radboud University Nijmegen</orgName>
								<address>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koning</forename><surname>Gans</surname></persName>
							<email>gkoningg@cs.ru.nl</email>
							<affiliation key="aff0">
								<orgName type="department">Institute for Computing and Information Sciences</orgName>
								<orgName type="institution">Radboud University Nijmegen</orgName>
								<address>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roel</forename><surname>Verdult</surname></persName>
							<email>rverdult@cs.ru.nl</email>
							<affiliation key="aff0">
								<orgName type="department">Institute for Computing and Information Sciences</orgName>
								<orgName type="institution">Radboud University Nijmegen</orgName>
								<address>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Exposing iClass Key Diversification</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>iClass is one of the most widely used contactless smartcards on the market. It is used extensively in access control and payment systems all over the world. This paper studies the built-in key diversification algorithm of iClass. We reverse engineered this key diversification algorithm by inspecting the update card key messages sent by an iClass reader to the card. This algorithm uses a combination of single DES and a proprietary key fortification function called &apos;hash0&apos;. We show that the function hash0 is not one-way nor collision resistant. Moreover, we give the inverse function hash0 −1 that outputs a modest amount (on average 4) of candidate pre-images. Finally, we show that recovering an iClass master key is not harder than a chosen plaintext attack on single DES. Considering that there is only one master key in all iClass readers, this enables an attacker to clone cards and gain access to potentially any system using iClass.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Over the last few years, much attention has been paid to the (in)security of the cryptographic mechanisms used in contactless smartcards <ref type="bibr">[NESP08, GdKGM + 08, GvRVS09, COQ09, GvRVS10]</ref>.</p><p>This paper does not focus on the security of the cards themselves but on the security of the cryptographic protocols used in the embedding systems. Concretely, we study the key diversification and the proprietary 'key fortification' functions of the HID iClass contactless smartcards and the secure key loading mode of the Omnikey readers.</p><p>iClass is an ISO/IEC 15693 <ref type="bibr">[ISO09]</ref> compatible contactless smartcard manufactured by HID Global. It was introduced on the market back in 2002 as a secure replacement of the HID Prox card which had no cryptography at all. According to the manufacturer more than 300 million iClass cards have been sold. These cards are widely used in access control to secured buildings such as The Bank of America Merrill Lynch, the International Airport of Mexico City and the City of Los Angeles among many others <ref type="bibr">1</ref> . According to <ref type="bibr">1</ref> http://hidglobal.com/mediacenter.php?cat2=2</p><p>HID <ref type="bibr">[Cum06]</ref> iClass is also deployed at the United States Navy base of Pearl Harbor. Other applications include secure user authentication such as in the naviGO system included in Dell's Latitude and Precision laptops; e-payment such as in the FreedomPay and SmartCentric systems; and billing of electric vehicle charging such as in the Liberty PlugIns system.</p><p>HID Global is also the manufacturer of the popular Omnikey readers. The Omnikey 5321 reader family is a multiprotocol contactless reader which includes iClass compatibility. Starting from firmware version 5.00 these readers have the so-called 'Omnikey Secure Mode' which is required to update iClass card keys. This Secure Mode provides encryption of the USB traffic complying with ISO/IEC 24727 [ISO08] standard.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>Experience has shown that, once obscurity has been circumvented, proprietary algorithms often do not provide a satisfactory level of security. One of the most remarkable examples of that is the infamous case of the Mifare Classic [NESP08, GdKGM + 08, GvRVS09] used widely in access control and transport ticketing systems. Other examples include KeeLoq [IKD + 08] and Hitag2 <ref type="bibr">[SNC09]</ref>, which are widely used in wireless car keys and the A5/1 <ref type="bibr">[Gol97]</ref> and DECT <ref type="bibr">[LST + 09]</ref> ciphers used in cell and cordless phones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Our contribution</head><p>The contribution of this paper is manyfold. First it describes the reverse engineering of the built-in key diversification algorithm of iClass. This key diversification algorithm consists of two parts: a cipher that is used to encrypt the identity of the card; and a key fortification function, called hash0 in HID documentation, which is intended to add extra protection to the master key. Our approach for reverse engineering is in line with that of [GdKGM + 08, LST + 09, GvRVS10] and consists of analyzing the update card key messages sent by an iClass compatible reader while we produce small modifications on the diversified key, just before fortification. For this it was first necessary to bypass the encryption layer of the Omnikey Secure Mode. We reverse engineered the Omnikey Secure Mode and wrote a library that is capable of communicating in Omnikey Secure Mode to any Omnikey reader. To eavesdrop the contactless interface we have built a custom firmware for the Proxmark III in order to intercept ISO/IEC 15693 <ref type="bibr">[ISO09]</ref> frames. We have released the library, firmware and an implementation of hash0 under the GNU General Public License and they are available at the Proxmark website 2 .</p><p>Last but not least, we show that the key fortification function hash0 is actually not one-way nor collision resistant and therefore it adds little protection to the master key. Concretely, we give the inverse function hash0 −1 that on input a 64 bit bitstring it outputs a modest amount (on average 4) of candidate pre-images. We propose an attack that recovers a master key from an iClass reader of comparable complexity to that of breaking single DES, thus it can be accomplished within a few days on a RIVYERA 3 . This is extremely sensitive since there is only one master key for all iClass readers and from which all diversified card keys can be computed.</p><p>As an alternative, it is possible to emulate a predefined card identity and use a DES rainbow table <ref type="bibr">[Hel80]</ref> based on this identity to perform the attack. This allows an adversary to recover the master key within minutes.</p><p>During the course of this research, Meriac and Plötz presented a powerful procedure to read out the EEPROM of a PIC microcontroller, like the ones used in iClass readers, at the 27th meeting of the Chaos Communication Congress <ref type="bibr">[MP10, Mer10]</ref>. This attack is possible due to a misconfiguration of the memory access control bits of the PIC used in early reader models, for more details on this attack see the OpenPCD website <ref type="bibr">4</ref> . Their attack on the hardware is a viable alternative to retrieve the master key.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Omnikey Secure Mode</head><p>The Omnikey contactless smartcard reader has a range of key slots where it stores cryptographic keys. These keys are used to authenticate with an HID iClass card. After a valid authentication the reader gains read and write access to the memory in the card.</p><p>All recent Omnikey 5321 and 6321 contactless smartcard readers manufactured by HID Global support encrypted communication with the host, which is called Secure Mode. Applications compliant with ISO/IEC 24727 <ref type="bibr">[ISO08]</ref> must provide end-to-end encryption and therefore the USB communication between the application and reader needs to be encrypted.</p><p>To activate the Secure Mode, the host application uses a 3DES key K CUW to perform mutual authentication with the reader. According to the Omnikey developers guide <ref type="bibr">[WDS + 04]</ref> this key is only known by a limited group of developers under a non-disclosure agreement with HID Global.</p><p>The Omnikey Secure Mode must be active in order to perform security sensitive operations like changing the key of a card. In order to be able to eavesdrop and modify messages between the reader and a card during a key update, the Omnikey Secure Mode must be circumvented.</p><p>The two-factor authentication application naviGO from HID Global provides a login procedure for Windows computers using an iClass card and a PIN-code. A trial version of this software package is freely available online <ref type="bibr">5</ref> . NaviGO uses the Omnikey reader for the personalization phase where it authenticates, updates the key and writes credentials to an iClass card. To perform these actions naviGO needs to know the cryptographic key K CUW in order to use the Secure Mode. HID Global stores the secret key in an unprotected binary file. After extracting K CUW from the file iCLASSCardLib.dll we gained full control over the secured USB channel.</p><p>We have released a library called iClassified that makes it possible to send arbitrary commands to an Omnikey reader using the Omnikey reader in Secure Mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">iClass and PicoPass</head><p>The iClass card is basically a re-branded version of the PicoPass contactless smartcard which is manufactured by Inside Secure <ref type="bibr">6</ref> . The documentation of the PicoPass <ref type="bibr">[Con04]</ref> defines the configuration options, commands and memory structure of an iClass 2KS card. Before HID Global sells the PicoPass as an iClass card, they configure the memory, store their cryptographic keys and blow the fuse that allows any future changes to the configuration.  The iClass cards come in two versions 2KS and 16KS with respectively 256 and 4096 bytes of memory. The memory is divided into blocks of eight bytes as shown in <ref type="figure" target="#fig_0">Figure 1</ref>. Memory blocks 0, 1, 2 and 5 are publicly accessible, they contain the card serial number id, configuration bits, the card challenge c C and issuer information. Block 3 and 4 contain two diversified cryptographic keys which are derived from two different HID master keys. These master keys are referred to in the documentation as debit key kd and credit key kc. The card only stores the diversified keys kd id and kc id . The remaining blocks are divided into two areas so-called applications. The size of these applications is defined by the configuration block.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Block</head><p>The first application of an iClass card represents the HID application which stores the identifier, PIN code, password and other access control information. Read and write access to the HID application requires a valid mutual authentication using a proprietary algorithm that proves knowledge of kd id .</p><p>The second application is user defined and secured by a key kc id derived from kc. The default kc (but not kd) is stored in the same binary file that contains the secret key for the Omnikey Secure Mode. We use this key later on Section 4.1 during the reverse engineering process.</p><p>We use our iClassified library to eavesdrop the USB communication while the card key is updated. We observe that a default iClass master key is loaded into key slot 32 of the reader. This key is used to derive the card key which is used for authentication. Then, a new master key is loaded into slot 32 and the card key is updated with the new derived key. <ref type="figure" target="#fig_3">Figure 2</ref> shows the eavesdropped messages between the reader and a card during a sequence of card key update commands. The application first updates the default key kc of an genuine iClass card to random kc ′ and kc ′′ . Finally it sets the default key again. The trace shows that the key update message contains as payload the exclusive-or (XOR) of the old and new key as mentioned in <ref type="bibr">[MP10]</ref>. This can be verified computing</p><formula xml:id="formula_0">(kc ′ id ⊕ kc id ) ⊕ (kc ′′ id ⊕ kc ′ id ) = kc id ⊕ kc ′′ id .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Authentication and Key Fortification</head><p>This section describes the authentication protocol between an iClass card and reader. Furthermore, it gives an overview of the built-in key diversification algorithm.</p><p>The authentication protocol between an iClass card and a reader is depicted in <ref type="figure" target="#fig_1">Figure 3</ref>. First, the card sends its identity id and a card challenge c C . This c C is called 'epurse' <ref type="bibr">[Con04]</ref> and it is special in the sense that it is intended to provide freshness. Apparently, the card lacks a pseudo-random generator and therefore, after a successful authentication, the reader should update c C to a new value in order to provide freshness in the next authentication. Note that this is not enforced by the card. Next, the reader answers with a nonce n R of its choosing and an answer a R to the challenge of the card. This answer is presumable some sort of MAC depending on c C and n R . Finally, the card answers with a similar message a C to achieve mutual authentication.</p><p>iClass has a built-in key diversification algorithm. suggests that the reader encrypts the card identity (id) using single DES. Then it performs a fortification algorithm to obtain the diversified key. The following steps verify that the card identity is the only input to the DES algorithm:</p><p>• start with any 64 bit bitstring c, e.g., all zeros • choose a random key k and use DES to decrypt c. This results in a plaintext p • choose a different key k ′ and use DES to decrypt c.</p><p>This results in a plaintext p ′ • run a card key update with k with a reader that receives identity p from a card emulator. Repeat this using key k ′ and identity p ′ and verify that the derived key k p is equal to k ′ p ′ . Key fortification functions are non-injective functions (many-to-one) which, in contrast with hash functions, intentionally have many collisions <ref type="bibr">[AL94]</ref>. The idea behind it is that even if an adversary has access to many diversified keys, these do not univocally determine a master key. This comes, of course, at the cost of loosing entropy in the diversified key.</p><p>In practice, it means that even if you manage to invert the fortification function, you will get many candidate preimages which in turn you need to brute force to get to the master secret key. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Reverse Engineering Key Fortification</head><p>This section describes the reverse engineering of the key fortification function. The design of this function, called h0 [Cum03] or hash0 <ref type="bibr">[Cum06]</ref>, is not publicly available. Our primary goal is to learn the card key derivation which gives complete control over the card key. In order to reach this goal it is necessary to reverse engineer the fortification function.</p><p>As explained in Section 3.1 the input to the key diversification is a master secret key (e.g., kc or kd) and a card identity id. From this key, say kc, and id a ciphertext c = DES enc (id, kc) is computed. Finally, the actual diversified key kc id is computed hash0(c) = kc id .  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Origin</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Input-Output Relations</head><p>A good first step to recover hash0 is to analyze its inputoutput relations on bit level. This requires complete control over its input c which can be achieved in a test setup by the emulation of a card identity id knowing the master key kc.</p><p>The following steps deliver XOR differences between two hash0 evaluations that differ only one bit in the input:</p><p>• generate a large set of random bitstrings c i ∈ {0, 1} 64 .</p><p>• for each c i calculate id i = DES dec (c i , kc) and id</p><formula xml:id="formula_1">j i = DES dec (c i ⊕ 2 j , kc) for j ∈ {0, . . . , 63}.</formula><p>• for each c i execute 64 key updates as follows:</p><p>-authenticate with id i -perform a key update, the reader requests the card identity again, now use id j i instead of id i Keep the key kc constant during the key updates described above. This delivers the XOR of two function evaluations of the form hash0(c i ) ⊕ hash0(c i ⊕ 2 j ). We performed this procedure for 3000 values c i with j ∈ {0, . . . , 63}. The results are grouped by the position of the flipped bit. Then, the AND and OR is computed of all the results in a group. These cumulative AND and OR-masks for 64 bitflips in 3000 random bitstrings c i are presented in <ref type="figure">Figure 6</ref> and 9. <ref type="figure">Figure 6</ref> shows that the hash0 function handles the 48 rightmost bits in smaller 6-bit pieces. These 6-bit data chunks are defined as z 0 , . . . , z 7 . The two bytes on the left are defined x and y. Here x defines a permutation on the output and the individual bits of y define whether or not a complement operation is applied on one of the 6-bit output values. The eight output bytes are defined as k 0 , . . . , k 7 and constitute the diversified key kc id . Similarly, the input c to the hash0 function is constituted by c = x, y, z 0 , . . . , z 7 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Function Input Partitioning</head><p>For the ease of reading we write x <ref type="bibr">[b]</ref> to denote the b-th bit of variable x where x <ref type="bibr">[0]</ref> means the rightmost bit of x.</p><p>The structure of the masks in <ref type="figure">Figure 6</ref> and 9 are computed with x = y = 0 and z 0 , . . . , z 7 as random bitstrings. The masks lead to the following observations:</p><p>• z 0 , . . . , z 3 affects k 4 , . . . , k 7 .</p><p>• z 4 , . . . , z 7 affects k 0 , . . . , k 3 .</p><p>• z 0 , . . . , z 3 and z 4 , . . . , z 7 generate a similar structure in the output but are mutually independent. This suggests that there is a subfunction that is called twice, once with z 0 , . . . , z 3 and once with z 4 , . . . , z 7 . In the context of this paper we refer to this function as scramble.</p><p>• y <ref type="bibr">[i]</ref> affects k i for i ∈ {0, . . . , 7}. The OR-mask for y indicates a complement operation on the output while the AND-mask presumes an injective function that maps y <ref type="bibr">[i]</ref> to k i <ref type="bibr">[7]</ref> .</p><p>• x creates a permutation. The output is scrambled after flipping a single bit within x. The AND-mask shows that k i <ref type="bibr">[0]</ref> is exclusively affected by x for i ∈ {0, . . . , 7}.</p><p>• flipping bits in z 0 , . . . , z 7 does never affect the left-or rightmost bits of k 0 , . . . , k 7 . This is inferred from the occurrences of the 0x7e value in the OR-mask which is 01111110 in binary.  The above observations suggest that the problem of function recovery can be split into parts. <ref type="figure" target="#fig_4">Figure 5</ref> summarizes how different parts of the input affect specific parts of the output when x is kept zero. Note that the last observation shows that the subfunction scramble operates on four 6-bit input values and computes four 6-bit output values. These output values constitute the middle 6 bits of output bytes k i , see <ref type="figure" target="#fig_4">Figure 5</ref>. Furthermore, it is observed that the ordering of the 6-bit output values and the leftmost bit of the output bytes are determined by x. Each bit of y is simply copied into the rightmost bit of each output byte.</p><p>Summarizing, the hash0 function can be split into three different parts. The first part is the subfunction scramble which is called twice, once with input z 0 , . . . , z 3 and once with input z 4 , . . . , z 7 . The second part computes a bitwise complement operation based on the complement byte y and the last part applies a permutation that is defined by the permute byte x. The following sections discuss these different parts of the hash0 function. Finally, Section 4.6 defines the complete function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>bit</head><p>OR-mask AND-mask </p><formula xml:id="formula_2">⊕ → k 0 k 1 k 2 k 3 k 4 k 5 k 6 k 7 k 0 k 1 k 2 k 3 k 4 k 5 k 6 k 7 z 7                    0<label>7e7e7e7e00000000</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="47">000000000000007e 0000000000000000</head><p>Figure 6: OR and AND-mask for bitflip 0-47</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Subfunction scramble</head><p>This section describes the reverse engineering of the subfunction scramble which operates on four 6-bit input values z 0 , . . . , z 3 . In order to recover this part of the function we keep x = y = 0 while z 0 , . . . , z 7 are randomly chosen. For the scramble subfunction only bitflips at positions 0 to 47 matter (see <ref type="figure">Figure 6</ref>). It makes sense to start with the recovery of either k 0 or k 4 as they both depend on a single input z i . Notice that k 4 is just z 3 shifted one bit to the left since we keep x = y = 0. However, k 0 seems less predictable. The XOR between two outputs k i ⊕ k ′ i of two function calls is defined as k ⊕ i . Furthermore, be aware that the subfunction scramble only affects bits k i <ref type="bibr">[1]</ref> , . . . , k i <ref type="bibr">[6]</ref> (See <ref type="figure" target="#fig_4">Fig 5)</ref>. To put it differently, the output is always shifted one bit to the left and therefore this shift can be omitted from the analysis.</p><p>In order to find a relation between input values z 7 and output values k ⊕ 0 a selection of all observed values k ⊕ 0 is made. <ref type="figure" target="#fig_5">Figure 7</ref> shows a relation between z 7 and k ⊕ 0 and shows which bits of z 7 are fixed for a certain output value k ⊕ 0 . Bits that do not matter are marked with a dot and the bitflip is marked f. The two inputs are z 7 where f = 0 and z ′ 7 where f = 1.  = (z 7 mod 63) + 1 ⊕ (z ′ 7 mod 63) + 1 which gives confidence that k 0[1..6] = (z 7 mod 63) + 1. The next step is to find k 1 <ref type="bibr">[1..6]</ref> which is dependent on two input input values, namely z 6 and z 7 . Again, an overview of all input-output relations <ref type="figure" target="#fig_8">(Figure 8</ref>) is constructed. The first part where k ⊕ 1 ∈ {02, 0c, 52, 6c, . . .} is the result of flipping z <ref type="bibr">6[0]</ref> and the second part where k ⊕ 1 ∈ {0c, 1c, 3c, . . . , 4e, 64, . . .} is the result of flipping z 6 <ref type="bibr">[1]</ref> .</p><formula xml:id="formula_3">z 7 /z ′ 7 k ⊕ 0 z 7 /z ′ 7 k ⊕ 0 ....</formula><p>The observations for flipping z <ref type="bibr">6[0]</ref> and z 6 <ref type="bibr">[1]</ref> show that in 97 % of the cases input z 6 and z 7 are independent. 3 % of the bitflips in z 6 make z 6 + 1 equal to z 7 or destroy this equality instead. </p><formula xml:id="formula_4">% z 6 /z ′ 6 z 7 k ⊕ 1 0.97 .....f ...... 02                bitflip z 6[0] 0.03           <label>00010f</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0.97</head><formula xml:id="formula_5">               ....f. ...... 0c                                          bitflip z 6[1]</formula><p>.   When z 6 <ref type="bibr">[1]</ref> is flipped more output variations in k ⊕ 1 are observed. Example for k ⊕ 1 = 0x3c:</p><formula xml:id="formula_6">               0010f0 001001 1a</formula><formula xml:id="formula_7">z 6 = 001101, z 6 + 2 = .001111. z ′ 6 = 001111, z ′ 6 + 2 = .010001. ⊕ 00111100 = 0x3c</formula><p>The result k ⊕ 1 = 78 comes from a modulo operation. Here input z 6 is taken modulo 62, which is 111110 in binary. Example for k ⊕ 1 = 0x78:</p><formula xml:id="formula_8">z 6 = 111100, (z 6 mod 62) + 2 = .111110. z ′ 6 = 111110, (z ′ 6 mod 62) + 2 = .000010. ⊕ 01111000 = 0x78</formula><p>Then, 3 % of the output variations invoked by bitflips in z 6 <ref type="bibr">[1]</ref> describe a relation z 6 + 1 = z 7 . The corresponding k ⊕ 1 is obtained by taking k 1[1..6] = 1 when the relation holds and k 1[1..6] = (z 6 mod 62) + 2 when it does not hold. Example for k ⊕ 1 = 0x4e:</p><formula xml:id="formula_9">z 6 = 100100, (z 6 mod 62) + 2 = .100110. z ′ 6 = 100110, ((z ′ 6 mod 62) + 1 = n 7 ) = .000001. ⊕ 01001110 = 0x4e</formula><p>Eventually, the function for k 1 <ref type="bibr">[1..6]</ref> is:</p><formula xml:id="formula_10">k 1[1..6] = 1, (z 6 mod 62) + 1 = (z 7 mod 63);</formula><p>(z 6 mod 62) + 2, otherwise.</p><p>The remaining k 2[1.</p><p>.6] and k 3[1.</p><p>.6] can be found in a similar way by flipping bits in the input and closely looking at the input-output relations. Also, it helps to look for related modulo operations on z 5 and z 4 . We give k 2[1..6] to give some idea of the evolving structure of the function: After the recovery of the first block z 4 , . . . , z 7 it is relatively easy to find the subfunction for z 0 , . . . , z 3 . The modulos and additions differ but the structure of the function is completely the same. For this reason it is possible to write it as a subfunction scramble that is called twice, once for z 0 , . . . , z 3 and once for z 4 , . . . , z 7 . The final subfunction scramble is given by Definition 4.1.</p><formula xml:id="formula_11">k 2[1..6] =                      2,<label>(</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Complement Byte</head><p>The complement byte y performs a complement operation on the output of the function. <ref type="figure">Figure 9</ref> shows that flipping a bit y <ref type="bibr">[i]</ref> means that bit k i <ref type="bibr">[7]</ref> is flipped for i ∈ {0, . . . , 7}. Notice that no other input bit influences any k i <ref type="bibr">[7]</ref> . Furthermore, k i <ref type="bibr">[1]</ref> , . . . , k i <ref type="bibr">[6]</ref> are flipped but be aware that these bits might come from any other z j due to the permute byte x. Finally, every k i <ref type="bibr">[0]</ref> is not affected. It is important to observe that for k 4 , . . . , k 7 the OR and AND-mask agree that the left 7 bits are always flipped while for k 0 , . . . , k 3 this is not true. To be precise, the bits k 0 <ref type="bibr">[1]</ref> , k 1 <ref type="bibr">[1]</ref> , k 2 <ref type="bibr">[1]</ref> and k 3 <ref type="bibr">[1]</ref> are never flipped. This is because the 6-bit output value z j that constitutes output byte k i is decremented by one if j ≤ 3 except when bit OR-mask AND-mask <ref type="table">fc00000000000000  8000000000000000  49  00fc000000000000  0080000000000000  50  0000fc0000000000  0000800000000000  51  000000fc00000000  0000008000000000  52  00000000fe000000  00000000fe000000  53  0000000000fe0000  0000000000fe0000  54  000000000000fe00  000000000000fe00  55</ref> 00000000000000fe 00000000000000fe  </p><formula xml:id="formula_12">⊕ → k 0 k 1 k 2 k 3 k 4 k 5 k 6 k 7 k 0 k 1 k 2 k 3 k 4 k 5 k 6 k 7 y                              48</formula><formula xml:id="formula_13">x                            </formula><formula xml:id="formula_14">z j = 101101, where j ≤ 3 y 0 = 0, k 0 = y 0 · z j · t = 0101101t y ′ 0 = 1, k ′ 0 = y ′ 0 · z j − 1 · t = 1010011t ⊕ 11111100 = 0xfc</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Permute Byte</head><p>Finally, byte x applies a permutation. Iterating over x while keeping y and z 0 , . . . , z 7 constant shows that x is taken modulo 70 since the same output is repeated again for every 70 consecutive inputs. The cumulative bitmasks of the output differences, shown in <ref type="figure">Figure 9</ref>, do not give direct information about this permutation but do make clear that k i <ref type="bibr">[0]</ref> is affected. Experiments show that x is an injective mapping on k i <ref type="bibr">[0]</ref> for i = 0, . . . , 7. This means that it is possible to learn x from k i <ref type="bibr">[0]</ref> . Furthermore, the permutation is independent of y and z i . This means that a table of mappings can be constructed which takes x as index and has particular mappings as its entries. The mappings are presented in <ref type="figure" target="#fig_0">Figure 10</ref>. To illustrate, π 0 = 01234567 means that there is no mixing at all and π 2 = 01342567 means that k 0 stays at position 0 while k 4 is moved to position 2. To isolate one particular mapping we write π x (i) which returns the target position of 6-bit output valuê z i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Key recovery attack</head><p>From the weaknesses that were explained in the previous section it can be concluded that hash0 does not significantly increase the complexity of an attack on the master key kc. In fact, the attack explained in this section requires one brute force run on DES. For this key recovery attack an attacker needs to control a reader and be able to issue key update commands. This is the case, for example, in the Omnikey Secure Mode. The attack consists of two phases:</p><p>Phase 1</p><p>• emulate a random identity id to the reader • issue an update key command that updates from a known user defined key kc ′ to the unknown master key kc. Now, id kc = hash0(DES enc (id, kc)) can be obtained from the XOR difference.</p><p>• compute the pre-images c i of id kc .</p><p>• repeat Phase 1 until an output id kc is obtained which has three pre-images.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Phase 2</head><p>• for every candidate key kt ∈ {0, 1} 56 check if DES enc (id, kt) = c i for i ∈ {0, 1, 2} • when the check above succeeds the corresponding key kt needs to be verified against another set of id and kc id .</p><p>We verified this attack on the two master keys kc and kd that are stored in the Omnikey reader for the iClass application. The first key kc was also stored in the naviGO software and we could check the key against pre-images that were selected as described above. Although we did not find kd stored in software we were still able to verify it since we could dump the EEPROM of a reader where kd was stored. The attack above comes down to a brute force attack on single DES. A slightly different variant is to keep the card identity id fixed and use a DES rainbow table <ref type="bibr">[Hel80]</ref> that is constructed for a specific plaintext and runs through all possible encryptions of this plaintext. Note that the rainbow table needs to be pre-computed and thus a fixed plaintext is chosen on forehand. This means that one fixed predefined id is to be used in the attack. The number of pre-images can no longer be controlled. In the worst case the number of pre-images is 512.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>In this paper we have shown that obscurity does not provide extra security and it can be circumvented. In fact, experience shows that instead of adding extra security it often covers for negligent designs.</p><p>It is hard to imagine why HID decided, back in 2002, to use single DES for key diversification considering that DES was already broken in practice in 1997 <ref type="bibr">[Fou98]</ref>. Especially when most (if not all) HID readers are capable of computing 3DES. Another unfortunate choice was to design their proprietary hash0 function instead of using an openly designed and community reviewed hash function like SHA-1. From a cryptographic perspective, their proprietary function hash0 fails to achieve any desirable security goal.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Memory layout of an iClass card</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Authentication protocol</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Extracted from the PicoPass datasheet [Con04]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Authenticate and update keys of an iClass card</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Partitioned Function Input for x = 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Input-output relations for k ⊕ 0 The relation is represented for every two inputs z 7 and z ′ 7</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Input-output relations for k ⊕ 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>z 5 mod 61) + 1 = (z 6 mod 62); ∧ (z 7 mod 63) 񮽙 = 0; 1, (z 5 mod 61) + 1 = (z 6 mod 62) ∧ (z 7 mod 63) = 0; 1, (z 5 mod 61) + 2 = (z 7 mod 63); (z 5 mod 61) + 3, otherwise.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Permutation π y [i] = 0. Example for k ⊕ 0 = 0xfc:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>id (87 04, kc ′ id ⊕ kc id ,id (87 04, kc ′′ id ⊕ kc ′ id ,id (87 04, kc id ⊕ kc ′′ id , e2 a5 bc 55)</head><label></label><figDesc></figDesc><table>Message 
Description 

Reader 
0c 00 73 33 
Read identifier 
Tag 
86 1d c1 00 f7 ff 12 e0 
Card serial number id 
Reader 
0c 01 fa 22 
Read configuration 
Tag 
12 ff ff ff 7f 1f ff 3c 
iClass 2KS configuration 
Reader 
18 02 
Authenticate with kc id 
Tag 
fe ff ff ff ff ff ff ff 
Card challenge c C 
Reader 
05 00 00 c1 d9 7e 99 bb f4 
Reader challenge (05, n R , a R ) 
Tag 
46 3c 62 98 
Response (a C ) 
Reader 
87 04 fc b4 32 3e 6a 86 56 26 8a b5 18 cc 
Update kc 8a b5 18 cc) 
Tag 
ff ff ff ff ff ff ff ff 
Update succesful 
Reader 
0c 00 73 33 
Read id 
... 
Reader 
87 04 76 98 db 5d 01 78 0a 8f 67 25 c1 08 
Update kc 67 25 c1 08) 
... 
Reader 
87 04 8a 2c e9 63 6b fe 5c a9 e2 a5 bc 55 
Update kc </table></figure>

			<note place="foot" n="2"> http://www.proxmark.org 3 http://www.sciengines.com 4 http://www.openpcd.org/HID_iClass_demystified</note>

			<note place="foot" n="5"> http://www.hidglobal.com/cardServices/ naviGoTrialDownloadForm.php 6 http://www.insidesecure.com/eng/Products/ Secure-Solutions/PicoPass</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Diversification and Fortification</head><p>This section describes the recovered key diversification and fortification procedure. Definition 4.2 gives the definition of the function hash0. It uses a subfunction scramble which is defined by Definition 4.1. First, the key diversification procedure where a diversified key kc id is computed from a card identity id and master key kc is as follows:</p><p>kc id = hash0(DES enc (id, kc)) Here the DES encryption of id with master key kc outputs a cryptogram c of 64 bits. These 64 bits are divided as c = x, y, z 0 , . . . , z 7 ∈ F 8 2 × F 8 2 × (F 6 2 ) 8 and used as input to the hash0 function. Finally, the output of the hash0 function is kc id = k 0 , . . . , k 7 ∈ (F 8 2 ) 8 . The function hash0 first computes x ′ = x mod 70 which results in 70 possible permutations (See <ref type="figure">Fig. 10</ref>). Then for all z i the modulus and additions are computed before calling the subfunction scramble.</p><p>Then, the subfunction scramble is called twice, first on input z ′ 0 , . . . , z ′ 3 and then on input z ′ 4 , . . . , z ′ 7 . The definition of the function scramble is as follows.</p><p>where sc :</p><p>After this a permutation is applied to the output bytes. The definition of hash0 is as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Weaknesses</head><p>This section describes weaknesses in the design of the Omnikey Secure Mode and on the iClass built-in key diversification and fortification algorithms. These weaknesses will be later exploited in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Omnikey Secure Mode</head><p>Even though encrypting the communication over USB is in principle a good practice, the way it is implemented in the Omnikey Secure Mode adds very little security. The shared key k CUW is the same for all Omnikey readers and it is included in software that is publicly available online. This only gives a false feeling of added security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Weak key diversification algorithm</head><p>iClass uses single DES encryption for key diversification. This provides very weak protection of the master key. This is a critical weakness, especially considering that there is only one master key for the HID application for all iClass cards.</p><p>The manufacturer seems to be aware of this weakness and tries to tackle the problem by adding the key fortification function.</p><p>This comes at the price of loosing entropy on the diversified card keys. After the DES computation the diversified 64-bit card key have at most 56 bit of entropy. Then, this key is put through the fortification function where it looses another 2.2 bits of entropy. In the next section, we explain where these 2.2 bits come from and discuss the security properties of the fortification function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Weak key fortification</head><p>This section clarifies why the key fortification is not strengthening the diversified key kc id . First, note that only the modulo operations in hash0 on x ( 256 70 ) and z 0 , . . . , z 2 , z 4 , . . . , z 7 are responsible for the collisions in the output. The expected number of pre-images for an output of hash0 is given by:</p><p>These modulo operations make inverting the function straightforward. For every pre-image one needs to determine if there exists another value within the input domain that leads to the same output when the modulus is taken. Note that each input value z i may have a second pre-image that maps to the same output value. Furthermore, every permute byte x has at least two other values that map to the same output value and in some cases there is even a third one. This means that the minimal number of pre-images is three. The probability p that for a given random input c there are only two other pre-images is:</p><p>This means that hash0 does not add that much of additional protection. For example, imagine an attacker who can learn the output kc id of hash0(DES enc (id, kc)) for arbitrary values id. Then, the probability p ′ for an attacker to obtain an output kc id which has only three pre-images is p ′ = 1 − (1 − p) n , where n is the number of function calls using random identities id. For n = 15 this probability p ′ &gt; 0.99.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Inverting hash0</head><p>It is relatively easy to compute the inverse of the function hash0. Let us first compute the inverse of the function scramble. Observe that the function scramble −1 is defined just as scramble except for one case where the condition and assignment are swapped. Concretely, </p><p>Next, we define the function hash0 −1 , the inverse of hash0. This function outputs a set C of candidate preimages. These pre-images output the same key k when applying hash0. The definition of hash0 −1 is as follows.  k π x ′ (7−i) <ref type="bibr">[1...6]</ref> , otherwise. i = 0 . . . 7</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 5.2. Let the function hash0</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Fortifying key negotiation schemes with poorly chosen passwords</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronics letters</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="1040" to="1041" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Datasheet PicoPass 2KS</title>
		<imprint>
			<date type="published" when="2004-11" />
		</imprint>
	</monogr>
<note type="report_type">Technical report</note>
	<note>Inside Contactless</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Practical Algebraic Attacks on the Hitag2 Stream Cipher</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicolas</forename><forename type="middle">T</forename><surname>Courtois</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O&amp;apos;</forename><surname>Sean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeanjacques</forename><surname>Neil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Quisquater</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Security</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="volume">5735</biblScope>
			<biblScope unit="page" from="167" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Cummings</surname></persName>
		</author>
		<title level="m">iCLASS Levels of Security</title>
		<imprint>
			<date type="published" when="2003-04" />
		</imprint>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Cummings</surname></persName>
		</author>
		<title level="m">Sales Training</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Presentation Slides from HID Technologies</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<title level="m">Electronic Frontier Foundation. Cracking DES: Secrets of Encryption Research, Wiretap Politics and Chip Design</title>
		<meeting><address><addrLine>Sebastopol, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Reilly &amp; Associates, Inc</publisher>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gdkgm + 08] Flavio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gerhard</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>De Koning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruben</forename><surname>Gans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Muijrers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roel</forename><surname>Peter Van Rossum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Verdult</surname></persName>
		</author>
		<imprint>
			<publisher>Ronny Wichers Schreur, and Bart Jacobs. Dismantling Mifare Classic</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">5283</biblScope>
			<biblScope unit="page" from="97" to="114" />
			<date type="published" when="2008" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>Computer Security -ESORICS</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Cryptanalysis of Alleged A5 Stream Cipher</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jovan</forename><surname>Dj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Golic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">1233</biblScope>
			<biblScope unit="page" from="239" to="255" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Wirelessly pickpocketing a Mifare Classic card</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Flavio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roel</forename><surname>Van Rossum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ronny</forename><forename type="middle">Wichers</forename><surname>Verdult</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schreur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 IEEE Symposium on Security and Privacy</title>
		<meeting>the 2009 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="3" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Dismantling SecureMemory, CryptoMemory and CryptoRF</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Flavio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roel</forename><surname>Van Rossum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ronny</forename><forename type="middle">Wichers</forename><surname>Verdult</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schreur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">17th ACM Conference on Computer and Communications Security (CCS 2010)</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="250" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A cryptanalytic time-memory trade-off. Information Theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hellman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="401" to="406" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Eli Biham, and Bart Preneel. A Practical Attack on KeeLoq</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastiaan</forename><surname>Indesteege</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Orr</forename><surname>Dunkelmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology -EUROCRYPT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="volume">4965</biblScope>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">24727 -Identification CardsIntegrated Circuit Card Programming Interfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Iso/Iec</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">15693 -Identification cardsContactless integrated circuit cards -Vicinity cards</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Iso/Iec</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Attacks on the DECT authentication mechanisms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lucks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schuler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tews</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">P</forename><surname>Weinmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wenzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Topics in Cryptology-CT-RSA 2009</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="48" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Heart of darkness -exploring the uncharted backwaters of hid iclass security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milosch</forename><surname>Meriac</surname></persName>
		</author>
		<ptr target="http://www.openpcd.org/images/HID-iCLASS-security.pdf" />
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Analyzing a modern cryptographic RFID system HID iClass demystified. Presentation at the 27th Chaos Computer Congress</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milosch</forename><surname>Meriac</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henryk</forename><surname>Plötz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Reverse Engineering a Cryptographic RFID Tag</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karsten</forename><surname>Nohl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Starbug</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henryk</forename><surname>Plötz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security &apos;08</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="185" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Extending SAT Solvers to Cryptographic Problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mate</forename><surname>Soos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karsten</forename><surname>Nohl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claude</forename><surname>Castelluccia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory and Applications of Satisfiability Testing -SAT 2009</title>
		<editor>Oliver Kullmann</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="volume">5584</biblScope>
			<biblScope unit="page" from="244" to="257" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
