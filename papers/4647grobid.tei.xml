<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:27+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ONE CLASS TO RULE THEM ALL 0-DAY DESERIALIZATION VULNERABILITIES IN ANDROID</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Or</forename><surname>Peles</surname></persName>
							<email>orpeles@il.ibm.com</email>
							<affiliation key="aff0">
								<orgName type="institution">IBM Security</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roee</forename><surname>Hay</surname></persName>
							<email>roeeh@il.ibm.com</email>
							<affiliation key="aff0">
								<orgName type="institution">IBM Security</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">ONE CLASS TO RULE THEM ALL 0-DAY DESERIALIZATION VULNERABILITIES IN ANDROID</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We present previously unknown high severity vulnera-bilities in Android.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. Introduction</head><p>Android is the most popular mobile operating system with 78% of the worldwide smartphone sales to end users in Q1 2015 <ref type="bibr">[1]</ref>.</p><p>Android apps are executed in a sandboxed environment to protect both the system and the hosted applications from malware <ref type="bibr" target="#b1">[2]</ref>. The Android sandbox relies on the Linux kernel's isolation facilities. While sandboxing is a central security feature, it comes at the expense of interoperability. In many common situations, apps require the ability to interact. For example, the browser app should be capable of launching the Google Play app if the user points toward the Google Play website. To recover interoperability, a key aspect of the Android architecture is Inter-App Communication (IAC) , which enables modular design and reuse of functionality across apps and app components. The Android IAC model is implemented as a messagepassing system, where messages are encapsulated by Intent objects. Through Intents, an app (or app component) can utilize functionality exposed by another app (or app component), e.g. by passing a message to the browser to render content or to a navigation app to display a location and provide directions to it. For implementing IAC, including sending and receiving Intents, Android uses a mechanism called Binder. As described thoroughly by <ref type="bibr" target="#b2">[3]</ref>,in the center of the Binder mechanism is the Binder Linux driver, that transfers messages between processes. Each such Inter-Process Communication (IPC) message is a 'transaction'. When an application talks to a service, it does so using proxy and stub methods that get translated to Binder transactions under the hood, albeit appear like a local function call to the developer.</p><p>Due to its significance, much past research has been invested, from multiple angles, in IAC. The research varies from Testing <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b6">6]</ref>, Verification <ref type="bibr" target="#b7">[7]</ref>, Prevention <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b9">9]</ref> and Offensive Security <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b13">13,</ref><ref type="bibr" target="#b14">14,</ref><ref type="bibr" target="#b15">15,</ref><ref type="bibr" target="#b16">16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. Serialization</head><p>Intents may contain arbitrary data of arbitrary types via a provided Bundle 2 object. For instance, an application may provide another app with a String which can then be accessed via Bundle.getString(String key) or through Intent.getStringExtra(String key). Moreover, a completely arbitrary object can be sent and later be accessed by the recipient via the Bundle.getObject(String key) method. In order to be able to send objects via IAC they must be serialized (or use the Parcelable interface explained briefly below). The recipient needs to deserialize them upon instantiation.</p><p>General-purpose serialization of objects can be achieved by implementing the Serializable interface in the object's class. Object members which shall not be serialized (for example, pointers used in native code) can easily be declared by the developer by providing the transient modifier before each of such a member. By default, during deserialization, ObjectInputStream's defaultReadObject method is called, receives the class name of the object being deserialized from the stream, and instantiates it, populating its fields that are non-transient and non-static with the stream's data. In addition, developers can implement special methods in their classes, that will override the default serialization methods. These methods, covered by the Java Documentation 3 include readObject, readResolve and writeReplace.</p><p>In addition, Android provides another serialization facility through the Parcleable interface. Objects of implementing classes can be placed inside a Parcel 4 object which is designed as a high-performance IPC transport.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. The General Android Problem</head><p>In 2014, Jann Horn has disclosed a significant vulnerability <ref type="bibr" target="#b17">[17]</ref> in Android. The vulnerability, identified as CVE-2014-7911, was a serious flaw in the way Android derserialized objects via ObjectInputStream. In Android versions earlier than 5.0, the deserializing code did not verify that the received object is indeed serializable by making sure that its class implements the Serializable interface. This allowed for inserting arbitrary objects (available to the target's class loader) into a target app or service. Things became more serious because oftentimes the inserted object is automatically deserialized, and later freed by the Garbage Collector (GC), which calls the finalize method of the deserialized object. The finalize method may switch into native code that may access non-transient pointers provided by the deserialized object, that the adversary controls. In current Android versions, any object put inside a Bundle can be initialized by a victim app (or service) if the latter only uses (touches) a Bundle arriving from the attacker's IAC. Using a Bundle is a very common behavior among apps.. Internally, when the Bundle is touched (e.g. by calling getStringExtra() or similar), it unparcels itself -initializing (and instantiating) all of its values (even unused ones). These values may include Serializable and Parcelable objects, that will get deserialized (or unparcelled). Together with his disclosure, Horn released a Proof-of-Concept (PoC) code crashing Android's system_server which runs under the system context. Horn's PoC worked by providing system_server with an evil, non-Serializable android.os.BinderProxy object, by inserting it into the setApplicationRestrictions's method Bundle parameter. While Horn's PoC only crashed system_server, it clearly demonstrated the problem, which indeed proved to be exploitable as a few months later Yaron Lavi and Nadav Markus released a write-up <ref type="bibr" target="#b18">[18]</ref> describing a fully working exploit.</p><p>Despite the fact that CVE-2014-7911 has been patched, there can still be Serializable classes available to applications that are dangerous to load if they can be controlled by the adversary. One prominent scenario happens if the developer had forgotten to add the transient modifier to a sensitive member (such as a pointer).</p><p>This game is asymmetric as one vulnerable class that is available to the default Android class loader is enough for all apps (or one highly-privileged service) to be compromised. Objects of such classes may cause damage in several ways, including automatic code execution of their finalize method with deserialized params or by other methods (such as writeReplace or writeObject) that can be called implicitly .</p><p>Hypothetically, even in an ideal world where there aren't such vulnerable classes available in the Android framework, such classes could be found in third-party frameworks (SDKs) or in specific apps -making a more targeted attack.</p><p>It is important to note that Bundle isn't the only vector. Each code path that leads to Parcel's readValue, readParcelable or readSerializable will also instantiate whatever object is on the stream (that is loadable).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. Finding a Vulnerable Class</head><p>We wanted to find a class available to any Android app that both implements the Serializable interface, holds a native pointer as a member without declaring it to be transient, and also provides a finalize method which accesses that pointer. The finalize method does not have to be implemented by the class itself, but rather by an ancestor class, accessing the pointer via a call to an overidden method.</p><p>We automatically created a list of candidate classes using the following mechanics. We first wrote a small app with a single Activity, and then ran it, waiting for a debugger, using the following am command, under an emulator running Android 4.2 through 5.1.1.</p><p>am start -D -n &lt;activity class&gt;</p><p>We remotely attached our custom debugger to the application through JDWP. On top of JDWP we ran a Java code that utilizes JDI as shown by <ref type="figure">Figure  IV.</ref>1. We ignored the Object's and Enum's finalize implementations because they were simply empty functions, creating a lot of uninteresting candidates. We printedout only classes which have at least one attackercontrollable field. A field is attacker-controllable if it is (1) non-transient (2) non-static (3) all of the classes in the class hierarchy from the candidate class to the class that actually defines the field (can be the candidate class itself) are Serializable. (4) of a Serializable type (or primitive) (5) no readObject / readResolve implementation that prevents us from controlling it. Note that this code does not check for the 5 th property of our attacker-controllable definition, so it only yields an upper bound, which we can verify manually. This code yields a couple of classes: 1) java.util.regex.  The more pedantic reader would notice that our experiment was limited to the preloaded classes only. In order to overcome that, we created a list of loadable classes by parsing the output of the oatdump tool over boot.art. This resulted in 13321 loadable classes under our Android 5.1 build. One could then try to add them to /system/etc/preloaded-classes, and re-run our experiment. We decided to take a different approach and write a small Android app, that loads the classes using Java Reflection, and examines whether they are candidate to be vulnerable, by the same criteria defined above. We did not find any additional candidates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. Attacking OpenSSLX509Certificate</head><p>OpenSSLX509Certificate is Serializable since it is a descendant of Certificate which is Serializable. It also has a finalize method which calls a native function with its mContext member, which is a pointer of type long, as an argument. Since OpenSSLX509Certificate doesn't implement any special deserialization methods (readObject or readResolve), and since mContext is attackercontrollable (as per our definition in Section IV), the adversary can control it. Eventually, as explained in Section III, OpenSSLX509Certificate's finalize method will be invoked automatically by the GC. The finalize method then invokes NativeCrypto.X509_free with mContext as a parameter. Its execution ends with a decrement of *(int *)(mContext + 0x10). (In native code.)</p><p>Constrained "Write What Where" in user-mode memory can be achieved by decrementing a positive WORD's value one by one (also by accessing its high/low HALFWORDs with unaligned addressing). Freeing of an arbitrary object could also be achieved, but there's no need as we managed to create a fully functional exploit without that.</p><p>Note that instead of relying on the GC to call finalize, we could have abused the OpenSSLX509Certificate's writeReplace method, that is inherited from Certificate. As explained in Section III, when implemented in a class, this method overrides the default method for serializing an object. The writeReplace method in our case calls getEncoded, a method implemented by OpenSSLX509Certificate that leads to the invocation of a native function (NativeCrypto.i2d_X509) with our attacker-controlled parameter (mContext).Unlike finalize, this method doesn't depend on the GC, but is triggered immediately when our OpenSSLX509Certificate object is serialized (at the other end). One way of abusing it would be sending an Intent with OpenSSLX509Certificate as an Intent Extra to an application that uses (touches) the Intent's Extras Bundle, and later serializes the Bundle which will trigger a writeReplace call on our deserialized object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. Proof-of-Concept Exploit</head><p>In order to demonstrate the impact of such a vulnerability, we developed and successfully tested a PoC exploit, running under Google Nexus 5 Hammerhead equipped with Android 5.1.1. The exploit can easily be ported to run on other devices running vulnerable Android versions. This paper describes a PoC that demonstrates the feasibility of the attack. It does not include any exploit code. The exploit's fundamental goal is to achieve code execution in an arbitrary app or service. One significant candidate is a process with elevated privileges -Android's system_server, which hosts many core services such as Android's Package Manager, Activity Manager and Power Manager services. It runs under UID 1000 -Android's system user. We attack system_server by inserting our objects into the setApplicationRestrictions method's Bundle parameter, see <ref type="bibr" target="#b17">[17]</ref>. After being able to run code in the system_server process, we demonstrated three different goals the exploit can achieve: The first is replacing an application already on the target device with our own malware app. The second goal we achieved was completely bypassing SElinux, by changing and reloading the SElinux policy. Third, on devices running kernels that were compiled with loadable modules support (not recent Google Nexus devices), we were also able to leverage the exploit to gain arbitrary kernel code execution. This was done by making our shellcode, running inside system_server, load our own kernel modulesee Section VII-C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Constrained "Write What Where"</head><p>As we mentioned in Section V, we are able to decrement the value of a positive integer by one. This is because our pointed object is believed to contain a reference counter of type signed integer at offset 0x10. Thus every time NativeCrypto.X509_free is called, it gets decremented and the function returns (without freeing anything). When the value reaches zero, the flow towards free continues, and may cause a crash by dereferencing an unmapped pointer.</p><p>Because the decrement doesn't crash the remote app (on a positive integer), we can re-run it multiple times, decrementing the target WORD until it reaches the value of 1.</p><p>In order to do it efficiently, we include many (0x500) OpenSSLX509Certificate objects inside each transaction's Bundle, making the WORD's value decrement faster. (Each Binder transaction is limited to 1MB in size otherwise a TransactionTooLargeException is thrown 8 .) In order to further improve the efficiency, to allow us to both target WORDs that initially are negative, and set WORDs with a negative value without crashing, we can also decrement from the middle of our target WORD (2 bytes aligned), lowering the value of the upper half of our WORD to reach a desired value, or until our WORD's MSB (sign-bit) is zeroed, so that we will later be able to operate on the target WORD directly and also decrement the lower HALFWORD. In case the desired value is negative, after setting the lower HALFWORD, we can get back to the address+2 WORD and set the higher HALFWORD to a negative value. The ability to do this of course depends, again, on the value of the WORD we decrement and of the next adjacent HALFWORD.</p><p>Note that for the constrained "Write What Where" we have to know the original value of the target WORD in the remote process as well. This is possible thanks to the Zygote creation model, see Section VI-D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Controlling the Program Counter (PC)</head><p>Now that we have the ability to control a value from another process's address space, we can use it to subvert a target program's logic, by changing authentication or privilege states for example. In addition, we can try to achieve arbitrary code execution. Android, a Linuxbased OS, has memory page permissions. Since we didn't find any memory page that is both writable and executable, we thought we could modify a function's address from the Global Offset <ref type="table">Table (</ref>.got section). Unfortunately for us, the shared libraries in memory were all compiled with the Relocation Read Only (RELRO) flag. This compile-time flag instructs the loader to resolve all symbols' addresses immediately during the binary loading, and then set their memory pages to read-only, making .got overwrite impossible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Writable Function Pointers</head><p>Another approach for gaining code execution by controlling memory is by changing a writable function pointer. In some cases, libraries let other apps hand pointers of callback functions, which are invoked in specific places in the library's code. For example, libraries may allow an application to hand a callback for logging purposes, that will be invoked every time the library needs to write to a log. These callbacks sometimes appear as global function pointers in the library's (writable) data section, making them a perfect target for achieving arbitrary code execution.</p><p>In our case, we found that libcrypto (the OpenSSL library) offers this functionality which is used by libjavacrypto (conscrypt's native library). libcrypto holds the pointers as global variables in the data section, and thus they are writable. We found calls to the callback throughout the code.</p><p>Specifically, we chose to override the id_callback function pointer to point to our code. We then make the target process reach a code path that invokes the callback function. We do this again using the same trick of serializing an object that will be instantiated at the other end. This time we put an OpenSSLECPrivateKey object, with bad contents in its byte array member inside the bundle. The byte array won't be successfully decoded as PKCS8, but will help us in later stage, see Section VI-H. OpenSSLECPrivateKey implements the readObject method, that overrides the default deserialization method, and thus is called during object deserialization. This function calls the NativeCrypto.d2i_PKCS8_PRIV_KEY_INFO function with the byte array we supplied. Our supplied byte array makes the function call the throwExceptionIfNecessary function (after failing to parse our byte array to a valid value), that eventually leads to an invocation of CRYPTO_THREADID_current, that directly calls our callback function .</p><p>A minor drawback we encountered of using the id_callback function pointer is that its adjacent HALFWORD is zeroed. This means that by decrementing this function pointer, we are practically limited to positive addresses [1, 0x7 f f f f f f f ] . We practically bypass this limit in Section VI-G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Bypassing Address Space Layout Randomization (ASLR)</head><p>ASLR is a security mechanism whose purpose is to make it harder for attackers to build a reliable exploit. ASLR randomly arranges key data areas of a process, including the base of the executable and the positions of the stack, heap and libraries. ASLR could have easily prevented us from gaining code execution by overriding a specific function pointer, because we wouldn't have known where the function pointer lies in memory, and not less important, what its initial value is, which is an address of a function in the libjavacrypto module.</p><p>Android's Zygote Process Creation Model: In Android, every application, and most of the service processes are created by forking from a single process named Zygote. The design was intended to improve the responsiveness of applications at launch-time, but it adversely affects the effectiveness of ASLR. The Zygote process is created among the first processes at boot time, and contains a full Dalvik or ART Virtual Machine instance with frequently used classes preloaded. Lee et al. <ref type="bibr" target="#b19">[19]</ref> concluded that "all running apps inherit the commonly used libraries from the Zygote process and thus share the same virtual memory mappings of these libraries, which represent a total of 27 MB of executable code in memory". Other research also abused Zygote. For example, Kaplan et al. <ref type="bibr" target="#b13">[13]</ref> leaked a random value generated in early boot in order to reconstruct the Linux Psuedo-Random Number Generator (PRNG) state.</p><p>Thanks to Zygote, by observing our own, malicious process's, memory we are able to realize the function pointer's address and value in the remote target process's memory. Both of these are addresses in libraries that were forked from Zygote (even in system_server, which also forks from Zygote).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Towards Code Execution</head><p>Currently, using the function callback we decremented, we have the ability to control the PC, i.e. to execute code from an arbitrary address (constrained to a positive int value) in memory. As we don't currently have code instructions that will perform the tasks we want in the target process's memory, at this stage we manipulate memory and register values in order to prepare our own shellcode for execution. We then jump to it. We achieved this by passing the shellcode bytes to the target process, and by chaining multiple ReturnOriented Programming (ROP) gadgets as explained in the next sections. In order to execute the chain of gadgets using returns, we placed the gadgets' addresses on the (pivoted) stack and jumped to the first gadget. We used the Stack Pivot technique to achieve this (see Section VI-H).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Reliably Locating our Shellcode in the Remote Process</head><p>For the Stack Pivot and later steps, we need to have a memory buffer (for the shellcode) at a reliable location in the remote process's memory. Traditionally, placing the shellcode in the target process's memory is done by using a technique called Heap Spraying, that basically involves filling the target process's heap memory with repetitions of the desired shellcode, increasing the probability that the shellcode will reside at an arbitrary address during the exploitation. In our case, though, the byte array that we fully control during the deserialization of the OpenSSLECPrivateKey object for triggering our code execution (see Section VI-C) happens to be directly pointed by the fp (r13) register at the time our first gadget's (see G1, Section VI-J) opcode is reached.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G. Running Code from an Unconstrained Arbitrary Address</head><p>The next adjacent HALFWORD of id_callback happens to be zero, meaning the value we can overwrite it with is limited. Due to the fact that id_callback's value always happens to be above 0x7fffffff (it is set to the address of a function under libjavacrypto, which sits at high memory), we can practically change id_callback's value to any positive integer. To overcome this limitation, and gain the ability to execute gadget at any user-space address, we wanted to find a gadget residing at a positive integer address, that will let us jump to any address.. Observing the memory layout of Android processes forked from Zygote, we noticed boot.oat (used by ART) has a large executable mapping around the 0x70000000 area. Since our controlled memory is pointed by fp (see Section VI-F) we searched for a gadget that directly jumps to a dereferenced value relative to fp. We haven't found such a gadget, but instead, found a gadget (G1, see Section VI-J) that takes fp <ref type="bibr">[0]</ref>, dereferences it 2 more times and jumps to the resulting address. Since we control fp <ref type="bibr">[0]</ref>'s value (the very first WORD in our byte array), and we could make sure that the dereferenced pointer chain will all be at addresses whose adjacent HALFWORDs are a positive short, allowing us to fully control the jump address by our constrained decrement. We thus have to set 2 additional WORDs using the decrementation method described in Section VI-A before running the gadget.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H. Stack Pivoting</head><p>A common method for attackers to conveniently control program execution involves pointing the stack pointer to an attacker-controlled memory. This allows the attacker to prepare a call stack that includes the addresses of the desired ROP gadgets so that each time a return instruction (pop {...,pc}) occurs, the next gadget runs. The second gadget we run (after achieving unconstrained arbitrary address execution) is G2 (Section VI-J). It changes the value of sp to a value relative to fp, and then returns. Thus from that point forwards, our controlled byte array (from Section VI-C.) becomes the program's stack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. Running Our Shellcode Despite SElinux</head><p>Security-Enhanced Linux (SElinux) is a security enhancement to Linux which allows fine-grained control over access control. It is comprised of kernel modifications and user-space tools that have been added to various Linux distributions. It was incorporated into Android in Android 4.3, in permissive mode (permission denials are logged but not enforced), and gradually moved to full enforcement in Android 5.0 <ref type="bibr" target="#b20">[20]</ref>. SElinux assigns processes with a security domain (or type), adding the ability to restrict specific processes' from doing certain actions (regardless of the user running them). The types' restrictions are defined in .te files. SElinux takes a secure white-list approach where everything is disallowed, except for the specific rules defined for the process.</p><p>We decided to run our own shellcode inside the system_server process due to the amount of SELinux capabilities this process has. (Which is due to the fact that it hosts many system services.) Our shellcode can then do many sensitive actions. The process is subject to the restrictions of the system_server type <ref type="bibr" target="#b9">9</ref> . A required step for running our shellcode, which we put as part of the OpenSSLECPrivateKey object's byte array, is to map it as an executable memory. By default, such an action will be restricted because of SElinux, but as one can see, system_server.te includes the "allow system_server self:process execmem" rule, giving the system_server process the PROCESS__EXECMEM permission, which allows it to map anonymous memory as executable. We take advantage of this fact, and use our ROP chain (explained in the next section) to map a readable, writable and executable (rwx) memory location, copy our shellcode to that location, and run it from there.</p><p>We note that we had to overcome a caching problem. ARM has two separate memory caches types -one for instructions and another for data <ref type="bibr" target="#b21">[21]</ref>. When we first copied our code to the rwx memory area, it was written to the data cache, and was not immediately flushed into memory. Thus when we jumped to the shellcode location, the processor fetched instructions for execution directly from memory, while our shellcode was still residing in the data cache. In order to overcome this, we copy a large memory amount after our shellcode, filling the data cache. By doing so, we manage to evict (flush) our shellcode from the data cache to memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>J. ROP Chain</head><p>The series of of ROP gadgets we use is summarized here. The gadgets map a rwx memory area in (the unused) address 0x50000000, copy the shellcode there and jump to it. All the gadgets were found inside libraries that are loaded by Zygote. They were found either manually (in boot.oat, which isn't a valid ELF binary), or by using ROPGadget <ref type="bibr" target="#b10">10</ref> .</p><p>(G1) Jump to an Arbitrary Address: mov r1, fp; ldr r0, [r1, #0]; ldr.w r0, [r0, #444]; ldr.w lr, [r0, #44]; blx lr. Found in boot.oat, which is at a positive integer address . This gadget is used for jumping to an unconstrained arbitrary memory address by taking a value relative to fp and jumping to it.</p><p>(G2) Stack Pivot: mov sp, fp, and return. (G3) Allocate Buffer on Stack: add.w sp, sp, #0x420, and return. Used to allow more stack space before calling libc functions. It is needed since our byte array happens to be near the beginning of a page, and we don't want the stack to grow down to an unmapped memory area.</p><p>(G4) Map RWX memory: pop {r0, r1, r2, r3, pc}. This gadget is used for running mmap(0x50000000, shellcode_size + EXTRA_FOR_CACHE_EVICTION, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0). Note that mmap's prologue includes pushing the LR register to the stack. In its epilogue it is popped from the stack and jumped into. Because we couldn't easily find a gadget that sets LR value, we used a small trick: we don't jump to mmap's real beginning, but rather into mmap just after the instruction that pushes LR. This way LR isn't placed on the stack at all, and thus later in the epilogue, when mmap pops a value from the stack (which was meant to be the saved LR), it gets what we placed on the stack in advance, which is the address of the next gadget.</p><p>(G5) Progress the Stack: pop {r0, r1, r2, r3, pc}. This gadget advances the stack pointer abit forward before jumping to next gadget, so we don't have an overlapping with the previous gadget's mmap 5 th and 6 th parameters, which lie on the stack.</p><p>(G6) Call memcpy and return to Shellcode: add r1, sp, #0x24c; pop {r0, r2, r5, r7, pc}. This gadget prepares r1 (memcpy's first argument) to point to our shellcode in memory, and then calls memcpy(0x50000000, OUR_SHELLCODE, shellcode_size + EXTRA_FOR_CACHE_EVICTION). Note that we used the same trick as mentioned in the mmap gadget, for setting the return address to be our shellcode location.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>K. The Shellcode</head><p>We compiled a shellcode written in C that uses library functions to perform its actions. The shellcode is compiled with placeholders for the library functions, that are resolved (using the Zygote method, see Section VI-D.) and changed by our application before triggering the exploit (i.e. before the shellcode is sent). In Section VII we list some options for the shellcode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. Impact</head><p>In this section we list a few options for a shellcode targeting system_server. While this list is incomplete, it surely demonstrates the severity of the vulnerability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Replacing Existing Applications</head><p>The shellcode can replace any user app on the device (residing in /data/app/&lt;target-app&gt;/base.apk) with arbitrary (malicious) app. It can then reboot the device (so changes will take place immediately) by setting the sys.powerctl property (by calling the libcutil's property_set function). The malware will have access to the original app's data and will be launched instead of the original app.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Completely Bypassing SElinux</head><p>On Android, the SElinux policy can be updated by writing the policy configuration files to the /data/security/current directory, and setting the selinux.reload_policy property to 1. In the original SElinux policy that comes with Android 5.1.1 (and others), the only process that is allowed to write to files under the /data/security is the process we control, system_server. One can find this allowance in the system_server.te file under the macro selinux_manage_policy(system_server) which gets transformed (definition in the te_macros file) to allow permissions for directory, file or link creation inside /data/security, and permission to set the selinux.reload_policy property.</p><p>In order to change the policy, we need to create the current directory inside /data/security, and write the policy files inside it. The policy consists of the sepolicy binary file, and 6 textual files 11 : (1) selinux_version. (2) file_contexts. <ref type="formula">(3)</ref> property_contexts. (4) seapp_contexts. (5) service_contexts and (6) mac_permissions.xml. In order to load the new policy, the contents of /data/security/current/selinux_version file must be equal to the contents of the /selinux_version file. This is not a difficult task, since the latter just contains the current Android BUILD_FINGERPRINT value which can be retreived by reading the ro.build.fingerprint property using libcutils' property_get. As for the mac_permissions.xml file, we create a symbolic link to the original file in /system/etc/security/mac_permissions.xml. We simply create a symbolic link, because in contrast to the rest of the files, this file isn't opened with the O_NOFOLLOW flag, and thus can follow links. As for the contents of the rest of the files, we use files generated in advance by either building a custom Android AOSP image (after changing the SELinux rules in the textual configuration as we like), or take the original files of the same Android build, but edit the binary sepolicy file using the sepolicy-inject tool <ref type="bibr" target="#b22">[22]</ref>. By taking the second approach, we ran our exploit and successfully changed sepolicy domains (system_server and shell_exec) to be permissive. We then ran a shell command execve with sh, that we were not allowed to perform previously.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Kernel Code Execution</head><p>Linux kernels can be compiled with loadable modules support, by specifying the CONFIG_MODULES option.</p><p>When this feature is supported, privileged processes can load arbitrary modules into the kernel using a syscall, as long as the kernel was not compiled with module signature verification (CONFIG_MODULE_SIG). As can be seen in the SElinux policy rules for the system_server process (system_server.te, explained in Section VI-I), system_server is not restricted from loading kernel modules, thanks to the "allow system_server kernel:system module_request" rule.</p><p>For security reasons, many Android kernels, including Google Nexus 5's were not compiled with CONFIG_MODULES, and hence this section is irrelevant to them. Despite that, we have encountered other new popular up-to-date Android devices whose kernels do support CONFIG_MODULES (without CONFIG_MODULE_SIG).</p><p>For testing this basic idea (on our device), we conducted the following experiment: we replaced our Nexus 5 device's kernel with a kernel we compiled from AOSP with CONFIG_MODULES support. We then used our exploit against it, with a shellcode that loads our kernel module (that we compiled in advance) into memory. We were indeed able to verify the exploit's success by seeing our module's printk's messages appear in the device's dmesg (kernel messages) log.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. Finding Vulnerable Classes in SDKs and Apps</head><p>As mentioned in Section III, vulnerable classes can be found in specific apps or frameworks, implying a more restricted (targeted) attack. We therefore decided to analyze the 32,701 most downloaded and free Android apps in order to find such classes. Since using our aforementioned runtime technique to conduct this experiment would take hours to complete, we decided to use a different approach. We created a tool that runs dexlib2 12 over the apps' dex files. dexlib2 gives a Reflection-like interface which allowed us to statically find classes that meet the criteria defined in section IV (again without property 5) in mere 93 minutes. One caveat of this approach is that dexlib2 is limited to the classes defined in the given APK's dex files, so our approach would have false negatives on classes which inherit from a Serializable Android SDK class or from an Android SDK class that has a finalize method. In order to compensate for that we created two caches. The first cache is of Serializable Android SDK classes with their attacker-controllable fields (see Section IV), while the second is of SDK classes that contain a finalize method. Both are based on classes found in boot.art of our Android 5.1 build (using the technique explained in Section IV). We found a total of 358 classes over 176 APKs that met our criteria. Our analysis had quite a few interesting findings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Vulnerable Classes Generated by SWIG (CVE-2015-2000/1/3/4/20)</head><p>We witnessed several APKs with a Serializable implementing class that contained a non-transient long member named swigCPtr. This immediately raised a red flag. Investigating further revealed a very similar to OpenSSLX509Certificate situation, with the swigCPtr variable passed to native code.</p><p>SWIG 13 or 'Simplified Wrapper and Interface Generator' is an interoperability tool that connects C/C++ code with a variety of high-level languages including Java. Running SWIG over a C++ class generates 2 additional components: A Java wrapper to be used by Java apps, and a JNI interface that interconnects the wrapper to the original C++ code.  This means that if the developer explicitly chose to implement the Serializable interface, by using SWIG's javainterfaces typemap, or more commonly, implicitly and probably accidentally by extending a class, using SWIG's javabase typemap, which is Serializable, the generated code would be vulnerable to our attack since the generated swigCPtr would not be transient. It should be noted that the generated native code ( <ref type="figure" target="#fig_3">Figure VIII.6</ref>) for a class with a virtual destructor can be exploited more easily since the attacker can trivially control the PC due to the fact that its address is fetched from the object's provided vtable whose pointer (swigCPtr) the attacker fully controls. Therefore it does not require overwriting a callback pointer as opposed to the technique shown in Section VI. As for non-virtual destructors, the flow reaches the global delete operator which reduces the problem to exploiting an arbitrary free.</p><p>The fact that SWIG can generate vulnerable code has an amplification potential. We indeed found multiple SDKs that included vulnerable SWIG-generated classes which further amplified the problem. Among the vulnerable SDKs were Jumio <ref type="bibr">(CVE-2015</ref><ref type="bibr">-2000</ref><ref type="bibr">), MetaIO SDK (CVE-2015</ref><ref type="bibr">-2001</ref>, PJSIP PJSUA2 <ref type="bibr">(CVE-2015</ref><ref type="bibr">(CVE- -2003</ref>, <ref type="bibr">GraceNote GNSDK (CVE-2015</ref><ref type="bibr">-2004</ref><ref type="bibr">) and MyScript (CVE-2015</ref><ref type="bibr">-2020</ref>. A total of 18 APKs in our sample set used these SDKs and ended-up to be vulnerable.</p><p>We argue that the fact that the application can accidentally implement the Serializable interface, by extending a Serializable class such as Exception, is the root cause of this issue, although we also encountered an explicit implementation of the Serializable interface.</p><p>B. ArcGis Runtime SDK for Android <ref type="bibr">(CVE-2015</ref><ref type="bibr">(CVE- -2002</ref> Similarly, ArcGis Runtime SDK for Android by esri contained a class with a attacker-controllable pointer which propagated to native code. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Google Play Services (ANDROID-2153894)</head><p>We also encountered the vulnerable OpenSSLX509Certificate class in the Google Play Services (GMS) APK. Google has tracked it with the above internal identifier and the same CVE as of the Android Platform instance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. Mitigation</head><p>We privately disclosed the vulnerabilities to the various vendors and code maintainers prior to the publication of this paper. The disclosure timeline is summarized by <ref type="table">Table I</ref>. The following describes the various patches that the vendors made to their vulnerable code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Patched OpenSSLX509Certificate</head><p>Google has fixed the two OpenSSLX509Certificate instances by adding the transient modifier to the mContext member. Google has also backported the patch to Android 4.4 (commit id 0b9d6334acde7460502face82417de40e438a3f4), 5.0 and 5.1 (commit id de55e62f6c7ecd57d0-a91f2b497885c3bdc661d3). The patch is also available in Android M (build MPZ79M).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Patched SDKs</head><p>We reported the issues to the relevant vendors or code maintainers. Jumio removed the vulnerable SWIG classes. esri has patched the ArcGis Runtime SDK by adding the transient modifier to the native pointer. MyScript and GraceNote fixed their SDKs by adding the transient modifier to the sensitive variables, PJSIP patched PJSUA2 by by overriding the readObject / writeObject methods, effectively making the vulnerable class non-Serializable. The MetaIO SDK was fixed as well, as it no longer implements the Serializable interface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Patched SWIG</head><p>Since the generated vulnerable code was due to bad configuration given by the developer, we do not consider SWIG to be vulnerable. This is somewhat analogous to blaming a compiler for buffer overflows. However, even the most competent developers could miss the fact that they accidentallly extended a Serializable class. Therefore we decided to contact SWIG team which released a more secure version. The patched version generates the swigCPtr member with the transient modifier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X. Discussion</head><p>While the patches fixed the specific instances that we had found, we feel that a general problem deserves a general mitigation, reducing the impact of such serialization attacks. Since Bundles are very common in Android's Inter-Process Communication, we suggest changing the Bundle's default behavior that automatically instantiates all of its values (under BaseBundle.unparcel, that is invoked by any 'touch' of the Bundle) to a lazy approach, i.e. retrieving only the values of keys it is asked for. Of course by design the problem will still remain, but will depend more on specific developer's code, so less apps will be vulnerable if another vulnerable class is found, significantly narrowing the attack surface. In addition, further protection that prevents arbitrary readObject, readReplace, writeObject or writeResolve methods to be called can be achieved by deprecating the current getParcelable and getSerializable methods (of both Bundle and Parcel) and change the APIs to include the class name of the expected objects.</p><p>Furthermore, mitigating exploitation is also possible. First, as explained in Section VI, ASLR is pretty much useless in Android if the attacker can launch malware.</p><p>[19] provides a secure replacement for the insecure Zygote implementation. In addition, as our PoC exploit overwrites a function pointer, pointer integrity mechanisms are also possible. One might think that callback pointers must be writable, because of their functionality, i.e. they have to be dynamically changed throughout program lifetime. However, this does not have to be the case. One mechanism that solves this problem is keeping the memory area that holds the function pointers to read only, and the memory will become writable by the callback setter functions just for the period of changing  <ref type="bibr" target="#b23">[23]</ref> proposes to whitelist function pointer values to identify cases where the function pointers are being abused. Another interesting mitigation is treating fields as transient by default (i.e. an opt-in approach as opposed to the current opt-out one). As for the specific payloads we show in Section VII, disabling CONFIG_MODULES,or at least enabling CONFIG_MODULE_SIG as well, is a good practice. A more restrictive SELinux non-bypassable policy should also be deployed.</p><p>In Android 5.0, the WebView component was moved to an updatable APK <ref type="bibr" target="#b24">[24]</ref>, decoupling it from the rest of the system. This had quite a few significant advantages with respect to security. First, it allowed Google to release security patches much faster. Second, it tackled the Android fragmentation problem as patches could be backported for old Android versions more easily, and delivered to various devices all at once. We encourage Google to continue their efforts towards decoupling the vendors' dependent code from the rest of the system, so patches will be available much faster. Our case showed the significance of such a separation, as the Google Play Services instance of OpenSSLX509Certificate was updated, in multiple Android versions, 3 days after our report.</p><p>As opposed to vulnerabilities found in final products, such as operating systems or applications, where an automatic update mechanism is usually available, the situation is by far worse for SDKs. One vulnerable SDK can affect dozens of apps whose developers are usually unaware of it, taking months to update. For example, a recent study <ref type="bibr" target="#b15">[15]</ref> shows that a high severity vulnerability <ref type="bibr" target="#b11">[11]</ref> found in Apache Cordova for Android, although been patched for months, still affects dozens of Android apps which use Cordova. The situation is most frustrating for apps which use orphan SDKs, ones that no longer receive security updates. Developers should be aware that depending on 3rd-party SDKs has that significant risk, prepare for alternatives, or choose their used SDKs wisely. Developers also deserve better toolsGradle and its 3rd-party plugin, Gradle Versions Plugin, which notify the developer when a new version is available for a used SDK, are a pretty good start.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Figure IV.1. JDI code that finds candidate vulnerable classes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>For example, running SWIG over the very simple C++ code shown by Figure VIII.1 generates the Java wrapper class found in Figure VIII.2 and the JNI binding code partially given by Figure VIII.3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure VIII. 1 .Figure VIII. 2 .Figure VIII. 3 .</head><label>123</label><figDesc>Figure VIII.1. C++ code as an input to SWIG</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure VIII. 6 .</head><label>6</label><figDesc>Figure VIII.5. Result of using the custom SWIG interface file</figDesc></figure>

			<note place="foot" n="1"> https://developer.android.com/about/dashboards</note>

			<note place="foot" n="2"> http://developer.android.com/reference/android/-os/Bundle.html 3 http://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html/ 4 http://developer.android.com/reference/android/-os/Parcel.html</note>

			<note place="foot" n="8"> http://developer.android.com/reference/android/os/-TransactionTooLargeException.html</note>

			<note place="foot" n="9"> https://android.googlesource.com/platform/external/sepolicy/+/android-5.1.1_r6/system_server.te 10 https://github.com/JonathanSalwan/ROPgadget</note>

			<note place="foot" n="11"> http://selinuxproject.org/page/NB_SEforAndroid_1-#Device_Policy_File_Locations</note>

			<note place="foot" n="12"> https://github.com/JesusFreke/smali/tree/master/dexlib2</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>XI. Acknowledgements</head><p>We would like to thank the following teams and individuals:</p><p>• Google and the various SDK teams (Jumio / esri / MyScript / MetaIO / PJSIP / GraceNote) for the prompt responses and patching. This shows without doubt their commitment for security.</p><p>• The SWIG team, and especially William S. Fulton, for making SWIG more secure.</p><p>• Sagi Kedmi of IBM X-Force Application Security</p><p>Research Team for his help with the 32k apps experiment.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Os Market</forename><surname>Smartphone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Share</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Understanding Android Security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Machigar</forename><surname>Ongtang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Mcdaniel</surname></persName>
		</author>
		<idno type="doi">1540-7993.doi:10.1109/MSP.2009.26</idno>
		<ptr target="http://dx.doi.org/10.1109/MSP.2009.26" />
	</analytic>
	<monogr>
		<title level="j">IEEE Security and Privacy</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="50" to="57" />
			<date type="published" when="2009-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thorsten</forename><forename type="middle">Android</forename><surname>Schreiber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Binder</surname></persName>
		</author>
		<ptr target="https://www.nds.rub.de/media/attachments/files/2012/03/binder.pdf" />
		<imprint>
			<date type="published" when="2011-10" />
			<publisher>Android Interprocess Communication</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">IntentFuzzer: Detecting Capability Leaks of Android Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kun</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianwei</forename><surname>Zhuge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yongke</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lujue</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haixin</forename><surname>Duan</surname></persName>
		</author>
		<idno type="doi">978-1-4503-2800-5.doi:10.1145/2590296.2590316</idno>
		<ptr target="http://doi.acm.org/10.1145/2590296.2590316" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM Symposium on Information</title>
		<meeting>the 9th ACM Symposium on Information<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="531" to="536" />
		</imprint>
		<respStmt>
			<orgName>Computer and Communications Security</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Dynamic Detection of Inter-application</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roee</forename><surname>Hay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Omer</forename><surname>Tripp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Pistoia</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Communication Vulnerabilities in Android</title>
		<ptr target="http://researcher.ibm.com/researcher/files/us-otripp/issta15.pdf" />
	</analytic>
	<monogr>
		<title level="m">Proc. ISSTA</title>
		<meeting>ISSTA</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="118" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Analyzing Interapplication Communication in Android</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erika</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adrienne</forename><forename type="middle">Porter</forename><surname>Felt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kate</forename><surname>Greenwood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Wagner</surname></persName>
		</author>
		<idno type="doi">978-1-4503-0643-0.doi:10.1145/1999995.2000018</idno>
		<ptr target="http://doi.acm.org/10.1145/1999995.2000018" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International Conference on Mobile Systems, Applications, and Services, MobiSys &apos;11</title>
		<meeting>the 9th International Conference on Mobile Systems, Applications, and Services, MobiSys &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="239" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">CHEX: Statically Vetting Android Apps for Component Hijacking Vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Long</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhichun</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhenyu</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenke</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guofei</forename><surname>Jiang</surname></persName>
		</author>
		<idno type="doi">978-1-4503-1651-4.doi:10.1145/2382196.2382223</idno>
		<ptr target="http://doi.acm.org/10.1145/2382196.2382223" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 ACM Conference on Computer and Communications Security, CCS &apos;12</title>
		<meeting>the 2012 ACM Conference on Computer and Communications Security, CCS &apos;12<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="229" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Reducing Attack Surfaces for Intraapplication Communication in Android</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kantola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erika</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Warren</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Wagner</surname></persName>
		</author>
		<idno type="doi">978-1-4503-1666-8.doi:10.1145/2381934.2381948</idno>
		<ptr target="http://doi.acm.org/10.1145/2381934.2381948" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second ACM Workshop on Security and Privacy in Smartphones and Mobile Devices, SPSM &apos;12</title>
		<meeting>the Second ACM Workshop on Security and Privacy in Smartphones and Mobile Devices, SPSM &apos;12<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="69" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">TaintDroid: An Informationflow Tracking System for Realtime Privacy Monitoring on Smartphones</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Byung-Gon</forename><surname>Chun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Landon</forename><forename type="middle">P</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jaeyeon</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Mcdaniel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anmol</forename><forename type="middle">N</forename><surname>Sheth</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=1924943" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;10</title>
		<meeting>the 9th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;10<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Overtaking Firefox Profiles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roee</forename><surname>Hay</surname></persName>
		</author>
		<ptr target="http://slidesha.re/1gqiyD3" />
		<imprint>
			<date type="published" when="2014-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Remote Exploitation of the Cordova Framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roee</forename><surname>Hay</surname></persName>
		</author>
		<ptr target="http://www.slideshare.net/ibmsecurity/remote-exploitation-of-the-cordova-framework" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Android Collapses into Fragments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roee</forename><surname>Hay</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-12" />
		</imprint>
	</monogr>
	<note>URL https</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Attacking the Linux PRNG On Android</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sagi</forename><surname>Kedmi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roee</forename><surname>Hay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Avi</forename><surname>Dayan</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/conference/woot14/workshop-program/presentation/kaplan" />
	</analytic>
	<monogr>
		<title level="m">8th USENIX Workshop on Offensive Technologies, WOOT &apos;14</title>
		<meeting><address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-08-19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Remote Exploitation of the Dropbox SDK for Android</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roee</forename><surname>Hay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Or</forename><surname>Peles</surname></persName>
		</author>
		<ptr target="http://www.slideshare.net/ibmsecurity/remote-exploitation-of-the-dropbox-sdk-for-android" />
		<imprint>
			<date type="published" when="2015-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">IBM X-Force Threat Intelligence Quarterly</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roee</forename><surname>Hay</surname></persName>
		</author>
		<idno>1Q 2015</idno>
		<ptr target="http://ibm.co/1wEMKV3" />
		<imprint>
			<date type="published" when="2015-03" />
		</imprint>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Attacking Android browsers via intent scheme URLs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Takeshi</forename><surname>Terada</surname></persName>
		</author>
		<ptr target="http://www.mbsd.jp/Whitepaper/IntentScheme.pdf" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jann</forename><surname>Horn</surname></persName>
		</author>
		<idno>CVE-2014-7911: Android &lt;5.0</idno>
		<ptr target="http://seclists.org/fulldisclosure/2014/Nov/51" />
		<title level="m">Privilege Escalation using ObjectInputStream, November</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">CVE-2014-7911 -A Deep Dive Analysis of Android System Service Vulnerability and Exploitation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yaron</forename><surname>Lavi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadav</forename><surname>Markus</surname></persName>
		</author>
		<ptr target="http://bit.ly/1Q7pdzT" />
		<imprint>
			<date type="published" when="2015-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">From Zygote to Morula: Fortifying Weakened ASLR on Android</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Byoungyoung</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Long</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tielei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenke</forename><surname>Lee</surname></persName>
		</author>
		<idno type="doi">978-1-4799-4686-0.doi:10.1109/SP.2014.34</idno>
		<ptr target="http://dx.doi.org/10.1109/SP.2014.34" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 IEEE Symposium on Security and Privacy, SP &apos;14</title>
		<meeting>the 2014 IEEE Symposium on Security and Privacy, SP &apos;14<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="424" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Security-Enhanced Linux in Android</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Android</surname></persName>
		</author>
		<ptr target="http://source.android.com/devices/tech/security/selinux/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Caches and SelfModifying Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><surname>Bramley</surname></persName>
		</author>
		<ptr target="http://community.arm.com/groups/processors/blog/2010/02/17/caches-and-self-modifying-code" />
		<imprint>
			<date type="published" when="2010-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Michal Krenek. setools-android with sepolicy-inject</title>
		<ptr target="http" />
		<imprint>
			<date type="published" when="2014-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">PoC: Function Pointer Protection in C Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Rattger</surname></persName>
		</author>
		<ptr target="http://gcc.gnu.org/ml/gcc/2013-08/msg00224.html/" />
		<imprint>
			<date type="published" when="2013-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">What Android 5.0&apos;s Auto-Updating WebView Means for Mobile Apps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Vantoll</surname></persName>
		</author>
		<ptr target="http://bit.ly/1DqQ4RC" />
		<imprint>
			<date type="published" when="2014-11" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
