<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:53+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scalability! But at what COST?</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Mcsherry</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Isard</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Derek</forename><forename type="middle">G</forename><surname>Murray</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Unaffiliated</forename><surname>Unaffiliated</surname></persName>
						</author>
						<author>
							<affiliation>
								<orgName>Unaffiliated †</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Scalability! But at what COST?</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We offer a new metric for big data platforms, COST, or the Configuration that Outperforms a Single Thread. The COST of a given platform for a given problem is the hardware configuration required before the platform out-performs a competent single-threaded implementation. COST weighs a system&apos;s scalability against the overheads introduced by the system, and indicates the actual performance gains of the system, without rewarding systems that bring substantial but parallelizable overheads. We survey measurements of data-parallel systems recently reported in SOSP and OSDI, and find that many systems have either a surprisingly large COST, often hundreds of cores, or simply underperform one thread for all of their reported configurations.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>"You can have a second computer once you've shown you know how to use the first one."</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>-Paul Barham</head><p>The published work on big data systems has fetishized scalability as the most important feature of a distributed data processing platform. While nearly all such publications detail their system's impressive scalability, few directly evaluate their absolute performance against reasonable benchmarks. To what degree are these systems truly improving performance, as opposed to parallelizing overheads that they themselves introduce?</p><p>Contrary to the common wisdom that effective scaling is evidence of solid systems building, any system can scale arbitrarily well with a sufficient lack of care in its implementation. The two scaling curves in <ref type="figure">Figure 1</ref> present the scaling of a Naiad computation before (system A) and after (system B) a performance optimization is applied. The optimization, which removes parallelizable overheads, damages the apparent scalability despite resulting in improved performance in all configurations. * Michael Isard was employed by Microsoft Research at the time of his involvement, but is now unaffiliated. † Derek G. Murray was unaffiliated at the time of his involvement, but is now employed by Google Inc. Figure 1: Scaling and performance measurements for a data-parallel algorithm, before (system A) and after (system B) a simple performance optimization. The unoptimized implementation "scales" far better, despite (or rather, because of) its poor performance.</p><p>While this may appear to be a contrived example, we will argue that many published big data systems more closely resemble system A than they resemble system B.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Methodology</head><p>In this paper we take several recent graph processing papers from the systems literature and compare their reported performance against simple, single-threaded implementations on the same datasets using a high-end 2014 laptop. Perhaps surprisingly, many published systems have unbounded COST-i.e., no configuration outperforms the best single-threaded implementation-for all of the problems to which they have been applied. The comparisons are neither perfect nor always fair, but the conclusions are sufficiently dramatic that some concern must be raised. In some cases the singlethreaded implementations are more than an order of magnitude faster than published results for systems using hundreds of cores. We identify reasons for these gaps: some are intrinsic to the domain, some are entirely avoidable, and others are good subjects for further research.</p><p>We stress that these problems lie not necessarily with the systems themselves, which may be improved with time, but rather with the measurements that the authors provide and the standard that reviewers and readers demand. Our hope is to shed light on this issue so that future research is directed toward distributed systems whose scalability comes from advances in system design rather than poor baselines and low expectations. name twitter rv <ref type="bibr" target="#b9">[13]</ref>  <ref type="table" target="#tab_0">uk-2007-05 [5, 6]  nodes  41,652,230  105,896,555  edges 1,468,365,182</ref> 3,738,733,648 size 5.76GB 14.72GB <ref type="table">Table 1</ref>: The "twitter rv" and "uk-2007-05" graphs. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Basic Graph Computations</head><p>Graph computation has featured prominently in recent SOSP and OSDI conferences, and represents one of the simplest classes of data-parallel computation that is not trivially parallelized. Conveniently, Gonzalez et al. <ref type="bibr" target="#b6">[10]</ref> evaluated the latest versions of several graph-processing systems in 2014. We implement each of their tasks using single-threaded C# code, and evaluate the implementations on the same datasets they use (see <ref type="table">Table 1</ref>). <ref type="bibr">1</ref> Our single-threaded implementations use a simple Boost-like graph traversal pattern. A GraphIterator type accepts actions on edges, and maps the action across all graph edges. The implementation uses unbuffered IO to read binary edge data from SSD and maintains pernode state in memory backed by large pages (2MB).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">PageRank</head><p>PageRank is an computation on directed graphs which iteratively updates a rank maintained for each vertex <ref type="bibr" target="#b15">[19]</ref>. In each iteration a vertex's rank is uniformly divided among its outgoing neighbors, and then set to be the accumulation of scaled rank from incoming neighbors. A dampening factor alpha is applied to the ranks, the lost rank distributed uniformly among all nodes. <ref type="figure" target="#fig_1">Figure 2</ref> presents code for twenty PageRank iterations.</p><p>scalable system cores twitter uk-2007-05 GraphChi <ref type="bibr" target="#b8">[12]</ref> 2 3160s 6972s Stratosphere <ref type="bibr" target="#b4">[8]</ref> 16 2250s -X-Stream <ref type="bibr" target="#b17">[21]</ref> 16 1488s -Spark <ref type="bibr" target="#b6">[10]</ref> 128 857s 1759s Giraph <ref type="bibr" target="#b6">[10]</ref> 128 596s 1235s GraphLab <ref type="bibr" target="#b6">[10]</ref> 128 249s 833s GraphX <ref type="bibr" target="#b6">[10]</ref> 128 419s 462s Single thread (SSD) 1 300s 651s Single thread (RAM) 1 275s -   <ref type="table" target="#tab_0">Table 2</ref> compares the reported times from several systems against a single-threaded implementations of PageRank, reading the data either from SSD or from RAM. Other than GraphChi and X-Stream, which reread edge data from disk, all systems partition the graph data among machines and load it in to memory. Other than GraphLab and GraphX, systems partition edges by source vertex; GraphLab and GraphX use more sophisticated partitioning schemes to reduce communication.</p><p>No scalable system in <ref type="table" target="#tab_0">Table 2</ref> consistently outperforms a single thread, even when the single thread repeatedly re-reads the data from external storage. Only GraphLab and GraphX outperform any single-threaded executions, although we will see in Section 3.1 that the single-threaded implementation outperforms these systems once it re-orders edges in a manner akin to the partitioning schemes these systems use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Connected Components</head><p>The connected components of an undirected graph are disjoint sets of vertices such that all vertices within a set scalable system cores twitter uk-2007-05 Stratosphere <ref type="bibr" target="#b4">[8]</ref> 16 950s -X-Stream <ref type="bibr" target="#b17">[21]</ref> 16 1159s -Spark <ref type="bibr" target="#b6">[10]</ref> 128 1784s ≥ 8000s Giraph <ref type="bibr" target="#b6">[10]</ref> 128 200s ≥ 8000s GraphLab <ref type="bibr" target="#b6">[10]</ref> 128 242s 714s GraphX <ref type="bibr" target="#b6">[10]</ref> 128 251s 800s Single thread (SSD) 1 153s 417s <ref type="table">Table 3</ref>: Reported elapsed times for label propagation, compared with measured times for singlethreaded label propagation from SSD.</p><p>are mutually reachable from each other.</p><p>In the distributed setting, the most common algorithm for computing connectivity is label propagation <ref type="bibr" target="#b7">[11]</ref> ( <ref type="figure" target="#fig_2">Figure 3)</ref>. In label propagation, each vertex maintains a label (initially its own ID), and iteratively updates its label to be the minimum of all its neighbors' labels and its current label. The process propagates the smallest label in each component to all vertices in the component, and the iteration converges once this happens in every component. The updates are commutative and associative, and consequently admit a scalable implementation <ref type="bibr" target="#b3">[7]</ref>. <ref type="table">Table 3</ref> compares the reported running times of label propagation on several data-parallel systems with a single-threaded implementation reading from SSD. Despite using orders of magnitude less hardware, singlethreaded label propagation is significantly faster than any system above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Better Baselines</head><p>The single-threaded implementations we have presented were chosen to be the simplest, most direct implementations we could think of. There are several standard ways to improve them, yielding single-threaded implementations which strictly dominate the reported performance of the systems we have considered, in some cases by an additional order of magnitude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Improving graph layout</head><p>Our single-threaded algorithms take as inputs edge iterators, and while they have no requirements on the order in which edges are presented, the order does affect performance. Up to this point, our single-threaded implementations have enumerated edges in vertex order, whereby all edges for one vertex are presented before moving on to the next vertex. Both GraphLab and GraphX instead partition the edges among workers, without requiring that all edges from a single vertex belong to the same  worker, which enables those systems to exchange less data <ref type="bibr" target="#b5">[9,</ref><ref type="bibr" target="#b6">10]</ref>. A single-threaded graph algorithm does not perform explicit communication, but edge ordering can have a pronounced effect on the cache behavior. For example, the edge ordering described by a Hilbert curve <ref type="bibr">[2]</ref>, akin to ordering edges (a, b) by the interleaving of the bits of a and b, exhibits locality in both a and b rather than just a as in the vertex ordering. <ref type="table" target="#tab_2">Table 4</ref> compares the running times of single-threaded PageRank with edges presented in Hilbert curve order against other implementations, where we see that it improves over all of them.</p><p>Converting the graph data to a Hilbert curve order is an additional cost in pre-processing the graph. The process amounts to transforming pairs of node identifiers (edges) into an integer of twice as many bits, sorting these values, and then transforming back to pairs of node identifiers. Our implementation transforms the twitter rv graph in 179 seconds using one thread, which can be a performance win even if pre-processing is counted against the running time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Improving algorithms</head><p>The problem of properly choosing a good algorithm lies at the heart of computer science. The label propagation algorithm is used for graph connectivity not because it is a good algorithm, but because it fits within the "think like a vertex" computational model <ref type="bibr" target="#b11">[15]</ref>, whose implementations scale well. Unfortunately, in this case (and many others) the appealing scaling properties are largely due to the algorithm's sub-optimality; label propagation simply does more work than better algorithms.</p><p>Consider the algorithmic alternative of Union-Find with weighted union <ref type="bibr">[3]</ref>, a simple O(m log n) algorithm which scans the graph edges once and maintains two integers for each graph vertex, as presented in <ref type="figure" target="#fig_3">Figure 4</ref>.   mentations of label propagation, faster than the fastest of them (the single-threaded implementation) by over an order of magnitude.</p><p>There are many other efficient algorithms for computing graph connectivity, several of which are parallelizable despite not fitting in the "think like a vertex" model. While some of these algorithms may not be the best fit for a given distributed system, they are still legitimate alternatives that must be considered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Applying COST to prior work</head><p>Having developed single-threaded implementations, we now have a basis for evaluating the COST of systems. As an exercise, we retrospectively apply these baselines to the published numbers for existing scalable systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">PageRank</head><p>Figure 5 presents published scaling information from PowerGraph <ref type="bibr" target="#b5">[9]</ref>, GraphX <ref type="bibr" target="#b6">[10]</ref>, and Naiad <ref type="bibr" target="#b12">[16]</ref>, as well as two single-threaded measurements as horizontal lines. The intersection with the upper line indicates the point at which the system out-performs a simple resourceconstrained implementation, and is a suitable baseline for systems with similar limitations (e.g., GraphChi and X-Stream). The intersection with the lower line indicates the point at which the system out-performs a feature-rich implementation, including pre-processing and sufficient  memory, and is a suitable baseline for systems with similar resources (e.g., GraphLab, Naiad, and GraphX). From these curves we would say that Naiad has a COST of 16 cores for PageRanking the twitter rv graph.</p><p>Although not presented as part of their scaling data, GraphLab reports a 3.6s measurement on 512 cores, and achieves a COST of 512 cores. GraphX does not intersect the corresponding single-threaded measurement, and we would say it has unbounded COST.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Graph connectivity</head><p>The published works do not have scaling information for graph connectivity, but given the absolute performance of label propagation on the scalable systems relative to single-threaded union-find we are not optimistic that such scaling data would have lead to a bounded COST.</p><p>Instead, <ref type="figure" target="#fig_5">Figure 6</ref> presents the scaling of two Naiad implementations of parallel union-find <ref type="bibr" target="#b10">[14]</ref>, the same examples from <ref type="figure">Figure 1</ref>. The two implementations differ in their storage of per-vertex state: the slower one uses hash tables where the faster one uses arrays. The faster implementation has a COST of 10 cores, while the slower implementation has a COST of roughly 100 cores.</p><p>The use of hash tables is the root cause of the factor of ten increase in COST, but it does provide some value: node identifiers need not lie in a compact set of integers. This evaluation makes the trade-off clearer to both system implementors and potential users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Lessons learned</head><p>Several aspects of scalable systems design and implementation contribute to overheads and increased COST. The computational model presented by the system restricts the programs one may express. The target hardware may reflect different trade-offs, perhaps favoring capacity and throughput over high clock frequency. Finally, the implementation of the system may add overheads a single thread doesn't require. Understanding each of these overheads is an important part of assessing the capabilities and contributions of a scalable system.</p><p>To achieve scalable parallelism, big data systems restrict programs to models in which the parallelism is evident. These models may not align with the intent of the programmer, or the most efficient parallel implementations for the problem at hand. Map-Reduce intentionally precludes memory-resident state in the interest of scalability, leading to substantial overhead for algorithms that would benefit from it. Pregel's "think like a vertex" model requires a graph computation to be cast as an iterated local computation at each graph vertex as a function of the state of its neighbors, which captures only a limited subset of efficient graph algorithms. Neither of these designs are the "wrong choice", but it is important to distinguish "scalability" from "efficient use of resources". The cluster computing environment is different from the environment of a laptop. The former often values high capacity and throughput over latency, with slower cores, storage, and memory. The laptop now embodies the personal computer, with lower capacity but faster cores, storage, and memory. While scalable systems are often a good match to cluster resources, it is important to consider alternative hardware for peak performance.</p><p>Finally, the implementation of the system may introduce overheads that conceal the performance benefits of a scalable system. High-level languages may facilitate development, but they can introduce performance issues (garbage collection, bounds checks, memory copies). It is especially common in a research setting to evaluate a new idea with partial or primitive implementations of other parts of the system (serialization, memory management, networking), asserting that existing techniques will improve the performance. While many of these issues might be improved with engineering effort that does not otherwise advance research, nonetheless it can be very difficult to assess whether the benefits the system claims will still manifest once the fat is removed.</p><p>There are many good reasons why a system might have a high COST when compared with the fastest purpose-built single-threaded implementation. The system may target a different set of problems, be suited for a different deployment, or be a prototype designed to assess components of a full system. The system may also provide other qualitative advantages, including integration with an existing ecosystem, high availability, or security, that a simpler solution cannot provide. As Section 4 demonstrates, it is nonetheless important to evaluate the COST, both to explain whether a high COST is intrinsic to the proposed system, and because it can highlight avoidable inefficiencies and thereby lead to performance improvements for the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Future directions (for the area)</head><p>While this note may appear critical of research in distributed systems, we believe there is still good work to do, and our goal is to provide a framework for measuring and making the best forward progress.</p><p>There are numerous examples of scalable algorithms and computational models; one only needs to look back to the parallel computing research of decades past. Borůvka's algorithm <ref type="bibr">[1]</ref> is nearly ninety years old, parallelizes cleanly, and solves a more general problem than label propagation. The Bulk Synchronous Parallel model <ref type="bibr" target="#b20">[24]</ref> is surprisingly more general than most related work sections would have you believe. These algorithms and models are richly detailed, analyzed, and in many cases already implemented.</p><p>Many examples of performant scalable systems exist. Both Galois <ref type="bibr" target="#b13">[17]</ref> and Ligra <ref type="bibr" target="#b19">[23]</ref> are shared-memory systems that significantly out-perform their distributed peers when run on single machines. Naiad <ref type="bibr" target="#b12">[16]</ref> introduces a new general purpose dataflow model, and out-performs even specialized systems. Understanding what these systems did right and how to improve them is more important than re-hashing existing ideas in new domains compared against only the poorest of prior work.</p><p>We are now starting to see performance studies of the current crop of scalable systems <ref type="bibr" target="#b14">[18]</ref>, challenging some conventional wisdom underlying their design principles. Similar such studies have come from previous generations of systems <ref type="bibr" target="#b18">[22]</ref>, including work explicitly critical of the absolute performance of scalable systems as compared with simpler solutions <ref type="bibr" target="#b16">[20,</ref><ref type="bibr" target="#b0">4,</ref><ref type="bibr" target="#b21">25]</ref>. While it is surely valuable to understand and learn from the performance of popular scalable systems, we might also learn that we keep making, and publishing, the same mistakes.</p><p>Fundamentally, a part of good research is making sure we are asking the right questions. "Can systems be made to scale well?" is trivially answered (in the introduction) and is not itself the right question. There is a substantial amount of good research to do, but identifying progress requires being more upfront about existing alternatives. The COST of a scalable system uses the simplest of alternatives, but is an important part of understanding and articulating progress made by research on these systems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Twenty PageRank iterations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Label propagation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Union-Find with weighted union.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Published scaling measurements for PageRank on twitter rv. The first plot is the time per warm iteration. The second plot is the time for ten iterations from a cold start. Horizontal lines are singlethreaded measurements.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Two Naiad implementations of union find.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Reported elapsed times for 20 PageRank it-
erations, compared with measured times for single-
threaded implementations from SSD and from RAM. 
GraphChi and X-Stream report times for 5 Page-
Rank iterations, which we multiplied by four. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 4 :</head><label>4</label><figDesc></figDesc><table>Reported elapsed times for 20 PageRank it-
erations, compared with measured times for single-
threaded implementations from SSD and from RAM. 
The single-threaded times use identical algorithms, 
but with different edge orders. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 5 reports its performance compared with imple-</head><label>5</label><figDesc></figDesc><table>scalable system 

cores twitter uk-2007-05 
GraphLab 
128 
242s 
714s 
GraphX 
128 
251s 
800s 
Single thread (SSD) 
1 
153s 
417s 
Union-Find (SSD) 
1 
15s 
30s 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 5 :</head><label>5</label><figDesc></figDesc><table>Times for various connectivity algorithms. 

</table></figure>

			<note place="foot" n="1"> Our C# implementations required some manual in-lining, and are less terse than our Rust implementations. In the interest of clarity, we present the latter in this paper. Both versions of the code produce comparable results, and will be made available online.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Efficiency Matters! HotStorage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Tucek</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The WebGraph Framework I: Compression Techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastiano</forename><surname>Vigna</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<publisher>WWW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">UbiCrawler: A Scalable Fully Distributed Web Crawler Software: Practice &amp; Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Boldi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruno</forename><surname>Codenotti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Massimo</forename><surname>Santini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastiano</forename><surname>Vigna</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Austin</forename><forename type="middle">T</forename><surname>Clements</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Frans</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nickolai</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">T</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eddie</forename><surname>Kohnler</surname></persName>
		</author>
		<title level="m">The Scalable Commutativity Rule: Designing Scalable Software for Multicore Processors. SOSP</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Spinning Fast Iterative Data Flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephan</forename><surname>Ewen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moritz</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kostas</forename><surname>Tzoumas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Volker</forename><surname>Markl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">PowerGraph: Distributed Graph-Parallel Computation on Natural Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">E</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yucheng</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haijie</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danny</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">GraphX: Graph Processing in a Distributed Dataflow Framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">E</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reynold</forename><forename type="middle">S</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ankur</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Crankshaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ion</forename><surname>Stoica</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">PEGASUS: Mining Peta-Scale Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charalampos</forename><forename type="middle">E</forename><surname>Tsourakakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christos</forename><surname>Faloutsos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">GraphChi: Large-Scale Graph Computation on Just a PC</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aapo</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guy</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">What is Twitter</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haewoon</forename><surname>Kwak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Changhyun</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hosung</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sue</forename><surname>Moon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<publisher>WWW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Filtering: A Method for Solving Graph Problems in MapReduce</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Silvio</forename><surname>Lattanzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Moseley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Siddharth</forename><surname>Suri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergei</forename><surname>Vassilvitskii</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Pregel: A System for Large-Scale Graph Processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Grzegorz</forename><surname>Malewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><forename type="middle">H</forename><surname>Austern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Aart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">C</forename><surname>Bik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilan</forename><surname>Dehnert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Naty</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Grzegorz</forename><surname>Leiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Czajkowski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>SIGMOD</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Naiad: A Timely Dataflow System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Derek</forename><forename type="middle">G</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Mcsherry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rebecca</forename><surname>Isaacs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martín</forename><surname>Abadi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Lightweight Infrastructure for Graph Analytics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Lenharth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SOSP</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Making Sense of Performance in Data Analytics Frameworks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kay</forename><surname>Ousterhout</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Rasti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">?</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sylvia</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Byung-Gon</forename><surname>Chun</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The PageRank citation ranking: Bringing order to the web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lawrence</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergey</forename><surname>Brin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terry</forename><surname>Winograd</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
		<respStmt>
			<orgName>Stanford Digital Library Technologies Project</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">TritonSort: A Balanced Large-Scale Sorting System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Rasmussen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Conley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Harsha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Madhyastha Radhika Niranjan Mysore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amin</forename><surname>Pucher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vahdat</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">XStream: Edge-Centric Graph Processing using Streaming Partitions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amitabha</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ivo</forename><surname>Mihailovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Willy</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SOSP</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mehul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hellerstein</surname></persName>
		</author>
		<title level="m">Java Support for Data-Intensive Systems: Experiences Building the Telegraph Dataflow System. SIGMOD Record</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Ligra: A Lightweight Graph Processing Framework for Shared Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julian</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guy</forename><surname>Blelloch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PPoPP</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A bridging model for parallel computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leslie</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<date type="published" when="1990-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">DimmWitted: A Study of MainMemory Statistical Analytics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ce</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Ré</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
