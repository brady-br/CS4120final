<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:03+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Synoptic: Summarizing System Logs with Refinement</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sigurd</forename><surname>Schneider</surname></persName>
							<email>sigurd@ps.uni-saarland.de</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science</orgName>
								<orgName type="institution">Saarland University † Computer Science &amp; Engineering University of Washington ‡ Google, Inc</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ivan</forename><surname>Beschastnikh</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science</orgName>
								<orgName type="institution">Saarland University † Computer Science &amp; Engineering University of Washington ‡ Google, Inc</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Slava</forename><surname>Chernyak</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science</orgName>
								<orgName type="institution">Saarland University † Computer Science &amp; Engineering University of Washington ‡ Google, Inc</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science</orgName>
								<orgName type="institution">Saarland University † Computer Science &amp; Engineering University of Washington ‡ Google, Inc</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuriy</forename><surname>Brun</surname></persName>
							<email>brun@cs.washington.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science</orgName>
								<orgName type="institution">Saarland University † Computer Science &amp; Engineering University of Washington ‡ Google, Inc</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Synoptic: Summarizing System Logs with Refinement</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Distributed systems are often difficult to debug and understand. A typical way of gaining insight into system behavior is by inspecting execution logs. However, manual inspection of logs is an arduous process. To support this task we developed Synoptic. Synoptic outputs a concise graph representation of logged events that captures temporal invariants mined from the log. We applied Synoptic to synthetic and real distributed system logs and found that it augmented a distributed system designer&apos;s understanding of system behavior with reasonable overhead for an offline analysis tool. In contrast to prior approaches, Synoptic uses a combination of refinement and coarsening to explore the space of representations. Additionally, it infers temporal event in-variants to capture distributed system semantics. These invariants drive the exploration process and are satisfied by the final representation.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Debugging distributed systems remains a significant challenge for developers who typically try to make sense of their systems by analyzing execution logs. However, even a small system with a few nodes running a distributed protocol, such as two-phase commit <ref type="bibr" target="#b14">[15]</ref> or Paxos <ref type="bibr" target="#b20">[22]</ref>, can generate thousands of messages in just a few minutes of execution. Manual inspection of logs scales poorly, and a developer may easily miss an important system behavior. This paper presents Synoptica tool that summarizes system execution logs to support developer understanding of system behavior.</p><p>We approach the problem of understanding a system from its logs as a summarization and data-reduction challenge. Synoptic treats an input log as a set of event instances that can be grouped into event classes. Events may be related by a user-defined relation, such as time. Synoptic's goal is to produce a minimal relation graph with nodes representing sets of events and edges connecting nodes for which the user-defined relation holds. <ref type="figure" target="#fig_1">Figure 1</ref> shows two Synoptic representations for a log containing two-phase commit protocol messages. This figure also illustrates two strategies for finding an appropriate summary log representation -refinement and coarsening. Synoptic mines a set of invariants in the form  : Two example representations of a two-node twophase commit log. Arrows represent temporal ordering. Rhombus nodes are start states -that is, initial events. Coarsening can convert the left graph into the right one, which is smaller but admits more behaviors. Refinement is the dual of coarsening. Coarsening is the traditional approach to log summarization; this paper shows the benefits of refinement.</p><p>of LTL expressions from the log (e.g., Abort AlwaysFollowedBy TX Abort, in <ref type="figure" target="#fig_1">Figure 1</ref>), and uses model checking to enforce these invariants while exploring the representation space. This results in representations that retain the rich distributed system semantics present in the log.</p><p>Some prior work uses an FSM model to represent events as transitions and a coarsening procedure to derive a compact model. Synoptic differs in three ways, the latter two of which are novel to our work. (1) Synoptic uses a relational model to represent events as nodes in a graph. This better fits the log analysis domain. (2) Synoptic mines temporal invariants from the log to formulate intuitive event (dis-)similarity metrics and stopping conditions. This produces a smaller model that captures behavior better. (3) Synoptic utilizes both refinement and coarsening on the model. This improves efficiency by avoiding repeated operations on large data structures.</p><p>We applied Synoptic to real and synthetic logs of distributed systems. Compared to kTail <ref type="bibr" target="#b1">[2]</ref>, a popular coarsening algorithm, Synoptic produced smaller summarizations while preserving more key properties of the event log. Compared to a kTail version modified to preserve invariants, Synoptic has substantially better runtime performance. In a user study, Synoptic's output matched the mental model of a distributed systems developer and reminded him of specific corner-case design choices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Approaching the Representations Space</head><p>Synoptic addresses the problem of finding a compact representation that summarizes a sequence of events logged by a distributed system. The notion of "event" depends on the system -events may be sent and received messages, local procedure invocations, debug output, or a combination of all of these. To run Synoptic, a user must (1) specify one or more partial orderings on the events (e.g., time) and (2) provide a way for Synoptic to identify events of the same class (e.g., message name).</p><p>Conceptually, the summarization problem can be broken down into two sub-problems -what type of representation model to use (Section 2.1) and how to explore the space of potential representations (Section 2.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Choice of Model</head><p>Synoptic uses a relational model. This section briefly overviews the advantages and disadvantages of statebased models, Petri nets, and the relational model. Space prevents us from discussing other potential models, such as HMMs <ref type="bibr" target="#b3">[4]</ref>.</p><p>State-based model. Distributed systems developers often structure node logic as a finite state machine (FSM) in which nodes represent system states <ref type="bibr" target="#b29">[31,</ref><ref type="bibr" target="#b4">5]</ref>. Although the FSM model is widely used, it is overly complex in our context because it forces an exploration algorithm to reason about system state. Events that appear in the log may indicate that the system is in a particular state, but we cannot assume that the log contains explicit state information. Reasoning about states detracts from the ultimate purpose of finding a representation that compactly summarizes the log.</p><p>Petri nets. Petri nets <ref type="bibr" target="#b26">[28]</ref> provide a formal means to model and reason about concurrent systems. Their main advantage over FSMs is their explicit representation of concurrency and associated concepts like mutual exclusion. However, Petri nets are more difficult to understand and generate than FSMs and, in our experiments, the ability to express explicit concurrency did not improve the summarizations.</p><p>Relational model. The relational model captures possibly multiple relations between log events. For example, events may be related temporally, with the happenedbefore relation <ref type="bibr" target="#b19">[21]</ref>, or physically, by co-occurring at the same node. This model can be visualized as a graph in which each vertex represents a set of log events. A directed edge between two vertices indicates that the contained log events are related. Based on user feedback in a study we carried out (see Section 5.3) we have found this model to be the most appropriate for capturing log summaries. In addition, this model resembles a modal transition system, which is a natural fit for reasoning about temporal invariants between events. Finally, this model can represent multiple relations simultaneously (e.g., graphically by using edges of different colors/labels) and, unlike the state-based model, it makes minimal assumptions about the underlying process that produced the log events. In the rest of the paper, unless otherwise specified, we will assume a relational model. The choice of model constrains how the exploration algorithm proceeds. It does not, however, severely limit the final representation shown to the user. For instance, we successfully experimented with mappings between the relational and state-based models, that make it possible to automatically convert representations between subsets of the two model types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Exploring the Space</head><p>Now that we have decided to use the relational model, we must decide how to explore the large space of potential representations. We represent the relational model as a graph (V, E), such that V contains partitions, i.e., sets of events, and E ⊆ V ×V × R is a set of directed edges with labels from R, the set of available event relations. In the following, we use the term graph to mean this graph representation of the model.</p><p>Prior work in automata inference has used graph coarsening, which iteratively compresses a representation of the concrete trace by merging states in the FSM <ref type="bibr" target="#b1">[2]</ref>. An alternate strategy is to perform graph refinement from an initial representation that consists of a single state. We now explain these two exploration directions in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Direction of Exploration</head><p>The space of potential representations can be explored using two dual operations: refinement and coarsening. These are illustrated in <ref type="figure" target="#fig_1">Figure 1</ref>.</p><p>Graph Coarsening. A step of graph coarsening produces a graph with fewer partitions than the previous graph. This new graph is produced by identifying at least two partitions containing similar information, and merging them. There exist a variety of partition similarity notions, such as behavioral and structural similarity.</p><p>Graph Refinement. A step of graph refinement produces a graph with at least one more partition than the prior graph. This new graph is produced by identifying a partition with events that are dis-similar enough to warrant separation of the events into different partitions.</p><p>Direction monotonicity. We call an algorithm that explore the space of representation in a single direction monotonic. The kTail algorithm <ref type="bibr" target="#b1">[2]</ref> is a popular example of a monotonic coarsening algorithm. It typically starts from a graph in which each event (not event class) is mapped to its own partition, which embodies the starting assumption that all log events are different. In the simplest case, a monotonic refinement algorithm could start from a single-node graph, which embodies the starting assumption that all events are the same.</p><p>The rest of this paper focuses on two summarization algorithms. The first is Bisim, a monotonic refinement algorithm. The second is BisimH, a hybrid, non-monotonic algorithm that combines Bisim with kTail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Guiding the Exploration with Policies</head><p>Two policies, termination and operation selection, induce a wide variety of exploration algorithms.</p><p>Termination Policy. An exploration algorithm must specify when a representation is considered final and no more coarsening/refinement exploration is performed.</p><p>Operation Selection Policy. Operation selection has two dimensions: (1) identifying candidate operations and (2) selecting a candidate as the next step. An operation either merges partitions or splits an existing partition.</p><p>To identify candidate operations, a summarization algorithm must determine whether two events are similar enough to warrant their representation as a single node and, when necessary, issue split/merge operations. This process crucially depends on the notion of similarity. If similarity is too fine-grained, the resulting representation will not be concise. If it is too coarse, the resulting graph might admit many spurious traces. If it is not an equivalence relation, the merge operation becomes nonassociative, and the result not only depends on the operations made, but also on their order. For example, GK-Tail as specified in <ref type="bibr" target="#b22">[24]</ref> is nondeterministic, because the output depends on the (unspecified) order of the operations.</p><p>Among all candidate operations, exactly one must be chosen for immediate processing. For example, consider the graph at E4 in <ref type="figure" target="#fig_5">Figure 8</ref> (on the last page). Three splits are possible: two (edge 1,4 and edge 3,5) split partition A and one (edge 2) splits partition C. Thus, a graph exploration algorithm must define a policy that dictates which operation should be performed next.</p><p>We can express kTail <ref type="bibr" target="#b1">[2]</ref> in our relational model in terms of the above two policies. kTail is a coarsening algorithm that starts with the most fine-grained representation. The termination policy is to stop once there is no pair of k-equivalent partitions, i.e., no two partitions that are roots of sub-graphs identical up to depth k. The operation selection policy merges any pair of k-equivalent partitions, chosen nondeterministically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Bisim and BisimH Algorithms</head><p>Synoptic can use two algorithms to summarize a log. We first introduce the Bisim algorithm, a monotonic refinement algorithm. Then we present a key deficiency in Bisim to motivate BisimH, which is a hybrid algorithm combining Bisim and kTail to explore the space of representations non-monotonically.</p><p>1 Input: event log L 2 let initialGraph = extract(L) 3 let I = mineInvariants(initialGraph) 4 let (V, E) = partition(initialGraph) 5 while (V, E) does not satisfy invariants I 6 // p: event → boolean, π: partition that will be split</p><formula xml:id="formula_0">7 let (p, π) = selectSplit((V, E), I) 8 let π 1 = {event ∈ π | p(event)} 9 let π 2 = {event ∈ π | ¬p(event)} 10 V := (V − {π}) ∪ {π 1 , π 2 } 11 E := {(π 3 , π 4 , r) ∈ V ×V × R | ∃ event 1 ∈ π 3 , ∃ event 2 ∈ π 4 12</formula><p>: event 1 r event 2 ∈ initialGraph} 13 end while 14 if (hybrid) 15</p><formula xml:id="formula_1">(V, E) := kTail((V, E), 0, I) 16 Output: (V, E)</formula><p>Figure 2: The Bisim/BisimH algorithm, depending on the value of hybrid. The procedures extract, mineInvariants, and partition are described in Section 3.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Bisim Algorithm</head><p>We developed Bisim, a bisimulation-inspired algorithm that combines partition refinement <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b24">26]</ref> with model checking. Bisim is novel in finding a compact representation that satisfies a set of temporal relations from the event log. <ref type="figure">Figure 2</ref> shows the Bisim pseudo-code, which involves four steps.</p><p>1. extract(), on line 2, creates an initial graph (step (b) in <ref type="figure" target="#fig_5">Figure 8</ref>) from the execution log. This graph contains a singleton partition for each event instance, and a directed edge between partitions that satisfy the partial ordering relation provided by the user.</p><p>2. mineInvariants(), on line 3, mines event relations listed in <ref type="figure">Figure 3</ref> from the initial graph. We term these relations "invariants" because they succinctly capture temporal event relationships. Synoptic's mining approach is similar to that of Daikon <ref type="bibr" target="#b9">[10]</ref>: it first enumerates all possible invariants, and then discards those invariants that are not satisfied by the initial graph. Due to space constraints, this paper omits optimization details that make this procedure efficient in practice.</p><p>3. partition(), on line 4, generates a partition graph (shown at E4 in <ref type="figure" target="#fig_5">Figure 8</ref>) from the initial graph by grouping events of the same class into a single partition and adding edges through existential abstraction. An edge between two partitions in this graph indicates that there are two events, one in each partition, that were connected in the initial graph. The partition graph may admit new traces that were not observed; however, each trace in the initial graph appears in the partition graph.</p><p>4. Bisim iteratively refines the partition graphlines 5-13. This is necessary because newly-introduced traces may violate invariants. Bisim terminates when the graph satisfies all the mined invariants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Invariant</head><p>LTL formula Type x AlwaysFollowedBy y (x → ♦y) liveness y AlwaysPrecededBy x ♦y → ¬y U x safety x NeverFollowedBy y (x → ¬y) safety <ref type="figure">Figure 3</ref>: Event relations that Synoptic mines from the input log, with corresponding LTL formula and classification. LTL properties must hold over the entire input log and are specified using the operators: always (), eventually (♦), and until (U). For example, the formula ♦y → ¬y U x requires x to occur before y. Without the premise ♦y, x would be required to appear at least once, even if the trace does not contain y.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Bisim Policies</head><p>The Bisim algorithm is parametrized (Section 2.2.2) with respect to termination and split policies. Line 5 of Figure 2 fixes the termination criterion and line 7 uses selectSplit for split selection. This section motivates our choices of these policies and their effects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Termination</head><p>Bisim uses a set of mined invariants for its termination criterion. Bisim's output is highly sensitive to this set. On the one hand, suppose the set of invariants is empty. Then the output is the quotient under label-equivalence, i.e., the initial partitioning. This graph is often too compact to capture key properties of the log. For example, when compacting correct two-phase commit event logs, the resulting graph incorrectly permits TX Commit to follow an Abort message. On the other hand, suppose that the invariant set includes all possible temporal log invariants expressible in LTL. Then the algorithm will terminate when, for all partitions A, if an event in A has a successor event in a partition B in the log, then every event in A has a successor event in B in the graph. In this case, the final representation is the quotient under bisimulation, i.e., a graph that satisfies the same set of LTL formulas as the log. Our experiments indicated that the bisimulation quotient is usually too similar to the initial graph, and thus too fine-grained to be a useful summary. Bisim chooses a compromise between these extremes. It terminates when the graph satisfies the three types of mined invariants listed in <ref type="figure">Figure 3</ref>. These invariant types are partially based on the specification patterns formulated by Dwyer et al. <ref type="bibr" target="#b7">[8]</ref> and are key to capturing rich semantics of distributed systems. For instance, key properties of two-phase commit and the Peterson algorithm (Section 5.1) are captured by these invariant types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Operation Selection</head><p>Our overall goal for Bisim is to pick a sequence of splits such that the resulting graph is the coarsest graph that satisfies a set of invariants. This problem is NP-hard <ref type="bibr" target="#b5">[6]</ref>, so an efficient algorithm might not yield the optimal result. We describe Bisim's split selection policy in terms of the dimensions of exploration (Section 2.2.2) and explain how it may make suboptimal decisions.</p><p>Candidate Operations. Bisim converts the mined invariants expressed in LTL into Büchi automata using LTL2Büchi <ref type="bibr" target="#b12">[13]</ref>. It then uses a model checker to obtain a set of counterexample traces for the current graph, each of which fails to satisfy at least one of the mined invariants. Next, Bisim follows the CEGAR approach <ref type="bibr" target="#b5">[6]</ref> to determine a set of candidate partitions, for each of which there exists a split that removes at least one of the counterexamples. Bisim identifies these partitions heuristically by tracing each counterexample, stepwise, in parallel, in the initial graph and in the current graph. In the initial graph, only a prefix of the counterexample will be present (otherwise the counterexample would not violate an invariant). Bisim finds the longest such prefix, and the last partition of this prefix in the current graph is the candidate partition -it allows a spurious transition that makes the trace a counterexample.</p><p>To remove the counterexample, the events in a candidate partition are divided into two sets: a set that contains events that can perform the spurious transition in the initial graph and a set that cannot. In line 7 of <ref type="figure">Figure 2</ref>, selectSplit obtains a predicate p that distinguishes these two event sets, and lines 8 and 9 introduce two new partitions, π 1 and π 2 , corresponding to these two sets.</p><p>In Synoptic's current implementation, getSplit only returns predicates that indicate the presence of an outgoing transition to a certain partition. Often, this constraint prevents Bisim from achieving an optimal splitting. To see this, consider <ref type="figure" target="#fig_5">Figure 8</ref>, in which Bisim yields a graph with six nodes at B6, while an invariant-satisfying graph with five nodes exists at C6. From the partition graph at E4, Bisim can obtain at most three different refinements, depending on which outgoing edge is used by the split. However, none of these refinements separates the event {a3} from events {a1, a2, a4}, which is necessary to yield the optimal graph.</p><p>In the future, we plan to consider different choices of predicate p, such as ones that indicate the presence of incoming edges.</p><p>Ranking among Candidate Partitions. Typically, the refined graph violates several invariants and candidate partitions must be ranked to decide which one to split first. Currently, Synoptic employs a two-class ranking: it examines all counterexamples in arbitrary order and performs the first split that validates an invariant (i.e., eliminates the last counterexample for that invariant). If no such split is available (because there are several violating traces for each invariant), Bisim picks a split nondeterministically. This two-class ranking introduces nondeterminism and Bisim might perform unnecessary splits. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The BisimH Algorithm</head><p>We have explained that the Bisim algorithm often refines more than it needs to. In particular, the result might contain partitions that can be merged without violating invariants. This seems to be inherent to the approach due to the NP-hardness of finding the optimal refinement <ref type="bibr" target="#b5">[6]</ref>. Motivated by the counterexample in <ref type="figure" target="#fig_5">Figure 8</ref>, we developed BisimH. BisimH extends Bisim with one additional step that mitigates the unnecessary splits by merging all partitions that can be merged without violating invariants. BisimH runs kTail (described at the end of Section 2.2.2), with k = 0, on the refined graph while enforcing that all merges respect the invariants. The resulting merged graph is locally minimal: merging any two partitions will violate some invariant.</p><p>In the future, we plan to explore more complex hybrid strategies, such as interleaving coarsening and refinement phases or considering both coarsening and refinement operations at every step. <ref type="figure" target="#fig_2">Figure 4</ref> shows the execution time of BisimH benchmarked on an AMD64 Intel i7 (1.6 GHz) Kubuntu machine with 8GB RAM. Each data point is the average of ten executions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Performance Evaluation</head><p>Performance vs. kTail with Invariants. kTail without invariants is usually much faster than BisimH but fails to produce compact graphs that satisfy key event invariants (see <ref type="figure" target="#fig_4">Figure 7)</ref>. It is straightforward to modify kTail to check for invariant violations and terminate once further merges violate invariants. However, BisimH scales better than kTail with Invariants due to its use of refinement. For example, when run on a Peterson log with 716 events, kTail with Invariants takes 86 seconds while BisimH completes in less than 1 second. For kTail, model checking dominates the performance cost, while BisimH operates on much smaller graphs. In the Peterson example, BisimH begins with a graph of size 5, and issues only 35-54 splits during operation. Thus, the graphs BisimH must model check contain at most 60 nodes. This provides tremendous speed-up compared to kTail, which initially operates on graphs with 716 nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Case Studies</head><p>To empirically evaluate Synoptic's ability to produce concise and useful representations, we applied it to three systems. The first system simulates the Peterson leader election algorithm <ref type="bibr" target="#b25">[27]</ref> and produces a log of all messages exchanged between simulated nodes in the system. The second system is a Twitter client <ref type="bibr" target="#b32">[34]</ref> that logs all messages to and from Twitter. The third system determines the likely reverse traceroute from an arbitrary destination on the Internet to a source host <ref type="bibr" target="#b18">[20]</ref>. Its logs are debugging events generated by the coordinating server.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Peterson Leader Election</head><p>The Peterson leader election algorithm <ref type="bibr" target="#b25">[27]</ref> allows an asynchronous unidirectional ring network of nodes to elect a leader. All nodes start as active and with a random unique node ID. In each round, at least half of the active nodes become relays through exchange and comparison of node IDs. A relay node forwards all messages it receives. When an active node receives its own messages via a ring of relay nodes, it becomes the leader.</p><p>We implemented a simulator of the Peterson algorithm that logs all messages sent and received by a node, as well as node state transition debug messages. This log includes a variety of message interleavings as the simulator allows concurrent node execution. Messages are timestamped and partially ordered using a Lamport vector clock <ref type="bibr" target="#b19">[21]</ref>. <ref type="figure" target="#fig_3">Figure 5</ref> shows BisimH output for an execution with 5 nodes that generated 3308 log events. This graph is useful in understanding node behavior as nodes take on different states. For example, Bisim correctly captures the fact that a relay node cannot send before receiving while an active node may first send and then receive, depending on the timing of incoming messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Trend</head><p>Search Result</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Get Trends</head><p>Figure 6: BisimH output for Twitter client-server interactions, when requesting trends (left) and performing a search (right).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Twitter API</head><p>We applied Synoptic to an open-source Twitter client <ref type="bibr" target="#b33">[35]</ref>. We added 3 lines of code to this client to log all messages exchanged between the client and the Twitter server. We verified Synoptic's output by consulting the official Twitter API documentation <ref type="bibr" target="#b32">[34]</ref>. <ref type="figure">Figure 6</ref> shows two of the graphs from the final representation that demonstrate that Synoptic may help developers gain an intuitive understanding of the overall structure of an API.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Reverse Traceroute</head><p>We carried out a user study with a developer who built a system to determine the likely reverse traceroute from an arbitrary destination on the Internet to a source host <ref type="bibr" target="#b18">[20]</ref>. Reverse traceroute relies on a distributed set of Internet vantage points and uses a variety of methods to find each segment of the reverse route, such as IP record route and timestamp options <ref type="bibr" target="#b15">[17,</ref><ref type="bibr" target="#b16">18]</ref>, and relying on IP spoofing from PlanetLab hosts.</p><p>We developed a small parser that uses regular expressions to extract information from logs generated by Reverse Traceroute. We then partitioned the output of this parser into traces, such that each dealt with determining one segment of the reverse path. Synoptic executed on these partitioned logs. We then discussed the Synopticgenerated representation (which we omit due to lack of space) with the developer.</p><p>The Synoptic representation prompted us to ask relevant questions about the system's design and helped the developer to remember implementation details. The developer pointed out distinct regions of the graph where the system employed a particular method to determine a segment on the reverse path. The user stated that Synoptic makes it easy to discover unexpected paths in the system and that he found it useful to see how often certain paths were taken by the system (edges between events in the graph were annotated to indicate co-event frequency). Unlike kTail, BisimH was always able to establish the key invariants -those that imply system correctness. We do not know the key invariants for reverse traceroute, which, unlike the others, lacks a proof of correctness and documentation. Further, with kTail, the user must guess the value of the k parameter, which trades off the size and accuracy of the graph. BisimH makes explicit which invariants it preserves. <ref type="figure" target="#fig_4">Figure 7</ref> also demonstrates that invariant types mined by BisimH <ref type="figure">(Figure 3</ref>) are sufficient to capture key invariants of a range of distributed systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Graph Quality: BisimH vs. kTail</head><p>Augmenting kTail to respect key invariants (kTail with Invariants in <ref type="figure" target="#fig_4">Figure 7</ref>) produces graphs that are as concise and as accurate as BisimH. However, BisimH is dramatically faster.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion and Future Work</head><p>BisimH uses three types of invariants that we believe are useful for capturing temporal system properties. Two of these appear in the survey of specification patters <ref type="bibr" target="#b7">[8]</ref>. Synoptic can accommodate other types of invariants that relate events. We plan to expand Synoptic to use the remaining six specification patterns from this survey. We also plan to expand Synoptic to mine structural properties of logged events, e.g., the value of the source and destination IP addresses and message data payload. Our initial experiments indicate that this direction is promising, though it may require users to specify format and data types of event fields.</p><p>BisimH is motivated by the Bisim counterexample in <ref type="figure" target="#fig_5">Figure 8</ref>. We are actively exploring the limits of BisimH and, thus far, have been unable to find a similar counterexample. However, one likely exists since finding an efficient, exact algorithm is equivalent to proving P = NP <ref type="bibr" target="#b5">[6]</ref>. Currently BisimH leverages kTail only once Bisim terminates, but another approach could interleave kTail and Bisim.</p><p>Synoptic's output depends on the ordering of events in the log. If events are missing, are out of order, or the log contains spurious events, Synoptic may mine false invariants or may omit true invariants, compromising the quality of the resulting graph. In small graphs, discrepancies could be easy to detect for users familiar with the system. In large graphs, manual detection is difficult. One way to handle log defects is to leverage anomaly detection to alert the user when an event occurrence or omission in the log may be due to a defect.</p><p>For Synoptic to converge on an accurate representation, it is sufficient for the log to contain an example trace corresponding to every path in the system model. For protocols and system that are well specified (e.g., twophase commit) this is straightforward. For more complex systems, such as reverse traceroute, it is non-trivial to determine how much input is necessary. The intended use of Synoptic-generated models plays a role in determining the appropriate input log size. A more rigorous understanding of the system will require a larger log. Figure 7: Graph quality metrics -number of input log events, output nodes, and whether the output satisfied the algorithm's key invariants (invs) -and execution times on logs of four systems. A * indicates that the key invariants were unknown, but, for reverse traceroute, kTail failed to preserve 68 invariants that BisimH mined and enforced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Work related to Synoptic falls into three main categories;</p><p>(1) tools to debug and visualize distributed systems; (2) algorithms to create concise FSM representations of system executions; and (3) the study of bisimulations, which motivated our development of Bisim.. Debugging and Visualizing Distributed Systems. Distributed systems are notoriously difficult to get right. This is exemplified by recent efforts that target bug finding in distributed systems <ref type="bibr" target="#b36">[38,</ref><ref type="bibr" target="#b35">37]</ref>. Magpie <ref type="bibr" target="#b6">[7]</ref> and XTrace <ref type="bibr" target="#b11">[12]</ref> are examples of debugging tools that provide a fine granularity of process tracing in distributed systems. Such tools, however, require system modification and do not focus on the problem of log summarization.</p><p>Prior work on distributed system log mining focused on detecting dependencies <ref type="bibr" target="#b23">[25]</ref>, anomalies <ref type="bibr" target="#b34">[36,</ref><ref type="bibr" target="#b17">19,</ref><ref type="bibr" target="#b39">41]</ref>, and performance debugging <ref type="bibr" target="#b30">[32,</ref><ref type="bibr" target="#b31">33]</ref>. Much of this work does not target the problem of finding a concise summary representation for an arbitrary distributed system. For instance, SALSA <ref type="bibr" target="#b30">[32]</ref> and Mochi <ref type="bibr" target="#b31">[33]</ref> extract and visualize node behavior of Hadoop <ref type="bibr">[16]</ref> node logs to support performance debugging. This line of work is MapReducespecific. Perracotta <ref type="bibr" target="#b38">[40]</ref> mines and visualizes temporal properties of event traces, and it has been used to study program evolution <ref type="bibr" target="#b37">[39]</ref>. Unlike Synoptic, Perracotta considers a totally ordered trace of events and does not consider properties that might be of interest in distributed systems, such as the invariants mined by Synoptic.</p><p>kTail and GK-Tail Algorithms. The problem of automata inference from positive examples of executions is computable <ref type="bibr" target="#b2">[3]</ref>, but is NP-complete <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b0">1]</ref>, and the FSA cannot be approximated by any polynomial-time algorithm <ref type="bibr" target="#b27">[29]</ref>. Therefore, polynomial-time algorithms that explore the FSM space are approximation algorithms.</p><p>An important algorithm that has been used extensively in related work is the kTail algorithm <ref type="bibr" target="#b1">[2]</ref>. kTail takes an automaton and produces a more compact one by recursively merging automaton states whose root subgraphs are identical up to a depth of k. Lorenzoli et al. <ref type="bibr" target="#b22">[24]</ref> developed a variant of kTail, called GK-Tail, and applied it to logged sequences of method call invocations. Unlike Bisim and BisimH, the GK-Tail algorithm does not preserve trace invariants. Another use of kTail is in work by <ref type="bibr">Lo et al. [23]</ref>, in which temporal properties are mined from execution traces and are used to steer the kTail algorithm to ensure that a kTail merge will not produce a graph violating a temporal constraint. This is similar to the kTail with Invariants algorithm of Section 4. This paper considers refinement exploration algorithms in contrast to the coarsening strategy in kTail.</p><p>Bisimulation. A bisimulation is a simulation relation that provides a strong notion of similarity for relational structures <ref type="bibr" target="#b28">[30]</ref>. Its key property is preserving certain properties of the relational structure, for example, two strongly bisimilar transition systems are guaranteed to satisfy the same set of LTL formulas. An important application in model checking is model minimization <ref type="bibr" target="#b10">[11]</ref>. Our Bisim algorithm is a modification of a partition refinement algorithm <ref type="bibr" target="#b24">[26]</ref>, which uses invariants to determine which state to split next and when to stop splitting, resulting in a coarser representation that is not bisimilar to the input structure. Our Bisim algorithm is also related to the partition refinement algorithms in <ref type="bibr" target="#b8">[9]</ref>, but Bisim uses invariants to guide exploration and termination.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>Synoptic summarizes distributed system execution logs with a compact graph by employing two key innovations. First, Synoptic mines temporal properties from logged events and maintains these invariants during summarization. Compared to other approaches, such as kTail, Synoptic generalizes the logs more accurately and captures more key properties. Second, Synoptic uses coarsening to explore the representations space starting with smaller representations, making it scale better than the popular kTail algorithm augmented with invariant checking. A user study showed that Synoptic representations can augment the intuition of distributed systems developers. Step-by-step depiction of Synoptic's process: (a) log events; (b) derive the initial graph; (c) mine temporal relations (NFby: NeverFollowedBy, AFby: AlwaysFollowedBy, AP: AlwaysPrecedes); (d) explore the representation space with BisimH. BisimH has two phases: (d.1) refine (right to left) from the initial partitioning at E4 until a representation satisfying all the mined invariants at B6; (d.2) coarsen (left to right) towards the final, more compact, representation at C6, which retains the satisfied invariants. Finally, (e) the derived representation is presented to the user. Bisim is sub-optimal on this example, motivating BisimH. The most compact valid representation at C6 cannot be reached by refinement alone when starting at E4.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1</head><label>1</label><figDesc>Figure 1: Two example representations of a two-node twophase commit log. Arrows represent temporal ordering. Rhombus nodes are start states -that is, initial events. Coarsening can convert the left graph into the right one, which is smaller but admits more behaviors. Refinement is the dual of coarsening. Coarsening is the traditional approach to log summarization; this paper shows the benefits of refinement.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: BisimH execution time on Peterson algorithm logs (Section 5.1) with varying number of events. The total execution time is broken up according to the steps described in Section 3.1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: BisimH output for a Peterson log with 3308 events, generated by simulating 5 nodes. The manually-added, labeled, dotted regions group nodes into the states a node may take on in the algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 compares</head><label>7</label><figDesc>Figure 7 compares the graphs generated by BisimH, kTail, and kTail with Invariants (from Section 4). Unlike kTail, BisimH was always able to establish the key invariants -those that imply system correctness. We do not know the key invariants for reverse traceroute, which, unlike the others, lacks a proof of correctness and documentation. Further, with kTail, the user must guess the value of the k parameter, which trades off the size and accuracy of the graph. BisimH makes explicit which</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Step-by-step depiction of Synoptic's process: (a) log events; (b) derive the initial graph; (c) mine temporal relations (NFby: NeverFollowedBy, AFby: AlwaysFollowedBy, AP: AlwaysPrecedes); (d) explore the representation space with BisimH. BisimH has two phases: (d.1) refine (right to left) from the initial partitioning at E4 until a representation satisfying all the mined invariants at B6; (d.2) coarsen (left to right) towards the final, more compact, representation at C6, which retains the satisfied invariants. Finally, (e) the derived representation is presented to the user. Bisim is sub-optimal on this example, motivating BisimH. The most compact valid representation at C6 cannot be reached by refinement alone when starting at E4.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Finding patterns common to a set of strings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Angluin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="46" to="62" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the Synthesis of Finite-State Machines from Samples of Their Behavior</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">W</forename><surname>Biermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Feldman</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="592" to="597" />
			<date type="published" when="1972" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Toward a mathematical theory of inductive inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Blum</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Blum</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="125" to="155" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cappécapp´cappé</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Moulines</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryden</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
		<title level="m">ference in Hidden Markov Models</title>
		<meeting><address><addrLine>Secaucus, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag New York, Inc</publisher>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Series in Statistics)</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Practical Byzantine Fault Tolerance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Castro</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liskov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI &apos;99: Proceedings of the third symposium on Operating systems design and implementation</title>
		<meeting><address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="173" to="186" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Counterexample-guided abstraction refinement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clarke</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Veith</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="154" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Magpie: supporting browsing and navigation on the semantic web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Domingue</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dzbor</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IUI &apos;04: Proceedings of the 9th international conference on Intelligent user interfaces</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="191" to="197" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Patterns in property specifications for finite-state verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dwyer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Avrunin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cor-Bett</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;99: Proceedings of the 21st international conference on Software engineering</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="411" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Partition-Refining Algorithms for Learning Finite State Automata</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elomaa</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISMIS &apos;02: Proceedings of the 13th International Symposium on Foundations of Intelligent Systems</title>
		<meeting><address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="232" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Dynamically discovering likely program invariants to support program evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ernst</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Cockrell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Griswold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Notkin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;99: Proceedings of the 21st international conference on Software engineering</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="213" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Bisimulation Minimization and Symbolic Model Checking. Formal Methods in System Design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fisler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vardi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Y</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="39" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fonseca</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stoica</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>X-Trace</surname></persName>
		</author>
		<title level="m">A Pervasive Network Tracing Framework. In NSDI</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">From States to Transitions: Improving Translation of LTL Formulae to Büchi Automata</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giannakopoulou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lerda</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FORTE &apos;02: Proceedings of the 22nd IFIP WG 6.1 International Conference Houston on Formal Techniques for Networked and Distributed Systems</title>
		<meeting><address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="308" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Language identification in the limit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gold</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="447" to="474" />
			<date type="published" when="1967" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Notes on Data Base Operating Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gray</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Operating Systems, An Advanced Course</title>
		<meeting><address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1978" />
			<biblScope unit="page" from="393" to="481" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<ptr target="http://www.ietf.org/rfc/rfc791.txt.Pg.20" />
		<title level="m">IPv4 Specification, Record Route option</title>
		<imprint>
			<date type="published" when="2010-03-09" />
			<biblScope unit="volume">21</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">IPv4 Specification</title>
		<ptr target="http://www.ietf.org/rfc/rfc791.txt.Pg.22" />
		<imprint>
			<date type="published" when="2010-03-09" />
			<biblScope unit="volume">23</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Multi-resolution Abnormal Trace Detection Using Varied-length N-grams and Automata</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ungureanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshihira</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Autonomic Computing, International Conference on 0</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="111" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katz-Bassett</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Madhyastha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">V</forename><surname>Ad-Hikari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">K</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sherry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Van We-Sep</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krishnamurthy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">Reverse</forename><surname>Traceroute</surname></persName>
		</author>
		<title level="m">NSDI&apos;10: : Proceedings of the 7th USENIX symposium on Networked systems design and implementation</title>
		<meeting><address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lamport</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The part-time parliament</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lamport</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="133" to="169" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Automatic steering of behavioral model inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">O</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mariani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pezz`epezz` Pezz`e</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE &apos;09: Proceedings of the the 7th joint</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Automatic generation of software behavioral models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lorenzoli</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mariani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pezz`epezz` Pezz`e</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;08: Proceedings of the 30th international conference on Software engineering</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="501" to="510" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Mining Dependency in Distributed Systems through unstructured log analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-G</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WASL&apos;09: Proceedings of USENIX Workshop on Analysis of System Logs</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Three partition refinement algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paige</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tarjan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="973" to="989" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">An O (n log n) unidirectional algorithm for the circular extrema problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peterson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems (TOPLAS)</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page">762</biblScope>
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Petri Net Theory and the Modeling of Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peterson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1981" />
			<publisher>Prentice Hall PTR</publisher>
			<pubPlace>Upper Saddle River, NJ, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The minimum consistent DFA problem cannot be approximated within any polynomial</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pitt</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Warmuth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="95" to="142" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On the origins of bisimulation and coinduction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sangiorgi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="1" to="41" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Implementing fault-tolerant services using the state machine approach: a tutorial</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="299" to="319" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Analyzing Logs as StAte Machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Kavulya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Narasimhan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Salsa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WASL&apos;08: Proceedings of USENIX Workshop on Analysis of System Logs</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Kavulya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Narasimhan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mochi</surname></persName>
		</author>
		<title level="m">HotCloud&apos;09: Proceedings of USENIX Workshop on Hot Topics in Cloud Computing</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
	<note>Visual Log-Analysis Based Tools for Debugging Hadoop</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Api</forename><surname>Twitter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Documentation</surname></persName>
		</author>
		<ptr target="http://apiwiki.twitter.com/Twitter-API-Documentation.Accessed" />
		<imprint>
			<date type="published" when="2010-06-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title/>
		<ptr target="http://code.google.com/p/java-twitter/" />
	</analytic>
	<monogr>
		<title level="j">A Java wrapper around the Twitter API</title>
		<imprint>
			<date type="published" when="2010-03-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Detecting large-scale system problems by mining console logs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jordan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">I</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;09: Proceedings of the ACM SIGOPS 22nd symposium on Operating systems principles</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="117" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">CrystalBall: predicting and preventing inconsistencies in deployed distributed systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yabandeh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Knezevic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kostic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kuncak</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI&apos;09: Proceedings of the 6th USENIX symposium on Networked systems design and implementation</title>
		<meeting><address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="229" to="244" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">MODIST: Transparent Model Checking of Unmodified Distributed Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI&apos;09: Proceedings of the 6th USENIX symposium on Networked systems design and implementation</title>
		<meeting><address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="213" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Automatically Inferring Temporal Properties for Program Evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evans</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISSRE &apos;04: Proceedings of the 15th International Symposium on Software Reliability Engineering</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="340" to="351" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Dynamically inferring temporal properties</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evans</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PASTE &apos;04: Proceedings of the 5th ACM SIGPLAN-SIGSOFT workshop on Program analysis for software tools and engineering</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="23" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">SherLog: error diagnosis by connecting clues from run-time logs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pasupathy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGARCH Comput. Archit. News</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="143" to="154" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
