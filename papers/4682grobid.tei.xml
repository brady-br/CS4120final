<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:28+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Leveraging Flawed Tutorials for Seeding Large-Scale Web Vulnerability Discovery</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tommi</forename><surname>Unruh</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">TU Berlin</orgName>
								<address>
									<settlement>Berlin</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bhargava</forename><surname>Shastry</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">TU Berlin</orgName>
								<address>
									<settlement>Berlin</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Malte</forename><surname>Skoruppa</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Saarland University</orgName>
								<address>
									<settlement>Saarland</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Federico</forename><surname>Maggi</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">FTR, Trend Micro, Inc</orgName>
								<address>
									<settlement>Milan</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konrad</forename><surname>Rieck</surname></persName>
							<affiliation key="aff3">
								<address>
									<settlement>Braunschweig, Braunschweig</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Pierre</forename><surname>Seifert</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">TU Berlin</orgName>
								<address>
									<settlement>Berlin</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabian</forename><surname>Yamaguchi</surname></persName>
							<affiliation key="aff3">
								<address>
									<settlement>Braunschweig, Braunschweig</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Leveraging Flawed Tutorials for Seeding Large-Scale Web Vulnerability Discovery</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The Web is replete with tutorial-style content on how to accomplish programming tasks. Unfortunately, even top-ranked tutorials suffer from severe security vulnerabil-ities, such as cross-site scripting (XSS), and SQL injection (SQLi). Assuming that these tutorials influence real-world software development, we hypothesize that code snippets from popular tutorials can be used to bootstrap vulnerability discovery at scale. To validate our hypothesis , we propose a semi-automated approach to find recurring vulnerabilities starting from a handful of top-ranked tutorials that contain vulnerable code snippets. We evaluate our approach by performing an analysis of tens of thousands of open-source web applications to check if vulnerabilities originating in the selected tutorials recur. Our analysis framework has been running on a standard PC, analyzed 64,415 PHP codebases hosted on GitHub thus far, and found a total of 117 vulnerabilities that have a strong syntactic similarity to vulnerable code snippets present in popular tutorials. In addition to shedding light on the anecdotal belief that programmers reuse web tuto-rial code in an ad hoc manner, our study finds disconcerting evidence of insufficiently reviewed tutorials compromising the security of open-source projects. Moreover, our findings testify to the feasibility of large-scale vulnerability discovery using poorly written tutorials as a starting point.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Programming aids such as web tutorials and Q&amp;A websites are popular with novice and expert programmers alike. To what extent, and how these aids influence the quality of real-world software remains an open question. On the one hand, popular Q&amp;A websites, such as stackoverflow.com, have an in-built reputation system where correct advice gets up-voted through a consensus. Hence, a common expectation is that community-driven websites weed out bad coding suggestions.</p><p>On the other hand, the Web is replete with tutorial-style webpages that simply present curated snippets of code that accomplish a task. Most tutorials omit a discussion about API quirks or the security-impact a code snippet might have. It is not surprising, therefore, that the presented code snippets suffer from basic security vulnerabilities.</p><p>The connection between tutorials and vulnerabilities in real-world code is largely unknown. Although previous studies <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b30">29,</ref><ref type="bibr" target="#b37">36]</ref> have shown that copy-pasted code can lead to recurring vulnerabilities, these studies have only considered instances of copy-pasted code within a codebase. We seek to generalize this result by asserting that, like code snippets originating in the same codebase, popular programming resources on the Web constitute a major source of documentation that is regularly consulted by developers and often introduces vulnerabilities into software.</p><p>Based on our assertion, we hypothesize that vulnerability discovery can be seeded by code snippets such as those found in top-ranked tutorials. Viewed from an adversarial standpoint, we present a novel approach for bootstrapping vulnerability discovery at scale. Our main intuition is that recurring vulnerabilities can be found by recognizing, and subsequently looking for patterns in code that correspond to the original vulnerability. We refer to instances of these patterns as code analogues throughout the rest of the paper. Our expectation is that if such a pattern recurs, so will the corresponding vulnerability. To identify code analogues, we automatically generate graph traversals, which can be used to mine code for these analogues using graph databases. Each graph traversal is derived from normalized fragments of a code snippet's abstract syntax tree (AST), augmented with data-flow information. These graph traversals thus express syntactic properties of the original tutorial code.</p><p>Our workflow for finding recurring vulnerabilities consists of two steps. First, we automatically translate vulnerable code snippets into graph traversals, which concretize our expectations of code that constitutes an analogue. Second, we serialize a codebase under analysis into a graph database and employ the automatically generated traversals to search the database for analogue occurrences. As a result, we obtain a set of locations in application source code that bear a strong syntactic resemblance to vulnerable code snippets.</p><p>An empirical evaluation of our approach, on a data set of 64,415 web applications, shows that an adversary with access to a standard PC and a DSL broadband connection can leverage our techniques to efficiently discover recurring vulnerabilities in web application code <ref type="bibr">(Sec- tion 3)</ref>. Although AST is a fundamental construct for any programming language, we prototype our analysis framework for analyzing applications written in PHP, the most widely deployed server side scripting language to date <ref type="bibr" target="#b34">[33]</ref>. Our analysis framework accepts vulnerable (tutorial) code snippets as input, and returns its analogues in a target PHP codebase. Since our analysis can not guarantee that the returned analogues are also vulnerable, we manually review them. Manual review has also been useful in teasing out the connection insecure tutorials and web application vulnerabilities. Thanks to our framework, we have uncovered over 100 vulnerabilities in web application code that bear a strong resemblance to vulnerable code patterns found in popular tutorials. More alarmingly, we have confirmed that 8 instances of a SQLi vulnerability present in different web applications are an outcome of code copied from a single vulnerable tutorial. Our results indicate that there is a substantial, if not causal, link between insecure tutorials and web application vulnerabilities.</p><p>In summary, we make the following contributions:</p><p>• We present a novel approach for bootstrapping large-scale vulnerability discovery, namely, leveraging flawed tutorial code to seed vulnerability search in application code. We evaluate this approach using a proof-of-concept framework that finds recurring vulnerabilities in PHP application code hosted on GitHub.</p><p>• We propose a computationally efficient method to search for recurring vulnerabilities. We translate vulnerable snippets of code into graph traversals to identify code analogues in a program abstraction.</p><p>• We show that large-scale vulnerability scanning of publicly available open-source repositories is feasible, even with limited resources such as a standard PC and a broadband DSL connection.</p><p>• Finally, our results give credence to the widely known anecdote that programmers copy and paste code from vulnerable tutorials. Our case study, involving 64,415 PHP projects hosted on GitHub, indicates that such ad hoc code re-use may endanger the security of software throughout the open-source landscape.</p><p>Our tools GithubSpider, and CADetector are available at https://github.com/tommiu/GithubSpider and https://github.com/tommiu/ccdetection respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methodology</head><p>In this study, we take on an attacker's perspective and design our method such that it allows for semi-automated discovery of recurring vulnerabilities without requiring special access to a hosting platform or considerable computational resources. <ref type="figure" target="#fig_0">Figure 1</ref> illustrates our workflow, that we briefly describe in the following paragraphs.</p><p>1. Derivation of templates from tutorials. We extract templates from vulnerable code snippets contained in tutorials. These templates represent syntactical properties of the vulnerable code as well as information about data flow (Section 2.1).</p><p>2. Generating traversals from templates. We leverage templates to automatically generate traversals for a graph-based code mining system. Graph traversals enable us to scan large amounts of code for analogues of these vulnerable snippets in a computationally efficient manner (Section 2.2).</p><p>3. Spidering code repositories. We automatically collect a large data set of open-source code bases from a code hosting site, choosing GitHub as a representative case study (Section 2.3).</p><p>4. Mining for vulnerabilities. Leveraging our analysis framework, we automatically mine the code of our data set for instances of vulnerable tutorial snippets. We manually cross-check if matches returned by our analysis platform constitute vulnerabilities (Section 2.4).</p><p>In the remainder of this section, we describe each of these steps in greater detail providing background information where necessary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Derivation of Templates from Tutorials</head><p>Exact copies of vulnerable code snippets can be found using string matching utilities such as the standard UNIX tool grep. However, as programmers copy and paste code from tutorials, they are likely to adapt it slightly, for example, by changing the names of variables. Therefore this na¨ıvena¨ıve approach fails in all but the most simple cases. To account for slight modifications, we require a method that is robust enough to identify sequences of statements similar to those found in the tutorial in terms of the operations they carry out on their input variables. We refer to these re-occurrences of tutorial code as code analogues, or simply analogues. An elegant approach to address this problem is to extract intermediate graph representations from code that represent syntax and data flow, and formulate syntactical and data flow properties of the code snippet in terms of traversals in these graphs <ref type="bibr">[see 13, 30, 35]</ref>. These traversals are formulated such that they succeed when the code matches, and fail when it does not. Although these graph traversals can be formulated manually, in this work, we devise a two-step procedure to automatically generate them from vulnerable snippets of code, making it possible to directly search for these snippets without additional manual work.</p><p>The first step of our procedure is to generate a template that encodes syntax and data flow of the code snippet that we attempt to scan for. To illustrate this process, we consider the vulnerable code snippet shown in <ref type="figure">Figure 2</ref> taken from a popular PHP tutorial. The code contains one SQLi, and one stored XSS vulnerability. The SQLi vulnerability occurs on line 6 as the attackercontrolled POST-variable $title is used in the construction of an SQL query without first undergoing sanitization. The XSS vulnerability can be triggered on line 12, and 13 where databases rows are inserted into the document without escaping.</p><p>Two queries can be generated from the code snippet shown in <ref type="figure">Figure 2</ref>: one to identify instances of the SQLi vulnerability, and another for the XSS vulnerability. In the following walk-through, we focus on the SQLi vulnerability, as highlighted in <ref type="figure">Figure 2</ref>.</p><p>We proceed to generate an AST of the vulnerable code snippet, a standard tree-representation of program syntax. ASTs provide a hierarchical decomposition of code into its language elements. As an example, <ref type="figure" target="#fig_3">Figure 3(a)</ref> shows the abstract syntax tree for the SQLi vulnerability. In this tree, leaf nodes correspond to identifiers (e.g., $title), API symbols (e.g., mysql ...), or literals (e.g., SELECT), and inner nodes represent operations such as assignments, function calls, or array indexing operations.</p><p>To derive a template from an AST, we replace all variables and literals by wildcard symbols and introduce edges between nodes representing the same variable. The template thus abstracts from concrete variable names and strings, while preserving data flow between variables. <ref type="figure" target="#fig_3">Figure 3</ref>(b) shows the corresponding template for our running example. As indicated by the data flow edges, the template enforces that there is a match if and only if the variable occurring on the left-hand side of the assignment in the first statement, and the variable appearing as an argument in a function call in the next statement are the same. An assignment to one variable, followed by the use of a different variable in a function call does not trigger a match, because there is no data flow between them.</p><p>With templates for code snippets at hand, we are now ready to generate graph traversals that allow code to be mined for instances (analogues) of these snippets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Generation of Traversals from Templates</head><p>Upon successful generation of a template for a vulnerable code snippet, we transform the template into a corresponding graph traversal. Although in principle, graph  traversals can be formulated in any programming language, the query language Gremlin <ref type="bibr" target="#b6">[7]</ref> is specifically designed for this purpose. Moreover, traversals formulated in Gremlin can be executed on any graph database system that supports the Blueprints standard <ref type="bibr" target="#b5">[6]</ref>, a compatibility layer for graph databases similar to JDBC for relational databases.</p><formula xml:id="formula_0">ASSIGN $title DIM "title" $_POST ASSIGN $result CALL mysql_.. "... ..." ASSIGN $found CALL mysql_.. AST LIST $result $title (a) Abstract Syntax Tree. ASSIGN * DIM * $_POST ASSIGN * CALL mysql_.. * * ASSIGN * CALL mysql_..</formula><p>For a given template, we generate a traversal that identifies ASTs with (1) the same node types, (2) in the same order, and (3) nested in the same way. Moreover, the traversal succeeds only if data flow between statements is in correspondence with the data-flow edges of the template.</p><p>In essence, the AST structure is encoded by formulating chains of filter operations that succeed only if the desired node types can be matched. To account for data flow, the names of variables are stored as the AST is traversed, and filtering is performed to ensure that the correct variable names occur throughout the tree. Algorithm 1 describes this process in detail. Each child node of the template is converted into a traversal via the recursive function ConvertNode, and prepareNode adds code to traverse to the next child node.</p><p>As an example, <ref type="figure" target="#fig_12">Figure 4</ref> shows the traversal generated by this procedure for the vulnerable code snippet in Figure 2. For all nodes in the AST, the traversal attempts to match the left subtree, the subtree in the middle, and the right subtree starting at lines 4, 20, and 37 respectively. Subtrees are matched by applying chains of filter expressions. For instance, to match the left-most subtree consisting of an assignment with a variable as a child node, the traversal first attempts to match an assignment, and, on success, determines whether the child node is a variable node using a subsequent filter (see lines 4 and 5). Finally, lightweight data-flow tracking is implemented by storing the names of variables as they are first encountered (e.g., on line 8), and filtering based on these names (e.g., line 38).</p><p>The generated traversals implement a computationally efficient code analogue detection. For classic code if node.type == "VAR" then 12:</p><p>if variable with name has been used before then for each child node of child do return { traverse next child } clone detection tools, the comparison of every subtree of a given AST of N nodes with every subtree of the same AST costs O(N 3 ) and can become O(N 4 ) when also comparing sequences of trees. Since empirically, a large software system of M lines of code has N = 10M AST nodes, this AST-based approach suffers a hard scaling problem. There is a solution to this runtime cost, which involves comparing hashes of AST subtrees instead of the AST subtrees themselves. Then, the runtime becomes O(N) [see 3]. However, hashing subtrees will not work with our approach.</p><p>In our approach, we are comparing a given source AST S of N nodes, obtained from a tutorial, with a target AST T of M nodes, which is the code base that should be scanned for code analogues of S. Therefore, N is much smaller than M. For this approach, the runtime is much smaller. More formally, our algorithm starts out with comparing the first node in N with every node in M, until it finds one that is equal. This costs O(M). Then, it will compare the other nodes as well, until all nodes in S were matched successfully in T . Therefore, when a code analogue is found, we did N comparisons to match it. For subtrees that are not analogues of S, we do 1 to N − 1 comparisons. This cost is O(N). In the worst case, this entails a full check that costs O(N) for every node .filter{ isType(it, "ASSIGN") }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5</head><p>.filter{ isType(it.ithChildren(0), "VAR") } .filter{ isType(it.ithChildren(1), "DIM") }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11</head><p>.filter{ isType(it.ithChildren(1).ithChildren(0),</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>12</head><p>"VAR") }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>13</head><p>.sideEffect{ childnumber = it.childnum }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>14</head><p>.sideEffect{ childnumber = childnumber + 1 } // Subtree in the middle <ref type="bibr" target="#b19">20</ref> .filter{ isType(it, "ASSIGN") }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>21</head><p>.filter{ isType(it.ithChildren(0), "VAR") } .filter{ isType(it.ithChildren(1), "CALL") }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>27</head><p>.filter{ isType(it.ithChildren <ref type="formula">(1)</ref> 28 .ithChildren(0), "NAME") }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>29</head><p>.filter{ isType(it.ithChildren(1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>30</head><p>.ithChildren(1), "ARG_LIST") }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>31</head><p>...   in T . Thus, the complexity of our approach is O(NM),or for cases where N M holds, O(M).</p><p>Our algorithm can benefit from knowledge about the depth of nodes. Let d(x) denote the depth of a node x, then, comparisons beyond an AST depth of d(T ) − d(S) + 1 can be safely avoided, given that nodes at the depth cannot contain the AST S. However, we typically make use of small vulnerable code snippets (N M), for which the saving in computational cost is marginal.</p><p>Translation of tutorial templates into graph traversals provides us a means to mine large amounts of open-source code for recurring vulnerabilities. Since we assume that the attacker is not an insider (who can stealthily plug our analyses into the back-end of a hosting platform), analysis impinges on the attacker being able to download a project's source code. To this end, we have implemented a tool called GithubSpider to facilitate code crawling at scale. In the next section, we briefly discuss its design and implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Spidering Code Repositories</head><p>We make a conservative estimate of computing resources that an attacker has at his/her disposal. We assume that an attacker has access to a modest computing device such as a standard PC, and a DSL broadband connection. Our threat model lowers the barrier to entry for performing vulnerability discovery at scale. Additionally, we assume that the attacker makes every effort to be stealthy. In the context of code spidering, this implies that rate limits imposed by a hosting service cannot be abused. Thus, we are constrained to spider at a modest speed. The constraints that we impose on the attacker make our tooling and analysis operate in a real-world setting. Understanding whether an attacker, in spite of these constraints, can use our techniques to find vulnerabilities in open-source code is part of our research question.</p><p>Although multiple code hosting platforms provide APIs that could be used for spidering, we focus on GitHub in our case study. GitHub is the most popular open-source collaboration platform, hosting approximately 10.3 million developers, and over 25 million projects <ref type="bibr" target="#b9">[10]</ref>. In addition to code, GitHub maintains meta-data such as a project's language, creation time, popularity (stars and forks), and total code size.</p><p>Our spidering tool, GithubSpider, uses GitHub's REST API to obtain project meta-data for a large number of projects. GithubSpider is designed to be general purpose: It obtains project meta-data and applies user-defined filters to them, providing the flexibility required to spider code repository classes of interest. Thus, GithubSpider can be leveraged towards analysis of a different family of codebases, say C/C++ code. We leverage GithubSpider to crawl projects written in the PHP language. Additionally, we filter projects based on their popularity. We gauge a project's popularity by the number of stars 1 it has received. After narrowing down projects of interest, we leverage GitHubspider to clone (download) projects and their revision history (see Section 3.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Mining for Vulnerabilities</head><p>Finally, we automatically mine the downloaded code repositories using the traversals generated from vulnerable code snippets (see Section 2.2). We achieve this by importing the code into the code-mining platform Joern <ref type="bibr" target="#b36">[35]</ref>. Joern first parses source files to generate ASTs, and subsequently imports the ASTs into a Neo4j graph <ref type="bibr" target="#b0">1</ref> A GitHub user can express interest in a repository by starring it.</p><p>Algorithm 2 Algorithm to find code analogues using graph traversals.</p><p>1: procedure MINECODE(repositories, queries)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2:</head><p>for each repository in respositories do 3:</p><p>create ASTs for repository <ref type="bibr">4:</ref> import ASTs into graph database and start server <ref type="bibr">5:</ref> for each query in queries do <ref type="bibr">6:</ref> run query against database server <ref type="bibr">7:</ref> save statistical data <ref type="bibr">8:</ref> save code clone data <ref type="bibr">9:</ref> stop graph database server database, which allows us to efficiently execute graph traversals and collect statistical data about our analysis.</p><p>Scanning the large number of projects obtained from our spider in an acceptable time frame is challenging task, as graph matching needs to be performed on all ASTs of all retrieved code bases. Fortunately, projects can be processed independently, and therefore, we can distribute scanning across several processes running in parallel by splitting spidered repositories into groups. This task can also be carried out in a distributed setting.</p><p>For a given set of queries and a group of repositories, Algorithm 2 summarizes the scanning process that we carry out. For each repository, the algorithm creates ASTs for each of its source files and imports them into the graph database. The graph database server is subsequently started, each query is executed against the databases, and statistical data such as query execution time is collected. Upon running all queries on a project, the graph database server is stopped.</p><p>We have implemented the presented algorithm in a tool, that we call CADetector, short for code analogue detector. CADetector takes automatically generated queries (Gremlin traversals), and a PHP project for analysis as input, and returns matching code as output. Code analogues are presented to a human analyst for review. In the next section, we present our evaluation methodology and results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Evaluation</head><p>Our evaluation follows a two-step process. First, we select a handful of vulnerable code snippets, obtained from top-ranked PHP tutorials, to seed our study. Second, if we find a match for a vulnerable snippet in our data set as a result of our analysis, we flag it for manual review. Based on this two-step process, we have performed extensive evaluation of our analysis framework. Our analysis data set consists of 64,415 PHP codebases that have been downloaded using GitHubSpider. To gauge its fea- sibility, we have run our analysis against the top 10 PHP codebases on GitHub, in addition to the codebases in our data set. The following paragraphs describe how seeds were obtained and queries generated (Section 3.1), the nature of the analysis data set <ref type="bibr">(3.3)</ref>, and our analysis results (3.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Identification of Vulnerable Tutorials</head><p>To identify widely read tutorials, we query the Google search engine using the following set of terms.</p><p>"mysql tutorial" "php database user" "php mysql user query" "php search form" "php ajax search tutorial" "javascript echo user input"</p><p>For each of these search terms, we manually review the first five results returned by the search engine. We evaluate each of the tutorials for SQLi and XSS vulnerabilities by following established secure programming guidelines by the Open Web Application Security Project (OWASP), namely, the guide on Reviewing Code for SQL Injection <ref type="bibr" target="#b13">[14]</ref>, and the Cross Site Scripting Prevention Cheat Sheat <ref type="bibr" target="#b27">[28]</ref>. Among the top five results (30 in total), we find 9 tutorials that contain vulnerable code: 6 tutorials with SQLi, and 3 tutorials with XSS. A snippet from a representative tutorial containing both SQLi and XSS vulnerabilities is shown in <ref type="figure">Figure 2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Query Generation</head><p>We expect copy-pasted code from vulnerable tutorials to result in recurring vulnerabilities in application code. A more subtle manner in which recurring vulnerabilities may manifest themselves is when developers follow the same (vulnerable) programming idiom(s) presented by a tutorial. To cater to both possibilities, we generate queries using an exact replica of code present in a tutorial (normal query), and a slice of the tutorial code containing the vulnerability (strict query). A strict query abstracts only the vulnerable slice of code, whereas a normal query abstracts the entire tutorial. We use strict queries to identify known vulnerable patterns in web applications, and normal queries to identify code analogues of tutorial code. <ref type="figure">Figure 5</ref> illustrates the difference between code snippets used for generating normal, and strict queries. Entire tutorial code is shown in the listing with the vulnerable slice highlighted in red. Lines 4-6 of the tutorial contain a classic SQLi vulnerability: Unsanitized user-input from a POST variable is used in a MySQL query. The vulnerable slice contains only these lines, which represents the minimal working snippet containing the vulnerability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Analysis Data-set</head><p>We leverage GitHub to obtain a large data set of web applications for analysis. GitHub hosts over 25 million projects written in several programming languages. Thus, we filter content (PHP projects) that is relevant to us. Our crawler inspects project metadata (accessible via REST API) to perform the filtering. GihubSpider, our code crawler implementation, has filtered through a total of 462,069 PHP repositories on GitHub. Of these, we have downloaded a total of 64,415 PHP codebases for analysis. These codebases comprise our analysis data set.</p><p>We divide our data set into three groups by popularity. We quantify the popularity of a codebase by the number of times it has been starred by users on GitHub. Our classification results in the following data set partitions:</p><p>1. Barely known projects (Not popular). 42,064 projects that are starred at most three times and have a total file size of less than 3 MB.</p><p>2. Projects known by several people (Popular). 16,037 projects that are starred at least four times, but at most nine times, and have a total file size of less than 3 MB.</p><p>3. Popular projects (Very popular). 6,314 projects that are starred at least ten times and have a total file size of less than 3 MB.</p><p>GitHub imposes a rate limit of 5000 API requests per authenticated user per hour. The imposed rate limit proved to be the main bottleneck in downloading repositories. Although using multiple authenticated accounts for crawling is a simple workaround for removing the bottleneck, we stayed clear of it.  <ref type="table">Table 1</ref>: Analysis summary for codebases in our data set. In total, 820 code analogues were found which included 117 recurring vulnerabilities. The table shows a break down of our findings in each data set partition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Analysis Results</head><p>We used auto-generated graph traversals (queries) to mine for analogues in our analysis data set. Discovered analogues were manually reviewed, and vulnerable analogues identified. <ref type="table">Table 1</ref> shows an overview of the analogues, and vulnerabilities discovered by our analyses. With under two dozen graph traversals generated from a handful of vulnerable tutorials, we obtained 820 code analogues of which 117 were found to be vulnerable. We found that string normalization in the AST resulted in non-exact matches. For instance, a query generated from the code snippet $var = $ GET <ref type="bibr">['var']</ref> matched not only its replica but also a seemingly benign snippet such as $var = $value <ref type="bibr">['id']</ref>. Thus, matches returned by the traversals had to be manually validated. In spite of string normalization, we found that automatically generated queries result in interesting corner cases. Among non popular codebases, roughly 1 out of 3 code analogues is vulnerable, and on average 1 out of 7 analogues is vulnerable across the entire data set. Analogues are localized to a small portion of application code, which facilitates manual review of all candidates returned by our analyzer.</p><p>Newly discovered vulnerabilities We manually verified a total of 117 vulnerabilities in our data set. Of these, 8 vulnerabilities were replicas of code from a popular SQL tutorial that we found on the first Google results page. Although all of the 8 vulnerabilities were found among non popular code repositories, the finding shows that ad-hoc code reuse is a reality. We are in the process of notifying the tutorial authors about our findings. Our hope is that the presented vulnerabilities are fixed in a timely manner, so that developers borrowing code from these tutorials in the future will not inherit the same vulnerabilities in their code. CADetector that match the traversal generated for the vulnerable slice in <ref type="figure">Figure 5</ref>. Although we expected to find only SQLi vulnerabilities, we also uncovered a pathtraversal vulnerability that matched our query template.</p><p>80% of the discovered vulnerabilities were SQLi vulnerabilities, and the rest were XSS, and path-traversal vulnerabilities. As shown in <ref type="table">Table 1</ref>, the proportion of vulnerable codebases is higher among low popularity codebases, compared to medium and high popularity codebases. During manual review, we found a plausible explanation for this disparity in vulnerability density: PHP applications in the moderate and high popularity categories make consistent use of newer, and more secure, MySQL APIs in PHP which are not vulnerable to classic (first-order) SQLi attacks. We found that use of the PDO MySQL interface <ref type="bibr" target="#b32">[31]</ref>, and the MySQLi extension <ref type="bibr" target="#b33">[32]</ref> was widespread among these codebases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Discussion</head><p>Manual review of the code analogues and vulnerabilities returned by our analysis framework suggests that, graph traversals are very good at eliciting vulnerable snippets in a large amount of code. Firstly, our approach ensures that the code analogues that we find are small snippets of code, typically spanning under 10 lines of code in our dataset. <ref type="figure" target="#fig_14">Figure 6</ref> shows three code analogues returned by CADetector for a query originating from the vulnerable code snippet in <ref type="figure">Figure 5</ref>. All three analogues span two lines of code and can be quickly assessed by a human analyst.</p><p>Secondly, we find that the abstraction that we choose (AST augmented with data-flow information) is robust. For example, we discovered a path-traversal vulnerability in the process of mining a codebase using a SQLi query. Indeed, both vulnerabilities share the same syntactic structure of code: A tainted PHP variable is used in a security-sensitive PHP function call (mysql query and fopen). However, since our abstraction does not convey information about taintedness of data, our analysis returns analogues where vulnerabilities may need to be manually verified. The third analogue shown in <ref type="figure" target="#fig_14">Figure 6</ref> serves as a demonstrative example. The analogue contains a potential SQLi vulnerability. It is vulnerable if the PHP variable $flight reads from a tainted variable (say, an attacker-controlled $ POST variable). This needs to be manually verified in our setup.</p><p>Analysis runtime Our timing measurements showed that our analysis is fast for even relatively large codebases. For the top 10 PHP code repositories on GitHub, CADetector analysis runtime varies between 19 seconds (for the laravel project, 777 lines of code) and 53 minutes (for symfony, 209 thousand lines of code). Our evaluations suggest that CADetector is a fast analogue detector for codebases with hundreds of thousands of lines of code and above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Related Work</head><p>Our work touches upon two distinct problems: finding similar code, and flagging vulnerabilities in source code. In the following, we contextualize our work in both domains.</p><p>Code clone detection Despite modern software design processes and state of the art programming environments, real-world software development accommodates ad-hoc code re-use. In their seminal work on code clone detection, Baxter et al. <ref type="bibr" target="#b2">[3]</ref>, citing earlier work <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b24">25]</ref>, state that 5-10% of source code is duplicated in large software projects. The initial motivation for code clone detection was that ridding software of seemingly redundant code might achieve a performance gain. Thus, traditional code clone detection tools seek code replicas in a single codebase, or a set of codebases with the same provenance. This has guided the design of several code clone detection tools <ref type="bibr">[2-5, 8, 15, 17, 18, 20, 21, 21- 24, 26, 27]</ref>.</p><p>Recent research <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b30">29]</ref> has shown that code clones pose a more serious threat: Vulnerabilities in cloned code get propagated but their fixes do not. ReDeBug <ref type="bibr" target="#b15">[16]</ref> flags unpatched code clones by finding replicas of a known vulnerable snippet in an OS distribution. Like earlier proposals on code clone detection, ReDeBug flags clones within codebases of similar provenance, because of which it may look for exact matches. In contrast, we cannot always expect to find borrowed code from an external source as is: Developers typically adapt tutorial code for their own end. This subtle difference precludes the use of hashing functions to measure similarity of code in our work. Instead, our queries attempt to recognize the structure of vulnerable code.</p><p>Yamaguchi et al. <ref type="bibr" target="#b37">[36]</ref> propose a machine-learning based method for extrapolating (i.e., finding other instances of) known vulnerable code patterns that are manually specified. Our work is closer to theirs in that we employ structural code fragments (such as AST fragments) to drive the search for vulnerabilities. Having said that, a notable difference is that Yamaguchi et al. perform computations on a code abstraction (specifically, a vector space). In our work, the query for a similar code snippet is concretized in the form of graph traversals. Moreover, we automatically generate vulnerability patterns from code snippets.</p><p>Vulnerability discovery Since we use static program analysis in discovering vulnerabilities, we shall restrict our discussion to prior work in this domain. The dynamic nature of web programming languages, such as PHP and JavaScript, has made static analysis of web applications a challenging task. Researchers have approached vulnerability discovery in PHP code as a static taint analysis problem: Detect the flow of untrusted user input into a security sensitive sink. Pixy <ref type="bibr" target="#b18">[19]</ref> is a static analysis tool that flags XSS, and SQLi vulnerabilities in PHP codebases. In the same vein as Pixy, Xie et al. <ref type="bibr" target="#b35">[34]</ref> present a summary-based static analysis algorithm to discover security vulnerabilities in PHP code. Our proposal is not another vulnerability scanner for PHP code. Rather, our techniques provide a means to draw inferences about unsafe coding practices among web application developers. Considering that web applications are ultimately userfacing programs that handle sensitive data, our study is timely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Limitations and Future Work</head><p>A limitation of our study is that our prototype restricts the evaluation scope of recurring vulnerability detection to PHP application code; that is, we cannot say that programmers employing other languages are similarly prone to copying from tutorials. Moreover, we restrict our analysis to open-source code, and thus, the possibility exists that the practice of copying from tutorials is particularly prevalent in the open-source world and less common in closed-source environments. Exploring these questions is left for future work.</p><p>For the detection of code analogues, we employ an approach that allows the names of identifiers to be changed, but is otherwise strict about the code it matches. For example, if additional statements are introduced in between statements of a seed, we do not detect the corresponding code as a clone. This is a deliberate design choice. Although it may result in the discovery of fewer tutorials, the identified code is more similar to that contained in the tutorial, and therefore, more likely to have been copied from it.</p><p>Our approach-formulating graph traversal queries from code snippets, and issuing these queries in a code mining system-is generic enough to be decoupled from the specifics of a programming language. Thus, our analysis techniques can be incorporated into existing code analysis platforms such as Kythe <ref type="bibr" target="#b10">[11]</ref>, Joern <ref type="bibr" target="#b36">[35]</ref>, and Frappé <ref type="bibr" target="#b11">[12]</ref>. Systematically leveraging popular tutorial content from the Web to seed vulnerability discovery is an avenue for future research. For instance, portals such as Google Trends can be queried to obtain high-value seeds for vulnerability discovery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>Developers routinely consult programming resources as software is written. Although formal documentation such as language and API reference manuals provide detailed guidance, tutorials on the Web are as easily available and are more succinct. The lure of quick actionable advice makes tutorials an appealing reference for developers. We find that tutorials are not only ubiquitous on the Web but also very popular, consistently appearing in the first Google results page. Several tutorials betray a lack of understanding of secure coding practices advocated by well-regarded online communities such as OWASP. In our large-scale case study, we find over 100 vulnerable code snippets in application code that are syntactically similar, and in 8 instances identical, to tutorial code. These findings corroborate our hypothesis that vulnerable tutorials can be used to seed large-scale vulnerability discovery. They also suggest that there is a pressing need for code audit of widely consumed tutorials, perhaps with as much rigor as for production code.</p><p>We show that the syntactic structure of code can be used to infer similarities between code snippets of different provenance. Because syntactic analysis is relatively lightweight, it is fast enough to mine a large number of differently-sized codebases for recurring vulnerabilities. Our large-scale study is a testament to the efficiency of our proposal. This also means that there is low barrier to entry for performing vulnerability discovery at scale. Even an adversary with access to modest computing resources may be seen as direct threat to the security of software in the large open-source landscape. Although our study provides a single data point for an objective assessment of both our adversarial strategy and the connection between tutorials and real-world software, there appears to be promise in the applicability of our techniques to other application classes.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Workflow for finding recurring vulnerabilities.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>$</head><label></label><figDesc>Figure 2: Identified vulnerable tutorial, allowing for SQLi (line 6), and XSS (line 11-12).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Abstract syntax tree and derived template for the example in Figure 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>13: t += filter { "this node's name == name" } 14: else 15: t += sideEffect { Remember the variable } 16:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>.</head><label></label><figDesc>sideEffect{ childnumber = it.childnum } 34 .sideEffect{ childnumber = childnumber + 1 } 35 36 // Right subtree 37 .parents().children() 38 .filter{ it.childnum == childnumber } 39 .filter{ isType(it, "ASSIGN") } 40 .filter{ isType(it.ithChildren(0), "VAR") } 41 42 // Remember variable "found" 43 .sideEffect{ _found = 44 it.ithChildren(0).varToName().next()} 45 .filter{ isType(it.ithChildren(1), "CALL") } 46 .filter{ isType(</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>47 it.ithChildren( 1 )</head><label>471</label><figDesc>.ithChildren(0), "NAME") } 48 .filter{ isType(it.ithChildren(1) 49 .ithChildren(1), "ARG_LIST") } 50 ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Generated traversal for the code snippet in Figure 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>/</head><label></label><figDesc>Figure 5: Vulnerable code snippet from tutorial, containing a SQL injection vulnerability between lines 4-6 (slice).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: The figure shows three analogues returned by CADetector that match the traversal generated for the vulnerable slice in Figure 5. Although we expected to find only SQLi vulnerabilities, we also uncovered a pathtraversal vulnerability that matched our query template.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On finding duplication and near-duplication in large software systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">S</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 2nd Working Conference on</title>
		<meeting>2nd Working Conference on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="86" to="95" />
		</imprint>
	</monogr>
	<note>Reverse Engineering</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Advanced clone-analysis to support object-oriented system refactoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Balazinska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Merlo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dagenais</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lagüe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kontogiannis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reverse Engineering, 2000. Proceedings. Seventh Working Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="98" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Clone detection using abstract syntax trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">D</forename><surname>Baxter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Yahin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Moura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Anna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings., International Conference on</title>
		<meeting>International Conference on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="368" to="377" />
		</imprint>
	</monogr>
	<note>Software Maintenance</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An evaluation of duplicate code detection using anti-unification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bulychev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Minea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 3rd International Workshop on Software Clones. Citeseer</title>
		<meeting>3rd International Workshop on Software Clones. Citeseer</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A language independent approach for detecting duplicated code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ducasse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rieger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Demeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Maintenance, 1999.(ICSM&apos;99) Proceedings. IEEE International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Blueprints property graph model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename><surname>Foundation</surname></persName>
		</author>
		<ptr target="https://github.com/tinkerpop/blueprints/wiki/Property-Graph-Model,online" />
		<imprint>
			<date type="published" when="2016-01" />
		</imprint>
	</monogr>
	<note>accessed 21</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename><surname>Foundation</surname></persName>
		</author>
		<ptr target="http://gremlindocs.spmallette.documentup.com/,online;accessed21" />
		<imprint>
			<date type="published" when="2016-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Scalable and systematic detection of buggy inconsistencies in source code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gabel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Goldszmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
		<idno type="doi">10.1145/1869459.1869475</idno>
		<idno>175-190. OOP- SLA &apos;10</idno>
		<ptr target="http://doi.acm.org/10.1145/1869459.1869475" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications</title>
		<meeting>the ACM International Conference on Object Oriented Programming Systems Languages and Applications<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Uncovering access control weaknesses and flaws with security-discordant software clones</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Gauthier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lavoie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Merlo</surname></persName>
		</author>
		<idno type="doi">10.1145/2523649.2523650</idno>
		<ptr target="http://doi.acm.org/10.1145/2523649.2523650" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Annual Computer Security Applications Conference</title>
		<meeting>the 29th Annual Computer Security Applications Conference<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="209" to="218" />
		</imprint>
	</monogr>
	<note>ACSAC &apos;13</note>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Inc</forename><surname>Github</surname></persName>
		</author>
		<ptr target="https://github.com/,on-line" />
		<imprint>
			<date type="published" when="2015-07" />
		</imprint>
	</monogr>
	<note>accessed 24</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Google</forename><surname>Inc</surname></persName>
		</author>
		<ptr target="https://www.kythe.io/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Frappé: Using clang to visualize large codebases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Hawes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Barham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><forename type="middle">L A</forename><surname>Ben</surname></persName>
		</author>
		<ptr target="http://llvm.org/devmtg/2014-10/Slides/Hawes-Frappe.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Vetting ssl usage in applications with sslint</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Rastogi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Venkatakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the IEEE Symposium on Security and Privacy (S&amp;P)</title>
		<meeting>of the IEEE Symposium on Security and Privacy (S&amp;P)</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Reviewing code for sql injection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Herlea</surname></persName>
		</author>
		<ptr target="https://www.owasp.org/index.php?title=Reviewing_Code_for_SQL_Injection&amp;oldid=88988" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Index-based code clone detection: incremental, distributed, scalable</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hummel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Juergens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Heinemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Conradt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Maintenance (ICSM), 2010 IEEE International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Redebug: Finding unpatched code clones in entire os distributions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Brumley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2012 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2012-05" />
			<biblScope unit="page" from="48" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Kclone: a proposed approach to fast precise code clone detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Binkley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krinke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Matsushita</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third International Workshop on Detection of Software Clones (IWSC)</title>
		<imprint>
			<publisher>Citeseer</publisher>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Deckard: Scalable and accurate tree-based detection of code clones</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Misherghi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Glondu</surname></persName>
		</author>
		<idno type="doi">10.1109/ICSE.2007.30</idno>
		<ptr target="http://dx.doi.org/10.1109/ICSE.2007.30" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Conference on Software Engineering. pp. 96-105. ICSE &apos;07</title>
		<meeting>the 29th International Conference on Software Engineering. pp. 96-105. ICSE &apos;07<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Pixy: a static analysis tool for detecting web application vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Jovanovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2006 IEEE Symposium on Security and Privacy (S P&apos;06)</title>
		<imprint>
			<date type="published" when="2006-05" />
			<biblScope unit="page" from="6" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Clonedetective-a workbench for clone detection research</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Juergens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Deissenboeck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hummel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st International Conference on Software Engineering</title>
		<meeting>the 31st International Conference on Software Engineering</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="603" to="606" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Ccfinder: a multilinguistic token-based code clone detection system for large scale source code. Software Engineering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kamiya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kusumoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Inoue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="654" to="670" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Using slicing to identify duplication in source code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Komondoor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Horwitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Static Analysis</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="40" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Clone detection using abstract syntax suffix trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Koschke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Falke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Frenzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reverse Engineering, 2006. WCRE&apos;06. 13th Working Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="253" to="262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Identifying similar code with program dependence graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krinke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. Eighth Working Conference on</title>
		<meeting>Eighth Working Conference on</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="301" to="309" />
		</imprint>
	</monogr>
	<note>Reverse Engineering</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Assessing the benefits of incorporating function clone detection in a development process</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lague</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Proulx</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mayrand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Merlo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hudepohl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Maintenance, 1997. Proceedings., International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="314" to="321" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Finding function clones in web applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lanubile</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Mallardo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Maintenance and Reengineering, 2003. Proceedings. Seventh European Conference on</title>
		<imprint>
			<date type="published" when="2003-03" />
			<biblScope unit="page" from="379" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Cp-miner: finding copy-paste and related bugs in large-scale software code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Myagmar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="176" to="192" />
			<date type="published" when="2006-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Xss (cross site scripting) prevention cheat sheet</title>
		<ptr target="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet#" />
	</analytic>
	<monogr>
		<title level="j">OWASP</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Why_Can</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">27</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">3F, online; accessed 19</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Untrusted_Data</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Detection of recurring software vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">H</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">T</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">N</forename><surname>Nguyen</surname></persName>
		</author>
		<idno type="doi">10.1145/1858996.1859089</idno>
		<ptr target="http://doi.acm.org/10.1145/1858996.1859089" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE/ACM International Conference on Automated Software Engineering</title>
		<meeting>the IEEE/ACM International Conference on Automated Software Engineering<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="447" to="456" />
		</imprint>
	</monogr>
	<note>ASE &apos;10</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Reps</surname></persName>
		</author>
		<title level="m">Program analysis via graph reachability. Information and Software Technology</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>The Php Documentation</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Group</surname></persName>
		</author>
		<ptr target="https://secure.php.net/manual/en/ref.pdo-mysql.php" />
		<title level="m">Php: Mysql (pdo) manual</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>The Php Documentation</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Group</surname></persName>
		</author>
		<ptr target="https://secure.php.net/manual/en/book.mysqli.php" />
		<title level="m">Php: Mysqli manual</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Usage of server-side programming languages for websites</title>
		<ptr target="http://w3techs.com/technologies/overview/programming_language/all" />
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="17" to="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Static detection of security vulnerabilities in scripting languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=1267336.1267349" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Conference on USENIX Security Symposium -Volume</title>
		<meeting>the 15th Conference on USENIX Security Symposium -Volume<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="volume">15</biblScope>
		</imprint>
	</monogr>
	<note>USENIX-SS&apos;06, USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Modeling and discovering vulnerabilities with code property graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Yamaguchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Golde</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Arp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Rieck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IEEE Symposium on Security and Privacy</title>
		<meeting>of IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Generalized vulnerability extrapolation using abstract syntax trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Yamaguchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lottmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Rieck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th Annual Computer Security Applications Conference</title>
		<meeting>the 28th Annual Computer Security Applications Conference</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="359" to="368" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
