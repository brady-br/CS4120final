<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:30+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">When Oblivious is Not: Attacks against OPAM</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nirjhar</forename><surname>Roy</surname></persName>
							<email>nirjhar@iitk.ac.in</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Indian Institute of Technology -Kanpur</orgName>
								<orgName type="institution" key="instit2">Indian Institute of Technology -Kanpur</orgName>
								<orgName type="institution" key="instit3">Indian Institute of Technology -Kanpur</orgName>
								<orgName type="institution" key="instit4">Nikhil Mittal Fortanix</orgName>
								<orgName type="institution" key="instit5">Indian Institute of Technology -Kanpur</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikhil</forename><surname>Bansal</surname></persName>
							<email>nikhilba@iitk.ac.in</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Indian Institute of Technology -Kanpur</orgName>
								<orgName type="institution" key="instit2">Indian Institute of Technology -Kanpur</orgName>
								<orgName type="institution" key="instit3">Indian Institute of Technology -Kanpur</orgName>
								<orgName type="institution" key="instit4">Nikhil Mittal Fortanix</orgName>
								<orgName type="institution" key="instit5">Indian Institute of Technology -Kanpur</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gourav</forename><surname>Takhar</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Indian Institute of Technology -Kanpur</orgName>
								<orgName type="institution" key="instit2">Indian Institute of Technology -Kanpur</orgName>
								<orgName type="institution" key="instit3">Indian Institute of Technology -Kanpur</orgName>
								<orgName type="institution" key="instit4">Nikhil Mittal Fortanix</orgName>
								<orgName type="institution" key="instit5">Indian Institute of Technology -Kanpur</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pramod</forename><surname>Subramanyan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Indian Institute of Technology -Kanpur</orgName>
								<orgName type="institution" key="instit2">Indian Institute of Technology -Kanpur</orgName>
								<orgName type="institution" key="instit3">Indian Institute of Technology -Kanpur</orgName>
								<orgName type="institution" key="instit4">Nikhil Mittal Fortanix</orgName>
								<orgName type="institution" key="instit5">Indian Institute of Technology -Kanpur</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">When Oblivious is Not: Attacks against OPAM</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Enclave platforms like Intel SGX, Sanctum and Keystone promise attractive security guarantees but have not always lived up to their billing, mostly due to side channel leaks in platform implementations. A particularly important side channel in these platforms has been the page-fault side channel. This side channel has proven to be particularly problematic because it is deterministic and controllable by a malicious operating system. This paper presents a new attack on the page-fault channel that works on the state-of-art proposal for secure demand paging in enclaves (InvisiPage, ISCA&apos;19). The insight behind the attack is that even if the exact page-fault addresses are hidden, the adversary may be able to infer the interval between when a page is evicted from an enclave and when it is fetched back into the enclave. Our evaluation shows this leak is sufficient to: (i) identify which application is being executed in an enclave, (ii) infer confidential details about the inputs to the application, and (iii) function as a covert channel between an untrusted enclave application and a malicious operating system.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Enclave platforms <ref type="bibr" target="#b4">[6,</ref><ref type="bibr" target="#b8">10,</ref><ref type="bibr" target="#b11">13,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr" target="#b15">17,</ref><ref type="bibr" target="#b22">24,</ref><ref type="bibr" target="#b27">29,</ref><ref type="bibr" target="#b28">30,</ref><ref type="bibr" target="#b31">33,</ref><ref type="bibr" target="#b44">46]</ref> enable secure execution of applications in the presence of a privileged software adversary. Enclave platforms can, in principle, enable secure computing in the cloud even if co-located applications and the cloud provider's infrastructure are malicious. These platforms achieve this security guarantee by relying on trusted hardware primitives that isolate a region of memory such that only the code that lies within this region can read and write to it.</p><p>Despite providing attractive security guarantees, enclave platforms have been plagued by implementation vulnerabilities. Almost all of these are based on side channels violating confidentiality <ref type="bibr" target="#b9">[11,</ref><ref type="bibr" target="#b16">18,</ref><ref type="bibr" target="#b26">28,</ref><ref type="bibr" target="#b29">31,</ref><ref type="bibr" target="#b40">42,</ref><ref type="bibr" target="#b45">47,</ref><ref type="bibr" target="#b47">49]</ref> that enable exfiltration of confidential data from enclaves. In this context, it is worth distinguishing two kinds of side channels: (i) softwarevisible hardware side channels such as caches, prefetchers, and branch predictors, and (ii) software side channels, like page tables. Significant progress has been made in addressing the first kind of side channel by isolating shared microarchitectural resources to ensure non-interference between protection domains (e.g. <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr" target="#b37">39]</ref>).</p><p>Software side channels, especially page tables, have received less attention. In their seminal work on controlledchannel attacks, Xu et al. <ref type="bibr" target="#b47">[49]</ref> showed that careful control of the page tables makes it possible to extract large amounts of confidential information from enclaves. They extracted image outlines from image processing applications and text documents from word processing tools. Their attack relies on the fact that platforms like SGX allow the operating system (OS) to retain control over the enclave applications page tables and use the OS to service page-faults. This control is exploited by the OS to cause page-faults within the enclave by marking all pages as not being present and learning the enclave's memory access pattern by observing which page-faults are triggered.</p><p>An initial defense against the controlled channel attack was T-SGX <ref type="bibr" target="#b39">[41]</ref> which uses transactional memory extensions to detect if an attack is underway and aborts execution if one is detected. T-SGX was defeated by a stealthier attack from Van Bulck et al. <ref type="bibr" target="#b46">[48]</ref> which analyzed page tables' accessed and dirty bits without causing page-faults. An approach that has proven more resilient has been the idea of making enclave page tables private. This approach was first taken by Iso-X <ref type="bibr" target="#b15">[17]</ref>, and was subsequently adopted by Sanctum <ref type="bibr" target="#b12">[14]</ref>, Apparition <ref type="bibr" target="#b14">[16]</ref>, Keystone <ref type="bibr" target="#b27">[29,</ref><ref type="bibr" target="#b28">30]</ref> and InvisiPage <ref type="bibr" target="#b3">[5]</ref>.</p><p>Simply making enclave page tables private is not enough, page fetches and evictions will be visible to the untrusted operating system (OS) because the OS continues to manage resource allocation. As a result, the OS can infer enclave secrets by observing the sequence of page-faults that an enclave experiences. Sanctum <ref type="bibr" target="#b12">[14]</ref> side-stepped this problem by disabling demand paging of enclave memory by default. This is clearly secure: if page-faults are not adversary-observable, nothing can leak via page-faults.</p><p>However, disabling demand paging is undesirable as it restricts enclaves to fixed-size working sets. There is significant interest in enclave applications that operate on large amounts of data, e.g. databases <ref type="bibr" target="#b33">[35]</ref>, blockchains <ref type="bibr" target="#b10">[12]</ref>, machine learning <ref type="bibr" target="#b23">[25,</ref><ref type="bibr" target="#b32">34]</ref>, data analytics <ref type="bibr" target="#b35">[37,</ref><ref type="bibr" target="#b49">51]</ref>, to name just a few. Restricting these applications to small datasets limits applicability of enclave platforms. Currently these applications have either used demand paging while disregarding the pagefault side channel <ref type="bibr" target="#b23">[25,</ref><ref type="bibr" target="#b33">35]</ref> or have developed novel oblivious algorithms that do not leak information via the program's access pattern <ref type="bibr" target="#b32">[34,</ref><ref type="bibr" target="#b49">51]</ref>. Neither of these is a satisfactory state of affairs. Principled solutions to the page-fault side channel will deliver increased security for all enclave applications rather than just those which have been custom-developed.</p><p>In response to the above concerns, Aga and Narayanasamy introduced InvisiPage <ref type="bibr" target="#b3">[5]</ref>, which enables demand paging in an enclave processor through an oblivious page access module (OPAM). InvisiPage addresses some of the above concerns by hiding the page-faults experienced by an enclave through interposition of an oblivious RAM (ORAM) primitive <ref type="bibr" target="#b18">[20,</ref><ref type="bibr" target="#b42">44]</ref> between an enclave's page-faults and OS-visible page operations. Unfortunately, instead of using a "vanilla" ORAM primitive, InvisiPage introduces certain optimizations to Path ORAM <ref type="bibr" target="#b42">[44]</ref> in order to improve performance. In this paper, we perform a careful security analysis of these optimizations and show that InvisiPage is vulnerable to a new type of side channel leak. It leaks the reuse distances of enclave pagesthe number of page-faults between when a page is evicted and subsequently re-fetched into the enclave.</p><p>We show that this vulnerability can be exploited in three ways. First, we can train a convolutional neural network to fingerprint applications executing within an enclave. Second, we can use the same kind of fingerprinting to classify the confidential types of inputs an enclave is operating on. Finally, we show that the reuse distance attack can be used as covert channel that transmits up to 70 bits/second between an enclave application that is sandboxed using techniques like Ryoan <ref type="bibr" target="#b24">[26]</ref> and a colluding operating system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>This section provides a brief review of enclave platforms, demand paging in enclaves and tree-based oblivious RAMs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Overview of Enclave Platforms</head><p>Enclave platforms provide trusted hardware primitives for secured execution of application code in the presence of a privileged software adversary. This is achieved by isolating a range of memory addresses such that only the code within that range of memory is allowed to read/write to the range. This form of isolation ensures confidentiality and integrity against direct attacks. Confidentiality also requires isolation of various microarchitectural side channels, and some implementations have adopted such isolation techniques <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr" target="#b37">39]</ref>. Enclave platforms must also provide an attestation operation <ref type="bibr" target="#b7">[9,</ref><ref type="bibr" target="#b44">46]</ref> that produces a signed cryptographic digest, called a measurement, of the initial state of the enclave.  <ref type="bibr">Enc(Output)</ref> zeroed out memory untrusted mem   <ref type="figure" target="#fig_1">Figure 1</ref> shows an example of an enclave executing a private program on a private dataset. First, the application loads the public components of its code and data into memory via the operating system. Since the OS is untrusted, there is no guarantee that the code and data loaded into memory are what was intended. Therefore, before the enclave becomes usable, a seal operation is required. This makes the initial code and data inaccessible to all other software on the platform. Immediately and atomically after sealing, the platform computes the enclave's measurement and stores the measurement in a trusted processor register. An attestation is a hardware-signed statement including this measurement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Life Cycle of an Enclave</head><p>In step 2, this attestation is provided (possibly over a network connection) to the trusted first-party who requested the creation of the enclave. If the attestation is valid, the first party and the enclave will establish a secure communication channel and the secret components of the code and data will be sent to the enclave. Note that enclave itself does not need to directly perform these I/O operations (and is not allowed to perform I/O in the case of Intel SGX), these are proxied through the untrusted OS and cryptography provides confidentiality and integrity against a malicious OS. In steps 4 to 6, the enclave decrypts this private code and data, computes and produces encrypted output that is sent to the first-party.</p><p>Finally, in step 7, the enclave is destroyed. The platform ensures that enclave memory is zeroed out at the time of destruction to prevent the OS from extracting secrets from the enclave after destruction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Page Fault Handling in Enclaves</head><p>Intel SGX places the page tables under the control of the host OS. SGX uses special hardware protections to prevent the OS from changing the contents of the enclave's pages while still allowing the OS to perform demand paging. This is ideal from a resource-management perspective but opens up the possibility of page table-based attacks <ref type="bibr" target="#b40">[42,</ref><ref type="bibr" target="#b46">48,</ref><ref type="bibr" target="#b47">49]</ref>, which allow a malicious OS to infer confidential information about the enclave's execution. Sanctum <ref type="bibr" target="#b12">[14]</ref> addresses this problem by maintaining a separate page table in enclave memory. While the page table's initial setup is done by the OS, it becomes private to the enclave after sealing (Step 2 in <ref type="figure" target="#fig_1">Figure 1</ref>). <ref type="bibr" target="#b0">1</ref> Sanctum allocates contiguous regions of virtual and physical memory to the enclave. The allocated memory is divided into two compartments, one compartment for the enclave runtime and the other for the application. These two compartments are isolated from each other via standard page table permission-bits. The mapping between these virtual and physical memory regions is controlled via the page tables which are stored in enclave runtime memory. When a page-fault occurs, execution is redirected to a page-fault handling routine in the runtime. The default runtimes in Sanctum and Keystone kill the enclave when a page-fault occurs; recent versions of Keystone provide an optional page-fault handler that simply encrypts page data. Oblivious RAM (ORAM) primitives enable secure demand paging in enclaves by interposing an ORAM between enclave accesses and OS-visible operations. This approach, first suggested by <ref type="bibr">Sanctum [14]</ref> and implemented by InvisiPage <ref type="bibr" target="#b3">[5]</ref> is shown in <ref type="figure" target="#fig_2">Figure 2</ref>. The steps shown in the figure are described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Overview of Secure Demand Paging Approaches</head><p>1. The page-fault occurs and is handled by the runtime.</p><p>2. The runtime determines whether this is a demand fault and if an eviction is required before the demand fetch.</p><p>3. If an eviction is needed, the victim page is identified and an ORAM client write is performed. If no eviction is needed, only an ORAM client read is performed. ORAM client reads and writes correspond to page fetch and eviction requests respectively.</p><p>4-5) In typical tree-based ORAMs, a client read or write involves several server reads and writes. In our specific case, server reads and writes correspond to OS-visible page fetches and page evictions respectively. Data in these pages is protected using randomized authenticated encryption. The ORAM orchestrates the reads and writes such that the OS learns nothing about the page addresses accessed by the application.</p><p>6) Eventually the page of interest is brought inside the enclave, decrypted and made available to the runtime.</p><p>7) The runtime now maps this page into the page table and returns control back to the enclave application.</p><p>The interface functions between the different components involved in the above process are shown in <ref type="table" target="#tab_1">Table 1</ref>. Most functions in <ref type="table" target="#tab_1">Table 1</ref> have been described above. The new entrants are allocPages and reclaimPages which are used by the enclave to request additional physical memory from the OS, and by the OS to request that an enclave free some of its memory and return it to the OS, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Overview of Path ORAM</head><p>Oblivious RAM (ORAM) <ref type="bibr" target="#b18">[20,</ref><ref type="bibr" target="#b19">21]</ref> is a cryptographic primitive that allows a client with a small amount of trusted storage to access a much large untrusted server storage while maintaining computational indistinguishability of usage access patterns. Most recent implementations of ORAMs have used the tree-based ORAM structure introduced by Shi et al. <ref type="bibr" target="#b38">[40]</ref> and Path ORAM <ref type="bibr" target="#b42">[44]</ref>, introduced by Stefanov and colleagues is perhaps the best-known exemplar of tree-based ORAMs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Path ORAM Data Structures</head><p>The two data structures maintained by Path ORAM in the enclave are a stash: a temporary array containing recently accessed pages and the position map which stores a mapping between enclave virtual addresses (trusted) and OS identifiers (untrusted addresses). In the untrusted OS, Path ORAM stores a binary tree comprised of buckets. Each bucket typically contains 4 encrypted pages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Path ORAM Invariant</head><p>Each page in the ORAM tree is mapped to some leaf by the position map and the page is stored somewhere along the path from the root to this leaf in the tree. The invariant explains why Path ORAM tree nodes are buckets containing multiple pages. Some leaves may be oversubscribed and the bucket structure prevents failure in these cases. <ref type="bibr" target="#b1">2</ref> Some buckets may also be undersubscribed and if so "dummy" pages containing random data are stored in them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.3">Path ORAM Access Algorithm</head><p>Algorithm 1 Path ORAM Pseudocode 1: procedure ACCESS(vpn, op, data * ) 2:</p><p>leaf ← positionMap <ref type="bibr">[vpn]</ref> 3:</p><formula xml:id="formula_0">positionMap[vpn] ← UNIFORMRANDOM(1, N) 4: stash ← stash ∪ READPATH(leaf) 5:</formula><p>data ← stash <ref type="bibr">[vpn]</ref> 6:</p><formula xml:id="formula_1">if op = evict then stash[vpn] ← data * 7:</formula><p>end if return data 10: end procedure Pseudocode for Path ORAM is shown in Algorithm 1. The algorithm is remarkably simple and elegant, but has a number of subtleties and pitfalls which we discuss in the next subsection. Each ORAM client access is handled in the following way. First, we look up the position map of the leaf node to which the requested page is mapped to (line 2). Second, we remap the page to a new leaf (line 3). Now the entire path from the root to this leaf is read in from the untrusted server into the client-side stash (line 4). After each bucket is read in, it is also authenticated and decrypted. Authentication ensures that the server has not modified the data. Decryption is needed because items in the tree are encrypted. Next, the requested page is fetched from the stash (line 5). If the access is an eviction, the stash is updated to contain the new data (line 6). Finally, we write all items in the stash that can possibly be stored on this path to the leaf back to the server (line 8).  An access is made to vpn=88 and this page is remapped to leaf 0. The ORAM fetches all buckets along the path to the leaf labeled 2. This brings in pages with vpn 88, 385 and 524 into the stash. Now all pages which can be written along this path in the stash are spilled from the stash back to the ORAM. This allows us to spill vpn 250 from the stash to the ORAM, vpn 385 is "pushed down" while 88 can only be stored at the root node because it has now been mapped to leaf 0. From the perspective of the untrusted OS, it only sees the enclave read in encrypted data stored in buckets labeled 6, 5 and 2 and write re-encrypted data back to the same buckets. The specific information about which pages were moved, which pages stayed in the same location, which new pages were spilled to the ORAM, etc. are all opaque to the OS due to randomized (re-)encryption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.4">Understanding Security of Path ORAM</head><p>Why is Path ORAM secure? First, let us consider the access pattern of the algorithm. Each access is a sequence of reads and writes to all buckets on the path from the root to some leaf. Specifically which leaf is accessed depends on the position map. All entries in the position map are obtained from a cryptographically secure pseudorandom number generator and are independent of the enclave program's page-faults.</p><p>How about the actual data itself? Path ORAM requires that all blocks stored in untrusted memory be (computationally) indistinguishable to the adversary (OS). This means that the OS should not be able to distinguish between dummy pages and real pages. It must also not be able to distinguish between pages that were read into the stash and the (possibly different, possibly identical) pages that are written back from the stash. Further, among the many pages that are read into the enclave, the OS must not be able to distinguish between the real page that was requested, unrelated real pages, and dummy pages. Authentication, randomized encryption and re-encryption of all pages on a particular path with each access are needed to ensure that the above security properties are satisfied.</p><p>Path ORAM brings in a whole path from the root to some leaf in the tree. The application itself requires only the page it has requested. If Path ORAM did not authenticate all the pages which were fetched, the untrusted OS could tamper with some subset of pages and check whether the tampering is detected. If no error is raised, the OS can infer that tampered pages were not accessed; this breaks indistinguishability.</p><p>Second, we need randomized encryption as well as reencryption of all pages on the path with each ORAM access. With each access, the host OS sees that the ORAM fetches a number of pages into the enclave along a path from the root to some leaf, and writes a number of pages back into the tree along the same path. Suppose identical data is fetched into the enclave and then written back with the exception of a single page that was modified. This lets the OS determine exactly which page was accessed, this also breaks indistinguishability.</p><p>In practice, these pitfalls are easily avoided by the use of authenticated encryption modes (e.g. Galois Counter Mode) with a fresh initialization vector (IV) for each (re)-encryption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Oblivious Page Access Module (OPAM)</head><p>Aga and Narayanasamy introduced the Oblivious Page Access Module (OPAM) as part of InvisiPage <ref type="bibr" target="#b3">[5]</ref>. OPAM builds on a Path ORAM substrate and introduces several optimizations to improve performance in the context of demand paging for enclaves. We do not review all the details of OPAM due to a lack of space and instead discuss its most important security-relevant optimizations. OPAM stores additional metadata corresponding to each tree node. Each access fetches this metadata inside the enclave and analyzes it to determine exactly which level of the tree contains the page of interest and fetches/evicts only this particular page in/out of the enclave. The other pages, which may need to be re-organized in order to prevent ORAM failure are shuffled without reencryption using an enclave-specific key. This optimization reduces the cost of each ORAM access from reading, decrypting, re-encrypting and writing lg N pages to reading and writing lg N pages but decrypting/encrypting only one page.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Security Analysis of OPAM</head><p>OPAM retains the same access template as Path ORAM in that a randomly-chosen path from the root to leaf in the tree is accessed with each client operation. Therefore, the path itself does not leak any information. In contrast to Path ORAM, OPAM does allow the host OS to distinguish between page evictions (client writes) and page fetches (client reads). This leaks one bit of information with each access and does not appear to be large enough to be exploitable. The most significant leak in OPAM is due to the fact that only one page is fetched into the enclave and all pages of others along this particular path are merely shuffled by the untrusted host OS. Since the entire path is not re-encrypted with each access, the untrusted host OS can distinguish between pages which are moved up/down the ORAM tree, pages which are read into the enclave, and pages which are newly spilled from the enclave to the ORAM. The primary difference in terms of obeservability of vanilla PATH ORAM and Invisipage is that in PATH ORAM, the adversary is able to observe a random set of pages(fully encrypted) getting read and written, whereas in Invisipage the adversary can see only one page getting read or written. So this leak information about the page getting read or written.</p><p>We refer to the number of page-faults that occur between a page eviction and a subsequent re-fetch of the page as the page's reuse distance. The above analysis shows that OPAM allows an honest-but-curious host OS to learn the reuse distances of all pages evicted from the enclave. While this may appear to be a benign leak, our experiments show that reuse distances are effective in exfiltrating secrets from enclaves.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Attacks on InvisiPage/OPAM</head><p>We now describe the main attack introduced by this paper: the page reuse distance attack. We start with a description of the threat model used in this section. We then provide an intuitive description of why re-use distances leak information and describe details of the attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Threat Model</head><p>We assume the standard enclave threat model corresponding to a software attacker. Only the enclave itself and the hardware platform are trusted <ref type="bibr" target="#b3">[5,</ref><ref type="bibr" target="#b43">45]</ref>. All other software on the system, including privileged software such as OS and other enclaves, are untrusted. The adversary can observe all invocations of untrusted code made by the enclave and read and modify all the untrusted code and data stored in untrusted memory. The adversary can also observe all the pages that are evicted by the enclave to the untrusted memory and read from the untrusted memory back to the enclave memory.</p><p>We do not consider microarchitectural side channels (e.g. cache-based side channels <ref type="bibr" target="#b25">[27,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b36">38]</ref>). These can be mitigated by isolating shared microarchitectural resources across protection domains as done in Sanctum <ref type="bibr" target="#b12">[14]</ref>, MI6 <ref type="bibr" target="#b6">[8]</ref>, etc. We do not consider the timing side channel for page-faults; that is we do not consider attacks based on measuring the wall-clock time between successive page-faults. The timing channel can be blocked by making ORAM accesses at a fixed rate <ref type="bibr" target="#b17">[19]</ref>. Figure 4: Illustrating relation between reuse distances and access patterns. The numbers within the boxes are page addresses while the labels above the boxes show the reuse distance for that particular address. <ref type="figure">Figure 4</ref> shows two kinds of access patterns. In <ref type="figure">Figure 4</ref>(a), the program repeatedly scans over an array. This results in the linear access pattern shown where four pages labeled from 0 to 3 are repeatedly accessed. Suppose the enclave has only two pages in its working set and the LRU page replacement algorithm is used. When the access to page 2 is made, page 0 will need to be evicted. Two page-faults later, when page 0 is accessed again, it will be fetched back into the enclave. For this access pattern, the reuse distance of every page is 2. In contrast, <ref type="figure">Figure 4</ref>(b) shows the access pattern for a program that repeatedly traverses a binary tree. For the tree traversal, the reuse distance of the root is 2 because the root node (labeled 0) is accessed in every iteration. The reuse distances for non-root pages are multiples of 2 because these may or may not be accessed in successive iterations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Why are Reuse</head><p>Therefore, if we have two programs running with an enclave -one performing a linear scan repeatedly and the other performing a tree traversal -we can distinguish between them by observing the reuse distances of pages evicted from the enclave. The reuse distance attack exploits this insight by training a convolutional neural network sequence classifier to fingerprint victim enclaves using their page reuse distances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Attacking OPAM Using Reuse Distances</head><p>The OPAM/untrusted memory interface consists of three operations: page evictions, page fetches and page shuffles. For simplicity, we assume the OS can directly intercept calls to pageRead and pageWrite in order to track the reuse distances of all pages as shown in Algorithm 2. The attack is not restricted to direct interception as discussed in the next subsection. The algorithm has two main procedures: trace ← trace ++ reuseDist <ref type="bibr">[k]</ref> 10:</p><p>delete reuseDist[k] 11: end procedure ONPAGEWRITE and ONPAGEREAD. These procedures are called by the adversarial OS whenever calls to pageWrite and pageRead respectively are intercepted. ONPAGEWRITE initializes the reuse distance of a freshly evicted page to be zero. Both procedures increment the reuse distance of all pages currently in the ORAM when a page is read/written. The array trace contains a sequence of reuse distances and ONPAGEREAD adds the reuse distance of the page being fetched to trace when that page is fetched from the OS into the enclave. This array is fed to a sequence classifier in order to exfiltrate secrets from the enclave application.</p><p>Why are page evictions/fetches adversary observable? The obvious (and perhaps cleanest) implementation of the pageRead and pageWrite operations is to invoke them by calling into the untrusted OS. In this case, they will obviously be visible to adversarial OS which can intercept and redirect these calls. Even if these operations are performed from within the enclave, their effect can be observed using the flush+reload techniques described in <ref type="bibr" target="#b46">[48,</ref><ref type="bibr" target="#b48">50]</ref>. Enclave side channel protections (e.g. <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr" target="#b37">39]</ref>) cannot prevent this leakage. These protect enclave memory; but the backing store is not part of the enclave and necessarily OS-accessible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The Level Tracking Attack</head><p>Can InvisiPage/OPAM be made secure by just re-encrypting all pages upon each access? Since OPAM has dataless stash, re-encrypting a page would need bringing the page into the enclave, re-encrypting it and writing it back. On the other hand, the page being accessed will either be read or written (depending on access type) but not both. Thus, re-encryption does not help preventing hiding of access type. In this section, we consider only the level of the accessed page in the OPAM tree and show that it alone is enough to leak information about the application.</p><p>It turns out that level at which data is stored in an ORAM tree loosely correlates with the age (aka reuse distance) of the data. Why does the level leak information? Each ORAM access (at least in principle) brings in the entire path into the stash, re-encrypts each of these pages and writes data from the stash back greedily as close to the leaf as possible. In OPAM, these operations are performed without necessarily reading the path into the enclave, but the effective movement of data is the same. This results in "pushing" older pages towards lower (closer-to-leaf) levels of the tree.</p><p>Thus, the level of the page accessed in the OPAM tree leaks information about the age of the accessed page. This leads to a straightforward extension of the reuse distance attack, where instead of collecting a trace of reuse distance, we collect a trace of access levels. <ref type="bibr" target="#b2">3</ref> We show that this trace is sufficient to identify secret applications, albeit with lower confidence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Covert Channels Using Reuse Distances</head><p>In this section we show that reuse distances can be used as a covert channel to transmit information from a sandboxed enclave to the outside world. Platforms like Ryoan <ref type="bibr" target="#b24">[26]</ref> and /CONFIDENTIAL <ref type="bibr" target="#b35">[37,</ref><ref type="bibr" target="#b41">43]</ref> aim to isolate untrusted enclave applications using a trusted enclave runtime. For example, Ryoan can be used for private genomic data analysis within an untrusted enclave and guarantees that only a binary output corresponding to the result of the analysis is revealed. These security guarantees are enforced using ideas similar to software fault isolation by restricting enclave access to non-enclave memory, and enclave OCALLs (external calls) to pre-defined trusted API functions.</p><p>The reuse distance leakage of OPAM provides such applications a covert channel to leak secret information (e.g. the input genome data) by carefully engineering their access patterns to cause a particular sequence of page-faults.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Threat Model</head><p>Our threat model here is similar to the one in Section 3.1 with the additional qualification that enclave application tries to collude with the host operating system to leak sensitive input data to the enclave The host OS is aware of the encoding used by the enclave application to transmit information via the reuse distance cover channel. <ref type="figure" target="#fig_6">Figure 5</ref> shows attack model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Encoding information in Reuse Distances</head><p>Assume we have an n-bit message to transmit and we are using a k-ary encoding for this message. Since the enclave is colluding with the OS, we assume the number of physical pages allocated to the enclave is P = n/log 2 (k); P is the length of a k-ary encoding of the message. The enclave allocates a buffer of size B = 2 × P × k pages and accesses all the pages in this buffer in sequence. This causes the eviction of P × (2 × k − 1) pages from the enclave. We can now leak a k-ary encoded message (k and the message length <ref type="bibr" target="#b2">3</ref> Please see Appendix A for details on how the levels are leaked is known to host OS) as follows. Each k-ary digit d is encoded by accessing a page with virtual page numbers in the range</p><formula xml:id="formula_2">[(k − d − 1) * 2P, (k − d) * 2P), which corresponds to the reuse-distance [d * 2P, (d + 1) * 2P).</formula><p>The host OS can trace the sequence of reads, writes and reuse distances by the enclave and later process it to extract the message. We note that this is one possible encoding and depending on the data to be leaked, much more efficient encodings can be used. We verified that this attack works with replacement policies like FIFO, LRU, LFU, CLOCK.</p><p>Example Encoding: Suppose the application wants to transmit a message 1011 using a binary encoding. The length n = 4 and k = 2. The enclave will allocate a buffer with B = 2 × 4 × 2 = 16 virtual pages. The runtime uses FIFO for page replacement and has been allocated P = 4 enclave physical pages to the application. First all the pages are accessed in sequence which generates OS observable sequence of page evictions to pages 1 to 12 respectively. To transmit the first bit of the message, which is 1, the application accesses a page with reuse distance in range <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b14">16)</ref>. To transmit the second bit, the enclave accesses a page with reuse distance in the range <ref type="bibr">[0,</ref><ref type="bibr" target="#b6">8)</ref>. The third and fourth bit are also transmitted similarly, resulting in the access sequence 1, 8, 2, 3. This can be decoded by the OS as being the message 1011.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head><p>This section presents our experimental evaluation of the reuse distance and level-tracking attacks, and the reuse distance covert channel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Methodology</head><p>This subsection briefly describes the experimental infrastructure, methodology and the benchmarks used in this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Experimental Infrastructure</head><p>Our experiments were conducted on the open source Keystone Enclave Platform <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b28">30]</ref> where we implemented InvisiPage/OPAM. The Keystone runtime is written in C and our modifications are ≈ 2800 SLoC. We used RISC-V QEMU <ref type="bibr" target="#b2">[3]</ref> to conduct these experiments in emulation mode. We have verified via experiments with a HiFive Unleashed board <ref type="bibr" target="#b0">[1]</ref> that results on emulation are representative of results on the actual hardware. To perform the reuse distance attack, we instrumented the untrusted components of InvisiPage and the encrypted address handlers to collect the reuse distance trace as described in Algorithm 2. <ref type="bibr">4</ref> We used both FIFO and CLOCK replacement in our experiments.We intend to open source the full experimental framework at the time of publication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Benchmarks</head><p>We created a benchmark suite consisting of five applications and three microbenchmarks chosen from diverse domains. We picked applications satisfying the following criteria. Applications amenable to enclaved execution, usually as privacypreserving versions of cloud services. Applications that work in batch mode: they only receive input once at the beginning of execution and produce output at the end of execution. Since enclaves must proxy all their input/output via the host OS, it is much easier to identify applications that interact with the OS multiple times in different ways by just fingerprinting these I/O interactions. We focus on the more challenging scenario where the encrypted input is given only once and encrypted output is also produced only once.</p><p>Applications used were the following.</p><p>1. avl, sha and mat_mul: The latter two are from Keystone's source code. avl is from <ref type="bibr" target="#b34">[36]</ref>.</p><p>2. picosat is a solver for propositional satisfiability by Biere et al. <ref type="bibr" target="#b5">[7]</ref>. SAT solvers are at the core of modern formal verification techniques and we use picosat as a proxy for privacy-preserving cloud-based verification platforms. <ref type="bibr">4</ref> Note that our implementation of InvisiPage/OPAM does not include the EPC-lite region of memory. EPC-lite is proposed by InvisiPage as a region of memory that provides page-level memory encryption as opposed to cache-block level memory encryption implemented in the EPC. The former has lower overheads for encryption and authentication assuming accesses occur only at the granularity of pages. The Freedom U540 does not have hardware support for memory encryption and our threat model does not include a hardware attacker, so separating EPC and EPC-lite does not reduce overheads.</p><p>3. lbm: This fluid dynamics application is taken from SPEC CPU 2017. It is representative of proprietary scientific applications being executed on untrusted clouds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>Recommender: This is a product recommendation engine built using collaborative filtering by Hamrouni et al. <ref type="bibr" target="#b20">[22]</ref>. It as an exemplar of the class of privacy-preserving cloudbased machine learning frameworks.</p><p>5. libjpeg: This application performs JPEG encoding. It is interesting because it is an example of a privacypreserving image processing application implemented using enclaves. This application was also studied by Xu et al. <ref type="bibr" target="#b47">[49]</ref>.</p><p>6. xz: This is also taken from SPEC CPU 2017 and is an example of data compression application that is likely to be commonly used in cloud-based services.</p><p>We had to modify the benchmarks for the Keystone environment. These changes consist of about 1200 lines of code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Attack Evaluation</head><p>How can the leakage of reuse distances and levels accessed be used to infer confidential applications? There are two possibilities: (a) given a secret application running within an enclave, the OS may use reuse distances or level access sequence to try to identify what application this is, and (b), given a known application operating on secret data, an attacker can attempt to use reuse distances or level access sequence to infer some properties of the secret input to the application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Experimental Setup</head><p>We executed these applications with a large number of (approximately 50-200) different inputs and collected traces of (a) reuse distances as described in Algorithm 2, or (b) tree level access data as described in Section 4.2. Data was divided into training and test sets in a 3:1 ratio. To remove any bias in the classifier due to the specific choice of training and test datasets, the accuracy evaluation is repeated 10 times with the random splits of the data into training and test datasets. The reuse distance trace is used as the input feature to a CNN (Convolutional Neural Network) Sequence Classifier. The classifier was implemented in Python 3 using the sklearn <ref type="bibr">[4]</ref> and keras <ref type="bibr" target="#b1">[2]</ref> frameworks and is only a few hundred lines of code. The traces are collected by observing reuse distances for the first F OPAM accesses and then feeding this sequence to the classifier. We experiment with three values of F: 5k, 50k and 100k.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Secret Application Identification With Reuse Distances</head><p>We evaluated the accuracy of the classifier in identifying applications given only a trace of reuse distances obtained when executing one of the applications the CNN has been trained on for a new input that the classifier has never seen before. <ref type="figure" target="#fig_7">Figure 6</ref> shows the classification accuracy for each of the seven applications while observing the first 5k, 50k and 100k page-faults. Average classification accuracy for these three values is 85%, 94% and 96% respectively. Average classification accuracy usually increases with trace length -this is expected because with more page-faults, we have more information about reuse distances, and hence access patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Secret Data Identification using Reuse Distances</head><p>To see how effective the reuse distance attack is in identifying secret data within a known application, we ran picosat on two sets of formulas from benchmarks in the main and random tracks of the SAT Competition 2017 <ref type="bibr" target="#b21">[23]</ref>. Using similar experiments as in the previous subsection, we evaluated how effective the classifier is in predicting the source of the benchmark for the reuse distances obtained from a new formula given to picosat. This could be predicted with ≥ 84% accuracy. SAT research has shown that random instances produce different behavior in SAT solvers than instances generated from "real-world" problems <ref type="bibr" target="#b13">[15]</ref>. This difference in behavior leaks through reuse distances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.4">Secret Application Identification Using Levels</head><p>We evaluated the accuracy of the classifier in identifying applications given only a trace of levels. We train a CNN sequence classifier on the traces obtained during application execution. <ref type="figure" target="#fig_8">Figure 7</ref> shows the classification accuracy for each of the six applications on previously unseen traces for traces of first 5k, 50k and 100k page-faults. Average classification accuracy for these three values is 19.82%, 62.45% and 85% respectively. Classification accuracy generally increases with increase in trace length. For 5k traces, the classification accuracy is just 19.82%, almost similar to what one could get with random guessing. For most applications the memory required is greater than the memory available within the enclave, during the initialization, the applications allocate pages and the pages that could not fit in the enclave memory are evicted to the OPAM tree. As a result most of the accesses in the beginning are writes to the lower levels of the tree (as the tree is initially empty), irrespective of the application. Thus, all the applications show similar access patterns (when only level of access is considered) for first few page-faults. As a result the classifier performs poorly for traces of length 5k. However, as the trace lengths increase the access pattern starts diverging and the classifier shows improved classification accuracy. However, <ref type="figure" target="#fig_7">Figure 6</ref> and 7 shows that some applications (like lbm) experience slightly reduced identification accuracy for increasing trace lengths. This is because some applications have an intermediate phase of execution with similar access patterns (e.g. initializing a large array); this occasionally confuses the classifier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.5">Setup For Covert Channel Using Reuse Distances</head><p>We generated random binary messages of various lengths(n), used k-ary encoding and transmitted from within the enclave to the host OS as described in Section 4. <ref type="figure" target="#fig_9">Figure 8</ref> shows results for five different values of k:2, 4, 8, 16 and 32. The corresponding values of n are: 256, 512, 768, 1024, 1280 respectively. In each case, we calculate the wall clock time and the number of bits leaked. A comparison is done between the leaked message and the original message to ensure accuracy. <ref type="figure" target="#fig_9">Figure 8</ref> shows how the bandwidth changes with the arity of the message. We see a peak bandwidth with arity 4. As we increase k, more data (bits) is transmitted with each page fault, but the number of page-faults required to setup the algorithm also increases. Our experiments show that for our setup, choosing k = 4 gives highest bandwidth. As we increase k, the overheads associated with increased number of initial pagefaults/evictions ( given by P × (2 × k − 1) and 12 in section 4.2) dominate and we see a steady decline in transmission bandwidth. The total number of bits transmitted in the entire process is independant of the encoding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.6">Reuse Distance Covert Channel Analysis</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>Page-fault based attacks on enclaves were introduced by the seminal work of Xu et al. <ref type="bibr" target="#b47">[49]</ref>. Shinde et al. <ref type="bibr" target="#b40">[42]</ref> also used the page-fault side channel to attack OpenSSL. Mitigations to this include T-SGX <ref type="bibr" target="#b39">[41]</ref> and Apparition <ref type="bibr" target="#b14">[16]</ref>. T-SGX uses transactional memory primitives to determine whether an attack is underway by counting the number of page-faults that occur within a transaction. T-SGX was defeated by Van Bulck et al. <ref type="bibr" target="#b46">[48]</ref> who observed accesses by monitoring the accessed/dirty bits of the page table directly, as opposed to marking the page not present and then waiting for a fault to occur. Sanctum <ref type="bibr" target="#b12">[14]</ref>, Keystone <ref type="bibr" target="#b27">[29,</ref><ref type="bibr" target="#b28">30]</ref> and InvisiPage <ref type="bibr" target="#b3">[5]</ref> have attempted to address the page-fault side channel by keeping enclave page tables private.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>This paper introduced a new side channel attack called the reuse distance attack on demand paging for enclave platforms. Our attack is able to infer confidential information about an enclave's execution by examining its page-faults and is applicable to the state-of-the-art approach to secure paging in enclaves: InvisiPage. Further, we showed that fixing InvisiPage/OPAM is not as simple as just re-encrypting all path accesses. InvisiPage explicitly leaks the level of the tree from which an access is made, and as we showed with the level tracking attack, this leak alone is sufficient to defeat InvisiPage. Although we do not show results due to a lack of space, our experiments with Path ORAM showed that although a vanilla Path ORAM is secure, it also about an order of magnitude slower than InvisiPage. All of the above implies that performant and secure demand paging in enclaves remains an open problem.  We remove all duplicate sequences and get the following 4 sequences: <ref type="bibr">(156,</ref><ref type="bibr">61,</ref><ref type="bibr">201)</ref>, <ref type="bibr">(452,</ref><ref type="bibr">156,</ref><ref type="bibr">161)</ref>, <ref type="bibr" target="#b8">(10,</ref><ref type="bibr">156,</ref><ref type="bibr">452)</ref> and <ref type="bibr">(201,</ref><ref type="bibr">132,</ref><ref type="bibr">156)</ref>. These four sequences correspond to different paths from the root to each of the leaves. Since the root node lies in all the paths, the o-vpn accessed in all the sequences must correspond to the root. This means that o-vpn 156 is the root. Similarly, the o-vpns accessed in only one path must correspond to the leaves. So 61, 132, 161, and 10 must be the leaves. Using a similar analysis, o-vpns corresponding to the other nodes can be found out. Once the attacker finds out the mapping, it can be used to find out the level of the tree nodes that are accessed.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>(</head><label></label><figDesc>1) seal (2) attest and receive inp over n/w (3) move encrypted input to enclave (4) decrypt (includes authentication) (5) compute (6) produce encrypted output (7) send output over n/w; destroy enclave</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Overview of Enclave Execution. Red and white boxes show memory accessible to the untrusted OS. Blue boxes show trusted and sealed memory; this memory is only accessible to the enclave.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Secure demand paging using ORAMs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Example Path ORAM access. The accessed path is shown in red thick arrows. Nodes labeled with a hyphen (-) contain dummy pages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 shows</head><label>3</label><figDesc>Figure 3 shows an example of how Path ORAM's data structures are updated with an example access. An access is made to vpn=88 and this page is remapped to leaf 0. The ORAM fetches all buckets along the path to the leaf labeled 2. This brings in pages with vpn 88, 385 and 524 into the stash. Now all pages which can be written along this path in the stash are spilled from the stash back to the ORAM. This allows us to spill vpn 250 from the stash to the ORAM, vpn 385 is "pushed down" while 88 can only be stored at the root node because it has now been mapped to leaf 0. From the perspective of the untrusted OS, it only sees the enclave read in encrypted data stored in buckets labeled 6, 5 and 2 and write re-encrypted data back to the same buckets. The specific information about which pages were moved, which pages stayed in the same location, which new pages were spilled to the ORAM, etc. are all opaque to the OS due to randomized (re-)encryption.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Covert Channel Attack Model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Classification accuracy using reuse distances for OPAM for varying trace lengths.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Classification accuracy using levels for OPAM for varying trace lengths.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Bandwidth vs Message arity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Sample OPAM tree to illustrate level leakage. The numbers inside the nodes are the o-vpns assigned to it and the label denote the fraction of paths from the root to leaves containing the node.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 9 shows</head><label>9</label><figDesc>Figure 9 shows an OPAM tree. OPAM assigns static o-vpns to each node in the tree. We assume that the o-vpns assigned to each node are random and not correlated with the node's position in the tree. On every access, the OPAM runtime passes a list of o-vpns (corresponding to all nodes from root to a leaf) to the OS, one of which is read/written while the others are shuffled. Let's assume that the OPAM makes 5 access during the runtime and gives the following o-vpns to the OS: (156, 61, 201), (452, 156, 161), (10, 156, 452), (201, 132, 156) and (10, 156, 452). The list of o-vpns can be used to determine the mapping between o-vpns and the tree nodes. We remove all duplicate sequences and get the following 4 sequences: (156, 61, 201), (452, 156, 161), (10, 156, 452) and (201, 132, 156). These four sequences correspond to different paths from the root to each of the leaves. Since the root node lies in all the paths, the o-vpn accessed in all the sequences must correspond to the root. This means that o-vpn 156 is the root. Similarly, the o-vpns accessed in only one path must correspond to the leaves. So 61, 132, 161, and 10 must be the leaves. Using a similar analysis, o-vpns corresponding to the other nodes can be found out. Once the attacker finds out the mapping, it can be used to find out the level of the tree nodes that are accessed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><head>Table 1 : App/RT/OS/ORAM Interfaces for Demand Paging.</head><label>1</label><figDesc></figDesc><table>Interface 
Function 
Description 

App/RT 
handlePF 
Page-fault handling entrypoint. 

RT/ORAM accessORAM 
ORAM access (page eviction/fetch). 

ORAM/OS 
pageRead 
Read page from untrusted memory. 
pageWrite 
Write page to untrusted memory. 

RT/OS 
allocPages 
Get additional physical memory. 
OS/RT 
reclaimPages Reclaim allocated memory. 

</table></figure>

			<note place="foot">* This author is currently at Fortanix Inc. † This paper is dedicated to the loving memory of our advisor, late Dr. Pramod Subramanyan.</note>

			<note place="foot" n="1"> Note that by enclave, we are referring to both the enclave application as well the runtime libraries which are linked with it.</note>

			<note place="foot" n="2"> The ORAM &quot;fails&quot; when an ORAM access cannot be completed because client-side storage is full and the corresponding path on the server is also full.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Acknowledgements</head><p>We thank Dr. Daniel Gruss and the anonymous reviewers for their valuable comments. This work is partially supported by Science and Engineering Research Board, Department of Science and Technology with sanction letter number sb/s2/rjn-057/2018.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Level Leakage</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">HiFive Unleashed</title>
		<ptr target="https://www.sifive.com/boards/hifive-unleashed" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Keras: The Python Deep Learning Library</title>
		<ptr target="https://keras.io/" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<ptr target="https://github.com/keystone-enclave/keystone" />
		<title level="m">Keystone Enclave: QEMU + HiFive Unleashed</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Invisipage: Oblivious demand paging for secure enclaves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shaizeen</forename><surname>Aga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Satish</forename><surname>Narayanasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 46th International Symposium on Computer Architecture, ISCA &apos;19</title>
		<meeting>the 46th International Symposium on Computer Architecture, ISCA &apos;19<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2019" />
			<biblScope unit="page" from="372" to="384" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Innovative Technology for CPU Based Attestation and Sealing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ittai</forename><surname>Anati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shay</forename><surname>Gueron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vincent R</forename><surname>Simon P Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Scarlata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy</title>
		<meeting>the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy</meeting>
		<imprint>
			<publisher>HASP</publisher>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Lingeling, plingeling, picosat and precosat at SAT Race</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Armin</forename><surname>Biere</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In FMV Report Series Technical Report</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<date type="published" when="2010-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">MI6: secure enclaves in a speculative outof-order processor</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Bourgeat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilia</forename><surname>Lebedev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sizhuo</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arvind</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinivas</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 52nd Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="page" from="42" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Direct anonymous attestation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ernie</forename><surname>Brickell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Camenisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liqun</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th ACM Conference on Computer and Communications Security, CCS &apos;04</title>
		<meeting>the 11th ACM Conference on Computer and Communications Security, CCS &apos;04<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="132" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scalable architectural support for trusted software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Champagne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ruby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 IEEE 16th International Symposium on High Performance Computer Architecture (HPCA)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">SGXpectre attacks: Stealing Intel secrets from SGX enclaves via speculative execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoxing</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanchuan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuan</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yinqian</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhiqiang</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lai</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1802.09085</idno>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Ekiden: A platform for confidentiality-preserving, trustworthy, and performant smart contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jernej</forename><surname>Kos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Warren</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Hynes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noah</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ari</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE European Symposium on Security and Privacy (EuroS&amp;P)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019" />
			<biblScope unit="page" from="185" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Victor</forename><surname>Costan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinivas</forename><surname>Devadas</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2016/086" />
	</analytic>
	<monogr>
		<title level="j">Intel SGX Explained. Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Sanctum: Minimal hardware extensions for strong software isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilia</forename><surname>Victor Costan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinivas</forename><surname>Lebedev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th USENIX Conference on Security Symposium, SEC&apos;16</title>
		<meeting>the 25th USENIX Conference on Security Symposium, SEC&apos;16<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="857" to="874" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Experimental Results on the Application of Satisfiability Algorithms to Scheduling Problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">M</forename><surname>Crawford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">B</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twelfth National Conference on Artificial Intelligence</title>
		<meeting>the Twelfth National Conference on Artificial Intelligence<address><addrLine>Menlo Park, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1092" to="1097" />
		</imprint>
	</monogr>
	<note>AAAI&apos;94</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Shielding software from privileged side-channel attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaowan</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhuojia</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Criswell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alan</forename><forename type="middle">L</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sandhya</forename><surname>Dwarkadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Conference on Security Symposium, SEC&apos;18</title>
		<meeting>the 27th USENIX Conference on Security Symposium, SEC&apos;18<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="1441" to="1458" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Iso-X: A flexible architecture for hardware-managed isolated execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dmitry</forename><surname>Evtyushkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jesse</forename><surname>Elwell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meltem</forename><surname>Ozsoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dmitry</forename><surname>Ponomarev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nael</forename><surname>Abu Ghazaleh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Riley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 47th Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="190" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A new side-channel attack on directional branch predictor</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dmitry</forename><surname>Evtyushkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Riley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cse</forename><surname>Nael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dmitry</forename><surname>Abu-Ghazaleh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ponomarev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="693" to="707" />
			<date type="published" when="2018" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Suppressing the oblivious ram timing channel while making information leakage and program efficiency trade-offs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">W</forename><surname>Fletchery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 IEEE 20th International Symposium on High Performance Computer Architecture (HPCA)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="213" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Towards a theory of software protection and simulation by oblivious rams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the nineteenth annual ACM symposium on Theory of computing</title>
		<meeting>the nineteenth annual ACM symposium on Theory of computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1987" />
			<biblScope unit="page" from="182" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Software protection and simulation on oblivious RAMs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oded</forename><surname>Goldreich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rafail</forename><surname>Ostrovsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Journal of the ACM (JACM)</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1996" />
			<biblScope unit="volume">43</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Recommender: A C library for product recommendations/suggestions using Collaborative Filtering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ghassen</forename><surname>Hamrouni</surname></persName>
		</author>
		<ptr target="https://github.com/GHamrouni/Recommender" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marijn</forename><surname>Heule</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matti</forename><surname>Järvisalo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomas</forename><surname>Balyo</surname></persName>
		</author>
		<title level="m">SAT competition 2017. SAT</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Using Innovative Instructions to Create Trustworthy Software Solutions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Hoekstra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reshma</forename><surname>Lal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pradeep</forename><surname>Pappachan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vinay</forename><surname>Phegade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juan</forename><forename type="middle">Del</forename><surname>Cuvillo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy</title>
		<meeting>the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy</meeting>
		<imprint>
			<publisher>HASP</publisher>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Chiron: Privacy-preserving machine learning as a service</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tyler</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Congzheng</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reza</forename><surname>Shokri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vitaly</forename><surname>Shmatikov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmett</forename><surname>Witchel</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1803.05961</idno>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Ryoan: A distributed sandbox for untrusted computation on secret data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tyler</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhiting</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanzhong</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmett</forename><surname>Witchel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems (TOCS)</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">13</biblScope>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">S$a: A shared cache attack that works across cores and defies vm sandboxing -and its application to aes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Irazoqui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Sunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="591" to="604" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Spectre attacks: Exploiting speculative execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kocher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fogh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hamburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mangard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Prescher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yarom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2019" />
			<biblScope unit="page" from="1" to="19" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Sanctorum: A lightweight security monitor for secure enclaves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilia</forename><surname>Lebedev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyle</forename><surname>Hogan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jules</forename><surname>Drean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kohlbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dayeol</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019" />
			<biblScope unit="page" from="1142" to="1147" />
		</imprint>
	</monogr>
	<note>Krste Asanovi´cAsanovi´c, Dawn Song, and Srinivas Devadas</note>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Keystone: An Open Framework for Architecting TEEs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dayeol</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kohlbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shweta</forename><surname>Shinde</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krste</forename><surname>Asanovi´casanovi´c</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1907.10119</idno>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Inferring fine-grained control flow inside SGX enclaves with branch shadowing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sangho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming-Wei</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prasun</forename><surname>Gera</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hyesoon</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Peinado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th USENIX Conference on Security Symposium, SEC&apos;17</title>
		<meeting>the 26th USENIX Conference on Security Symposium, SEC&apos;17<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="557" to="574" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Last-level cache sidechannel attacks are practical</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="605" to="622" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Innovative Instructions and Software Model for Isolated Execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Mckeen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Alexandrovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Berenzon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><forename type="middle">V</forename><surname>Rozas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hisham</forename><surname>Shafi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vedvyas</forename><surname>Shanbhogue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Uday</forename><forename type="middle">R</forename><surname>Savagaonkar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy</title>
		<meeting>the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy</meeting>
		<imprint>
			<publisher>HASP</publisher>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Oblivious multi-party machine learning on trusted processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olga</forename><surname>Ohrimenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Felix</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cedric</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aastha</forename><surname>Mehta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Nowozin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kapil</forename><surname>Vaswani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Costa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th USENIX Conference on Security Symposium, SEC&apos;16</title>
		<meeting>the 25th USENIX Conference on Security Symposium, SEC&apos;16<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="619" to="636" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Enclavedb: A secure database using SGX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Priebe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kapil</forename><surname>Vaswani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Costa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="264" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">The Crazy Programmer</title>
		<ptr target="https://www.thecrazyprogrammer.com/2014/03/c-program-for-avl-tree-implementation.html" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Vc3: Trustworthy data analytics in the cloud using SGX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Felix</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cédric</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christos</forename><surname>Gkantsidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Peinado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gloria</forename><surname>Mainar-Ruiz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Russinovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="38" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Malware Guard Extension: Using SGX to Conceal Cache Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><surname>Weiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clémentine</forename><surname>Maurice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1702.08719</idno>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Avoiding information leakage in the memory controller with fixed service policies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ali</forename><surname>Shafiee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akhila</forename><surname>Gundu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manjunath</forename><surname>Shevgoor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>Balasubramonian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohit</forename><surname>Tiwari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<meeting>the 48th Annual IEEE/ACM International Symposium on Microarchitecture</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="89" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Oblivious ram with o ((logn) 3) worst-case cost</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T-H Hubert</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emil</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mingfei</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on The Theory and Application of Cryptology and Information Security</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="197" to="214" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">T-SGX: Eradicating Controlled-Channel Attacks Against Enclave Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming-Wei</forename><surname>Shih</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sangho</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Peinado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the 2017 Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Preventing page faults from telling your secrets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shweta</forename><surname>Shinde</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zheng</forename><surname>Leong Chua</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Viswesh</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prateek</forename><surname>Saxena</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th ACM on Asia Conference on Computer and Communications Security, ASIA CCS &apos;16</title>
		<meeting>the 11th ACM on Asia Conference on Computer and Communications Security, ASIA CCS &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="317" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A Design and Verification Methodology for Secure Isolated Regions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rohit</forename><surname>Sinha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akash</forename><surname>Lal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Nuno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sriram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rajamani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sanjit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kapil</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vaswani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2016</title>
		<meeting>the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2016<address><addrLine>Santa Barbara, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="665" to="681" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Path ORAM: An Extremely Simple Oblivious RAM Protocol</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emil</forename><surname>Stefanov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marten</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T.-H. Hubert</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Fletcher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ling</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiangyao</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinivas</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Journal of the ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<date type="published" when="2018" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A formal foundation for secure remote execution of enclaves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pramod</forename><surname>Subramanyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rohit</forename><surname>Sinha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilia</forename><surname>Lebedev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinivas</forename><surname>Devadas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjit</forename><forename type="middle">A</forename><surname>Seshia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;17</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;17<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="2435" to="2450" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">AEGIS: architecture for tamper-evident and tamperresistant processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G Edward</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dwaine</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Blaise</forename><surname>Gassend</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marten</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinivas</forename><surname>Devadas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th annual international conference on Supercomputing</title>
		<meeting>the 17th annual international conference on Supercomputing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="160" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Foreshadow: Extracting the keys to the intel SGX kingdom with transient out-of-order execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marina</forename><surname>Minkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ofir</forename><surname>Weisse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Baris</forename><surname>Kasikci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><forename type="middle">F</forename><surname>Wenisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raoul</forename><surname>Strackx</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th USENIX Conference on Security Symposium, SEC&apos;18</title>
		<meeting>the 27th USENIX Conference on Security Symposium, SEC&apos;18<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="991" to="1008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Telling your secrets without page faults: Stealthy page table-based attacks on enclaved execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jo</forename><surname>Van Bulck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nico</forename><surname>Weichbrodt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rüdiger</forename><surname>Kapitza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Piessens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raoul</forename><surname>Strackx</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th USENIX Conference on Security Symposium, SEC&apos;17</title>
		<meeting>the 26th USENIX Conference on Security Symposium, SEC&apos;17<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1041" to="1056" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Controlled-channel attacks: Deterministic side channels for untrusted operating systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanzhong</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weidong</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Peinado</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="640" to="656" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Flush+reload: A high resolution, low noise, l3 cache side-channel attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katrina</forename><surname>Falkner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd USENIX Conference on Security Symposium, SEC&apos;14</title>
		<meeting>the 23rd USENIX Conference on Security Symposium, SEC&apos;14<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="719" to="732" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Opaque: An oblivious and encrypted distributed analytics platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenting</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ankur</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jethro</forename><forename type="middle">G</forename><surname>Beekman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raluca</forename><forename type="middle">Ada</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">E</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ion</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th USENIX Conference on Networked Systems Design and Implementation, NSDI&apos;17</title>
		<meeting>the 14th USENIX Conference on Networked Systems Design and Implementation, NSDI&apos;17<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="283" to="298" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
