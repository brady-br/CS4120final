<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:28+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">NEMESYS: Network Message Syntax Reverse Engineering by Analysis of the Intrinsic Structure of Individual Messages</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephan</forename><surname>Kleber</surname></persName>
							<email>stephan.kleber@uni-ulm.de</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Distributed Systems</orgName>
								<orgName type="institution">Ulm University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henning</forename><surname>Kopp</surname></persName>
							<email>henning.kopp@uni-ulm.de</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Distributed Systems</orgName>
								<orgName type="institution">Ulm University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Kargl</surname></persName>
							<email>frank.kargl@uni-ulm.de</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Distributed Systems</orgName>
								<orgName type="institution">Ulm University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">NEMESYS: Network Message Syntax Reverse Engineering by Analysis of the Intrinsic Structure of Individual Messages</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Protocol reverse engineering based on traffic traces allows to analyze observable network messages. Thereby, message formats of unknown protocols can be inferred. We present a novel method to infer structure from network messages of binary protocols. The method derives field boundaries from the distribution of value changes throughout individual messages. None of many previous approaches exploits features of structure which are contained within each single message. Our method exploits this intrinsic structure instead of comparing multiple messages with each other. We implement our approach in the tool NEMESYS: NEtwork Message SYntax analysiS. Additionally, we introduce the Format Match Score: the first quantitative measure of the quality of a message format inference. We apply the Format Match Score to NEMESYS and a previous approach and compare the results to mutually validate our new format inference method and the measure of its quality.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A network protocol has the purpose to enable communication between nodes. Communicating nodes are entities implementing a specific shared protocol specification. In this context, a specification allows for the interpretation of transmitted data as information of defined meaning by the receiver. An analyst being confronted with communication which uses an unknown specification will need to reverse engineer its specification by monitoring network traffic or the communicating entities.</p><p>Traffic analysis is one method of protocol reverse engineering to infer the meaning of the communication <ref type="bibr" target="#b4">[5]</ref>. It resorts solely to the analysis of traffic traces, which are observable on the link between the communicating entities. Although traffic analysis can only gain information from what can be observed on the communication link, it is non-invasive and does not require control over any entity; therefore, static traffic analysis is regularly applied. This method of network analysis has been used to gain comprehension of hitherto unknown network protocols for security-relevant tasks. Use-case examples for static traffic reverse engineering are the analysis of botnets <ref type="bibr" target="#b12">[13]</ref>, the setup of honeypots <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14]</ref>, vulnerability testing by fuzzing <ref type="bibr" target="#b11">[12]</ref>, and the automated modeling of networks <ref type="bibr" target="#b20">[21]</ref>.</p><p>Current methods for traffic analysis are mainly based on algorithms originating from natural language processing and bio-informatics. Although these fields solve the related problem of inferring structure from sequences of values, in their context the challenge is reduced by additional knowledge about their data. Natural language processing determines words from delimiters, separating atomic parts of the vocabulary, and then identifies keywords by their frequency of occurrence. In bioinformatics it is often known which sequences of aminoacids are relevant in DNA or protein-sequences, therefore, aligning multiple sequences on their sub-sequences is a robust method of identifying similarity between the sequences.</p><p>Network protocols do not necessarily provide the required properties to apply either of these methods efficiently: A lot of protocols do not use keywords that would be discernible by natural language processing; in bio-informatics only few different sequences need to be aligned at a time. In contrast, inferring message formats from network traffic traces requires a large number of messages of one protocol to observe the variability of values. However, large corpora of message traces critically impact the performance, due to the exponential complexity <ref type="bibr" target="#b17">[18]</ref> of multiple sequence alignment. Therefore, neither natural language processing nor bioinformatics can provide for sufficient inference of the structure of binary data in a network protocol message.</p><p>Subsequent analysis steps of protocol reverse engineering, like message type identification, semantic deduction, or behavior analysis to derive the state model of the protocol, are highly dependent on the format inference quality. To cluster message types or align field sequences more precisely, the main goal of message format inference is to reliably and automatically segment each message on byte-positions that constitute field boundaries.</p><p>Contributions: Our paper contains two major contributions: Foremost, we propose a new method to infer structure from network messages. Additionally, we introduce the first quantitative measure of the quality of a message format inference.</p><p>To infer structure from network messages, we exploit typical patterns of value changes in network messages as heuristic for field boundaries. This yields a message segmentation derived from the distribution of value characteristics throughout each individual message. The basic idea of this method is to exploit the intrinsic structure of each single message for the analysis, instead of comparing multiple messages with each other. This approach obviated the need for pairwise comparisons of messages as the initial feature extraction step of protocol reverse engineering. We implement our approach in the tool NEMESYS: NETWORK MESSAGE SYNTAX ANALYSIS.</p><p>To evaluate NEMESYS and to compare multiple inference results, we introduce the measure Format Match Score (FMS), which quantifies the quality of the format inference for a specific message. We apply this measure to our results and compare them to the sequencealignment field inference performed by the tool Netzob 1 .</p><p>This article is structured as follows: In the next section we discuss related work and revisit the relevant common terminology for the discussion about network messages. In Section 3 we present the details of our approach. In Section 4 we describe the design of its implementation NEMESYS. We define the Format Match Score, our quality measure for network message syntax inference, in Section 5. Section 6 contains the results of our evaluation of NEMESYS by applying FMS. Finally, we outline our ideas for future work and conclude the paper in Sections 7 and 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Static traffic analysis is a specific kind of protocol reverse engineering, where network traffic between two genuine entities is monitored purely passively. First solutions have been proposed by Beddoe <ref type="bibr" target="#b0">[1]</ref> and Rauch <ref type="bibr" target="#b15">[16]</ref>. The basic application of sequence alignment to network protocols originates from Beddoe. Based on his work, the most versatile available tool implementing static traffic analysis is Netzob <ref type="bibr" target="#b3">[4]</ref>. We utilize Netzob's functionality to leverage our approach. Since Beddoe's paper, algorithms from natural language processing and bio-informatics have been applied to network protocols.</p><p>Methods based on natural language processing work well on protocols which use ASCII-encoded keywords to structure their messages. <ref type="figure">Figure 1</ref> shows part of a textual protocol with separator chars clearly delimiting keyword and data fields. Binary protocols, packing data more densely and not separating fields by delimiters or labeling them by explicit keywords, do not exhibit these characteristics, which, however, are necessary for natural language processing. Therefore, these methods inherently are not applicable to binary protocols.</p><p>As for bio-informatics algorithms, to derive a potential structure from an alignment of multiple messages, it requires that the same value is transmitted in the same relative position of a sequence of multiple values within each message. However, it cannot be unconditionally expected to find the same value in the byte sequence of multiple independent messages in binary protocols. On the other hand, long variable message parts bias the alignment by spurious relationships of values across messages and therefore lead to false positive identification of field boundaries.</p><p>ScriptGen <ref type="bibr" target="#b13">[14]</ref>, Discoverer <ref type="bibr" target="#b7">[8]</ref>, and Netzob use sequence alignment to infer message formats. Both, ScriptGen and Discoverer differ from Netzob in that they align subsequences of messages (tokens) instead of single bytes. They propose effective methods to generate such tokens from textual protocols. In addition, ScriptGen proposes to derive tokens from frequency, variance, and other byte characteristics throughout all messages of a trace. Although ScriptGen and Discoverer envision their methods to be universally applicable, they leave it to future work to solve the details of inferring binary protocols.</p><p>ProDecoder <ref type="bibr" target="#b18">[19]</ref> and PRISMA <ref type="bibr" target="#b12">[13]</ref> use statistical methods known from natural language processing. Both tools use these methods to find tokens by identifying sequences that appear together frequently and coherently. Due to the missing keywords and separators in binary protocols, natural language processing produces very limited results and is inefficient for large traces.</p><p>FieldHunter <ref type="bibr" target="#b2">[3]</ref> is a recent promising approach combining concepts from Netzob, Discoverer, ScriptGen, and other related methods. It provides advanced solu-tions for a number of challenges for format inference, like characterization of field types. However, FieldHunter does not exploit features contained inside one single message. Thus, like previous methods, it misses a lot of details of the structure of messages.</p><p>Despite this wide variety of methods and features which have been proposed for traffic analysis, to the best of our knowledge, a feature extraction from the intrinsic structure of messages has never been proposed in this context. Moreover, we are not aware of any kind of measure for the correctness and precision of the format inference of network messages. Therefore, we propose the first such measure in this paper.</p><p>The surveys by Duchêne et al. <ref type="bibr" target="#b8">[9]</ref> and Narayan et al. <ref type="bibr" target="#b14">[15]</ref> provide an overview of protocol reverse engineering beyond the methods directly related to our work, in particular such that are based on software reverse engineering. Software reverse engineering for the analysis of an executable that implements a network protocol has been proposed and is well understood for scenarios where this approach is applicable <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b19">20]</ref>. In contrast to inferring the parsing logic of an executable program, traffic analysis remains possible in cases where the executable program binary is not accessible for reverse engineering. We do not further discuss these methods, since they utilize fundamentally different concepts to perform their task.</p><p>We adopt the terminology for protocol elements of Narayan et al. <ref type="bibr" target="#b14">[15]</ref>: For the message type to be discernible and for the information to be interpretable at the receiver, each message needs a defined format following a strict syntax. This syntax defines fields, and the specification associates them with semantic. Each field has a length and a value. The length can be fixed or variable. The value can be completely variable, like in a data field, or it can be static, like a message type identifier, or it can be ephemeral. Ephemeral values remain static during exactly one session, such as the Identification field in DNS, intended to match request and reply despite using the connectionless UDP transport.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Approach</head><p>To discern the syntax of a network message, we utilize the structure that is intrinsic to the message. Since each network protocol is designed to be efficiently parseable by its recipient, we can expect to find specific hints towards the structure in each message itself. For example, binary protocols typically use fields of the lengths of common data types, such as 32 bits for an integer. However, field contents do not uniformly fill the value domain of such a fixed numerical field.</p><p>For instance, numeric values are a common field data type in network messages. Counted numbers exhibit a specific variance distribution from its most to its least significant byte. This observation is similar or even correlated to Benford's Law <ref type="bibr" target="#b1">[2]</ref> which predicts the anomalous distribution of the digits of numbers found in the real-world. To illustrate, this is most obvious in the case of multiple zeros being the most significant bytes of a fixed size integer. For example, a 4 byte integer field containing the value 2069 would look like 00000815 in hexadecimals.</p><p>The observation of network messages shows a typical behavior throughout the sequence of values, which is indicating substructures of messages. Our approach is to segment a message according to features of its intrinsic structure. This way we determine field candidates. After investigating a number of different methods to characterize bit sequences <ref type="bibr" target="#b6">[7]</ref>, we discovered the similarity of consecutive message bytes to be a good feature to perceive the intrinsic structure of a message.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Similarity Revealing Structure</head><p>The main similarity feature we use is the delta of the congruence in bit values of consecutive bytes (BCD) of one message. We assume that the message does consist of multiple bytes, though our exposition is generalizable to work with nibbles or words instead. We define Bit Congruence as the bitwise similarity of bytes and utilize the bitwise similarity defined by Sokal and Michener <ref type="bibr" target="#b16">[17]</ref>. We apply the Bit Congruence per each two consecutive bytes of the message. </p><formula xml:id="formula_0">BC(b, b) = c agree (b, b) 8 .</formula><p>Iterating over all bytes m 0 , . . . , m n of a network message m, we can determine a delta between the Bit Congruences of consecutive byte pairs. It is calculated from the difference of the Bit Congruence in every pair of consecutive byte positions k. The delta of this similarity within a message of m bytes length then is the following vector.</p><formula xml:id="formula_1">∆BC = BC(m k , m k+1 ) − BC(m k−1 , m k ) 0&lt;k&lt;n</formula><p>Although bit values of longer sequences of numerical data tend to have a recognizable BC pattern in network messages, not all subsequences of bits obey this behavior individually. Thus, the BC is a noisy feature and consequently also ∆BC. Despite the noise, we need to reliably find positions in the message where the feature property changes noticeably across multiple bytes to discover the  <ref type="formula" target="#formula_2">82 00 01 00 00 00 00 00 00 03 77 77 77 03 69 66 63 03 63</ref>  24 04 06 ec 00 00 02 79 00 00 12 20 0a 64 00 c8 d2 3d 05 60 2b 12 6b 75 d2 3d 09 6c d7 c7 ac c4 d2 3d 09 6e 27 e0 24 0a d2 3d 09 6e 27 e4 40 ba 19 04 0a ec 00 00 02 7b 00 00 12 85 0a 64 00 c8 d2 3d 06 a2 53 5e d7 1e d2 3d 09 fa a4 67 33 15 d2 3d 09 fa a1 76 63 25 d2 3d 09 fa a1 7b 4b 10</p><p>Message:</p><p>(b) Features of one NTP message. overall tendency. Therefore, we smooth the ∆BC by a standard Gaussian filter g σ (∆BC) with parameter σ .</p><p>Even by simple observation in <ref type="figure" target="#fig_3">Figure 2</ref>, this smoothed Bit Congruence delta clearly shows a periodic behavior coinciding with fields as postulated.</p><p>Numbers have a characteristic distribution of Bit Congruence deltas across their binary representation in one field. In particular, at the transition from one field to another, big-endian numeric values commonly have low variability; from the beginning of the field, this rises into high variability towards the end of the field. For counting numbers, this is due to the order of the significance of the bytes. We acknowledge that there are several data types of fields used in binary protocols that do not change their variability in a way recognizable by our feature. Some examples are char sequences (byte positions 13 to 25 in <ref type="figure" target="#fig_3">Figure 2a</ref>), seemingly random session cookies, message authentication codes, and nonces. While consecutive random-looking values cannot be split into their components by any method without additional specification, char sequences may change their variability according to the letter frequency in natural language. This is difficult to detect with our method, which compares only small subsequences of the message. However, seemingly random values occur comparatively seldom throughout a message and are therefore clearly discernible by our feature from other parts of the message. Character strings on the other hand are easily identifiable by their value domain, as we will show in our implementation (Section 4).</p><p>For an expedient analysis during steps after the extraction of the ∆BC feature, a large number of messages is needed to have a diverse set of samples. Only then the different realizations of potentially multiple syntaxes which are specified in one protocol become observable. The reason we chose Sokal and Michener to provide the Bit Congruence feature for our approach is twofold. For one, it is simple to be calculated so that we can efficiently analyze the necessary large numbers of independent messages. On the other hand, it is a normalized bit similarity metric. The normalization by the length of the compared bit strings has one conceptual and one practical benefit: It makes the approach universally valid, independently of the applied basic unit size. For common protocols, these basic units are bytes, but nibbles or larger bit strings may be used alternatively. The practical benefit of normalizing is that it allows to apply optimized default Gaussian-filter implementations, based on the normalized Gaussian distribution. These implementations require the sequence for smoothing to be normalized to values between zero and one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Applying the Feature</head><p>We interpret the ∆BC feature to derive message segments that constitute field candidates for each analyzed message. Due to the explained typical feature-value distribution throughout one field, the segmentation is achieved by determining approximates for the inflection points at the rising edges of the discrete Gaussian-filtered Bit Congruence delta g σ (∆BC). By reducing the noise in the input data, the smoothing by the Gaussian filter shows the overall variability level for longer sequences of bytes in the message. It thereby prevents longer field candidates to be split up erroneously for a single deviating byte-value outlier. <ref type="figure" target="#fig_3">Figure 2</ref> shows plots of unsmoothed and Gaussian-filtered ∆BC of two example messages. The byte position next to an inflection point on the rising edge of the smoothed ∆BC is marked with an orange dot. The true field boundaries, we seek to infer, are marked by vertical dashed blue lines.</p><p>The number of discrete values to deduct inflection points from often are derived from only 2 to 4 bytes. Therefore, we do not use interpolated inflection points of g σ (∆BC) directly. The exact cut position for segments at the rising edge of Bit Congruence deltas is determined from the maximum delta of the unsmoothed ∆BC in scope of each rising edge. Therefore, we determine the scope of a rising edge from the interval of a pair of local extrema (e min , e max ). As cutting point, we use the most distinctive change in each interval (e n , e n+1 ) for each n where e n is a local minimum and e n+1 is a local maximum. This yields exact points of transitions from high to low variability throughout one message. To illustrate, our approximation of the inflection points is marked by blue triangles in <ref type="figure" target="#fig_3">Figure 2</ref>. Due to the noisy nature of the feature, the resulting message segments are not necessarily cut at the exact field boundaries and may slightly skitter compared to the protocol specification.</p><p>Our approach now provides segmentation of messages by approximating the inflection points of Gaussiansmoothed deltas of Bit Congruences (g σ (∆BC)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">NEMESYS Implementation</head><p>We implement our approach in the tool NEMESYS: NETWORK MESSAGE SYNTAX ANALYSIS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Architecture</head><p>NEMESYS is implemented in Python 3 as a proof-ofconcept and consists of the modules SpecimenLoader, MessageAnalyzer, and MessageSegment depicted in <ref type="figure" target="#fig_4">Figure 3</ref>.</p><p>The SpecimenLoader reads a PCAP file and prepares its representation for the analysis using methods of Netzob. MessageAnalyzer defines classes for each analysis method, as well as an AbstractBaseClass for all of them. Bit Congruence (BC), Bit Congruence delta (BCD), and Gaussian-filtered BCD (BCDG) are implemented as analyzer subclasses. The BCDG class also contains methods to approximate the inflection points and to cut the message into according MessageSegments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Segmentation</head><p>In NEMESYS, a MessageSegment is fully defined by the message it originates from, the byte offset, the length in bytes, and the kind of feature analysis performed on the message to gain the segmentation. This encapsulates a message together with an analysis method and allows to slice the message according to the extracted features. Features are one or more analysis values that are used as basis to detect a field boundary. Moreover, the architecture to calculate and interpret features enables to flexibly exchange the analysis method by writing a new analysisclass that can be instantiated in the message segments.</p><p>The sole parameter of NEMESYS is the radius of the smoothing by the Gaussian filter denoted as σ . σ is the standard deviation of the Gaussian distribution that is used as the kernel to convolute with the BCD value. To illustrate the influence σ has on the smoothing, regard another application of the Gaussian filter: image processing. In this context, Gaussian filtering blurs the image to reduce noise such as scratches and raster artifacts. It produces a weighted mean of each data point and its neighbors.</p><p>In our application to network messages, the optimal value for σ is dependent on the field lengths of the protocol. This parameter can be adjusted by the analyst to improve the message segmentation precision. However, for unknown protocols a reasonable assumption about the typical field length must be made. Our empirical tests have shown that for common protocols with field lengths of 2 to 8 bytes, a value of 0.9 yields best field matching results (see Appendix, <ref type="table">Table 4</ref> and <ref type="figure">Figure 10</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Refinements</head><p>It is possible to make computationally cheap refinements of the results. These are intended to take additional knowledge about typical protocol design into account. We implemented one kind of value-based refinement to demonstrate the procedure. In particular, we address the issue of character sequences, which do not exhibit the same structure as numerical fields. Such fields may very well be embedded within binary protocol messages, like DNS containing a domain name.</p><p>Typically, character sequences are split into segments too short. In some cases, segments before or after character sequences contain one or more character bytes. Therefore, NEMESYS merges consecutive segments which completely consist of printable-character values into one text field. We chose to define printable characters according to the ASCII encoding as either \t, \n, or \r, or having a value between ≥ 0x20 and ≤ 0x7e. Afterwards, NEMESYS checks whether segments adjacent to text segments need to be split and re-segmented to keep consecutive chars together. These operations have almost no effect on purely binary protocols but improve the inference of text fields within binary protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Format Match Score</head><p>We introduce the Format Match Score (FMS) as quantitative measure that provides a reference value for the quality of a format inference. To the best of our knowledge, this score is the first of its kind to adequately incorporate the relevant aspects of correctness of a message format inference. It is designed to (1) take into account the ratio of correctly recognized fields, (2) differentiate between shifted field boundaries and completely wrongly inferred fields, which result in too many or too few fields of one message, and (3) quantify the decreasing utility of the different aspects of deviation of the inference. Deviations and ratios are determined by applying the protocol specification to a specific inferred message. The FMS is intended as a benchmark for the message format inference quality to be applied with a known protocol as representative test specimen. It cannot serve as an oracle for the quality of the inference of a truly unknown protocol. Nevertheless, knowing the efficacy of a format inference algorithm by benchmarking it allows to deduce the expected result quality of the approach for an unknown protocol of similar kind.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Quality Aspects</head><p>The FMS is based on a number of quality aspects as introduced above. To formalize these, we first define the necessary properties of a message, its real format, and its inference.</p><p>For a single message, we define the properties: R R R: The set of real field boundaries and |R| their number. I I I: The set of inferred boundaries and |I| their number. r r r k k k with 0 0 0 &lt; &lt; &lt; k k k &lt; &lt; &lt; |R R R|: The byte index of the kth real field boundary; to ease notation, we always set r 0 = 0 at the start of the message and r |R| as the message length. i i i l l l with 0 0 0 &lt; &lt; &lt; l l l &lt; &lt; &lt; |I I I|: The byte index of the lth inferred field boundary.</p><p>We define a scope for each true field boundary r k within a single message. A scope begins at the center between the previous and the current boundary r k and ends right before the center between the current and the subsequent boundary as illustrated in <ref type="figure" target="#fig_5">Figure 4</ref>. The message start r 0 and end r |R| have no scopes assigned and are not considered inferable boundaries. Thus, an inferred boundary i l is within the scope of r k for any 0 &lt; k &lt; |R| if the following inequality holds:</p><formula xml:id="formula_2">r k−1 + r k − r k−1 2 ≤ i l &lt; r k + r k+1 − r k 2<label>(1)</label></formula><p>We define δ δ δ r r r as the distance of a real field boundary r k to the nearest inferred field boundary i l : δ r = min{|i − r|, where i satisfies Equation (1)} As usual, we define the minimum operator on an empty set to be min / 0 = −∞. Consequently, δ r is interpreted as:</p><p>δ r = −∞: no matching inferred boundary exists for the true boundary r δ r = 0: an exactly matching inferred boundary exists for the true boundary r −∞ &lt; δ r &lt; 0: the nearest inferred boundary for the true boundary r is δ r bytes left of r δ r &gt; 0: the nearest inferred boundary for the true boundary r is δ r bytes right of r.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Calculating the Format Match Score</head><p>Knowing R, I, and δ r , we can now calculate the FMS. We use Gaussian weights to assign a measure of quality exp − (δ r /γ) 2 to an inferred field with field distance δ r . The parameter γ decreases the steepness of the quality drop towards larger deviations from zero of the distance between inferred and real field boundaries. Depending on the use case, γ can be adjusted for benchmarks to represent the requirements of the use case in regard to the accuracy of the format inference. The specificity penalty incorporates the deviation of the inferred field count from the true amount of fields in the format. Any deviation from zero reduces the</p><formula xml:id="formula_3">δ r exp − δ r γ 2 Note 0 1 exact match ±1 0.779 ±2 0.368 ±3 0.105 ±4</formula><p>0.018 −∞ 0 no matching inferred field <ref type="table">Table 1</ref>: Rounded weights of inferred fields corresponding to real fields r at distance δ r for γ = 2.</p><p>FMS proportional to a Gaussian distribution. The nonlinearity of the penalty takes into account that the usefulness of the inference typically decreases slowly for only few additional or missing fields, but the inference becomes useless with increasing pace for larger skitter.</p><p>The match gain incorporates near field matches, which are weighted by the distance from their true field boundary positions, and exact field matches. It is normalized by the amount of true fields in the message format. The weight of an exact match is 1 and of a true field that lacks any counterpart in the inference it is 0. Each near match is weighted non-linearly by a Gaussian distribution dependent on the distance of the true from the inferred field. <ref type="table">Table 1</ref> gives some examples for values of near matches, assuming a factor of γ = 2.</p><p>The overall FMS assumes 1 for an exact match of the inferred and true format. It approaches 0 for increased deviation of inferred and true format.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>We evaluate the quality of our format inference approach by applying the FMS to the inference results of our method's implementation NEMESYS. For the evaluation, we implemented the Python-modules MessageComparator and ParsedMessage as add-on of NEMESYS. The two modules obtain the dissection of each message and compare these real field boundaries to the inferred ones by applying FMS. We illustrate this process in <ref type="figure" target="#fig_7">Figure 5</ref>.</p><p>As baseline information about the protocol specification, we utilize tshark 2 . For each message in the trace, we compare the inference results to the according protocol dissector provided by tshark. ParsedMessage hands each message to a tshark process and parses the JSON output of its dissectors. As specimens, we use the binary protocols DNS, NTP, and DHCP. We chose these protocols as representatives of different typical binary protocols. DHCP has varying amounts and lengths of fields. We chose NTP because it is a protocol of fixed field lengths, The traces we analyzed are publicly available <ref type="bibr" target="#b2">3</ref> ; we preprocessed each raw trace by removing duplicates of the payload and truncating them to traces of the sizes of 100, 1 000, and 10 000 messages.</p><p>To visualize the accuracy of the inference for a whole trace, we generated histograms of the amounts of inferred boundaries positioned around true boundaries of fields. <ref type="figure" target="#fig_10">Figure 6</ref> depicts this histogram for 10 000 messages of DNS and NTP each. (We placed the respective plot for DHCP in the Appendix, <ref type="figure">Figure 8</ref>.) In these plots, the vertical dashed blue lines denote true boundaries; the bars count in how many messages a boundary was inferred at that byte position. Since our format inference method is heuristic, inferred field boundaries are scattered around the true field boundaries. The narrower the bars of the plot are scattered around the true fields, the better the inference matches the true format. To determine the distance between each true field boundary and its nearest inferred counterparts, we needed to take the variable length fields of DNS and DHCP into account. Therefore, we aligned the true field boundaries and their nearest inferred counterparts across all messages for the graphical representation to the maximum length of each field in the messages' sequences.</p><p>To provide a quantitative evaluation, we applied our novel FMS. We chose the parameter of the FMS to be γ = 2 in our evaluation so that small deviations in the inference still are rewarded as shown in <ref type="table">Table 1</ref>. Thus, a distance of an inferred field by 1 still is rewarded by about 0.78 of an exact match, whereas for a distance of 4 byte positions only less than 0.02 remains. For comparison with our results and to validate the FMS, we used Netzob to infer the same messages as NEMESYS. <ref type="table" target="#tab_2">Ta- ble 2</ref> shows the inference results in FMS for the best matching message in the trace and the average inference quality over all messages in the trace. We repeated the analysis with traces of different sizes and recorded the runtime of each analysis.     Both, Netzob and NEMESYS require a parameter, which we needed to set for our test runs. To select these, we iterated the respective parameters during test runs of each tool. We then used the best NEMESYS σ s and Netzob similarity-thresholds for each protocol, according to the FMS. For Netzob the similarity thresholds used were 53 (DNS), 75 (DHCP), and 66 (NTP); for NEMESYS we used σ = 0.6 (DNS, DHCP) and 1.2 (NTP).</p><p>In the best case inferences, NEMESYS shows moderate (DNS) to significant (DHCP) better format matching than Netzob, while both approaches yield comparable results for NTP. In the average case, Netzob and NEMESYS yield a similar FMS, partly with Netzob leading (DNS, 100 NTP messages), partly with NEMESYS leading (more than 100 NTP messages). Overall, we conclude that the inference quality of Netzob and NEMESYS is similar.</p><p>What sets NEMESYS apart is that it does not need to do any comparison between multiple messages in the trace. Dependent on the length and number of messages, this results in a linear complexity of the analysis. On the other hand, global multiple sequence alignment -performed by Netzob and most other protocol reverse engineering tools -has exponential runtime. It guarantees to optimally align k sequences of the maximum length l at the complexity of O(l k ) <ref type="bibr" target="#b9">[10]</ref>. The analysis run of 10 000 messages could not be performed with Netzob due to the exponential increase in its runtime and memory consumption. The runtimes of the analyses in <ref type="table" target="#tab_2">Table 2</ref> show this advantage of our approach in scalability. This becomes even more distinct when considering the maximum lengths of the messages in our the analysis traces: NTP and the DNS trace we used contain small messages of 68 and 96 bytes at max. Our DHCP trace contains largest messages of 548 bytes. Neither of these lengths are unusual and should not be prohibitive for an automated message analysis. NEMESYS completes the segmentation of even the largest trace of longest messages in under one minute, while Netzob requires almost 40 minutes for only the tenth of this amount of messages, as can be seen regarding DHCP in <ref type="table" target="#tab_2">Table 2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Limitations</head><p>A general limitation of static traffic analysis is that it is prevented by encryption of the messages. This can only be overcome by obtaining a plain-text trace. One method to accomplish this is memory introspection during the runtime of a program before or after encryption <ref type="bibr" target="#b8">[9]</ref>. Therefore, this approach is not a method of static traffic analysis. Alternatively, a Man-in-the-Middle between two genuine entities can record the decrypted messages in transit <ref type="bibr" target="#b10">[11]</ref>. Both methods require control over either the entities' execution environment or over the network topology.</p><p>Due to the nature of our approach, being a heuristic method, there are some limitations regarding the result Worst (FMS 0.10): 2126 0100 0001 0000 0000 0000 055f6c646170045f74637011436f6e6669674d616e616765725369746506 5f (continued) 7369746573026463065f6d736463730575736166610264730261660365647500 0021 0001</p><p>Average (FMS 0.45): d95e 0100 0001 0000 0000 0000 0377777706676f6f676c6502617400 0001 0001 Best (FMS 0.71): 51c6 8182 0001 0000 0000 0000 0e666c75677375626d697373696f6e00 0001 0001</p><p>(a) Inferred DNS messages (worst, average, and best case)</p><p>Worst (FMS 0.07): d9 00 0a fa 00000000 00010400 00000000 0000000000000000 0000000000000000 0000000000000000 d2 (continued) 3d20986645a1ca 67040000 00000000000000000000000000000000</p><p>Average (FMS 0.45): 19 06 0a fa 00001475 00042070 ac110205 d23d36d31b81981b d23d36c386157837 d23d36c36b8ec0f8 d2 (continued) 3d3ac397d9e767 62040000 00000000000000000000000000000000</p><p>Best (FMS 0.67): 1c 05 0a fa 00000c5f 0000236f ac140102 d23d4a7dcbd37634 d23d4c431df9c62a d23d4c430bd37634 d2 (continued) 3d4c430bd37634 00000000 ae840d599377b365f479f156b0e84097     <ref type="figure" target="#fig_11">Figure 7</ref>. (Due to the message length, we placed an abbreviated depiction of DHCP messages in the Appendix in <ref type="figure">Figure 9</ref>.) Besides other quality aspects, <ref type="table" target="#tab_4">Table 3</ref> gives the number of over-and underspecified field boundaries in column S. The specificity S = −9 for the message of DNS with the worst inference result may be read as NEMESYS having inferred nine fields too much. <ref type="figure" target="#fig_11">Fig- ure 7a</ref> shows that this is due to the character sequence embedded in the message blue . Three fields have not been inferred due to unset values orange . They contain only zero-bytes with no indication of field boundaries in between. This sums up to the nine overspecified fields. The three near field matches are off-by-one errors due to the heuristic feature (green ). In the average case of DNS inferences, the character sequence leads to three fields too much. The same amount of fields is missing due to unset fields with zero-values . In the best case, two such fields are not inferred. The near field match (green ) is due to the heuristic.</p><p>Regarding NTP in <ref type="figure" target="#fig_11">Figure 7b</ref> also shows unset fields with zero-values causing a bias at the previous and following field. For all shown NTP messages, the heuristic causes an off-by-one error at several field starts (green ). Two positions in the average and best cases are misinterpreted as boundaries (red ). An example is the last field of the best NTP match. This is a message authentication code, and as such a pseudo-random value not a counting number, to which neither Benford' Law nor any similar principle applies. Moreover, our method cannot infer single byte fields, like the four values at the beginning of the NTP messages beige .</p><p>While our evaluation shows a good approximation for areas of potential fields, pinpointing of the exact field boundaries is challenging with this feature. Despite some mismatches due to the heuristic approach, our evaluation shows that the inflection points in our feature of Bit Congruence deltas yields reasonably precise results. Furthermore, by abstracting from concrete binary values to a heuristic feature, we are able to discover structural patterns which remain hidden when only exact byte value matches are considered. Bearing in mind that we only analyze one message at a time, NEMESYS is able to infer message formats with competitive precision and excellent performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Future Work</head><p>NEMESYS generates message segments from the change in Bit Congruence between bytes. Besides this similarity metric, a large number of other metrics exist <ref type="bibr" target="#b6">[7]</ref> that could be evaluated to extract an alternative binary similarity feature that reveals message structure. For example, a similarity which weights agreement on 1-bits over agreement on 0-bits may be more suited to discriminate flag-like fields.</p><p>NEMESYS' message segments are heuristic and therefore fuzzy in regard to the inferred field boundary. To pinpoint the exact boundaries, specific characteristics of the Bit Congruence or value based refinements in the vicinity of field candidates may be used. Learning characteristics of these features from fields in known protocols could also help to recognize the data type and decrease the skitter for non-numeric field types.</p><p>For an overall quality value, we used the average FMS over the messages of a trace in the evaluation. Adding single messages that contain more inferable structure increases the overall quality score of the larger trace. Inversely, eliminating the worst-inferred messages effectively increases the quality. This is easy for a known protocol, for which a FMS can be calculated; for an unknown protocol it is impossible. Thus, it remains to be solved how to identify messages that do not exhibit enough discernible structure for syntax analysis.</p><p>As the next step in the protocol reverse engineering process, the analyzed messages need to be classified into clusters of equal format. Thus, the resulting field candidates can be combined into field "templates" according to their similarity in terms of the Bit Congruence or other features. As described above, these features can be used to hypothesize about the data type of the field. Combining the templates with their hypothetical field type renders it possible to utilize a method like ScriptGen's region analysis <ref type="bibr" target="#b13">[14]</ref> or Discoverer's type-based alignment <ref type="bibr" target="#b7">[8]</ref> Such kind of type-based alignment and clustering can use this information to more efficiently categorize messages without having to align byte-by-byte. To evaluate methods using data type identification, the FMS could be enhanced to assess the inference of field data types.</p><p>For use cases like anomaly detection, it may not be required to exactly know the format but a characterization of messages to recognize their protocol without knowing the exact specification. Our method could be adapted not to segment messages but to characterize them in whole by Bit Congruence features. Such a characterization could be applied as fingerprint of allowed protocols without requiring deep packet inspection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>In this paper, we present a novel method of format inference for unknown network protocol messages. Moreover, we introduce a measure to quantitatively compare the quality of format inferences.</p><p>NEMESYS segments messages without relying on identical byte values to determine similarity. The novelty of our approach is that we do not compare multiple messages to find similarities in byte values, but that we analyze a single message at a time to discover its intrinsic structure. With this method we are able to efficiently identify the message syntax of binary protocols. The resulting message segments need further interpretation to determine the exact field boundaries reliably. Nevertheless, we achieve results comparable to sequence alignment by analyzing only isolated messages. Compared to the exponential complexity of any pairwise comparison, we reveal structure more efficiently, i. e., scaling with the message amount and the message sizes in linear time. Moreover, by abstracting from concrete binary values to a heuristic feature, we are able to discover structural patterns, which remain hidden when only exact value matches are considered.</p><p>Not having enough information about a protocol specification makes guessing the quality of a reverse engineering result a vague task. Evaluating a format inference method, like Netzob or NEMESYS, using known protocols allows a quantitative comparison. The Format Match Score we introduce is the first of its kind to measure the quality assessment of a method. It takes into account the specific measurable aspects of the divergence between inferred and true message formats. Our evaluation applies the Format Match Score to NEMESYS, mutually validating both contributions of this paper.</p><p>The specific benefit of the approach of NEMESYS is that it works without having to analyze arbitrary parts of all messages in a set of specimens. With further refinement, it provides the means to (1) pinpoint the exact field boundaries from the heuristic candidates it yields, (2) identify field types through the feature characteristics, and (3) identify message types from the feature profile.  <ref type="table">Table 4</ref>: Comparison of the inference quality depending on parameter σ : Format inference results for worst, average, and best quality of 10 000 messages of each protocol inferred with default σ = 0.9 and the individual optimum for each protocol trace (see Section 6). The differences of these quality scores are visualized in <ref type="figure">Figure 10</ref>. Figure 10: Comparison of the inference quality depending on parameter σ : the difference ∆ between an inference with the proposed default of σ d = 0.9 for unknown protocols and an inference with the individually optimal σ o for each evaluated protocol trace as presented in Section 6; worst, average, and best refers to the FMS results as listed in <ref type="figure">Figure 10</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Notes</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>For two bytes b and b their bits are denoted as b i and b i , with 0 ≤ i &lt; 8. The number of bits that have the same value is called c agree (b, b) = |{0 ≤ i &lt; 8 : b i = b i }|. The similarity metric by Sokal and Michener applied to b and b yields what we call the Bit Congruence</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Gaussian filtered Bit Congruence deltas as message feature: The red line is showing the smoothed ∆BC; the fine black line ∆BC without smoothing; vertical blue dashed lines are true field boundaries; the byte values of the displayed message are shown along the x-axis in hexadecimals.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Overview of the NEMESYS analysis process</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Scope of each true field boundary.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Overview of the evaluation process</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>(a) Inferred boundary positions for 10 000 DNS messages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Inferred boundary positions for 10 000 NTP messages.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Histograms of inferred field boundaries around true field boundaries. The vertical dashed blue lines denote true boundaries; the bars count in how many messages a boundary was inferred at that byte position.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>(Figure 7 :</head><label>7</label><figDesc>Figure 7: Example segmentations of messages from the specimen traces annotated with the comparison to the dissector: True fields are separated by SPACEs; inferred fields are in framed boxes. Values are in hexadecimal notation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>FMS</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Format inference results for best and average 
quality of all messages measured in FMS. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Quality aspects examples (rounded) from the 
evaluation analysis runs of NEMESYS with 10 000 mes-
sages. M is the number of exact matches, N of near 
matches. For the sample messages see Figures 7 and 9. 

precision. To illustrate what kind of errors account for a 
suboptimal inference by NEMESYS, we discuss exam-
ple message segmentations annotated with true fields for 
comparison. For each protocol, we present the best, aver-
age, and worst case FMS of an inferred message format 
in </table></figure>

			<note place="foot" n="1"> http://netzob.org/ 2 https://www.wireshark.org/docs/wsug_html_chunked/ AppToolstshark.html 3 NTP and DHCP filtered from http://download.netresec.com/ pcap/smia-2011/; DNS filtered from http://ictf.cs.ucsb. edu/ictfdata/2010/dumps/ictf2010pcap.tar.gz 4 We considered Netzob&apos;s parsing of the already aligned 1 000 DHCP messages as failed after 100 hours of runtime. All URLs last accessed on May, 20 2018.</note>
		</body>
		<back>
			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Network Protocol Analysis using Bioinformatics Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marshall</forename><forename type="middle">A</forename><surname>Beddoe</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<publisher>McAfee Inc</publisher>
		</imprint>
	</monogr>
<note type="report_type">Tech. rep</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The Law of Anomalous Numbers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Benford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the American Philosophical Society</title>
		<meeting>the American Philosophical Society</meeting>
		<imprint>
			<date type="published" when="1938" />
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page" from="551" to="572" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Towards Automatic Protocol Field Inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ignacio</forename><surname>Bermudez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alok</forename><surname>Tongaonkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marios</forename><surname>Iliofotou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Mellia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maurizio</forename><forename type="middle">M</forename><surname>Munafò</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Communications</title>
		<imprint>
			<biblScope unit="volume">84</biblScope>
			<date type="published" when="2016-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Towards Automated Protocol Reverse Engineering Using Semantic Information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Georges</forename><surname>Bossert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frédéric</forename><surname>Guihéry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guillaume</forename><surname>Hiet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM Symposium on Information, Computer and Communications Security. ASIA CCS &apos;14</title>
		<meeting>the 9th ACM Symposium on Information, Computer and Communications Security. ASIA CCS &apos;14</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">CAPEC -CAPEC-192: Protocol Reverse Engineering (Version 2.6)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Capec Content Team</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">MACE: Model-inference-Assisted Concolic Exploration for Protocol and Vulnerability Discovery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Domagoj</forename><surname>Chia Yuan Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pongsin</forename><surname>Babi´cbabi´c</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><forename type="middle">Zhijie</forename><surname>Poosankam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><forename type="middle">Xuejun</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th USENIX Security Symposium</title>
		<meeting>the 20th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Survey of Binary Similarity and Distance Measures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seung-Seok</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sung-Hyuk</forename><surname>Cha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><forename type="middle">C</forename><surname>Tappert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Journal of Systemics</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Discoverer: Automatic Protocol Reverse Engineering from Network Traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weidong</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jayanthkumar</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Helen</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 16th USENIX Security Symposium</title>
		<meeting>16th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">State of the Art of Network Protocol Reverse Engineering Tools</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Duchêne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Colas</forename><forename type="middle">Le</forename><surname>Guernic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Alata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vincent</forename><surname>Nicomette</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohamed</forename><surname>Kaâniche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Journal of Computer Virology and Hacking Techniques</title>
		<imprint>
			<date type="published" when="2017-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">MUSCLE: Multiple Sequence Alignment with High Accuracy and High Throughput</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">C</forename><surname>Edgar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Research</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<date type="published" when="2004-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Breaking Fitness Records without Moving: Reverse Engineering and Spoofing Fitbit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hossein</forename><surname>Fereidooni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiska</forename><surname>Classen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Spink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Patras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Miettinen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Hollick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mauro</forename><surname>Conti</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1706.09165</idno>
		<imprint>
			<date type="published" when="2017-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">PULSAR: Stateful Black-Box Fuzzing of Proprietary Network Protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugo</forename><surname>Gascon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Wressnegger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabian</forename><surname>Yamaguchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Arp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konrad</forename><surname>Rieck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th International Conference of Security and Privacy in Communication Networks</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Learning Stateful Models for Network Honeypots</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tammo</forename><surname>Krueger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugo</forename><surname>Gascon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicole</forename><surname>Krämer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konrad</forename><surname>Rieck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th ACM Workshop on Security and Artificial Intelligence</title>
		<meeting>the 5th ACM Workshop on Security and Artificial Intelligence</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">ScriptGen: An Automated Script Generation Tool for Honeyd</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Corrado</forename><surname>Leita</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ken</forename><surname>Mermoud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Dacier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Annual Computer Security Applications Conference</title>
		<meeting>the 21st Annual Computer Security Applications Conference</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Narayan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sandeep</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">Charles</forename><surname>Shukla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Clancy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">A Survey of Automatic Protocol Reverse Engineering Tools&quot;. In: ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2015-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Protocol Debug (PDB)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><surname>Rauch</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<pubPlace>Blackhat. Las Vegas</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Statistical Method for Evaluating Systematic Relationships</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><forename type="middle">D</forename><surname>Sokal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Michener</surname></persName>
		</author>
		<idno>XXXVIII-2.22</idno>
	</analytic>
	<monogr>
		<title level="m">University of Kansas Scientific Bulletin</title>
		<imprint>
			<date type="published" when="1958-03" />
			<biblScope unit="page" from="1409" to="1438" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On the Complexity of Multiple Sequence Alignment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lusheng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Biology</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A Semantics Aware Approach to Automated Reverse Engineering Unknown Protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yipeng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiao-Chun</forename><surname>Yun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muhammad</forename><forename type="middle">Zubair</forename><surname>Shafiq</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liyan</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><forename type="middle">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhibin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danfeng</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yongzheng</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th IEEE International Conference on Network Protocols</title>
		<meeting>the 20th IEEE International Conference on Network Protocols</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Automatic Network Protocol Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gilbert</forename><surname>Wondracek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><forename type="middle">Milani</forename><surname>Comparetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Krügel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engin</forename><surname>Kirda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium. The Internet Society</title>
		<meeting>the Network and Distributed System Security Symposium. The Internet Society</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">ZOE: Content-based Anomaly Detection for Industrial Control Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Wressnegger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ansgar</forename><surname>Kellner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konrad</forename><surname>Rieck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th Conference on Dependable Systems and Networks</title>
		<meeting>the 48th Conference on Dependable Systems and Networks</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
