<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:54+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">CONCURRIT: Testing Concurrent Programs with Programmable State-Space Exploration</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><surname>Burnim</surname></persName>
							<email>jburnim@cs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering and Computer Sciences</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tayfun</forename><surname>Elmas</surname></persName>
							<email>elmas@cs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering and Computer Sciences</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Necula</surname></persName>
							<email>necula@cs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering and Computer Sciences</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koushik</forename><surname>Sen</surname></persName>
							<email>ksen@cs.berkeley.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering and Computer Sciences</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>Berkeley</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">CONCURRIT: Testing Concurrent Programs with Programmable State-Space Exploration</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Testing is the most widely-used methodology for software validation. However, due to the nondeterministic interleavings of threads, traditional testing for concurrent programs is not as effective as for sequential programs. To attack the nondeterminism problem, software model checking techniques have been used to systematically enumerate all possible thread schedules of a test program. But such systematic and exhaustive exploration is typically too time-consuming for many test programs. We believe that the programmer&apos;s help to guide the model checker towards interesting executions is critical to circumvent this problem. We propose a testing technique and a supporting tool called CONCURRIT, which provides a model checker that can be guided programmatically within test code. While writing a test, the programmer specifies a particular thread interleaving scenario in mind using an embedded domain-specific language (DSL), and CONCUR-RIT explores all and only the executions realizing the intended scenario. During the exploration, the programmer is also able to observe the execution (e.g., assert in-variants) and constrain the future decisions of the model checker, all within the test code. We believe that providing the programmer the ability to observe and control the exploration of executions will lead to more effective and efficient testing for concurrent programs.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Testing is the most widely-used methodology for software validation. Concurrency brings new challenges to software testing. The biggest challenge is the nondeterminism in the scheduling of concurrently running computations, i.e., threads. The output of a concurrent program can be highly sensitive to timings of the interactions and interference between threads. The same test program can result in a large number of nondeterministic executions producing different outcomes. This makes concurrency-related defects notoriously difficult to detect and reproduce. As a result, testing has not been applied on concurrent programs as effectively in practice as it has on sequential programs.</p><p>We believe that to address this problem, it is critical for testing to provide the programmer techniques and tools (i) to conveniently express interesting executions of a test program with respect to a particular thread interleaving scenario in mind and (ii) to examine these executions systematically and efficiently. We observe a spectrum of approaches to this, as described next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Background</head><p>At one end of the spectrum, there are manual approaches. In the extreme case, a multithreaded test program is run under a completely nondeterministic scheduler. There is no guarantee about whether the resulting execution will be of any interest (e.g., with sufficient degree of interaction between threads) to the programmer and whether re-running the test will produce the same or different executions. To control the nondeterminism, the programmer implements a synchronization/communication mechanism (e.g., inserts sleep statements throughout the code) to restrict the possible schedules of threads towards a particular scenario. However, such mechanisms are not portable and reliable in general and may require nontrivial modifications in the program text. Techniques have been proposed to guide the execution to intended thread schedules in more portable and reliable ways, where the intended schedules are specified by the programmer relative to a global timer (ConAn <ref type="bibr" target="#b15">[16]</ref>, MultithreadedTC <ref type="bibr" target="#b20">[21]</ref>) or a sequence of user-defined events expressed in linear temporal logic (IMUnit <ref type="bibr" target="#b9">[10]</ref>). While these techniques give the programmer the ability to impose constraints on the interleaving of threads, they do not support systematic exploration of all executions satisfying these constraints.</p><p>At the other end of the spectrum, there are fully automated approaches. To alleviate the nondeterminism in the execution, software model checking techniques have been combined with testing to control the thread scheduler so that distinct interleavings of the threads in the test are systematically enumerated and checked against the test criteria <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b19">20]</ref>. Many model checking exploration techniques have been developed that seek to achieve high coverage of executions in a scalable way <ref type="bibr" target="#b11">[12]</ref>-such as partial-order reduction <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>, symmetry reduction <ref type="bibr" target="#b8">[9]</ref>, thread-modular reasoning <ref type="bibr" target="#b5">[6]</ref>, and preemption bounding <ref type="bibr" target="#b18">[19]</ref>. These techniques do not directly help to efficiently examine interesting and potentially-problematic interleaving scenarios. Due to the state-space explosion problem, examining a particular scenario involving large components of the program and identifying a bug may require to wait for an expensive (in time and resources) model checking process.</p><p>Recent studies proposed techniques to control the scheduling of a model checker to target suspicious executions more quickly than traditional state-space exploration. Among them, active testing <ref type="bibr" target="#b21">[22]</ref>, probabilistic scheduling <ref type="bibr" target="#b1">[2]</ref>, and change-aware preemption prioritization <ref type="bibr" target="#b10">[11]</ref> are fully automated and rely on heuristics. However, we believe that programmers help to guide the exploration of executions is also valuable, and testing tools should be designed to allow the programmer to interact with the test runtime to express her intents and insights about the test scenario. In fact, work on preemption sealing <ref type="bibr" target="#b0">[1]</ref> proposed to disable preemptions that the programmer thinks are not interesting or can cause false warnings. In our work, we would like to give more control and flexibility to the programmer in this direction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Our Approach</head><p>We propose a modeling and implementation of a testing technique and supporting tool (CONCURRIT) that combines testing and software model checking in a novel way. Our main goal is to make the model checking more accessible and controllable to the programmer. In particular, we provide a domain-specific language (DSL) embedded in a host language (in our case C/C++) using which the programmer can specify at high level how an execution of the test should develop, indicating constraints and nondeterministic choices on thread schedules. For example, a constraint on the schedule may dictate which threads are allowed to be interleaved at which point of the execution, or at which code location or under what conditions control will pass from a thread to another. Our DSL provides to the programmer a concise and convenient way of imposing constrains on thread interleavings programmatically-i.e., within the test code. In this way, one can describe a test scenario with various degrees of flexibility in the thread schedule ranging from fully deterministic to fully nondeterministic. Section 2 gives example test programs written in our DSL. CON-CURRIT implements a testing framework and a stateless model checker that, guided by our DSL, enumerates all possible executions satisfying the scenario constraints.</p><p>Our approach also makes the underlying model checker more accessible to the programmer for implementing and evaluating a custom search strategy within the test code. While existing model checkers also offer plug-in mechanisms to customize and extend the search algorithms, we believe that interacting with the tool directly from the test code and using a high-level DSL (rather than a low-level API) is more convenient for programmers. In this aspect, our work is similar to <ref type="bibr" target="#b14">[15]</ref>, which separates a compact and high-level fixed-point formulation of a model checking algorithm for Boolean programs from a general-purpose fixed-point solver.</p><p>The initial prototype implementation of CON-CURRIT for C/C++ programs is available online at http://code.google.com/p/concurrit/.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Testing Programs in Cooperative Semantics</head><p>One of our key insights is that from the perspective of a programmer, cooperative executions of a program are relatively much simpler to describe and reason about than its traditional preemptive executions. Thus, we propose to test a concurrent program by only examining its cooperative executions. In this case, code locations that a thread may yield control to another thread are explicitly marked, and a thread may not release control at a different location. In other words, code between two yield locations are guaranteed to run atomically. Once the functionality of the program is tested in the cooperative semantics, there are techniques (e.g., Yi et al. <ref type="bibr" target="#b22">[23]</ref><ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b24">[25]</ref>) that can validate the choice of yield points by checking that the program is cooperative <ref type="bibr" target="#b24">[25]</ref> with these yield points-i.e., when run under a traditional preemptive scheduler, the program does not exhibit any extra behavior other than it exhibits when running under a cooperative scheduler.</p><p>Let P refer to the program under test. We propose to perform the validation of P in the following steps: S1 The programmer obtains from P a program P coop by annotating P with yield points. (Section 3.1 ) S2 The programmer writes multithreaded tests for P coop and runs them in the cooperative semantics. This paper is mainly about the testing of P coop in this step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S3</head><p>The programmer (using <ref type="bibr" target="#b23">[24]</ref> or <ref type="bibr" target="#b24">[25]</ref>), either (i) shows that P coop is cooperative, or (ii) identifies potential interference points that are not covered by the existing yield annotations in P coop . If (ii) happens, back in S1, the programmer adds yield points to cover detected interference and re-runs the tests in S2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S4</head><p>The programmer compiles and deploys the program in the preemptive semantics by simply ignoring the yield annotations. In our case, yield annotations are C macros that translate to no-ops in the release build.   <ref type="figure">Figure 1</ref>. Example producer-consumer tests. <ref type="figure">Figure 1</ref> shows two tests for checking a concurrent producer-consumer module, which uses a shared, bounded buffer of integers. We omit the details of the program under test (shown at the top of the <ref type="figure">figure)</ref>, except we highlight that the code is annotated with yield points each with a unique label. The figure shows only one of these annotations labeled "Await" (line 5), though others exists so that threads running producer and consumer can interleave with each other. We focus on the test procedures, we call test scripts, written using our DSL. In the code, keywords specific to our DSL are shown underlined. For simplicity of exposition, we use a conceptual language, whereas in our implementation, the DSL is embedded in C/C++, and the corresponding language constructs are provided as C macros that translate to API calls to the CONCURRIT library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">// Program code under test (annotated with yield points for testing)</head><formula xml:id="formula_0">2 producer(Buffer *buff, int product) { ... ... ... } 3 consumer(Buffer *buff) { 4 ... 5 if (buff is empty) { ... yield(''Await''); ... } 6 ... 7 } 8 ---------------------------------------------------------------------------------------------- 9 //</formula><formula xml:id="formula_1">} 21 --------------------------------------------------------------------------------------------- 22 //</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Example: A Producer-Consumer Test</head><p>The first test test producer consumer 1 describes a scenario involving a bounded buffer to hold 2 integers (line 11), two threads P1, P2 to act as producers to insert 1 and 2 into the buffer (line 13), and two threads C1, C2 to act as consumers (line 14). Using our DSL, the programmer specifies that she expects to examine all possible nondeterministic interleavings of the threads. The DSL expression all endedpq returns true iff all the threads (visible in the current scope) have terminated. The statement transferp˚q.untilp˚q at line 16 instructs the model checker to run one of the threads P1, P2, C1, C2 until it reaches some yield point; ˚'s indicate that both the thread and yield point are chosen nondeterministically. The transfer statement blocks during this execution. We point out that, in addition to checking a postcondition of the test (line 19), the programmer can also insert an assertion at each interleaving point to check a program invariant (line 17). In this way, the programmer avoids to add these checks inside the program code under test, and thus, decouples her program from its tests.</p><p>The real novelty of our DSL comes into play when the programmer is interested in a particular set of interleavings rather than a completely nondeterministic one. The second test test producer consumer 2 describes such a situation. Suppose that the programmer does not want to examine all interleavings of these producer and consumer threads, because she suspects that a concurrency error is likely to occur during a particular interleaving scenario, and she wants to ensure that the intended scenario does not trigger any errors. Note that, looking at all interleavings of the threads (i.e., without constraining the interleavings) would help the programmer check her claim about the error-freedom of that interleaving scenario. However, exploring all interleavings would be too costly in time. Thus, the programmer intends to check all and only the possible executions of the scenario in mind, which develops in three steps: T1 Thread C1 runs first until it detects that the buffer is empty and starts waiting for the buffer to get full. T2 Then, both producer threads and consumer thread C2 run concurrently, until C2 consumes the integer either P1 or P2 inserts in the buffer and finishes. At the end of this step, size of the buffer must be § 1, since C2 consumes one of the integers produced.</p><p>T3 Finally, both producer threads and C1 run sequentially in some arbitrary order. At the end, the buffer must be empty, since in order to terminate C1 must consume the remaining integer not consumed by C2.</p><p>As shown in <ref type="figure">Figure 1</ref>, our DSL provides a clean, concise, and high-level way describing the scenario above. First, the DSL constructs help the programmer to constrain the nondeterminism in the interleavings of producer and consumer threads, so that at each point only allowed threads can run (using with), and a thread cannot execute earlier than or beyond a given point (using until). For example, C1 should run up to a yield point labeled "Await" at the beginning of the test (line 26), and then it should not run until C2 ends (line 28-32). (In fact, one can describe in this style a fully deterministic interleaving indicating which threads to transfer at each point and until which yield point.) Second, the DSL constructs also allow the programmer to indicate expected nondeterminism about which thread to choose and until when that thread must run (using˚)using˚). For example, in T2, P1, P2, and C2 are interleaved with each other nondeterministically, and in T3, threads are run sequentially until termination (we use the special label end to refer to the end of a thread) but in a nondeterministic order. Therefore, this test script specifies not a single execution but a set of executions, which our integrated model checker targets to systematically enumerate. We note that various model checking techniques, e.g., dynamic partial order reduction <ref type="bibr" target="#b4">[5]</ref>, can still be applied in this setting to make the exploration efficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">When a Test Passes or Fails</head><p>While testing a sequential program, the common question asked by the programmer is: Does the (only) execution of the test satisfy all the assertions? Having the ability to search all executions of a concurrent test program, we can talk about two questions to answer when running a test with a model checker. Each question determines when the overall test passes or fails (in other words, when the model checker finishes the exploration of executions). A successful execution of the test script is a "terminating" execution that (i) does not violate an assertion and (ii) satisfies all the constraints specified by the programmer. Section 3.2.1 overviews our DSL constructs to impose constraints on executions. A failing execution is one that violates an assertion. If an assertion violation is detected, the model checker terminates the exploration immediately and declares the test failed.</p><p>The model checker can be run one of two modes to answer the following questions, respectively: Are there any successful executions of the test script? In this mode, the model checker seeks to find a successful execution. The test passes if the model checker explores at least one successful execution without detecting any failing execution meanwhile. The test fails otherwise. Notice that, a test in this mode can pass, producing a successful execution, even though there also exists a failing execution. Are there any failing executions of the test script? In this mode, the model checker enumerates all successful executions of the test script. The test fails if the model checker detects a failing execution during the exploration and passes otherwise. Differently from the previous mode, a test in this mode can pass even though there is no successful execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Testing Programs with CONCURRIT</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Annotations for Cooperative Execution</head><p>Cooperative concurrency builds on the idea of (symmetric) coroutines <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b12">13]</ref>, which generalize subroutines to allow multiple entry points for suspending and resuming the execution. In CONCURRIT, we model coroutines for C/C++ using pthreads <ref type="bibr" target="#b17">[18]</ref> and cooperation at yield points using proper synchronization operations. In our case, the cooperation among threads is performed explicitly using two kinds of operations: transfer and yield. The former is used in the test script to pass control to other threads. The latter is used for a thread (for example, P1, P2, C1, C2 in <ref type="figure">Figure 1</ref>) to relinquish the control back to the test script, and for this, the program's code under test needs to be explicitly annotated with yield before testing, as explained next.</p><p>Every yield annotation is given a unique label, using which the yield location can be referred to in the test script. Let l range over labels. A yieldpl q statement can be placed anywhere in the code to indicate a location at which a thread executing that code in a cooperative execution may yield control to other threads. <ref type="figure">Figure 1</ref> shows an example to this at line 5. The yield points in general indicate source locations, such as accesses to shared memory, that are subject to interference by other threads. Thus, similarly to <ref type="bibr" target="#b22">[23]</ref>, yield points can also be annotated as follows: A read from a shared variable x can be replaced by yield readpl , xq. This expresses that the current thread first yields the execution to other threads, and when the control is transferred back to it again, it reads from x and returns the value. A write to a variable x in the form of x " e can be replaced by yield writepl , xq " e. This is similar to yield read, except that the current thread writes the (previously computed) value of e to x after it gains the control back.</p><p>In the extreme case, one can treat every shared variable access a potential yield point and imagine a tool that examines shared variable accesses and automatically inserts yield annotations accordingly. We provide such a tool (using Pin <ref type="bibr" target="#b16">[17]</ref>) that monitors sample executions of the test program and marks accesses that involve in a data race as potential yield points. However, in reality the number of shared variable accesses subject to harmful interference may be less than all shared accesses <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b24">25]</ref>. In this case, the programmer can choose to add the annotations gradually (for example, by pruning out the yield annotations inserted by a tool) as more tests pass. In fact, we see the gradual, test-driven addition of yield annotations as a systematic way of increasing the concurrency of the program. <ref type="figure" target="#fig_2">Figure 2</ref> shows our DSL for writing tests. Note that, for simplicity we present here a conceptual language rather f , g P Functions t P ThreadVariables l ::" next | end | "label text"</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Test Scripts: Syntax and Semantics</head><p>Yield labels e ::" ended (t) | all ended() | ¨ ¨ ¨ Boolean expressions t ::" ˚ | t | t1, ¨ ¨ ¨, t k Thread expressions u ::" ˚ | l | e Until expressions c ::" except(t) | until(u) | count(k) Transfer clauses s ::" t = thread (f, args) Thread creation | t = transfer (t).c1. . . c k</p><p>Transfer to a thread  <ref type="figure">Figure 3</ref>. Execution of a test script.</p><formula xml:id="formula_2">| assert (e) Assertion | assume (e) Assumption | with/without (t1, ¨ ¨ ¨, t k ) { s } Thread scope | x " e | s ; s | if(e) { s } | ¨ ¨ ¨ Standard C/C++ stmts.</formula><formula xml:id="formula_3">· · · yield(l 1 ); · · · yield(l 2 ); · · · } // Test script: test func() { t 1 = thread(f, . . . ); t 2 = thread(g, . . . ); transfer(t 1 ).until(l 1 ); assert x == 0; transfer(񮽙).until(񮽙); assume y == 1; assert x == 1; } g(args) { t 1 t 2 Main</formula><p>than the actual C/C++ syntax. A test script in this setting is a function (in a recognizable signature by our testing framework), whose body is a statement s from <ref type="figure" target="#fig_2">Figure 2</ref>. A test script combines our DSL expressions and statements with other, standard expressions and statements of the host language (in our case, C/C++). <ref type="figure">Figure 3</ref> depicts the execution of a test. The test is executed by a set of threads: tMain, t 1 , ..., t n u whose interleavings are controlled by a model checker. Main refers to the special controller thread running the test script written in our DSL. In <ref type="figure">Figure 1</ref> the body of test producer consumer 1/2 are executed by Main. Every execution of the test starts with Main being the only thread. Other threads (t 1 , ..., t n ), we call test threads, are created by Main within the script using the thread operation; each test thread executes a given function call concurrently (and cooperatively) with Main and other test threads. In <ref type="figure">Figure 1</ref> threads P1, P2, C1, C2 are test threads and created at lines 13-14. Creating a thread does not activate the new thread; the thread is activated later by a transfer statement as described next.</p><p>At any time during the execution, either Main or one of t 1 , ..., t n is allowed to run, and that thread does not pass the control to another thread until it reaches a transfer or yield.</p><p>• Control passes from the Main thread to a test thread t i by a transfer operation in the test script. (Arrows 1, 3 in <ref type="figure">Figure 3</ref>) As only one thread is active at any time, Main then gets into a waiting state.</p><p>• Control passes from a test thread t i to the Main thread by a yield operation. (Arrows 2, 4 in <ref type="figure">Fig- ure</ref> 3) Not every yield call is granted (taken) (see Section 3.2.1), but whenever it is, control is always given to Main.</p><p>When Main becomes active, it can check some condition on the current state using assert or assume (see below), perform local computation and update some (possibly global) variables, and/or can transfer control to another test thread. An execution of the test ends when the test script finishes. The model checker may then backtrack and start a new execution of the script.</p><p>We point out that the test script may also describe an infeasible interleaving. For example, a thread may block (on a synchronization operation) between two yield point, preventing Main from taking the control back. To detect and avoid such cases, we set a time limit for each thread to execute between two yield points. If this time expires, the model checker stops the current execution and backtracks for a distinct execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">DSL Constructs to Constrain Test Executions</head><p>Assert and assume. Given a boolean expression on the current state (global variables plus the locals of Main) we distinguish two ways to reason about a condition on the current program state: assert e and assume e. Both statements do not have any side effects if e holds (i.e., evaluates to true), but they differ when e does not hold.</p><p>If e does not hold, assert e causes the test to fail immediately, as usual. On the other hand, assume e in this case does not terminate the entire test. Instead, the model checker discards the currently explored execution, backtracks, and restarts with a distinct thread schedule. Thus, we use assumptions to impose a "soft" constraint on the executions to be explored by the model checker, especially when expressing at which conditions an interleaving is expected to happen is more convenient than referring to a particular yield label in the program. Nondeterministic transfers. While a test thread always yields to Main, the target of a transfer from Main can be decided statically or at runtime. In the simplest case, transferpt i q passes the control to thread t i . The programmer can also leave the (nondeterministic) decision about which thread to run to the model checker using transferpt 1 , ..., t k q or transferp˚q. In the former case one of t 1 , ..., t k and in the latter case any thread in the current scope (see below) is chosen. <ref type="bibr" target="#b0">1</ref> The chosen target thread is returned by transfer for the script's observation when control is given back to Main. An except clause can be attached to transferp˚q to prevent a thread or threads from being scheduled at that transfer point (e.g., transferp˚q.exceptpt 2 q). Transfer clauses. When transferring to a test thread, the programmer can also choose at which yield point the target thread should yield the control back to Main. For this, transfer statements are augmented with count and until clauses, which specify the required conditions for the target thread to yield. By default, each transfer is augmented with untilp˚q and countp1q clauses, indicating that the target thread can relinquish the execution at any point. 1 Given a label l , untilpl q.countpkq indicates that the target thread should yield at the k th visit of a yield point labeled with l but no earlier. We also define special labels next and end for convenience to refer to the next reached yield label and the end of the target thread. For example, transferptq.untilpendq transfers to t and executes it until t terminates. Finally, the programmer can also specify a boolean expression in untilpeq to indicate that the target thread should yield only when e evaluates to true. Given that, transferp¨¨transferp¨¨ ¨ q.untilpeq is equivalent to transferp¨¨transferp¨¨ ¨ q; assumepeq. Thread scopes. Our DSL allows the programmer to define a temporary thread scope in which the model checker works with only a subset of threads visible in the current C scope. For this, we provide withpt 1 , ¨ ¨ ¨, t k q and withoutpt 1 , ¨ ¨ ¨, t k q statements. The former defines a thread scope in which only threads t 1 , ¨ ¨ ¨, t k are used in any scheduling decision while executing the given statement (referring to another thread causes an error). In <ref type="figure">Figure 1</ref>, we use with to constrain part of the execution to threads P1, P2 and C2 (line 28). The latter also defines a thread scope but in a dual way; it temporarily removes t 1 , ¨ ¨ ¨, t k from the current scope.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Conclusion</head><p>We propose a modeling and implementation of a testing technique and supporting tool (CONCURRIT) combining testing and software model checking in a novel way. Our technique provides a domain-specific language (DSL) embedded in a host language (in our case C/C++). The programmer, using this DSL, can specify at high level how an execution of the test should develop; s/he can explicitly indicate constraints on thread schedules. In this way, the programmer can control the degree of freedom in nondeterministic choices a model checker would make during the state-space exploration. We believe that such a DSL can make the model checking more acces-</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Test script in our DSL describing all interleavings of</head><label></label><figDesc>four threads 10 test producer consumer 1() { 11 Buffer buff(2); // Create empty bounded buffer of size two 12 // Create producer and consumer threads, but not activate them yet 13 thread t P1 = thread(producer, &amp;buff, 1), P2 = thread(producer, &amp;buff, 2); 14 thread t C1 = thread(consumer, &amp;buff), C2 = thread(consumer, &amp;buff); 15 while(!all ended()); // Loop until both threads terminate 16 transfer(*).until(*); // Run a thread until some yield point 17 assert( ... ); // Check an invariant on the buffer 18 } 19 assert(buff.size() == 0); // Check a post-condition on the buffer 20</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Test script in our DSL describing intended interleavings of</head><label></label><figDesc>a scenario 23 test producer consumer 2() { 24 ... // Same definitions in lines 11-14 above 25 // T1 26 transfer(C1).until(''Await''); // Run C1 until yield point labeled ''Await'' 27 // T2 28 with(P1, P2, C2) { // Execute lines 29-31 with only P1, P2 and C2 29 while(!ended(C2)); // Loop until C2 terminates 30 transfer(*).until(*); // Run a thread until some yield point 31 } 32 } 33 assert(buff.size() †= 1); // Check a condition on the buffer 34 // T3 35 while(!all ended()) { // Loop until all threads terminate 36 transfer(*).until(end); // Run a thread until it terminates 37 } 38 assert(buff.size() == 0); // Check a condition on the buffer 39 }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Syntax of our DSL, embedded in C/C++, for writing test scripts. (We do not show yield, as it is not used in test scripts, but in the program under test.)</figDesc></figure>

			<note place="foot" n="1"> The nondeterministic decision may be biased by the model checker&apos;s search algorithm, e.g., the partial-order reduction [7] being used. sible and controllable to the programmer, and thus, can lead to a more effective use of the state-space exploration in unit and system testing.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Preemption sealing for efficient concurrency testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Burckhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katherine</forename><surname>Coons</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madanlal</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shaz</forename><surname>Qadeer</surname></persName>
		</author>
		<idno>MSR-TR-2009-143</idno>
		<imprint>
			<date type="published" when="2009" />
			<pubPlace>Microsoft Research</pubPlace>
		</imprint>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A randomized scheduler with probabilistic guarantees of finding bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Burckhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pravesh</forename><surname>Kothari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madanlal</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Santosh</forename><surname>Nagarakatte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the fifteenth edition of ASPLOS on Architectural support for programming languages and operating systems, ASPLOS &apos;10</title>
		<meeting>the fifteenth edition of ASPLOS on Architectural support for programming languages and operating systems, ASPLOS &apos;10<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="167" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">NDSeq: Runtime checking for nondeterministic sequential specifications of parallel correctness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><surname>Burnim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tayfun</forename><surname>Elmas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Language Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Design of a separable transitiondiagram compiler</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Melvin</forename><forename type="middle">E</forename><surname>Conway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="396" to="408" />
			<date type="published" when="1963-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Dynamic partial-order reduction for model checking software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cormac</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrice</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;05: Proc. of the 32nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="110" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Thread-modular model checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cormac</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shaz</forename><surname>Qadeer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th international conference on Model checking software, SPIN&apos;03</title>
		<meeting>the 10th international conference on Model checking software, SPIN&apos;03<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="213" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Partial-order methods for the verification of concurrent systems: an approach to the stateexplosion problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrice</forename><surname>Godefroid</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Springer-Verlag Inc</publisher>
			<biblScope unit="volume">1032</biblScope>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Cartesian partial-order reduction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guy</forename><surname>Gueta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cormac</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eran</forename><surname>Yahav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mooly</forename><surname>Sagiv</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th international SPIN conference on Model checking software</title>
		<meeting>the 14th international SPIN conference on Model checking software<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="95" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Symmetry reduction criteria for software model checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Radu</forename><surname>Iosif</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th International SPIN Workshop on Model Checking of Software</title>
		<meeting>of the 9th International SPIN Workshop on Model Checking of Software<address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="22" to="41" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Improved multithreaded unit testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vilas</forename><surname>Jagannath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milos</forename><surname>Gligoric</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongyun</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qingzhou</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Grigore</forename><surname>Rosu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Darko</forename><surname>Marinov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on Foundations of software engineering, ESEC/FSE &apos;11</title>
		<meeting>the 19th ACM SIGSOFT symposium and the 13th European conference on Foundations of software engineering, ESEC/FSE &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="223" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Change-aware preemption prioritization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vilas</forename><surname>Jagannath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qingzhou</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Darko</forename><surname>Marinov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 International Symposium on Software Testing and Analysis, ISSTA &apos;11</title>
		<meeting>the 2011 International Symposium on Software Testing and Analysis, ISSTA &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="133" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Software model checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ranjit</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rupak</forename><surname>Majumdar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page">54</biblScope>
			<date type="published" when="2009-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Coroutines and Networks of Parallel Processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gilles</forename><surname>Kahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">B</forename><surname>Macqueen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Processing 77</title>
		<imprint>
			<publisher>North Holland Publishing Company</publisher>
			<date type="published" when="1977" />
			<biblScope unit="page" from="993" to="998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A comparative study of software model checkers as unit testing tools: An industrial case study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moonzoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yunho</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hotae</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="146" to="160" />
			<date type="published" when="2011-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Analyzing recursive programs using a fixed-point calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Salvatore</forename><surname>La Torre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madhusudan</forename><surname>Parthasarathy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gennaro</forename><surname>Parlato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 ACM SIGPLAN conference on Programming language design and implementation, PLDI &apos;09</title>
		<meeting>the 2009 ACM SIGPLAN conference on Programming language design and implementation, PLDI &apos;09<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="211" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Tool support for testing concurrent java components</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brad</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Hoffman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Strooper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="555" to="566" />
			<date type="published" when="2003-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Pin: building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chi-Keung</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harish</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Artur</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoff</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vijay</forename><forename type="middle">Janapa</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim</forename><surname>Hazelwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 ACM SIGPLAN conference on Programming language design and implementation, PLDI &apos;05</title>
		<meeting>the 2005 ACM SIGPLAN conference on Programming language design and implementation, PLDI &apos;05<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="190" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Pthreads library interface</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Mueller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Iterative context bounding for systematic testing of multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madanlal</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shaz</forename><surname>Qadeer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2007 ACM SIGPLAN conference on Programming language design and implementation, PLDI &apos;07</title>
		<meeting>the 2007 ACM SIGPLAN conference on Programming language design and implementation, PLDI &apos;07<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="446" to="455" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Concurrent testing of java components using java pathfinder</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Mutilin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Leveraging Applications of Formal Methods, Verification and Validation</title>
		<imprint>
			<date type="published" when="2006-11" />
			<biblScope unit="page" from="53" to="59" />
		</imprint>
	</monogr>
	<note>Second International Symposium on</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Unit testing concurrent software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Pugh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathaniel</forename><surname>Ayewah</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the twenty-second IEEE/ACM international conference on Automated software engineering, ASE &apos;07</title>
		<meeting>the twenty-second IEEE/ACM international conference on Automated software engineering, ASE &apos;07<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="513" to="516" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Race directed random testing of concurrent programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2008 ACM SIGPLAN conference on Programming language design and implementation, PLDI &apos;08</title>
		<meeting>the 2008 ACM SIGPLAN conference on Programming language design and implementation, PLDI &apos;08<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="11" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Types for precise thread interference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jaeheon</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Disney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cormac</forename><surname>Flanagan</surname></persName>
		</author>
		<idno>UCSC-SOE-11-22</idno>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
		<respStmt>
			<orgName>University of California at Santa Cruz</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Effects for cooperable and serializable threads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jaeheon</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cormac</forename><surname>Flanagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th ACM SIGPLAN workshop on Types in language design and implementation, TLDI &apos;10</title>
		<meeting>the 5th ACM SIGPLAN workshop on Types in language design and implementation, TLDI &apos;10<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="3" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Cooperative reasoning for preemptive execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jaeheon</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Caitlin</forename><surname>Sadowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cormac</forename><surname>Flanagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM symposium on Principles and practice of parallel programming, PPoPP &apos;11</title>
		<meeting>the 16th ACM symposium on Principles and practice of parallel programming, PPoPP &apos;11<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="147" to="156" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
