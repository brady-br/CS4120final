<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:26+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Mouse Trap: Exploiting Firmware Updates in USB Peripherals</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><surname>Maskiewicz</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">UC San Diego</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Ellis</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">UC San Diego</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Mouradian</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">UC San Diego</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">UC San Diego</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Mouse Trap: Exploiting Firmware Updates in USB Peripherals</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Although many users are aware of the threats that mal-ware pose, users are unaware that malware can infect peripheral devices. Many embedded devices support firmware update capabilities, yet they do not authenticate such updates; this allows adversaries to infect peripher-als with malicious firmware. We present a case study of the Logitech G600 mouse, demonstrating attacks on networked systems which are also feasible against air-gapped systems. If the target machine is air-gapped, we show that the Logitech G600 has enough space available to host an entire malware package inside its firmware. We also wrote a file transfer utility that transfers the malware from the mouse to the target machine. If the target is networked, the mouse can be used as a persistent threat that updates and reinstalls malware as desired. To mitigate these attacks, we implemented signature verification code which is essential to preventing malicious firmware from being installed on the mouse. We demonstrate that it is reasonable to include such signature verification code in the bootloader of the mouse.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In July of 2013, the US Commerce Department's Inspector General released a report revealing that the US Economic Development Administration (EDA) spent $2.7 million in December 2011 in response to a malware infection <ref type="bibr" target="#b33">[34]</ref>. The EDA had intended to destroy all of its IT equipment -every computer, mouse, keyboard, printer, camera, and monitor in their possession, valued at over $3 million -and stopped only when they exhausted their budget, with $170,500 of equipment actually destroyed. The precautions taken were due to a misunderstanding across internal departments, leading administrators to believe they were under a large-scale and sophisticated cyber attack; in reality, only a handful of computers were compromised, and the malware appeared to be untargeted and easily quarantinable. Various technology news organizations ridiculed the EDA for its * jmaskiew@ucsd.edu â€  {bellis,jmouradi,hovav}@cs.ucsd.edu lack of cybersecurity understanding, believing that peripherals would not have been compromised during the incident <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b12">13]</ref>. The Verge, a technology magazine, observed that "throwing away computer mice seems like a poor approach to ridding an organization of digital threats" <ref type="bibr" target="#b22">[23]</ref>. Ars Technica, a publication generally respected for its technical accuracy, published an article titled "US agency baffled by modern technology, destroys mice to get rid of viruses" <ref type="bibr" target="#b9">[10]</ref>. These comments demonstrate the common belief that peripherals such as mice cannot be infected by malware. In this paper, we show that this belief is false. We give, for the first time, an end-to-end demonstration of mouseborne malware. We show how unprivileged software running on a PC host can replace the firmware on an offthe-shelf Logitech G600 gaming mouse, and how compromised firmware on the mouse can in turn reinfect the PC host.</p><p>Far from being benign, mice make an ideal vector for compromise of hardened or air-gapped computers. A compromised mouse could be carried by an unwitting user into a secure facility. Mouse-to-host attack, like keyboard-to-host attack <ref type="bibr" target="#b11">[12]</ref>, is simple and compact due to the capabilities of the USB human interface device (HID) stack.</p><p>We believe that mice, like other embedded devices, should verify the integrity of firmware updates cryptographically. We show that it is possible to implement RSA signature verification within the space constraints of a G600 mouse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Background and Motivation</head><p>As antivirus software becomes more sophisticated, persistent delivery of malware becomes increasingly difficult. Users are unlikely to suspect peripherals such as keyboards and mice to be capable of containing malware, and modern anti-virus software is often incapable of scanning peripherals' firmware. With both users and defensive software unaware of its presence, malware located in a peripheral could have a long and undetected life.</p><p>Malware positioned within a USB peripheral can input HID codes to the computer on behalf of the user. Many modern operating system protections and isolations can be circumvented in this manner since such inputs are considered user-intended behavior. Additionally, the attacker-controlled peripheral can retrieve malware from the web and install it on the host machine, allowing attackers to persistently reinstall removed malware and update out-of-date malware. Furthermore, peripherals used across multiple computers can first be compromised on an insecure machine and then be used to compromise a secure machine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related Work</head><p>As antivirus software develops, people have put a great deal of effort into delivering malware to locations undetectable by traditional antivirus scanning techniques. Advanced rootkits such as Mebroot are executed before the user's operating system even boots, bypassing many malware detection and prevention mechanisms <ref type="bibr" target="#b32">[33]</ref>.</p><p>USB HID as a delivery mechanism. The USB HID class has a standardized protocol for communication with keyboards, mice, and an array of other USB devices <ref type="bibr" target="#b31">[32]</ref>. Several projects have developed custom HID hardware for exploit delivery. In 2010, a briefing on how to write software complying to the USB HID specification was given at BlackHat, demonstrating how to construct a USB device that uses the USB HID protocol to emulate a legitimate user <ref type="bibr" target="#b29">[30]</ref>. Crenshaw demonstrated the feasibility of a malicious USB HID dongle and showed how to lock Windows systems down against the installation of new USB devices <ref type="bibr" target="#b13">[14]</ref>. There are a number of programmable HID USB keystroke dongle (PHUKD) designs and tutorials available on the web. PHUKD allows an attacker to deliver keystrokes to a user's computer by inserting the dongle into an available USB slot, ultimately gaining control of the computer <ref type="bibr" target="#b27">[28]</ref>. A radio frequency version of the device, UR-FUKED, has been shown to allow adaptive, remote delivery of HID keystrokes to a computer <ref type="bibr" target="#b16">[17]</ref>.</p><p>Attacks on embedded device firmware. Firmware update attacks, or the process of compromising a victim's embedded device by installing firmware of attacker construction, have been demonstrated in several arenas. Cui et al. reverse-engineered HP laserjet printer firmware, leveraging its insecure update mechanism to allow the delivery of firmware to the printer of their choosing <ref type="bibr" target="#b14">[15]</ref>.</p><p>Additionally, Cui et al. provided a survey indicating that insecure update mechanisms were not restricted to the printers used to demonstrate their attack <ref type="bibr" target="#b14">[15]</ref>. Even more generally, Belissimo et al. surveyed the security of software updates and found secure software updates to be challenging to implement and make available in practice <ref type="bibr" target="#b5">[6]</ref>.</p><p>Such attacks can apply to embedded systems that are part of traditional PCs. For example, Miller showed how to modify the firmware on Apple laptop batteries <ref type="bibr" target="#b25">[26]</ref>. In 2009, Chen successfully reverse-engineered and exploited a firmware updater for a full-size, wired Apple keyboard, allowing delivery of a persistent rootkit to the keyboard itself <ref type="bibr" target="#b11">[12]</ref>; as Chen observed, the keyboard could then compromise its host through USB HID. Brocker and Checkoway demonstrated a sophisticated attack to enable a Macbook camera's recording mode without illuminating the LED <ref type="bibr" target="#b10">[11]</ref>. The reprogrammed camera could also masquerade as a USB HID device, enabling VM escape, though the camera firmware does not persist across reboots.</p><p>Our findings are analogous to Chen's, but for an offthe-shelf mouse rather than keyboard. Compared to Chen, we provide an end-to-end demonstration (it is not clear that Chen implemented his proposed keyboard-tohost attack); in addition, we show that cryptographic protection against unauthorized firmware is feasible on the mouse.</p><p>Malicious mice. There has been a fair amount of work outside of academia involving mice specifically; these attacks often rely on modifying the hardware of the mouse.</p><p>Several individuals have used the pixel array presented by the optical laser on the mouse to turn it into various kinds of low-definition cameras. Franci Kapel turned a mouse into a web camera while Jeroen "Sprite_tm" Domburg combined the pixel array with movement information to turn it into a scanner <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b15">16]</ref>.</p><p>In March 2014, German technology magazine c't reported a novel trigger for sending the payload. The mouse waits to deliver the payload until the 18 Ã— 18 pixel matrix read in by the optical laser matches a particular pattern <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b7">8]</ref>. <ref type="bibr" target="#b0">1</ref> This inspired Imgur user Indyaner to experiment with adding custom hardware to mice in order to deliver malware. Indyaner added custom hardware to a Logitech mouse and repackaged it <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b6">7]</ref>. Notably, the Arduino that Indyaner used has an ATmega32u4 which is very similar to the ATmega32u2 that we found inside of the Logitech G600 gaming mouse.</p><p>Netragard conducted a devastating pentest involving modified mice. After modifying the mouse's hardware, they repackaged it and mailed it to a target in the company with fliers to disguise the mouse as a promotional gift. The target employee proceeded to plug the mouse in at work, causing the mouse to contact Netragard's command and control server <ref type="bibr" target="#b28">[29]</ref>. This validates our statement that a mouse is a valid vector for infiltrating an organization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Attack Model</head><p>There are two components to our attack: infecting the mouse and exploiting the target. In this section, we present several options for both of these components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.1">Infecting the Mouse</head><p>Ensuring that an infected mouse is attached to the target machine requires different steps depending on whether the target is networked or air-gapped.</p><p>The networked case is simpler since the mouse is already connected to the target machine. The mouse firmware must be updateable, and the adversary must control a program capable of updating the mouse running on the target's machine. Since USB is not a protected resource, the adversary's program only needs user-level privileges. Common techniques for obtaining such user-level privileges include web exploits, drive-bydownloads, and distributing Trojan horses in repackaged software. Alternatively, an attacker could deliver users a seemingly legitimate mouse firmware update via a manin-the-middle attack, posing as the mouse manufacturing company. We note that the original firmware updater we modified was delivered over HTTP, which would enable this kind of attack <ref type="bibr" target="#b24">[25]</ref>.</p><p>The second attack method is to deliver an alreadycompromised mouse, prepared in a lab environment, to a victim computer. A known infiltration technique is to leave compromised USB peripherals, such as USB mass storage devices, in a company parking lot <ref type="bibr" target="#b30">[31]</ref>. Users find the storage devices and use them, assuming they were incidentally dropped by a benign individual. A compromised mouse found in a shopping bag, repackaged, with the receipt included, could just as easily be taken by an unsuspecting user, as demonstrated by the Netragard pentest <ref type="bibr" target="#b28">[29]</ref>. A common defense against USB mass storage device attacks is to disable the Windows AutoRun.exe service; this mitigation is ineffective against mice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3.2">Delivering the Malware</head><p>We consider two separate attack models: one where the mouse is connected to a machine with Internet access and another where the mouse is connected to an air-gapped machine.</p><p>If the mouse is connected to a machine with Internet access, then the mouse can simply open a shell in order to download and run malware. This also allows the mouse to retrieve updated versions of the malware or reinstall malware if it has been detected and removed. This attack model involves only low-complexity firmware modification on the mouse.</p><p>If the mouse is connected to a machine without Internet access, then the mouse must contain the entire malware. It can then transfer this malware to the host machine over USB. Some possibilities for this transfer mechanism include: 1) constructing the malware using shell utilities directed by key commands (see Â§5 for more details), 2) identifying as a firewire-to-usb adapter and using direct memory access <ref type="bibr" target="#b4">[5]</ref>, and 3) reporting as a usb storage device with the executable onboard and clicking on it . This attack model requires that the mouse is either shared between secure and insecure computers or that the mouse is attached to a secure computer after being delivered surreptitiously as described above.</p><p>Furthermore, peripherals are often reused when new computers are acquired. A consumer may buy a new desktop but reuse their old keyboard, monitor, mouse, and speakers. In this way an infected mouse may transfer across generations of computers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Roadmap</head><p>To mount our attack, we first obtained a mouse whose firmware can be updated and therefore compromised. We describe this mouse and its architecture in Â§2. We then reverse-engineered the mouse firmware with standard techniques as we describe in Â§3. We proceeded to reverse-engineer the firmware updater and patch it to enable flashing the mouse with firmware of our construction, as we will discuss in Â§4. We describe our various current exploits in Â§5; they all revolve around sending HID codes to a terminal to execute arbitrary commands and infect the target computer with malware. In Â§6 we discuss potential alternate triggering mechanisms for our attack. In Â§7, we propose mitigations to our attack and discuss their feasibility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">Ethics and Disclosure</head><p>We notified the vendor of our findings on July 6, 2014. We do not believe that the problems we identified are unique to the mouse we studied. Rather, we believe that every device with flashable firmware is potentially at risk. Mice and keyboards are assumed to speak for the user, simplifying device-to-host attacks; but other devices, once compromised, can reinvent themselves as keyboards <ref type="bibr" target="#b10">[11]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Overview of the Mouse</head><p>In this section we will describe the architecture and regular behavior of our chosen mouse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Choice of Mouse</head><p>For both ease of programming and wider spread compromise capability, we elected to use a mouse that has a software firmware update mechanism. After finding updateable mice via the web, we examined two such mice: the Logitech G500s and G600. Manual disassembly and inspection of the microcontrollers revealed that the Logitech G600 features an Atmel ATmega32u2 which has a readily available data sheet and runs AVR, an 8 bit RISC architecture. The Logitech G500s, however, appeared to have a custom microcontroller and at the time of this report did not appear to have publicly available programming information. Therefore, we chose the G600 as our target.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Mouse Firmware Structure</head><p>The ATmega32u2 uses a Harvard architecture, so the chip's memory is split into program and data memory. Within the application section, the firmware is split into two segments: an application segment and a bootloader segment. The application segment starts at the beginning of program memory whereas the bootloader segment occupies the last 1/8 of program memory.</p><p>The application segment contains all of the code to be run during normal operation of the mouse. This includes the mouse's main sleep loop, SPI interrupt handling from the optical laser, and sending both USB HID codes and button presses to the host.</p><p>The bootloader is responsible for managing the firmware update process. As part of this responsibility, it has privileges that the application segment does not necessarily have. For instance, the bootloader is able to write to application memory <ref type="bibr" target="#b0">[1]</ref>. The firmware update process does not write to the bootloader segment of the mouse, so it is always possible to flash the mouse with firmware. This proved valuable since it means that a buggy firmware update does not permanently disable the mouse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Sending USB HID Codes</head><p>Because the G600 is a gaming mouse, it has far more buttons than the standard left button, right button, and scroll wheel. It has an entire number pad on its side (labeled G9 through G20) as well as a Gshift button that changes the behavior of all buttons on the mouse much the same way that a normal shift key changes the behavior of buttons on a key board. Due to this number pad, the mouse registers itself as a composite mouse and keyboard, so the computer is expecting to receive key input from the device.</p><p>Using USB PCAP <ref type="bibr" target="#b26">[27]</ref>, a tool which allows users to record USB traffic sent over the wire, and Wireshark, we 0x 01 00 1E 00 00 00 00 HID '1' 0x 08 00 01 00 00 14 G9 button pressed 0x 01 00 00 00 00 00 00 HID clear 0x 01 00 00 00 00 00 G9 button up <ref type="table">Table 1</ref>: The sequence of signals involved in sending an HID '1' over USB when button G9 is pressed were able to identify USB packets that corresponded to mouse movement and button presses. Four signals work in tandem to send a USB button press; see <ref type="table">Table 1</ref> for an example. HID related packets are prefixed with 0x01 and contain standard HID keyboard codes. Packets encoding the combination of buttons that are currently pressed begin with 0x80 and end with 0x14. Bytes 1 through 3 contain bit flags that represent all buttons currently pressed down, allowing for combos based off of pressing multiple buttons.</p><p>We also note that in the HID specification, modifier keys such as Alt, Shift, Control, etc. are sent as bit flags as well. Understanding how to send such keys plays a crucial role in our final exploits.</p><p>In the USB protocol, devices register various communication "endpoints" which can send and receive data. Each of these is numbered and can be set to fulfill a specific responsibility. The ATmega32u2 has 4 USB endpoints available for both input and output <ref type="bibr" target="#b0">[1]</ref>. The output buffers can be populated with a fixed number of data bytes and flushed, triggering the data to be sent from the mouse down the USB cable. USB PCAP revealed that mouse movement was sent over USB endpoint 1 and button presses from the mouse are sent over USB endpoint 2. Endpoint 4 appears completely unused and is therefore an appealing candidate to use for communicating with malware running on a target machine.</p><p>The ATmega32u2 supports two approaches to sending consecutive USB packets: polling and interrupt driven. In the polling option, an application desiring to send data continuously checks the status of the RWAL (Read/Write Allowed) flag until it signals that the data bank is ready to be written to. In the interrupt driven approach, an interrupt is fired every time that a data bank is available to be written to. This interrupt is then caught by the appropriate handler. Our reverse engineering indicated that the mouse utilizes polling to determine when it can send USB packets; see Â§3 for more details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">The Mechanics of a Firmware Update</head><p>A firmware update to the mouse is initiated from the software updater on the host machine. A USB reset is sent to switch the mouse from the application segment to the bootloader segment, at which point the mouse begins listening for firmware update messages from the host. We   remind the reader that Logitech wrote a custom firmware updater in their bootloader, so there is no public documentation available.</p><p>There is a complex function in the bootloader that controls how it responds to various USB packets. For the purposes of this discussion, the only relevant packets are those that begin with 0xc0 which contain the actual bytes of the firmware and those that begin with 0xd0 which deal with various aspects of the control flow of the firmware update; see <ref type="table" target="#tab_1">Table 2</ref>  Upon receiving a Start Page packet, the mouse clears out a page-sized temporary buffer in program memory. Then, as the bootloader receives each Firmware Data packet, it writes the data into the temporary buffer. Upon receiving an End Page packet, the firmware updater writes the temporary buffer to program memory at the page address indicated in the packet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Firmware Analysis</head><p>With standard reverse-engineering techniques, we were able to identify significant units of mouse firmware functionality. The firmware contains over 12,000 lines of assembly as well as 3 KB of data that contain information such as the version string and device name. Ultimately we gave precise, human readable names to over 160 functions compromised of over 4,000 lines of assembly. During this process we reversed engineered substantial portions of a USB library, an EEPROM library, an SPI library and a math library. We are happy to have avoided reversing the entire firmware; knowing what not to read is just as important as knowing what to read when attempting to quickly understand how a system works.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Obtaining the Firmware</head><p>Firmware for the Logitech G600 can be updated via software available from the Logitech website. Both 32-and 64-bit versions are available for download for recent Windows platforms <ref type="bibr" target="#b24">[25]</ref>.</p><p>Inspection of the firmware updater revealed that there were several Intel Hex (IHEX) files contained as Windows Resources within. With basic tools (Windows Resource Hacker <ref type="bibr" target="#b19">[20]</ref>), we were able to extract the IHEX files -which we found to be different versions of the G600 firmware as AVR binaries -modify them, and replace them within the updater to be delivered to the mouse which we will describe in more detail in Â§4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Analysis Process</head><p>We developed a workflow for analyzing the firmware with GCC tools. After extracting an IHEX file resource using Windows Resource Hacker <ref type="bibr" target="#b19">[20]</ref>, we converted the IHEX into an AVR binary file using avr-objcopy, then disassembled it for reverse-engineering using avr-objdump.</p><p>The manual was invaluable in understanding the sequence of steps necessary for reading from and writing to USB. We particularly benefited from the information it contained regarding various memory locations that are used for interacting with USB, EEPROM, and SPI. Identifying references to these locations allowed us to quickly pinpoint the leaf functions that dealt with the USB controller. Additionally, searching for the constants we saw in the PCAP (from Â§2.3) further helped us to locate functions responsible for sending USB HID codes.</p><p>We pair programmed heavily; it prevented many misunderstandings of the assembly. The merits of pair programming particularly shined each time we completed annotating a function and needed to articulate a higher level function name that captured the precise role of that function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Static Analysis</head><p>To better focus our reverse engineering efforts, we wrote a static analysis tool capable of recursively extracting the call chain. This tool leveraged a symbol table that we updated throughout the reversing process so that the call chain used the meaningful names that we gave to functions rather than their raw addresses when possible. This helped us better visualize the overall flow of functions, allowing us to more easily understand higher level patterns in the firmware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Hardware Debugging</head><p>We attempted to use microcontroller development hardware to aid us in the firmware analysis process. Tools like the AVR Dragon <ref type="bibr" target="#b1">[2]</ref> allow users to use JTAG to set hardware breakpoints and to re-flash the microcontroller. However, we were unable to use JTAG with the Logitech G600. The ATmega32u2's manual indicates that irreversibly disabling JTAG is possible by blowing a hardware fuse, so we conclude this was Logitech's course of action. This is one of many best practices for mitigating attacks on embedded devices.</p><p>In addition to supporting JTAG, the ATmega32u2 supports debugWIRE, a proprietary hardware debugger offered by Atmel. However, we lacked the proprietary tools necessary to take advantage of debugWIRE and did not pursue it further.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Firmware Update Process</head><p>In this section we will discuss the steps we took to modify the firmware updater as well as the process we developed for packaging malicious firmware and deploying it to the mouse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Modifying the Firmware Updater</head><p>On execution, the updater attempts to determine whether a G600 is connected to the computer. If a G600 is detected, it queries the G600 for its version of the firmware. If the version of the firmware running on the mouse is at least as recent as the version contained in the updater, the updater will inform the user that the mouse is up-to-date and exit. Otherwise, the user can initiate the firmware update process.</p><p>In order to guarantee that the modified firmware would reach the mouse, we used IDA Pro to examine the updater and identified the conditional branch which aborts the update process in the event of a failed version check. We patched the updater to make this branch an unconditional jump to the code path that initiates the firmware update.</p><p>Although Atmel offers a default firmware update protocol in the ATmega32u2 manual, Logitech elected to implement a custom protocol in their bootloader. Analysis of the bootloader section revealed that the mouse checks the firmware for corruption by calculating a CRC16-CCITT <ref type="bibr" target="#b35">[36]</ref> as part of this protocol. We note that although the CRC is at the end of the application segment, it is not at the actual end of the firmware since the application segment is followed by the bootloader.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Preparing a Firmware Update</head><p>Once we identified the function responsible for sending HID codes, we hijacked the control flow of that function to additionally call a custom function that we placed in an unused section of program memory. After this initial change, we developed the following four step workflow to flash the mouse:</p><p>1. Write the custom functions in a stand alone assembly file 2. Run a script to modify the firmware and prepare it as an IHEX file (a) Assemble our custom functions using avr-gcc </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Results</head><p>The current state of the attack is that a modified Logitech firmware update utility first transfers new, arbitrary firmware to the mouse. The malicious firmware then waits for its internal timer to trigger and then sends arbitrary HID key codes in order to open a shell on the target machine and execute malicious commands. Following convention, we run calc.exe. Below we have included an alternative malicious command 2 that could be run if the computer has Internet access.</p><p>&lt;WIN&gt; + R powershell.exe Start-BitsTransfer -source http://pwn.com/pwn.exe -destination .\pwn.exe .\pwn.exe exit If the target computer does not have Internet access, then the mouse needs to store and deliver the entire malware. To handle this scenario, we wrote a file transfer utility to copy a binary stored on the mouse to the host computer <ref type="bibr" target="#b2">3</ref> . As a proof of concept, we transfered a binary representation of the Fibonacci sequence from the mouse to the host computer.</p><p>The mouse has over 6.75 KB of available space in the application section to store a malicious binary; we could squeeze in a slightly larger binary by storing a zipped version on the mouse and unzipping it after we've transfered it to the host computer. Despite the increases in malware size over the past several years, there are still many pieces of malware that fit into our available space <ref type="bibr" target="#b23">[24]</ref>.</p><p>It is worth noting that this exploit can trivially be turned into a VM escape by first sending the host key. Additionally, we observe that it is somewhat common for consoles to briefly pop up on a user's screen in Windows, often during an update. We videotaped our exploit, and the entire process takes less than one third of a second and is indiscernible from a console-based update process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Other Triggers</head><p>There are several other options for triggering a firmware update including timers based off of user inactivity, communication with a adversary-controlled program on the target, and fingerprinting of the target.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Timers and Clandestine attacks</head><p>We have two 8 bit registers available to us to use a counter. So far, we have used that counter to count button presses so that we trigger the exploit every n button presses. This eases testing, but it is not subtle from a user's point of view. However, as mentioned above, the terminal only briefly flashes on the user's screen.</p><p>Instead of sending the exploit in response to user activity, it may be more subtle to respond to a period of user inactivity. We believe we can do this by modifying the main sleep loop, the code responsible for handling timer interrupts, and the code responsible for handling user-triggered interrupts such as mouse movement and button clicks. The counter would represent the length of time since the last user activity, and it would be reset to 0 every time the user triggers an interrupt. Every timer interrupt, we could increment the counter to give us a running tally of how long it has been since user activity. In the main sleep loop, we can check the counter and send the exploit if it has been sufficiently long. Although we have not actually implemented these enhancements, we have identified and annotated all of the relevant portions of the code.</p><p>If we need more than a 16 bit counter, it is possible to use the mouse's data space to store the current count. It was initially unclear what regions of memory were safe to overwrite due to the Harvard architecture of the mouse. However, during the reversing process we developed a fairly comprehensive view of the location in memory and purpose of the various global structs that store the mouse's state. If we were to avoid all such structs, trial and error might quickly reveal locations in data memory that we could reliably use.</p><p>In constructing any such timer, the adversary must wait long enough to ensure that the user is not looking while being careful to not wait so long as to let the target computer enter sleep mode or lock the screen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Communicating With The Malware</head><p>An alternative approach to trigger the mouse's payload would be some sort of communication with the host machine. If the mouse was flashed by the target user's machine, then we can assume that there is some attackercontrolled code running on the machine. Since USB is not a restricted resource, the malware can send messages to the mouse in order to inform the mouse that the malware is already present and that the mouse need not send the payload. If the malicious mouse does not hear from the malware in a sufficient period of time, it can then trigger the payload and reinfect the host machine with the malware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Making the Attack Targeted</head><p>It is conceivable that a USB device may in some way be able to fingerprint the host that it is connected to. A malicious USB device can report itself as various different devices, even a firewire-to-USB converter with direct memory access <ref type="bibr" target="#b4">[5]</ref>, opening various opportunities for gathering information about the host. If we can develop such a fingerprinting mechanism, we open up new avenues for targeted attacks. The malicious mouse can scan host devices for fingerprints until it determines that is connected to a target device and only then release its payload. This will allow us to infect the mouse on a less secure machine and avoid suspicion until we are connected to a target more secure machine. Alternatively, it would allow us to infect many mice but to only infect the specific hosts that we wished to target, decreasing the likelihood of detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Mitigations and Discussion</head><p>Logitech has taken responsible steps against the most trivial attacks. Disabling JTAG prevents attackers from gaining complete control over the mouse and bypassing intended update functionality in entirety. However, the firmware itself must be more carefully protected using digital signature verification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Mitigations</head><p>Ideally, the mouse should only accept a firmware update that is authored by Logitech. In order to guarantee this, the mouse must authenticate the author of the code via a digital signature. We implemented a digital signature to evaluate the space requirements that this would impose. To be clear, we are describing a digital signature on the firmware itself, verified by the mouse before being executed, not a signature on the updater.</p><p>Although the mouse has several kilobytes of free space available, the digital signature verification code must fit in the bootloader since the bootloader controls the firmware update process. The bootloader segment has a maximum size of 4 KB on the ATmega32u2, and the Logitech bootloader uses 3.3 KB of that space.</p><p>We implemented PKCS#1 v1.5 signing and RSA in C, using SPONGENT/256/256/128 as our underlying hash function <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b8">9]</ref>. We did so with a mind toward space efficiency and applied various compile-time flags to minimize the executable size. In total, the signature verification code took 1.5 KB: SPONGENT took 400 bytes and the rest of RSA and PKCS took 1100 bytes. Although this requires more space than is currently available in the Logitech bootloader, we do not view this as prohibitive in general on the ATmega32u2. Note that Balasch et al. were able to implement SPONGENT/256/256/128 using 12% less space with hand coded assembly <ref type="bibr" target="#b3">[4]</ref>, suggesting that there is room for compacting the code size even further.</p><p>However, this mitigation is not perfect. Due to the small amount of memory available, once a mouse has received illegitimate firmware, it has already overwritten its legitimate firmware with the unsafe version. This leads to the classic fail-open/fail-closed problem for the mouse, where the mouse must choose between running the untrusted firmware or completely ceasing to operate. In this case, ceasing to operate (failing closed) and waiting for a legitimate firmware update is probably the better choice, though it is still not ideal.</p><p>Exploitable vulnerabilities in the bootloader itself would allow the cryptographic verification to be bypassed, of course. We did not find any such vulnerabilities in our reverse engineering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Limitations and Severity</head><p>Thus far, we have treated the Logitech G600 as a case study, discussing how it could be used to sabotage target users or corporations. However, since the G600 is a gaming mouse, this drastically reduces the population our specific exploit can reasonably target. This does not reduce the strength of our attack in general, as these techniques can be applied broadly as demonstrated by Netragard <ref type="bibr" target="#b28">[29]</ref>. Nonetheless, the intended market for the mouse must be considered.</p><p>Competitive gaming and eSports have become increasingly popular over the past several years and the associated prize pools have grown accordingly. For example, the prize pool for the DOTA 2 international championships in July of 2014 was over $10 million <ref type="bibr" target="#b34">[35]</ref>. In general, such competitions are extremely concerned with cheating; players compete on airgapped systems that are constantly monitored for suspect behavior. Players are banned from bringing USB sticks (with configuration files, etc.) due to the fear that they will have exploits on the USB stick. However, players are allowed to bring their own mice, keyboards, and other peripherals since this is often an integral part of their performance. Our exploit makes it clear that even allowing players to bring their own peripherals opens the door for unfair play.</p><p>Another limitation of this style of exploit is that the reverse engineering process is laborious and often limited to a specific peripheral. Furthermore, there is great variation among mice in the general population. As such, this exploit is better suited for a targeted attack than mass exploitation. Such firmware update attacks are particularly viable at the individual or corporate level. The mice used within one company are often standardized, providing a high chance of success within a given company.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We have presented an end-to-end demonstration of malware hosting on an off-the-shelf mouse, the Logitech G600. We reverse-engineered the mouse firmware update process and showed how it could be subverted to install malware on the mouse. We showed how mousehosted malware could take advantage of the USB HID stack as an attack vector against the host. Contrary to the common belief that mice are benign, mice turn out to make an ideal vector for compromise of hardened or air-gapped computers.</p><p>We implemented cryptographic verification code required to prevent the mouse from loading illegitimate firmware in order to investigate the associated requirements. We conclude that signature verification code is not prohibitively large.</p><p>Cryptographic verification could be bypassed if there are exploitable vulnerabilities in the mouse bootloader itself, and an attacker with physical access to a mouse could modify its hardware or write malicious firmware directly to flash. Ultimately, host security against malicious mice must come down to distinguishing input (mouse movements and keystrokes) generated by the user from input faked by the mouse firmware, as proposed in DARPA's Active Authentication program <ref type="bibr" target="#b17">[18]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Firmware</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>(</head><label></label><figDesc>b) Copy the appropriate bytes from the compiled binary to an unused portion of the original firmware (c) Compute a CRC of our modified firmware and add it to the firmware (d) Use avr-objcopy to convert the elf to an IHEX file ready to be injected into the mouse updater 3. Inject our modified firmware into the mouse updater using a Windows resource extractor 4. Flash the mouse by running the modified mouse up- dater</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>The various signals involved in a firmware up-
date. All packets are 32 bytes in length. For sending the 
firmware data the two-th byte indicates which data packet 
out of 8 it is. The rest of the packet contains actual pro-
gram data. Bytes one and two of the Start Page and End 
Page signals contain the address the of page to write. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head></head><label></label><figDesc>for details. We gave the different packets semantic names based off of a series of "case statements" in the bootloader that switch off of various bytes of incoming USB packets. Our analysis of the firmware update function in the mouse firmware revealed five kinds of packets: Start Up- date, Start Page, Firmware Data, End Page, and End Up- date. A Start Update packet causes the bootloader to erase all pages of program memory that contain appli- cation code in preparation for receipt of a new firmware version. The actual data transfer occurs page by page, where transferring one page involves one Start Page packet, eight Firmware Data packets, and then an End Page packet. Once all of the pages have been transferred, the host sends an End Update packet.</figDesc><table></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>Keaton Mowery and David Kohlbrenner aided us in the modification of the x86 Logitech firmware updater. Samuel Chen, who has extensive background in microcontroller software development, kindly worked with us on trying to enable JTAG with his personal AVR hardware and software. Michael Walter provided an excellent translation of the article from c't. Stefan Savage had helpful comments and suggestions.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Notes</head><p>1 The c't article makes a remarkable claim which we have not seen followed up on. Their off-the-shelf mice, when imaging mouse pads with a particular design, would send commands to the host that would download and install a remote-access tool. Patterns in the mouse pad encode the download trigger and the IP address to contact. They had received the mouse pads several months earlier as a free conference give-away.</p><p>2 Start-BitsTransfer is the Powershell equivalent of wget. We note that the BitsTransfer utility may be used from cmd as well. <ref type="bibr" target="#b2">3</ref> We considered two options for writing the file transfer tool: copy con and Powershell. The copy con approach relies on using Alt codes while the Powershell approach would write the hex bytes into a Powershell byte array and then use set-content to write to file. We implemented the copy con approach and were disappointed to discover a flaw: 0x00 terminates the transfer. The Powershell approach is capable of writing all bit patterns.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<idno>ATmega8U2/16U2/32U2 Complete</idno>
	</analytic>
	<monogr>
		<title level="j">Atmel. Doc</title>
		<imprint>
			<biblScope unit="volume">7799</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">AVR Dragon Information Page</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Atmel</surname></persName>
		</author>
		<ptr target="http://www.atmel.com/tools/AVRDRAGON.aspx" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Bachfeld</surname></persName>
		</author>
		<ptr target="http://www.heise.de/ct/heft/2014-8-Computermaeuse-laden-Schaedlinge-aus-dem-Netz-nach-2156334.html" />
		<title level="m">Im Auge der Maus</title>
		<imprint>
			<date type="published" when="2014-03" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-05-21</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Compact Implementation and Performance Evaluation of Hash Functions in ATtiny Devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Josep</forename><surname>Balasch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">BariÂ¸sbariÂ¸s</forename><surname>Ege</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benoit</forename><surname>GÃ©rard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zheng</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>GÃ¼neysu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Heyse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">StÃ©phanie</forename><surname>Kerckhof</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">FranÃ§ois</forename><surname>Koeune</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Plos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Smart Card Research and Advanced Applications</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="158" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Klein. FireWire: all your memory are belong to us</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Michael &amp;quot;becher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dornseif</surname></persName>
		</author>
		<ptr target="http://cansecwest.com/core05/2005-firewire-cansecwest.pdf" />
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-03-12</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Secure software updates: Disappointments and new challenges</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anthony</forename><surname>Bellissimo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Burgess</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of HotSec&apos;06</title>
		<meeting>HotSec&apos;06</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="37" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">A Real Malware In A Mouse</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Benchoff</surname></persName>
		</author>
		<ptr target="http://hackaday.com/2014/03/31/a-real-malware-in-a-mouse/" />
		<imprint>
			<date type="published" when="2014-03" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-05-21</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Benchoff</surname></persName>
		</author>
		<ptr target="http://hackaday.com/2014/03/30/malware-in-a-mouse/" />
		<title level="m">Malware In A Mouse</title>
		<imprint>
			<date type="published" when="2014-03" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-05-21</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">SPONGENT: A Lightweight Hash Function</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrey</forename><surname>Bogdanov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miroslav</forename><surname>KneÅ¾eviÂ´ckneÅ¾eviÂ´c</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregor</forename><surname>Leander</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deniz</forename><surname>Toz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kerem</forename><surname>VarÄ±cÄ±</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ingrid</forename><surname>Verbauwhede</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptographic Hardware and Embedded Systems-CHES 2011</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="312" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">US agency baffled by modern technology, destroys mice to get rid of viruses</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Bright</surname></persName>
		</author>
		<ptr target="http://arstechnica.com/information-technology/2013/07/us-agency-baffled-by-modern-technology-destroys-mice-to-get-rid-of-viruses/" />
		<imprint>
			<date type="published" when="2013-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">iSeeYou: Disabling the MacBook webcam indicator LED</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Brocker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Checkoway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of USENIX Security 2014. USENIX</title>
		<editor>Kevin Fu</editor>
		<meeting>USENIX Security 2014. USENIX</meeting>
		<imprint>
			<date type="published" when="2012-08" />
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Reversing and Exploiting an Apple Firmware Update</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Black Hat</title>
		<meeting>Black Hat</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Federal agency spent $3 million fighting non-existent malware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stacy</forename><surname>Cowley</surname></persName>
		</author>
		<ptr target="http://money.cnn.com/2013/07/09/technology/security/commerce-malware" />
		<imprint>
			<date type="published" when="2013-07" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-03-13</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Plug and prey: Malicious USB devices. Presented at Shmoocon</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adrian</forename><surname>Crenshaw</surname></persName>
		</author>
		<ptr target="http://www.irongeek.com/downloads/Malicious%20USB%20Devices.pdf" />
		<imprint>
			<date type="published" when="2011-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">When firmware modifications attack: A case study of embedded exploitation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ang</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Costello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Stolfo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of NDSS Symposium</title>
		<meeting>NDSS Symposium</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">&amp;quot;</forename><surname>Jeroen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sprite_Tm</surname></persName>
		</author>
		<ptr target="http://spritesmods.com/?art=mouseeye" />
	</analytic>
	<monogr>
		<title level="j">Domburg. Optical Mouse Cam</title>
		<imprint>
			<date type="published" when="2006-12" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-05-21</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Hacking with Hardware: Introducing the Universal RF USB Keyboard Emulation Device: URFUKED. In Defcon 18</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Elkins</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Security: Active authentication. IT Professional</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><forename type="middle">P</forename><surname>Guidorizzi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-08" />
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="4" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Indyaner</surname></persName>
		</author>
		<ptr target="https://imgur.com/a/uOhyn" />
		<imprint>
			<date type="published" when="2014-03" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-05-21</note>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Angus</forename><forename type="middle">Johnson Resource</forename><surname>Hacker</surname></persName>
		</author>
		<ptr target="http://www.angusj.com/resourcehacker/" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">PKCS #7: Cryptographic Message Syntax Version 1</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kaliski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Convert Optical Mouse into Arduino Web Camera</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Franci</forename><surname>Kapel</surname></persName>
		</author>
		<ptr target="http://frenki.net/2013/12/convert-optical-mouse-into-arduino-web-camera/" />
		<imprint>
			<date type="published" when="2013-12" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-05-21</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">US Commerce Department destroyed $170,000 worth of TVs, mice, and more to root out malware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><surname>Kastrenakes</surname></persName>
		</author>
		<ptr target="http://www.theverge.com/2013/7/8/4503946/commerce-department-unnecessary-cybersecurity-computer-destruction" />
		<imprint>
			<date type="published" when="2013-07" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-03-13</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">You Dirty RAT! Part 1 -DarkComet</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Kujawa</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Logitech G600 Support and Downloads Website</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Logitech</surname></persName>
		</author>
		<ptr target="http://www.logitech.com/en-us/support/g600-mmo-gaming-mouse" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-03-10</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Battery firmware hacking: Inside the innards of a smart battery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charlie</forename><surname>Miller</surname></persName>
		</author>
		<ptr target="https://media.blackhat.com/bh-us-11/Miller/BH_US_11_Miller_Battery_Firmware_Public_WP.pdf" />
		<imprint>
			<date type="published" when="2011-08" />
		</imprint>
	</monogr>
	<note>Presented at BlackHat</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomasz</forename><surname>MoÂ´nmoÂ´n</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Usbpcap</surname></persName>
		</author>
		<ptr target="http://desowin.org/usbpcap/,Unknown" />
		<imprint/>
	</monogr>
	<note>Online; accessed 2014-03-10</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">418 I&apos;m a teapot: Programmable HID USB Keystroke Dongles (PHUKD)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lawrence</forename><surname>Munro</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Netragard&apos;s Hacker Interface Device (HID)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Netragard</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Rushing. USB-HID Hacker Interface Design. Presented at Black Hat</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul&amp;quot; &amp;quot;</forename><surname>Pisani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Carugati</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Dropped USB Sticks in Parking Lot as Actual Attack Vector</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruce</forename><surname>Schneier</surname></persName>
		</author>
		<ptr target="https://www.schneier.com/blog/archives/2012/07/dropped_usb_sti.html" />
		<imprint>
			<date type="published" when="2012-07" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-03-12</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
				<ptr target="http://www.usb.org/developers/hidpage/,Unknown" />
		<title level="m">USB.org sponsored by USB Implementers Forum Inc. USB HID Information</title>
		<imprint/>
	</monogr>
	<note>Online; accessed 2014-03-10</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Symantec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Trojan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mebroot</surname></persName>
		</author>
		<ptr target="http://www.symantec.com/security_response/writeup.jsp?docid=2008-010718-3448-99" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-03-10</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Economic development administration: Malware infections on EDA&apos;s systems were overstated and the disruption of IT operations was unwarranted</title>
		<idno>No. OIG-13-027-A. Online</idno>
		<ptr target="http://www.oig.doc.gov/OIGPublications/OIG-13-027-A.pdf" />
		<imprint>
			<date type="published" when="2013-06" />
		</imprint>
	</monogr>
<note type="report_type">Final Report</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">The International -DOTA 2 Championships</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Valve</surname></persName>
		</author>
		<ptr target="http://www.dota2.com/international/compendium/" />
		<imprint>
			<date type="published" when="2014-05" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-05-26</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ross</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Paper On Crcs</surname></persName>
		</author>
		<ptr target="http://www.ross.net/crc/crcpaper.html" />
		<imprint>
			<date type="published" when="1993-08" />
		</imprint>
	</monogr>
	<note>Online; accessed 2014-03-12</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
