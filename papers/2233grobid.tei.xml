<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:32+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Effective Entropy: Security-Centric Metric for Memory Randomization Techniques</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Herlands</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">MIT Lincoln Laboratory</orgName>
								<orgName type="laboratory" key="lab2">MIT Lincoln Laboratory</orgName>
								<orgName type="laboratory" key="lab3">MIT Lincoln Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Hobson</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">MIT Lincoln Laboratory</orgName>
								<orgName type="laboratory" key="lab2">MIT Lincoln Laboratory</orgName>
								<orgName type="laboratory" key="lab3">MIT Lincoln Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paula</forename><forename type="middle">J</forename><surname>Donovan</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">MIT Lincoln Laboratory</orgName>
								<orgName type="laboratory" key="lab2">MIT Lincoln Laboratory</orgName>
								<orgName type="laboratory" key="lab3">MIT Lincoln Laboratory</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Effective Entropy: Security-Centric Metric for Memory Randomization Techniques</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>User space memory randomization techniques are an emerging field of cyber defensive technology which attempts to protect computing systems by randomizing the layout of memory. Quantitative metrics are needed to evaluate their effectiveness at securing systems against modern adversaries and to compare between randomiza-tion technologies. We introduce Effective Entropy, a measure of entropy in user space memory which quantitatively considers an adversary&apos;s ability to leverage low entropy regions of memory via absolute and dynamic intersection connections. Effective Entropy is indicative of adversary workload and enables comparison between different randomization techniques. Using Effective Entropy, we present a comparison of static Address Space Layout Ran-domization (ASLR), Position Independent Executable (PIE) ASLR, and a theoretical fine grain randomization technique.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Memory based exploits take advantage of software vulnerabilities, allowing an adversary to hijack control flow of a process and execute arbitrary code. While advancements in security techniques have eliminated the simplest forms of code injection attacks <ref type="bibr" target="#b21">[22]</ref>, more sophisticated attacks continue to defeat modern security systems. Contemporary adversaries boast a substantial repertoire of techniques to overcome security features including heap spraying <ref type="bibr" target="#b7">[8]</ref>, integer overflow <ref type="bibr" target="#b22">[23]</ref>, and return oriented programming <ref type="bibr" target="#b17">[18]</ref> [5] (ROP), a generalization of the earlier return to libc schemes <ref type="bibr" target="#b24">[25]</ref>.</p><p>User space memory randomization is an active sector of security research which attempts to protect a computing system by randomizing its memory layout. These techniques are premised on the assumption that adversaries often require precise knowledge of the location of sections, functions, and instructions in memory. Therefore, randomizing the locations of these elements will increase the difficulty to exploit a system. Yet these techniques lack quantitative metrics to evaluate their effectiveness in protecting memory against contemporary attacks and how they affect adversary workload. In this paper we introduce Effective Entropy (EffH), a novel metric to quantifiably assess the security of memory randomization technologies based on specific threat models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>In response to the proliferation of memory-based exploits, researchers have developed a litany of security protections for user space memory. Two widely implemented techniques include concealed memory address values called stack canaries, which detect code injection attacks <ref type="bibr" target="#b5">[6]</ref>  <ref type="bibr" target="#b8">[9]</ref>, and Wñ®½™X, which prevents memory pages from being simultaneously writable and executable.</p><p>Recent literature has highlighted user space memory randomization schemes. Address Space Layout Randomization (ASLR) is the most commonly deployed randomization technology. Versions of ASLR are standard in the most recent versions of Mac OS X, Windows, Linux, and FreeBSD as well as a number of smartphone operating systems. For example, under standard conditions in Linux ASLR implementations, the kernel facilitates load time randomization of an arbitrary process's virtual memory. Specifically, the base address of the stack, heap, virtual dynamically linked shared objects (VDSO), and memory mapped (mmap) sections are each randomized, though with different amounts of entropy <ref type="bibr" target="#b3">[4]</ref>. In contrast, Position Independent Executable (PIE) ASLR additionally randomizes the base address of the program image (including the Text, Read-Only Data, and Read-Write Data sections) as a single block by appending the program image to the randomized mmap section. In Linux distributions static (non-PIE) ASLR is standard and a program can be specifically compiled with a PIE option. However, PIE is standard in recent OpenBSD distributions <ref type="bibr" target="#b6">[7]</ref> which is indicative of a trend towards more hardened memory space security in commodity operating systems.</p><p>Research on fortifying memory randomization has generated a variety of proposals which focus on all sections of user space memory. While many of these security enhancements combine a number of elements, they mainly focus on either base address or fine-grain randomization security techniques. For example, proposals such as Address Space Layout Permutation <ref type="bibr" target="#b13">[14]</ref> increase the magnitude of entropy for the base addresses above contemporary ASLR implementations. In order to achieve greater randomization, these techniques leverage the fact that the size of memory for a process is small with respect to the size of memory potentially available to the user. Alternatively, fine-grain randomization technologies such as Binary Stirring <ref type="bibr" target="#b23">[24]</ref>, which provides randomization to the Text section, attempt to increase the granularity of randomization to resolutions smaller than memory sections. Similarly, Multicompiler <ref type="bibr" target="#b11">[12]</ref>, which also provides randomization within the Text section, randomly adds NOPs between blocks of code. In addition to base and fine-grain randomization, a number of proposals attempt to dynamically re-randomize sections in memory during the execution of the program. For example, the Minix Kernel enables dynamic randomization of base addresses in operating system processes <ref type="bibr" target="#b9">[10]</ref> and Instruction Location Randomization has the capability for dynamic fine grain randomization in the Text section <ref type="bibr" target="#b10">[11]</ref>.</p><p>Each of these techniques has specific requirements for the source code or binaries it requires in order to operate properly. For the purposes of this paper, we are not concerned with these specifications, although widespread adoption of any system certainly favors the most generally applicable technology. Throughout this paper, unless otherwise noted, we focus on Ubuntu 12.04 machines and its static ASLR and PIE ASLR implementations.</p><p>Other security randomization proposals, such as Instruction Set Randomization <ref type="bibr" target="#b12">[13]</ref>, In Place Code Randomization <ref type="bibr" target="#b14">[15]</ref>, and Data Space Randomization <ref type="bibr" target="#b0">[1]</ref> also propose protecting a computer system by obfuscating aspects of a process' memory from the attacker. However, these schemes do not randomize the layout of memory and thus fall outside the scope of our evaluation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Threat Models</head><p>As formalized in Section 5, EffH is dependent on the specifics of the threat model of an adversary. This specificity enables EffH to provide an accurate assessment of the security impact of a memory randomization technology. Below we describe two adversarial threat models over which we will evaluate security techniques: the Advanced Adversary and the Memory Disclosure Adversary. These threats are commensurate with the skill and versatility of modern adversaries who are able to leverage multiple vulnerabilities to launch successful attacks.</p><p>The Advanced Adversary is a sophisticated adversary who desires to execute arbitrary code on a target machine and has knowledge of a zero day vulnerability in an arbitrary program. Additionally, the adversary has access to a binary identical to the one being run on the target machine. The vulnerability allows the adversary to write to a writable section of memory in an attempt to take control of the instruction pointer. In order to isolate the effects of memory randomization, we assume the adversary can circumvent all other security features (with the notable exception of Wñ®½™X protection) without learning anything which would affect the entropy of memory.</p><p>The Memory Disclosure Adversary is similar to the Advanced Adversary but also has partial knowledge of the layout of memory obtained through an information disclosure attack. Such attacks force the machine to disclose an obfuscated address or permit the adversary to read a controlled area in memory, and are a common means of reducing the entropy in an arbitrary section of memory <ref type="bibr" target="#b16">[17]</ref>. A complete consideration of the difficulty of using an information disclosure to reduce entropy is beyond the scope of this paper. Rather, we consider a simple but practical Memory Disclosure Adversary that can disclose the location of one section of memory in its entirety. A lack of intra-section randomization in today's systems makes this type of disclosure practical; objects have fixed relative positions and an adversary that discloses one address in a section has effectively disclosed the location of every other object in that section. Under this adversarial model we evaluate randomization techniques in terms of the effect that a complete disclosure of one section has on the other sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Security Metrics</head><p>Two of the most commonly used metrics for evaluating memory randomization techniques (a) measure the entropy introduced into a system and (b) test systems against known exploits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Entropy</head><p>Entropy, H, defined in equation 1, is a quantitative and information theoretic measurement which measures the unpredictability of a random variable, X, over its possible states, x i 2 X. Measuring the individual entropy of each section in memory is fairly straightforward. Additionally, measures of entropy are easily compared between memory sections and randomization technologies. Given the ease of measurement and objectivity of results, this is the standard means by which memory randomization techniques are currently evaluated.</p><formula xml:id="formula_0">H(X) = ñ®½™ n Ã‚ i=1 p(x i ) log p(x i )<label>(1)</label></formula><p>Utilizing the entropy provided to each section as a measure of security assumes that greater entropy correlates with great difficulty on behalf of the adversary attempting exploit a system. Yet this assumption does not hold under the modern adversary threat models discussed in Section 3. These adversaries are able to launch attacks which circumvent the entropy of various memory sections, potentially rendering even high entropy useless. Indeed, two of the most significant papers on evaluating memory randomization security demonstrated that using specially crafted memory attacks, they could avoid the entropy in static ASLR <ref type="bibr" target="#b18">[19]</ref> and a fine grain ASLR implementation <ref type="bibr" target="#b19">[20]</ref>. Their evaluations demonstrated fundamental weaknesses in the presumed relationship between entropy and security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Exploits</head><p>Since randomization techniques attempt to prevent adversaries from exploiting a process running on a target machine, it seems intuitive to measure the security by directly testing the technology against potential attacks. More specifically, launching a set of known exploits against an unprotected system and against a system protected by the randomization technology would demonstrate which attacks were prevented by the additional security. Furthermore, specially crafted attacks can demonstrate weaknesses within a security system and perhaps challenge some of the underlying assumptions of that technology.</p><p>However, analysis of individual exploits is fundamentally limited in the information it can provide about a security system since exploits do not provide a quantitative assessment of computing system. Additionally, it is difficult to compare different exploits, or make comparisons between heterogeneous security systems using the same exploits. Finally, since exploits are developed to take advantage of specific nuances of a system, trivial changes in a system (such as dynamically switching between endianness) can break specific implementations of current exploits without fundamentally increasing security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">New Metrics</head><p>In order to properly evaluate the security offered by diverse memory randomization technologies, metrics must be developed which can quantifiably access a large set of randomization schemes. Learning from the advantages and drawback of using entropy and exploits as metrics, we can identify some necessary qualities in evaluations: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Effective Entropy</head><p>EffH attempts to provide meaningful measurements of effectiveness by combining the quantitative rigor of entropy with domain knowledge regarding the capabilities of modern adversaries. Specifically, EffH considers an attacker's capability to circumvent entropy in memory by leveraging interconnections within memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Memory Connections</head><p>Although memory is divided into a number of sections, these individual sections interact with each other throughout the lifetime of a process. Interconnections between sections in user space memory can either be absolute or dynamic. Absolute connections exist throughout the execution of a program regardless of the state of the process. Dynamic connections form and break over the course of a program's execution and exist only during certain states of a process. <ref type="table" target="#tab_0">Table 1</ref> shows examples of the connections in memory.</p><p>Absolute connections include connections formed by jump and call instructions which move the instruction pointer to a fixed address as well as pointers located in read-only memory. Dynamic connections are formed by the values of registers and writable pointers at every moment where an attacker could gain control of the program's execution.</p><p>These register and pointer values could be used by attackers leveraging gadgets with indirect branch instructions. Given the computational power of even relatively few gadgets <ref type="bibr" target="#b15">[16]</ref> we assume that any executable section has the necessary instructions to leverage the values in registers. Similarly, attackers can leverage pointers in memory, though the attackers may have to overcome additional entropy, as discussed below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Definition</head><p>The importance of memory connections can be understood through a simple example. Consider a static ASLR protected system, where every instruction in the program image connects to an address in the mmap. Although the mmap is randomized <ref type="bibr">with</ref>  image and mmap to reach every address in the mmap with impunity. Thus, the mmap effectively has zero bits of entropy. Furthermore since only the base address of the mmap is randomized, a single connection between the program image and mmap is sufficient for an adversary to know the location of all addresses in the mmap with zero bits of entropy. This entropy reduction technique is not novel, and is routinely employed in attacks against static ASLR <ref type="bibr" target="#b20">[21]</ref>. EffH measures the effective magnitude of entropy in each memory section that an adversary must directly confront and cannot circumvent by taking advantage of intermemory connections. Since the ability for an adversary to leverage inter-memory connections is dependent on their threat model, EffH models must be constructed to specifically address each threat model. Equation 2 defines EffH of each section, s, for both the Advanced Adversary and Memory Disclosure Adversary threat models. Connections from executable sections reduce the initial entropy of the target section, h s , to the minimum entropy of any executable section with a connecting instruction, min(H x conn ) if min(H x conn ) &lt; h s . In order to leverage pointers in writable or RO memory these adversaries must use gadgets from an executable section, as discussed above. Therefore connections from pointers reduce EffH s to the sum of the minimum entropy of any section with a connecting pointer, min(H p conn ), and the minimum entropy of all executable sections min(H x ).</p><formula xml:id="formula_1">EffH s = min 8 &lt; : h s min(H x conn ) min(H p conn ) + min(H x )<label>(2)</label></formula><p>H p conn = {h p j : 9connection( j, s)} H x conn = {h x j : 9connection( j, s)} EffH better addresses realistic threat models than standard entropy because EffH accounts for the ability of an attacker to use connections to circumvent the entropy of various sections. Faced with uncertainty about the location of a section in memory an attacker may (a) repeatedly probe the process to probabilistically reduce entropy (b) obtain a memory disclosure to eliminate entropy (c) accept a lower rate of success inversely proportional to the EffH of the desired section. Since all of these options require more effort on behalf of the attacker or reduce the chance of a system being exploited, EffH measures the increased adversary workload.</p><p>Considering the necessary characteristics for robust metrics defined in Section 4, the values of EffH for each memory section are both quantitative and readily comparable between different systems. Additionally, EffH is not dependent on a particular threat model. Finally, EffH is indicative of difficulty faced by an adversary because EffH represents the true randomness that an adversary confronts in memory.</p><p>Consider the example shown in <ref type="figure">Figure 1</ref> of a static (non-PIE) 64-bit Linux ASLR implementation that randomizes the Stack section with 22 bits of entropy, Memory Maps (mmap) with 28 bits, and the Heap with 13 bits. The Program Image itself is not randomized (0 bits of entropy). We assume that an Advanced Adversary is able to exploit a stack buffer overflow to write arbitrary values to the stack, including overwriting the return address.</p><p>An attacker wishing to call the exec() function might attempt to directly guess the address of exec() by overwriting the return address with a guessed address. However, the attacker would confront the full 28 bits of entropy of the mmap section. A more fruitful approach would be to leverage the existing exec ptr in the heap, which points to the exec() function. The attacker cannot directly overwrite the return address with a guess of the location of exec ptr due to the layer of indirection associated with using a pointer stored on the heap. To use exec ptr indirectly the attacker may use gadgets in any sufficiently large executable section. In this case the attacker chooses a gadget from the Program Image, as it is not randomized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Example</head><p>The attack unfolds as follows. The attacker overwrites the return address on the stack with the address of the gadget in the Program Image (1). The attacker also overwrites the next value on the stack with a guess for the address of exec ptr (2). When the program returns, the invoked gadget in the Program Image will pop the attacker's guess of exec ptr off the stack and jump to the value contained at that address. If the attacker's guess of exec ptr is successful, control flow will be redirected to the exec() function (3).</p><p>To </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Methodology</head><p>In order to measure EffH for a particular randomization technology, we empirically calculated the entropy of all memory sections by running a sample program ten million times and sampling the base address of every randomized section during each run.</p><p>To determine the absolute connections static analysis was used on sample programs to identify all the intended and unintended fixed control instruction connections and pointers in non-writable sections of memory.</p><p>To determine the dynamic connections in the sample programs we used an algorithmic approach similar in concept to conservative garbage collectors <ref type="bibr" target="#b2">[3]</ref>. All indirect branch instructions which use pointers in writable memory (such as jmp *&lt;W address&gt;) were identified. The sample programs were each run twice through identical, deterministic execution paths. During those runs the memory of the process was examined at each point where an adversary could take control of the program (i.e. at every control transfer instruction). At those instances, we stored the values of registers as well as intended and unintended pointers in writable memory. In this manner we identified every potential dynamic connection formed during each run. In our evaluation we assumed that under both the Advanced and Memory Disclosure Adversary models that dynamic connections existing at any control transfer instruction could be used by the adversaries during the actual control transfer instruction that is used to hijack control flow.</p><p>A potential dynamic connection is any value in a register or writable memory which evaluates to an address allocated in user memory space. Since memory sections are randomized for each run, false dynamic connections can be registered if a connection target value happens to equal that of valid user space memory. For example, an int value in writable memory could be incorrectly identified as a pointer. In the post-processing step, false connections were eliminated by taking the intersecting set of dynamic connections from the two independent runs on each program, each of which were executed on independently randomized systems.</p><p>The rate of false connections was quite low, usually around 1.5% of potential dynamic connections were false. Since under normal conditions, user space memory on Linux 32-bit systems begins at memory address 0x8048000, it is reasonable that very few false connections are formed by accidental values in writable memory. While these algorithms do not directly account for false connections to sections in memory with no entropy, these false connections do not affect EffH since they terminate in sections with already minimal entropy.</p><p>In Section 7 we discuss measurements of ROP gadgets and system calls in executable sections. We determined the number of ROP gadgets by statically counting all series of instructions ending with a control flow instruction. We used an every munch algorithm with a maximal instruction length of 5 <ref type="bibr" target="#b15">[16]</ref> and considered both intended and unintended gadgets <ref type="bibr" target="#b1">[2]</ref>. We searched for system calls by similarly evaluating instructions beginning at every address in executable memory.</p><p>Although EffH is measured on a per-program level, the metric itself is a function of a randomization technology and a threat model. Our ability to generalize the results of per-program measurements requires two assumptions regarding program execution flow and memory connections.</p><p>1. Any sufficiently large program is assumed to have relevantly similar sets of connections between memory sections. An example of insufficiently large program is one which does not utilize a section in memory, such as the heap, or one with a degenerately small number of instructions. 2. Any non-degenerate execution path in a sufficiently large program uses a set of dynamic connections which is drawn from the same distribution as any other non-degenerate execution path. Thus we do not require an exhaustive search traversing every potential execution in order to ascertain the dynamic connections formed by a program. Rather we traverse only a single execution path in each program.</p><p>These assumptions are reasonable because in a given computing environment memory sections are connected in standard ways. For example, on many systems pointers to executable code and readable data are pushed onto the stack while function addresses are written to the Global Object <ref type="table">Table.</ref> Reasonably long execution paths utilize a variety of library functions, executable instructions, and program data that should be representative of the computing system more generally. Our empirical testing corroborates these assumptions since we find no variation in EffH measurements between measured programs under static and PIE ASLR protection (see Section 7).</p><p>We also assume that the permissions of sections in memory do not dynamically change during the runtime of a process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Evaluation Results</head><p>Empirical tests of static ASLR on 32-bit Linux machines demonstrate that the stack is randomized with 19 bits of entropy, heap with 13 bits, mmap with 8 bits, and VDSO with 8 bits. Specifically, the stack's entropy incorporates kernel-level ASLR applied at the page level for security purposes, and a secondary minor randomization applied in an attempt to avoid L1 cache evictions in certain circumstances. This additional process randomizes the most Running a program with the ADDR NO RANDOMIZE flag disables both randomization processes and they cannot be otherwise individually disabled. Thus we do not distinguish between these two randomizations processes since an adversary will encounter both identically in the stack. <ref type="figure">Figure 2</ref> shows entropy and EffH for all sections in memory in both static and PIE ASLR under the Advanced Adversary threat model. All of the programs we measured provided the same results for static and PIE scenarios respectively. These similarity of results is not surprising since in both static and PIE ASLR the program image has connections to every other section in memory. In static ASLR the program image's zero bits of entropy implies that all other sections have zero bits of EffH. In contrast, in PIE ASLR all sections are reduced to a maximum of 8 bits of EffH.</p><p>To simulate the effects of a Memory Disclosure Adversary, we consider the case where a pointer to the program image was pushed onto the stack and then maliciously forced to be printed out. The adversary is expected to know the location of the program image with certainty. While the EffH of static ASLR remains constant since the location of the program image was never randomized this disclosure allows the adversary to reduce the EffH of PIE ASLR as shown in <ref type="figure">Figure 3</ref>. In PIE, the program image is connected to the mmap, so knowledge of the program image's base address implies knowledge of the mmap's location. Thus, the mmap section has zero bits of entropy since even without any connection from the program image to the mmap section, an adversary can know its location with certainty. The remaining sections, which have connections originating from the program image, have zero bits of EffH. Fine grain randomization attempts to increase the granularity of memory randomization. In addition to increasing the entropy of memory, these techniques attempt to reduce the utility of an arbitrary memory disclosure. They assume that as more sections are independently randomized, a memory disclosure will provide less information about the layout of memory and limit the adversary's resources such as the location of ROP gadgets and system calls needed to construct effective exploits <ref type="bibr" target="#b16">[17]</ref>.</p><p>While no commodity fine grain randomization system exists, we simulated the effects of fine grain randomization in the mmap section by assuming that every library is independently randomized with 8 bits of entropy. We refer to this randomization as independent library randomization. Using the previously identified connections we calculated the theoretical EffH of independent library randomization in static ASLR under the Memory Disclosure Adversary. <ref type="figure" target="#fig_2">Figure 4</ref> shows typical results of this simulation run on the vim text editor program. Note that a number of individual libraries retain 8 bits of EffH though most have zero bits of EffH.</p><p>If we consider only the executable libraries from the vim example and measure the ROP gadgets available in those sections (see <ref type="figure">Figure 5</ref>) we see that adversaries still have thousands of ROP gadgets to use in the sections with zero bits of EffH. Note that the section without entropy is the program image. Similarly <ref type="figure">Figure 6</ref> shows that most of the sections with system calls still have zero bits of EffH. The independent library randomization fails to prevent adversaries from acquiring knowledge of essential attack elements.</p><p>The results from our evaluations suggest that for most sections in a program EffH is reduced to match the section with the minimum entropy. Designers of randomization techniques should consider first focusing on raising the minimum entropy across all sections rather than achieving a higher average entropy or maximizing the entropy of critical sections. A critical section with high entropy often proves to be easily reachable due to connections from the ostensibly less important, lower entropy sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We introduced Effective Entropy, a new metric to quantifiably assess the security provided by memory randomization techniques. This metric combines the mathematical rigor of traditional entropy measurements with the realistic threat models of sophisticated adversaries by considering connections within memory. EffH provides insight into memory randomization technologies. Buttressed by previous studies, our analysis demonstrates fundamental weaknesses in static ASLR, PIE ASLR, and fine-grain independent library randomization schemes. These analyses illustrated how EffH can be used to simulate the effects of a memory randomization scheme before development and expose potential attack vectors.</p><p>While EffH demonstrates the difficulty to reach certain areas of memory, it does not measure the utility of those memory sections to an attacker. Additionally, quantifying the marginal increase in adversary workload with respect to EffH, or another metric, remains an open research question. Little empirical data exists regarding adversary workload and it is difficult to construct high fidelity models.</p><p>Future work could evaluate more memory randomization schemes with EffH including those which dynamically re-randomize layout during runtime. Additionally more adversarial models such as those involving just-intime compilation could be considered in order to expand current understanding of the effects of such techniques. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™</head><label></label><figDesc>Figure 2: Advanced Adversary threat model. Entropy and EffH results shown for systems protected by static ASLR and PIE ASLR. Note that EffH is 0 for all sections in static ASLR</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™ ñ®½™</head><label></label><figDesc>Figure 3: Memory Disclosure Adversary threat model. Entropy and EffH results shown for systems protected by static ASLR and PIE ASLR. Note that EffH is 0 for all sections</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Entropy and EffH measurements of memory sections in systems protected by independent library randomization. Each library section is plotted towards the right side of the x-axis while the program image, stack, heap, and VDSO sections are plotted towards the left. Results shown for the Memory Disclosure Adversary threat model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :Figure 6 :</head><label>56</label><figDesc>Figure 5: The number of ROP gadgets, bits of entropy, and bits of EffH for each executable library in a system protected by independent library randomization. Results shown for the Memory Disclosure Adversary threat model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>1 .</head><label>1</label><figDesc></figDesc><table>Quantitative, not anecdotal 

2. Comparable between existing security systems and 
future technologies 

3. Objective, unbiased towards specific exploits 

4. Predictive of adversary workload 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head></head><label></label><figDesc>8 bits of entropy, ASLR does not provide the program image with any entropy. An adversary can use the connections between the program</figDesc><table>Absolute 

Dynamic 

jmp 0x8057420 
jmp *0xBF04084 
jmp %ebx 
Read-only pointer 
Writable pointer 

Table 1: Examples of absolute and dynamic connections in user 
space memory. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head></head><label></label><figDesc>calculate EffH mmap we use Equation 2. The first component of Equation 2, h s , is simply the entropy of the mmap section, thus h mmap = 28. The next compo- nent, min(H x conn ), calculates the entropy of any absolute references from executable sections to the mmap sec- tion; for this example we assume there are none.</figDesc><table>Fi-
nally, we must calculate min(H p 
conn ) + min(H x ), the mini-
mum entropy of any sections containing pointers to the Stack (22 bits) 

&amp;exec_ptr guess A 
ret addr A 

Heap (13 bits) 

exec_ptr 

Memory Maps (28 
bits) 

exec() 

Program image 
(0 bits) 

pop %ecx 
jmp *%ecx 

%esp 

? 

1 

2 

3 

Figure 1: EffH of Memory Maps reduced to 13 bits due to 
pointer from Heap (13 bits) that may be accessed via gadgets in 
the Program Image (0 bits). 'A' denotes attacker supplied values 

mmap section (i.e. the Heap) plus the minimum entropy 
of any sections containing executable code (i.e. the Pro-
gram Image), which contain gadgets that allow us to use 
the pointer on the heap. In this example, min(H p 
conn ) + 
min(H x ) = min(h heap ) + min(h program image ) = 13 + 0. 
Thus, EffH mmap = min(28, 13) = 13. 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The authors would like to thank David Bigelow and Hamed Okhravi for their work on empirical measures of entropy. This work is sponsored by Assistant Secretary of Defense for Research &amp; Engineering under Air Force Contract FA8721-05-C-0002. Opinions, interpretations, conclusions and recommendations are those of the author and are not necessarily endorsed by the United States Government.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Data space randomization. DIMVA &apos;08</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bhatkar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sekar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="page" from="1" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Jumporiented programming: a new class of code-reuse attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bletsch</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Freeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">W</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASI-ACCS &apos;11, ACM</title>
		<imprint>
			<biblScope unit="page" from="30" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boehm</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-J</forename></persName>
		</author>
		<title level="m">Space efficient conservative garbage collection. PLDI &apos;93, ACM</title>
		<imprint>
			<biblScope unit="page" from="197" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Ubuntu security features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Canonical</forename><surname>Ltd</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Return-oriented programming without returns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Checkoway</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Dmitrienko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-R</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Winandy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS &apos;10, ACM</title>
		<imprint>
			<biblScope unit="page" from="559" to="572" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Stackguard: Automatic adaptive detection and prevention of buffer-overflow attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cowan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Walpole</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bakke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Beattie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Grier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wagle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">T</forename><surname>Al</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">81</biblScope>
			<biblScope unit="page" from="346" to="355" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">The OpenBSD 5.3 release</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>De Raadt</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Heap taichi: exploiting memory allocation granularity in heap-spraying attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ding</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACSAC &apos;10, ACM</title>
		<imprint>
			<biblScope unit="page" from="327" to="336" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Propolice: Improved stacksmashing attack detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Etoh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoda</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IPSJ SIG Notes</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="181" to="188" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Enhanced operating system security through efficient and finegrained address space randomization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giuffrida</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kuijsten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tanenbaum</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security &apos;12</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Ilr: Where&apos;d my gadgets go?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hiser</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nguyen-Tuong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Co</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Davidson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P &apos;12</title>
		<imprint>
			<biblScope unit="page" from="571" to="585" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Diversifying the software stack using randomized nop insertion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jackson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Homescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Crane</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Brun-Thaler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Franz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Moving Target Defense</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="151" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Countering code-injection attacks with instruction-set randomization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">C</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">S</forename><surname>Keromytis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prevelakis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS &apos;03, ACM</title>
		<imprint>
			<biblScope unit="page" from="272" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Address space layout permutation (aslp): Towards fine-grained randomization of commodity software. ACSAC &apos;06</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kil</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bookholt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ning</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="339" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Smashing the gadgets: Hindering return-oriented programming using in-place code randomization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pappas</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Polychronakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keromytis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P &apos;12</title>
		<imprint>
			<biblScope unit="page" from="601" to="615" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Q: exploit hardening made easy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Avgerinos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brumley</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="25" to="25" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The info leak era on software exploitation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">J</forename><surname>Serna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Black Hat USA</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The geometry of innocent flesh on the bone: return-into-libc without function calls (on the x86)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shacham</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS &apos;07, ACM</title>
		<imprint>
			<biblScope unit="page" from="552" to="561" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On the effectiveness of address-space randomization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shacham</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pfaff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Goh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E.-J</forename><surname>Modadugu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boneh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS &apos;04, ACM</title>
		<imprint>
			<biblScope unit="page" from="298" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Just-in-time code reuse: On the effectiveness of fine-grained address space layout randomization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">Z</forename><surname>Snow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Monrose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Davi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dmitrienko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Liebchen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A.-R</forename><surname>Sadeghi</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="574" to="588" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Bypassing browser memory protections in windows vista</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sotirov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dowd</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Blackhat USA</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Sok: Eternal war in memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Szekeres</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Payer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Song</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P &apos;13</title>
		<imprint>
			<biblScope unit="page" from="48" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Intscope: Automatically detecting integer overflow vulnerability in x86 binary using symbolic execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS &apos;09</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Binary stirring: self-randomizing instruction addresses of legacy x86 binary code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wartell</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mohan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Hamlen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">W</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS &apos;12, ACM</title>
		<imprint>
			<biblScope unit="page" from="157" to="168" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The advanced return-into-lib (c) exploits: Pax case study. Phrack Magazine, Volume 0x0b, Issue 0x3a, Phile# 0x04 of</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wojtczuk</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="0" to="0" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
