<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:12+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scaling Verifiable Computation Using Efficient Set Accumulators Scaling Verifiable Computation Using Efficient Set Accumulators</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Ozdemir</surname></persName>
							<email>aozdemir@cs.stanford.edu</email>
							<affiliation key="aff0">
								<orgName type="department">No Affiliation</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Riad</forename><surname>Wahby</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">No Affiliation</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stanford</forename><surname>University</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">No Affiliation</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Unaffiliated;</roleName><forename type="first">Barry</forename><surname>Whitehat</surname></persName>
							<email>barrywhitehat@protonmail.com</email>
							<affiliation key="aff0">
								<orgName type="department">No Affiliation</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Boneh</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">No Affiliation</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Ozdemir</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">No Affiliation</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stanford</forename><surname>Riad</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">No Affiliation</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wahby</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">No Affiliation</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stanford</forename><forename type="middle">Barry</forename><surname>Whitehat</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">No Affiliation</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><forename type="middle">Boneh</forename><surname>Stanford</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">No Affiliation</orgName>
								<orgName type="institution">Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Scaling Verifiable Computation Using Efficient Set Accumulators Scaling Verifiable Computation Using Efficient Set Accumulators</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Verifiable outsourcing systems offload a large computation to a remote server, but require that the remote server provide a succinct proof, called a SNARK, that proves that the server carried out the computation correctly. Real-world applications of this approach can be found in several blockchain systems that employ verifiable outsourcing to process a large number of transactions off-chain. This reduces the on-chain work to simply verifying a succinct proof that transaction processing was done correctly. In practice, verifiable outsourcing of state updates is done by updating the leaves of a Merkle tree, recomputing the resulting Merkle root, and proving using a SNARK that the state update was done correctly. In this work, we use a combination of existing and novel techniques to implement an RSA accumulator inside of a SNARK, and use it as a replacement for a Merkle tree. We specifically optimize the accumulator for compatibility with SNARKs. Our experiments show that the resulting system reduces costs compared to existing approaches that use Merkle trees for committing to the current state. These results apply broadly to any system that needs to offload batches of state updates to an untrusted server.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Verifiable outsourcing <ref type="bibr">[4, 13, 15, 16, 21, 32, 45, 47, 49, 52, 56, 61, 78, 79, 96, 106-108, 111-115, 121, 123, 124]</ref> is a technique that enables a weak client to outsource a computation to a powerful server. The server returns the result of the computation along with a proof that the computation was done correctly. The proof must be succinct, which means that it must be short and cheap to verify. Verifiable outsourcing is relevant in a number of scenarios, including weak IoT devices, wearables, and low-power devices.</p><p>More recently, verifiable outsourcing has been deployed in blockchain environments, because on-chain work is expensive-literally. Here, a batch of k transactions, say k = 1000, is outsourced to an untrusted server, called an aggregator, for processing. The aggregator (1) verifies that the transactions are valid (e.g., properly signed), (2) computes the updated global state resulting from these transactions, and (3) generates a succinct proof that the aggregator correctly executed steps (1) and (2). The updated state and the succinct proof are then sent to the blockchain. In this approach, the (expensive) on-chain work is reduced to only verifying the proof-which is fast, taking time independent of the number of transactions k-and then recording the updated state. Example systems that operate this way include Rollup <ref type="bibr" target="#b6">[7]</ref>, Coda <ref type="bibr" target="#b86">[89]</ref>, Matter <ref type="bibr">[86]</ref>, and Zexe <ref type="bibr" target="#b27">[29]</ref>.</p><p>The process described above is called verifiable outsourcing of state update <ref type="bibr" target="#b30">[32]</ref>. In more detail, the state is a set of elements S = {x 1 , . . . , x M } from some universe X . The blockchain (or a low-power device) stores only a succinct digest of S, e.g., the root of a Merkle tree whose leaves comprise the elements of S. The untrusted but powerful aggregator stores the full set S, in the clear. (Note that we treat S as public data-privacy is orthogonal to our goal, which is scalability). When processing a batch of transactions as described above, the aggregator updates S to produce a new set S , then computes a new Merkle digest for S that it sends to the blockchain to be verified and recorded. The aggregator's proof establishes that its starting state S is consistent with the current digest, that correctly applying transactions yields the ending state S , and that the new digest is consistent with S .</p><p>The succinct proof needed here is called a SNARK <ref type="bibr" target="#b17">[19]</ref>, which we define in more detail in the next section. Constructing efficient SNARKs and optimizing their implementation is a very active area of research <ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b13">15,</ref><ref type="bibr" target="#b14">16,</ref><ref type="bibr" target="#b47">49,</ref><ref type="bibr" target="#b62">64,</ref><ref type="bibr" target="#b68">70,</ref><ref type="bibr" target="#b93">96]</ref>, with several new systems just in the last year <ref type="bibr" target="#b9">[11,</ref><ref type="bibr" target="#b35">37,</ref><ref type="bibr" target="#b41">43,</ref><ref type="bibr" target="#b42">44,</ref><ref type="bibr" target="#b60">62,</ref><ref type="bibr" target="#b61">63,</ref><ref type="bibr" target="#b83">85,</ref><ref type="bibr" target="#b117">122]</ref>. A common thread in all of these systems is that the proving costs are enormous. In particular, proving imposes multiple-orders-of-magnitude slowdown compared to native execution <ref type="bibr" target="#b93">[96,</ref><ref type="bibr" target="#b101">106,</ref><ref type="bibr" target="#b111">116]</ref>; this can be defrayed via parallel execution, e.g., in clusters <ref type="bibr" target="#b43">[45,</ref><ref type="bibr" target="#b116">121]</ref> or on GPUs <ref type="bibr" target="#b103">[108,</ref><ref type="bibr" target="#b107">112]</ref>.</p><p>Perhaps more importantly, for widely deployed SNARKs, proving correctness of large computations requires an amount of RAM proportional to the computation's execution time <ref type="bibr" target="#b14">[16,</ref><ref type="bibr" target="#b93">96]</ref>. The result is that, even when proving is distributed across hundreds of workers, the largest reachable computation sizes are relatively small: only about 2 billion steps <ref type="bibr" target="#b116">[121]</ref>. This imposes a strict upper bound on the number of transactions k that can be processed in a single batch. This state of affairs has motivated a large body of work on computational primitives that yield efficient proofs. Examples include arithmetic <ref type="bibr" target="#b77">[79,</ref><ref type="bibr" target="#b93">96,</ref><ref type="bibr" target="#b103">108]</ref>, control flow <ref type="bibr" target="#b93">[96,</ref><ref type="bibr" target="#b103">108,</ref><ref type="bibr" target="#b111">116]</ref>, persistent state <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b47">49,</ref><ref type="bibr" target="#b54">56,</ref><ref type="bibr" target="#b100">105]</ref>, and random-access memory <ref type="bibr" target="#b10">[12,</ref><ref type="bibr" target="#b11">13,</ref><ref type="bibr" target="#b14">16,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b77">79,</ref><ref type="bibr" target="#b111">116]</ref>. Our work continues in this vein, with a focus on reducing proving costs for computations involving persistent state or random-access memory.</p><p>Our work. A Merkle tree <ref type="bibr" target="#b87">[90]</ref> is an example of an accumulator <ref type="bibr" target="#b15">[17]</ref>, a cryptographic primitive that lets one commit to a set S, and later prove that an element x is a member of S. Although Merkle trees are used pervasively in today's general-purpose verifiable state update applications, in this work we show that a Merkle tree is not the best choice for large batches of state updates when S is moderately to very large, say |S| ≥ 2 <ref type="bibr" target="#b8">10</ref> . In particular, we show that replacing Merkle trees with RSA-based accumulators <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b38">40,</ref><ref type="bibr" target="#b79">81]</ref> significantly improves proving time and/or reachable computation size. Our contributions are:</p><p>• We define a new operation for RSA accumulators, which we call MultiSwap, that provides a precise sequential semantics for batched verifiable state updates ( §3).</p><p>• We synthesize existing and novel techniques for efficiently implementing MultiSwap (and, more generally, RSA accumulators) in the context of SNARKs ( §4). These techniques include a hash function that outputs provable prime numbers, and a new division-intractable hash function. Our approach makes use of very recent advances in manipulating RSA accumulators <ref type="bibr" target="#b22">[24]</ref>.</p><p>• We apply our techniques in two contexts ( §5). The first, called Rollup <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b63">65,</ref><ref type="bibr" target="#b91">94]</ref>, is a technique for batching cryptocurrency transactions off-chain in order to save on-chain work. The second is a general-purpose RAM abstraction with long-lived state (i.e., over many proofs), which builds upon and improves prior work <ref type="bibr" target="#b10">[12,</ref><ref type="bibr" target="#b11">13,</ref><ref type="bibr" target="#b14">16,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b111">116]</ref>.</p><p>• We implement and evaluate ( §6, §7). In particular, we compare our RSA accumulator implementation to Merkle trees in two benchmarks: one that measures only set operations, and one that implements a Rollup-style distributed payment application. We also compare our RAM abstraction with existing work via a cost model analysis.</p><p>In the set operations benchmark, we find that RSA accumulators surpass 2 20 -element Merkle trees for batches of ≈1,300 operations, and allow for 3.3× more operations to be performed in the largest proof sizes we consider. In the Rollup application, RSA accumulators surpass 2 <ref type="bibr" target="#b18">20</ref> -element Merkle trees for ≈600 transactions, and allow 1.9× more transactions in the largest proofs. For RAM, we find that for a RAM of size 2 20 , RSA accumulators surpass Merkle trees for ≈1000-4000 accesses, depending on write load.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and definitions</head><p>Multisets. A multiset is an unordered collection that may contain multiple copies of any element. S 1 S 2 denotes the union of multisets S 1 and S 2 , i.e., the multiset S 3 where each element x ∈ S 3 has multiplicity equal to the sum of the multiplicities of x in S 1 and S 2 . S 1 S 2 denotes the strict difference of multisets S 1 and S 2 , i.e., the multiset S 3 where each element x ∈ S 3 has multiplicity equal to the difference of multiplicities of x in S 1 and S 2 . Note that S 1 S 2 is only defined if S 2 ⊆ S 1 .</p><p>RSA groups. An RSA group is the group Z × N , i.e., the multiplicative group of invertible integers modulo N, where N is the product of two secret primes. We define the RSA quotient group for N as the group Z × N /{±1}. In this group, the elements x and N − x are the same, meaning that all elements can be represented by integers in the interval [1, N /2]. It is believed that this group has no element of known order, other than the identity.</p><p>Proofs and arguments. Informally, a proof is a protocol between a prover P and a PPT verifier V by which P convinces V that ∃υ : R(ι, υ) = 1, for a relation R, ι an input from V , and υ a (possibly empty) witness from P . A proof satisfies the following properties:</p><p>• Completeness: If ∃υ : R(ι, υ) = 1, then an honest P convinces V except with probability at most ε c 1 /2.</p><p>• Soundness: If ∃υ : R(ι, υ) = 1, no cheating prover P convinces V except with probability at most ε s 1 /2. If soundness holds only against PPT P , this protocol is instead called an argument. When the witness υ exists, one may also require the proof system to provide knowledge soundness. Informally this means that whenever P convinces V that ∃υ : R(ι, υ) = 1, υ exists and P "knows" a witness υ (slightly more formally, there exists a PPT algorithm, an extractor, that can produce a witness via oracle access to P ).</p><p>Proof of exponentiation. Let G be a finite group of unknown order. Wesolowski <ref type="bibr" target="#b115">[120]</ref> describes a protocol that allows P to convince V that y = x n in G, namely a protocol for the relation R given by R (n, x, y),</p><formula xml:id="formula_0">· = 1 ⇐⇒ y = x n ∈ G.</formula><p>The protocol is: on input (n, x, y), V sends to P a random chosen from the first 2 λ primes. 1 P sends back Q = x n// ∈ G, and V accepts only if Q · x n mod = y ∈ G holds. This protocol is complete by inspection. Wesolowski shows that it is sound if the group G satisfies the adaptive root assumption, roughly, it is infeasible for an adversary to find a random root of an element of G chosen by the adversary. The RSA quotient group Z × N /{±1} is conjectured to satisfy this assumption when P cannot factor N <ref type="bibr" target="#b21">[23]</ref>.</p><p>Division-intractable hashing. Recall that a hash function Pocklington primality certificates. Let p be a prime, and r &lt; p and a be positive integers. Define p = p · r + 1. Pocklington's criterion <ref type="bibr" target="#b32">[34]</ref> states that if a p·r ≡ 1 mod p and gcd(a r − 1, p ) = 1, then p is prime. In this case, we say that (p, r, a) is a Pocklington witness for p .</p><formula xml:id="formula_1">H : X → D is collision resistant if it is infeasible for a PPT adversary to find distinct x 0 , x 1 such that H(x 0 ) = H(x 1 ). In- formally</formula><p>Pocklington's criterion is useful for constructing primality certificates. For a prime p n , this certificate comprises</p><formula xml:id="formula_2">p 0 , {(r i , a i )} 0&lt;i≤n</formula><p>where p i = p i−1 · r i + 1. To check this certificate, first verify the primality of the small prime p 0 (e.g., using a deterministic primality test), then verify the Pocklington witness</p><formula xml:id="formula_3">(p i−1 , r i , a i ) for p i , 0 &lt; i ≤ n.</formula><p>If each r i is nearly as large as p i , the bit lengths double at each step, meaning that the total verification cost is dominated by the cost of the final step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Accumulators</head><p>A cryptographic accumulator <ref type="bibr" target="#b15">[17]</ref> commits to a collection of values (e.g., a vector, set, or multiset) as a succinct digest. This digest is binding, meaning informally that it is computationally infeasible to equivocate about the collection represented by the digest. In addition, accumulators admit succinct proofs of membership and, in some cases, non-membership.</p><p>Merkle trees. The best-known vector accumulator is the Merkle tree <ref type="bibr" target="#b87">[90]</ref>. To review, this is a binary tree that stores a vector in the labels of its leaves; the label associated with an internal node of this tree is the result of applying a collisionresistant hash H to the concatenation of the children's labels; and the digest representing the collection is the label of the root node. A membership proof for the leaf at index i is a path through the tree, i.e., the labels of the siblings of all nodes between the purported leaf and the root. Verifying the proof requires computing the node labels along the path and comparing the final value to the digest (the bits of i indicate whether each node is the right or left child of its parent). Updating a leaf's label is closely related: given a membership proof for the old value, the new digest is computed by swapping the old leaf for the new one, then computing the hashes along the path. Merkle trees do not support succinct non-membership proofs.</p><p>The cost of verifying k membership proofs for a vector comprising 2 m values is k · m evaluations of H. The cost of k leaf updates is 2 · k · m evaluations. Membership proofs and updates cannot be batched for savings.</p><p>RSA accumulators. The RSA multiset accumulator <ref type="bibr" target="#b38">[40,</ref><ref type="bibr" target="#b79">81]</ref> represents a multiset S with the digest</p><formula xml:id="formula_4">S = g ∏ s∈S H(s) ∈ G,</formula><p>where g is a fixed member of an RSA quotient group G and H is a division-intractable hash function ( §2). Inserting a new element s into S thus requires computing S H(s) .</p><p>To prove membership of s ∈ S, the prover furnishes the value π = S 1/H(s) , i.e., a H(s)'th root of S. This proof is verified by checking that π H(s) = S.</p><p>Non-membership proofs are also possible <ref type="bibr" target="#b79">[81]</ref>, leveraging the fact that s ∈ S if and only if gcd(H(s ), ∏ s∈S H(s)) = 1. This means that the Bézout coefficients a, b, i.e., integers satisfying</p><formula xml:id="formula_5">a · H(s ) + b · ∏ s∈S H(s) = 1</formula><p>are a non-membership witness, since the above implies that</p><formula xml:id="formula_6">S b · (g a ) H(s ) = g</formula><p>Because a is large and b is small, the proof (g a , b) is succinct.</p><p>Insertions, membership proofs, and non-membership proofs can all be batched <ref type="bibr" target="#b22">[24]</ref> via Wesolowski proofs ( §2). For example, since S {s i } = S ∏ i s i , computing an updated digest directly requires an exponentiation by ∏ i s i . In contrast, checking the corresponding proof only requires computing and then exponentiating by ∏ i s i mod , for a prime of less than 200 bits. This means that the exponentiation (but not the multiplication) to verify a batch proof has constant size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Verifiable computation and SNARKs</head><p>Several lines of built systems <ref type="bibr">[13, 15, 16, 21, 32, 47, 49, 61, 79, 96, 106-108, 112, 113, 124]</ref> enable the following highlevel model. <ref type="bibr" target="#b1">2</ref> A verifier V asks a prover P to convince it that y = Ψ(x), where Ψ is a program taking input x and returning output y. To do so, P produces a short certificate that the claimed output is correct. Completeness holds with ε c = 0; soundness holds as long as P is computationally bounded, with ε s negligible in a security parameter ( §2).</p><p>Roughly speaking, these systems comprise two parts. In the front-end, V compiles Ψ into a system of equations C (X,Y, Z), where X, Y , and Z are (vectors of) formal variables.</p><formula xml:id="formula_7">V constructs C such that z satisfying C (X = x,Y = y, Z = z)</formula><p>exists (that is, the formal variable X is bound to the value x, and so on) if and only if y = Ψ(x). The back-end comprises cryptographic and complexity-theoretic machinery by which P convinces V that a witness z exists for X = x and Y = y.</p><p>This paper focuses on compilation in the front-end. We target back-ends derived from GGPR <ref type="bibr" target="#b62">[64]</ref> via Pinocchio <ref type="bibr" target="#b93">[96]</ref> (including <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b14">16,</ref><ref type="bibr" target="#b68">70]</ref>), which we briefly describe below.</p><p>Our work is also compatible with other back-ends, e.g., Zaatar <ref type="bibr" target="#b101">[106]</ref>, Ligero <ref type="bibr" target="#b1">[2]</ref>, Bulletproofs <ref type="bibr" target="#b34">[36]</ref>, Sonic <ref type="bibr" target="#b83">[85]</ref>, and Aurora <ref type="bibr" target="#b12">[14]</ref>. <ref type="bibr" target="#b2">3</ref> GGPR, Pinocchio and their derivatives instantiate zeroknowledge Succinct Non-interactive ARguments of Knowledge with preprocessing (zkSNARKs), which are argument protocols satisfying completeness, knowledge soundness, and zero knowledge ( §2), <ref type="bibr" target="#b3">4</ref> where knowledge soundness and zero knowledge apply to the assignment to Z. In addition, these protocols satisfy succinctness: informally, proof length and verification time are both sublinear in |C | (here, proofs are of constant size, while V 's work is O(|X| + |Y |)). These protocols include a preprocessing phase, in which V (or someone that V trusts) processes C to produce a structured reference string (SRS), which is used by P to prove and V to verify.</p><p>The cost of the preprocessing phase and the length of the SRS are O(|C |). The cost of the proving phase is O(|C | log |C |) in time and O(|C |) in space (i.e., prover RAM).</p><p>The system of equations C (X,Y, Z) is a rank-1 constraint system (R1CS) over a large finite field F p . An R1CS is defined by three matrices, A, B,C ∈ F |C |×(1+|X|+|Y |+|Z|) p . Its satisfiability is defined as follows: for W the column vector of formal</p><formula xml:id="formula_8">variables [1, X,Y, Z] , C (X,Y, Z) is the system of |C | equa- tions (A ·W ) • (B ·W ) = C ·W , where</formula><p>• denotes the Hadamard (element-wise) product. In other words, an R1CS C is a conjunction of |C | constraints in |X| + |Y | + |Z| variables, where each constraint has the form "linear combination times linear combination equals linear combination."</p><p>These facts outline a computational setting whose costs differ significantly from those of CPUs. On a CPU, bit operations are cheap and word-level arithmetic is slightly more costly. In an R1CS, addition is free, word-level multiplication has unit cost, and bitwise manipulation and many inequality operations are expensive; details are given below.</p><p>Compiling programs to constraints. A large body of prior work <ref type="bibr">[13, 16, 32, 79, 96, 106-108, 115, 116</ref>] deals with efficiently compiling from programming languages to constraints.</p><p>An important technique for non-arithmetic operations is the use of advice, variables in Z whose values are provided by the prover. For example, consider the program fragment x != 0, which cannot be concisely expressed in terms of rank-1 constraints. Since constraints are defined over F p , this assertion might be rewritten as X p−1 = 1, which is true just when X = 0 by Fermat's little theorem. But this is costly: it requires O(log p) multiplications. A less expensive way to express this constraint is Z · X = 1; the satisfying assignment to Z is X −1 ∈ F p . Since every element of F p other than 0 has a multiplicative inverse, this is satisfiable just when X = 0.</p><p>Comparisons, modular reductions, and bitwise operations make heavy use of advice from P . For example, the program fragment y = x1 &amp; x2, where x1 and x2 have bit width b and &amp; is bitwise AND, is represented by the following constraints:</p><formula xml:id="formula_9">Z 1,0 + 2 · Z 1,1 + . . . + 2 b−1 · Z 1,b−1 = X 1 Z 2,0 + 2 · Z 2,1 + . . . + 2 b−1 · Z 2,b−1 = X 2 Z 3,0 + 2 · Z 3,1 + . . . + 2 b−1 · Z 3,b−1 = Y Z 1,0 · (1 − Z 1,0 ) = 0 . . . Z 1,b−1 · (1 − Z 1,b−1 ) = 0 Z 2,0 · (1 − Z 2,0 ) = 0 . . . Z 2,b−1 · (1 − Z 2,b−1 ) = 0 Z 1,0 · Z 2,0 = Z 3,0 . . . Z 1,b−1 · Z 2,b−1 = Z 3,b−1</formula><p>Here, the variables Z 1,0 . . . </p><formula xml:id="formula_10">Z 1 · X 1 = Z 2 (1) Z 3 · (Z 2 − 1) = 0 (2) (1 − Z 3 ) · X 1 = 0 (3) (1 − Z 3 ) · (Y − X 2 − 1) = 0 (4) Z 3 · (Y − 3 · X 2 ) = 0 (5)</formula><p>This works as follows: if X 1 = 0, Z 2 = 0 by (1), so Z 3 = 0 by (2) and Y = X 2 + 1 by (4). Otherwise, Z 3 = 1 by (3), so </p><formula xml:id="formula_11">= b /b l limbs { ˆ a i }, where a = ∑ η−1 i=0âi=0ˆi=0â i · 2 b l ·i .</formula><p>For correctness, the compiler must track the maximum value of each number and ensure that C contains constraints that encode a sufficient number of limbs.</p><p>Multiprecision operations rely heavily on advice from P . At a high level, P supplies the result of a multiplication or addition, and the compiler emits constraints to check that result. Subtractions and divisions are checked by verifying the inverse addition or multiplication, respectively. xJsnark describes a range of optimizations that reduce the required number of constraints. We leave details to <ref type="bibr" target="#b77">[79]</ref>, because they are not necessary to understand our further optimizations ( §4.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Random-access memory</head><p>Programs that make use of RAM-in particular, programs whose memory accesses depend on the input, and thus cannot be statically analyzed-present a challenge for compiling to constraints. Prior work demonstrates three solutions. We now describe each, and compare costs and functionality below.</p><p>Linear scan. The most direct approach to emulating RAM in constraints is to perform a linear scan <ref type="bibr" target="#b77">[79,</ref><ref type="bibr" target="#b93">96]</ref>. Concretely, Y = LOAD(Z) compiles to a loop that scans through an array, comparing the loop index to Z and, if they match, setting Y to the corresponding value. (STORE is analogous.)</p><p>The Pantry approach. In Pantry <ref type="bibr" target="#b30">[32]</ref>, the authors borrow a technique from the memory-checking literature <ref type="bibr" target="#b18">[20]</ref> based on Merkle trees <ref type="bibr" target="#b87">[90]</ref> (see also §2.1). In particular, Pantry stores the contents of RAM in the leaves of a Merkle tree whose root serves as ground truth for the state of memory.</p><p>For a LOAD, P furnishes advice comprising a purported value from memory, plus a Merkle path authenticating that value. The corresponding constraints encode verification of the Merkle path, i.e., a sequence of hash function invocations and an equality check against the Merkle root. For a STORE, P furnishes, and the constraints verify, the same values as for a LOAD. In addition, the constraints encode a second sequence of hash function invocations that compute a new Merkle root corresponding to the updated memory state.</p><p>The BCGT approach. Ben-Sasson et al. <ref type="bibr" target="#b10">[12]</ref> introduce, and other work <ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b14">16,</ref><ref type="bibr" target="#b77">79,</ref><ref type="bibr" target="#b111">116]</ref> refines, an approach building on the observation <ref type="bibr" target="#b2">[3]</ref> that one can check a sequence of RAM operations using an address-ordered transcript, i.e., the sequence of RAM operations sorted by address accessed, breaking ties by execution order. In such a transcript, each LOAD is preceded either by the corresponding STORE or by another LOAD from the same address; correctness of RAM dictates that this LOAD should return the same value as the preceding operation. (A LOAD from an address to which no value was previously stored returns a default value, say, 0.) Leveraging this observation, correctness of memory operations is compiled to constraints as follows. First, every access to memory appends a tuple (IDX i , OP i , ADDR i , DATA i ) to an execution-ordered transcript; here, IDX i = i is the index of the memory operation and OP i is either LOAD or STORE. Then P furnishes a purported address-ordered transcript T , and the constraints check its correctness by ensuring that (1) transcript T is a permutation of the execution-ordered transcript, (2) each sequential pair of entries in transcript T is indeed correctly ordered, and (3) each sequential pair of entries in transcript T is coherent, i.e., each LOAD returns the value of the previous STORE (or the default if no such STORE exists).</p><p>Check <ref type="formula">(1)</ref> is implemented with a routing network <ref type="bibr" target="#b16">[18,</ref><ref type="bibr" target="#b113">118]</ref>.</p><p>Costs and functionality. Roughly speaking, for tiny memories linear scan is cheapest; otherwise, BCGT-style RAM is. <ref type="bibr" target="#b4">5</ref> In more detail, assume a memory of size 2 m , accessed k times. For a linear scan, each RAM operation costs O(2 m ) constraints. (i.e., 2 m copies of constraints encoding conditional assignment). For Pantry, each LOAD entails m copies of constraints encoding a collision-resistant hash function and each STORE entails 2m such copies, where such hash functions entail a few hundred to a few thousand constraints ( §6; <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b30">32,</ref><ref type="bibr" target="#b77">79]</ref>). For BCGT, each RAM operation costs O(log k) constraints for the routing network, O(m) constraints for address comparison, and O(1) constraints for coherence checking, all with good constants <ref type="bibr">[116, Fig. 5]</ref>.</p><p>Although Pantry-style RAM is costly, it offers functionality that the other two do not: the ability to pass the full state of a large RAM from one computation to another. Pantry accomplishes this by including in X the Merkle root corresponding to the initial RAM state; this has constant size (usually one element of F p ). In contrast, BCGT and linear scan would both require 2 m values in X for a 2 m -sized RAM; as discussed above, this would incur 2 m cost for V in verification. (Prior work <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b14">16]</ref> uses this approach to partially initialize RAM.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Swap sequences via batched operations</head><p>In this section, we define a new primitive, which we call MultiSwap, that exposes a sequential update semantics for RSA accumulators ( §2.1). MultiSwap takes an accumulator and a list of pairs of elements, removing the first element from each pair and inserting the second. The key property of this primitive is that it is defined in terms of batched insertions and removals. In Section 4, we show how these batched operations are efficiently implemented as a system of constraints ( §2.2).</p><p>In more detail, let S and S be multisets, and let (x 1 , y 1 ), . . . , (x n , y n ) be a sequence of operations, called swaps, that replaces each x i by y i in order: (x 1 , y 1 ) applied to S produces some new set S 1 = S {x 1 } {y 1 }; then (x 2 , y 2 ) applied to S 1 produces S 2 = S 1 {x 2 } {y 2 }, etc. Our goal is to verify that when the above sequence is applied to S, the result is S = S n . Recall from Section 2.1 that RSA accumulators admit efficient batched insertions (deletions are analogous; §4). Our question is: how can we use this un-ordered primitive to implement one with ordered semantics?</p><p>Consider the following naïve solution: first verify the deletions, then verify the insertions. In other words, verify that there exists some S mid such that S {x i } = S mid and S mid {y i } = S . The problem with this approach is that it does not permit certain valid sequences, i.e., those in which a later swap deletes an item inserted by an earlier swap. (To see why, notice that S mid only exists if all x i ∈ S.)</p><p>Instead, our solution first verifies all the insertions, and then verifies all the deletions, irrespective of the order in which the operations are listed. In other words, it verifies the predicate</p><formula xml:id="formula_12">∃S mid : S {y i } = S mid ∧ S mid {x i } = S (6) (Note that S mid {x i } = S is equivalent to S {x i } = S mid .)</formula><p>Intuitively, Equation <ref type="formula">(6)</ref> holds just when each element of an unordered multiset of swaps {(x i , y i )} can be applied to S in some order to produce S . As we discuss below, this multiset may include cycles, subsets of swaps that have no net effect.</p><p>We now give a precise semantics for MultiSwap. Let MultiSwap(S, σ, S ) denote the predicate that holds just when Equation <ref type="formula">(6)</ref> is satisfied. Let σ denote an unordered multiset of swaps {(</p><formula xml:id="formula_13">x i , y i )}. A swap (x i , y i ) is valid for S if x i ∈ S .</formula><p>We say that σ is sequentially consistent with respect to S if there exists some ordering on σ such that all swaps are valid when applied in that order starting from S. Furthermore, we say that σ produces S from S if S is the product of such an application order to S, and we say that σ c is a cycle if it comprises {(c 0 , c 1 ), (c 1 , c 2 ), . . . , (c n , c 0 )}. Lemma 1. MultiSwap(S, σ, S ) holds if and only if there exist any number of cycles σ c i and cycle-free σ ⊆ σ such that σ = σ i σ c i , σ is sequentially consistent with respect to S, and σ produces S from S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The proof of Lemma 1 is in Appendix A. Section 5 applies</head><p>MultiSwap to problems that need sequential semantics for batched verifiable state updates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Batched operations from constraints</head><p>In the previous section we described how the MultiSwap primitive is built from batched insertions and removals. In this section we describe these batched operations, the primitives that they are built on, and how those primitives are implemented as a set of constraints C ( §2.2).</p><p>Recall ( §2.1) that RSA accumulators support batched insertions through an interactive protocol whose final check is</p><formula xml:id="formula_14">Q · S ∏ i H ∆ (y i ) mod = S {y i }<label>(7)</label></formula><p>where · denotes a digest; S, the initial multiset; , a random prime challenge; {y i }, the inserted elements; H ∆ , a divisionintractable hash function; and Q, a witness from P . Removing elements {x i } is similar, except that S {x i } is regarded as the initial multiset and S the final one. <ref type="bibr" target="#b5">6</ref> To instantiate this interactive protocol in constraints, we apply the Fiat-Shamir heuristic <ref type="bibr" target="#b53">[55]</ref>, i.e., C computes the challenge by hashing all of the inputs to the protocol. 7 <ref type="figure" target="#fig_2">Figure 1</ref> illustrates the insertion proof's verification procedure. MultiSwap requires two proofs (one for insertion and one for removal); for this purpose, we hash all inputs to both proofs to derive a common challenge, as is standard <ref type="bibr" target="#b48">[50]</ref>.</p><formula xml:id="formula_15">1 . . . . . . . . . . . . H ∆ × mod y 1 H ∆ × mod y 2 H ∆ × mod y k exp G exp G × G H p S S</formula><p>In the rest of this section we explain how to efficiently implement the blocks of <ref type="figure" target="#fig_2">Figure 1</ref> in constraints. In particular, we explain how to implement H p , the prime hash function used to compute ( §4.1) and H ∆ , the division-intractable hash function used to hash each element ( §4.2). We also describe optimizations for multiprecision operations ( §4.3). Finally, we discuss P 's cost for generating the witness input Z to C ( §2.2), notably, the digests S {y i } and S {x i } and the corresponding witnesses Q for insertion and removal ( §4.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Hashing to primes</head><p>The hash function H p <ref type="figure" target="#fig_2">(Fig. 1)</ref> generates the challenge used in the Wesolowski proofs of batch insertion and removal.</p><p>These proofs are sound when P has negligible probability of guessing the factors of before evaluating H p <ref type="bibr" target="#b115">[120]</ref>. In the non-interactive setting, one way to ensure this is by choosing at random from the first 2 2λ primes (Fn. 1, §2). In our context, however, a more efficient approach is for H p to output slightly larger primes that are guaranteed by construction to have 2λ bits of entropy. 8 Soundness is identical.</p><p>In standard settings (i.e., outside of constraints), a typical approach ( §8) for hashing to a random prime is rejection sampling. Here, the input is fed to a collision-resistant hash whose output seeds a pseudorandom generator (PRG), then the PRG's outputs are tested in sequence until a prime is found. Verifying correct execution requires, at the very least, testing primality of the purported output. This is typically done with a probabilistic primality test like Miller-Rabin <ref type="bibr" target="#b95">[98]</ref>. Such tests, however, generally require many iterations for soundness, where each iteration involves an exponentiation modulo the prime being tested. This would be far too costly if implemented directly in constraints.</p><p>Instead, we take advantage of advice from P ( §2.2). At a high level, P helps to recursively construct a Pocklington certificate ( §2) for H p 's output, where each intermediate prime p i is the result of hashing H p 's input. (This is related to prior approaches; see §8.) This strategy is economical when implemented in constraints, because it uses very little pseudorandomness and requires only one exponentiation modulo the resulting prime, plus a few smaller exponentiations.</p><p>We now describe the recursive step used to construct p i from p i−1 . Further below, we describe the base case and give implementation details. Recall ( §2) that a Pocklington witness for p i comprises (p i−1 , r i , a i ) such that p i = p i−1 · r i + 1. (If p i is prime, some a i must exist.) Notice that, given p i−1 , one can find p i by testing candidate r i values until p i−1 · r i + 1 is prime. To implement this in constraints, we let r i = 2 b n i · h i + n i , where n i is a b n i -bit number provided by P as advice and h i is a b h i -bit pseudorandom number (we discuss its generation below). P furnishes a corresponding a i and C includes constraints that compute p i and r i , and check the witness.</p><p>The base case is p 0 = 2 b n 0 · h 0 + n 0 , for h 0 a pseudorandom number and n 0 supplied by P . We fix b n 0 + b h 0 = 32, i.e., p 0 &lt; 2 32 , and the constraints test primality of p 0 using a deterministic 3-round Miller-Rabin test that works for all values up to 2 32 <ref type="bibr" target="#b71">[73]</ref>. This test requires 3 exponentiations modulo p 0 with exponents less than 32 bits; these are inexpensive.</p><p>We choose bit widths b n i such that a valid n i exists with overwhelming probability, then choose b h i subject to the constraint that b h i + b n i &lt; log p i−1 , which ensures that r i &lt; p i−1 as required ( §2). rounds suffice for 256 bits of entropy using the parameters listed in <ref type="figure" target="#fig_1">Figure 2</ref>. C generates h i by hashing the input to H p with a hash function H modeled as a random oracle. Each iteration yields a prime approximately twice as wide as the prior iteration's; meanwhile, the cost of each iteration is dominated by an exponentiation. This means that our approach has cost less that that of two exponentiations modulo the final prime. In contrast, using Miller-Rabin to check a 264-bit prime (which has roughly 256 bits of entropy) would require 80 exponentiations modulo that prime to give ≈2 −80 probability of outputting a composite (because Miller-Rabin is a probabilistic primality test). Our approach thus saves more than an order of magnitude and provably outputs a prime.</p><p>One final optimization is to force the most significant bit of each h i to 1; this establishes a lower bound on each p i and on (which is the final p i ). As we discuss in Section 4.3, having this lower bound reduces the cost of modular reductions. The tradeoff is a small loss in entropy, namely, 1 bit per iteration. Even so, four rounds suffice to produce a 322-bit prime 9 with 256 bits of entropy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Division-intractable hashing</head><p>Coron and Naccache show <ref type="bibr" target="#b46">[48]</ref> that a hash function H that outputs sufficiently large integers is division intractable when modeled as a random oracle. Informally, this is because in any randomly-selected set of large (say, 2000 bit) numbers, each element has a distinct, moderately sized (say, 200 bit) prime factor with high probability.</p><p>Security of this hash function rests on the fact that the density of integers in the interval [0, α) with factors all less than µ approaches β −β+o(1) as α → ∞, where β = log α log µ . We conjecture that this density also holds for a large interval around α, namely, α, α + α 1/8 . (This is closely related to a conjecture on which the elliptic curve factorization method relies; there, the interval is</p><formula xml:id="formula_16">α − √ α, α + √ α [71]</formula><p>.) Our hash function is defined as follows: let ∆ be a public 2048-bit integer chosen at random, and let H be a hash function with codomain 0, 2 256 with 128-bit collision resistance. Then H ∆ (x) = H(x) + ∆. Security of this construction follows from the analysis of <ref type="bibr" target="#b46">[48]</ref> in the random oracle model, <ref type="bibr">9</ref> Even though the prime comprises only 322 bits, C represents it with 352 ( <ref type="figure" target="#fig_3">Fig. 3)</ref>, which is the next multiple of the limb width b l (32 bits; §2.2). assuming the conjecture stated above. Concretely, we conjecture that an adversary making q queries to H ∆ has probability roughly q · 2 −128 of breaking division intractability.</p><p>H ∆ 's advantage over prior work is that its implementation in constraints is much smaller. The system parameter ∆ is baked into the constraints, and the only dynamic values to compute are the base hash H(x) and the sum H(x) + ∆; using known techniques <ref type="bibr" target="#b77">[79]</ref>, this sum is inexpensive. Moreover, since all hashes must be reduced modulo the challenge (Eq. <ref type="formula" target="#formula_14">(7)</ref>) and H ∆ (x) mod = (H(x) + (∆ mod )) mod , the (costly) reduction ∆ mod can be checked once in the constraints and the result can be re-used for each H ∆ (x). We note that while this approach gives smaller C than hashing to primes (because H ∆ and modular reductions are cheaper), it increases P 's work (because H ∆ 's bit length is longer; §4.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Multiprecision arithmetic optimizations</head><p>We describe two optimizations for multiprecision arithmetic in constraints, building on ideas described in Section 2.2.</p><p>Computing greatest common divisor. We observe that addition and multiplication checks can be leveraged to verify a statement gcd(x, y) = d by checking three equations over Z:</p><formula xml:id="formula_17">∃a, b a · x + b · y = d (8) ∃x x · d = x ∃y y · d = y</formula><p>In constraints, the existential variables above correspond to advice provided by P . Verifying coprimality (gcd(x, y) = 1) reduces to condition (8), i.e., materializing the multiplicative inverse of x modulo y. We use this simplification in Section 4.1 to verify a Pocklington witness ( §2).</p><p>Optimizing division and modular reduction. Prior work implements division and modular reduction for a dividend x and divisor d by having the prover provide, as advice, the quotient q and remainder r &lt; d such that x = q·d +r; this equality is then checked with multiprecision arithmetic ( §2.2). For correctness, C must enforce upper bounds on the bit widths of q and r via bit splitting ( §2.2), which requires as many constraints as the sum of the bit widths of q and r.</p><p>Since r can range from 0 to d − 1, its width is just that of d. The width of q, however, is slightly more subtle. Since q's value is x /d, a conservative choice is to assume q is as wide as x. But this choice is imprecise: q is only as wide as log 2 ( x max/d min ), where x max denotes x's maximum possible value, and d min denotes d's minimum possible value. (Intuitively, this is because q is small when d is large.)</p><p>As in prior work <ref type="bibr" target="#b77">[79]</ref>, our system uses a dataflow analysis to track the maximum value of each number, in order to determine the required representation size. To bound q's width more tightly using the above expression, we augment this dataflow analysis to also track minimum values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Optimizing the cost of advice generation</head><p>The prior sections have treated P as an advice oracle. We now discuss P 's cost in computing this advice. Prior work <ref type="bibr" target="#b111">[116,</ref><ref type="bibr" target="#b116">121]</ref> shows that P 's (single-threaded) cost per constraint is ≈100 µs or more (this includes, e.g., an elliptic curve point multiplication per constraint <ref type="bibr" target="#b14">[16,</ref><ref type="bibr" target="#b62">64,</ref><ref type="bibr" target="#b68">70,</ref><ref type="bibr" target="#b93">96]</ref>). Computing most advice values-including for multiprecision operations and prime hashing-is negligible by comparison. Possible exceptions are the witnesses for Wesolowski proofs ( §2) used by batch insertion and removal operations ( §2.1). (Recall that one of each operation is required for a MultiSwap; §3.)</p><p>The witness for a batch insertion S {y i } = S ∏ i H ∆ (y i ) is the value S (∏ i H ∆ (y i ))// . This exponent has length ≈2048 · k bits for k elements inserted. In microbenchmarks, GMP <ref type="bibr" target="#b64">[66]</ref> computes a 2048-bit exponentiation modulo a 2048-bit N in ≈2.5 milliseconds (i.e., roughly 25× P 's per-constraint proving cost), so computing this value costs roughly the same as 25 · k constraints, which is inconsequential ( §5, <ref type="figure" target="#fig_3">Fig. 3</ref>).</p><p>Batch removal is much more expensive. To prove that removing the elements {x i } from the multiset S yields a new multiset S , P must prove that S = S</p><formula xml:id="formula_18">∏ i H ∆ (x i ) , where S = S {x i } = g ∏ s∈S{x i } H ∆ (s)<label>(9)</label></formula><p>No known method for computing S is faster than directly evaluating this expression because the order of G is unknown (recall that this computation is in G = Z × N /{±1} where N has unknown factorization; §2). Meanwhile, this exponent has bit length ≈2048 · M, for M the total size of the multiset S , i.e., it costs roughly the same as 25 · M constraints. (As discussed in the prior paragraph, given S it is inexpensive to compute the witness for batch removal, namely, S (∏ i H ∆ (x i ))// ). Even for large accumulators, this cost may be reasonable: as we show in Section 7, MultiSwap can easily save tens of millions of constraints compared to Merkle trees. On the other hand, proof generation can be parallelized <ref type="bibr" target="#b116">[121]</ref>, whereas at first glance the exponentiation in (9) appears to be strictly serial <ref type="bibr" target="#b20">[22,</ref><ref type="bibr" target="#b98">101]</ref>. We observe, however, that since g is fixed, a pre-computation phase can be used to sidestep this issue <ref type="bibr" target="#b31">[33]</ref>. Specifically, for some upper bound 2 m on the maximum size of the accumulator, the above exponent is at most 2 2048·2 m , so pre-computing the values g i = g 2 i·2 m , 0 ≤ i &lt; 2048 (via successive squaring) turns the above exponentiation into a 2048-way multi-exponentiation <ref type="bibr" target="#b88">[91]</ref> (which can be computed in parallel): for each g i , the exponent is a 2 m -bit chunk of the value ∏ s∈S{x i } H ∆ (s). Further parallelism is possible simply by computing more g i with closer spacing.</p><p>This precomputation also enables a time-space tradeoff, via windowed multi-exponentiation <ref type="bibr" target="#b88">[91,</ref><ref type="bibr" target="#b105">110]</ref>. In brief, when computing a multi-exponentiation over many bases, first split the bases into groups of size t and compute for each group a table of size 2 t . This turns t multiplications into a table lookup and one multiplication, for a factor of t speedup. t = 20 is rea-sonable, and reduces the cost of computing the exponentiation in (9) to roughly the equivalent of 1.25 · M constraints.</p><p>The above pre-computation is a serial process that requires ≈2048 · 2 m squarings in G. Assuming that 2048 squarings takes ≈2.5 milliseconds (i.e., the same amount of time as a general 2048-bit exponentiation; this is pessimistic), this precomputation takes ≈2 m · 2.5 milliseconds. For m = 20, this is ≈45 minutes; for m = 25, it is ≈1 day. Note, however, that this pre-computation is entirely untrusted, so it can be done once by anyone and reused indefinitely for the same g. Finally, the above precomputation requires materializing</p><formula xml:id="formula_19">∏ s∈S{x i } H ∆ (s)</formula><p>, which is 2 31 bits when M = 2 20 . This product can be expressed as a highly parallel computation; the final step is a multiplication of two, 2 <ref type="bibr" target="#b28">30</ref> -bit values, which can itself be parallelized via a Karatsuba-like approach.</p><p>We evaluate P 's witness generation costs in Section 7.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Applications of MultiSwap</head><p>In this section we discuss two applications of MultiSwap and compare constraint costs for these applications when implemented using Merkle swaps and MultiSwaps.</p><p>MultiSwap Costs. The first two rows of <ref type="figure" target="#fig_3">Figure 3</ref> model the costs of Merkle swaps and swaps computed via MultiSwap.</p><p>A Merkle swap requires hashing the old and new values and Merkle path verifications for each ( §2.1), so the number of hash invocations is logarithmic in the number of leaves.</p><p>For a MultiSwap, each swap requires a H ∆ invocation ( §4.2), which comprises an invocation of the underlying hash H and multiprecision arithmetic to compute the result and multiply it mod ( §4, <ref type="figure" target="#fig_2">Fig. 1</ref>). In addition, each swap is an input to H p , which requires another hash invocation. All of these costs are independent of the number of elements in the accumulator. MultiSwap also costs a large constant overhead, however; this is to generate ( §4.1) and check two Wesolowski proofs via modular exponentiations ( §2, §4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Verifiable outsourcing for smart contracts</head><p>Blockchain systems <ref type="bibr" target="#b24">[26]</ref> like Ethereum <ref type="bibr" target="#b51">[53]</ref> enable smart contracts: computations defined by a blockchain's users and executed as part of the block validation procedure. One application of smart contracts is implementing a form of verifiable state update ( §1): for global state Γ (stored on the blockchain) and a transaction γ (submitted by a user), the computation (1) checks that γ is valid according to some predicate, and if so (2) updates the global state to a new value Γ .</p><p>Consider, for example, a distributed payment system where Γ comprises a list of users and their public keys and balances. Transactions let users send payments to one another. When Alice wishes to send a payment, she constructs a transaction γ that includes (1) the target user; (2) the amount to send; and (3) a digital signature over the prior two items; she submits this to the smart contract, which verifies it and updates Γ.</p><p>A major practical limitation of this approach is that computation, storage, and network traffic are extremely expensive for smart contracts. <ref type="bibr" target="#b8">10</ref> One solution to this issue, Rollup <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b63">65,</ref><ref type="bibr" target="#b91">94]</ref>, is an instance of verifiable computation ( §2.2): the smart contract delegates the work of checking transactions to an untrusted aggregator, and then checks a proof that this work was done correctly. 11 To effect this, users submit transactions γ i to the aggregator rather than directly to the smart contract. The aggregator assembles these transactions into a batch {γ i }, then generates a proof π certifying the correct execution of a computation Ψ that verifies the batch and updates the global state from Γ to Γ . Finally, the aggregator submits π and Γ to the smart contract, which verifies the proof and stores the updated state. Checking this proof is substantially cheaper for the smart contract than verifying each transaction individually, and the exorbitant cost of smart contract execution justifies the aggregator's cost in generating the proof <ref type="bibr" target="#b110">[115]</ref>.</p><p>In more detail, the constraints C corresponding to Ψ ( §2.2) take the current state Γ as the input X and the updated state Γ as the output Y . P (i.e., the aggregator) supplies the batch {γ i } as part of the witness (i.e., the advice vector Z), meaning that the smart contract can verify the proof without reading {γ i }. This saves both computation and network traffic.</p><p>Notably, though, even reading Γ and Γ is too expensive for the smart contract, as is storing Γ on the blockchain. (Recall that verifying a proof requires work proportional to the size of the inputs and outputs; §2.2.) The original Rollup design <ref type="bibr" target="#b6">[7]</ref> addresses this by storing Γ in a Merkle tree ( §2.1). The inputs and outputs of C are just Merkle roots, and only this root is stored on the blockchain. Each leaf of this tree contains a tuple (pk, bal, #tx) comprising a user's public key, their balance, and a transaction count (which prevents replaying past transactions). The constraints that verify a transaction in C thus require two Merkle tree updates, one each for payer and payee. (Each update comprises two Merkle paths; §2.1).</p><p>We observe that a single MultiSwap ( §3) can replace all of the Merkle tree updates for a batch of transactions. In particular, MultiSwap's semantics guarantee sequential consistency of the transactions with respect to Γ and Γ . And whereas the per-swap cost of Merkle swaps increase logarithmically with the number of accounts stored in Γ, the per-swap cost of MultiSwap is essentially independent of the number of users. This means that for large batches of transactions and/or large numbers of users, a MultiSwap-based Rollup requires far fewer constraints than a Merkle-based one.</p><p>Costs. The middle two rows of <ref type="figure" target="#fig_3">Figure 3</ref> show costs for Rollup using Merkle and MultiSwap. Both cases pay to ver-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Number of constraints</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>System</head><p>Per-Operation Costs Per-Proof Costs  The approximate value of each parameter in our implementation ( §6, §7) is given in parentheses. See Section 5 for discussion.</p><formula xml:id="formula_20">Merkle swap 2(c H e + m · c H ) MultiSwap ( §3, §4) 2(c H e + c H in + c split + c + ( f ) + c × ) 4c e G (||) + 2c × G + c H p + c mod (b H ∆ )</formula><p>ify the payer's signature and ensure that the payer's balance is sufficient. The difference is in the swap costs, which are discussed above ( §5); Rollup requires two swaps per transaction, one each to update the payer's and payee's accounts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Efficient persistent RAM</head><p>Recall from Section 2.2 that Pantry-style RAM, while expensive, offers unique functionality: the ability to pass the full state of RAM from one proof to another. This enables computations over persistent state <ref type="bibr" target="#b30">[32]</ref>, recursively verifiable state machine execution <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b86">89]</ref>, and other useful applications. Unfortunately, the high cost (in constraints) of hash functions ( §6) limits the number of Pantry-style RAM operations that can be used in a computation-especially for large RAMs <ref type="bibr" target="#b30">[32,</ref><ref type="bibr" target="#b77">79,</ref><ref type="bibr" target="#b111">116]</ref>. In this section, we show how to use the batched RSA accumulator construction of Section 4 to address this issue. Our design yields a persistent RAM abstraction whose per-access constraint cost is lower than Pantry's even at modest RAM sizes, and is nearly insensitive to RAM size.</p><p>To begin, notice that Pantry's RAM abstraction essentially stores memory values in a fixed-size Merkle tree, executing a membership proof for each LOAD and a swap for each STORE. Moreover, since our goal is efficiency, our design will ideally check all memory operations using a small number of batched accumulator operations ( §4).</p><p>This seems to suggest the following (incorrect) approach.</p><p>First, replace the Merkle tree with an RSA accumulator, representing memory locations as addr, data tuples. Then, verify all LOAD and STORE operations in a batch using MultiSwap ( §3) as follows. For each LOAD from address δ, P supplies as advice the value ν purportedly stored at δ, and the constraints encode a swap that replaces the tuple δ, ν with itself. For each STORE of the value ν to address δ, P supplies as advice the value ν purportedly being overwritten, and the constraints encode the swap (δ, ν, δ, ν ). The reason this approach is incorrect is that it does not enforce the consistency of LOAD operations with program execution. In particular, recall ( §3) that MultiSwap(S, σ, S ) only guarantees that S is produced by a sequentially-consistent cycle-free subsequence σ ⊆ σ. Since LOAD operations are self-cycles, they are not included in σ . This use of MultiSwap thus only guarantees that σ correctly encodes STORE operations-LOADs can return any value.</p><p>We might attempt to fix this issue by checking LOAD operations using membership proofs. But this is inefficient: checking such a proof requires the constraints to materialize an accumulator that contains the value being loaded; meanwhile, the LOAD might correspond to a prior STORE, in which case the accumulator against which the proof must be checked would first have to be computed. In other words, this strategy makes batching accumulator operations impossible.</p><p>Our key insight is that a hybrid of the Pantry and BCGT approaches solves this issue. At a high level, our design enforces the correctness of LOAD and STORE operations using an address-ordered transcript ( §2.2) while ensuring that this transcript is consistent with the initial and final state of RAM using batched accumulator operations. As above, each memory location is stored in the accumulator as an addr, data tuple. As in BCGT-style RAM, the constraints build an executionordered transcript, P supplies an address-ordered transcript T , and the constraints ensure that T is correctly ordered, coherent, and a permutation of the execution-ordered transcript.</p><p>For the initial state of RAM, the constraints enforce consistency by ensuring that the first time an address δ is accessed in T , the tuple δ, ν is removed from the accumulator. If the first access is a LOAD, ν is the corresponding DATA value from T . Otherwise, P supplies as advice a claimed ν value such that δ, ν is in the accumulator. (For now, we assume that memory location δ has some corresponding tuple in the accumulator; we discuss uninitialized memory below.) Observe that this ensures consistency, because a removal is only possible if δ, ν is indeed in the accumulator.</p><p>For the final state of RAM, the constraints enforce consistency by ensuring that the last time an address δ is accessed in T , the tuple δ, ν is inserted into the accumulator. The value ν is the corresponding DATA value from T . Together with the above, this ensures that all of the accesses to address δ collectively result in the swap (δ, ν, δ, ν ).</p><p>Constraints for the above checks work as follows. First, for entry i in T , the constraints compute</p><formula xml:id="formula_21">h i,del = H ∆ (ADDR i , ν)</formula><p>and h i,ins = H ∆ (ADDR i , ν ) ( §4.2). Then, for each sequential pair of entries i, i + 1 in T , if ADDR i = ADDR i+1 , then entry i must be the last access to ADDR i and entry i + 1 must be the first access to ADDR i+1 . Finally, the constraints compute ∏ i∈F h i,del mod and ∏ i∈L h i,ins mod ( §4), the values inserted into and removed from the accumulator, respectively, for F the first-accessor set and L the last-accessor set.</p><p>Handling uninitialized memory. A remaining issue is how to handle the case where memory is uninitialized. Recall that in the BCGT approach, a LOAD not preceded by a STORE to the same address is serviced with a default value, say, 0. That does not work here, because this approach relies crucially on swapping old values for new ones, to ensure consistency with both the initial and final accumulators. A straightforward solution is to ensure that every memory location is initialized, by executing a setup phase that constructs an accumulator containing the tuple δ, 0 for every address δ. The cost of constructing this accumulator is high when the address space is large, since it amounts to one exponentiation per entry in RAM. Note, however, that this computation can be parallelized using the pre-computed values described in Section 4.4, and admits the same time-space tradeoff described in that section. <ref type="bibr" target="#b10">12</ref> Costs. The constraint costs of memory accesses are shown in the bottom two rows of <ref type="figure" target="#fig_3">Figure 3</ref>. The Merkle-based RAM requires two proofs of membership for each STORE, but only only one for each LOAD <ref type="bibr" target="#b30">[32]</ref>, so it is slightly cheaper than a Merkle swap-but logarithmic in RAM size.</p><p>The RSA accumulator-based RAM uses one MultiSwap for all LOADs and STOREs, with attendant per-operation costs (which are independent of RAM size; §5). It also incurs extra per-operation costs to check T as described above; these are logarithmic in the number of accesses but concretely very inexpensive ( §2.2, [116, <ref type="figure" target="#fig_5">Fig. 5</ref>; 79, Appx. B-A]).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Implementation</head><p>We implement a library comprising multiprecision arithmetic, Pocklington prime certification, RSA accumulators, and Merkle trees. This library extends Bellman <ref type="bibr">[9]</ref>, a library for building constraint systems and generating proofs using the pairing-based argument due to Groth <ref type="bibr" target="#b68">[70]</ref>. Based on this library, we implement two end-to-end applications: one that verifies a sequence of swaps, and one that verifies a batch of transactions for a distributed payment system ( §5.1).</p><p>We also implement or adapt four hash functions: MiMC [1], which costs 731 constraints (91 rounds of the x 7 permutation); Poseidon <ref type="bibr" target="#b67">[69]</ref>, which costs 316 constraints; Pedersen <ref type="bibr" target="#b70">[72,</ref><ref type="bibr" target="#b94">97]</ref>, which costs 2753 constraints (based on the JubJub elliptic curve <ref type="bibr" target="#b26">[28]</ref>), and SHA-256 <ref type="bibr" target="#b55">[57]</ref>, which costs 45567 constraints. We adapt the latter three hashes from Sapling <ref type="bibr">[104]</ref>. <ref type="bibr" target="#b11">13</ref> Finally, we implement custom Bellman constraint synthesizers (ConstraintSystems, in the jargon of Bellman) that allow us to quickly measure a constraint system's size and P 's cost computing a corresponding witness.</p><p>We use a 2048-bit RSA quotient group ( §2) modulo the RSA-2048 challenge number <ref type="bibr" target="#b74">[76,</ref><ref type="bibr" target="#b99">102]</ref>, and choose a random 2048-bit ∆ to define the division-intractable hash function H ∆ ( §4.2); we give concrete values in Appendix B. We synthesize all constraints over the BLS12-381 <ref type="bibr" target="#b25">[27]</ref> curve.</p><p>In total, our implementation comprises ≈11,300 lines of Rust. We have released it under an open-source license <ref type="bibr" target="#b8">[10]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Evaluation</head><p>We evaluate our MultiSwap implementation, comparing it to Merkle trees by answering the following questions:</p><p>δ for which no value exists, P supplies a proof of non-membership ( §2.1) for valid <ref type="bibr">[δ]</ref>, plus a default value. This obviates the setup phase, but requires additional constraints to (1) compute H ∆ (valid[ADDR i ]) for each entry in T , (2) check a batched non-membership proof, (3) check a batched insertion of valid <ref type="bibr">[·]</ref> values (which can be combined with the swap check), and (4) enforce correctness of the default value. Further exploration is future work. <ref type="bibr" target="#b11">13</ref> The costs of MiMC, Poseidon, and JubJub depend on the underlying elliptic curve; we target BLS12-381 <ref type="bibr" target="#b25">[27]</ref>. The cost of SHA-256 is ≈30% higher in Sapling than in prior work <ref type="bibr" target="#b0">[1]</ref>, but even the best reported costs are more than 10× the other hashes' costs. This discrepancy does not change our results: we focus on Poseidon, which is the best case for Merkle trees ( §7.1).</p><p>(1) How does the cost of a MultiSwap compare to the cost of Merkle swaps for a batch of swaps? In particular, what is the break-even point (i.e., the number of operations beyond which MultiSwap is cheaper), and how do costs compare for a fixed (large) constraint budget?</p><p>(2) What is the effect of hash function cost on the tradeoff between RSA accumulators and Merkle trees?</p><p>We answer the first question by synthesizing constraint systems for both MultiSwap and Merkle swaps, at varying set and batch sizes ( §7.1). We also synthesize constraints for the Rollup application ( §7.2) and compare the persistent RAM application using a cost model ( §7.3). Our cost metric is number of constraints; to validate this metric, we measure end-to-end times for MultiSwap and Merkle swaps ( §7.1).</p><p>For the second question, we evaluate the break-even point for MultiSwap versus the cost of the underlying hash function, for four different hash functions ( §7.1).</p><p>In sum, we find that MultiSwap breaks even for batch sizes of at most several thousand operations; for large sets, this value is several hundred. We also find that MultiSwap's advantage is greater when hashing is more expensive.</p><p>Baseline. Our baselines are constraint systems ( §2.2) that use Merkle trees ( §2.1) to store state. For each baseline, we fix capacity to be M = 2 m , for a range of m values. In all experiments except persistent RAM, the basic Merkle tree operation is a swap ( §5, <ref type="figure" target="#fig_3">Fig. 3</ref>). Merkle-based RAMs use a mix of membership proofs and swaps ( §2.1, §2.2); we discuss further in Section 7.3.</p><p>Setup. Except in the hash cost experiment ( §7.1), both Merkle and MultiSwap fix the hash function H ( §4.1, §4.2) as our Poseidon <ref type="bibr" target="#b67">[69]</ref> implementation ( §6). As we show in Section 7.1, this is the most favorable choice for the Merkle baseline, because Poseidon is inexpensive in constraints.</p><p>For execution time ( §7.1), our testbed has two Intel Xeon E5-2687Wv4 CPUs (12 physical cores per socket, 48 threads total) and 128 GiB of RAM, and runs Ubuntu 18.04. We compile with Rust 1.41-nightly (c9290dcee 2020-02-04) <ref type="bibr">[103]</ref>.</p><p>Method. Our primary cost metric is number of constraints, which we measure with a custom Bellman synthesizer ( §6).</p><p>We use this metric because P 's costs (both time and space) are dominated by constraint count in the back-ends we target ( §2.2). V 's costs are small and essentially constant.</p><p>To validate this metric, in Section 7.1 we measure P 's and V 's time for MultiSwap and Merkle swaps, for 2 20 -element sets. Limitations of the underlying Bellman and Sapling libraries ( §6) cause our MultiSwap and Merkle implementations to unnecessarily resynthesize all constraints when generating proofs. To sidestep this, for each experiment we measure total proving time (synthesis, witness computation, and proof generation), separately measure just synthesis time, and report the difference. Fixing this issue (by rewriting Bellman/Sapling) is future work.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">MultiSwap versus Merkle swaps</head><p>Benchmark. This experiment compares the costs of MultiSwap and Merkle trees for a computation comprising only swaps, varying the number of swaps and set size.</p><p>Constraint costs. <ref type="figure" target="#fig_4">Figure 4</ref> shows the results. The cost of Merkle trees varies with set size, because the number of hash invocations depends on this value ( §2.1; §5, <ref type="figure" target="#fig_3">Fig. 3</ref>). In contrast, the constraint cost of MultiSwap is independent of the number of elements in the set; for moderately sized sets (≈2 10 elements), the per-swap cost is less than for Merkle trees. On the other hand, MultiSwap pays a large overhead (≈11 million constraints) to evaluate H p and verify two Wesolowski proofs ( §4; §5, <ref type="figure" target="#fig_3">Fig. 3</ref>). Thus, MultiSwap requires some minimum batch size before it breaks even. For small sets (say, 2 5 elements) there is no break-even point; for sets with 2 10 or more elements, the break-even point is at most a few thousand swaps, and decreases with set size. <ref type="figure" target="#fig_5">Figure 5a</ref> shows the number of swaps that fit in 10 9 constraints, for different accumulators. (We compare at this size because it is close to the largest that prior work can handle <ref type="bibr" target="#b116">[121]</ref>.) Depending on set size, MultiSwap improves reachable batch sizes by up to ≈3.3×.  Proving and verifying time. <ref type="figure" target="#fig_6">Figure 6</ref> shows proving times (witness computation plus proof generation) for MultiSwap and Merkle with sets having 2 20 elements, for varying batch sizes. Verification costs ≈7 ms in all cases. MultiSwap has longer proving times for small batches but shorter times for large batches, and the break-even point between 1200 and 1600 swaps. This is slightly larger than in <ref type="figure" target="#fig_4">Figure 4</ref> because of the added cost of computing the new accumulator digest ( §4.4).</p><p>For an accumulator with 2 20 elements, computing a new digest after batch removal takes ≈43 seconds and uses ≈4 GiB of RAM via the preprocessing approach described in Section 4.4. For smaller accumulators this cost is correspondingly smaller. Larger accumulators have slower witness generation, which affects break-even batch size; we discuss in Section 9.</p><p>Effect of hash cost. <ref type="figure" target="#fig_7">Figure 7</ref> shows the effect of hash cost on MultiSwap's break-even point for sets of 2 20 elements (other set sizes are analogous; note that the axes are logarithmic). We measure MiMC, Poseidon, Pedersen/Jubjub, <ref type="bibr" target="#b12">14</ref> and SHA-256 ( §6). As expected, in all cases Merkle trees are cheaper for small numbers of operations. For the least expensive hash (Poseidon), MultiSwap's break-even point is the highest; as hash cost increases, so does MultiSwap's advantage. (We report results in all other experiments with Poseidon, which is the worst case for MultiSwap.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Application: payment system</head><p>Benchmark. This experiment compares the costs of MultiSwap and Merkle trees for the Rollup application described in Section 5.1. We measure cost versus the number of transactions (a signature verification, a validity check, and two swaps). Signatures use the scheme from ZCash <ref type="bibr" target="#b70">[72]</ref>.</p><p>Results. <ref type="figure" target="#fig_8">Figure 8</ref> shows the results. In contrast with the previous experiment, here all accumulator types pay a fixed overhead per transaction (this is dominated by signature verification), which reduces MultiSwap's per-transaction advantage. In this application, set size corresponds to the number of accounts. As in Section 7.1, MultiSwap does not break even for the smallest set size. The break-even point for 2 10 accounts is ≈2000 transactions, and ≈600 for 2 20 accounts. <ref type="figure" target="#fig_5">Figure 5b</ref> shows the number of transactions that fit in 10 9 constraints, for different accumulators. MultiSwap's advantage is as large as ≈1.9×, depending on set size. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Application: persistent RAM</head><p>Benchmark. This experiment compares the costs of MultiSwap-based and Pantry's <ref type="bibr" target="#b30">[32]</ref> Merkle-based persistent RAM 5.2. We compare using the cost model of <ref type="figure" target="#fig_3">Figure 3 ( §5)</ref>, which is derived from prior work <ref type="bibr" target="#b77">[79,</ref><ref type="bibr" target="#b111">116]</ref>; future work is to port Buffet's RAM compiler to Bellman and synthesize. We report cost versus RAM size.</p><p>Results. <ref type="figure" target="#fig_9">Figure 9</ref> shows the results. For Merkle-based RAM, bands in the figure represent varying write loads, from 0 (lowest cost) to 100% (highest cost). As in prior experiments, MultiSwap's cheaper per-operation cost yields a breakeven point of several thousand operations for a large RAM. This model includes the cost of memory consistency checks ( §2.2, §5.2, <ref type="figure" target="#fig_3">Fig. 3</ref>); these cost fewer than 100 constraints per operation and are thus negligible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related work</head><p>Verifiable computation. The literature on verifiable computation is both broad and deep; a somewhat recent survey <ref type="bibr" target="#b114">[119]</ref> gives a thorough treatment of the area's beginnings.</p><p>Our work builds most directly on xJsnark's <ref type="bibr" target="#b77">[79]</ref> multiprecision arithmetic and on the RAM primitives first described by Ben-Sasson et al. <ref type="bibr" target="#b10">[12]</ref> and further refined by Ben-Sasson et al. <ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b14">16]</ref>, in Buffet <ref type="bibr" target="#b111">[116]</ref>, and in xJsnark. Buffet and xJsnark both extend lines of work concerned with efficiently compiling high-level programs to constraints, including Pepper <ref type="bibr" target="#b102">[107]</ref>, Ginger <ref type="bibr" target="#b103">[108]</ref>, Pinocchio <ref type="bibr" target="#b93">[96]</ref>, and Pantry <ref type="bibr" target="#b30">[32]</ref>.</p><p>Several other works in this area deal with persistent state. Pantry <ref type="bibr" target="#b30">[32]</ref> was the first to use Merkle trees for stateful computations, and its persistent RAM primitive inspired ours ( §5.2). vSQL <ref type="bibr" target="#b118">[123]</ref> builds a verifiable subset of SQL, building on the interactive proofs of Goldwasser et al. <ref type="bibr" target="#b65">[67]</ref>, Cormode et al. <ref type="bibr" target="#b45">[47]</ref>, and Thaler <ref type="bibr" target="#b106">[111]</ref>, and on the polynomial commitments of <ref type="bibr">Papamanthou et al. [95]</ref>, which build on the work of Kate et al. <ref type="bibr" target="#b75">[77]</ref>. In contrast to the persistent RAM and multiset abstractions we develop, vSQL exposes a database abstraction; queries operate on all rows in parallel.</p><p>ADSNARK <ref type="bibr" target="#b3">[4]</ref> extends the Pinocchio <ref type="bibr" target="#b93">[96]</ref> SNARK to support operations on authenticated data provided by a third party. Geppetto <ref type="bibr" target="#b47">[49]</ref> also extends Pinocchio, allowing the verifier to commit to inputs for a specific computation and later verify a proof against that commitment, and also enabling data transfer between separate constraint systems bundled into one proof. Fiore et al. <ref type="bibr" target="#b54">[56]</ref> take Geppetto's commitments to inputs a step further, making them computation independent. In contrast to a multiset or persistent RAM abstraction, however, all of these systems require a number of constraints sufficient to read every input value-in other words, a multiset of size M implies at least M constraints. Further, they do not efficiently support programs whose multiset or RAM accesses depend on inputs and thus cannot be statically analyzed ( §2.2).</p><p>Spice <ref type="bibr" target="#b100">[105]</ref> aims to enable zero-knowledge auditing of concurrent services. Spice's amortized cost per state operation is ≈2× lower than ours for large batches, but its approach differs from ours in two key ways. First, Spice's core state verification primitive requires a number of constraints linear in the total size of the state; this cost is amortized over a batch of requests, each containing one or more state operations. In contrast, MultiSwap operations ( §3) have constraint costs that depend only on the number of state updates, not on total state size. Second, verification costs in Spice scale with the number of requests in a batch; in our work, verification cost is independent of batch size. Piperine <ref type="bibr" target="#b78">[80]</ref> optimizes Spice's state verification primitive and saves verification work by combining all requests from a batch into one proof; this yields verification cost independent of batch size.</p><p>Accumulators. Cryptographic accumulators <ref type="bibr" target="#b15">[17]</ref> based on RSA have a long history <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b38">40,</ref><ref type="bibr" target="#b79">81,</ref><ref type="bibr" target="#b82">84]</ref>. The recent work of Boneh et al. <ref type="bibr" target="#b22">[24]</ref> builds upon work by <ref type="bibr">Wesolowski [120]</ref> to construct batched membership and non-membership proofs for these accumulators. Our work builds directly on this line.</p><p>Merkle-based accumulators have also seen extensive study <ref type="bibr" target="#b36">[38,</ref><ref type="bibr" target="#b87">90]</ref>, and related structures have seen applications, e.g., in the blockchain <ref type="bibr" target="#b96">[99]</ref> and PKI contexts <ref type="bibr" target="#b97">[100]</ref>. These works all rely crucially on collision-resistant hashing, which is expensive when expressed as constraints ( §6, §7).</p><p>Two other lines of work build accumulators <ref type="bibr" target="#b37">[39,</ref><ref type="bibr" target="#b40">42,</ref><ref type="bibr" target="#b49">51,</ref><ref type="bibr" target="#b90">93]</ref> and vector commitments <ref type="bibr" target="#b39">[41,</ref><ref type="bibr" target="#b80">82,</ref><ref type="bibr" target="#b81">83]</ref> from bilinear maps. Elliptic curve operations and pairings appear to be very expensive when compiled to constraints <ref type="bibr" target="#b13">[15]</ref>, but these lines may nevertheless be an interesting direction for further study.</p><p>Prime generation. A long line of work <ref type="bibr" target="#b28">[30,</ref><ref type="bibr" target="#b29">31,</ref><ref type="bibr" target="#b66">68,</ref><ref type="bibr" target="#b72">74,</ref><ref type="bibr" target="#b73">75]</ref> aims to efficiently generate pseudorandom prime numbers. In some cases, uniformly distributed primes <ref type="bibr" target="#b57">[59]</ref> are desirable.</p><p>All of these proceed in "guess-and-check" fashion, which is inefficient when implemented in constraints (see §4.1). Most closely, Maurer <ref type="bibr" target="#b84">[87,</ref><ref type="bibr" target="#b85">88]</ref> and Shawe-Taylor <ref type="bibr" target="#b104">[109]</ref> describe prime generation methods based on Pocklington certificates; Clavier et al. <ref type="bibr" target="#b44">[46]</ref> optimize for embedded devices. To our knowledge, no prior work tackles this problem in our context.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Discussion and conclusion</head><p>We have shown that in verifiable state applications with moderate to large state, accessed thousands of times, RSA accumulators are less costly than Merkle trees.</p><p>There are two caveats: first, RSA accumulators require a trusted setup. In practice, most SNARKs <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b62">64,</ref><ref type="bibr" target="#b68">70,</ref><ref type="bibr" target="#b93">96]</ref> also require a trusted setup, so this is not a significant burden. Moreover, it is possible to mitigate trust requirements by generating an RSA modulus using a multiparty computation <ref type="bibr" target="#b23">[25,</ref><ref type="bibr" target="#b58">60]</ref>. A conjectured alternative that avoids trusted setup is a class group of imaginary quadratic order <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b33">35]</ref>; exploring efficient constraint implementations is future work.</p><p>Second, for very large sets (say, &gt; 2 25 ) P 's cost (in time) for advice generation is high ( §4.4). For small batch sizes, this cost overwhelms the time saved because of reduced constraint count. Note, however, that there will be some batch size at which RSA breaks even, since per-swap cost is smaller than Merkle for 2 10 elements. Moreover, reducing the number of constraints also reduces P 's RAM requirements; meanwhile, P 's advice generation task requires little memory. This means that even if an RSA accumulator requires greater total proving time than a Merkle tree, the RSA accumulator's use may still be justified because it reduces the amount of RAM P needs to generate a proof. Since RAM is a major bottleneck <ref type="bibr" target="#b111">[116,</ref><ref type="bibr" target="#b116">121]</ref> ( §1), such a time-space tradeoff may have significant practical benefit. Exploring this tradeoff is future work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Z 1,b−1 contain a purported bitwise expansion of X 1 , and likewise Z 2,0 . . . Z 2,b−1 and Z 3,0 . . . Z 3,b−1 for X 2 and Y , respectively. The first three constraints ensure that the assignment to Z meets this requirement provided that each Z i, j is assigned either 0 or 1; the remaining constraints ensure the latter. This operation is known as bit splitting; its cost for a b-bit value is b + 1, so the above program fragment costs 3 · b + 3 constraints in total. Comparisons and modular reductions also require bit splitting. Compiling conditionals to constraints requires expanding all branches into their corresponding constraints and selecting the correct result. Loops are similar; loop bounds must be statically known. For example, the program fragment if (x1 != 0) { y = x2 + 1 } else { y = x2 * 3 } compiles to the constraints</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Z 2 =</head><label>2</label><figDesc>1 by (2), Z 1 = X −1 1 by (1), and Y = 3 · X 2 by (5). Multiprecision arithmetic. xJsnark [79] describes tech- niques for compiling multiprecision arithmetic to efficient constraint systems. In brief, large integers are represented as a sequence of limbs in F p . The limb width, b l , is defined such that a b-bit number a is represented as η</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Insertion proof verification procedure ( §4), which checks that Q is a valid Wesolowski proof ( §2) for the exponentiation S = S ∏ i H ∆ (y i ) on challenge . To do so, it computes = H p (y 1 , . . . , y k ) (purple box, bottom left), computes ∏ i H ∆ (y i ) mod (red and blue boxes, top), computes the LHS of the verification equation (cyan boxes, bottom right), and checks that equation (black box, bottom right). H ∆ is a division-intractable hash function ( §4.2), H p is a hash to a prime ( §4.1), and G is an RSA quotient group ( §2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Constraint count models for Merkle swaps ( §2.1), MultiSwap ( §3, §4), Payments ( §5.1), and Persistent RAM ( §5.2). The approximate value of each parameter in our implementation ( §6, §7) is given in parentheses. See Section 5 for discussion.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Constraint count v. number of swaps ( §7.1). "Merkle m" denotes a Merkle tree with 2 m leaves.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Number of operations verifiable in 10 9 constraints (higher is better).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Witness computation plus proof generation time v. number of swaps, for accumulators with 2 20 elements ( §7.1).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Constraint count v. number of swaps, varying hash function ( §7.1). Merkle trees are all of depth 20.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Constraint count v. number of transactions ( §7.2). "Merkle m" denotes a Merkle tree with 2 m leaves.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Constraint count v. number of accesses ( §7.3). "Merkle m" denotes a Merkle tree with 2 m leaves. Ribbons indicate variation according to write load, from 0 to 100%.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>, H is division intractable if the range of H is Z, and it is infeasible for a PPT adversary to findˆxfindˆ findˆx and a set {x i } in</head><label></label><figDesc></figDesc><table>X such thatˆxthatˆ 

thatˆx ∈ {x i } and H( ˆ 
x) divides ∏ i H(x i ). A collision-
resistant hash function that outputs prime numbers is division 
intractable. We construct a different division intractable hash 
function in Section 4.2. 

</table></figure>

			<note place="foot">Alex Ozdemir and Riad Wahby, Stanford University; Barry Whitehat, Unaffiliated; Dan Boneh, Stanford University https://www.usenix.org/conference/usenixsecurity20/presentation/ozdemir Scaling Verifiable Computation Using Efficient Set Accumulators Alex Ozdemir Stanford Riad S. Wahby Stanford</note>

			<note place="foot" n="1"> When this protocol is made non-interactive via the Fiat-Shamir heuristic, the challenge must instead be drawn from the first 2 2λ primes [120; 23, §3.3].</note>

			<note place="foot" n="2"> The description in this section owes a textual and notational debt to the description in Buffet [116], which works in the same model.</note>

			<note place="foot" n="3"> We do not target STARK [11] (which uses a different C representation) or systems built on GKR [67] and CMT [47], e.g., vRAM [124], Hyrax [117], and Libra [122] (which restrict C in ways this work does not comprehend). 4 We do not target zero-knowledge applications in this work, but our techniques may be applicable in that setting when combined with prior zeroknowledge approaches for RSA accumulators [40]; this is future work.</note>

			<note place="foot" n="5"> An exception is a computation with an enormous number of memory accesses where Pantry would win. But the number of accesses to reach this asymptote is well beyond the reach of practical proof systems.</note>

			<note place="foot" n="6"> Proofs of non-membership ( §2.1) use similar primitives; we do not discuss them in detail because they are not necessary for MultiSwap. 7 This requires that we model the concrete hash function that outputs as a random oracle [8]; similar assumptions are common in practice. 2080 29th USENIX Security Symposium USENIX Association</note>

			<note place="foot" n="10"> Anecdotally, recent Ethereum prices [54] result in storage costs of more than $1 per kilobyte. Similarly, per-transaction costs are frequently in the $0.25 to $1 range even when executing minimal computation. 11 Rollup is distinct from Optimistic Rollup [58], which does not use cryptographic proofs and is not discussed in this paper.</note>

			<note place="foot" n="12"> An alternative solution is to implement, in essence, a shadow memory [92] indicating which addresses are valid. This is effected by storing a canary value valid[δ] in the accumulator for each address δ for which some tuple δ, · exists. If Ψ attempts to LOAD or STORE from a memory location</note>

			<note place="foot" n="14"> Our design ( §4) models the underlying hash function as a random oracle. Thus, Pedersen hashing should not be used for MultiSwap; we use it in this experiment only to demonstrate the effect of hash cost.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported in part by the NSF, the ONR, the Simons Foundation, the Stanford Center for Blockchain Research, and the Ripple Foundation. The authors thank Justin Drake, Srinath Setty, and Justin Thaler for helpful comments.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Proof of MultiSwap Consistency</head><p>Let σ denote a multiset of swaps. Let in σ denote {y : (x, y) ∈ σ} and let rm σ denote {x : (x, y) ∈ σ}. Claim 1. Let σ be a multiset of swaps and σ c be a cycle. MultiSwap(S, σ σ c , S ) holds if and only if MultiSwap(S, σ, S ) does.</p><p>Proof: We prove both directions simultaneously, by illustrating a bidirectional chain of mutually implicating equalities. We start with the definition of MultiSwap(S, σ σ c , S ):</p><p>Since σ c is a cycle, we have that in σ c = rm σ c , so rm σ c ⊆ S in σ c , and the removal of rm σ c can be moved earlier</p><p>This last line is exactly our goal: the statement that MultiSwap(S, σ, S ) holds. Claim 2. If σ contains no cycles and MultiSwap(S, σ, S ) holds, then σ is sequentially consistent with respect to S, producing S .</p><p>Proof: Let n be the number of swaps in σ. For a set S and multiset of swaps τ, define the directed multigraph G S,τ as a multigraph where the vertices are the universe of multiset elements, the edges point from each removal to its corresponding insertion, and each vertex is labeled with a multiplicity equal to to the multiplicity of that vertex's element in S, minus the out-degree, plus the in-degree. Observe that in G = G S,σ , the multiplicity of each vertex is equal to the multiplicity of that element in S . Furthermore, by the predicate MultiSwap(S, σ, S ) and the soundness of the proofs of insertions and removal, all multiplicities in G are non-negative.</p><p>We now construct the sequentially valid ordering of σ. Since σ has no swap cycles, G has no edge cycles. Thus, the edges of G can be topologically sorted such that all edges to a vertex occur before any edge from that vertex. We lift this edge order to a swap order, observing that in this swap order, all swaps inserting an element occur before all swaps removing it.</p><p>It suffices to show that when σ is applied to S in this order, each swap is valid. Let σ i denote the first i elements of σ in the aforementioned order. Thus, G S,σ n is equal to G. Furthermore, the order ensures for all i &gt; j and for all vertices v, the multiplicity of v in G S,σ i is at most the multiplicity of v in G S,σ j . Suppose that the i th element of this order, (x i , y i ) were invalid, where i ≤ n. This implies that the multiplicity of x i in G S,σ i is negative. This would imply that the multiplicity of x i in G S,σ n = G were negative, a contradiction. Thus no swap (x i , y i ) is invalid in this order. Proof of Lemma 1. The reverse direction follows immediately from the definition of MultiSwap.</p><p>We prove the forward direction by (strong) induction on the size of σ. Say that σ has no cycles. Then the lemma follows from Claim 2. Otherwise, let τ be a multiset of swaps and let σ c be a cycle such that σ = τ σ c . By Claim 1, MultiSwap(S, τ, S ) holds. Then, by the inductive hypothesis, τ can be decomposed into cycle-free τ and cycles τ c i such that τ = τ i τ c i and τ is sequentially consistent with respect to S, producing S . By observing that τ ( i τ c i ) σ c is a decomposition of σ into a cycle-free swap multiset and cycles, we conclude this direction of the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Parameter Values</head><p>Our RSA accumulators work in G = Z × N /{±1}, where N is the RSA-2048 challenge number <ref type="bibr" target="#b99">[102]</ref> <ref type="table">, N=0xc7970ceedcc3  b0754490201a7aa613cd73911081c790f5f1a8726f46355  0bb5b7ff0db8e1ea1189ec72f93d1650011bd721aeeacc2  acde32a04107f0648c2813a31f5b0b7765ff8b44b4b6ffc  93384b646eb09c7cf5e8592d40ea33c80039f35b4f14a04  b51f7bfd781be4d1673164ba8eb991c2c4d730bbbe35f59  2bdef524af7e8daefd26c66fc02c479af89d64d373f4427  09439de66ceb955f3ea37d5159f6135809f85334b5cb181  3addc80cd05609f10ac6a95ad65872c909525bdad32bc72  9592642920f24c61dc5b3c3b7923e56b16a4d9d373d8721  f24a3fc0f1b3131f55615172866bccc30f95054c824e733</ref> a5eb6817f7bc16399d48c6361cc7e5.</p><p>We randomly selected a 2048-bit offset ∆ for our divisionintractable hash H ∆ ( §4.2); we use the value ∆=0xf3709c40 772816d668926cae548ffea31f49034ab1b30fb84b595ca 6c126a6646a4341abea2f8b07bf8d366801ac293e5a286a bb43accdec39ac8f0bc599519cf1e532f9c70b5406c4b65 2ca7da4e1cb102b69953841ae20d4bcab055c5338487ba0 0fe95e821abd381b191dfb77bae3e022ccd818d4064882d 28481ffa2db45093a4deab05f6ebfbadcf11afe7369caea aaf1f02572348a17f0510b333b8a2d56e67d892f1e1182b 26301d9347ae0a900cff2a0979caddb1a86e04a6cbc9704 d6549e5b3aef0d5c3dc4aba648ed421b0ba37c3f8e8edc1 2ef42b86d8e5fbc0dbd903238ca2e9ed6873ccb68e8103b 5d01b4249bfbe8e70cb4f4983f41df8c8f.</p><p>Our evaluation ( §7) builds on the BLS12-381 elliptic curve <ref type="bibr" target="#b25">[27]</ref>, which is the Barreto-Lynn-Scott curve <ref type="bibr" target="#b5">[6]</ref> with parameter z = -0xd201000000010000 whose subgroup order is p = 0x73eda753299d7d483339d80809a1d80553bda40 2fffe5bfeffffffff00000001. This is the characteristic of the field F p for which we synthesize constraints.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Albrecht</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Grassi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rechberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tiessen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2016-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Ligero: Lightweight sublinear arguments without a trusted setup</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ames</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hazay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Ishai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Venkitasubramaniam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2017-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Checking computations in polylogarithmic time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Babai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Fortnow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Szegedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM STOC</title>
		<imprint>
			<date type="published" when="1991-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">ADSNARK: Nearly practical and privacy-preserving proofs on authenticated data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Barbosa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fiore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Reischuk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2015-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Collision-free accumulators and fail-stop signature schemes without trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Bari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Pfitzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="1997-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Constructing elliptic curves with prescribed embedding degrees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">S L M</forename><surname>Barreto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lynn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCN</title>
		<imprint>
			<date type="published" when="2003-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<ptr target="https://github.com/barryWhiteHat/roll_up" />
		<title level="m">roll_up: Scale ethereum with SNARKs</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Random oracles are practical: A paradigm for designing efficient protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="1993-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bellman-Bignat</surname></persName>
		</author>
		<ptr target="https://github.com/alex-ozdemir/bellman-bignat" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Scalable zero knowledge with no trusted setup</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Bentov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Horesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Riabzev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2019-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Fast reductions from RAMs to delegatable succinct constraint satisfaction problems: extended abstract</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ITCS</title>
		<imprint>
			<date type="published" when="2013-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">SNARKs for C: Verifying program executions succinctly and in zero knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Virza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2013-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Aurora: Transparent succinct arguments for R1CS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Riabzev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Spooner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Virza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">P</forename><surname>Ward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2019-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Scalable zero knowledge via cycles of elliptic curves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Virza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2014-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Succinct non-interactive zero knowledge for a von neumann architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ben-Sasson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Virza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2014-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">One-way accumulators: A decentralized alternative to digital sinatures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Benaloh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>De Mare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="1994-05" />
		</imprint>
	</monogr>
	<note>extended abstract</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Mathematical theory of connecting networks and telephone traffic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Beneš</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics in Science and Engineering</title>
		<imprint>
			<date type="published" when="1965" />
			<publisher>Elsevier Science</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Bitansky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ITCS</title>
		<imprint>
			<date type="published" when="2012-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Checking the correctness of memories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Blum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">S</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Gemmell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Naor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<imprint>
			<date type="published" when="1991-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Verifiable computation using multiple provers. Cryptology ePrint Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Thaler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2014/846" />
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">846</biblScope>
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Verifiable delay functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bonneau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bünz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Fisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2018-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">A survey of two verifiable delay functions. Cryptology ePrint Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bünz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Fisch</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2018/712" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Batching techniques for accumulators with applications to IOPs and stateless blockchains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bünz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Fisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2019-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Efficient generation of shared RSA keys (extended abstract)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Franklin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1997-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">SoK: Research perspectives and challenges for bitcoin and cryptocurrencies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bonneau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Kroll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">W</forename><surname>Felten</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2015-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">BLS12-381: New zk-SNARK elliptic curve construction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bowe</surname></persName>
		</author>
		<ptr target="https://electriccoin.co/blog/new-snark-curve/" />
		<imprint>
			<date type="published" when="2017-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Cultivating Sapling: Faster zk-SNARKs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bowe</surname></persName>
		</author>
		<ptr target="https://electriccoin.co/blog/cultivating-sapling-faster-zksnarks/" />
		<imprint>
			<date type="published" when="2017-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Zexe: Enabling decentralized private computation. Cryptology ePrint Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bowe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Miers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wu</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2018/962" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On generation of probable primes by incremental search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1993-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Speeding up prime number generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Landrock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="1993-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Verifying computations with state</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Feldman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2013-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Fast exponentiation with precomputation (extended abstract)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">F</forename><surname>Brickell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename><surname>Mccurley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Wilson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="1993-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">New primality criteria and factorizations of 2 m ± 1</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Brillhart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">H</forename><surname>Lehmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Selfridge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comp</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">130</biblScope>
			<biblScope unit="page" from="620" to="647" />
			<date type="published" when="1975-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A survey on IQ cryptography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Buchmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hamdy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Public Key Cryptography and Computational Number Theory</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Bulletproofs: Short proofs for confidential transactions and more</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bünz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bootle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Poelstra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Wuille</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Maxwell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2018-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Transparent SNARKs from DARK compilers. Cryptology ePrint Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bünz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Fisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Szepieniec</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2019/1229" />
		<imprint>
			<date type="published" when="1229" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Strong accumulators from collision-resistant hashing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Camacho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hevia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Kiwi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Opazo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISC</title>
		<imprint>
			<date type="published" when="2008-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">An accumulator based on bilinear maps and efficient revocation for anonymous credentials</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Camenisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Soriente</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC</title>
		<imprint>
			<date type="published" when="2009-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Dynamic accumulators and application to efficient revocation of anonymous credentials</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Camenisch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lysyanskaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2002-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Vector commitments and their applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Catalano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fiore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC</title>
		<imprint>
			<date type="published" when="2013-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Edrax: A cryptocurrency with stateless transaction validation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chepurnoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2018/968" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Marlin: Preprocessing zkSNARKs with universal and updatable SRS. Cryptology ePrint Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Maller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mishra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Vesely</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Ward</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2019/1047" />
		<imprint>
			<date type="published" when="1047" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Fractal: Post-quantum and transparent recursive proofs from holography. Cryptology ePrint Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ojha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Spooner</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2019/1076" />
		<imprint>
			<date type="published" when="1076" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Cluster computing in zero knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Virza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2015-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Generating provable primes efficiently on embedded devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Clavier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Feix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Thierry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PKC</title>
		<imprint>
			<date type="published" when="2012-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Practical verified computation with streaming interactive proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Thaler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ITCS</title>
		<imprint>
			<date type="published" when="2012-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Security analysis of the Gennaro-Halevi-Rabin signature scheme</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-S</forename><surname>Coron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Naccache</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2000-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Geppetto: Versatile verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Costello</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kreuter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Naehrig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zahur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2015-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Modular design of secure yet practical cryptographic protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J F</forename><surname>Cramer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-01" />
		</imprint>
		<respStmt>
			<orgName>Universiteit van Amsterdam</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Supporting non-membership proofs with bilinear-map accumulators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Damgård</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Triandopoulos</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/2008/538" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="volume">538</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Cinderella: Turning shabby X.509 certificates into elegant anonymous credentials with the magic of verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Delignat-Lavaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2016-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ethereum</surname></persName>
		</author>
		<ptr target="https://ethereum.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
				<ptr target="https://ethgasstation.info" />
		<title level="m">ETH Gas Station</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">How to prove yourself: Practical solutions to identification and signature problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1987-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Hash first, argue later: Adaptive verifiable computations on outsourced data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fiore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Ohrimenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2016-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Secure hash standard. NIST FIPS PUB 180-4</title>
		<imprint>
			<date type="published" when="2015-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Ethereum smart contracts in L2: Optimistic rollup</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Floersch</surname></persName>
		</author>
		<ptr target="https://medium.com/plasma-group/ethereum-smart-contracts-in-l2-optimistic-rollup-2c1cef2ec537" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Close to uniform prime number generation with fewer random bits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-A</forename><surname>Fouque</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tibouchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="2014-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Fast distributed RSA key generation for semi-honest and malicious adversaries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">K</forename><surname>Frederiksen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Lindell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Osheter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Pinkas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2018-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Zø: An optimizing distributing zero-knowledge compiler</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fredrikson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Livshits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2014-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">AuroraLight: Improved prover efficiency and SRS size in a sonic-like system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gabizon</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2019/601" />
	</analytic>
	<monogr>
		<title level="m">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<title level="m" type="main">PLONK: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gabizon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">J</forename><surname>Williamson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Ciobotaru</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2019/953" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
	<note>Cryptology ePrint Archive</note>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Quadratic span programs and succinct NIZKs without PCPs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2013-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m" type="main">Optimistic vs. ZK rollup: Deep dive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gluchowski</surname></persName>
		</author>
		<ptr target="https://medium.com/matter-labs/optimistic-vs-zk-rollup-deep-dive-ea141e71e075" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
		<title level="m" type="main">GNU multiple precision arithmetic library</title>
		<ptr target="https://gmplib.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Delegating computation: interactive proofs for muggles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Goldwasser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">T</forename><surname>Kalai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">N</forename><surname>Rothblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM STOC</title>
		<imprint>
			<date type="published" when="2008-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Strong primes are easy to find</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="1985-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Starkad and Poseidon: New hash functions for zero knowledge proof systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Grassi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kales</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Khovratovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rechberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schofnegger</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2019/458" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">On the size of pairing-based non-interactive arguments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Groth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2016-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Factoring integers with elliptic curves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hendrik</forename><forename type="middle">W</forename><surname>Lenstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics</title>
		<imprint>
			<biblScope unit="volume">126</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="649" to="673" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<title level="m" type="main">Zcash protocol specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hopwood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bowe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hornby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Wilcox</surname></persName>
		</author>
		<ptr target="https://github.com/zcash/zips/blob/master/protocol/protocol.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">On strong pseudoprimes to several bases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Jaeschke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematics of Computation</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="issue">204</biblScope>
			<biblScope unit="page" from="915" to="926" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Fast generation of prime numbers on portable devices: An update</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Joye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHES</title>
		<imprint>
			<date type="published" when="2006-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Efficient generation of prime numbers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Joye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Paillier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Vaudenay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CHES</title>
		<imprint>
			<date type="published" when="2000-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<title level="m" type="main">RSA factoring challenge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kaliski</surname></persName>
		</author>
		<editor>H. C. A. van Tilborg</editor>
		<imprint>
			<date type="published" when="2005" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Constant-size commitments to polynomials and their applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kate</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Zaverucha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASIACRYPT</title>
		<imprint>
			<date type="published" when="2010-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">TRUESET: Faster verifiable set computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Sayed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Triandopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2014-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">xJsnark: A framework for efficient verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2018-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Replicated state machines without replicated execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Nikitin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Setty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2020-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Universal accumulators with efficient nonmembership proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Xue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACNS</title>
		<imprint>
			<date type="published" when="2007-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Functional commitment schemes: From polynomial commitments to pairing-based accumulators from simple assumptions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Libert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>Ramanna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICALP</title>
		<imprint>
			<date type="published" when="2016-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Concise mercurial vector commitments and independent zero-knowledge sets with short proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Libert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2010-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">Secure accumulators from euclidean rings without trusted setup</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lipmaa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACNS</title>
		<imprint>
			<date type="published" when="2012-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Maller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bowe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kohlweiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Meiklejohn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2019-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Fast generation of secure RSA-moduli with almost maximal diversity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><forename type="middle">M</forename><surname>Maurer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="1990-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Fast generation of prime numbers and secure public-key cryptographic parameters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><forename type="middle">M</forename><surname>Maurer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="123" to="155" />
			<date type="published" when="1995-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<monogr>
		<title level="m" type="main">Coda: Decentralized cryptocurrency at scale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Meckler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shapiro</surname></persName>
		</author>
		<ptr target="https://cdn.codaprotocol.com/v2/static/coda-whitepaper-05-10-2018-0.pdf" />
		<imprint>
			<date type="published" when="2018-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">A digital signature based on a conventional encryption function</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">C</forename><surname>Merkle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1988-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">Algorithms for multi-exponentiation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Möller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAC</title>
		<imprint>
			<date type="published" when="2001-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">How to shadow every byte of memory used by a program</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Nethercote</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Seward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VEE</title>
		<imprint>
			<date type="published" when="2007-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Accumulators from bilinear pairings and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CT-RSA 2005</title>
		<imprint>
			<date type="published" when="2005-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<monogr>
		<title level="m" type="main">On-chain scaling to potentially ~500 tx/sec through mass tx validation</title>
		<ptr target="https://ethresear.ch/t/on-chain-scaling-to-potentially-500-tx-sec-through-mass-tx-validation/3477" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">Signatures of correct computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Tamassia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TCC</title>
		<imprint>
			<date type="published" when="2013-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Pinocchio: Nearly practical verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gentry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Raykova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2013-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Non-interactive and information-theoretic secure verifiable secret sharing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">P</forename><surname>Pedersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="1992-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">Probabilistic algorithm for testing primality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Number Theory</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="128" to="138" />
			<date type="published" when="1980-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b96">
	<analytic>
		<title level="a" type="main">Improving authenticated dynamic dictionaries, with applications to cryptocurrencies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Reyzin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Meshkov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chepurnoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ivanov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FC</title>
		<imprint>
			<date type="published" when="2017-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b97">
	<analytic>
		<title level="a" type="main">Efficient asynchronous accumulators for distributed PKI</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Reyzin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Yakoubov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCN</title>
		<imprint>
			<date type="published" when="2016-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b98">
	<monogr>
		<title level="m" type="main">Time-lock puzzles and timed-release crypto</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Wagner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-03" />
		</imprint>
		<respStmt>
			<orgName>MIT LCS</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b99">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rsa</forename><surname>The</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Numbers</surname></persName>
		</author>
		<ptr target="https://web.archive.org/web/20130921041734/http://www.emc.com/emc-plus/rsa-labs/historical/the-rsa-challenge-numbers.htm" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b100">
	<analytic>
		<title level="a" type="main">Proving the correct execution of concurrent services in zero-knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Angel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2018-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b101">
	<analytic>
		<title level="a" type="main">Resolving the conflict between generality and plausibility in verified computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroSys</title>
		<imprint>
			<date type="published" when="2013-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b102">
	<analytic>
		<title level="a" type="main">Making argument systems for outsourced computation practical (sometimes)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T V</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mcpherson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2012-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b103">
	<analytic>
		<title level="a" type="main">Taking proof-based verified computation a few steps closer to practicality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T V</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Panpalia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2012-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b104">
	<analytic>
		<title level="a" type="main">Generating strong primes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shawe-Taylor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electronics Letters</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">16</biblScope>
			<biblScope unit="page" from="875" to="877" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b105">
	<analytic>
		<title level="a" type="main">Addition chains of vectors (problem 5125)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">G</forename><surname>Straus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Amer. Math. Monthly</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="page" from="806" to="808" />
			<date type="published" when="1964" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b106">
	<analytic>
		<title level="a" type="main">Time-optimal interactive proofs for circuit evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Thaler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2013-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b107">
	<monogr>
		<title level="m" type="main">Verifiable computation with massively parallel interactive proofs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Thaler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Roberts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mitzenmacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pfister</surname></persName>
		</author>
		<editor>HotCloud</editor>
		<imprint>
			<date type="published" when="2012-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b108">
	<analytic>
		<title level="a" type="main">A hybrid architecture for interactive verifiable computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T V</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2013-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b109">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Wahby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Howald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Garg</surname></persName>
		</author>
		<title level="m">Verifiable ASICs</title>
		<imprint>
			<date type="published" when="2016-05" />
		</imprint>
	</monogr>
	<note>IEEE S&amp;P</note>
</biblStruct>

<biblStruct xml:id="b110">
	<analytic>
		<title level="a" type="main">Full accounting for verifiable outsourcing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Wahby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shelat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Thaler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Walfish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wies</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CCS</title>
		<imprint>
			<date type="published" when="2017-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b111">
	<analytic>
		<title level="a" type="main">Efficient RAM and control flow in verifiable outsourced computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Wahby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T V</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2015-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b112">
	<analytic>
		<title level="a" type="main">Doubly-efficient zkSNARKs without trusted setup</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Wahby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Tzialla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shelat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Thaler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Walfish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2018-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b113">
	<analytic>
		<title level="a" type="main">A permutation network</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Waksman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="159" to="163" />
			<date type="published" when="1968-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b114">
	<analytic>
		<title level="a" type="main">Verifying computations without reexecuting them: from theoretical possibility to near practicality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Walfish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Blumberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the Association for Computing Machinery</title>
		<imprint>
			<date type="published" when="2015-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b115">
	<analytic>
		<title level="a" type="main">Efficient verifiable delay functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wesolowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUROCRYPT</title>
		<imprint>
			<date type="published" when="2019-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b116">
	<analytic>
		<title level="a" type="main">DIZK: A distributed zero knowledge proof system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chiesa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security</title>
		<imprint>
			<date type="published" when="2018-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b117">
	<analytic>
		<title level="a" type="main">Libra: Succinct zero-knowledge proofs with optimal prover computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO</title>
		<imprint>
			<date type="published" when="2019-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b118">
	<analytic>
		<title level="a" type="main">vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2017-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b119">
	<analytic>
		<title level="a" type="main">vRAM: Faster verifiable RAM with program-independent preprocessing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Papadopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Papamanthou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE S&amp;P</title>
		<imprint>
			<date type="published" when="2018-05" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
