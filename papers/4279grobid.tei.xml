<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:09+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. Data Recovery from &quot;Scrubbed&quot; NAND Flash Storage: Need for Analog Sanitization Data Recovery from &quot;Scrubbed&quot; NAND Flash Storage: Need for Analog Sanitiza- tion</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Md</roleName><forename type="first">Mehedi</forename><surname>Hasan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Electrical and Computer Engineering Department</orgName>
								<orgName type="institution">The University of Alabama</orgName>
								<address>
									<settlement>Huntsville</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Biswajit</forename><surname>Ray</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Electrical and Computer Engineering Department</orgName>
								<orgName type="institution">The University of Alabama</orgName>
								<address>
									<settlement>Huntsville</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Md</roleName><forename type="first">Mehedi</forename><surname>Hasan</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">The University of Alabama in Huntsville</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Biswajit</forename><surname>Ray</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">The University of Alabama in Huntsville</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. Data Recovery from &quot;Scrubbed&quot; NAND Flash Storage: Need for Analog Sanitization Data Recovery from &quot;Scrubbed&quot; NAND Flash Storage: Need for Analog Sanitiza- tion</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the 978-1-939133-17-5</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Digital sanitization of flash based non-volatile memory system is a well-researched topic. Since flash memory cell holds information in the analog threshold voltage, flash cell may hold the imprints of previously written data even after digital sanitization. In this paper, we show that data is partially or completely recoverable from the flash media sanitized with &quot;scrubbing&quot; based technique, which is a popular technique for page deletion in NAND flash. We find that adversary may utilize the data retention property of the memory cells for recovering the deleted data using standard digital interfaces with the memory. We demonstrate data recovery from commercial flash memory chip, sanitized with scrubbing, by using partial erase operation on the chip. Our results show that analog scrubbing is needed to securely delete information in flash system. We propose and implement analog scrubbing using partial program operation based on the file creation time information.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Secure deletion of obsolete data from the storage medium is a topic of paramount importance to ensure the privacy and security of the data owner. According to the Data Protection Act (DPA) 2018, the deletion of information must be real i.e. the content should not be recoverable in any way. However, achieving true deletion of user data from the physical storage medium is not always straightforward and it depends critically on the analog characteristics of the specific non-volatile storage elements.</p><p>In this paper, we evaluate the secure deletion concept in NAND flash based non-volatile storage system. NAND flash memory finds a ubiquitous place in today's computing and storage landscape. Flash memory is widely used in personal electronic gadgets including smartphones, solid state drives, laptops, tablets, USB memory sticks, SD memory cards, etc. Due to the increasing popularity of flash as non-volatile storage media, the concept of secure deletion or sanitization of flash media is getting even more important.</p><p>NAND flash exhibits certain unique challenges for secure deletion due to its special characteristics. First, write operation in flash takes place at page level granularity while erase operation happens at block level which requires all the pages in a block to be deleted at the same time. Because of the mismatch in granularity between erase operations and program operations in flash, in-place update of a page is very resource expensive. Second, NAND flash requires erase-before-write constraint, which makes overwriting operation very unfriendly, given the mismatch in granularity between erase and write operation. Third, NAND flash has finite endurance meaning only a fixed number of program and erase operation are allowed on a NAND block. Thus, the flash controller is typically designed to minimize erase operation and ensure wear-leveling of all the memory blocks. In other words, erasing a block for in-place update of a page is not a common practice.</p><p>Since in-place updates are not possible in NAND flash, the standard overwrite-based erasure techniques, typically used for hard drives, does not work properly for NAND storage system. Instead, NAND storage usually perform logical sanitization (i.e., the data is not retrievable via the SATA or SCSI interface) by invalidating the page address of obsolete data. The page address mapping in NAND storage is handled by an intermediate firmware layer called Flash Translation Layer (FTL), which performs one-to-one mapping between logical page address and the physical memory address of the flash media. Thus, for any page update operation, FTL will write the new contents to another physical page (or sector) location and update the address table map so that the new data appears at the target logical address. As a result, the old version of the data remains in the physical storage medium, which can be retrieved by the adversary with advanced memory interfaces.</p><p>In order to achieve page-level deletion in flash based storage, the idea of "data scrubbing" was proposed by Wei et al <ref type="bibr" target="#b0">[1]</ref>.</p><p>The key concept behind "scrubbing" based sanitization is the creation of an all-zero page (or all cells programmed), which is equivalent to deletion of data from that page. Since it is not possible to remove charge from the floating gates at page level granularity, "scrubbing" provides an alternative route to digital sanitization by programming all the cells in the page. However, in this paper, we show that the deleted data is partially or completely recoverable after "scrubbing" due to the analog property of the programmed cells. More specifically, programmed cells in flash continuously lose charge due to fundamental data retention characteristics. As a result, the zero bits (or programmed bits) in the original data loses a portion of the stored charge at the time of erase operation. We call these zero bits as weak zeros since they have slightly lower threshold voltage compared to the freshly written bits. During "scrubbing" a new set of zero bits are created by newly programming the erased cells in the original data. We label the freshly written zeros as "strong zeros" because they have higher threshold voltage compared to the original zero bits (weak zeros) in the data. Thus, careful analysis of the analog threshold voltage of the memory cells in a scrubbed page will reveal the original data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contribution:</head><p>Our key contributions in this paper are as follows: 1) We demonstrate that data is partially or fully recoverable from "scrubbing" based deleted page. We use partial erase operation on a "scrubbed" page to recover the deleted data.</p><p>2) We find that fundamental data retention (or charge loss) characteristics of flash cells should be taken into account during "scrubbing" to ensure true deletion of data.</p><p>3) We propose a new analog "scrubbing" technique in order to make sure data remains unrecoverable after deletion. The proposed technique utilizes the time difference between write and erase operation in order to program the erased bits. This will minimize the threshold voltage differences among the cells in the erased page.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Background</head><p>In this section, we will describe the fundamentals of flash memory cell, its operation, and NAND flash system design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Flash Memory Organization and Operations</head><p>Flash Cell: <ref type="figure" target="#fig_0">Figure 1</ref> (a) shows the device structure of a flash memory cell, which is essentially made of floating gate MOSFET (Metal Oxide Semiconductor Field Effect Transistor). Electrons placed on a floating gate are trapped because the floating gate is isolated electrically from the control gate and the transistor channel by blocking oxide and tunnel oxide respectively. Thus, a flash memory cell stores information in the form of charges (electrons) for an extended period of time without requiring any power supply.</p><p>NAND Array: Flash memory is organized as two-dimensional arrays of floating gate transistors. A number of cells connected in series, in a column, form a string (see <ref type="figure" target="#fig_0">Figure  1</ref>(b)), which is electrically connected to the metal bit line at one end and grounded at the other end. Cells in a row are electrically connected through a metal Word Line (WL) and constitute a page. The size of a page varies from 2-16K byte depending on manufacturer. There can be multiple pages per metal wordline depending on the storage technology. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Flash Translation Layer (FTL)</head><p>In order to efficiently manage the NAND array's special characteristics, a firmware layer called flash translation layer (FTL) <ref type="bibr" target="#b2">[3]</ref>- <ref type="bibr" target="#b4">[5]</ref> is typically used by the storage system which interfaces the host file system with the raw NAND memory. FTL provides a block access interface to the host file system by mapping the logical addresses in block layer to physical addresses in NAND flash. In addition, FTL contains firmware module for garbage collection and wear leveling <ref type="bibr" target="#b2">[3]</ref>- <ref type="bibr" target="#b4">[5]</ref>. The garbage collection module periodically reclaims all the invalid pages in the media in order to perform block erase operation, which will free-up memory space for new data. The wear-leveling module manages the limited endurance of the flash media by ensuring uniform program-erase operation on all the blocks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Threat model and Assumptions</head><p>Adversary Model: We assume the adversary has one-time access to the flash memory device. In addition, we assume that adversary can perform multiple read and erase operations on the content of the flash. We also assume that adversary aims to illegitimately derive sensitive information which is not available through a "legitimate" interface. For example, we assume adversary has access to the raw NAND memory chip and he/she can perform low level memory operation, such as partial erase, shifted read or read retry, etc.</p><p>Assumption: We assume adversary can read the data from the NAND flash without any error correction. Most of the NAND chips do not include error correction engine on the memory chip. Instead, the ECC engine is typically included in the FTL. We also assume that adversary can access the NAND flash chip with bypassing the FTL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Data Retrieval after Scrubbing</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Data Retention (DR)</head><p>Flash memory technology has finite data retention characteristics as the stored charge on the floating gate (and trapped electrons in the oxides) continuously leaks through surrounding oxides <ref type="bibr" target="#b5">[6]</ref>- <ref type="bibr" target="#b7">[8]</ref>. Because of DR, when data is stored and kept for some time, the programmed state cell tends to lose its charge and its threshold becomes lower. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association 29th USENIX Security Symposium 1401</head><p>the data retention effects on the í µí± í µí±¡ distribution for SLC type of storage. In <ref type="figure" target="#fig_2">Figure 3</ref>(a), there are two states: erase state and programmed state. Flash manufacturers keep enough voltage margin between the two states. The read reference voltage is typically chosen in the middle of the voltage margin. When the cell voltage is greater than the reference voltage, it reads as logic zero and when the cell voltage is lower than this, the data is read as one. In <ref type="figure" target="#fig_2">Figure 3</ref>(b) we show the DR effect on the cell í µí± í µí±¡ distribution. Usually, program state í µí± í µí±¡ distribution moves down with DR, while erase state í µí± í µí±¡ distribution remains almost the same. If the data retention time is not large (less than 1-2 years), the program state will still be read as zero even after down-shift of cell í µí± í µí±¡ distribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Scrubbing after Data Retention</head><p>When data scrubbing is applied for page level sanitization after DR, all the data of the page becomes zero. It is important to note that even though all the bits are read as zero digitally, their threshold voltage distribution will have significant and detectable differences. In <ref type="figure" target="#fig_2">Figure 3</ref>(c), the data retention effect on the "scrubbing" process is explained. When scrubbing operation is applied to a page, which has gone through a finite time of data retention, only the erased cells are programmed.</p><p>The zeros in the original data remain at the same í µí± í µí±¡ . However, the newly written zero has higher threshold than the old zeros as old zeros already lose some of their charges. In <ref type="figure" target="#fig_2">Fig- ure 3(c)</ref>, the red zeros are the old zeros which have a lower threshold distribution than the black zeros which have a higher threshold distribution. Thus, the data retention property is the key characteristic to identify the same logical zero as weak zero and strong zero based on their threshold voltage distribution. In other words, if scrubbing is done immediately after writing the data, the difference between old and new zeros will be minimal and it will be difficult to recover the data. If the time difference between write and scrubbing is high, there will be a higher chance that data will be recoverable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Partial Erase</head><p>We utilized partial erase of a block in order to recover the scrubbing based deleted data. A full erase is the process where all the bits in a memory block turn into the logic state "1". The datasheet of the specific flash chip reports the typical erase time of a block. If the erase operation is interrupted in between by issuing a "RESET" command, then the operation is called partial erase. Partial erase will lower down the í µí± í µí±¡ distribution of the programmed cells in step by step, which provides a method to distinguish the strong vs weak zeros using standard digital interfaces. Alternative methods exist in order to determine the cell í µí± í µí±¡ by using digital interfaces, such as read retry, which involves counting fail bits with shifted read levels <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b9">[10]</ref>. However, many SLC NAND chips do not include read retry feature. Hence partial erase offers a more generic method to distinguish weak vs strong zeros.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Data Recovery with Partial Erase</head><p>The adversary can utilize the partial erase operation to distinguish between strong and weak zeros on a fully scrubbed page (meaning all the data being zeros). For example, if the adversary performs partial erase on a fully scrubbed page with fine resolution of erase time, the weak zeros will first turn into ones while the strong zeros will still be read as zeros. Thus, adversary can recover the original data by distinguishing the strong and weak zeros on a deleted page.</p><p>In <ref type="figure" target="#fig_3">Figure 4</ref> we illustrate the data recovery process with an Einstein image (binary) as an example. We first store the binary image in a NAND block (Toshiba SLC Part # TC58NVG3S0F). The size of the image is 276,000 bytes and it requires 64 SLC pages for getting stored in the memory. In order to accelerate the data retention effects, we then bake the NAND chip at high temperature (120°C) for 3 hours and read back the image data. <ref type="figure" target="#fig_3">Figure 4(b)</ref> shows the post-bake Einstein image. From a digital viewpoint, there is no difference between the pre-bake Einstein image and the post bake one. Retrieve data from each page of target block using partial erase (Retrievepage); 1:</p><p>Issue NAND block erase command; 2:</p><p>Apply time delay (í µí±¡ í µí± í µí± ); 3:</p><p>Issue RESET command (FFh); 4:</p><p>Issue READ command to read NAND flash data; 5:</p><p>Save the retrieved bytes;</p><p>However, the analog threshold voltage of the memory bits holding the data in <ref type="figure" target="#fig_3">Figure 4</ref> perform partial erase operation on the scrubbed image to recover back the original data. Partial erase operation will shift down the í µí± í µí±¡ distribution of both strong and weak zeros in such a way that the memory read operation with a fixed reference voltage will identify most of the weak zeros as one bits and most of the strong zeros as zero bits (see <ref type="figure" target="#fig_3">Figure 4</ref>(h)). We invert the bit map after partial erase operation and plot the recovered image in <ref type="figure" target="#fig_3">Figure 4</ref>(d).</p><p>Algorithm 1 briefly describes the command sequence used for data retrieval process. First, we select a block where data was stored for some time and then scrubbed recently. So, all the data is read as 0 with standard NAND read command. Then, according to the data storing information (i.e. the time when the data stored and scrubbed), we calculate the optimal partial erase time (PEtime). And, then upon applying the precise time delay for the partial erase process, we also issue the NAND Read operation to read data from a specified page. The data read after the partial erase is essentially the inverted version of original stored data. So, we invert the data and save as Retrievepage data. And the final stopping criteria requires 90% of the data become in the erased state. Until this requirement fulfills, the partial operation will continue for the specific block and keep saving data from the specified page for each partial erase operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Analog Scrubbing</head><p>In principle, analog sanitization of the flash media will ensure true destruction of the stored data. Analog sanitization of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Original image Scrubbed image</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>After few days</head><p>Image after DR semiconductor memory is always challenging because there are many electronic processes that leave imprints of remnant data on the device characteristics <ref type="bibr" target="#b10">[11]</ref>- <ref type="bibr" target="#b12">[13]</ref>. The block erase operation of the NAND flash device is closer to the analog sanitization of the flash media, as it ensures information is lost by removing the floating gate charge from the programmed cells. However, due to fundamental array architecture of NAND flash, there is no equivalent page-level erase command that converts all the bits in a page into erased bits. Hence developing analog scrubbing method is essential in order to securely delete page data in the NAND array. In this work, we propose the analog sanitization method of NAND memory pages using the history of data creation such as page creation time. The basic idea is to create an all-zero page (similar to digital scrubbing) with the additional constraint that all the zero bits have undistinguishable analog threshold voltage distribution. We implement this idea using partial program technique as described in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scrubbing</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Partial Page Program</head><p>A NAND page generally takes ~100-1000 µs to be fully programmed based on different technology. The partial page program method on a NAND page is typically implemented by issuing a NAND RESET command after the NAND write command. The RESET command will forcibly stop the NAND write operation before its stipulated time. As a result, the memory cells get programmed to a lower threshold voltage level than the corresponding fully programed threshold level. In addition, introducing a time delay (í µí±¡ í µí± í µí± ) between the NAND write command and the RESET command, it is possible control the analog threshold voltage of the partially programmed cells.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Analog Scrubbing with Partial Page Program</head><p>The goal of analog scrubbing is to match the threshold voltage distribution of the original zero bits and the newly created zero bits during page scrubbing. The challenge here is to estimate the partial program time during scrubbing which depends on the mean threshold voltage value of the original zeros of the page. Hence the knowledge of page creation time and an accurate model for data retention characteristics of the memory chip will be critical to implement this method.</p><p>Algorithm 2 explains the process of analog scrubbing, where we estimate the program time for analog scrubbing process based on data retention information. Note that NAND flash has a default page program time tPROG of ~100-1000 µs. We first select a block where some data has been stored previously and select a page to be read. In this method, depending on the data retention information, program time delay í µí±¡ í µí± í µí± is defined for a page (í µí±¡ í µí± í µí± ≤ tPROG). Then we issue the NAND write operation to implement the analog scrubbing. In this case, some of the bit might not be programmed, so if the percent of bit programmed is less than 97%, this process will take place again until the criteria fulfills. After performing scrubbing in this way, difference between 0's threshold voltage distribution is not noticeable, and an adversary is not able to recover the data from this page fully or partially.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Implementation and Evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Experimental set-up</head><p>A custom design hardware board is used in order to interface the commercial off the shelf flash chips with the computer. The board contains a socket to hold the flash chip under test and an FT2232H (Future Technology Devices International Ltd) break-out board for USB communication. For the evaluation purpose, we have used SLC NAND flash memory chips from different flash manufacturers including Toshiba, Micron, and Samsung. The exact part number for all the chips used is listed in <ref type="table">Table 1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Data Retrieval Efficiency after Scrubbing</head><p>We evaluate the data recovery efficiency from a digitally sanitized all zero page in <ref type="figure" target="#fig_5">Figure 5</ref>. The key parameter in the data recovery process is the precise control of the partial erase time. If the duration of erasure is kept long, most of the bits will be erased (similar to standard block erase operation). On the flip side, if the erase duration is too small, then most of the bits will remain in zero states. <ref type="figure" target="#fig_5">Figure 5(a)</ref> illustrates the gradual data recovery process as a function of erase duration. For a clear illustration, we plot the impact of partial erase time on strong vs weak zeros separately in <ref type="figure" target="#fig_5">Figure 5(b)</ref>. For complete recovery of the scrubbed image, it is required that all the weak zeros (zero bits of the original image) are converted to ones while all the strong zeros (one bits of the original image) remain at zero state. Due to overlap in the í µí± í µí±¡ distribution of the strong vs weak zeros, a partial recovery of the original image is possible in practice. For example, in the <ref type="figure" target="#fig_5">Fig- ure 5(b)</ref> we found that at the beginning of erase operation weak zeros turned into ones much faster than the strong zeros.</p><p>However, a significant percentage of strong zeros also flip to ones before all the weak zeros are flipped. Hence there is a narrow window of opportunity for the partial erase duration that ensures recovery of most of the original data.</p><p>We define bit accuracy as a new metric for recovered image which measures the percentage of correctly identified bits of the original image data after partial erase operation. We find that there is an optimum erase duration that gives the highest bit accuracy. Please note that a completely scrubbed image (all zero bits or all one bits) will also have a bit accuracy approximately 50% assuming equal number of zeros and ones in the image. However, in order to recognize an image, the correctly identified positions also play a significant role. Hence in <ref type="figure" target="#fig_5">Figure 5</ref>(a) we find that even though the bit accuracy of the recovered image is low for certain erase duration, the image is correctly recognizable. The other important point to note here is that the maximum bit accuracy is a function of data retention time or the storage history of the image. Typically, the longer the duration of high temperature bake in our experiment (or older the stored data), the separation between í µí± í µí±¡ distribution of strong vs weak zeros will be wider. This will increase the bit accuracy of the recovered image. <ref type="figure">In Fig- ure 6</ref> we plot the maximum bit accuracy of the recovered image for different high temperature bake time. We find that the longer the bake duration, the higher the bit accuracy. Note that the maximum bit accuracy of the recovered image corresponding to different bake time is a function different partial erase duration.</p><p>We have performed the evaluation of a partial erase based image recovery on chips from different flash manufacturers and found that the partial erase method works for those chips which have longer block erase time. The block erase time of NAND flash chip is defined in the datasheet by the manufacturer i.e. í µí±¡ í µí°¸í µí± and typically í µí±¡ í µí°¸í µí± varies from ~1-10 ms. The longer the block erase time, it is easier to control the partial erase operation using the digital interface. Note that the partial erase operation is implemented using our measurement set-up as follows: we issue a block erase operation for a specified NAND block and then we issue the NAND RESET (FFh) command after certain pre-defined time delay (í µí±¡ í µí± í µí± ). The RESET command takes a finite time (few hundreds of microseconds) to forcibly terminate the erase operation. In addition, the effective time for the pre-mature termination of erase operation depends on the delays associated with issuing commands by the digital interface. Hence the minimum value of the partial erase duration is limited by the time corresponding to the RESET command and the delays associated with the digital interface. For some of the chips as listed in <ref type="table">Table 1</ref>  we found that the minimum value of partial erase duration is comparable to the block erase time, and hence the NAND block gets completely erased after the partial erase operation with í µí±¡ í µí± í µí± = 0í µí± . Thus, the data recovery process could not be successfully implemented on those chips using our experimental set-up. A faster digital interface is needed in order to implement data recovery algorithm on those chips with lower block erase time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Effectiveness of Analog Scrubbing</head><p>In order to show the effectiveness of the proposed analog scrubbing, we perform the following step-by-step experiments. First, we write the same Einstein image on a NAND block and bake it for 3 hours at 120°C to emulate the data retention effects. We then create an all zero page using partial programming technique. The partial program duration is calculated based on memory's data retention characteristics. We then repeat the partial erasure based data retrieval process (as discussed in Section 6.2) on the scrubbed image. The results are shown in <ref type="figure">Figure 7</ref>. We find that recovered image is difficult to be identified compared to the fully scrubbed image. These results show the prospect of analog scrubbing technique for the true deletion of data. However, the accurate implementation requires careful characterization of partial program duration as a function of data retention time, which remains a topic for future investigation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Related Work on NAND Sanitization Methods</head><p>In this section we provide a brief overview of the state-ofthe-art sanitization methods for NAND flash memory systems. Since in-place updates are not possible in NAND flash, the standard multiple overwrite-based erasure techniques, typically used for hard drives, do not work properly for NAND storage system. Instead, following methods are typically employed by NAND controller for sanitization:</p><p>• Block erase: Block erasure method is a basic NAND command to remove data from all the pages of a NAND block. The method essentially removes electronic charge from the flash cells and hence physically erase the data from the NAND media. Typically, during garbage collection process this method is used to remove old invalid data once the drive is almost full <ref type="bibr" target="#b2">[3]</ref>- <ref type="bibr" target="#b4">[5]</ref>. Thus, this command is sparingly used by a NAND controller. However, there are certain sanitization proposals which use this command for secure deletion <ref type="bibr" target="#b13">[14]</ref>- <ref type="bibr" target="#b15">[16]</ref>. The major drawback of block erasure based methods is the poor performance caused by the significant valid data migration overhead <ref type="bibr" target="#b15">[16]</ref>. The other bottleneck for the frequent block erasure is the finite endurance limit of NAND flash technology. Thus, block erasure based immediate page deletion techniques are not a practical and efficient solution for NAND storage. • Logical sanitization: Since block erasure methods suffer from poor performance, NAND storage usually performs logical sanitization by invalidating the page address of obsolete data. The page address mapping in NAND storage is handled by FTL, which performs oneto-one mapping between logical page address and the physical memory address of the flash media. Thus, for any page update operation, FTL will write the new contents to another physical page (or sector) location and update the address table map so that the new data appears at the target logical address. As a result, the old version of the data remains in the physical storage medium, which can be retrieved by the adversary.</p><p>• Encryption based sanitization: Several authors have recently proposed NAND sanitization methods based on an encryption technique <ref type="bibr" target="#b16">[17]</ref>- <ref type="bibr" target="#b21">[22]</ref>. The basic idea in this method is to encrypt the user file with an encryption key and store the encrypted data and the key in two separate NAND blocks. Secure deletion is achieved by removing the keys, which can be done efficiently as keys require smaller memory space. Even though encryption based techniques are quite fast, they suffer from the following drawbacks. First, encryption based technique carries the risk of data recovery as its implementation may have certain issues, such as random number generation (for encryption key) which can be compromised by a motivated adversary <ref type="bibr" target="#b22">[23]</ref>. Second, encryption based sanitization requires proper sanitization of key storage block and any other derived values that might be useful in cryptanalysis. Third, several existing storage solutions and resource constrained embedded platforms may not include any encryption/decryption module and hence cannot implement this technique.</p><p>• Scrubbing or zero-overwrite based digital sanitization: In order to achieve page-level deletion in flash based storage, the idea of "data scrubbing" was proposed <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b23">[24]</ref>. The key concept behind "scrubbing" based sanitization is the creation of an all-zero page (or all cells programmed), which is equivalent to the deletion of data from that page. Thus, "scrubbing" provides an alternative route to digital sanitization by programming all the cells in the page. However, we have shown in this paper that the scrubbed data is partially or completely recoverable due to the analog property of the programmed cells.</p><p>• History independent erase: Recently, several researchers have proposed secure NAND deletion methods which will not only remove data from the storage medium but also conceal deletion history from the system <ref type="bibr" target="#b24">[25]</ref>- <ref type="bibr" target="#b26">[27]</ref>. For example, Jia et al. <ref type="bibr" target="#b25">[26]</ref> proposed undetectable secure deletion in flash system by using a partial scrubbing technique and removing any structural artifacts of past deletion operation from the flash system. Similarly, Chen et al. <ref type="bibr" target="#b26">[27]</ref> designed HiFlash, a history independent flash device, which will remove all the history related artifacts in the flash layout.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion</head><p>In this paper, we show that digitally sanitized (zero overwrite based "scrubbing") NAND flash storage media still maintains the previously written information in the analog threshold voltage characteristics. The data retention property of the flash memory cells causes difference in the analog threshold voltage of the original zero bits in the data and the newly created zeros during scrubbing. We experimentally demonstrate that the difference in the analog threshold voltage can be exploited to recover the deleted data from a fully scrubbed allzero page. We utilize partial erase technique to recover the deleted data and our evaluation shows more than 75% bits are recoverable depending on the specification of the NAND chip, memory cell's data retention characteristics and the nature of the image data. Finally, we describe a new method for analog sanitization of NAND memory pages using page creation time and partial program technique. Our evaluation shows promise of the proposed technique for analog sanitization and true deletion of user data from the flash media.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: (a) A floating gate (FG) NAND flash memory cell which stores information in the form of charge on the FG. Metal word-line (WL) act as the control gate of the FG transistor. Charge is injected on the FG through tunneling of electron from Si-channel to FG. Blocking oxide prevents back tunneling of electron to control gate. (b) The hierarchical storage in NAND flash array consisting of kilo-bytes of memory cells and the WL electrically connects those cells (called a page of information). Each block consists of multiple WLs. The select gate transistors can be standard MOSFET or FG transistors, depending on manufacturer or technology node. (c) Typical threshold voltage distribution for erase state cell and programmed state cell.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: (a) The architecture of a flash-based storage system. (b) File system overview of storage system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: (a) Threshold voltage distribution of memory cells for stored '1' and '0'. Programmed state has a higher threshold than the erased state. (b) Down-shift of threshold distribution of programmed state due to data retention effect. (c) Threshold voltage distribution difference between weak '0' and strong '0'. The newly programmed cell has a higher threshold than the old one.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>(a) and the Figure 4 (</head><label>4</label><figDesc>b) are dis- tinctively different as illustrated with the downshifted thresh- old voltage distribution of zero bits in Figure 4(f). Next, we perform the scrubbing based deletion operation and read the data back. Figure 4(c) shows the deleted image. As expected from a scrubbed NAND data, the image looks completely black or all the bits of the image are at zero state. However, in terms of analog threshold voltage, there is an important distinction between the zero bits. The original zero bits have slightly lower threshold voltage than the newly created zero bits, even though digitally both are read as zeros. Finally, we</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Data recovery from scrubbed pages. (a) Original Einstein image (460 × 600) which is stored to the NAND flash. (b) Original image after data retention takes place (c) Scrubbed image, this is all '0' image. We bake the chip for 3 hours in an oven of temperature 120°C in order to accelerate the data retention effect. (d) The raw image recovered using partial erase operation. (e), (f), (g) &amp; (h) Threshold voltage distribution for corresponding image of (a), (b), (c) &amp; (d).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: (a) Illustration of bit accuracy of a recovered image vs partial erase time. The image was scrubbed with zerooverwrite method after 3 hours of bake at 120°C. (b) For clear illustration, we plot the percentage of weak zeros that flipped into ones as well as the percentage of strong zeros that remained at zero state with respect to erase time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :Figure 7 :</head><label>67</label><figDesc>Figure 6: Bit recovery accuracy versus bake time for stored Einstein image on two different NAND flash chips.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>,</head><label></label><figDesc></figDesc><table>Part # 
Manufacturer 
Block erase 
time (tER) 

RESET time (Erase) 
Bit recovery efficiency 

TC58NVG3S0F 
Toshiba 
3ms 
500µs 
77.54% 
MT29F8G08ABACA 
Micron 
2ms 
500µs 
53.72% 
K9F2G08X0A 
Samsung 
1.5ms 
500µs 
-
MT29F4G08ABADA 
Micron 
700µs 
500µs 
-

Table 1: Evaluation of bit recovery efficiency on different NAND chips. 

Weak/Strong 

zero 

accuracy 

(%) 

Erase time (ms) 

Bit 

accuracy 

(%) 

Erase time (ms) 

</table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Reliably Erasing Data from Flash-based Solid State Drives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">M</forename><surname>Grupp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">E</forename><surname>Spada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Swanson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX Conference on File and Stroage Technologies</title>
		<meeting>the 9th USENIX Conference on File and Stroage Technologies<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="8" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Program interference in MLC NAND flash memory: Characterization, modeling, and mitigation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">F</forename><surname>Haratsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 IEEE 31st International Conference on Computer Design (ICCD)</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="123" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Solid-State Drives: Memory Driven Design Methodologies for Optimal Performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zuolo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Zambelli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Micheloni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Olivo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="2017-09" />
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="page" from="1589" to="1608" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Software Support Inside and Outside Solid-State Devices for High Performance and High Efficiency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="2017-09" />
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="page" from="1650" to="1665" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Reliability of SolidState Drives Based on NAND Flash Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">R</forename><surname>Mielke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Frickey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Kalastirsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Quan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ustinov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">J</forename><surname>Vasudevan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="2017-09" />
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="page" from="1725" to="1750" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Error Characterization, Mitigation, and Recovery in Flash-Memory-Based Solid-State Drives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">F</forename><surname>Haratsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="2017-09" />
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="page" from="1666" to="1704" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Reviewing the Evolution of the NAND Flash Technology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Compagnoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Goda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename><surname>Spinelli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Feeley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">L</forename><surname>Lacaita</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Visconti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="2017-09" />
			<biblScope unit="volume">105</biblScope>
			<biblScope unit="page" from="1609" to="1633" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Characterizing flash memory: Anomalies, observations, and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">M</forename><surname>Grupp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2009 42nd Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="24" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Enabling Accurate and Practical Online Flash Channel Modeling for Modern MLC NAND Flash Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">F</forename><surname>Haratsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE J. Sel. Areas Commun</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="2294" to="2311" />
			<date type="published" when="2016-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Threshold voltage distribution in MLC NAND flash memory: Characterization, analysis, and modeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">F</forename><surname>Haratsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automation Test in Europe Conference Exhibition (DATE)</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1285" to="1290" />
		</imprint>
	</monogr>
	<note>in 2013 Design</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Data Remanence in Semiconductor Devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Gutmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Secure Deletion of Data from Magnetic and Solid-state Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Gutmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Conference on USENIX Security Symposium</title>
		<meeting>the 6th Conference on USENIX Security Symposium<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="8" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Data Remanence in Flash Memory Devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Skorobogatov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th International Conference on Cryptographic Hardware and Embedded Systems</title>
		<meeting>the 7th International Conference on Cryptographic Hardware and Embedded Systems<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="339" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">User-level Secure Deletion on Log-structured File Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Reardon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Marforio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Capkun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th ACM Symposium on Information</title>
		<meeting>the 7th ACM Symposium on Information<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="63" to="64" />
		</imprint>
		<respStmt>
			<orgName>Computer and Communications Security</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">TrueErase: per-file secure deletion for the storage data path</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Diesburg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<publisher>ACSAC</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Models and Design of an Adaptive Hybrid Scheme for Secure Deletion of Data in Consumer Electronics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">H</forename><surname>Noh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Consum. Electron</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Data Node Encrypted File System: Efficient Secure Deletion for Flash Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Reardon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Capkun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="333" to="348" />
		</imprint>
	</monogr>
	<note>presented at the Presented as part of the 21st {USENIX} Security Symposium ({USENIX} Security 12</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">On Secure Data Deletion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Reardon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Capkun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Secur. Priv</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="37" to="44" />
			<date type="published" when="2014-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">SoK: Secure Data Deletion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Reardon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Capkun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="301" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Secure deletion for NAND flash file system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Heo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">Y</forename><surname>Shin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACMSymposium on Applied Computing</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">DEFTL: Implementing Plausibly Deniable Encryption in Flash Translation Layer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="2217" to="2229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">SADUS: Secure data deletion in user space for mobile devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Secur</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="612" to="626" />
			<date type="published" when="2018-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">When Good Randomness Goes Bad: Virtual Machine Reset Vulnerabilities and Hedging Deployed Cryptography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Yilek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Ndss &apos;10 (network and Distributed Security Symposium)</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Scrubbing-Aware Secure Deletion for 3-D NAND Flash</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kuo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput.-Aided Des. Integr. Circuits Syst</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="2790" to="2801" />
			<date type="published" when="2018-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Sanitizing Data is Not Enough!: Towards Sanitizing Structural Artifacts in Flash Media</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32Nd Annual Conference on Computer Security Applications</title>
		<meeting>the 32Nd Annual Conference on Computer Security Applications<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="496" to="507" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">NFPS: Adding Undetectable Secure Deletion to Flash Translation Layer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th ACM on Asia Conference on Computer and Communications Security</title>
		<meeting>the 11th ACM on Asia Conference on Computer and Communications Security<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="305" to="315" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">HiFlash: A History Independent Flash Device</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sion</surname></persName>
		</author>
		<idno>abs/1511.05180</idno>
	</analytic>
	<monogr>
		<title level="j">ArXiv</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
