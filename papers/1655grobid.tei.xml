<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:06+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Ad Hoc Synchronization Considered Harmful</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weiwei</forename><surname>Xiong</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of California</orgName>
								<orgName type="institution" key="instit2">San Diego †University of Illinois at Urbana-Champaign *Intel</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soyeon</forename><surname>Park</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of California</orgName>
								<orgName type="institution" key="instit2">San Diego †University of Illinois at Urbana-Champaign *Intel</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiaqi</forename><surname>Zhang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of California</orgName>
								<orgName type="institution" key="instit2">San Diego †University of Illinois at Urbana-Champaign *Intel</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of California</orgName>
								<orgName type="institution" key="instit2">San Diego †University of Illinois at Urbana-Champaign *Intel</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhiqiang</forename><surname>Ma</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of California</orgName>
								<orgName type="institution" key="instit2">San Diego †University of Illinois at Urbana-Champaign *Intel</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Ad Hoc Synchronization Considered Harmful</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Many synchronizations in existing multi-threaded programs are implemented in an ad hoc way. The first part of this paper does a comprehensive characteristic study of ad hoc synchronizations in concurrent programs. By studying 229 ad hoc synchronizations in 12 programs of various types (server, desktop and scientific), including Apache, MySQL, Mozilla, etc., we find several interesting and perhaps alarming characteristics: (1) Every studied application uses ad hoc synchronizations. Specifically, there are 6-83 ad hoc synchronizations in each program. (2) Ad hoc synchronizations are error-prone. Significant percentages (22-67%) of these ad hoc synchronizations introduced bugs or severe performance issues. (3) Ad hoc synchronization implementations are diverse and many of them cannot be easily recognized as synchronizations, i.e. have poor readability and maintainability. The second part of our work builds a tool called SyncFinder to automatically identify and annotate ad hoc synchronizations in concurrent programs written in C/C++ to assist programmers in porting their code to better struc-tured implementations, while also enabling other tools to recognize them as synchronizations. Our evaluation using 25 concurrent programs shows that, on average, SyncFinder can automatically identify 96% of ad hoc syn-chronizations with 6% false positives. We also build two use cases to leverage SyncFinder&apos;s auto-annotation. The first one uses annotation to detect 5 deadlocks (including 2 new ones) and 16 potential issues missed by previous analysis tools in Apache, MySQL and Mozilla. The second use case reduces Valgrind data race checker&apos;s false positive rates by 43-86%.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Synchronization plays an important role in concurrent programs. Recently, partially due to realization of multicore processors, much work has been conducted on synchronization in concurrent programs. For example, various hardware/software designs and implementations have been proposed for transactional memory (TM) <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b39">40]</ref> as ways to replace the cumbersome "lock" operations. Similar to TM, some new language constructs <ref type="bibr" target="#b45">[46,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b11">12]</ref> such as Atomizer <ref type="bibr" target="#b11">[12]</ref> have also been proposed to address the atomicity problem. On a different but related note, various tools such as AVIO <ref type="bibr" target="#b26">[27]</ref>, CHESS <ref type="bibr" target="#b30">[31]</ref>, CTrigger <ref type="bibr" target="#b35">[36]</ref>, ConTest <ref type="bibr" target="#b5">[6]</ref> have been built to detect or expose atomicity violations and data races in concurrent programs. In addition to atomicity synchronization, condition variables and monitor mechanisms have also been studied and used to ensure certain execution order among multiple threads <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b21">22]</ref>.</p><p>So far, most of the existing work has targeted only the synchronizations implemented in a modularized way, i.e., directly calling some primitives such as "lock/unlock" and "cond wait/cond signal" from standard POSIX thread libraries or using customized interfaces implemented by programmers themselves. Such synchronization methods are easy to recognize by programmers, or bug detection and performance profiling tools.</p><p>Unfortunately, besides modularized synchronizations, programmers also use their own ad hoc ways to do synchronizations. It is usually hard to tell ad hoc synchroniztions apart from ordinary thread-local computations, making it difficult to recognize by other programmers for maintenance, or tools for bug detection and performance profiling. We refer to such synchronization as ad hoc synchronization. If a program defines its own synchronization primitives as functional calls and then uses these functions throughout the program for synchronization, then we do not consider these primitives as ad hoc, since they are well modularized.</p><p>Ad hoc synchronization is often used to ensure an intended execution order of certain operations. Specifically, instead of calling"cond wait()" and "cond signal()" or other synchronization primitives, programmers often use ad hoc loops to synchronize with some shared variables, referred to as sync variables. According to programmers' comments, they are implemented this way due to either flexibility or performance reasons. <ref type="figure" target="#fig_0">Figure 1</ref>(a)(b)(c)(d) show four real world examples of ad hoc synchronizations from MySQL, Mozilla, and OpenLDAP. In each example, a thread is waiting for some other threads by repetitively checking on one or more shared variables, i.e. sync variables. Each case has its own specific implementation, and it is also not obviously apparent that a thread is synchronizing with another thread.</p><p>Unfortunately, there have been few studies on ad hoc  synchronization. It is unclear how commonly it is used, how programmers implement it, what issues are associated with it, whether it is error-prone or not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Contribution 1: Ad Hoc Synchronization Study</head><p>In the first part of our work, we conduct a "forensic investigation" of 229 ad hoc synchronizations in 12 concurrent programs of various types (server, desktop and scientific), including Apache, MySQL, Mozilla, OpenLDAP, etc. The goal of our study is to understand the characteristics and implications of ad hoc synchronization in existing concurrent programs.</p><p>Our study has revealed several interesting, alarming and quantitative characteristics as follows:</p><p>(1) Every studied concurrent program uses ad hoc synchronization. More specifically, there are 6-83 ad hoc synchronizations implemented using ad hoc loops in each of the 12 studied programs. The fact that programmers often use ad hoc synchronization is likely due to two primary reasons: (i) Unlike typical atomicity synchronization, when coordinating execution order among threads, the intended synchronization scenario may vary from one to another, making it hard to use a common interface to fit every need (more discussion follows below and in Section 2); (ii) Performance concerns make some of the heavy-weight synchronization primitives less applicable.</p><p>(2) Although almost all ad hoc synchronizations are implemented using loops, the implementations are diverse, making it hard to manually identify them among the thousands of computation loops. For example, <ref type="figure" target="#fig_0">Figure 1</ref>(a) directly spins on a shared variable; <ref type="figure" target="#fig_0">Figure 1</ref>(b) has multiple exit conditions; <ref type="figure" target="#fig_0">Figure 1</ref>(c) shows the exit condition indirectly depends on the sync variable and needs complicated calculation to determine whether to exit the loop; <ref type="figure" target="#fig_0">Figure 1</ref>  changed the states or not. Such characteristic may partially explain why programmers use ad hoc synchronizations. More discussion and examples are in Section 2.</p><p>(3) Ad hoc synchronizations are error-prone. <ref type="table" target="#tab_2">Table 1</ref> shows that among the five software systems we studied, signficant percentages (22-67%) of ad hoc synchronizations introduced bugs. Although some experts may expect such results, our study is among the first to provide some quantitative results to back up this observation. Ad hoc synchronization can easily introduce deadlocks or hangs. As shown on <ref type="figure">Figure 2</ref>, Apache had a deadlock in one of its ad hoc synchronizations. It holds a mutex while waiting on a sync variable "queue info→idlers". <ref type="figure">Figure 3</ref> shows another deadlock example in MySQL, which has never been reported previously. More details and the real world examples are in Section 2.</p><p>Because they are different from deadlocks caused by locks or other synchronization primitives, deadlocks involving ad hoc synchronizations are very hard to detect using existing tools or model checkers <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b42">43,</ref><ref type="bibr" target="#b23">24]</ref>. These tools cannot recognize ad hoc synchronizations unless these synchronizations are annotated manually by programmers or automatically by our SyncFinder described in section 1.2. For the same reason, it is also hard for concurrency testing tools such as ConTest <ref type="bibr" target="#b5">[6]</ref>  ... S2.2 pthread_mutex_lock(&amp;mutex); S2.3 protect_global_read --;</p><p>Figure 3: A deadlock caused by a circular wait among three threads (This is a new deadlock detected by our deadlock detector leveraging SyncFinder's auto-annotation). Thread 2 is waiting at S2.2 for the lock to be released by thread 1; thread 1 is waiting at S1.2 for thread 3 to decrease the counter at S3.3; and thread 3 is waiting at S3.2 for thread 2 to decrease another counter at S2.3. consistency model and also with some compiler optimizations, e.g. loop invariant hoisting (discussed further in Section 2).</p><p>By studying the comments associated with ad hoc synchronizations, we found that some programmers knew their implementations might not be safe or optimal, but they still decided to keep their ad hoc implementations.</p><p>(4) Ad hoc synchronizations significantly impact the effectiveness and accuracy of various bug detection and performance tuning tools. Since most bug detection tools cannot recognize ad hoc synchronizations, they can miss many bugs related to those synchronizations, as well as introduce many false positives (details and examples in Section 2). For the same reason, performance profiling and tuning tools may confuse ad hoc synchronizations for computation loops, thus generating inaccurate or even misleading results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Contribution 2: Identifying Ad Hoc Synchronizations</head><p>Our characteristic study on ad hoc synchronization reveals that ad hoc synchronization is often harmful with respect to software correctness and performance. The first step to address the issues raised by ad hoc synchronization is to identify and annotate them, similar to the way that type annotation helps Deputy <ref type="bibr" target="#b8">[9]</ref> and SafeDrive <ref type="bibr" target="#b49">[50]</ref> to identify memory issues in Linux. Specifically, if ad hoc synchronizations are annotated in concurrent programs, (1) static or dynamic concurrency bug (e.g. data race and deadlock) detectors can leverage such annotations to detect more bugs and prune more false positives caused by ad hoc synchronizations; (2) performance tools can be extended to capture bottlenecks related to these synchronizations; (3) new programming language/model designers can study ad hoc synchronizations to design or revise language constructs; (4) programmers can port such ad hoc synchronizations to more structured implementations. Unfortunately, ad hoc synchronizations are very hard and time-consuming to recognize and annotate manually. Partly because of this, although some annotation languages for synchronizations like Sun Microsystems' Lock Lint <ref type="bibr" target="#b1">[2]</ref> have been available for several years, they are rarely used, even in Sun's own code <ref type="bibr" target="#b34">[35]</ref>. Furthermore, manual examination is also error-prone. <ref type="figure" target="#fig_1">Figure 4</ref> shows a MySQL ad hoc synchronization example that we missed during the manual identification we conducted for our characteristic study. Fortunately, our automatic identification tool SyncFinder found it. We overlooked this example because of the complicated nested "goto" loops. identification process of our characteristic study but is identified by our auto-identification tool, SyncFinder. The interlocked "goto" loops can easily be missed by manual identification ( <ref type="figure" target="#fig_0">Figure 1(d)</ref> shows more detailed code).</p><p>Motivated by the above reasons, the second part of our work involved building a tool called SyncFinder to automatically identify and annotate ad hoc synchronizations in concurrent programs. SyncFinder statically analyzes source code using inter-procedural, control and data flow analysis, and leverages several of our observations and insights gained from our study to distinguish ad hoc synchronizations apart from thousands of computation loops.</p><p>We evaluate SyncFinder with 25 concurrent programs including the 12 used in our characteristic study and 13 others. SyncFinder automatically identifies and annotates 96% of ad hoc synchronization loops with 6% false positives on average.</p><p>To demonstrate the benefits of auto-annotation of ad hoc synchronizations by SyncFinder, we design and evaluate two use cases. In the first use case, we build a simple wait-inside-critical-section detector, which can iden-  tify deadlock and bad programming practices involving ad hoc synchronizations. In our evaluation, our tool detects five deadlocks that are missed by previous deadlock detection tools in Apache, MySql and Mozilla, and, moreover, two of the five are new bugs and have never been reported before. In addition, even though some(16) of the detected issues are not deadlocks, they are still bad practices and may introduce some performance issues or future deadlocks. The synchronization waiting loop inside a critical section protected by locks can potentially cause cascading wait effects among threads. As the second use case, we extend the Valgrind [33] data race checker to leverage the ad hoc synchronization information annotated by SyncFinder. As a result, Valgrind's false positive rates for data races decrease by 43-86%. This indicates that even though SyncFinder is not a bug detector itself, it can help concurrency bug detectors improve their accuracy by providing ad hoc synchronization information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Ad Hoc Synchronization Characteristics</head><p>To understand ad hoc synchronization characteristics, we have manually studied 12 representative applications of three types (server, desktop and scientific/graphic), as shown on <ref type="table" target="#tab_5">Table 2</ref>. Two inspectors separately investigated almost every line of source code and compared the results with each other. As shown on <ref type="table" target="#tab_7">Table 3</ref>, in our initial study, we missed a few ad hoc synchronizations, most of which are those implemented using interlocked or nested goto loops (e.g., the example in <ref type="figure" target="#fig_1">Figure 4)</ref>. Fortunately, our automatic identification tool, SyncFinder, discovers them, and we were able to extend our manual examination to include such complicated types.</p><p>Threats to Validity. Similar to previous work, characteristic studies are all subject to the validity problem. Potential threats to the validity of our characteristic study are the representativeness of applications and our examination methodology. To address the former, we chose a variety of concurrent programs, including four servers, three clien-   <ref type="table">OpenLDAP)</ref> are for-loops doing complicated useful work and checking synchronization condition in it, like one in <ref type="figure" target="#fig_0">Figure 1</ref>(d).</p><p>t/desktop concurrent applications as well as five scientific applications from SPLASH-2, all written in C/C++, one of the popular languages for concurrent programs. These applications are well representative of server, client/desktopbased and scientific applications, three large classes of concurrent programs.</p><p>In terms of our examination methodology, we have examined almost every line of code including programmers' comments. This was an immensely time consuming effort that took three months of our time. To ensure correctness, the process was repeated twice, each time by a different author. Furthermore, we were also quite familiar with the examined applications, since we have modified and used them in many of our previously published studies.</p><p>Overall, while we cannot draw any general conclusions that can be applied to all concurrent programs, we believe that our study does capture the characteristics of synchronizations in three large important classes of concurrent applications written in C/C++. Finding 1: Every studied application uses ad hoc synchronizations. More specifically, there are 6-83 ad hoc synchronizations in each of the 12 studied programs. As shown in <ref type="table" target="#tab_5">Table 2</ref>, ad hoc synchronizations are used in all of our evaluated programs, and some programs (e.g. MySQL) even use as many as 83 ad hoc synchronizations. This indicates that, in the real world, it is not rare for programmers to use ad hoc synchronizations in their concurrent programs.</p><p>While we are not 100% sure why programmers use ad hoc synchronizations, after studying the code and comments, we speculate there are two primary reasons. The first is because there are diverse synchronization needs to ensure execution order among threads. Unlike atomicity synchronization that shares a common goal, the exact synchronization scenario for order ensurance may vary from one to another, making it hard to design a common interface to fit every need (more discussion in Finding 2).</p><p>The second reason is due to performance concerns on synchronization primitives, especially those heavyweight ones implemented as system calls. If the synchronization condition can be satisfied quickly, there is no need to pay the high overhead of context switches and system calls.  (ii) There can be multiple, different types of dependency relations between sync variables and loop exit conditions (-dir, -df, -cf, -func); (iii) Some synchronization loops do useful work with asynchronous condition checking (async). Such performance justifications are frequently mentioned in programmers' comments associated with ad hoc synchronization implementations. While ad hoc synchronizations are seemly justified, are they really worthwhile? What are their impact on program correctness and interaction with other tools? Can they be expressed using some common, easy-to-recognize synchronization primitives? We will dive into these questions in our finding 3 and 4, trying to shed some lights into the tradeoffs.  <ref type="table" target="#tab_9">Table 4</ref> further categorizes ad hoc synchronizations from several perspectives. Some real world examples for each category can be found in <ref type="figure" target="#fig_0">Figure 1</ref> and <ref type="figure" target="#fig_2">Figure 5</ref>. (i) Single vs. multiple exit conditions: Some ad hoc synchronization loops have only one exit condition <ref type="bibr" target="#b0">1</ref> . We call such sync loops sc loops. Unfortunately, many others (up to 86% of ad hoc synchronizations in a program) have more than one exit condition. We refer to them as mc loops. In some of them (referred to as mc all), all exit 1 A condition that can break the execution out of a loop. conditions are satisfied by remote threads. In the other loops (referred to as mc Nall), there are also some local exit conditions such as time-outs, etc., that are independent of remote threads and can be satisfied locally.</p><p>(ii) Dependency on sync variables: The simplest ad hoc synchronization is just directly spinning on a sync variable as shown on <ref type="figure" target="#fig_0">Figure 1(a)</ref>. In many other cases (50-100% of ad hoc synchronizations in a program), exit conditions indirectly depend on sync variables via data dependencies (referred to as df, <ref type="figure" target="#fig_2">Figure 5</ref>(a)), control dependencies (referred to as cf, <ref type="figure" target="#fig_0">(Figure 1(c)</ref>), even inter-procedural dependencies (referred to as func, <ref type="figure" target="#fig_2">Figure 5</ref>(c)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(iii) Asynchronous synchronizations (referred as async):</head><p>In some cases (77% of ad hoc synchronizations in server/desktop applications we studied), a thread does not just wait in synchronization. Instead, it also performs some useful computations while repetitively checking sync variables at every iteration. For example, in <ref type="figure" target="#fig_0">Fig- ure 1(d</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Finding 3: Ad hoc synchronizations can easily introduce bugs or performance issues.</head><p>After studying the 5 applications listed in <ref type="table" target="#tab_2">Table 1</ref>, we found that 22-67% of synchronization loops previously introduced bugs or performance issues. These high issue rates are alarming, and, as a whole, may be a strong sign that programmers should stay away from ad hoc synchronizations.</p><p>For each ad hoc synchronization loop, we use its corresponding file and function names to find out in the source code repository if there was any patch associated with it. If there is, we manually check if the patch involves the ad hoc sync loop. We then uses this patch's information to search the bugzilla databases and commit logs to find all relevant information. By examining such information as well as the patch code, we identify whether the patch is a feature addition, a bug not related to synchronization, or a bug caused exactly by the ad hoc sync loop. We only count the last case.</p><p>Besides deadlocks (as demonstrated in <ref type="figure">Figure 2 and</ref> 3), ad hoc synchronization can also introduce other types of concurrency bugs. In some cases, an ad hoc synchronization fails to guarantee an expected order and lead to a crash because the exit condition can be satisfied by a third thread unexpectedly. Due to space limitations, we do not show those examples here.</p><p>In addition to bugs, ad hoc synchronizations can also introduce performance issues. <ref type="figure" target="#fig_4">Figure 6</ref> shows such an example. In this case, the busy wait can waste CPU cycles and decrease throughput. Therefore, programmers revised the synchronization by adding a sleep inside the loop.</p><p>Ad hoc synchronizations also have problematic interactions with modern hardware's relaxed consistency models <ref type="bibr" target="#b3">[5,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b44">45]</ref>. These modern microprocessors can reorder two writes to different locations, making ad hoc synchronizations such as the one in <ref type="figure" target="#fig_0">Figure 1</ref>(a) fail to guarantee the intended order in some cases. As such, experts recommended programmers to stay away from such ad hoc synchronization implementations, or at least implement synchronizations using atomic instructions instead of just simple reads or writes <ref type="bibr" target="#b3">[5,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b44">45]</ref>.</p><p>To make things even worse, ad hoc synchronizations also have problematic interactions with compiler optimizations such as loop invariant hoisting. Programmers Comment examples Programmers are aware of better design but still use ad hoc implementation (8%) /* This can be built in smarter way, like pthread cond, but we do it since the status can come from.. */ /* By doing.. applications will get better performance and avoid the problem entirely. Regardless, we do this...  should avoid such optimizations on sync variables, and ensure that waiting loops always read the up-to-date values instead of the cached values from registers. As a workaround, programmers may need to use wrapping variable accesses with function calls <ref type="bibr">[3]</ref>. All of these just complicate programming as well as software testing and debugging.</p><p>Interestingly, some programmers are aware of the above ad hoc synchronization problems but still use them. We study the 63 comments associated with ad hoc synchronizations in MySQL, Apache, and Mozilla. As illustrated in <ref type="table" target="#tab_11">Table 5</ref>, programmers sometimes mentioned better alternatives, but they still chose to use their ad hoc implementations for flexibility. In some cases, they explicitly indicated their preference for the lightness and simplicity of ad hoc spinning loops, especially when the synchronizations were expected to rarely occur or rarely need to wait long. Also, programmers often explicitly stated their assumptions/expectation in comments about what remote threads should do correspondingly, since ad hoc synchronizations are complex and hard to understand.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Finding 4: Ad hoc synchronizations can significantly impact the effectiveness and accuracy of concurrency bug detection and performance profiling tools.</head><p>As mentioned earlier, since existing concurrency bug (deadlock, data race) detection tools cannot recognize ad hoc synchronizations, they will fail to detect bugs that involve such synchronizations (e.g. deadlock examples shown on <ref type="figure">Figure 2 and 3)</ref>.</p><p>In addition, they can also introduce many false positives. It has been well known that most data race detectors incur high false positives due to ad hoc synchronizations. Such false positives come from two sources: (1) Benign data races on sync variables: typically an ad hoc synchronization is implemented via an intended data race on sync variables. <ref type="figure" target="#fig_6">Figure 7</ref>(a) shows such a benign data race reported by Valgrind <ref type="bibr" target="#b32">[33]</ref> in MySQL. <ref type="formula">(2)</ref> False data races that would never execute in parallel due to the execution order guaranteed by ad hoc synchronizations: For example, in <ref type="figure" target="#fig_6">Figure 7</ref>(b), the two threads are synchronized at S2 and S3, which guarantees the correct order between S1 and S4's accesses to q info→pools. S1 and S4 would never race with each other. However, most data race checkers cannot recognize this ad hoc synchronization and, as a result, incorrectly report S1 and S4 as a data race. Synchronization is also a big performance and scalability concern because time waiting at synchronization is wasted. Unfortunately, existing work in synchronization cost analysis <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b31">32]</ref> and performance profiling <ref type="bibr" target="#b28">[29]</ref> cannot recognize ad hoc synchronizations, and therefore the synchronizations can easily be mistaken as computation. As a result, the final performance profiling results may cause programmers to make less optimal or even incorrect decisions while performance tuning.</p><p>Replacing with synchronization primitives. Our findings above reveal that ad hoc synchronization is often harmful in several respects. Therefore, it is desirable that programmers use synchronization primitives such as cond wait, rather than ad hoc synchronization. <ref type="figure" target="#fig_7">Fig- ure 8</ref> shows how ad hoc synchronization can be replaced with a well-known synchronization primitive, POSIX pthread cond wait(). Note that it may not always be straightforward to use existing synchronization primitives to replace all ad hoc synchronizations, because existing synchronization primitives may not be sufficient to meet the diverse synchronization needs as well as the performance requirements, as discussed in Finding 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Ad hoc Synchronization Identification</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overview</head><p>As ad hoc synchronizations have raised many challenges and issues related to correctness and performance, it would be useful to identify and annotate them. Manually doing this is tedious and error-prone since they are diverse and hard to tell apart from computation. Therefore, the second part of our work builds a tool called SyncFinder to automatically identify and annotate them in the source code of concurrent programs. The annotation can be leveraged in several ways as discussed in Section 1.2. There are two possible approaches to achieve the above goal. One is dynamic and is done by analyzing run-time traces. The other approach is static, involving the analysis of source code. Even though the dynamic approach has more accurate information than the static method, it can incur large (up to 30X <ref type="bibr" target="#b26">[27]</ref>) run-time overhead to collect memory access traces. In addition, the number of ad hoc synchronizations that can be identified using this method would largely depend on the code coverage of test cases. Also some ad hoc synchronization loops may terminate after only one iteration, making it hard to identify them as ad hoc synchronization loops <ref type="bibr" target="#b17">[18]</ref>. Due to these reasons, we choose the static method, i.e., analyzing source code.</p><p>The biggest challenge to automatically identify ad hoc synchronizations is how to separate them from computation loops. The diversity of ad hoc synchronizations makes it especially hard. To address the above challenge, we have to identify the common elements among various ad hoc synchronization implementations. Commonality among ad hoc synchronizations: Interestingly, ad hoc synchronizations are all implemented using loops, referred to as sync loops <ref type="figure">(Figure 9</ref>). While a sync loop can have many exit conditions, at least one of them is the exit condition to be satisfied when an expected synchronization event happens. We refer to such exit conditions as sync conditions. The sync condition directly or indirectly depends on a certain shared variable (referred as a sync variable) that is loop-invariant locally, and modified by a remote thread.</p><p>Note that a sync variable may not necessarily be directly used by a sync condition (e.g., inside a while loop condi- Following the above characteristic, SyncFinder starts from loops in the target programs, and examines their exit conditions to identify those that are (1) loop invariant, (2) directly or indirectly depend on a shared variable, and (3) can be satisfied by a remote thread's update to this variable. By checking these constraints, SyncFinder filters out most computation loops as shown in our evaluation.</p><p>Checking all of the above conditions requires SyncFinder to conduct (1) program analysis to know the exit conditions for each loop; (2) data and control flow analysis to know the dependencies of exit conditions; (3) some static thread analysis to conservatively identify what segment of code may run concurrently; and (4) some simple satisfiability analysis to check whether the remote update to the sync variable can satisfy the sync condition.</p><p>As shown on <ref type="figure" target="#fig_0">Figure 10</ref>, SyncFinder consists of the following steps: (1) Loop detection and exit condition extraction; (2) Exit dependent variable (EDV) identification; (3) Pruning computation and condvar loops based on characteristics of EDVs; (4) Synchronization pairing to pair an identified sync loop with a remote update that would break the program out of this sync loop; (5) Final result reporting and annotation in the target program's source code.</p><p>SyncFinder is built on top of the LLVM compiler infrastructure <ref type="bibr" target="#b22">[23]</ref> since it provides several useful basic features that SyncFinder needs. LLVM's intermediate representation (IR) is based on single static assignment (SSA) form, which automatically provides a compact definitionuse graph and control flow graph for every function, both of which can be leveraged by SyncFinder's data-, and control-flow analysis. In addition, SyncFinder also uses LLVM's loopinfo analysis, alias analysis, and constant propagation tracking to implement the ad hoc sync loop identification algorithm. SyncFinder annotation is done via the static instrumentation interfaces provided in LLVM. In the rest of this section, we focus on our algorithms and do not go into details about the basic analysis provided by LLVM.  <ref type="table">Table 6</ref>: Loop mechanisms used for real-world ad hoc synchronization. There are a non-negligible number of "goto" loops, which often complicate loop analysis (e.g., <ref type="figure" target="#fig_1">Figure 4</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Finding Loops</head><p>As shown in <ref type="table">Table 6</ref>, ad hoc synchronizations are implemented using three primary forms of loops: "while", "for" and "goto". Fortunately, LLVM's loopinfo pass identifies all those loops based on back edges in LLVM IR.</p><p>For each loop identified by LLVM, SyncFinder extracts its exit conditions. Specifically, it identifies the basic blocks with at least one successor outside of the loop, then for each identified basic block, SyncFinder extracts its terminator instruction, from which SyncFinder can identify the branch conditions. Such conditions are the exit conditions for this loop. SyncFinder represents the exit conditions in a canonical form: disjunction (OR) of multiple conditions, and examines each separately.</p><p>In addition, since LLVM does not keep the loop context information, e.g., loop headers and bodies, across functions, SyncFinder keeps track of them into its own data structure and uses them throughout the analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Identifying Sync Loops</head><p>The key challenge of SyncFinder is to differentiate sync loops from computation loops. To address this challenge, SyncFinder examines the exit conditions of each loop by going through the following steps to filter out computation loops. (1) Exit Dependent Variable (EDV) analysis : For each exit condition of each loop in the target program, the first step is to identify all variables that this exit condition depends on-we refer to them as exit dependent variables (EDVs). If a loop is a sync loop, the sync variables should be included in its EDVs. Note that a sync variable is not necessarily used in an exit condition (sync condition) directly. A loop exit condition can be data/controldependent on a sync variable. Therefore, we conduct dataflow and control-flow analysis to find indirect EDVs. The EDV identification process is similar to static backward slicing <ref type="bibr" target="#b47">[48,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b14">15]</ref>.</p><p>SyncFinder first starts from variables directly referenced in the exit condition. They are added into an EDV set. Then, as shown in <ref type="figure" target="#fig_0">Figure 11</ref>, it pops a variable out from the EDV set, and finds out new EDVs along this variable's data/control flow. New EDVs are inserted into the set. It then pops another EDV from the set, and so on so forth until it reaches the loop boundary. For an EDV that does not depend on any other variables inside this loop, we refer them as a leaf-EDV (similar to "live-in" variables). SyncFinder maintains a separate set for leaf-EDVs. Obviously, leaf-EDVs are the ones we should focus on since they are not derived from any other EDVs in this loop.</p><p>During the backward data/control flow tracking process, if the dependency analysis encounters a function whose return value or passed-by-reference arguments affect the loop exit condition, SyncFinder further tracks the dependency via inter-procedural analysis. SyncFinder applies data-and control-flow analysis starting from the function's return value, and identifies Return/arguments-Dependent Variables (RDVs) in the callee. Such RDVs are also added into the leaf-EDV set. In addition, all RDVs of this function are stored in a summary to avoid analyzing this function again for other loops.</p><p>To handle variable and function pointer aliasing, SyncFinder leverages and extends LLVM's alias analysis to allow it go beyond function boundary. (2) Pruning computation loops For every exit condition of a loop, SyncFinder applies the following two pruning steps to check whether it is a sync condition. At the end, if a loop has at least one sync condition, it is identified as a sync loop. Otherwise, it is pruned out as a computation loop. Most computation loops are filtered in this phase. Non-shared variable pruning: A sync variable should be a shared variable that can be set by a remote thread. Specifically, it should be either a global variable, a heap object, or a data object (even stack-based) that is passed to a function (e.g., thread starter function) called by another thread, which can be shared by the two threads.</p><p>Therefore, if an exit condition has no shared variables in its leaf-EDV set, it is deleted from the loop's exit condition set. SyncFinder moves to the next exit condition of this loop. If the loop has no exit conditions left, this loop is pruned out as a computation loop.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Loop-variant based pruning:</head><p>In almost all cases, a sync condition is loop-invariant locally, and only a remote thread changes the result of the sync condition. Based on this observation, SyncFinder prunes out those exit conditions that are loop-variant locally as shown on <ref type="figure" target="#fig_0">Figure 12</ref>. It is possible that some ad hoc synchronizations may also change the sync conditions locally. In all our experiments with 25 concurrent programs, we did not find any true ad hoc synchronizations that SyncFinder missed due to this pruner. Note that some exit conditions, such as expiration time, are separated as different conditions, and we examine each condition separately. To check if an exit condition is loop variant, SyncFinder applies a modification (M OD) analysis within the scope of a loop being examined. Specifically, it checks all leafEDVs and leaf-RDVs of this loop, and prunes out those modified locally within this loop. The leaf-RDV summary is also updated accordingly. (3) Pruning condvar loops: SyncFinder does not consider condvar loops (i.e., sync loops that are associated with cond wait primitives) as ad hoc loops as they can be easily recognized by intercepting or instrumenting these primitives. As the final step of the ad hoc sync loop identification, SyncFinder checks every loop candidate to see it calls a cond wait primitive inside the loop. Loops that use primitives are recognized as condvar loops and are thereby pruned out. The names of cond wait primitives(original pthread functions or wrappers) are provided as input to SyncFinder to identify cond wait calls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Synchronization Pairing</head><p>Once we identify a potential sync loop, we find the remote update (referred as a sync write) that would "release" (break) the wait loop. To identify a sync write, SyncFinder  first collects all write instructions modifying sync variable candidates, and then applies the following pruning steps. Pruning unsatisfiable remote updates For each remote update to the target sync variable candidate, SyncFinder analyzes what value is assigned to this variable, and whether it can satisfy the sync condition. A complicated solution to achieve this functionality is to use a SAT solver. But it is too heavyweight, especially since, according to our observations (shown in <ref type="table" target="#tab_14">Table 7</ref>), the majority(66%) of sync writes either assign constant values to sync variables, or use simple counting operations like increment/decrement, rather than complicated computations. This is because a sync variable is usually a control variable (e.g. status, flag, etc.) and does not require sophisticated computations. Therefore, instead of using a SAT solver, we use constant propagation to check if this remote update would satisfy the exit condition. For an assignment with a constant, it substitutes the variable with the constant, and propagates it till the exit condition to see if it is satisfiable or not. For increment based updates, SyncFinder treats it as "sync var &gt; 0" since it obviously does not release the loop that is waiting for an exit condition "(sync var == 0)".</p><p>Pruning serial pairs A sync loop and a sync write should be able to execute concurrently. If there is a happensbefore relation between such pair, due to thread creation/join, barrier, etc, the remote write does not match with the sync loop. Due to the limitation of static analysis, currently SyncFinder conservatively prunes serial pairs related to only thread creation/join. Specifically, SyncFinder follows thread creation and conservatively estimates code that might be running concurrently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">SyncFinder Annotation</head><p>After the above pruning process, the remaining ones are identified as sync loops, along with their corresponding sync writes. All the results are stored in a file. SyncFinder also automatically annotates in the target software's source code using LLVM static instrumentation framework. For the corresponding sync write, it inserts //#SyncAnnotation: Sync Write(&amp;syncVar, &amp;loopId).</p><p>The loopId is used to match a remote sync write with a sync loop. Similar annotations are also inserted into the target program's bytecode to be leveraged by concurrency bug detection tools as discussed in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Two Use Cases of SyncFinder</head><p>SyncFinder's auto-identification can be used by many bug detection tools, performance profiling tools, concurrency testing frameworks, program language designers, etc. We built two use cases to demonstrate its benefits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">A Tool to detect bad practices</head><p>It is considered bad practice to wait inside a critical section, as it can easily introduce deadlocks like the Apache example shown on <ref type="figure">Figure 2</ref> and the MySQL example on <ref type="figure">Figure 3</ref>. Furthermore, it can result in performance issues caused by cascading wait effects, and may introduce deadlocks in the future if programmers are not careful. As a demonstration, we built a simple detector (referred to as wait-inside-critical-section detector) to catch these cases leveraging SyncFinder's auto-annotation of ad hoc synchronizations. Our detection algorithm can be easily integrated into any existing deadlock detection tool as well.</p><p>To detect such pattern, our simple detector checks every sync loop annotated by SyncFinder to see if it is performed while holding some locks. If a sync loop is holding a lock, then SyncFinder checks the remote sync write to see whether the write is performed after acquiring the same lock or after another ad hoc sync loop, so on and so forth, to see if it is possible to form a circle. If it is, the detector reports it as a potential issue: either a deadlock or at least a bad practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Extensions to data race detection</head><p>We also extend Valgrind <ref type="bibr" target="#b32">[33]</ref>'s dynamic data race detector to leverage SyncFinder's auto-identification of ad hoc sync loops. Valgrind implements a happens-before algorithm <ref type="bibr" target="#b20">[21]</ref> using logical timestamps, which was originally based on conventional primitives including mostly lock primitives, and thread creation/join. It cannot recognize ad hoc synchronizations. As a result, it can introduce many false positives (shown in <ref type="table" target="#tab_2">Table 12</ref>) as discussed in Section 2 and illustrated using two examples in <ref type="figure" target="#fig_6">Figure 7</ref>.</p><p>We extend Valgrind to eliminate data race false positives by considering ad hoc synchronizations annotated by SyncFinder. It treats the end of a sync loop in a similar way to a cond wait operation, and the corresponding sync write like a signal operation. This way it keeps track of the happens-before relationship between them. We also extend Valgrind to not consider sync variable reads and writes as data races.</p><p>Apps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Total</head><p>Identified  program uses ad hoc sync loops except LU. Both true ad hoc sync loops and false positives are showed here. For the 12 programs used in the characteristic study, the numbers of missed ad hoc sync loops are also reported. They are generated by comparing with our manual checking results from the characteristic study. We cannot show the numbers of missed ad hoc sync loops for the unseen programs in the study since we did not manually examine them as we did for the 12 studied programs. To show SyncFinder's total exploration space, we also show the total number of loops, most of which are computation loops. Note that the total numbers of ad hoc sync loops are different from those numbers shown in <ref type="table" target="#tab_5">Table 2</ref> because some code (for other platforms such as FreeBSD, etc) are not included during the compilation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Effectiveness and Accuracy</head><p>We evaluated SyncFinder on 25 concurrent programs, including 12 used in our manually characteristic study and 13 other ones. <ref type="table" target="#tab_16">Table 8</ref> shows the overall result of SyncFinder on the 25 programs. On average SyncFinder accurately identifies 96% of ad hoc sync loops in the 12 studied programs and has a 6% false positive rate overall. SyncFinder successfully identified diverse ad hoc order synchronizations, including those we missed during our manual identification. For example, it successfully identifies those complicated, interlocked "goto" sync loops, as shown in <ref type="figure" target="#fig_1">Figure 4</ref>. For the 12 studied programs, SyncFinder misses a few(1-3 per application) sync loops in large server/desktop applications. Considering the total number of loops (up to 4265) in each of these applications, such a small miss rate does not limit SyncFinder's applicability to real world programs. SyncFinder fails to identify these sync loops because of the unavailability of the source code for these library functions and inaccurate pointer alias.</p><p>SyncFinder also returns a low number of false positives for all 25 programs. As showed in <ref type="table" target="#tab_16">Table 8</ref>, SyncFinder has 0-6 false positives per program (i.e. a false positive rate of 0-30%). Such numbers are quite reasonable. Programmers can easily examine the reported sync loops to prune out those few false positives. Most of the false positives are caused by inaccurate function pointer analysis. Due to complicated function pointer alias, sometimes SyncFinder cannot further track into callee functions to check if a target variable (leaf-EDV) is locally modified. In these cases, SyncFinder conservatively considers the target variable as a sync variable.  To show the effectiveness of sync loop identification, in <ref type="table" target="#tab_18">Table 9</ref>, we test SyncFinder on some server/desktop applications and show the results from each of the sync loop identification steps. From the total loops identified, SyncFinder extracts exit conditions, and identifies all leafEDVs (the third column in <ref type="table" target="#tab_18">Table 9</ref>). From the leaf-EDVs, SyncFinder prunes out non-shared variables (95% of leafEDVs), and applies loop-variant based pruning, which further prunes 80% of shared leaf-EDVs. SyncFinder then applies the final pruning step to prune out sync variables that are associated with condvar loops. The remains are sync variable candidates and those loops using them are potential sync loops.  <ref type="table" target="#tab_2">Apache  27  22  27  22  21  MySQL  251  204  178  141  123  OpenLDAP  168  134  146  115  96  PBZip2  19  15  11  9  9   Table 10</ref>: False synchronization pair pruning. Note that the numbers shown here are synchronization pairs. In all the other results, we show "synchronization loops" (regardless how many setting statements for an ad hoc sync loop) serial pair pruning. <ref type="table" target="#tab_2">Table 10</ref> shows the effect of those pruning steps on the same set of server/desktop applications in <ref type="table" target="#tab_18">Table 9</ref>. First, remote update based pruning eliminates 51.8% of false sync pair candidates on average. It is especially effective on Apache, since the majority of sync writes are just simple assignments with constant values, so it is easy to determine whether such values would satisfy the corresponding sync exit conditions. Second, the effectiveness of serial pair pruning depends on application characteristics. While it prunes out almost all false positives in simple desktop/scientific programs (e.g., PBZip2), it is less effective in servers like Apache, where many function pointers are used. Due to the limitation of function pointer analysis, it is hard to know in all cases whether two certain regions cannot be concurrent. To be conservative, SyncFinder does not prune the pairs inside such regions. Fortunately, the remote update based pruning helps filtering them out.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Sync Loop Identification and Pruning</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Synchronization Pairing and Pruning</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Two Use Cases: Bug Detection</head><p>Apps.</p><p>Deadlock <ref type="formula">(</ref>   <ref type="table" target="#tab_2">Table 11</ref> shows that our simple deadlock detector (leveraging SyncFinder's ad hoc synchronization annotation) detects five deadlocks involving ad hoc order synchronizations, including those shown in <ref type="figure">Figure 2</ref> and <ref type="figure">Figure 3</ref>. Previous tools would fail to detect these bugs since they cannot recognize ad hoc synchronizations. Besides deadlocks, our detector also reports 16 bad practices, i.e. waiting in a sync loop while holding a lock, which could raise performance issues or cause future deadlocks.   <ref type="table" target="#tab_2">Table 12</ref> shows that SyncFinder auto-annotation could reduce the false positive rates of Valgrind data race detector by 43-86%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>Spin and hang detection Some recent work has been proposed in detecting simple spinning-based synchronizations <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b17">18]</ref>. For example, <ref type="bibr" target="#b24">[25]</ref> proposed some new hardware buffers to detect spinning loops on-the-fly. <ref type="bibr" target="#b17">[18]</ref> also provides similar capability but does it in software. Both can detect only simple spinning loops, i.e. those sync loops with only one single exit condition and also directly depend on sync variables (referred as "sc-dir" in <ref type="table" target="#tab_7">Table 3</ref> in Section 2). As shown in <ref type="table" target="#tab_7">Table 3</ref> such simple spinning loops account for less than 16% of ad hoc sync loops on average in server/desktop applications we studied.</p><p>Besides, both of them are dynamic approaches and thereby suffer from the coverage limitation of all dynamic approaches (discussed in Section 3). In contrast, SyncFinder uses a static approach and can detect various types of ad hoc synchronizations. Additionally, we also conduct an ad hoc synchronization characteristic study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Synchronization annotation</head><p>Many annotation languages <ref type="bibr" target="#b2">[4,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b0">1,</ref><ref type="bibr" target="#b40">41]</ref> have been proposed for synchronizations in concurrent programs. Unfortunately, annotation is not frequently used by programmers since it is tedious. SyncFinder is complementary to these work by providing automatic annotation for ad hoc synchronizations. Concurrent bug detection tools Much research has been conducted on concurrency bug detection <ref type="bibr" target="#b46">[47,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b42">43]</ref>. These tools usually assume that they can recognize all synchronizations in target programs. As we demonstrated using deadlock detection and race detection, SyncFinder can help these tools improve their effectiveness and accuracy by automatically annotating ad hoc synchronizations that are hard for them to recognize. Transactional memory Various transactional memory designs have been proposed to solve the programmability issues related to mutexes <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b43">44]</ref> and also condition variables <ref type="bibr" target="#b9">[10]</ref>. Our study complements such work by providing ad hoc synchronization characteristics in real world applications. Software bug characteristics studies Several studies have been conducted on the characteristics of software bugs <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b41">42,</ref><ref type="bibr" target="#b33">34]</ref>, including one of our own <ref type="bibr" target="#b25">[26]</ref> on concurrency bug characteristics. This paper is different from those studies by focusing on ad hoc synchronizations instead of bugs, even though many of them are prone to introducing bugs. The purpose of this paper is to raise the awareness of ad hoc synchronizations, and to warn programmers to avoid them when possible. Also we developed an effective way to automatically identify those ad hoc synchronizations in large software.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions and Limitations</head><p>In this paper, we provided a quantitative characteristics study of ad hoc synchronization in concurrent programs and built a tool called SyncFinder to automatically identify and annotate them. By examining 229 ad hoc synchronization loops from 12 concurrent programs, we have found several interesting and alarming characteristics. Among them, the most important results include: all concurrent programs have used ad hoc synchronizations and their implementations are very diverse and hard to recognize manually. Moreover, a large percentage (22-67%) of ad hoc loops in these applications have introduced bugs or performance issues. They also greatly impact the accuracy and effectiveness of bug detection and performance profiling tools. In an effort to detect these ad hoc synchronizations, we developed SyncFinder, a tool that successfully identifies 96% of ad hoc synchronization loops with a 6% false positive rate. SyncFinder helps detect deadlocks missed by conventional deadlock detection and also reduce data race detector's false positives. Many other tools and research projects can also benefit from SyncFinder. For example, concurrency testing tools (e.g., CHESS <ref type="bibr" target="#b30">[31]</ref>) can leverage SyncFinder's auto-annotation to force a context switch inside an ad hoc sync loop to expose concurrency bugs. Similarly, performance tools can be extended to profile ad hoc synchronization behavior.</p><p>All work has limitations, and ours is no exception: (i) SyncFinder requires source code. However, this may not significantly limit SyncFinder's applicability since it is more likely to be used by programmers instead of end users. (ii) Due to some implementation issues, SyncFinder still misses 1-3 ad hoc synchronizations. Eliminating them would require further enhancement to some of our analysis (such as alias analysis, etc.) (iii) Even though SyncFinder's false positive rates are quite low, for some use cases that are sensitive to false positives, programmers would need to manually examine the identified ad hoc synchronization or leverage some execution synthesis tools like ESD <ref type="bibr" target="#b48">[49]</ref> to help identify false positives. (iv) For our characteristic study, we can always study a few more applications, especially of different types.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Real world examples of ad hoc synchronizations. Sync variables are highlighted using bold fonts. Example (a) directly spins on the sync variable; (b) checks more than one sync variables, (c) takes a certain control path to exit after checking a sync variable, (d) performs some useful work inside the waiting loop.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: An ad hoc synchronization missed in our manual</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>g lo b a l-&gt; b a rrie r).c o u n t;if(g lo b a l-&gt; p b a r_ c o u n tFigure 5 :</head><label>5</label><figDesc>Figure 5: Examples of various ad hoc synchronizations. A sync variable is highlighted using a bold font. An arrow shows the dependency relation from a sync variable to a loop-exit condition. The examples of other ad hoc categories are shown on Figure 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Finding 2: Ad hoc synchronization is diverse.</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: An ad hoc synchronization in MySQL was revised by programmers to solve a performance problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>because we'd rather write error message in this routine, ..*/ Programmers try to prevent bugs at the first place (22%) /* We could end up spinning indefinitely with a situation where.. The 'i++' stops the infinite loop */ /* We can safely wait here in the case.. without fear of deadlock because we made.. */ /* This spinning actually isn't necessary except when the compiler does corrupt 64bit arithmetic.. */ Programmers explicitly state their sync assumptions (75%) /* GC doesn't set the flag until it has waited for all active requests to end */ /* We must break the wait if one of the following occurs: i).. ii).. iii).. iv).. v).. */</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>atomic_inc( &amp;(q_info-&gt;idlers) ); Listener S3 while(q_info-&gt;idlers == 0) {..Figure 7 : False positives in Valgrind data race detection due to ad hoc synchronizations.</head><label>7</label><figDesc>Figure 7: False positives in Valgrind data race detection due to ad hoc synchronizations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>p= (g lo b a l-&gt; b a rrie r).c o u n t;Figure 8 : Replacing ad hoc synchronizations with synchro- nization primitives using condition variables.</head><label>8</label><figDesc>Figure 8: Replacing ad hoc synchronizations with synchronization primitives using condition variables. (a) shows the re-implementation of ad hoc synchronization in Figure 1(a); (b) is for Figure 5(a).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 : SyncFinder design to automatically identify and annotate ad hoc synchronizationFigure 9 :hoc synchronization abstract model.</head><label>109</label><figDesc>Figure 10: SyncFinder design to automatically identify and annotate ad hoc synchronization</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Leaf-EDV identification. SyncFinder recursively tracks Exit Dependent Variables(EDVs) along the data-, controlflow, until it reaches a leaf-EDV.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: The non-sync variables pruned out by loopvariant based pruning. In the two computation loops, the variables in italic font are shared variable leaf-EDVs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>It inserts //#SyncAnnotation: Sync Loop Begin(&amp;loopId), //#SyncAnnotation: Sync Loop End(&amp;loopId), respectively, at the begin- ning and end of an identified sync loop. In addi- tion, inside the loop, it also annotates the read to a sync variable by inserting //#SyncAnnotation: Sync Read(&amp;syncVar, &amp;loopId).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head></head><label></label><figDesc>(d) synchronizes on program states and performs useful work while checking whether the remote thread has</figDesc><table>Apps. 
#ad hoc sync #buggy sync 
Apache 
33 
7 (22%) 
OpenLDAP 
15 
10 (67%) 
Cherokee 
6 
3 (50%) 
Mozilla-js 
17 
5 (30%) 
Transmission 
13 
8 (62%) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Percentages of ad hoc synchronizations that had 

introduced bugs according to the bugzilla databases and 
changelogs of the applications. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>The number of ad hoc synchronizations in concur-

rent programs we studied. Ad hoc sync is implemented with 
an ad hoc loop using shared variables (i.e., sync variables) in it. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Ad hoc sync loops missed by human inspec-
tions. Two inspectors, I a and I b , investigate the same 
source code separately. Most of the sync loops missed 
by both inspectors (i.e., those in Apache and MySQL) are 
interlocked or nested goto loops. Others (in </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>Table 4 :</head><label>4</label><figDesc></figDesc><table>Diverse ad hoc synchronizations in concurrent programs we studied. (i) The number of exit conditions in synchroniza-

tion loops are various (sc vs. mc); </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>/* get tuple Id of a table */</head><label></label><figDesc></figDesc><table>), a MySQL master thread does background tasks 
like log flushing until a new SQL query arrives (by check-
ing new activity counter). do { 
ret= m_skip_auto_increment ? 
readAutoIncrementValue(...): 
getAutoIncrementValue( 

£ 

); 
} while(ret== -1 &amp;&amp; --retries &amp;&amp; ..); 

for (;;) { 
if (m_skip_auto_increment &amp;&amp; 
readAutoIncrementValue(...) 
|| getAutoIncrementValue(...){ 
if (--retries &amp;&amp; ...) { 
my_sleep(retry_sleep); 
continue; 
} 
} break; 
} 

/* 30 ms sleep 
for transaction */ 

/* MySQL */ 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>Table 5 :</head><label>5</label><figDesc></figDesc><table>Observations in programmers' comments on ad 

hoc synchronization from Apache, Mozilla, and MySQL. We 
study 63 comments associated with ad hoc synchronizations. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14" validated="false"><head>Table 7 : The characteristics of writes to sync variables. In</head><label>7</label><figDesc></figDesc><table>the four sampled applications, majority of writes assign constant 
values, or use simple increase or decrease operations. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16" validated="false"><head>Table 8 :</head><label>8</label><figDesc></figDesc><table>Overall results of SyncFinder: Every concurrent 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18" validated="false"><head>Table 9 :</head><label>9</label><figDesc></figDesc><table>EDV Analysis and non-sync variable pruning. After 

identifying leaf-EDVs for each loop, SyncFinder applies non-
shared, loop-variant and condvar-loop based pruning schemes. 
The final results are the sync variables of the ad hoc sync loops. 
Some sync variables may be associated with a same sync loop. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_21" validated="false"><head>Table 11 : Deadlock and bad practice detection</head><label>11</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_23" validated="false"><head>Table 12 : False positive reduction in Valgrind</head><label>12</label><figDesc></figDesc><table></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Acknowledgments</head><p>We would like to express our deepest appreciation to our shepherd, Professor George Candea, who was very responsive during our interactions with him and provided us with valuable suggestions, which have significantly improved our paper and strengthened our work. Moreover, we would also like to thank the anonymous reviewers whose comments and insightful suggestions have greatly shaped and improved our paper and have taught us many important lessons. Finally, we greatly appreciate Bob Kuhn, Matthew Frank and Paul Petersen for their continuous support and encouragement throughout the whole project, as well as their insightful feedback on the project and the paper. This work is supported by NSF-CSR 1017784, NSF CNS-0720743 grant, NSF CCF-1017804 grant, NSF CNS-1001158 (career award) and Intel Grant.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Java</surname></persName>
		</author>
		<ptr target="http://java.sun.com/j2se/1.5.0/docs/guide/language/annotations.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Lock Lint -Static data race and deadlock detection tool for C</title>
		<ptr target="http://developers.sun.com/sunstudio/articles/locklint.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<ptr target="http://msdn2.microsoft.com/en-us/library/ms235402.aspx" />
		<title level="m">MSDN run-time library reference -SAL annotations</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Foundations of the c++ concurrency memory model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boehm</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adve</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;08: Proceedings of the</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<title level="m">ACM SIGPLAN conference on Programming language design and implementation</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="68" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Applications of synchronization coverage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bron</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Farchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Magid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Nir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><forename type="middle">R</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, PPOPP 2005</title>
		<meeting>the ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, PPOPP 2005<address><addrLine>Chicago, IL, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="206" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Flux: A language for programming highperformance servers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Grimaldi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kostadinov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Corner</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<meeting><address><addrLine>General Track; USENIX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="129" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An empirical study of operating system errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM Symposium on Operating System Principles (18th SOSP&apos;01)</title>
		<meeting>the 18th ACM Symposium on Operating System Principles (18th SOSP&apos;01)<address><addrLine>Banff, Alberta, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>ACM SIGOPS</publisher>
			<date type="published" when="2001-10" />
			<biblScope unit="page" from="73" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Dependent types for low-level programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Condit</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Harren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">R</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Necula</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Programming Languages and Systems, 16th European Symposium on Programming</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="520" to="535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Condition variables and transactional memory: Problem or oppertunity?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dudnik</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">4th ACM SIGPLAN Workshop on Transactional Computing(Transact)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">RacerX: effective, static detection of race conditions and deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashcraft</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the nineteenth ACM symposium on Operating systems principles</title>
		<meeting>the nineteenth ACM symposium on Operating systems principles</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="237" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Atomizer: a dynamic atomicity checker for multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Flanagan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Freund</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;04: Proceedings of the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming languages</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="256" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Transactional memory: Architectural support for lock-free data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herlihy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moss</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="289" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Monitors: an operating system structuring concept</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hoare</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="549" to="557" />
			<date type="published" when="1974" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Interprocedural slicing using dependence graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Horwitz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Reps</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">W</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brinkley</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN&apos;88 Conference on Programming Language Design and Implementation (PLDI)</title>
		<meeting>the ACM SIGPLAN&apos;88 Conference on Programming Language Design and Implementation (PLDI)<address><addrLine>Atlanta, Georgia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="35" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Proving monitors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Howard</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="273" to="279" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Intel thread checker</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Intel</forename><surname>Corporation</surname></persName>
		</author>
		<ptr target="http://software.intel.com/en-us/articles/intel-thread-checker-documentation/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Identifying ad-hoc synchronization for enhanced race detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jannesari</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tichy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">F</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IPDPS</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Tokentm: Efficient execution of large transactions with hardware transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jayaram</forename><surname>Bobba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neelam</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H.-M S D W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Computer Architecture</title>
		<imprint>
			<date type="published" when="2008-06" />
			<biblScope unit="page" from="127" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Deadlock immunity: Enabling systems to defend against deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jula</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Tralamazza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Zamfir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Candea</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting><address><addrLine>San Diego, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-12-08" />
			<biblScope unit="page" from="295" to="308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lamport</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Experience with processes and monitors in mesa</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lampson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Redell</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="105" to="117" />
			<date type="published" when="1980-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">LLVM: A Compilation Framework for Lifelong Program Analysis &amp; Transformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lattner</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adve</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 International Symposium on Code Generation and Optimization (CGO&apos;04)</title>
		<meeting>the 2004 International Symposium on Code Generation and Optimization (CGO&apos;04)<address><addrLine>Palo Alto, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Pulse: A dynamic deadlock detection mechanism using speculative execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ellis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Lebeck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sorin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="31" to="44" />
		</imprint>
	</monogr>
	<note>General Track</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Spin detection hardware for improved management of multithreaded systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lebeck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sorin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems PDS</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="508" to="521" />
			<date type="published" when="2006-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Learning from mistakes -a comprehensive study on real world concurrency bug characteristics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architecture Support for Programming Languages and Operating Systems</title>
		<meeting>the International Conference on Architecture Support for Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="2008-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Avio: detecting atomicity violations via access interleaving invariants</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS-XII: Proceedings of the 12th international conference on Architectural support for programming languages and operating systems</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="37" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The java memory model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pugh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">The paradyn parallel performance measurement tool. Special issue on performance evaluation tools for parallel and distributed computer systems 28</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Callaghan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Cargille</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">K</forename><surname>Hollingsworth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Irvin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Karavanic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kunchithapadam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Newhall</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1995-11" />
			<biblScope unit="page" from="37" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">An effective hybrid transactional memory system with strong isolation guarantees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">C</forename><surname>Trautmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bronson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Casper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kozyrakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olukotun</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA &apos;07: Proceedings of the 34th annual international symposium on Computer architecture</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="69" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">AND NEAMTIU, I. Finding and reproducing heisenbugs in concurrent programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Musuvathi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Basler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nainar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting><address><addrLine>San Diego, California, USA, Proceedings</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-12-08" />
			<biblScope unit="page" from="267" to="280" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">An architectural framework for detecting process hangs/crashes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nakka</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Saggese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">P</forename><surname>Kalbarczyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>And Iyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDCC: EDCC, European Dependable Computing Conference</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Valgrind: a framework for heavyweight dynamic binary instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nethercote</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seward</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="89" to="100" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Predicting the location and number of faults in large software systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ostrand</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Weyuker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bell</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Software Eng</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="340" to="355" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Listening to programmers taxonomies and characteristics of comments in operating system code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Padioleau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;09: Proceedings of the 31st International Conference on Software Engineering</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="331" to="341" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">CTrigger: exposing atomicity violation bugs from their hiding places</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Park</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the 14th International Conference on Architectural Support for Programming Languages and Operating Systems<address><addrLine>DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="25" to="36" />
		</imprint>
	</monogr>
	<note>ASPLOS 2009, Washington</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Transactional memory bibliography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajwar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hill</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<ptr target="http://www.cs.wisc.edu/trans-memory/biblio/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Precise interprocedural chopping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reps</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rosay</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGSOFT &apos;95: Proceedings of the 3rd ACM SIGSOFT symposium on Foundations of software engineering</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="41" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Txlinux: using and managing hardware transactional memory in an operating system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rossbach</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><forename type="middle">S</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Ra-Madan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aditya</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Witchel</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st ACM Symposium on Operating Systems Principles</title>
		<meeting>the 21st ACM Symposium on Operating Systems Principles<address><addrLine>Stevenson, Washington, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007-10-14" />
			<biblScope unit="page" from="87" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Software transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shavit</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Touitou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Principles of Distributed Computing</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">WARLOCK -A static data race analysis tool</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sterling</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Winter Technical Conference</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="97" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A comparison of software defects in database management systems and operating systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sullivan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chillarege</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In FTCS</title>
		<imprint>
			<biblScope unit="page" from="475" to="484" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Thread analyzer user&apos;s guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sun</forename><surname>Microsystems Inc</surname></persName>
		</author>
		<ptr target="http://dlc.sun.com/pdf/820-0619/820-0619.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Composable memory transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marlow</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P.-J M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN symposium on Principles and practice of parallel programming</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Shared memory consistency models: A tutorial</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Adve</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gharachorloo</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">computer</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Associating synchronization constraints with data in an object-oriented language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vaziri</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tip</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dolby</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;06: Conference record of the 33rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="334" to="345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Dynamic deadlock avoidance for multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kudlur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lafortune</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mahlke</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Gadara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">8th USENIX Symposium on Operating Systems Design and Implementation</title>
		<meeting><address><addrLine>San Diego, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-12-08" />
			<biblScope unit="page" from="281" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Program slicing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weiser</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;81: Proceedings of the 5th international conference on Software engineering</title>
		<meeting><address><addrLine>Piscataway, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1981" />
			<biblScope unit="page" from="439" to="449" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Execution synthesis: a technique for automated software debugging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zamfir</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Candea</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroSys &apos;10: Proceedings of the 5th European conference on Computer systems</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="321" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Safedrive: Safe and recoverable extensions using language-based techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">R</forename><surname>Bagrak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>En-Nals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Harren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brewer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="45" to="60" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
