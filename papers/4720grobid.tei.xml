<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:30+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">BLESA: Spoofing Attacks against Reconnections in Bluetooth Low Energy</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianliang</forename><surname>Wu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Purdue University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Purdue University</orgName>
								<orgName type="institution" key="instit4">Purdue University</orgName>
								<orgName type="institution" key="instit5">Purdue University</orgName>
								<orgName type="institution" key="instit6">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuhong</forename><surname>Nan</surname></persName>
							<email>nan1@purdue.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Purdue University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Purdue University</orgName>
								<orgName type="institution" key="instit4">Purdue University</orgName>
								<orgName type="institution" key="instit5">Purdue University</orgName>
								<orgName type="institution" key="instit6">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vireshwar</forename><surname>Kumar</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Purdue University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Purdue University</orgName>
								<orgName type="institution" key="instit4">Purdue University</orgName>
								<orgName type="institution" key="instit5">Purdue University</orgName>
								<orgName type="institution" key="instit6">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dave</forename></persName>
							<email>daveti@purdue.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Purdue University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Purdue University</orgName>
								<orgName type="institution" key="instit4">Purdue University</orgName>
								<orgName type="institution" key="instit5">Purdue University</orgName>
								<orgName type="institution" key="instit6">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jing</forename><surname>Tian</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Purdue University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Purdue University</orgName>
								<orgName type="institution" key="instit4">Purdue University</orgName>
								<orgName type="institution" key="instit5">Purdue University</orgName>
								<orgName type="institution" key="instit6">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antonio</forename><surname>Bianchi</surname></persName>
							<email>antoniob@purdue.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Purdue University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Purdue University</orgName>
								<orgName type="institution" key="instit4">Purdue University</orgName>
								<orgName type="institution" key="instit5">Purdue University</orgName>
								<orgName type="institution" key="instit6">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathias</forename><surname>Payer</surname></persName>
							<email>epflmathias.payer@nebelwelt.net</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Purdue University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Purdue University</orgName>
								<orgName type="institution" key="instit4">Purdue University</orgName>
								<orgName type="institution" key="instit5">Purdue University</orgName>
								<orgName type="institution" key="instit6">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongyan</forename><surname>Xu</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Purdue University</orgName>
								<orgName type="institution" key="instit2">Purdue University</orgName>
								<orgName type="institution" key="instit3">Purdue University</orgName>
								<orgName type="institution" key="instit4">Purdue University</orgName>
								<orgName type="institution" key="instit5">Purdue University</orgName>
								<orgName type="institution" key="instit6">Purdue University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">BLESA: Spoofing Attacks against Reconnections in Bluetooth Low Energy</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The Bluetooth Low Energy (BLE) protocol ubiquitously enables energy-efficient wireless communication among resource-constrained devices. To ease its adoption, BLE requires limited or no user interaction to establish a connection between two devices. Unfortunately, this simplicity is the root cause of several security issues. In this paper, we analyze the security of the BLE link-layer, focusing on the scenario in which two previously-connected devices reconnect. Based on a formal analysis of the reconnec-tion procedure defined by the BLE specification, we highlight two critical security weaknesses in the specification. As a result , even a device implementing the BLE protocol correctly may be vulnerable to spoofing attacks. To demonstrate these design weaknesses, and further study their security implications, we develop BLE Spoofing Attacks (BLESA). These attacks enable an attacker to impersonate a BLE device and to provide spoofed data to another previously-paired device. BLESA can be easily carried out against some implementations of the BLE protocol, such as the one used in Linux. Additionally, for the BLE stack implementations used by Android and iOS, we found a logic bug enabling BLESA. We reported this security issue to the affected parties (Google and Apple), and they acknowledged our findings.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Bluetooth Low Energy (BLE) is the most widely utilized lowenergy communication protocol, and, by 2023, the number of BLE-capable devices is expected to reach 5 billion <ref type="bibr" target="#b9">[10]</ref>. The BLE protocol enables wireless, short-range communication which allows two devices to connect and exchange data. A typical usage scenario consists of a smartphone and a "gadget" device (such as a fitness tracker) that communicate over BLE. Every BLE connection involves a device acting as a client (in this example, the smartphone) and another device acting as a server (in this example, the fitness tracker). The first time two devices connect (allowing them to exchange data), they perform a specific pairing procedure, which varies depending on the type of the connected devices and their user-interfaces' capabilities.</p><p>The major factors that have helped the rapid growth of the adoption of BLE-enabled devices are its low cost and the minimal setup effort required for end users. Unfortunately, previous research <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b12">12,</ref><ref type="bibr" target="#b23">22,</ref><ref type="bibr" target="#b25">24,</ref><ref type="bibr" target="#b28">27]</ref> has shown that these userfriendly features have a negative impact on the security of this protocol. This concern is particularly worrisome since BLE communication is often used in security-sensitive devices, such as physical safety devices (e.g., locks) or health monitoring devices (e.g., medical implants) <ref type="bibr" target="#b16">[16]</ref>.</p><p>Researchers have pointed out and studied many implementation weaknesses in the BLE protocol by manually analyzing its specification <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b33">32,</ref><ref type="bibr" target="#b36">35]</ref>. Additionally, some previous works have also performed a formal automated analysis of the BLE specification <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b30">29]</ref>. However, these formal approaches only focused on limited aspects of the entire protocol, such as the BLE pairing mechanism. This limitation is due to the fact that it is challenging to fully formalize and automatically analyze the BLE specification. The challenges stem from the complexity of the BLE protocol, difficulties in modeling its multi-layer design, and its multiple variants and optional features (which allow this protocol to support a wide range of devices with significantly different capabilities).</p><p>In this paper, we study a previously-unexplored mechanism of the BLE protocol. Specifically, we focus on the mechanism of dealing with reconnecting two previously connected devices. This mechanism comes into play when, for instance, a server device (e.g., a fitness tracker) moves out of the BLE wireless communication range of a connected client device (e.g., a smartphone), and then at a later time, the two devices get close enough to re-establish a connection.</p><p>To start our analysis of this scenario, we first carried out a formal verification of the relevant BLE link-layer specification <ref type="bibr" target="#b11">[11]</ref>, by using the ProVerif protocol verifier <ref type="bibr" target="#b8">[9]</ref>. Our formal analysis highlighted two weaknesses in the BLE official specification. These weaknesses, in some BLE stack implementations, allow an attacker to launch a spoofing attack in which the attacker pretends to be a previously-paired server device, inducing a client device into accepting spoofed data.</p><p>In particular, we discovered that the BLE specification allows implementing several aspects of this protocol in multiple ways, some of which are vulnerable. For this reason, even BLE stack implementations correctly following the specification can potentially be susceptible to spoofing attacks. For instance, we found that the BLE protocol stack (when accessed via gatttool <ref type="bibr" target="#b27">[26]</ref>) used in Linux client devices (e.g., Linux laptops), while following the BLE specification correctly, is susceptible to the identified spoofing attack.</p><p>Furthermore, we discovered that even BLE protocol stacks implemented in ways that are, in theory, not susceptible to the identified attack are still vulnerable in practice due to a specific logic vulnerability. Specifically, we found a similar implementation issue in the BLE stack used by Android devices and in that used by iOS devices. This issue makes many Android and iOS devices vulnerable to the identified attack. We have responsibly reported our findings to Google and Apple, and they have confirmed these vulnerabilities. As of June 2020, while Apple has assigned the CVE-2020-9770 to the vulnerability and fixed it, the Android BLE implementation in our tested device (i.e., Google Pixel XL running Android 10) is still vulnerable.</p><p>To showcase the identified issues, we design a novel practical attack, named BLESA (BLE Spoofing Attack). In BLESA, the attacker pretends to be a previously-paired server device, rejects the authentication requests coming from the client device, and then feeds spoofed data to it. We then show that a Linux laptop running Ubuntu with the most updated version of its BLE stack is vulnerable to BLESA. In addition, we demonstrate the effectiveness of BLESA by launching it against Google Pixel XL phone recording the information from a wearable activity-tracking device called Oura Ring <ref type="bibr" target="#b26">[25]</ref>. In particular, by using BLESA, the attacker successfully impersonates the ring, injects spoofed data to the phone, and the companion application of the ring running on the phone accepts and displays the spoofed data.</p><p>In summary, our work has these main contributions:</p><p>• We performed a formal analysis of the BLE link-layer authentication mechanism and discovered two design weaknesses in the BLE protocol specification.</p><p>• We studied how these design weaknesses affect existing BLE stack implementations, and we discovered a related logic bug in the BLE link-layer implementations used by Android and iOS devices.</p><p>• Exploiting the identified design weaknesses and the discovered logic bug, we crafted a novel attack, named BLESA, which allows an attacker to impersonate a server device and provide forged data to a previously-paired client device.</p><p>• We proposed mitigation techniques to the identified security issues, which enable systemic changes in the reconnection procedure to make it robust against BLESA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>The original Bluetooth (Classic) protocol was designed for short-range wireless streaming applications such as audio, video, and file transfer. Different from Bluetooth Classic, Bluetooth Low Energy (BLE) is designed for energyconstrained low-cost IoT applications that require an intermittent transfer of smaller amounts of data at lower speeds.</p><p>The BLE protocol enables a device, acting as a server (e.g., a fitness tracker), to efficiently communicate relevant data (e.g., the number of tracked footsteps) to another connected device, acting as a client (e.g., a smartphone). In BLE, the typical communication procedure between the server and the client involves five steps:</p><p>1. The server advertises its presence by broadcasting advertising packets containing its identity. 2. The client scans for advertising packets to discover the server and establishes a wireless connection with it. 3. (Optionally) The client pairs with the server to share a long-term cryptographic key. This key is used to encrypt and authenticate the exchanged data. 4. The client initiates the request to access the data stored by the server. 5. The server checks if the client has the right to access the specific requested data. If this condition is true, the server grants read/write access to the requested data.</p><p>Security Levels. The data stored at a server is organized in attributes, and each attribute (e.g., a blood pressure measurement) is identified using a unique identifier. BLE allows the server to protect attributes at a fine-grained granularity. In particular, the server can specify an access control policy for each attribute. Each such policy describes how an attribute can be accessed (read-only, write-only, or read-and-write), and which security level is needed to access it. Specifically, there are four possible security levels: no security (level 1), encryption only (level 2), encryption and authentication (level 3), and strong encryption with authentication (level 4).</p><p>When an access request is received from the client, the server checks whether the current connection meets the security level required to access the requested attribute. If the connection satisfies the required security level, the server grants access to the requested attribute. Otherwise, the server denies the request and sends an error message back to the client.</p><p>Pairing and Key Generation.</p><p>The pairing between the client and the server is optional, and it depends on the security level requested by the server. When encryption or authentication is needed to access an attribute, the client and the server must be paired to establish a (long-term) shared secret key. Once the long-term key is generated between two devices, the two devices are said to be bonded, and the long-term key is utilized to derive session keys to encrypt and authenticate the exchanged data during reconnections.</p><p>Different pairing methods require different levels of user interaction, and a specific pairing method is selected based on the available user interface (e.g., keyboard and display) of the pairing devices. For example, if the server device has a graphical user interface (such as in a smartwatch), user interaction (e.g., pressing a button or inserting a PIN) is required to approve the pairing on the server. In this case, the generated key can be used to access security level 3 or 4 attributes (depending on the length of the key). Alternatively, if the server device does not have input or output interfaces (e.g., a temperature sensor), no user interaction is possible on the server-side. In this case, the generated key can only be used to access attributes requiring security level 2.</p><p>Note that authentication and encryption are not always needed since data transmission in plaintext is allowed in the specification. In fact, the access control policy specified by the server fully determines if encryption and/or authentication are used.</p><p>For example, the Polar H7 Heart Rate Sensor <ref type="bibr" target="#b32">[31]</ref> transmits the heart rate in plaintext. Hence, no pairing is needed to read the heart rate from this device. Conversely, the Fitbit smartwatch <ref type="bibr" target="#b21">[20]</ref> requires link-layer encryption and authentication. In this case, a smartphone has to pair with the smartwatch before reading its recorded data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Threat Model</head><p>We assume the adversary has the same capabilities as the Dolev-Yao model <ref type="bibr" target="#b20">[19]</ref>, i.e., the adversary can eavesdrop, intercept, and modify legitimate messages communicated between a server and a client. The adversary can also inject any message into the communication channel. However, the adversary does not know the secret key shared between the server and the client, and the used cryptographic functionality are perfectly secure. Also, the adversary cannot replace the firmware of the server or client. Since BLE is a short-range communication protocol, we assume that the distance between the adversary and the client, and the distance between the adversary and the server, are both within the Bluetooth range. In this scenario, the adversary aims to impersonate the server and to mislead the client with spoofed messages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Formal Analysis of BLE Reconnection</head><p>We perform formal verification of the BLE link-layer authentication mechanism when the client reconnects with a previously connected server. We utilize ProVerif <ref type="bibr" target="#b8">[9]</ref> to carry out this protocol verification.</p><p>Listing 1: ProVerif code with the verified security properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">ProVerif Model</head><p>We build a formal model for the authentication process when the client reconnects with the server in a new session. The authentication process is modeled as two communicating state machines, one for the client and one for the server. We model the state machine corresponding to the transmission of the attribute request of the client and the state machine corresponding to the handling of the attribute request on the server in the BLE specification <ref type="bibr" target="#b11">[11]</ref>. The model comprehensively covers the different types of messages including those corresponding to the attribute access requests, attribute access responses, and the error responses. The communication between the client and the server is modeled as the free (or open) channel (free plain_channel: channel) where the adversary has the abilities as described in the threat model.</p><p>We also consider all the features of the attributes to cover the different usage scenarios of server devices. Therefore, we model the attributes on the server as both readable and writable.</p><p>Furthermore, we model two types of attributes: (1) basic attributes that can be accessed without pairing (i.e., at security level 1), and (2) sensitive attributes that can be accessed after pairing (at security level 2 or higher). Finally, we model the client to send access requests to the server to read/write these two types of attributes in different orders. The shared secret key established during the pairing is used to encrypt/decrypt the traffic when encryption is needed.</p><p>Security Goals. We analyze the above model in the light of traditional security goals that are presented in Listing 1. These security goals include: (1) Confidentiality, i.e., the communicated messages should not leak any sensitive data to the adversary (Line 6-9), (2) Integrity, i.e., the communicated messages should not be tampered by the adversary without being detected (Line 6-9), and (3) Authenticity, i.e., the communicated messages can be verified to be generated by the genuine sender (Line 11). Besides, we also check one BLE specific security goal extracted from the rules specified in the specification <ref type="bibr" target="#b11">[11]</ref> when initiating requests from the client and handling requests on the server. Only if the security level of the connection is consistent with the requirement to access the attribute, should the server give read/write access to the client (Line 13).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Discovered Design Weaknesses</head><p>Through formal verification, we discover several instances of violations of the checked security goals when the previouslyconnected devices reconnect. These violations result in the following two security weaknesses that can be potentially exploited by an adversary to launch spoofing attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Weakness-1: Optional Authentication</head><p>We find that the link-layer encryption/authentication is optional: the client and the server may choose to disable it for a specific attribute. Therefore, in the case of the basic attribute, the confidentiality, integrity, and authenticity goals of the attribute access request and response can be violated as shown in the following results from ProVerif.</p><p>RESULT not attacker(attAccessRsp[]) is false.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Counterexample:</head><p>out(plain_channel, ~M) with ~M = attAccessReq at 2 in copy a in(plain_channel, ~M) with ~M = attAccessReq at 11 in copy a_1 out(plain_channel, ~M_1) with ~M_1 = errCode at 13 in copy a_1 in(plain_channel, a_2) at 14 in copy a_1 out(plain_channel, ~M_2) with ~M_2 = attAccessRsp at 16 in copy a_1 The attacker has the message ~M_2 = attAccessRsp. A trace has been found.</p><p>We note that the server determines the security level of its connection with the client based on the requested attribute's access control policy. As the counterexample shows, when the access control policy allows the lowest security level (i.e., security level 1) of the connection, the attribute access request and the response can be transmitted in plaintext. In this case, no link-layer authentication is deployed. Therefore, the attacker can launch spoofing attacks against the server and the client devices.</p><p>We highlight that because the security level of the connection is guided by the server, the client cannot enforce a connection with higher security levels if the server only allows connections with security level 1. This aspect makes both the server and the client vulnerable to spoofing attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Weakness-2: Circumventing Authentication</head><p>The BLE specification provides two possible authentication procedures when the client reconnects with the server after pairing.</p><p>(1) Reactive Authentication. In this procedure, the client sends the attribute access request in plaintext (i.e., at security level 1) right after establishing the connection. Only if the server responds with an error message revealing an inconsistency between the current security level of the connection and the one required for accessing the attribute, the client reacts by enabling the encryption/authentication.</p><p>For this procedure, the formal analysis indicates that the authenticity of the access response can be violated, as shown by the following ProVerif output.</p><p>RESULT inj-event(clientRecvRsp) ==&gt; inj-event(serverSendRsp) is false.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Counterexample:</head><p>event clientReqSecLv(secLv1) at 3 in copy a out(plain_channel, ~M) with ~M = attAccessReq at 4 in copy a in(plain_channel, a_1) at 5 in copy a event clientRecvRsp at 14 in copy a (goal) The event clientRecvRsp is executed at 14 in copy a. A trace has been found.</p><p>As the counterexample shows, the attacker can first intercept the request sent from the client. After that, the attacker can respond to the client with any message other than an error message, so that the client will receive and accept the message from the attacker.</p><p>Although the sensitive attribute stored at the server is not leaked to the adversary, the adversary can eavesdrop on the request sent by the client, impersonate the server, and trick the client with a spoofed response corresponding to the sensitive attribute. We will demonstrate in Section 5.1 that the existing BLE stack implementation (when accessed via gatttool) on Linux follows this reactive authentication making the corresponding clients vulnerable to spoofing attacks.</p><p>(2) Proactive Authentication. In this procedure, the client device proactively enables the encryption/authentication before sending any request to the server. In particular, the client enables the encryption using the pre-shared secret key previously established, and then it proceeds with the authentication. In this case, if the server fails to enable the encryption (which also means that it fails to enable the authentication), the client aborts the connection. Our formal verification shows that all the checked security goals hold during proactive authentication, as shown by the following results.</p><formula xml:id="formula_0">RESULT not attacker(attSecAccessReq[]) is true. RESULT not attacker(attSecAccessReq[]) is true. RESULT inj-event(clientRecvRsp) ==&gt; inj-event(serverSendRsp) is true. RESULT inj-event(clientReqSecLv(x)) ==&gt; inj-event(serverRspSecLv(x)) is true.</formula><p>Unfortunately, as we will further elaborate in Section 5.2, the existing BLE stack implementations used by Andriod and iOS fail to correctly follow this procedure making the  corresponding clients vulnerable to spoofing attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">BLE Spoofing Attack (BLESA)</head><p>We exploit the design weaknesses identified through the formal verification to craft the BLE Spoofing Attack (BLESA). In this attack, an adversary provides spoofed data to a client device pretending to be a previously-paired server device.</p><p>Attack Setup. We examine the scenario where the server and the client were securely paired in a previous session. Currently, they are disconnected, but they intend to start a new session. This scenario happens when, for instance, the client moves out of the communication range of the server and then it gets back.</p><p>In this scenario, the adversary first discovers the server and connects with it to obtain information (e.g., the identifier) about a server's attributes. The adversary can easily obtain this information because the BLE protocol is designed to allow any device to connect with another BLE device and obtain information about provided attributes. Further, since the BLE advertising packets are always transmitted in plaintext, the adversary can easily impersonate the benign server by advertising the same packets and cloning its MAC address. Then, the adversary starts broadcasting spoofed advertising packets to ensure that whenever the client attempts to start a new session with the previously-paired server, it can discover the spoofed advertising packets and establish a connection with the adversary.</p><p>At this point, the adversary is ready to launch BLESA against the client. We present the workflows of BLESA against the client following the reactive authentication procedure and that following the proactive authentication procedure in the following sections. <ref type="figure" target="#fig_1">Figure 1a</ref> shows an illustration where the client and the server reconnect, and the reactive authentication procedure (discussed in Section 4.2.2) plays out in a benign environment. The client first sends an attribute read request to the server at the lowest security level (i.e., level 1) without any encryption/authentication. If the attribute is sensitive and can be read only at a higher security level (e.g., security level 3 with encryption and authentication), the server responds to the client with an error message (e.g., insufficient encryption). After receiving the error message, the client elevates the security level by enabling encryption and authentication using the preshared secret key and sends the request again. At this time, the server readily accepts the read request and returns the attribute value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">BLESA against Reactive Authentication</head><p>Now we present the workflow of BLESA, as shown in <ref type="figure" target="#fig_1">Figure 1b</ref>. Here, the adversary intercepts the attribute read request from the client and responds with a spoofed attribute value. Since the client does not encounter any error message, it mistakenly assumes that the attribute can be accessed at the  lowest security level (i.e., in plaintext). Therefore, the client does not enable the encryption/authentication, and it accepts the spoofed attribute value.</p><note type="other">Server Client (Encrypted and authenticated) Attribute value (Encrypted and authenticated) Read attribute request Reconnect to a paired server device Connected Connected Connection request Enable encryption Encryption and authentication enabled Encryption and authentication enabled Accept attribute value (a) Reconnection with the paired benign server. Reconnect to a paired server device No longterm key Advertise as benign device No authentication or encryption Connected Connected Bypass authentication and connection not abort Client Connection request Enable encryption Encryption fails Attribute read request Spoofed attribute value</note><p>We highlight that in this instantiation of BLESA, the fundamental reason making the attack possible is the fact that the client device relies on the server's error message to adapt the used security level. <ref type="figure" target="#fig_3">Figure 2a</ref> shows the workflow of the proactive authentication procedure triggered when a client device reconnects with a benign server. Right after the connection, the client requests to enable the encryption (and authentication) using the preshared key, and the server complies with the request. Then the client securely sends an attribute read request, and the server securely responds with the (encrypted and authenticated) attribute value. If the BLE stack correctly implementing the proactive authentication follows the specification (as presented in <ref type="figure" target="#fig_1">Figure 10</ref>.2 on page 1382 in <ref type="bibr" target="#b11">[11]</ref>), BLESA will fail against the client. However, our further analysis reveals that both Android and iOS-based client devices suffer from a logic bug that makes BLESA possible against these devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">BLESA against Proactive Authentication</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementation Vulnerability.</head><p>According to the BLE specification, when the client reconnects with the previouslypaired server, if the encryption enabling process fails during the proactive authentication procedure, the client should either re-pair with the server (as mentioned in <ref type="figure" target="#fig_4">Figure 3</ref>) or abort the connection. However, the BLE stacks in some clients (i.e., ... If encryption fails either the bond no longer exists on the remote device, or the wrong device has been connected. The local device must, after user interaction to confirm the remote device, re-bond, perform service discovery and re-configure the remote device...  <ref type="bibr" target="#b11">[11]</ref>) indicating the steps to deal with the failure in enabling the encryption during the proactive authentication procedure.</p><p>Android and iOS-based devices) fail to follow the specification correctly. Specifically, we discover that even if the enabling encryption process fails, the client may not abort the connection and continue the communication in plaintext without re-pairing with the server. This flaw can be exploited by an adversary to launch BLESA.   <ref type="bibr" target="#b11">[11]</ref>) indicating the procedure to deal with the non-availability of the long-term key at the client device.</p><p>We suspect that this implementation vulnerability is likely caused by the way in which this part of the BLE protocol is explained in the official documentation.</p><p>Specifically, since encryption is not mandatory in BLE for accessing basic attributes and some server devices do not support link-layer encryption (i.e., the design weakness-1 discussed in Section 4.2.1), the BLE specification makes provisions to maintain the compatibility and enhance usability with these resource-constrained server devices. For this reason, when the encryption/authentication fails, the BLE data and control messages can still be transmitted in plaintext as described in the specification <ref type="figure" target="#fig_6">(Figure 4)</ref>. We believe that the contradiction originating from the details in the specification shown in <ref type="figure" target="#fig_4">Figures 3 and 4</ref> may have confused the BLE stack developers. As such, they made the logical mistake of not aborting the connection in the event of failure of the encryption process, which is mandatory for accessing the security-sensitive attributes on a previously-paired server. <ref type="figure" target="#fig_3">Figure 2b</ref> presents the details of how the BLESA succeeds against client devices using the proactive authentication procedure, but affected by the explained implementation vulnerability. Specifically, after the connection to the adversary, if the client attempts to enable the encryption, the adversary sends an error message to the client specifying the non-availability of the long-term key so that the encryption fails. At this point, the client does not follow correctly the BLE specification (which, in this case, recommends aborting the connection), but continues the connection with the adversary.</p><p>Due to the first design weakness described in Section 4.2.1, the client then proceeds to send the read request for the target attribute in plaintext. Unlike the server, the adversary readily grants the access to the attribute, making it available at the lowest security level (i.e., security level 1), and it feeds spoofed attribute data to the client. Consequently, the client accepts the spoofed data from the adversary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Implementation and Impact</head><p>In this section, we first examine the impact of the two identified design weaknesses in the real-world BLE stack implementations (Section 6.1 and Section 6.2). We then elaborate on the impact of BLESA on the Linux platforms (Section 6.3) and the Android/iOS mobile platforms (Section 6.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Examination of Design Weakness-1</head><p>To find out if there are indeed certain BLE server devices that do not employ the link-layer authentication, we follow two approaches: (1) We inspect the behavior of a set of BLE devices' companion applications through static analysis. <ref type="formula">(2)</ref> We sample a set of real-world BLE devices and inspect their communication packets with runtime analysis.</p><p>Static Analysis of Mobile Applications. A typical BLE device (e.g., Fitbit fitness tracker) relies on its companion mobile application (e.g., the Fitbit application) which enables the end-user to access and manage the recorded attribute data (e.g., the number of footsteps). Since the pairing procedure (to establish a secret key) is one of the prerequisites for enabling the link-layer authentication, we can readily confirm that the BLE device does not support the link-layer authentication if there is no pairing API invoked in its companion application. To this end, we utilize the static analysis framework, FlowDroid <ref type="bibr" target="#b5">[6]</ref>, to inspect the Android BLE applications. More specifically, for each companion application, we use the Class Hierarchical Analysis (CHA) option in FlowDroid to build the call graph and find whether the application indeed invokes the pairing API from any of its entry points (e.g., an Activity). Since CHA is a relatively conservative way for call-graph construction, it may miss part of the method invocations. However, the analysis result is much more precise, with minimal false positives compared to other options (e.g., SPARK) <ref type="bibr" target="#b24">[23]</ref>. Hence, it provides us a lower-bound of BLE apps using pairing. Our static analysis starts with 33,785 popular applications, which are automatically crawled from AndroZoo website <ref type="bibr" target="#b0">[1]</ref> in January and February 2020. Based on the constructed callgraph and corresponding APIs of these applications, we find that only 127 applications contain the BLE data read/write operations. We then check if the pairing API (createBond()) is invoked in these applications. Unfortunately, we find that only 41 (32.3%) out of the 127 inspected applications contain the pairing procedure, implying that a majority of the investigated BLE companion applications (67.7%) do not implement the link-layer authentication. Runtime Analysis of Transmitted Packets. We examine 12 BLE devices (as listed in <ref type="table" target="#tab_0">Table 1</ref>) which are selected to represent a variety of application from mainstream BLE device manufacturers. We connect each of these server devices with a Google Pixel XL phone and read their attributes. During these experiments, we intercept the runtime communicated packets using an Ubertooth One radio <ref type="bibr" target="#b34">[33]</ref>. By analyzing the intercepted packets, we find that 10 out of the 12 inspected BLE devices do not support any link-layer encryption/authentication. To this end, we conclude that most real-world BLE devices do not employ link-layer authentication.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Examination of Design Weakness-2</head><p>For the examination of the second weakness, we test four different client devices that cover all major platforms with different BLE stack implementations. We present detailed information about these devices in <ref type="table" target="#tab_1">Table 2</ref>. We run experiments on each of these platforms to explore the answers for the following two questions: (1) Which of the two authentication procedures (i.e., reactive or proactive, as discussed in Section 4.2.2) does the client device utilize when it reconnects with a server device? (2) If the client device follows the proactive authentication procedure, does its BLE stack implementation have any logic flaw making it vulnerable against a spoofing attack? To answer these two questions, we first pair each tested client with a server (which is emulated using a Linux laptop, as shown in <ref type="table" target="#tab_2">Table 3</ref>) and then disconnect them. Thereafter, we reconnect the tested client with the same server, and we ask the client to read one of the server's attributes, while capturing all the generated BLE traffic using Wireshark <ref type="bibr" target="#b19">[18]</ref>. By analyzing the traffic data corresponding to the Linux laptop used as the client, we find that the Linux BLE stack (i.e., BlueZ accessed via gatttool) implements the reactive authentication procedure. As a result, the Linux BLE stack suffers from the weakness described in Section 4.2.2.</p><p>Conversely, we find that the Android, iOS, and Windows BLE stacks implement the proactive authentication procedure. Among them, the Windows BLE stack strictly follows the BLE specification. However, both Android and iOS devices continue the reconnection even when the encryption/authentication fails (as elaborated in Section 5.2). Responsible Disclosure.</p><p>We have reported the vulnerability to Apple and Google on April 8, 2019. Apple has acknowledged our findings, assigned the CVE-2020-9770 to the vulnerability, and fixed it. Although Google has also confirmed the vulnerability, we have been told that our vulnerability report is similar to another report submitted three days earlier than us <ref type="bibr" target="#b0">1</ref> . We note that a more recent (as of May <ref type="bibr" target="#b0">1</ref> We received the following reply from Google: "The Android Security  2020) Android BLE implementation in our test device (i.e., Google Pixel XL with Android 10) is still vulnerable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">BLESA against Linux Clients</head><p>For attacking the Linux client (listed in the third row in Table 2), we utilize another Linux laptop (listed in the first row in <ref type="table" target="#tab_2">Table 3</ref>) as the server device. The emulated server runs a python script to provide a service corresponding to a sensitive attribute that can be read at security level 3 (i.e., with an encrypted and authenticated connection). To emulate the adversary, we use a Linux desktop with a CSR 4.0 <ref type="bibr" target="#b15">[15]</ref> Bluetooth dongle (shown in <ref type="table" target="#tab_3">Table 4</ref>). The adversary also runs a python script that handles the messages received from the client and launches BLESA against it. Besides, we use the gatttool on the client device to send the attribute read requests and receive the responses. To launch BLESA, the adversary carries out the following steps which are akin to the procedure described in Section 5.1:  scan (bluetoothctl) for the advertising packets transmitted by the server to record its MAC address;  change the adversary's Bluetooth MAC address (bdaddr tool in BlueZ) to the server's MAC address so that the client can reconnect with the adversary;  broadcast the same (impersonated) advertising packets as the server by issuing Host Controller Interface (HCI) commands, HCI_LE_Set_Advertising_Parameters, HCI_LE_ Set_Advertising_Data, and HCI_LE_Set_Advertising_ Enable, to the dongle; and inject the spoofed data via ATT_ READ_RSP message after receiving ATT_READ_REQ message from the client.</p><p>By performing these steps, the adversary successfully bypasses the reactive authentication procedure of the Linux client and tricks the client into accepting the spoofed data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">BLESA against Android/iOS Clients</head><p>Since BLESA bypasses the link-layer authentication by downgrading the connection to plaintext, all Android and iOSbased client devices communicating with the BLE server  devices that do not employ any application-layer security mechanism (e.g., encryption or authentication) are vulnerable to BLESA. We note that according to prior research <ref type="bibr" target="#b33">[32]</ref>, 46% of the Android applications (2,379 million cumulative installations) do not utilize application-layer security while reading data from BLE server devices. This implies that at least 46% of the Andriod applications are vulnerable against BLESA. The Apple app store is likely to have a similar proportion of vulnerable applications.</p><p>Here, we present how an adversary (shown in <ref type="table" target="#tab_3">Table 4</ref>) launches BLESA against a Google Pixel phone (the client device, shown in <ref type="table" target="#tab_1">Table 2</ref>) by impersonating an Oura Ring (the server device, shown in <ref type="table" target="#tab_2">Table 3</ref>). The adversary carries out the first three steps similar to those utilized for attacking Linux clients as discussed in Section 6.3, i.e.,  scan for the advertising packets of the ring;  clone the advertising packets and the MAC address of the ring;  advertise as the ring. Thereafter, the adversary performs the following: send an HCI command HCI_LE_Long_Term_Key_</p><p>Request_Negative_Reply indicating the unavailability of the key to bypasse the encryption and authentication when the HCI event HCI_LE_Long_Term_Key_Request is received;</p><p> inject the spoofed data via ATT_READ_RSP messages after receiving ATT_READ_REQ message from the phone. We note that the adversary can follow the same steps to launch BLESA against an iOS client device (the second row in <ref type="table" target="#tab_1">Table 2</ref>).</p><p>By performing these steps, the adversary successfully injects spoofed data into the smartphone, and the companion application of the ring running on the smartphone displays the spoofed data to the user. <ref type="figure" target="#fig_8">Figure 5a</ref> shows that, in our experiment, the real battery level of the Oura Ring device is 43%. Through BLESA, we successfully inject a spoofed battery level (0%) to the application, as shown in <ref type="figure" target="#fig_8">Figure 5b</ref>.</p><p>At the same time, we also inject another spoofed message which triggers a notification in the application mentioning that the charging is complete, as shown in <ref type="figure" target="#fig_8">Figure 5c</ref>.</p><p>We note that although the first spoofed message tricks the application into believing that the battery level is at 0%, the application interestingly accepts another spoofed message (corresponding to charging completion) and displays the false notification to the user. A demo of this attack can be accessed at https://pursec.cs.purdue.edu/projects/ blesa.html.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Mitigation of BLESA</head><p>To prevent BLESA, we need to secure the reconnection procedure between clients and their previously-paired server devices. We can achieve this by improving the BLE stack implementations and/or updating the BLE specification.</p><p>Updating Implementation.</p><p>As far as the Linux BLE stack (BlueZ accessed via gatttool) is concerned, the client devices can be updated to only employ the proactive authentication. We clarify that, another Linux client tool, bluetoothctl, used by typical applications and built on the D-Bus APIs in BlueZ, strictly follows the proactive authentication specification, and therefore, is immune to BLESA. According to BlueZ developers, they have marked gatttool as deprecated and will remove gatttool and its source code from BlueZ completely and only keep bluetoothctl. Also, the discovered implementation vulnerability of the proactive authentication used by Android and iOS clients can be mitigated by correctly following the BLE specification. The updated implementation must ensure that when the authentication with a previously-paired server fails, the client aborts the connection and restarts the pairing process.</p><p>A more fundamental problem is that even for the proactive authentication, BLESA can bypass the link-layer authentication in the presence of other potential bugs in the implementation. This is a typical scenario in which authentication at multiple layers is suggested by the security researchers <ref type="bibr" target="#b22">[21]</ref>. In fact, the link-layer problem would not be an exploitable issue if we had authenticaiton/encryption at application-layer. Unfortunately, such an improvement might not be widely deployed because a large proportion of resource-constrained devices cannot be remotely updated.</p><p>Updating Specification. We argue that while it is important to fix the implementation bugs to promptly make the BLE devices secure against BLESA, it is equally critical to chart out a roadmap to prevent more advanced spoofing attacks.</p><p>To this end, we should prevent the client from sending the attribute access request first and adjust the security level of the connection later based on the error message returned by the server. In other words, the client should first obtain the authentic information about the access requirements of the attributes stored at the server, and then adjust the security level of the connection to meet those requirements, before sending the access request. However, this approach requires the client to record the security requirements for each attribute on the server during the pairing process. Therefore, pairing process in the specification needs to be updated so that the server can send the security requirements of each of its attributes to the client.</p><p>Challenges and Future Directions. Patching different vulnerabilities at different layers in a timely fashion is a naive and straight forward approach to prevent spoofing attacks in BLE. However, this approach is unlikely to work well in practice because such ad-hoc, case-by-case fixes might not be feasibly adopted by the extremely fragmented BLE ecosystem at a large-scale. BLE device vendors tend to sacrifice security for utility, especially for low-end BLE devices. It is especially challenging to secure those low-end BLE devices that do not support any firmware update. Also, it is difficult to modify the pairing process while maintaining the backward compatibility with the legacy BLE devices. In addition, fundamentally addressing the BLE protocol vulnerabilities will require updating the BLE specification, which requires a lot of time and coordination. Therefore, such challenges bring the need for a device-agnostic, legacy-friendly, and comprehensive solution to mitigate the threat of spoofing attacks, as partially explored by a recent study <ref type="bibr" target="#b35">[34]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related Work</head><p>Formal analysis of the Bluetooth Protocol. Existing literature focuses on the formal analysis of Bluetooth pairing protocols. Chang et al. <ref type="bibr" target="#b13">[13]</ref> have formally analyzed the authentication process in the Bluetooth legacy pairing and the secure simple pairing, and revealed their weaknesses. Phan et al. <ref type="bibr" target="#b31">[30]</ref> have also formally verified and found vulnerabilities in the secure simple pairing. Arai et al. <ref type="bibr" target="#b4">[5]</ref> have specifically analyzed the numeric comparison protocol used in the secure simple pairing and identified potential attacks. Nguyen et al. <ref type="bibr" target="#b30">[29]</ref> have discovered vulnerabilities in the protocols that use out-of-band channels to establish shared keys. In contrast, in this paper, we focus on the formal modeling and analysis of the reconnection procedure in the BLE protocol, which leads to two design weaknesses in the authentication process.</p><p>Attacks against Bluetooth. A majority of the recent studies focus on the design weaknesses and implementation flaws in the Bluetooth stacks. Naveed et al. <ref type="bibr" target="#b29">[28]</ref> have discussed the mis-binding between applications and external Bluetooth Classic devices. Sivakumaran et al. <ref type="bibr" target="#b33">[32]</ref> have revealed similar mis-binding issues for BLE devices and analyzed the application-layer security issues in BLE applications on Android. Antonioli et al. <ref type="bibr" target="#b2">[3]</ref> have discovered a logic flaw in the key negotiation protocol during pairing and exploited it to decrypt the encrypted traffic. <ref type="bibr">BadBluetooth [35]</ref> has revealed how a malicious Bluetooth device can launch severe attacks against mobile platforms. Biham et al. <ref type="bibr" target="#b7">[8]</ref> have focused on the Elliptic Curve Diffie-Hellman protocol and found weaknesses in the Bluetooth pairing procedure against invalid curve attacks. The study closest to our work is presented by Antonioli et al. <ref type="bibr" target="#b3">[4]</ref> where they have presented impersonation attacks against Bluetooth Classic by exploiting the existing support for legacy pairing methods and role-switching feature. In this paper, we focus on the design weaknesses and implementation vulnerabilities in the BLE stack and how they can be exploited to launch the spoofing attack, BLESA. We highlight that since BLESA can be launched by an adversary without any additional assistance from a malicious application preinstalled on the client device, it is more powerful and practical than the attacks in the prior art <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b29">28,</ref><ref type="bibr" target="#b33">32,</ref><ref type="bibr" target="#b36">35]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion</head><p>In this paper, we carried out a formal verification of the reconnection procedure defined in the BLE specification, and we discovered two design weaknesses in the BLE link-layer authentication mechanism. By exploiting these design weaknesses, we proposed BLESA, a novel BLE spoofing attack through which an attacker can impersonate a BLE server device and provide spoofed data to a previously-paired BLE client device. BLESA can easily be launched against a BLE device running Linux (accessed via gatttool).</p><p>In addition, further examination of the identified weaknesses in real-world BLE implementations revealed a related implementation vulnerability in the Android and iOS BLE stacks. Due to this vulnerability, these two stacks are vulnerable against BLESA.</p><p>To showcase BLESA, we provided an in detail description of how to use this attack to spoof data coming from a fitness tracker to an Android smartphone. Moreover, we estimated the number of existing Android apps potentially affected by this attack. Finally, we discussed possible improvements in the reconnection procedure, to fundamentally mitigate the threat of spoofing attacks like BLESA.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>(</head><label></label><figDesc>Encrypted and authenticated) Read attribute request Connected Connected Connection request Reconnect to a paired server device Accept attribute value Client (a) Reconnection with the paired benign server. (Plaintext) No authentication or encryption Spoofed attribute value (Plaintext) Read attribute request Adversary Connected Connected Connection request Reconnect to a paired server device Accept spoofed attribute value Client Advertise as benign server (b) Instantiation of BLESA against the client.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: BLE communication workflow when the client (following the reactive authentication procedure) reconnects with (a) the benign server and (b) the adversary which exploits the security weaknesses to circumvent the authentication procedure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Instantiation of BLESA against the client.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: BLE communication workflow when the client (following the proactive authentication procedure) reconnects with (a) the benign server and (b) an adversary exploiting BLESA.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Description of the BLE protocol (page 1381 in [11]) indicating the steps to deal with the failure in enabling the encryption during the proactive authentication procedure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>.</head><label></label><figDesc>.. if the Host indicates that a key is not available, the slave shall either send an LL_REJECT_IND ... or Key Missing ... The Link Layer can now send LL Data PDUs and LL Control PDUs; these packets will not be encrypted.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Description of the BLE protocol (page 3031 in [11]) indicating the procedure to deal with the non-availability of the long-term key at the client device.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Team believes that this is a duplicate of a report previously submitted by another external researcher on Apr 5, 2019". (a) Benign battery level (43%). (b) Spoofed battery level (0%). (c) Spoofed notification for charging.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Demonstration of the impact of BLESA on the data displayed by the Oura Ring application on the Google Pixel phone.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><head>Table 1 : List of BLE server devices examined to evaluate the impact of the design weakness-1.</head><label>1</label><figDesc></figDesc><table>Device Name 
Support for link-layer 
authentication 

Nest Protect Smoke Detector 
× 
Nest Cam Indoor Camera 
× 
SensorPush Temperature Sensor 
× 
Tahmo Tempi Temperature Sensor 
× 
August Smart Lock 
× 
Eve Door&amp;Window Sensor 
× 
Eve Button Remote Control 
× 
Eve Energy Socket 
× 
Ilumi Smart Light Bulb 
× 
Polar H7 Heart Rate Sensor 
× 
Fitbit Versa Smartwatch 
√ 

Oura Smart Ring 
√ 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><head>Table 2 : List of BLE client platforms examined to evaluate the impact of the design weakness-2 and utilized as the victims to evaluate BLESA.</head><label>2</label><figDesc></figDesc><table>Platform 
OS 
BLE Stack 

Google Pixel XL 
Android 8.1, 9, 10 
Fluoride [17] 
iPhone 8 
iOS 12.1, 12.4, 13.3.1 
iOS BLE stack 

Linux Laptop 
Ubuntu 18.04 
BlueZ 5.48 [14] 
(accessed via gatttool) 
Thinkpad X1 Yoga 
Windows 10 V. 1809 
Windows stack 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 3 : BLE server devices utilized to evaluate BLESA.</head><label>3</label><figDesc></figDesc><table>Platform 
OS 
BLE Stack 

Linux Laptop 
Ubuntu 18.04 
BlueZ 5.48 
Oura Ring [25] 
Vendor OS 
Vendor Firmware 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 4 : Adversary's platform for launching BLESA.</head><label>4</label><figDesc></figDesc><table>Platform 
OS 
BLE Stack 

Linux PC &amp; BT Dongle 
Ubuntu 18.04 
BlueZ 5.48 

</table></figure>

			<note place="foot" n="1"> free attAccessReq [private]. 2 free attAccessRsp [private]. 3 free attSecAccessReq [private]. 4 free attSecAccessRsp [private]. 5 // Secrecy and integrity of attribute read request and attribute value 6 query attacker( attAccessReq ). 7 query attacker( attAccessRsp ). 8 query attacker( attSecAccessReq ). 9 query attacker( attSecAccessRsp ). 10 // Authenticity of attribute request and response 11 query event( clientRecvRsp ) == &gt; inj-event( serverSendRsp ). 12 // Consistency of request and response security levels 13 query x: SecLv ; event( clientReqSecLv (x))== &gt; inj-event( serverRspSecLv (x)).</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank the anonymous reviewers for their valuable comments and suggestions. This work was supported in part by ONR under Grant N00014-18-1-2674. Any opinions, findings, and conclusions in this paper are those of the authors and do not necessarily reflect the views of the ONR.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Androzoo: Collecting millions of android apps for the research community</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Allix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Tegawendé</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacques</forename><surname>Bissyandé</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yves</forename><forename type="middle">Le</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Traon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Mining Software Repositories, MSR &apos;16</title>
		<meeting>the 13th International Conference on Mining Software Repositories, MSR &apos;16</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Key negotiation downgrade attacks on bluetooth and bluetooth low energy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniele</forename><surname>Antonioli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nils</forename><surname>Tippenhauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kasper Bonne Rasmussen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Inf. Syst. Secur</title>
		<imprint>
			<biblScope unit="page">0</biblScope>
		</imprint>
	</monogr>
	<note>ja</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The KNOB is Broken: Exploiting Low Entropy in the Encryption Key Negotiation Of Bluetooth BR/EDR</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniele</forename><surname>Antonioli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nils</forename><forename type="middle">Ole</forename><surname>Tippenhauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kasper</forename><surname>Rasmussen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium (USENIX Security)</title>
		<meeting>the USENIX Security Symposium (USENIX Security)</meeting>
		<imprint>
			<date type="published" when="2019-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">BIAS: Bluetooth Impersonation AttackS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniele</forename><surname>Antonioli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nils</forename><forename type="middle">Ole</forename><surname>Tippenhauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kasper</forename><surname>Rasmussen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Security and Privacy (S&amp;P)</title>
		<meeting>the IEEE Symposium on Security and Privacy (S&amp;P)</meeting>
		<imprint>
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Formal Verification of Improved Numeric Comparison Protocol for Secure Simple Paring in Bluetooth Using ProVerif</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenichi</forename><surname>Arai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Toshinobu</forename><surname>Kaneko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Security and Management (SAM)</title>
		<meeting>the International Conference on Security and Management (SAM)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>The Steering Committee of The World Congress in Computer Science</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">FlowDroid: Precise Context, Flow, Field, Object-Sensitive and Lifecycle-Aware Taint Analysis for Android Apps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Arzt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Siegfried</forename><surname>Rasthofer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Fritz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Bodden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandre</forename><surname>Bartel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacques</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yves</forename><forename type="middle">Le</forename><surname>Traon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Damien</forename><surname>Octeau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Mcdaniel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;14</title>
		<meeting>the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;14</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Exploiting BLE smart bulb security using BtleJuice: A step-bystep guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vaibhav</forename><surname>Bedi</surname></persName>
		</author>
		<ptr target="https://blog.attify.com/btlejuice-mitm-attack-smart-bulb/" />
		<imprint>
			<date type="published" when="2018-08-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Breaking the Bluetooth Pairing-The Fixed Coordinate Invalid Curve Attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eli</forename><surname>Biham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lior</forename><surname>Neumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Selected Areas in Cryptography</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An Efficient Cryptographic Protocol Verifier Based on Prolog Rules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruno</forename><surname>Blanchet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th IEEE Computer Security Foundations Workshop (CSFW-14)</title>
		<imprint>
			<date type="published" when="2001-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bluetooth Special Interest Group</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bluetooth Market Update</surname></persName>
		</author>
		<ptr target="https://www.bluetooth.com/bluetooth-resources/2019-bluetooth-market-update/,2019.Ac-cessed" />
		<imprint>
			<date type="published" when="2019-08-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Core specifications 5</title>
		<ptr target="https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=478726" />
	</analytic>
	<monogr>
		<title level="j">Bluetooth Special Interest Group</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<date type="published" when="2019-04-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Victor Casares. Mimo baby hack</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Formal analysis of authentication in bluetooth device pairing. FCS-ARSPA07</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vitaly</forename><surname>Shmatikov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bluez Contributers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bluez</surname></persName>
		</author>
		<ptr target="http://www.bluez.org/,2019.Accessed" />
		<imprint>
			<date type="published" when="2019-08-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Csr</forename><surname>Csr</surname></persName>
		</author>
		<idno>4.0</idno>
		<ptr target="https://www.amazon.com/Bluetooth-Adapter-Songway-Computer-Keyboard/dp/B07KWVXBKZ/ref=sr_1_46?keywords=bluetooth+adapter+car+4" />
	</analytic>
	<monogr>
		<title level="j">Bluetooth USB adapter</title>
		<imprint>
			<biblScope unit="page" from="0" to="1563227361" />
			<date type="published" when="2019-08-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Uncovering privacy leakage in BLE network traffic of wearable fitness trackers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Aveek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Parth</forename><forename type="middle">H</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen-Nee</forename><surname>Pathak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prasant</forename><surname>Chuah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mohapatra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International Workshop on Mobile Computing Systems and Applications (HotMobile)</title>
		<meeting>the 17th International Workshop on Mobile Computing Systems and Applications (HotMobile)</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Fluoride Bluetooth stack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Android</forename><surname>Developers</surname></persName>
		</author>
		<ptr target="https://android" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Readme</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2019-08-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Wireshark developers</title>
		<ptr target="https://www.wireshark.org.Accessed" />
		<imprint>
			<date type="published" when="2020-05-15" />
		</imprint>
	</monogr>
	<note>Wireshark Go Deep</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">On the security of public key protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danny</forename><surname>Dolev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on information theory</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fitbit</surname></persName>
		</author>
		<ptr target="https://www.fitbit.com/us/products/smartwatches/versa,2019.Accessed" />
		<imprint>
			<date type="published" when="2019-08-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Evaluating critical security issues of the IoT world: Present and future challenges</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mario</forename><surname>Frustaci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pasquale</forename><surname>Pace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gianluca</forename><surname>Aloi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giancarlo</forename><surname>Fortino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Internet of things journal</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Breaking BLE beacons for fun but mostly profit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Constantinos</forename><surname>Kolias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lucas</forename><surname>Copi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fengwei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Angelos</forename><surname>Stavrou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th European Workshop on Systems Security (EuroSec)</title>
		<meeting>the 10th European Workshop on Systems Security (EuroSec)</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Soot phase options (call graph construction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Lam</surname></persName>
		</author>
		<ptr target="https://www.sable.mcgill.ca/soot/tutorial/phase/phase.html" />
		<imprint>
			<date type="published" when="2019-08-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Security vulnerabilities in Bluetooth technology as used in IoT</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Angela</forename><surname>Lonzetta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Cope</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Campbell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bassam</forename><surname>Mohd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thaier</forename><surname>Hayajneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Sensor and Actuator Networks</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Oura Health Ltd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Oura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Smart Ring</surname></persName>
		</author>
		<ptr target="https://ouraring.com/products/,2019.Accessed" />
		<imprint>
			<date type="published" when="2019-08-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Ubuntu Manpage. gatttool -tool for Bluetooth Low Energy device</title>
		<ptr target="http://manpages.ubuntu.com/manpages/cosmic/man1/gatttool.1.html.Ac-cessed" />
		<imprint>
			<date type="published" when="2020-05-15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">An active man-in-the-middle attack on Bluetooth smart devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tal</forename><surname>Melamed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Safety and Security Engineering</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Inside job: Understanding and mitigating the threat of external device mis-binding on android</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muhammad</forename><surname>Naveed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiao-Yong</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soteris</forename><surname>Demetriou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaofeng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carl A</forename><surname>Gunter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Formal analysis of secure device pairing protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trung</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean</forename><surname>Leneutre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 13th International Symposium on Network Computing and Applications</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Analyzing the secure simple pairing in Bluetooth v4.0. Wireless Personal Communications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C-W</forename><surname>Raphael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Phan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mingard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">64</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Polar h7 heartrate sensor</title>
		<ptr target="https://support.polar.com/us-en/support/H7_heart_rate_sensor" />
		<imprint>
			<date type="published" when="2019-08-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A study of the feasibility of co-located app attacks against BLE and a large-scale analysis of the current application-layer security landscape</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pallavi</forename><surname>Sivakumaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jorge</forename><surname>Blasco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Security Symposium (USENIX Security)</title>
		<meeting>the USENIX Security Symposium (USENIX Security)</meeting>
		<imprint>
			<date type="published" when="2019-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Ubertooth Developers</title>
		<imprint/>
	</monogr>
	<note>Ubertooth One</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">BlueShield: Detecting Spoofing Attacks in Bluetooth Low Energy (BLE) Networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianliang</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuhong</forename><surname>Nan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vireshwar</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathias</forename><surname>Payer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongyan</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23nd International Symposium on Research in Attacks, Intrusions and Defenses</title>
		<imprint>
			<biblScope unit="page">2020</biblScope>
		</imprint>
	</monogr>
	<note>RAID 2020</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">BadBluetooth: Breaking Android Security Mechanisms via Malicious Bluetooth Peripherals</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fenghao</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenrui</forename><surname>Diao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiongyi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kehuan</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the 26th Annual Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
