<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:52+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">CoRD: A Collaborative Framework for Distributed Data Race Detection</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Baris</forename><surname>Kasikci</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer and Communication Sciences École Polytechnique Fédérale de Lausanne (EPFL)</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristian</forename><surname>Zamfir</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer and Communication Sciences École Polytechnique Fédérale de Lausanne (EPFL)</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Candea</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer and Communication Sciences École Polytechnique Fédérale de Lausanne (EPFL)</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">CoRD: A Collaborative Framework for Distributed Data Race Detection</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Modern concurrent software is riddled with data races and these races constitute the source of many problems. Data races are hard to detect accurately before software is shipped and, once they cause failures in production, developers find it challenging to reproduce and debug them. Ideally, all data races should be known before software ships. Static data race detectors are fast, have few false negatives, but unfortunately have many false pos-itives. Conversely, dynamic data race detectors do not have false positives, but have many false negatives and incur high runtime overhead. There is no silver bullet and, as a result, modern software still ships with numerous data races. We present CoRD, a collaborative distributed testing framework that aims to combine the best of the two approaches: CoRD first statically detects races and then dynamically validates them via crowdsourced executions of the program. Our initial results show that CoRD is more effective than static or dynamic detectors alone, and it introduces negligible runtime overhead.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Data races are a common root cause for many concurrency-related problems <ref type="bibr" target="#b19">[20]</ref>. They caused the loss of human lives <ref type="bibr" target="#b17">[18]</ref> as well as material losses <ref type="bibr" target="#b26">[27]</ref>. Moreover, practitioners report that it typically takes weeks, sometimes even months, to diagnose and fix a data race <ref type="bibr" target="#b8">[9]</ref>, which means that data races also waste significant development resources.</p><p>Even though they have potentially catastrophic consequences, data races are prevalent in modern software. Running a state-of-the-art data race detector while loading a web page in Firefox causes the detector to report more than 1, 000 unique data races <ref type="bibr" target="#b13">[14]</ref>. The reason why software riddled with races still works is that, data races do not always lead to an observable harmful effect in real applications (5%-24% according to <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b27">28]</ref>). This is because most data race bugs occur under thread interleavings that are rarely encountered during the common execution case.</p><p>Ideally, programs should have no data races at all. For instance, the new C and C++ standards allow the compiler to perform certain optimizations that may transform seemingly benign data races into harmful ones <ref type="bibr" target="#b1">[2]</ref>. The question is then how to ensure that software does not ship with any data races? This can be achieved by using data race detection before software is shipped. Data race detection can be broadly classified as either static or dynamic. Static data race detectors <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b27">28]</ref> analyze the program source code without executing it. They scale to large code bases, providing results in a short amount of time. For instance, RELAY can analyze and report races in the Linux kernel (4 MLOC) in around 5 hours. Static race detectors typically have fewer false negatives (i.e., do not miss real races) than dynamic race detectors <ref type="bibr" target="#b22">[23]</ref>. However, static race detectors tend to have many false positives (i.e., produce reports that do not actually correspond to real races). For example, 84% of the races reported by RELAY <ref type="bibr" target="#b27">[28]</ref> are not true races.</p><p>Dynamic data race detectors typically do not have false positives, but only detect data races in executions they can directly observe, therefore they have many false negatives. They also have high runtime overhead (e.g., 200× in the case of Intel ThreadChecker <ref type="bibr" target="#b10">[11]</ref> and up to 8.5× in the case of FastTrack <ref type="bibr" target="#b5">[6]</ref>), because they typically need to monitor all memory accesses and synchronization primitives. Detectors that employ sampling <ref type="bibr" target="#b12">[13]</ref> decrease runtime overhead at the expense of introducing both false positives and false negatives. High runtime overhead indirectly decreases the coverage of dynamic detectors: they cannot be enabled in production, so they are only used by developers to detect races in executions of the program's test suite.</p><p>Therefore, the use of data race detection is limited on the one hand, by the abundance of false positives of static race detectors and, on the other hand, by the large number of false negatives and prohibitive overheads of dynamic race detectors. The problem stems from how the two approaches analyze program paths: Static detectors cannot obtain the full path context needed to determine the validity of the race, while dynamic detectors cannot perform the full-program analysis needed to find all races. This is why existing race detectors are rarely used <ref type="bibr" target="#b20">[21]</ref>.</p><p>We introduce CoRD, a collaborative framework for data race detection that combines the benefits of static and dynamic detectors: it has few false positives, few false negatives, and incurs negligible runtime overhead. CoRD detects data races using a static analysis pass with few false negatives, and then it crowdsources the dynamic validation of these data races in a full-path context on many machines, using a collaborative distributed framework. The validation step confirms real data races (true positives) and identifies likely false positives. CoRD is lightweight, and thus suitable for use in production software. Additionally, CoRD explicitly increases the probability of manifestation of race-related failures for testing purposes, thus helping developers to promptly classify the consequences of real data races <ref type="bibr" target="#b13">[14]</ref> and hopefully getting them fixed before they affect a wider user population.</p><p>In preliminary experiments, CoRD effectively detects 3 races that lead to deadlocks in SQLite and 4 races that lead to crashes in Pbzip2, while incurring a maximum runtime overhead of 1.6%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Case for Collaborative Race Detection</head><p>The collaborative race detection framework is a concrete instance of the SoftBorg information recycling vision <ref type="bibr" target="#b2">[3]</ref>, which argues that nodes running copies of the same program P should collaborate in identifying and fixing incorrect code in P, as well as construct proofs of the correct code.</p><p>Rather than trying to automate testing using a single, in-house testing infrastructure, SoftBorg advocates distributing the testing tasks among its participants in a way that is efficient and minimally intrusive for the participants. If the community of cooperative nodes is large, testing should be comprehensive and should amortize the overhead across the participants. The testing results should be more "meaningful" than in-house testing, because they result from actual program executions of the participants.</p><p>SoftBorg leverages the observation that software users have collectively, overwhelmingly more hardware than any single software company. For instance, Google's Chrome Web browser runs on more than 300 million computers <ref type="bibr" target="#b9">[10]</ref>, which exceeds by more than two orders of magnitude the most optimistic estimates of how many servers are housed in Google's data centers <ref type="bibr" target="#b11">[12]</ref>. Therefore, leveraging end-users to perform testing offers substantial advantages.</p><p>In this paper, we present an initial attempt at materializing this vision for the case of distributed collaborative data race detection. We describe an early-stage design and prototype, along with promising preliminary results. We also discuss our future research directions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">CoRD Design</head><p>CoRD's high-level architecture is shown <ref type="figure" target="#fig_0">Figure 1</ref>: The hive is a central program that performs data race detection. Pods are daemons running at the end-users' site, and they monitor the executions of program P and relay by-products of the execution to the hive.</p><p>We envision CoRD being used in the following way: First, developers set up a hive service for their software. The hive statically detects races in some program P and produces an instrumented version of P. The users download the instrumented version of P together with the pod. Then, the hive instructs the various running instances of P (by communicating with their pods) to explore both possible interleavings that a pair of racing memory accesses can exhibit. We call these interleavings the primary and the alternate. If the hive and the pod manage to orchestrate P to follow both the primary and the alternate interleaving, we say that the race is validated, because there exists conclusive proof that it is a real race.</p><p>The pods automatically connect to the hive and report the explored interleavings. The hive validates the races based on these reports. Validation results are then inspected by developers, who eventually fix the validated races and update the software. A new (instrumented) version of the software is created, and the process repeats. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Hive</head><p>The hive is set up and administered by the developers of an application. It can be deployed in a centralized server or in the cloud, depending on the required computational power. The hive generates instrumented binary executables, and makes them available to the users for download ( <ref type="figure" target="#fig_1">Figure 2</ref>): (step 1) the hive takes the program source code as input and compiles it to LLVM bitcode; (step 2) a static data race detector, operating on LLVM bitcode, identifies pairs of potentially racing memory access instructions; (step 3) the hive instruments the LLVM bitcode with calls before and after the potentially racing instructions. This instrumentation is used to orchestrate the thread schedule at the end-user site.</p><p>The instrumentation is done for all the potentially racing accesses, however, the hive selectively activates it on-demand when P runs, in different ways for different end-user machines. Essentially, this activation mechanism aims to validate as many races as possible by uniformly distributing validation tasks across the participants to CoRD. Finally, (step 4) the hive compiles the  CoRD's static race detector uses an interprocedural, flow-sensitive analysis that implements a static variant of the popular lockset-based dynamic race detection algorithm <ref type="bibr" target="#b24">[25]</ref>. This algorithm tries to infer whether, for any pair of accesses to a shared variable, of which at least one is a write, the accesses can occur without the threads holding a common lock. If this is the case, the algorithm flags a race. Our algorithm is based on the algorithm used in RacerX <ref type="bibr" target="#b4">[5]</ref>, modified to have fewer false negatives.</p><p>CoRD's instrumentation compiler backend generates lightweight instrumentation calls to the pod that allow the pod to orchestrate the thread schedule on the user machine. More details follow in §3.4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Pod</head><p>Once a hive-pod connection is established, the hive sends the pod a target race and the desired order of racing accesses (i.e., the primary or alternate). The pod monitors the instrumented binary and enforces the program to follow the order of the racing accesses specified by the hive. To achieve this at runtime, the pod intercepts the instrumentation calls that were generated by the hive and orchestrates program schedule ( §3.4).</p><p>The pod then relays the information gathered during schedule orchestration back to the hive for it to validate races. The pod can send three types of reports: (1) schedule enforced, (2) schedule not enforced, or (3) specification violation (crash, deadlock, or assert). These reports are used in race validation, which we detail below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Race Validation</head><p>CoRD validates data races based on the reports received from the pods. In this section, we detail how this validation is performed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Validating True Positives</head><p>CoRD confirms true positives (real data races) as follows: if both the primary and the alternate schedule of a potential data race can be enforced in the same execution context, then it means that there is no mutual exclusion between the two accesses. Thus this is a data race. However, this data race may not necessarily lead to a specification violation. The ability to confirm potential races before reporting them is a key component of CoRD's improved detection accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Gathering Evidence for False Positives</head><p>CoRD cannot tell with certainty if a data race is a false positive or not, but it uses two heuristics to report likely false positives. The first heuristic monitors whether only one ordering of the potentially racing accesses can be enforced. This is usually the case if the racing accesses are properly synchronized. The static race detector flags such accesses as races because it may not be aware of some synchronization primitives. The second heuristic monitors the purported racing memory accesses and, if they do not access the same memory, the data race is deemed a likely false positive.</p><p>CoRD leverages its large scale to increase the confidence that a report is a potential false positive. The more instances of a likely false positive race report are reported to the hive as a result of different executions, the higher the probability that the race report is actually a false positive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Reporting Specification Violations</head><p>CoRD also increases the likelihood of triggering raceinduced failures that violate the program specification (e.g., crash, deadlock, or assert).</p><p>In the case of a crash, the pod catches the SIGSEGV signal and submits the crash report to the hive. CoRD takes a similar approach in the case of a hang or when the program receives an unhandled SIGINT (e.g., the user pressed Ctrl-C). In this case, CoRD prompts the user with a dialog asking whether the program has failed to meet expectations. If yes, the pod informs the hive that the enforced schedule leads to a specification violation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Schedule Orchestration</head><p>The pod attempts to enforce the instrumented binary running at the end-user site to follow either the primary or the alternate schedule, as instructed by the hive. If the program follows the desired schedule by itself, without the pod having to steer it, CoRD's thread schedule orchestration is idle and has virtually no overhead. However, if the program is about to exhibit the reverse schedule (primary instead of alternate, or vice-versa), the orchestration kicks in to enforce the required order.</p><p>The case in which the orchestration takes over is shown in <ref type="figure">Figure 3</ref>. Assume a program with two threads, T 1 and T 2 , and two racing accesses, r 11 and r 12 . Let's further assume that the hive instructs the program to follow the primary schedule of racing accesses, which in  <ref type="figure">Figure 3</ref>. Schedule orchestration this case corresponds to the order r 11 → r 12 of racing accesses, meaning that r 11 executes before r 12 . Assume that during execution, T 1 is about to execute r 12 before r 11 . Since this is not the order desired by the hive, the orchestration preempts T 1 for a configurable period of time (using timed wait on a condition variable), allowing T 2 to get scheduled and execute r 11 (step 1).</p><p>If T 2 executes r 11 (step 2), the instrumented code signals (using a condition variable signal statement) T 1 to continue and execute r 12 (step 3). Once r 12 is executed, the pod notifies the hive that the required schedule was enforced.</p><p>On the other hand, if the timed wait timeouts as shown in <ref type="figure">Figure 3</ref>, and T 2 does not execute r 11 , T 1 gets scheduled back and r 12 gets executed. This could mean two things: (a) the timeout was too short for T 2 to have a chance to execute r 11 , or (b) the interleaving in question cannot be enforced under any circumstances (perhaps because there is some ordering constraint between the accesses such as an ad-hoc synchronization <ref type="bibr" target="#b29">[30]</ref>, that the static race detector at the hive did not recognize). Either way, the pod notifies the hive that the required order cannot be enforced.</p><p>When CoRD enforces a particular schedule, the upper limit on the overhead is the timeout duration. Similarly, if the schedule cannot be enforced, the overhead stems from the unnecessary wait.</p><p>This constant upper bound on the timeout is key in achieving low overhead. To preserve the low latency of interactive applications, CoRD uses short timeouts of less than 200 ms; for server applications, higher timeouts can be configured by developers. It is also possible to configure the value of the timeout depending on how often the potentially racing accesses execute.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Incentives for Using CoRD</head><p>Today, many users experience the same concurrency problems, and these problems go unnoticed. End users may experience crashes, hangs, data loss, etc. while validating the races, in cases in which they would not have encountered such behavior. However, if one user encountered this problem, then many other users will not, therefore we sacrifice one user for the good of many.</p><p>To motivate users to participate, we envision using a reward system for users who find true positives. Such users can be allowed free upgrades and free product trials if the software under test comes from a vendor, or they can be awarded "badges of honor" in the case of opensource software.</p><p>This system could work well for beta testers (Windows 7 had more than 8 million beta testers <ref type="bibr" target="#b0">[1]</ref>) and also for regular users. We believe that CoRD's low runtime overhead is key in increasing adoption by regular users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Preliminary Experimental Results</head><p>As a preliminary evaluation, we ran CoRD on two real concurrent programs: the SQLite <ref type="bibr" target="#b25">[26]</ref> embedded database (used in Firefox, iOS, Chrome and Android) and Pbzip2 <ref type="bibr" target="#b6">[7]</ref> a parallel implementation of the popular bzip2 file compressor. SQLite has around 100 KLOC and Pbzip2 has around 2 KLOC. All experiments were run on a 800 MHz 48 core AMD Opteron 6176 machine with 512 GB of RAM running Ubuntu Linux 11.04 with kernel version 2.6.38-13. All time-related results represent averages over 10 experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Effectiveness of detection</head><p>CoRD first statically detected 88 potential races for SQLite and 122 races for Pbzip2. The static race detection took 55.57 seconds for SQLite and 0.52 seconds for Pbzip2, on average over the 10 runs. <ref type="table">Table 1</ref> shows the results of data race detection.  <ref type="table">Table 1</ref>. Data race detection with CoRD. The "Potential races" refers to races the races reported by the static race detector. The next three categories correspond to true positives (3.3.1):Crashes and Deadlocks refer to crashes and deadlocks that occur in one of the primary or alternate interleavings. Races in the "No observable effect" category represent true races for which the execution of the primary and alternate did not cause any observable program failure (crash deadlock or fired assertion, in our case)."Likely false positives" were explained in (3.3.2). "Not encountered" races correspond to potential races that were not encountered in our test runs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Program</head><p>In order to perform validation, we used a single test case for SQLite that initializes the database and inserts some items to it and subsequently removes them. We used two test cases for Pbzip2: one that does compression and another one that does decompression. CoRD managed to uncover 3 races that cause a deadlock in SQLite, 4 races that cause a crash in Pbzip2, and 1 race that did not have any observable effect. Prior work has reported 1 of the races that cause a deadlock, 3 of the races that caused a crash and the race with no observable effect <ref type="bibr" target="#b13">[14]</ref>. To our knowledge, the other races were not previously reported.</p><p>The large number of "Likely false positives" confirms prior work that reports many false positives for static race detection <ref type="bibr" target="#b27">[28]</ref>. We believe that the large number of "Not encountered" races is due to the limited set of test cases we used for our preliminary evaluation, which limits the number of paths explored through a program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Performance Evaluation</head><p>To evaluate the runtime performance overhead incurred by CoRD, we first measured the effect of the instrumentation without performing any validation, and compared this with native execution. We observed 0.91% overhead for Pbzip2 and 0.99% overhead for SQLite.</p><p>Next, we enabled validation and measured the overhead of CoRD for Pbzip2 and SQLite by only validating a single race at a time. This case incurred at most 1.6% overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Efficiency Comparison to Other Detectors</head><p>For comparison, we performed pure dynamic race detection for Pbzip2 and SQLite using Google's ThreadSanitizer <ref type="bibr" target="#b15">[16]</ref> while running the same test cases used by CoRD. The average overhead ranged from 3, 001% for Pbzip2 to 972% for SQLite with the peak overhead being 4, 200%. Note that we give ThreadSanitizer the benefit of access to all executions that CoRD has access to. This is probably overly generous, because dynamic race detection is not crowd-sourced to multiple users. So one would run ThreadSanitizer on fewer executions and obtain lower coverage than shown here.</p><p>If we had performed pure static race detection, we would have obtained the same total number of races for Pbzip2 and SQLite. However, the classification in Table 1 would not have been available, therefore developers would not have information on how to prioritize the fixing of races. This would in turn impact the users, because it might take longer to remove the data races with severe consequences. The benefit of tolerating the &lt; 2% overhead of CoRD is that race detection results are more detailed and helpful.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Bug manifestation probability</head><p>Finally we evaluated how CoRD increases the probability that concurrency bugs manifest themselves. For this, we ran the SQLite test case 10,000 times and never encountered any deadlock. In contrast, CoRD caused the occurrence of 3 deadlocks from a maximum of 176 executions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related Work</head><p>CoRD is inspired in part by Windows Error Reporting (WER) <ref type="bibr" target="#b7">[8]</ref>, a large collaborative error reporting system. WER collects information (memory dumps, call stacks, etc.) after a crash, in order to prioritize potential bugs. WER does not formulate any hypotheses regarding a potential bug before encountering it. WER crowd sources program executions and gathers reports after crashes or hangs. Then, it formulates the hypothesis about a potential bug. This hypothesis has to be validated manually.</p><p>CoRD reverses this process: it formulates the hypothesis prior to crowd sourcing (static race detection) and then uses crowd sourcing for validation tasks instead of executions. Moreover, in CoRD, validation is entirely automatic. Having a hypothesis together with automated validation can potentially be more valuable: it will save the developer the time-consuming detective work of connecting the hypothesis to the validation.</p><p>CoRD's distributed and collaborative approach is in part influenced by statistical bug isolation <ref type="bibr" target="#b18">[19]</ref>, which transforms an assertion-dense program into several programs with fewer assertions. Users execute these programs and report back the triggered assertions. Similarly, AjaxScope <ref type="bibr" target="#b14">[15]</ref> enables error-reporting, performance profiling, and leak detection. AjaxScope uses on-the-fly instrumentation of JavaScript code to distribute the overhead across many users. CoRD distributes race validation tasks among its participants, and increases the chances of manifestation of data race-related failures.</p><p>Kivati <ref type="bibr" target="#b3">[4]</ref> is a system that statically detects potential atomicity violations and avoids the potential violations at runtime. Kivati requires source code instrumentation and a modified kernel. It's runtime overhead can go up to 35%. Similarly to Kivati, CoRD uses static analysis to detect potential races. CoRD validates data races in a distributed manner to reduce runtime overhead and does not require a custom kernel. Moreover, CoRD can learn from failing executions and has the potential to avoid only known-to-be-harmful interleavings.</p><p>CTrigger <ref type="bibr" target="#b23">[24]</ref> is a system that takes as input a trace of program execution and performs an analysis of this trace to identify accesses that are potentially involved in an atomicity violation. Subsequently, it re-executes programs and injects delays between instructions to increase the chances of triggering an atomicity violation. CTrigger requires a recording infrastructure and performs offline replay and analysis. Similarly, CoRD increases the chances to encounter race-related problems. However, CoRD does not rely on any execution recording and has low runtime overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Future Work</head><p>CoRD's race detection does not rely on alias analysis, and this potentially increases both the number of false positives and false negatives in race detection. We plan to use alias analysis to perform more accurate static race detection.</p><p>We plan to explore a solution which involves distributing "fixes" back to the pods. It is possible to avoid cer-tain interleavings in subsequent runs of the instrumented binary by distributing a list of to-be-avoided schedules, allowing the software to gain immunity against data race bugs. CoRD can be used to derive the execution filters used by LOOM <ref type="bibr" target="#b28">[29]</ref> to avoid races at runtime.</p><p>Currently the assignment of potential data races to pods is done randomly. This is inefficient, because the hive may enable monitoring for a potential data race for a user that never executes the racing memory accesses. In future work, we intend to improve this by leveraging the path sampling statistics gathered by the pods: each pod can monitor which racing accesses are executed locally and forward this information to the hive. The hive can then make more informed assignment decisions of data race reports to pods.</p><p>We are currently working on better ways to generate the timeout values used for thread schedule orchestration. One option is to derive the value of the timeout using static analysis and estimating the time required for the second racing access to occur <ref type="bibr" target="#b16">[17]</ref>. Another option is to try out different timeout values on different pods, so that only few users are impacted by larger timeouts.</p><p>The general concept of a distributed collaborative framework has privacy implications, although in the particular example of data race detection, the information that is gathered from the pods is minimal. We are considering general ways to quantify the balance between privacy and the amount of execution information that is relayed from the pods to the hive.</p><p>Finally, we plan to extend the idea of collaborative information recycling to other types of bugs. We believe that, with sufficiently specialized instrumentation, other types of bugs can also be efficiently triggered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We propose CoRD, a collaborative framework that statically detects data races and then dynamically validates them by leveraging execution information from all its participants. Our initial results show that CoRD is effective in detecting races and has low overhead, while increasing the chances of manifestation of race-related failures which enables better testing and validation.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. CoRD general architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. CoRD hive architecture</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Coverity for their support regarding their static analysis tool.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<ptr target="http://windows.microsoft.com/en-us/windows/history" />
		<title level="m">A history of Windows</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">How to miscompile programs with &quot;benign&quot; data races</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-J</forename><surname>Boehm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Workshop on Hot Topics in Parallelism</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Exterminating bugs via collective information recycling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HOTDEP</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Kivati: fast detection and prevention of atomicity violations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Chew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM EuroSys European Conf. on Computer Systems</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">RacerX: Effective, static detection of race conditions and deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ashcraft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Operating Systems Principles</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Fasttrack: efficient and precise dynamic race detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">N</forename><surname>Freund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Parallel BZIP2</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gilchrist</surname></persName>
		</author>
		<ptr target="http://compression.ca/pbzip2" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Debugging in the (very) large: Ten years of implementation and experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Glerum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kinshumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Aul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Orgovan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nichols</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Grant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Loihle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hunt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Operating Systems Principles</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Concurrency at Microsoft -An exploratory survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Nagappan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV Workshop on Exploiting Concurrency Efficiently and Correctly</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Google chrome blog</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google</surname></persName>
		</author>
		<ptr target="http://chrome.blogspot.ch/2012_06_01_archive.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title/>
		<ptr target="http://software.intel.com/en-us/articles/intel-parallel-inspector" />
	</analytic>
	<monogr>
		<title level="j">Intel Corp. Parallel Inspector</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">How many servers does google have?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Pearn</surname></persName>
		</author>
		<ptr target="https://plus.google.com/114250946512808775436/posts/VaQu9sNxJuY" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Effective data-race detection for the kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">B</forename><surname>John Erickson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madanlal</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Olynyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Operating Sys. Design and Implem</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Data races vs. data race bugs: Telling the difference with portend</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kasikci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Zamfir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Intl. Conf. on Architectural Support for Programming Languages and Operating Systems</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Ajaxscope: a platform for remotely monitoring the client-side behavior of web 2.0 applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kiciman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Livshits</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Operating Systems Principles</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">ThreadSanitizer -data race detection in practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">I</forename><surname>Serebryany</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Binary Instrumentation and Applications</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient state merging in symbolic execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kinder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bucur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An investigation of the Therac-25 accidents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">G</forename><surname>Leveson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<date type="published" when="1993-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Scalable statistical bug isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Liblit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">X</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Intl. Conf. on Programming Language Design and Implem</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Learning from mistakesa comprehensive study on real world concurrency bug characteristics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Intl. Conf. on Architectural Support for Programming Languages and Operating Systems</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">LiteRace: effective sampling for lightweight data-race detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Marino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Intl. Conf. on Programming Language Design and Implem</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Automatically classifying benign and harmful data races using replay analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narayanasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tigani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Intl. Conf. on Programming Language Design and Implem</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Hybrid dynamic data race detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>O&amp;apos;callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-D</forename><surname>Choi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Principles and Practice of Paralle Computing</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Ctrigger: exposing atomicity violation bugs from their hiding places</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Eraser: a dynamic data race detector for multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sobalvarro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sqlite</surname></persName>
		</author>
		<ptr target="http://www.sqlite.org/" />
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
				<ptr target="http://www.securityfocus.com/news/8032" />
		<title level="m">General Electric acknowledges Northeastern blackout bug</title>
		<imprint>
			<publisher>The Associated Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">RELAY: Static race detection on millions of lines of code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename><surname>Voung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lerner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on the Foundations of Software Eng</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Bypassing races in live applications with execution filters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Operating Sys. Design and Implem</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Ad-hoc synchronization considered harmful</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Operating Sys. Design and Implem</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
