<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:26+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Web-based Attacks on Host-Proof Encrypted Storage</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karthikeyan</forename><surname>Bhargavan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">INRIA</orgName>
								<orgName type="institution" key="instit2">ENS Cachan</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antoine</forename><surname>Delignat-Lavaud</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">INRIA</orgName>
								<orgName type="institution" key="instit2">ENS Cachan</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Web-based Attacks on Host-Proof Encrypted Storage</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Cloud-based storage services, such as Wuala, and password managers, such as LastPass, are examples of so-called host-proof web applications that aim to protect users from attacks on the servers that host their data. To this end, user data is encrypted on the client and the server is used only as a backup data store. Authorized users may access their data through client-side software, but for ease of use, many commercial applications also offer browser-based interfaces that enable features such as remote access, form-filling, and secure sharing. We describe a series of web-based attacks on popular host-proof applications that completely circumvent their cryptographic protections. Our attacks exploit standard web application vulnerabilities to expose flaws in the encryption mechanisms, authorization policies, and key management implemented by these applications. Our analysis suggests that host-proofing by itself is not enough to protect users from web attackers, who will simply shift their focus to flaws in client-side interfaces.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Host-Proof Web Applications</head><p>The remarkable increase in website attacks in recent years and the consequent loss of sensitive user data has motivated a security-focused redesign of web applications where data is now routinely stored in encrypted form on web servers and only decrypted when needed. This architecture protects users from malicious hackers who may steal a database from the server but will not be able to decrypt it. However, it does not prevent data theft by disgruntled employees, who may have access to the decryption keys. Moreover, since the server application has access to decrypted data and is itself accessible over the web, any vulnerability in its code risks leaking user data to a web-based attacker through standard attacks like cross-site request forgery (CSRF).</p><p>Server-side encryption may be adequate for casual websites, but users of cloud-based storage and privacy- <ref type="figure">Figure 1</ref>: Host-proof web application architecture sensitive applications such as password managers demand stronger security guarantees. For example, when the storage service <ref type="bibr">Dropbox [5]</ref> revealed that some of its employees could read user files, it was widely criticized for violating user privacy <ref type="bibr">[15]</ref>. Conversely, when the password manager LastPass <ref type="bibr" target="#b5">[7]</ref> announced that its servers may have been compromised <ref type="bibr" target="#b12">[16]</ref>, public reaction was mitigated because of the host-proof <ref type="bibr" target="#b4">[6]</ref> design that LastPass implements against this class of attacks.</p><p>A host-proof web application follows the architecture depicted in <ref type="figure">Figure 1</ref>. Personal data is encrypted on the client using a key or passphrase known by the user, while the web server only acts as an encrypted data store. The full functionality of the application is implemented in the client-side app, which performs all encryptions and decryptions, backs up the database to the server and, only when the user authorizes it, shares decrypted data with other users or websites. Since the server never sees unencrypted data (nor any decryption key, ideally), even if an attacker steals the database from the server, he cannot recover the plaintext without substantial computational effort to brute-force through every user's decryption key.</p><p>This design is sometimes called cryptographic cloud storage, and may use cryptographic mechanisms that enable some operations on encrypted data (such as search) <ref type="bibr" target="#b24">[28]</ref>. The design is also sometimes misleadingly called zero-knowledge <ref type="bibr" target="#b1">[3,</ref><ref type="bibr" target="#b8">11]</ref>. We use the more neutral term host-proof to simply mean that the security of the application does not depend on trusting the server.</p><p>We consider two classes of host-proof web applications: cloud-based storage and password managers.</p><p>• Storage services, such as Wuala <ref type="bibr" target="#b9">[12]</ref> and SpiderOak <ref type="bibr" target="#b8">[11]</ref>, offer a remote encrypted backup folder synchronized across all of the user's devices. The user may explicitly share specific sub-folders or files with other users, groups, or through a web link.</p><p>• Password managers, such as LastPass <ref type="bibr" target="#b5">[7]</ref> and 1Password <ref type="bibr">[1]</ref>, offer to store users' confidential data, such as login credentials to different websites, or credit card numbers. When the user browses to a website, the password manager offers to automatically fill in the login form with a username and password retrieved from the encrypted database. The password database is backed up on a server and synchronized across the user's devices.</p><p>These applications differ from each other in their precise use of cryptography and in their choice of web interfaces. <ref type="table">Tables 1 and 2</ref> summarize the main features of a series of host-proof applications. In addition to those mentioned above, these tables include the cloud storage applications BoxCryptor <ref type="bibr" target="#b0">[2]</ref> and CloudFogger <ref type="bibr" target="#b2">[4]</ref> that add client-side encryption to non host-proof cloud services such as Dropbox. They also include the password managers RoboForm <ref type="bibr" target="#b7">[10]</ref>, PassPack <ref type="bibr" target="#b6">[9]</ref>, and Clipperz <ref type="bibr" target="#b1">[3]</ref>. For each application, <ref type="table">Table 1 notes the crypto- graphic algorithms and mechanisms used, while Table 2</ref> summarizes the web interfaces offered.</p><p>Despite differences in their design and implementation, the common security goals of host-proof encrypted storage applications can be summarized as follows:</p><p>• confidentiality: unshared user data must be kept secret from all web-based adversaries (including the server application itself);</p><p>• integrity: encrypted user data cannot be tampered with without it being detected by the client;</p><p>• authorized sharing: data shared by the user may be read only by explicitly authorized principals.</p><p>In the rest of this paper, we describe five exemplary attacks on commercial host-proof applications that break these security goals by exploiting flaws in both their cryptographic design and their web interfaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Metadata Tampering Attacks on Client-side Encryption</head><p>Client-side encryption typically relies on the user either knowing an encryption key or knowing a secret passphrase from which a key may be derived. All the applications analyzed in this paper support the PBKDF2 password-based key derivation function <ref type="bibr" target="#b10">[13]</ref> that takes a passphrase p, salt s, and iteration count c, and generates an encryption key k (of a given length):</p><formula xml:id="formula_0">k = KDF(p, s, c)</formula><p>The salt ensures that different keys derived from the same passphrase are independent and a high iteration count protects against brute-force attacks by stretching the low-entropy password <ref type="bibr" target="#b25">[29]</ref>. The choice of s and c varies across different applications; for example LastPass uses a username as s and c = 1000, whereas SpiderOak uses a random s and c = 16384. When c is too low or the passphrase p is used for other (cheaper) computations, the security of the application can be compromised <ref type="bibr" target="#b21">[25]</ref>. The attacks in this paper do not rely on brute-force attacks against passwords. In the rest of this paper, we assume that all passphrases and keys derived from them are strong and unguessable.</p><p>Given an encryption key k and data d, each application uses an encryption algorithm to generate a ciphertext e:</p><formula xml:id="formula_1">e = ENC(k, d)</formula><p>The applications in this paper all support AES encryption, either with 128-bit or 256-bit keys, and a variety of encryption modes (CTR, CBC, CFB). Some applications also support other algorithms, such as Blowfish, Twofish, 3DES, and RC6. In this paper, we assume that all these encryption schemes are correctly implemented and used. Instead, we focus on what is encrypted and how encrypted data is handled.</p><p>On storage services, such as SpiderOak and Wuala, each file is individually encrypted using AES and then integrity protected using HMAC (with another key derived from the passphrase)</p><formula xml:id="formula_2">h = HMAC(k , ENC(k, d))</formula><p>To avoid storing multiple copies of the same file, some services, including Wuala, perform the encryption in two steps: first the file is encrypted using the hash of its contents as key, then the hash is encrypted with a passphrasederived key.</p><formula xml:id="formula_3">e = ENC(HASH(d), d), ENC(k, HASH(d))</formula><p>The first encryption doesn't depend on the user, enabling global deduplication: the server can identify and consolidate multiple copies of a file. Although the contents  <ref type="table">Table 2</ref>: Example host-proof web applications and their web interfaces of each file is encrypted, metadata, such as the directory structure and filenames, may be left unecrypted to enable directory browsing. Some password managers, such as LastPass, separately encrypt each data item: username, password, credit card number, etc. but leave the database structure unencrypted. Others, such as RoboForm and 1Password, encrypt each record as a separate file. Still others encrypt the full database atomically. In most of these cases, there is no integrity protection for the ciphertext. Moreover, some metadata, such as website URLs, may be left unencrypted to enable search and lookup.</p><p>When metadata is left unprotected and is not strongly linked to the encrypted user data using some integrity mechanism (such as HMAC), it becomes vulnerable to tampering attacks. We illustrate two such attacks.</p><p>RoboForm Passcard Tampering The RoboForm password manager stores each website login in a different file, called a passcard. For example, a Google username and password would be stored in a passcard Google .rfp of the form:</p><formula xml:id="formula_4">URL3:Encode('https://accounts.google.com') +PROTECTED-2+ &lt;ENC(k,(username,password))&gt;</formula><p>That is, it contains the plaintext URL (encoded in ASCII) and then an encrypted record containing all the login data for the URL. By opening this passcard in RoboForm, the user may directly login to Google using the decrypted login data. Notably, nothing protects the integrity of the URL. So, if an adversary can modify the URL to bad.com, RoboForm will still decrypt and verify the passcard and leak the Google username and password to the attacken when the user browses bad.com.</p><p>A web-based attacker can exploit this vulnerability in combination with RoboForm's passcard sharing feature. RoboForm users may send passcards over email to their friends. So if an adversary could intercept such a passcard and replace the URL with bad.com, the website can then steal the secret passcard data. Similar attacks apply when synchronizing RoboForm with a compromised backup server or when malware on the client has access to the RoboForm data folder.</p><p>1Password Keychain Tampering 1Password uses a different encryption format, but similarly fails to protect the integrity of the website URL. For example, a Google record in 1Password's Keychain format is of the form:</p><p>tamper with the keychain and cause it to leak secret data to malicious websites.</p><p>Similar vulnerabilities due to lack of integrity protection on filenames in BoxCryptor and CloudFogger enable an attacker to modify filenames of encrypted files, say from a.pdf to a.exe.</p><p>Towards Authenticated Encryption It is generally accepted among the cryptographic community that "encryption without integrity-checking is all but useless" <ref type="bibr" target="#b22">[26]</ref>. A simple fix to tampering attacks would be to use an MAC to protect the integrity of both the metadata and the encrypted items, as in Wuala and SpiderOak. Alternately, the metadata could also be encrypted and the integrity of the plaintext could be protected by a cryptographic hash (before encryption).</p><p>More generally, many host-proof applications appear to use encryption algorithms as if they guaranteed ciphertext integrity. This assumption is false for many modes of AES and especially for hybrid encryption using a combination of RSA and AES. Instead, each password manager should seek to implement a scheme that provides authenticated encryption with associated data <ref type="bibr" target="#b26">[30]</ref>, where the associated data includes unencrypted metadata.</p><p>Vulnerability Response We notified both 1Password and RoboForm about these attacks on April 3, 2012.</p><p>The 1Password team responded within days with details of their new keychain format for their next version (4.0); this format includes integrity protections which potentially addresses our concerns, but a more detailed analysis of the new format remains to be done.</p><p>The RoboForm team proved more resistant to changing their design. They questioned our threat model ("if a malware can modify passcards, it can be just a keylogger instead"), but our attack works even on passcards transported over insecure email. Despite our demo, they refused to believe that we can tamper with passcards ("produce as many passcards as you want and then modify them. they all should be rejected"). We are continuing our discussions with RoboForm but do not anticipate any fixes in the near future.</p><p>Both vulnerabilities were publicly disclosed <ref type="bibr" target="#b15">[19,</ref><ref type="bibr" target="#b16">20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Cross-Site Request Forgery on Remote Web Access</head><p>Some host-proof applications such as LastPass and SpiderOak offer fully-featured JavaScript interfaces to its roaming users. A user may login to the website with her passphrase and access her data. However, the passphrase itself should never be sent to the server; instead the JavaScript client should derive decryption keys within the browser. Ideally, all decryptions would also be run within the user's browser, but for efficiency, some decryptions may be executed server-side, with the promise that decryption keys are destroyed on logout.</p><p>SpiderOak JSONP CSRF Attack The SpiderOak website uses AJAX with JSONP to retrieve data about the user's devices, directory contents and share rooms. So, when a user is logged in, a GET request to /storage/&lt;u32&gt;/?callback=f on https://spideroak.com where &lt;u32&gt; is the base32-encoded username returns:</p><p>f({"stats": {"firstname": "Legit", "lastname": "User", "devices": 3, ... Hence, by accessing the JSON for each device (e.g. /storage/homepc/), the JavaScript client retrieves and displays the entire directory structure for the user.</p><p>It is well known that JSONP web applications are subject to Cross-Site Request Forgery if they do not enforce an allowed origin policy <ref type="bibr" target="#b20">[24]</ref>. SpiderOak enforces no such policy, hence if a user browsed to a malicious website while logged into SpiderOak, that website only needs to know or guess the user's SpiderOak username to retrieve JSON records for her full directory structure.</p><p>More worryingly, if the user has shared a private folder with her friends, accessing the JSON at /storage/&lt;u32&gt; /shares yields an array of shared "rooms" that includes access keys:</p><p>{"share_rooms" :</p><p>[ { "url" : "/browse/share/&lt;id &gt;/&lt;key &gt;" , "room_key" : "&lt;key &gt;" , "room_description" : "" , "room_name":&lt;room &gt;}] , "share_id" : "&lt;id &gt;" , "share_id_b32" : "&lt;u32 &gt;"} So, the malicious website may now at leisure access the shared folders at https://spideroak.com/browse/share/ &lt;id&gt;/&lt;key&gt; to steal all of a user's shared data.</p><p>Key Management for Shared Data Our specific attack can be prevented by simply adding standard CSRF protections to all the JSONP URLs offered by SpiderOak. However, a more general design flaw is the management of encryption keys for shared data. When a folder is shared by a user, it is decrypted and stored in plaintext on the server, protected only by a password that is also stored in plaintext on the server. This breaks the host-proof design completely since flaws in the SpiderOak website may now expose the contents of all shared folders (as indeed we found). A better design would be to use encrypted shared folders as in Wuala <ref type="bibr" target="#b23">[27]</ref>, where decryption keys are temporarily provided to the website but not stored permanently.</p><p>Vulnerability Response We notified the SpiderOak team about the attack on May 21, 2012; they acknowledged the issue and disabled JSONP within one hour. However, no change was made to the management of share room keys, and no additional protections against CSRF attacks, such as Referer or token based checks, have been put in place. We fear that shared data on SpiderOak remains vulnerable to other website attacks; notably, many of the problems reported on the SpiderOak Security Response page relate to cross-site scripting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Stealing Data from Client-side Websites</head><p>Wuala is a Java application that may be run directly as a desktop client or as a Java applet from the Wuala website. It maintains an encrypted directory tree where each file is encrypted with a different key and the hierarchy of keys is maintained by a sophisticated key management structure <ref type="bibr" target="#b23">[27]</ref>. When started, Wuala asks for a username and password, uses them to derive a master key which is then used to decrypt the directory tree. On Windows systems, Wuala creates the following local directory structure:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>%userprofile%/AppData</head><p>Local Wuala Data (local cache) Roaming Wuala defaultUser (master key file)</p><p>The defaultUser file contains the master key for the current user. The Data folder contains the encrypted directory tree along with plaintext data for files that have been recently uploaded or downloaded from the server. Wuala also runs a lightweight HTTP server on localhost at port 33333. This HTTP server is primarily meant to provide various status information, such as whether Wuala is running, whether backup is in progress, log error messages, etc. It may also be used to open the Wuala client at an given path from the browser. The user may enable other users on the LAN to access this HTTP server to monitor its status. The HTTP server cannot be disabled but is considered a mostly harmless feature.</p><p>Database recovery attack on Wuala We discovered a bug on the Wuala HTTP server, where files requested under the /js/ path resolve first to the contents of the main Wuala JAR package (which has some JavaScript files) and then, if the file was not found, to the content of Wuala's starting directory.</p><p>If Wuala was launched as an applet, its starting directory will be Roaming in the above tree, meaning that browsing to http://localhost:33333/js/defaultUser will return the master key of the current active user. Using this master key file anyone can masquerade as the user and obtain the full directory tree from Wuala.</p><p>If Wuala was started from as a desktop client, its stating directory will be Local instead, allowing access to the local copy of the database, including some plaintext files. These flaws can be directly exploited by an attacker on the same LAN (if LAN access to the HTTP server is enabled; it isn't by default), or by any malware on the same desktop (even if the malware does not have permission to read or write to disk or to access the Internet). The attacker obtains the full database if Wuala was started as an applet, and some decrypted files otherwise.</p><p>Protecting Keys from Web Interfaces Our attack relies on a bug in the HTTP server, it simply should not allow access to arbitrary files under the /js/ path. More generally, the attack reveals a design weakness that the Wuala master key is available in plaintext when Wuala is running and is stored in plaintext on disk if the user asks Wuala to remember his password. This file is extremely sensitive since obtaining the file is adequate to reconstruct and decrypt a complete copy of the user's directory tree (on any machine). The software architecture of Wuala makes the file available to all parts of the application including the HTTP server. We advocate a more modular architecture that isolates sensitive key material and cryptographic operations in separate processes from (potentially buggy) web interfaces.</p><p>Vulnerability Response We notified the Wuala team about the vulnerability on May 21, 2012. They responded immediately and released an update (version 399) within 24 hours that disabled file access from the local web server. No other change was made to the HTTP server or master key cache file following our report. The vulnerability has been publicly disclosed <ref type="bibr" target="#b13">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Phishing Attacks on Browser Extensions</head><p>Password managers typically offer browser extensions that can be used to fill forms automatically on known websites. These extensions are written in JavaScript and either implement cryptography in JavaScript (e.g. LastPass) or call out to an external desktop application (e.g. 1Password and RoboForm). When a user visits a website, say gmail.com with a password manager's browser extension installed, the extension examines the URL of the page to decide whether or not to automatically fill in the login form (using data re-trieved and decrypted from the database). However, the code for parsing the URL is often flawed and does not account for maliciously crafted URLs. So given a URL http://www.google.com, this code returns the string Google.com. However, this code does not correctly account for URLs of the form http://user: password@website. So, suppose a malicious website redirected a user to the url http://www.google.com:xxx@bad. com. The browser would show a page from http://bad. com (after trying to login as the "user" Google.com), but the 1Password browser extension would incorrectly assume that it was on the domain Google.com and release the user's Google username and password. This amounts to a phishing attack on the browser extension, which is particularly serious since one of the advertised features of password managers like 1Password is that they attempts to protect naive users from password phishing. Similar attacks can be found on other password managers, such as RoboForm's Chrome extension, that use URL parsing code that is not defensive enough.</p><p>URL Parsing Parsing URLs correctly with regular expressions is a surprisingly difficult task, despite URLs having a well understood syntax <ref type="bibr" target="#b11">[14]</ref>, and leading websites often get it wrong <ref type="bibr" target="#b27">[31]</ref>. Perhaps the most widely used URL parsing library for JavaScript is parseUri <ref type="bibr">[8]</ref> which uses the following regular expression (in "strict" standard-compliance mode): </p><formula xml:id="formula_5">\ / ? # ] * ) ( ? : : ( \ d * ) ) ? ) ) ? ( ( ( ( ? : [ ˆ ? # \ / ] * \ / ) * ) ( [ ˆ ? # ] * ) ) ( ? : \ ? ( [ ˆ # ] * ) ) ? ( ? : # ( . * ) ) ? ) /</formula><p>This regular expression is also incomplete. For example, given the URL http://bad.com/#@accounts.google.com, it yields a domain accounts.google.com whereas the correct interpretation is bad.com.</p><p>Domain-based Authorization Password managers authorize websites based on their domain name. The basic flaw that enables our phishing attacks is that the interpretation of the domain of the URL by the browser extension is inconsistent with the interpretation of the browser. In the cases shown above, the extension was wrong and the browser was right. But even if the extension were right and the browser were wrong, a secret password may be leaked. An easy fix that prevents our attack is for the extension to directly use the parsed window.location object given by the browser. A different fix is to use a careful regular expression parser that mimics the browser.</p><p>A more general design question is whether domain-based authorization is appropriate for website login. On hosting websites such as WordPress and Google Sites, hundreds of different websites may share the same domain name, causing domain-based password managers to be very error-prone. Moreover, users may wish to only release their passwords over HTTPS, but domains do not include protocol information. So for example, if a user asked LastPass to remember her password to https: //facebook.com, and later she was redirected to the HTTP login form on http://facebook.com, LastPass will happily fill in her username and password, revealing it to eavesdroppers on the network. We advocate that password managers implement site-specific authorization policies that include full origins (scheme, host, port) and enable users to choose their desired level of security. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Rootkit attacks on bookmarklets</head><p>Bookmarklets are bookmarks that contain a fragment of Javascript code. When clicked, this code is injected into the current active page, a feature commonly used by password managers to fill login forms on the page using the user's password database. Bookmarklets can be considered lightweight substitutes for browser extensions and are particularly suited for mobile and roaming users. Unlike extensions, bookmarklets are evaluated inside the Javascript scope of the page they are being injected into, making them vulnerable to a variety of threats, collectively called rootkit attacks <ref type="bibr" target="#b17">[21]</ref> that are very hard to protect against. Of particular concern are bookmarklets that handle sensitive data like passwords: they must ensure that they do not inadvertently leak the data meant for one site to another. The countermeasure proposed in <ref type="bibr" target="#b17">[21]</ref> addresses exactly this problem by verifying the origin of the website and has been adopted by a number of password managers, including LastPass and PassPack. However, they are still vulnerable to attack. This code retrieves the encrypted username and encrypted password for the current website, it downloads a decryption key (encrypted with the secret key associated with the bookmarklet), and uses the decryption key to decrypt the username and password before filling in the login form. Even though the decryption key is itself encrypted, it is enough to know &lt;user&gt; and _LASTPASS_RAND to decrypt it. Hence, a malicious page can detect when the _LP_CONTAINER object becomes defined (i.e. when the user has clicked the LastPass bookmark), redefine this object and call _LP_START again to decrypt and leak the key, username, and password. Since the username and password are meant for the current (malicious) page, this does not seem like a serious attack, until we note that the decryption key obtained by this attack is the permanent master key that is used to encrypt all the usernames and passwords in the user's LastPass database. Hence, the bookmarklet leaks the decryption key for the full database to a malicious website. A similar attack applies to the PassPack bookmarklet: a malicious website can steal a temporary encryption key that enables it to add a new record into the user's password database for any URL.</p><p>Per-record Key Derivation To protect host-proof applications against bookmarklet attacks, it is not enough to strongly authenticate the page that loads the content script. We also need to verify that the website is authorized to read any secret included in the content script. For example, our attacks would not be so serious if the keys revealed by the bookmarklet were specific to the website. Instead, they reveal a design flaw in the ways keys are used in LastPass; LastPass derives a master key from a username and a master password, without using any seed. This key remains constant for a long time (until the master password is changed). Moreover, it is used to individually encrypt each username and password field, and also used to re-encrypt the full database. To correctly implement data sharing with different websites, we advocate that different keys be generated for different records, by using per-record salts, or by including the URL (or its domain name) into the key derivation process.</p><p>Vulnerability Response We notified LastPass about the vulnerability on May 21, 2012. The LastPass team acknowledged the risk of leaking the master decryption key to malicious websites and changed their bookmarklet design within 24 hours. Decryption is now performed inside an iframe loaded from the https://lastpass.com origin, preventing the host page from stealing the key. However, they did not modify the overall design; hence, LastPass still uses a single master key for all encryptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>The host-proof application design pattern provides one level of isolation between sensitive user data and website attackers, but this is not enough. Moving cryptography to the client means that special attention should be paid to enforcing strong isolation between code that is relevant to the user interface and code that performs security-sensitive cryptographic operations. Current commercial host-proof client applications have critical flaws in the way they integrate browser-based interfaces with cryptographic code. We have presented a series of practical attacks that exploit these flaws. We have built demonstrations of these attacks and helped various vendors fix their software. From the viewpoint of web application security, our attacks are not new; what is novel is their interaction with cryptographic mechanisms, and the way they reveal security design flaws. We found these attacks by a careful but manual study of selected host-proof applications over a few weeks. It is worrying that we were able to find attacks on most applications we looked at without the aid of any sophisticated tools. To find more subtle attacks or to verify that an application is free from attack will require automated tools that can account for both web-specific threats and a precise model of cryptography but still scale up to realistic web applications. As ongoing and future work, our goal is to build such analysis tools based on sound formal foundations <ref type="bibr" target="#b18">[22,</ref><ref type="bibr" target="#b19">23]</ref> and apply them, for example, to the verification of the host-proof web applications studied here.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>"devices": [["homepc", "homepc/"], ["laptop", "laptop/"], ["mobile","mobile/"]]}})</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>1Password Phishing Attack For example, the URL parsing code in the 1Password extension (version 3.9.2) attempts to extract the top-level domain name from the URL of the current page: var href = getBrowser().contentWindow.location.href + "/"; var domain = href.replace(/^http[s]*:\/\/(.*?)\/.*$/i, "$1"); var middle = domain.replace(/^(www.)*(.*)/i, "$2"); return middle.substring(0,1).toUpperCase() + middle.substring(1,middle.length);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Vulnerability Response We notified 1Password about the phishing vulnerability on April 3, 2012. The 1Pass- word team responded immediately and released a new beta version of their browser extensions on April 5, 2012 (build 39304) that implements a new, more careful, URL parsing function. This function fixes the specific attack that we found but a full verification of their new URL parsing code and its consistency with different browsers remains an open question. The 1Password vulnerability has been publicly disclosed [18].</figDesc></figure>

			<note place="foot">{&quot;uuid&quot;:&quot;37F3E65BA83C4AB58D8D47ED26BD330B&quot;, &quot;title&quot;:&quot;Google&quot;, &quot;location&quot;:&quot;https://accounts.google.com/&quot;, &quot;encrypted&quot;:&lt;ENC(k,(username,password))&gt;} Hence, an attacker who has write access to the keychain may similarly modify the location field to bad. com and obtain the user&apos;s Google password. Concretely, since 1Password keychains are typically shared over Dropbox, any attacker who has (temporary) access one of the user&apos;s Dropbox-connected devices will be able to</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Boxcryptor</surname></persName>
		</author>
		<ptr target="http://boxcryptor.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Clipperz</surname></persName>
		</author>
		<ptr target="http://clipperz.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cloudfogger</surname></persName>
		</author>
		<ptr target="http://cloudfogger.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dropbox</surname></persName>
		</author>
		<ptr target="http://dropbox.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Host-Proof</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hosting</surname></persName>
		</author>
		<ptr target="http://ajaxpatterns.org/Host-Proof_Hosting" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lastpass</surname></persName>
		</author>
		<ptr target="http://lastpass.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Passpack</surname></persName>
		</author>
		<ptr target="http://passpack.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Roboform</surname></persName>
		</author>
		<ptr target="http://www.roboform.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Spideroak</surname></persName>
		</author>
		<ptr target="http://spideroak.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wuala</surname></persName>
		</author>
		<ptr target="http://wuala.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
				<title level="m">PKCS #5: Password-Based Cryptography Specification, Version 2.0. IETF</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
				<title level="m">RFC3986: Uniform Resource Identifier</title>
		<meeting><address><addrLine>URI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Generic Syntax. IETF</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">LastPass Security Notification</title>
		<imprint>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
				<idno>CVE-2012-3874</idno>
		<title level="m">Wuala Status Page Leaks Plaintext Files</title>
		<imprint>
			<date type="published" when="2012-07-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
				<title level="m">CVE-2012-3879: Phishing attack on 1Password Browser Extensions</title>
		<imprint>
			<date type="published" when="2012-07-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Receive Passcard by E-mail</title>
		<idno>CVE-2012-3882: RoboForm</idno>
	</analytic>
	<monogr>
		<title level="j">Feature Accepts Tampered Metadata</title>
		<imprint>
			<date type="published" when="2012-07-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
				<title level="m">CVE-2012-3883: 1Password Restore Feature Accepts Tampered Metadata</title>
		<imprint>
			<date type="published" when="2012-07-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Rootkits for JavaScript environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Adida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Barth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Collin</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd USENIX conference on Offensive technologies, WOOT&apos;09</title>
		<meeting>the 3rd USENIX conference on Offensive technologies, WOOT&apos;09</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Towards a formal foundation of web security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Akhawe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Barth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">E</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23rd IEEE Computer Security Foundations Symposium</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="290" to="304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Discovering concrete attacks on website authorization by formal analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chetan</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karthikeyan</forename><surname>Bhargavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergio</forename><surname>Maffeis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th IEEE Computer Security Foundations Symposium (CSF&apos;12)</title>
		<meeting><address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012-06" />
		</imprint>
	</monogr>
	<note>To appear</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Robust defenses for cross-site request forgery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Barth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Collin</forename><surname>Jackson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<editor>Peng Ning, Paul F. Syverson, and Somesh Jha</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="75" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Secure Password Managers&quot; and &quot;Military-Grade Encryption</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrey</forename><surname>Belenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dmitry</forename><surname>Sklyarov</surname></persName>
		</author>
		<ptr target="http://www.elcomsoft.com/WP/BH-EU-2012-WP.pdf" />
	</analytic>
	<monogr>
		<title level="m">on Smartphones: Oh, Really? Technical report</title>
		<imprint>
			<publisher>Elcomsoft Co. Ltd</publisher>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Cryptography and the internet</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Steven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bellovin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology: Proceedings of CRYPTO &apos;98</title>
		<imprint>
			<date type="published" when="1998-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Cryptree: A folder tree structure for cryptographic file systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dominik</forename><surname>Grolimund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luzius</forename><surname>Meisser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Schmid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rogert</forename><surname>Wattenhofer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th IEEE Symposium on Reliable Distributed Systems, SRDS &apos;06</title>
		<meeting>the 25th IEEE Symposium on Reliable Distributed Systems, SRDS &apos;06</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="189" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Cryptographic cloud storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seny</forename><surname>Kamara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kristin</forename><surname>Lauter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th international conference on Financial cryptograpy and data security, FC&apos;10</title>
		<meeting>the 14th international conference on Financial cryptograpy and data security, FC&apos;10<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="136" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Secure applications of low-entropy keys</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Kelsey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruce</forename><surname>Schneier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Workshop on Information Security, ISW &apos;97</title>
		<meeting>the First International Workshop on Information Security, ISW &apos;97<address><addrLine>London, UK, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="121" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Authenticated-encryption with associated-data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phillip</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM conference on Computer and communications security, CCS &apos;02</title>
		<meeting>the 9th ACM conference on Computer and communications security, CCS &apos;02<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="98" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Busting frame busting: a study of clickjacking vulnerabilities at popular sites</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gustav</forename><surname>Rydstedt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elie</forename><surname>Bursztein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Collin</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Oakland Web 2.0 Security and Privacy</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
