<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:56+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards Transparent and Seamless Storage-As-You-Go with Persistent Memory *</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hyeonho</forename><surname>Song</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">UNIST</orgName>
								<orgName type="institution" key="instit2">UNIST</orgName>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sam</forename><forename type="middle">H</forename><surname>Noh</surname></persName>
							<email>samhnoh@unist.ac.kr</email>
							<affiliation key="aff1">
								<orgName type="department">Introduction</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Towards Transparent and Seamless Storage-As-You-Go with Persistent Memory *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In traditional computer systems, memory and storage are statically divide and separately allocated. In such a strictly dichotomized system, resource usage becomes unbalanced; more memory is always in need, yet large portions of storage remains unused <ref type="bibr" target="#b2">[5,</ref><ref type="bibr" target="#b15">18]</ref>. The goal of this paper is to break this strict division of memory and storage, and present a system that can dynamically move the boundary between memory and storage as need be.</p><p>Commercial Persistent Memory (PM) is now in the horizon. In particular, 3D XPoint based SSDs are now in the market <ref type="bibr" target="#b9">[12]</ref>. More importantly, PM products based on the DIMM interface are expected to be available soon as well <ref type="bibr" target="#b8">[11]</ref>. Such products are expected to bring many changes to ways systems behave <ref type="bibr" target="#b4">[7,</ref><ref type="bibr" target="#b6">9,</ref><ref type="bibr" target="#b17">21]</ref>.</p><p>In this paper, we assume a hybrid memory system composed of DRAM and DIMM interface PM, where the intention is to use PM as storage space <ref type="bibr" target="#b4">[7,</ref><ref type="bibr" target="#b6">9,</ref><ref type="bibr" target="#b17">21]</ref>. For such a system, we present Storage-As-You-Go (SAY-Go), a system that transparently adjusts the use of PM such that PM can be used as memory as well as storage as need be. In particular, it has been observed that storage is almost never used to its full capacity <ref type="bibr" target="#b2">[5,</ref><ref type="bibr" target="#b15">18]</ref>. Our approach is to provide PM as a middle ground where PM that is not yet used as storage may be allocated as memory if the application requires more memory to alleviate the memory crunch.</p><p>There are two technical challenges in achieving this goal. One is providing a memory allocation service that can freely grow and shrink memory it is managing. The other is a file system that supports dynamic resizing of partitions. In this paper, we present our solution of the former, which we refer to as Persistent Memory Buddy (PMB). A design of PMB is presented along with its implementation in the Linux kernel. The latter is left for future <ref type="bibr">work</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Since the inception of modern computing, the hunger for more memory has yet to be satiated. From the early days of computing, and even to this day, techniques such as virtual memory and swapping have been used to provide the illusion of sufficient memory as shown in <ref type="figure" target="#fig_0">Fig- ure 1(a)</ref>. These techniques have come with sacrifice in performance as data needs to be transferred between fast memory and slow storage that are separated by a hard, static boundary. Such techniques were developed under the premise that DRAM capacity is (relatively) small, while storage capacity is large. With the advent of PM, researchers have considered other options. As PM is compatible with DRAM in terms of performance, it was observed that PM itself could (temporarily) be used as memory <ref type="bibr" target="#b10">[13,</ref><ref type="bibr" target="#b11">14]</ref>. (We limit our discussions here to when PM is being used as storage. There is a whole body of work that attempts to make use of PM just as main memory, but again, a resource that is statically and separately divided from storage. See <ref type="bibr" target="#b13">[16,</ref><ref type="bibr" target="#b14">17,</ref><ref type="bibr" target="#b18">22]</ref> and references within for more related work.) The basic idea behind these approaches is depicted in <ref type="figure" target="#fig_0">Figure 1</ref>(b) where part of PM is borrowed out of storage space and used as part of memory.</p><p>Specifically, pVM <ref type="bibr" target="#b11">[14]</ref> is a recent study that focuses on providing persistent store similar to NV-Heap <ref type="bibr" target="#b3">[6]</ref> and Mnemosyne <ref type="bibr" target="#b16">[20]</ref>, but making use of the memory system to enhance performance. In so doing, it also provides a feature to allocate part of the PM as non-persistent space to the process address space. Since providing persistent store is the primary purpose, it also provides a technique for ensuring consistency. In terms of transparency, users need to explicitly make calls to a library with calls such as npmalloc(), nvmmap() to allocate space from PM. This requires application modification and programmer awareness to make use of these features.</p><p>The system most similar to our approach is Memorage proposed by Jung and Cho <ref type="bibr" target="#b10">[13]</ref>. Memorage approaches the problem from a file system perspective. Operating on a PM-based file system, file system free blocks are taken and structured as a buddy system and set as the Memorage zone to provide PM space as memory. The file system has to be modified to reflect the fact that the blocks lent as memory have been allocated so that conflicts do not occur. The benefit of Memorage is that it does not require any application modifications and working memory expansion can be transparently provided. However, it requires modifications to the file system to support this feature. Additionally, runtime overhead is incurred as data structures for memory expansion are created and released dynamically. Finally, the original Memorage study overlooks the issue of data structure consistency, a critical issue when making use of PM.</p><p>A summary of the differences between the two previous closely related studies, pVM and Memorage, and SAY-Go, the system we propose, are given in <ref type="table" target="#tab_1">Table 1</ref>.</p><p>The key distinctive feature of SAY-Go is the transparent dynamic adjustment of the memory and storage boundary as shown in <ref type="figure" target="#fig_0">Figure 1(c)</ref>. To the best of our knowledge, our work is the first to propose and provide a mechanism for supporting such a dynamic boundary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PM Buddy Design Goals</head><p>In the Storage-As-You-Go (SAY-Go) system, instead of a static division of PM into working memory and storage, the PM capacity used as working memory or storage is dynamically adjusted as need be. For such dynamic adjustment, appropriate memory management and file system support is required. In this section, we describe the design goals of PM Buddy (PMB), the memory management component to support SAY-Go.</p><p>Our design goal with PMB is as follows.</p><p>1. Seamless Integration: PMB should take action only when memory runs out. As we assume systems with DRAM and PM hybrid memory, DRAM will, in general, be used as working memory. It is only when DRAM runs out that PMB should start to take action and PM is allocated to applications. This is because PM is anticipated to have performance characteristics lower than that of DRAM. Through this flexible and dynamic allocation of PM free space, the system can dynamically change the logical boundaries of working memory and storage despite the physically fixed boundaries of DRAM and PM, as can be seen from <ref type="figure" target="#fig_0">Figure 1</ref>(c). 2. Transparency: PMB must be supported in a way such that applications are not aware of its happenings, but should only reap the benefits of employing PMB. That is, legacy applications should not change in any way. Furthermore, in developing new applications, legacy programming models should be sufficient and need not make use of new programming models. 3. Consistency: Finally, the system needs to remain consistent upon a normal reboot as well as a reboot after recovery from fault. Consistency here refers to the fact that the persistent part of PM should be viewed as being persistent and the non-persistent part being cleared of content for reuse. Such consistency, though seemingly trivial and natural, cannot be maintained without properly ensuring the permanence of state and their corresponding metadata upon a fault. For example, if not accurately designed, memory leaks may occur if a user program terminates due to a fault in the memory allocation step. Such memory leaks can accumulate as PM is, by nature, persistent, leading to performance degradation in the long run. To achieve goals 1 and 2, we design and implement PMB within the memory management framework of the operating system kernel. In particular, as we describe in Section 4, within Linux, the Buddy system is adopted and extended. To achieve the third goal, we maintain data structures such as page descriptors and an allocation bit map in PM separately from the existing Buddy system and make use of logging.</p><p>We describe the detailed implementation of PMB in the following section. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">PM Buddy Implementation</head><p>In this section, we describe the working prototype of PMB as implemented in Linux. In order to satisfy the transparency design goal, we make minimal changes to the existing system. This is especially important with the memory management module as this module is complex and sensitive to changes. Our approach is to extend the functionality of the existing buddy memory manager. Thus, as PM is extended to be used as working memory, the extra memory space is simply added on to the existing Buddy system with no changes to other layers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Layout</head><p>Memory in Linux is divided into zones, in particular, ZONE DMA, ZONE NORMAL, and ZONE HIGHMEM <ref type="bibr" target="#b7">[10]</ref>. We concentrate our discussion on ZONE NORMAL as this is the zone from which pages are allocated as working memory. Hereafter, we do not consider ZONE DMA and ZONE HIGHMEM as they are irrelevant to our discussion.</p><p>With PMB, the volatile DRAM is covered by ZONE NORMAL (denoted NORMAL, henceforth), while PM is divided into two new zones, ZONE MIGRATE and ZONE STRG (each denoted by MIGRATE and STRG, respectively, henceforth) as shown in <ref type="figure" target="#fig_1">Figure 2</ref>. STRG is the minimum storage area that will always be used as storage space (solid line in <ref type="figure" target="#fig_1">Figure 2</ref>). It is also used to persist metadata that is needed to satisfy the consistency goal of the design, that is, maintain consistency of PM. In particular, STRG stores the PM page descriptor, which contains the current order information that is essential in maintaining the buddy system. It also stores the bitmap that maintains the allocation state of PM pages and a log table used to recover from faults that occur during allocation.</p><p>Though we do not consider the use of recent programming models such as Mnemosyne <ref type="bibr" target="#b16">[20]</ref>, NV-Heaps <ref type="bibr" target="#b3">[6]</ref>, or pVM <ref type="bibr" target="#b11">[14]</ref> in this paper, such models can be supported by making use the STRG zone as depicted by the dotted arrow in <ref type="figure" target="#fig_1">Figure 2</ref>. MIGRATE, on the other hand, is the PM area that is used as memory or storage as flexibly as need be. This area is the core of PMB that is used to satisfy the seamless integration design goal. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Managing pages</head><p>The MIGRATE zone is the key component in PMB. Pages in MIGRATE are either allocated as persistent or non-persistent pages depending on its use as storage or memory. As shown in <ref type="figure" target="#fig_2">Figure 3</ref>, the management of pages in MIGRATE (right hand side) is almost exactly the same as Buddy management in the NORMAL zone (left hand side). The main difference here is the unit of each page. Whereas in Buddy, each page is 4KB, with PMB, the page size is 2MB, the size used for huge pages in Linux. PMB takes the 2MB huge page size as the default page size. This choice is made as the existing Buddy supports a maximum of 4MB contiguous memory space, which is relatively small for the storage layer. With the 2MB default page in PMB, zone MIGRATE and STRG can be allocated contiguous space ranging from 2MB to 2GB, and this allows for the storage layer to handle 2GB of I/O at once. Note 2MB is chosen as this size is the huge page unit supported in our platform architecture and may be changed according to the architectural support.</p><p>Page movement occurs in two directions: from MI-GRATE to NORMAL, which we refer to as 'migration', and vice versa, which we refer to as 'retrieval'. Migration and retrieval are both done in 4MB page chunks, between order 10 of the NORMAL zone and order 1 of the MI-GRATE zone, as depicted in <ref type="figure" target="#fig_2">Figure 3</ref>. Note that 4MB is the largest contiguous page unit supported by the Buddy system. This allows for PMB to be seamlessly integrated into the existing memory module.</p><p>Actual migration of pages from MIGRATE to NOR-MAL is instigated by a free space watermark. If the number of free pages falls below this watermark, the migrator thread calls the page migration function, which transfers the 4MB of free space.</p><p>For retrieval, in our current implementation, there is no watermark and the pages are retrieved, that is, returned from NORMAL to MIGRATE, when all pages belonging to the same order 10 page chunk are released. As we maintain the zone of origin in the page descriptor, this is checked to see where the chunk is from. If it is from MIGRATE, then it is returned to MIGRATE. If the  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head><p>In this section, we discuss the experimental results of PMB. The goals of the experiments are twofold. The first goal is to show that PMB is beneficial in performance compared to the traditional swapping method that is typically used to provide a larger virtual address space in traditional systems. The second is to show that our implementation correctly allocates and retrieves the pages between MIGRATE and NORMAL. These together, in effect, is used to show the practical usefulness of PMB. We make use of two workloads, namely, FFT and the Redis in-memory database, both of which are memory intensive applications. The detailed characteristics of each workload are shown in <ref type="table" target="#tab_2">Table 2</ref>. Note that memory usage is 12GB and 20GB, respectively. The experimental environment is summarized in <ref type="table" target="#tab_3">Table 3</ref>. As real PM is unavailable, we simply make use of DRAM to emulate PM. NORMAL is simply considered to be DRAM as it should be, while MIGRATE and STRG are considered to be PM and set as pseudo-PM by using the modified PMEM device driver <ref type="bibr">[19]</ref>.</p><p>Of the total 256GB of DRAM, 16GB is set aside for STRG. Currently, STRG has no real function except to hold the metadata for consistency. The rest of the 240GB are partitioned between NORMAL and MIGRATE, of which the size is differently set for each workload. For FFT, it is set to 16GB and 224GB, and for Redis, it is set to 32GB and 208GB. This is to accommodate the entire memory needs of each application in DRAM, which serves as the base case. In order to strain the memory usage of each application so that migration will occur, we employ a stress tool that will take up a specified amount of memory capacity <ref type="bibr">[2]</ref>. Using this tool limits the memory usage of the applications that we consider requiring  it to either swap out (as in the traditional system) or to invoke PMB to expand its memory usage to PM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Comparison with swap</head><p>The traditional mechanism to support virtual address space larger than the physical address space is to temporarily place part of the virtual address space in storage space, for example, by means of swapping <ref type="bibr" target="#b12">[15]</ref>. Naturally, if memory space could be extended, there would be less need to make use of storage space resulting in performance improvements. Quantitative observations of such benefits have been made in a previous study <ref type="bibr" target="#b11">[14]</ref>. In this section, we present our own experiments and observations in comparison to the swap mechanism based on our implementation of PMB. <ref type="figure" target="#fig_3">Figure 4</ref> shows the average execution time of 5 executions for each setting with its standard deviation shown with the line range on top of the bars. The results show that as less and less memory is available for the workload considered (which is controlled with the stress tool mentioned above), performance with PMB remains stable. With real PM, we anticipate performance to degrade somewhat as read/write latency is expected to be slightly worse than DRAM. In the interest of space, we did not consider this issue in this paper. In contrast, we see that swapping performance degrades considerably as memory allocated become limited. We also note the standard variation for swapping is much larger than that of PMB showing that PMB performance is relatively stable. Specifically, our measurements show that page migration with PMB is done in 400 nanoseconds on average, while for each swap-in and swap-out, it takes 6 and 41 microseconds, respectively, as measured when the function do swap page() and shrink zone(), respectively, is called and returned. While the actual copying of the page using the movntq instruction for each swap takes roughly 1.2 microseconds, the rest is due to software overhead. In particular, the high overhead of swap-out is due to a couple of reasons. First, within the shrink zone() function, the system tries to avoid swap-out by trying to make use of the unused pages that the slab allocator had pre-allocated and by flushing the page cache to free up memory. Second, if, and only when, these attempts fail, it scans the pages in the zones using a complicated selection algorithm to select the victim page. In the case of swap-in, the page fault handler simply checks whether the requested page is in the swap space, and if so, brings it back to working memory, which incurs much less overhead compared to swap-out. <ref type="figure" target="#fig_4">Figure 5</ref> shows the actual number of pages swapped in and out for the two applications as reported by the /proc/vmstat utility provided in Linux <ref type="bibr" target="#b0">[1]</ref>. We see that the number of swaps has a strong influence on the performance shown in <ref type="figure" target="#fig_3">Figure 4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">PM page migration and retrieval</head><p>In this section, we observe the number of pages that are moved between NORMAL and MIGRATE as the application executes. <ref type="figure" target="#fig_5">Figure 6</ref> shows the number of pages that are migrated to NORMAL, retrieved back to MIGRATE, and the difference between the two, that is the number of pages from MIGRATE that are being used as memory pages, measured in 3 second intervals, as time progresses. We observe that pages are being migrated and retrieved dynamically as applications execute. <ref type="figure" target="#fig_5">Figures 6(a)</ref> and (b) show that for applications run independently and alone, most of the migration and retrieval is happening in a monotonic manner. We observe that the changes are more dynamic for <ref type="figure" target="#fig_5">Figure 6</ref>(c) as FFT terminates and relinquishes the PM space that had been allocated. When run with Redis, FFT showed an average execution time of 60 seconds. Since there is a 20 second lapse before restarting its execution, we see that pages are being freed and retrieved in the vicinity of 60, 140, 220, 300 seconds, being reflected in the fluctuating red line in <ref type="figure" target="#fig_5">Figure 6</ref>(c) around these points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Summary and Future Work</head><p>In this paper, we proposed a system called Storage-AsYou-Go (SAY-Go) that transparently adjusts the use of PM such that PM can be used as memory as well as storage as need be. Whereas previous studies considered DIMM interface PM as storage, this study proposed to break the boundary between memory and storage so that PM is used as memory or storage as needed and for performance benefit.</p><p>In particular, in this paper, we presented the design and implementation of, what we call Persistent Memory Buddy (PMB). PMB allows for memory allocation service that can freely grow and shrink memory it is managing. We presented experimental results that show that PMB performs considerably better than the traditional swapping technique and that PM is being dynamically allocated as memory or storage space.</p><p>There are many issues to resolve to reach our eventually goal of SAY-Go. First and foremost, a file system that supports dynamic resizing of partitions is required. We are in the process of designing this file system. Even within PMB, there are many policy issues that need to be carefully analyzed. This is also on-going work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Working memory expansion methods: (a) Swapping (b) pVM and Memorage (c) SAY-Go</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: PM Buddy layout in Linux</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Page allocation from MIGRATE zone to NOR-MAL zone and vice versa</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Performance of applications as the DRAM used by the application is limited to the values in the x-axis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Total number of swap-ins and swap-outs, each of which incurs a memory copy, observed during execution of applications.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Page migration and retrieval count with PMB</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 (</head><label>6</label><figDesc>a) is the results for when FFT is mak- ing use of 9GB of DRAM (second bar of Figure 4(a)), Figure 6(b) is for Redis making use of 15GB of DRAM (second bar of Figure 4(b)), Figure 6(c) is when both FFT and Redis are executed simultaneously, with the stress tool taking up 8GBs of DRAM. As FFT has shorter ex- ecution time, it is restarted upon termination after a 20 second lapse to show the effect of termination. The re- sults presented are average values of three runs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head></head><label></label><figDesc>. * This work was supported by Samsung Research Funding Center of Samsung Electronics under Project Number SRFC-IT1402-52.</figDesc><table>DRAM 
PM 

static partition 
Working memory 
storage 

swap 
space 
data saved 

DRAM 
PM 

static partition 
Working memory 
storage 

lend to main memory 

dynamic partition 

DRAM 
PM 

Working memory 
storage 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><head>Table 1 : Summary and comparison to previous work</head><label>1</label><figDesc></figDesc><table>pVM 
Memorage 
SAY-Go 

Goal 
persistent 
memory 
efficient use 
store 
expansion 
of resources 
Memory 
fixed 
fixed 
dynamic 
Storage 
Division 

Consistency 
yes 
not 
yes 
considered 
Transparent 
no 
yes 
yes 
(Automatic 
scaling) 
Runtime 
no 
yes 
no 
overhead 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><head>Table 2 : Workload characteristics [3, 4, 8]</head><label>2</label><figDesc></figDesc><table>FFT 
Redis 

Scale 
Memory intensive 
In-memory 
application 
database 
Domain 
Signal processing Key-value store 
Benchmark 
Splash2x 
YCSB 
suite 
in Parsec 3.0 
Input 
Native (largest) 
1:1 (read:write) 
Memory usage 
12GB 
20GB 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Evaluation Platform 

CPU 
Intel Xeon E5-2620v3 
Memory 16GB PC4-17000 × 16 (Total 256GB) 
OS 
Ubuntu 14.04 with Linux v4.11.1 

chunk is originally from NORMAL, naturally, it remains 
in NORMAL. The actual code change required for mi-
gration (and retrieval) is simply a series of list link and 
unlink operations. 

</table></figure>
		</body>
		<back>
			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Linux programmer&apos;s manual: process information pseudofilesystem</title>
		<ptr target="http://man7.org/linux/man-pages/man5/proc.5.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Redis</surname></persName>
		</author>
		<ptr target="https://redis.io/documentation/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A five-year study of file-system metadata</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Agrawal</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Bolosky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Douceur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lorch</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Storage (TOS)</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">9</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Making Persistent Objects Fast and Safe with Next-Generation, NonVolatile Memories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Coburn</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Caulfield</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Akel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Grupp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">M</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Swanson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Nv-Heaps</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Better I/O Through ByteAddressable, Persistent Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Condit</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nightingale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">B</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ipek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Burger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Coetzee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Operating Systems Principles (SOSP</title>
		<meeting>the ACM Symposium on Operating Systems Principles (SOSP</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Benchmarking Cloud Serving Systems with YCSB</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cooper</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">F</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sears</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Cloud Computing (SoCC)</title>
		<meeting>the ACM Symposium on Cloud Computing (SoCC)</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">System Software for Persistent Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dulloor</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Keshavamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lantz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sankaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jackson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Computer Systems (EuroSys)</title>
		<meeting>the European Conference on Computer Systems (EuroSys)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Understanding the Linux Virtual Memory Manager</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gorman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Intel&apos;s 3D XPoint TM Technology Products -What&apos;s Available and What&apos;s Coming Soon</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Debra</forename><forename type="middle">H</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
				<ptr target="hhttps://www.intel.com/content/www/us/en/products/memory-storage/solid-state-drives/gaming-enthusiast-ssds/optane-900p-series.html" />
		<title level="m">INTEL. Intel optane SSD 900p series</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Emerging persistent ram based malleable main memory and storage architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jung</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cho</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Memorage</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International ACM Conference on International Conference on Supercomputing (ICS)</title>
		<meeting>the International ACM Conference on International Conference on Supercomputing (ICS)</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">pVM: persistent virtual memory for efficient capacity scaling and object storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kannan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ada</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karsten</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Computer Systems (EuroSys)</title>
		<meeting>the European Conference on Computer Systems (EuroSys)</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Linux swap space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kay</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An Experimental Study on the Effect of Asymmetric Memory Latency of New Memory on Application Performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Moon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Symposium on Modeling, Analysis and Simulation of Computer and Telecommunication Systems (MASCOTS)</title>
		<meeting>the IEEE International Symposium on Modeling, Analysis and Simulation of Computer and Telecommunication Systems (MASCOTS)</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Nvm duet: Unified working memory and persistent store architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R.-S</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D.-Y</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-L</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-Y</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A study of practical deduplication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meyer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bolosky</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename></persName>
		</author>
		<idno>14. [19] SNIA. pmem</idno>
		<ptr target="http://http://pmem.io" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Storage (TOS)</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Lightweight Persistent Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Volos</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Tack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mnemosyne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Log-structured File System for Hybrid Volatile/Non-volatile Main Memories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Swanson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Nova</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on File and storage technologies (FAST)</title>
		<meeting>the Conference on File and storage technologies (FAST)</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A study of application performance with non-volatile main memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Swanson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Mass Storage Systems and Technologies (MSST)</title>
		<meeting>the IEEE Conference on Mass Storage Systems and Technologies (MSST)</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
