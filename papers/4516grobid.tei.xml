<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:23+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Provenance Analyzer: Exploring Provenance Semantics with Logic Rules</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saumen</forename><surname>Dey</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sean</forename><surname>Riddle</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bertram</forename><surname>Ludäscher</surname></persName>
						</author>
						<author>
							<affiliation>
								<orgName>1 Introduction</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Provenance Analyzer: Exploring Provenance Semantics with Logic Rules</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Consider the snippet of an OPM (Open Provenance Model <ref type="bibr" target="#b7">[8]</ref>) graph shown in <ref type="figure" target="#fig_0">Fig. 1</ref>. It consists of a single wasGeneratedBy edge with two nodes, data artifact A and process P. What exactly can we say about the dependency between artifact A and process P? Can we say that A was in fact generated by P, or was A generated by another process Q which used an artifact B that was generated by P? In fact, we cannot be sure. In particular, the given provenance information is insufficient to describe unambiguously in which order some basic OPM events (i.e., start of P, creation of A, end of P) occurred.</p><p>The authors of <ref type="bibr" target="#b3">[4]</ref> introduced precise edges (in addition to the default imprecise edges) to help narrow such ambiguities, provided a formal temporal OPM semantics via partial orders, and gave an efficient deductive procedure to compute all constraints implied by the axioms. Precise edges are labeled with a role, and represent a direct rather than transitive relationship, whereas an imprecise edge can represent a direct or a transitive relationship. → Q, or (iii) P did in fact create A and there is a * {scdey,swriddle,ludaesch}@ucdavis.edu. Dept. of Computer Science, UC Davis. The first and second authors contributed equally.</p><p>1 Similar to <ref type="bibr" target="#b3">[4]</ref>, we use "!" to indicate precise relations.</p><p>precise edge as in <ref type="figure" target="#fig_1">Fig. 2</ref>(b) to indicate this. In the latter case, the imprecise edge is redundant. <ref type="bibr" target="#b1">2</ref> Note that even though <ref type="figure" target="#fig_1">Fig. 2</ref>(b) specifies an unambiguous total order of events (assuming that events cannot occur simultaneously), <ref type="figure" target="#fig_0">Fig. 1</ref> and <ref type="figure" target="#fig_1">Fig. 2(a)</ref> do not. The situation only gets more complex when additional edge types are introduced. In <ref type="figure" target="#fig_2">Fig. 3</ref>, there are five temporal events: create(B), use(B), begin(P), end(P), and create(A). One obvious order is create(B)≤begin(P)≤use(B)≤create(A)≤end(P). But also legal is one in which begin(P)≤create(B). There are more dramatic ones as well, e.g., (a) where all events occur at the same time (e.g., via a sufficiently coarsegrained clock <ref type="bibr" target="#b3">[4]</ref>) or (b) data artifact A was generated first and then data artifact B was used! The many different ways these events might have occurred can make it difficult to understand and use provenance. In addition, these ambiguities may make system to system provenance data sharing impossible.   <ref type="bibr" target="#b3">[4]</ref>: The r-labeled wasDerivedFrom edge between A and B, together with the r-labeled use edge from P to B and the third precise edge wasGeneratedBy from A to P imply that A was in fact generated by P and that P used B in the creation of A. The additional knowledge captured in this way eliminates certain possible worlds as create(A) cannot precede use(B) anymore. In fact, the order of events implied by <ref type="figure" target="#fig_3">Fig. 4</ref> is almost completely determined, the only excep-</p><formula xml:id="formula_0">data(D). % data identifier D invoc(I).</formula><p>% process invocation id I usd <ref type="bibr">(I,D)</ref>. % process invocation I used data D gen <ref type="bibr">(D,I)</ref>.</p><p>% data D was generated by invocation I der(D2,D1). % data D2 was derived form D1 inf(I2,I1). % invocation I1 was informed by I2 tion that the events create(B) and begin(P) can be in either order.</p><p>We are developing Provenance Analyzer, a framework and system prototype that allows users to compute all possible worlds, i.e., all orders in which the events of a given OPM graph may have occured and then analyze these alternative orders to better understand the provenance data and their respective dependencies. In particular, our system allows enumeration of the (often very large number of) possible orders, as well as queries about which dependencies are true in all (or just some) of the possible world. The main idea is to encode provenance semantics contained in a particular set of axioms and constraints as logic rules, then employ a powerful reasoning framework to systematically generate and test all possible orders. In our current prototype, we encoded the temporal axioms and constraints in <ref type="bibr" target="#b3">[4]</ref> as logic rules. Our system facilitates experimenting with different provenance semantics: a provenance researcher can simply add, modify, or delete axioms and study the repercussions using actual examples.</p><p>Below, we first introduce a variant of OPM, modeled in Datalog. We then describe the Provenance Analyzer framework and implementation. We end with a brief discussion of related work and conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Provenance Model</head><p>In our Datalog variant of the Open Provenance Model (OPM) <ref type="bibr" target="#b7">[8]</ref>, we focus on data artifacts and processes and the relationships between them. The key relations are used, wasGeneratedBy, wasDerivedFrom, and wasInformedBy, with shorthands usd, gen, der, and inf, respectively. <ref type="bibr" target="#b2">3</ref> An OPM graph G = (V, E) is a directed graph whose nodes V = D ∪ I are data artifacts D or process invocations I; and edges</p><formula xml:id="formula_1">E ⊆ E usd ∪ E gen ∪ E der ∪ E in f , E usd = I × D, E gen = D × I, E der = D × D, E in f = I × I.</formula><p>We use the relations as shown in <ref type="figure" target="#fig_5">Fig. 5</ref> to capture the node and edge information in our system.</p><p>Extension of OPM. In <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr">Kwasnikowska et al. ex</ref>tend the OPM model with distinct precise edges, in <ref type="bibr" target="#b2">3</ref> We ignore the agents, wasControlledBy, and wasTriggeredBy entities in the OPM model. addition to the (default) imprecise edges. This model is represented by the relations in <ref type="figure" target="#fig_6">Fig. 6</ref> in addition to those in <ref type="figure" target="#fig_5">Fig. 5</ref>. Using this model, a provenance graph G = (V, R, E) is a directed graph whose nodes V = D ∪ I are data artifacts D or process invocations I; R is a set of roles; and edges E ⊆ E p ∪ E m , precise edges E p = E pGen ∪ E pUsd ∪ E pDer , and imprecise edges E m = E der ∪ E in f ∪ E gen ∪ E usd , where E pGen = D × R × I, E pUsd = I ×R×D, E pDer = D×R×D, E usd = I ×D, E gen = D×I, E der = D × D, and E in f = I × I.</p><formula xml:id="formula_2">pGen(D,R,I).</formula><p>% data D was generated by % invocation I with role R pUsd(I,R,D).</p><p>% invocation I used data D % with role R pDer(D2,R,D1). % data D2 was derived form % D1 with role R Formal temporal extension of OPM. A formal temporal semantics for OPM in the form of a translation from OPM graph patterns to temporal constraints is given in <ref type="bibr" target="#b3">[4]</ref> (e.g., an artifact cannot be used before it is created). The OPM graphs can optionally be annotated with additional constraints for specific events if they are known in the context of a given computation. With the temporal semantics, OPM is extended as G = (V, R, E, S), where S = (Ev, T, M), Ev is the set of events, T is a set of time points, M ⊂ Ev × T is the mapping from events to time points, and Ev = Ev create ∪ Ev use ∪ Ev begin ∪ Ev end . There is an Ev create event for each data artifact and an Ev use event for each use. Each process has an Ev begin and Ev end event. The relation time/1 contains the set of available time points and the at/2 relation maintains the mapping of an event to a time point. <ref type="bibr" target="#b3">4</ref> The predicates used to encode this temporal extension are in <ref type="figure" target="#fig_7">Fig. 7</ref>.</p><formula xml:id="formula_3">event(E). % event identifier E create(E,D).</formula><p>% create event for the data D begin(E,I).   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Other Preliminaries</head><p>Before presenting the details of our approach, we recall some necessary background and basic definitions on partial and total orders, as these are essential to our approach. We also briefly introduce Answer Set Programming (ASP), which we use in each of our approaches to search the problem space.</p><p>Total and Partial Orders. A (non-strict) partial order is a binary relation ≤ over a set X that is reflexive, antisymmetric, and transitive. A total order is a partial order which is also total, i.e., all pairs a, b ∈ X are comparable: a ≤ b or b ≤ a holds. Generally, there are many linear extensions (total orders) that agree with a given partial order, and the existence of at least one is guaranteed <ref type="bibr" target="#b8">[9]</ref>. For example, consider X = {a, b, c} with the partial order: a ≤ b and a ≤ c. Two linear extensions are a ≤ b ≤ c and a ≤ c ≤ b. A single total order can be obtained by a simple, linear time algorithm, e.g., see Cormen et al. <ref type="bibr" target="#b1">[2]</ref>. Sometimes (partial and total) orders are defined using a strict relation &lt; instead of ≤: Such a strict total order is transitive and trichotomous, i.e., exactly one of a &lt; b, a &gt; b, or a = b holds. An example of a logic program that creates all strict total orders over a given set of events ev/1 is shown in <ref type="figure" target="#fig_9">Fig. 8</ref>: The non-stratifed rule (1) is used to generate alternative "guesses": for any X = Y , either X &lt; Y or Y &lt; X; (2) infers transitive edges; and (3) rules out cases where a &lt; b and b &lt; a (including the special case of reflexivity a &lt; a). <ref type="bibr" target="#b4">5</ref> Answer Set Programming (ASP). In our approach we generate many models representing the possible schedules of events, then eliminate those that contradict the axioms. Specifically, we use a Generate-and-Test pattern from answer set programming (ASP) <ref type="bibr" target="#b5">[6]</ref>, i.e., we use sets of stable models <ref type="bibr" target="#b2">[3]</ref> to represent all possible worlds that are consistent with the given provenance assertions.</p><p>Let us consider the ASP program shown in <ref type="figure" target="#fig_9">Fig. 8</ref>. If it is run in combination with the facts ev(a), ev(b), and ev(c), then it will generate 3! = 6 distinct stable models that differ in the valuation of after/2: e.g., among them would be {after(a, b), after(b, c)} and <ref type="bibr" target="#b4">5</ref> The empty head in (3) is shorthand for "False": if the body evaluates to true, the constraint is violated and the model is discarded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Provenance</head><p>Graph {after(b, a), after(a, c)}. Both are stable models because they "reproduce themselves", when reducing the negative literals of the ground-instantiated program according to their values in the model, then computing the unique minimal model of the reduced positive program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Provenance Analyzer</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Framework</head><p>Provenance Analyzer consists of three main steps: (i) ExtractEvents, (ii) ComputeTotalOrders, and (iii) PostProcessing (see <ref type="figure">Fig. 9</ref>). Given an OPM provenance graph, the first step extracts events using the logic rules in <ref type="figure" target="#fig_0">Fig. 11</ref>. Rules (1-3) check if the provenance graph is legal. These rules are based on the definition of legal OPM as stated in <ref type="bibr" target="#b3">[4]</ref>: Rule (1) checks if there are any write conflicts (i.e., a data artifact is "precisely generated" by more than one process invocation). Rules (2) and (3) check if for a precise wasDerivedFrom edge (pDer) there is a precise used edge (pUsd) and a precise wasGeneratedBy edge (pGen). Rules (4-8) extract temporal events from the OPM graph using the relations described in <ref type="figure" target="#fig_7">Fig. 7</ref>. Rule (4) extracts a create event with identifier E for a data artifact D. The id relation maps data artifacts D and process invocations I to unique event identifiers E. Rule (5) extracts a use event for precise use of a data artifact, where useId provides the event identi- Three alternative implementations of ComputeTotalOrders in <ref type="figure">Fig. 9</ref>: DeducePO computes a partial order using all axioms and inference rules from <ref type="bibr" target="#b3">[4]</ref> and then computes all total orders. AbducePO computes all partial event orders and removes the ones which contradict the axioms. AbduceTime maps events to time points in all possible ways and removes the ones which violate the axioms.</p><p>fier E for the precise use of a data artifact D by a process invocation I with role R. Rule (6) extracts a use event for an imprecise use of a data artifact, where useIdNoR provides the event identifier E for the imprecise use of a data artifact D by a process invocation I. Rules (7) and (8) extract the begin and end events for a process invocation, respectively.</p><p>ComputeTotalOrders generates all total orders that are compatible with the given axioms.</p><p>Various approaches can be considered for this step. Our current prototype implements three approaches, (i) Deduce Partial Order (DeducePO), (ii) Abduce Partial Order (AbducePO), and (iii) Abduce Time (AbduceTime). In DeducePO, we use the axioms and inference rules provided in <ref type="bibr" target="#b3">[4]</ref> to compute the unique partial order of the events and then compute all possible total orders. In AbducePO, we use abduction to generate all possible partial orders of events and implement the temporal axioms in form of constraints (denial rules) to filter out the partial orders that do not respect the temporal axioms, and in AbduceTime, we generate all possible ways (i.e., possible models) of mapping events with time points and remove the models that violate any temporal axioms. The logical architecture of these three approaches is shown in <ref type="figure" target="#fig_0">Fig. 10</ref>.</p><p>In the PostProcessing step, which is optional, various analysis of interests can be performed on the possible models of the events. For example, to check if a relation-   ship between two events is in (i) some models, (iii) all models, (iii) no models, (iv) or even in a certain percentage of models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Deduce Partial Order (DeducePO)</head><p>Our first approach follows that of <ref type="bibr" target="#b3">[4]</ref>, then compuates all total orders: new edges in the OPM graph are inferred, and then, using the old and new edges along with the deductive procedure given in <ref type="bibr" target="#b3">[4]</ref>, a partial order is created (ComputePO in <ref type="figure" target="#fig_0">Fig. 10</ref>) that contains exactly the constraints implied by the axioms. Rules deducing constraints specified by Axioms 2 6 and Axiom 8 7 are shown in <ref type="figure" target="#fig_0">Fig. 12</ref>. Other axioms are implemented similarly. From there, each possible total ordering that satisfies the partial order is generated with ASP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Abduce Partial Order (AbducePO)</head><p>In our AbducePO approach, GuessPO step as shown in <ref type="figure" target="#fig_0">Fig. 10</ref>, uses abduction to generate all possible valuations of the after(E1, E2) predicate, representing that E1 happens strictly after E2. Denial rules are applied that ensure that after(E1, E2) respects the temporal axioms. Rules enforcing axioms 2 and 8 are shown in <ref type="figure" target="#fig_0">Fig. 13</ref>. Other axioms are implemented in the similar way.</p><p>% Artifact can't be created before process has started. % tc_after is a transitive closure over after :-pGen(D,_,I), begin(E1,I), create(E2,D), tc_after(E1, E2).</p><p>% Artifact can't be created after process has ended. :-pGen(D,_,I), create(E1,D), end(E2,I), tc_after(E1, E2).</p><p>% Artifact can't be created before the use :-pGen(D2,_,I), use(E1,I,R,D1), create(E2,D2), pDer(D2,R,D1), tc_after(E1, E2). TOFilter removes all partial orders that do not trivially correspond to total orders by forming a chain of after facts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Abduce Time</head><p>In this approach the basic idea is to generate all possible ways (models) events can be mapped to time points. We use the Datalog rules shown in <ref type="figure" target="#fig_0">Fig. 14</ref> for this purpose. Rules 1 and 2 map exactly one time point to an event. In some of these models two or more events may be mapped to a single time point. Rule 3 removes such models from the list of possible models. Now, among these remaining possible models, some may not confirm to the axioms as specified in the <ref type="bibr" target="#b3">[4]</ref> paper. We implement these axioms as denial rules and for example we showed the implementation of axioms 2 and 8 in <ref type="figure" target="#fig_0">Fig. 14</ref>. Axiom 2 is implemented using rules 4 and 5 and axiom 8 is implemented using rule 6. Rule 4 removes the models in which data artifacts are created before the process that created the artifact has started. In the similar way, rule 5 removes the modes in data artifacts are created after the process that created the artifact has ended. Rule 6 removes the models in which a data artifact is used before it is created.</p><p>As a final step using the rules 7 through 9 are used to remove models with any gap in between timepoints. All the possible models which pass this step have all the events in total order, which have no ambiguities and thus can be used for further analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Post Processing</head><p>We discuss two useage of our Provenance Analyzer and we believe this can be used for many other interesting purposes.</p><p>% Assigning only one timepoint to an event (1) at(T,E) :-time(T), event(E), not blk(T,E). (2) blk(T,E) :-time(T), at(TE,E), TE != T. % No two events happen at the same time (3) :-at(T,E1), at(T,E2), E1 != E2. % Axiom 2 (4) :-pGen(D,_,I), begin(E1,I), create(E2,D), at(T1,E1), at(T2,E2), T1&gt;T2. (5) :-pGen(D,_,I), create(E1,D), end(E2,I), at(T1,E1), at(T2,E2), T1&gt;T2.</p><p>% Axiom 8 (6) :-pGen(D2,_,I), useR(E1,I,R,D1), create(E2,D2), pDer(D2,R,D1), at(T1,E1), at(T2,E2), T1&gt;T2.</p><p>% Removing parsely distributed events (7) eventsAt(T) :-at(T,_).  A common query to ask of our system (which we will call the LEQ query) is whether for events E 1 and E 2 , is T (E 1 ) ≤ T (E 2 ) in (a) some models, (b) all models, or (c) no models. This can be efficiently solved directly on the deductively generated partial order taken in combination with whether or not the user chooses to allow simultaneous events; for details, see the appendix.</p><p>Another interesting use of Provenance Analyzer can be to understand the impact of axioms and inferences. Note that AbducePO and AbduceTime can both arrive at the exact same total orders as the deductive approach, but solely using the axioms and without the accompanying inference rules. This makes them a useful tool to experiment with altered axioms and examine effects without worrying that the rules used in the deductive approach will no longer be sound and complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head><p>We evaluated Provenance Analyzer from the point of views of (i) Number of models, and (ii) Execution time.</p><p>Number of Models. We introduce a new provenance graph, to facilitate the explanation of number of models  generation, as shown in <ref type="figure" target="#fig_0">Fig. 15</ref>, which is a complex variant of our earlier examples. <ref type="table" target="#tab_1">Table 1</ref> shows the number of models generated for the provenance graphs as shown in <ref type="figure" target="#fig_2">Fig. 3, Fig. 4</ref>, and <ref type="figure" target="#fig_0">Fig. 15</ref>. We see that adding edges to an existing graph and leaving the nodes unchanged (as in going from <ref type="figure" target="#fig_2">Fig. 3</ref> to <ref type="figure" target="#fig_3">Fig. 4</ref>) tends to reduce the number of possible worlds. <ref type="figure" target="#fig_0">Fig. 15</ref> has got lot more models. This is due to the inclusion of additional nodes. For each additional data item there is a new time point representing its creation and one for each use, and for each new process invocation there is a start and an end timepoint. These new time points increase the number of possible orders, even if there are concomitantly more constraints on those total orders. Given the provenance as shown in <ref type="figure" target="#fig_0">Fig. 15</ref>, the AbduceTime approach outperforms the more guided DeducePO when generating all legal total orders of events. This is only the case, though, if there are exactly as many time points defined in time/1 as events to order. If there are more time points than the number of events, then the abductive component of AbduceTime will attempt to generate interpretations that use them by leaving gaps in time. These will be consolidated by TOFilter, which removes models containing gaps, but it takes time to generate them and determine that they must be removed later. The execution of the AbduceTime approach is O(T E ), where T is the number of time points and E is the number of events, whereas the other two approaches do not use the time/1 predicate at all, so they are unaffected. One might want to allow gaps to constrain at what time points events can occur. Note that TOFilter will eliminate these, so it should not be used in this situation.  <ref type="table">Table 2</ref>: Runtimes (sec) for the seven events in <ref type="figure" target="#fig_0">Fig. 15</ref>.</p><p>Generating all total orders of events quickly becomes infeasible with even moderately-sized input traces. With the DeducePO approach, it is possible to stop after generating the single, most informed partial order, and not generate the total orders at all. Both AbduceTime and AbducePO generate all partial orders, in which some of them do not obey the definition of a partial order and are discarded. The problem is that the number of partial orders is significantly larger than the number of all total orders. This is obvious when one observes that TOFilter removes some partial orders and is still left with all strict total orders. We envision future work to make the partial and total order generation steps more efficient based on the observation that if a partial order is not legal, then a partial order that is identical, except with some inputs that were incomparable made comparable, is also illegal. Use of subsumption during execution should allow the pruning of redundant branches in the search tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related work</head><p>There has been some work to explore possible models captured by a given provenance graph. In <ref type="bibr" target="#b6">[7]</ref>, the authors have presented an encoding of PROV, the emerging W3C recommendation for a provenance data model and a successor of OPM. Provenance graphs, inference rules and constraints are realized in Datalog. Such an encoding allows intuitive, declarative queries on provenance graphs. Furthermore, the constraint-solving capabilities of the DLV Datalog engine <ref type="bibr" target="#b4">[5]</ref>, which is freely available for non-commercial use, are used to demonstrate automated validation of PROV constraints, e.g., to detect temporal inconsistencies and illegal cycles in the provenance graph.</p><p>In <ref type="bibr" target="#b0">[1]</ref>, the authors argue that data provenance can be at times ambiguous or simply inaccurate. They identified likely provenance quality issues and established crucial quality dimensions toward measuring quality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>To understand the processing history of data artifacts, it is often important to understand the order of events. Time is only an optional annotation in OPM and provenance recorders may not capture all the time information. Thus, a provenance graph may not be sufficient to infer a total order of events. <ref type="bibr" target="#b3">[4]</ref> addresses limitations of OPM by providing a formal semantics that introduces precise and imprecise edges and a temporal semantics. This maps an OPM graph to a set of ordering constraints between time-points. Utilizing its axioms and inferences, they show that there is a deductive procedure for generating the partial order that corresponds to the graph as implied by the axioms.</p><p>We have developed a prototype, Provenance Analyzer, in which we have implemented the axioms and inference rules as specified by <ref type="bibr" target="#b3">[4]</ref> to compute the partial order of events from the given provenance graph.</p><p>Our framework for experimenting with axioms allows for manual elucidation of the effect of alterations to the axioms and inference rules. In <ref type="bibr" target="#b3">[4]</ref>, a subset of the axioms and inference rules is shown to be sufficient to generate all correct inequalities between timepoints where neither represents the use of an artifact (so-called nouse inequalities). Our tool could be used to automate an exhaustive search through all combinations of axiom and rule subsets and test empirically which approaches might coincide for a given set of examples. Although this wouldn't constitute a formal proof of equivalence, it would still allow to test and debug variant sets of axioms and find candidate pairs of potentially equivalent (or definitely non-equivalent) rule sets.</p><p>Our tool can be downloaded from http://code. google.com/p/provenance-analyzer/.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Data artifact A wasGeneratedBy process P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: Two different possibilities in the trace file</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 :</head><label>3</label><figDesc>Fig. 3: P generated A, but did it use B for that?</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 :</head><label>4</label><figDesc>Fig. 4: Refinement of Fig. 3 via a generate-use-derive triangle [4]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4</head><label>4</label><figDesc>Fig. 4 refines and clarifies the situation via a generateuse-derive triangle [4]: The r-labeled wasDerivedFrom edge between A and B, together with the r-labeled use edge from P to B and the third precise edge wasGeneratedBy from A to P imply that A was in fact generated by P and that P used B in the creation of A. The additional knowledge captured in this way eliminates certain possible worlds as create(A) cannot precede use(B) anymore. In fact, the order of events implied by Fig. 4 is almost completely determined, the only excep-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: Datalog schema used in Provenance Analyzer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 :</head><label>6</label><figDesc>Fig. 6: Extended Datalog schema for precise edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 7 :</head><label>7</label><figDesc>Fig. 7: Datalog schema for temporal relations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 8 :</head><label>8</label><figDesc>Fig. 8: Rules producing all strict total orders over ev/1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Fig. 10: Three alternative implementations of ComputeTotalOrders in Fig. 9: DeducePO computes a partial order using all axioms and inference rules from [4] and then computes all total orders. AbducePO computes all partial event orders and removes the ones which contradict the axioms. AbduceTime maps events to time points in all possible ways and removes the ones which violate the axioms.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 11 :</head><label>11</label><figDesc>Fig. 11: Rules to extract events from an OPM graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 12 :</head><label>12</label><figDesc>Fig. 12: Axiom 2 and 8 in the DeducePO approach.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 13 :</head><label>13</label><figDesc>Fig. 13: Implementation of axiom 2 and 8 in form of denial rules in the AbducePO approach.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>( 8 )</head><label>8</label><figDesc>eventsAfter(T) :-time(T), at(T2,_), T2&gt;T. (9) :-time(T), eventsAfter(T), not eventsAt(T).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 14 :</head><label>14</label><figDesc>Fig. 14: AbduceTime approach, in which events are mapped to time points in all possible ways (models) using rules 1,2, and 3. Axioms are implemented as denial rules to remove the illegal models. Implementation of axioms 2 and 8 are shown in rules 4 though 6. Rules 7 though 9 removes models with gaps in time points.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig</head><label></label><figDesc>Fig. Models List of events extracted 3 5 P : begin, B : create, A : create, B : use, P : end 4 2 B : create, P : begin, B : use, A : create, P : end 15 16 P : begin, B : create, B : use, C : create, C : use, A : create, P : end</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig. 15 :</head><label>15</label><figDesc>Fig. 15: Data artifact A wasGeneratedBy process P, which used both B and C</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>G</head><label></label><figDesc></figDesc><table>ExtractEvents 

Events Ev 

ComputeTotalOrders 

Possible worlds 
of total orders 
of events 

PostProcessing 

Results 

Fig. 9: Provenance Analyzer Framework with main 
steps ExtractEvents, ComputeTotalOrders, and 
PostProcessing. There are different approaches for 
ComputeTotalOrders. PostProcessing is optional. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Number of total orders and event lists 

</table></figure>

			<note place="foot" n="2"> Axiom 2 in [4] states for a precise wasGeneratedBy edge we have: begin(P)≤create(A)≤end(P), while for an imprecise wasGeneratedBy edge, Axiom 5 only states: begin(P)≤create(A), so no additional constraints are inferred from the imprecise edge.</note>

			<note place="foot" n="6"> if artifact A precisely depends on process P, then begin(P) ≤ create(A) ≤ end(P) 7 if artifacts A and B and process P form a use-derive-generate triangle in which A is derived from B in role r, P used B in the same role, and A was precisely generated by P, then use(P, r, B) ≤ create(A)</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Appendix</head><p>LEQ on All/Some/No models. In Section 4.5, we claimed that it was possible to efficiently perform the query "For events E 1 and E 2 , is T (E 1 ) ≤ T (E 2 ) for all, some, or no models?" <ref type="bibr">(Where T (x)</ref> should be read as 'the time at which x occurred') Consider the partial order deductively generated by the technique specified in <ref type="bibr" target="#b3">[4]</ref>. If the constraint T (E 1 ) ≤ T (E 2 ) is derived, then T (E 1 ) ≤ T (E 2 ) is true for all possible total orders. If the reverse constraint is derived, then T (E 2 ) ≤ T (E 1 ). In terms of the original question, this means that either T (E 1 ) &gt; T (E 2 ) in all models if simultaneous events are forbade, or T (E 1 ) = T (E 2 ) in some models if they are allowed. So if simultaneous events are disallowed, then T (E 1 ) ≤ T (E 2 ) in no models, whereas if they are allowed, then T (E 1 ) ≤ T (E 2 ) in some models. If no constraint exists between T (E 1 ) and T (E 2 ), then some total orders exist in which T (E 1 ) &lt; T (E 2 ) and some in which T (E 1 ) &gt; T (E 2 ). If this were not the case, then either T (E 1 ) ≤ T (E 2 ) or the reverse constraint T (E 2 ) ≤ T (E 1 ) would be derived.</p><p>LEQ using AbducePO and AbduceTime. LEQ can also be solved by post-processing of models generated by the AbducePO or AbduceTime approaches. Normally, it is infeasible to perform queries that make claims about multiple models. Some ASP systems, for example DLV, do have support for brave/cautious (the query evaluates to true if it is true in some/all models) reasoning without enumerating all possible worlds. We created a postprocessor that creates an EDB from a logic program by executing that program under ASP semantics and, from answer sets {A 1 , ..., A n }, creates a fact p(i, ¯ X) for each p( ¯ X) ∈ A i . Now LEQ, as well as well as more complex queries that go beyond what can be accomplished with brave/cautious reasoning, can be easily expressed in this multiverse reification.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Provenance analysis: Towards quality provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cheah</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Plale</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2012 IEEE 8th International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
	<note>E-Science</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Introduction to Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cormen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">H</forename><surname>Leiserson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Stein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<publisher>MIT Press</publisher>
			<biblScope unit="page" from="549" to="552" />
		</imprint>
	</monogr>
	<note>2nd ed.. Section 22.4: Topological sort</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The stable model semantics for logic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gelfond</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lifschitz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Conference on Logic programming</title>
		<meeting>the 5th International Conference on Logic programming</meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page">161</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">A formal account of the open provenance model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kwasnikowska</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Moreau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">And</forename><surname>Van Den</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bussche</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010-12" />
		</imprint>
		<respStmt>
			<orgName>University of Southampton</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Tech. Rep. 21819</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The dlv system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leone</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Pfeifer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Faber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Calimeri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Dellarmi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Eiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gottlob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ianni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ielpa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">T</forename><surname>Al</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Logics in Artificial Intelligence</title>
		<imprint>
			<biblScope unit="page" from="537" to="540" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">What is answer set programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lifschitz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAAI Conference on Artificial Intelligence</title>
		<meeting>the AAAI Conference on Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1594" to="1597" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">A prov encoding for provenance analysis using deductive rules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Missier</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Belhajjame</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<publisher>IPAW</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The open provenance model core specification (v1.1)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moreau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Clifford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Futrelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kwas-Nikowska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Miles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Missier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Plale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Simmhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Stephan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">V</forename><surname>Bussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Future Generation Computer Systems</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="743" to="756" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Ordered sets: an introduction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schr¨oderschr¨</forename><surname>Schr¨oder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">S W</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>Birkhauser</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
