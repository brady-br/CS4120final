<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:23+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Not So Fast: Analyzing the Performance of WebAssembly vs. Native Code Not So Fast: Analyzing the Performance of WebAssembly vs. Native Code</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>July 10-12, 2019</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abhinav</forename><surname>Jangda</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Massachusetts Amherst</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts</orgName>
								<address>
									<settlement>Amherst</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bobby</forename><surname>Powers</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Massachusetts Amherst</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts</orgName>
								<address>
									<settlement>Amherst</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emery</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Massachusetts Amherst</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts</orgName>
								<address>
									<settlement>Amherst</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arjun</forename><surname>Guha</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Massachusetts Amherst</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts</orgName>
								<address>
									<settlement>Amherst</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abhinav</forename><surname>Jangda</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Massachusetts Amherst</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts</orgName>
								<address>
									<settlement>Amherst</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bobby</forename><surname>Powers</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Massachusetts Amherst</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts</orgName>
								<address>
									<settlement>Amherst</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emery</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Massachusetts Amherst</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts</orgName>
								<address>
									<settlement>Amherst</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arjun</forename><surname>Guha</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Massachusetts Amherst</orgName>
								<orgName type="institution" key="instit2">University of Massachusetts</orgName>
								<address>
									<settlement>Amherst</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Not So Fast: Analyzing the Performance of WebAssembly vs. Native Code Not So Fast: Analyzing the Performance of WebAssembly vs. Native Code</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2019 USENIX Annual Technical Conference</title>
						<meeting>the 2019 USENIX Annual Technical Conference <address><addrLine>Renton, WA, USA</addrLine></address>
						</meeting>
						<imprint>
							<date type="published">July 10-12, 2019</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 2019 USENIX Annual Technical Conference is sponsored by USENIX. https://www.usenix.org/conference/atc19/presentation/jangda</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>All major web browsers now support WebAssembly, a low-level bytecode intended to serve as a compilation target for code written in languages like C and C++. A key goal of Web-Assembly is performance parity with native code; previous work reports near parity, with many applications compiled to WebAssembly running on average 10% slower than native code. However, this evaluation was limited to a suite of scientific kernels, each consisting of roughly 100 lines of code. Running more substantial applications was not possible because compiling code to WebAssembly is only part of the puzzle: standard Unix APIs are not available in the web browser environment. To address this challenge, we build BROWSIX-WASM, a significant extension to BROWSIX [29] that, for the first time, makes it possible to run unmodified WebAssembly-compiled Unix applications directly inside the browser. We then use BROWSIX-WASM to conduct the first large-scale evaluation of the performance of WebAssembly vs. native. Across the SPEC CPU suite of benchmarks, we find a substantial performance gap: applications compiled to WebAssembly run slower by an average of 45% (Firefox) to 55% (Chrome), with peak slowdowns of 2.08× (Firefox) and 2.5× (Chrome). We identify the causes of this performance degradation, some of which are due to missing optimizations and code generation issues, while others are inherent to the WebAssembly platform.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Web browsers have become the most popular platform for running user-facing applications, and until recently, JavaScript was the only programming language supported by all major web browsers. Beyond its many quirks and pitfalls from the perspective of programming language design, JavaScript is also notoriously difficult to compile efficiently <ref type="bibr" target="#b9">[12,</ref><ref type="bibr" target="#b14">17,</ref><ref type="bibr" target="#b27">30,</ref><ref type="bibr" target="#b28">31]</ref>. Applications written in or compiled to JavaScript typically run much slower than their native counterparts. To address this situation, a group of browser vendors jointly developed WebAssembly.</p><p>WebAssembly is a low-level, statically typed language that does not require garbage collection, and supports interoperability with JavaScript. The goal of WebAssembly is to serve as a universal compiler target that can run in a browser <ref type="bibr" target="#b12">[15,</ref><ref type="bibr" target="#b13">16,</ref><ref type="bibr" target="#b15">18]</ref>. 1 Towards this end, WebAssembly is designed to be fast to compile and run, to be portable across browsers and architectures, and to provide formal guarantees of type and memory safety. Prior attempts at running code at native speed in the browser <ref type="bibr" target="#b2">[4,</ref><ref type="bibr" target="#b10">13,</ref><ref type="bibr" target="#b11">14,</ref><ref type="bibr">38]</ref>, which we discuss in related work, do not satisfy all of these criteria.</p><p>WebAssembly is now supported by all major browsers <ref type="bibr" target="#b5">[8,</ref><ref type="bibr" target="#b31">34]</ref> and has been swiftly adopted by several programming languages. There are now backends for C, C++, C#, Go, and Rust <ref type="bibr" target="#b0">[1,</ref><ref type="bibr">2,</ref><ref type="bibr" target="#b21">24,</ref><ref type="bibr" target="#b35">39]</ref> that target WebAssembly. A curated list currently includes more than a dozen others <ref type="bibr" target="#b7">[10]</ref>. Today, code written in these languages can be safely executed in browser sandboxes across any modern device once compiled to WebAssembly.</p><p>A major goal of WebAssembly is to be faster than JavaScript. For example, the paper that introduced WebAssembly <ref type="bibr" target="#b15">[18]</ref> showed that when a C program is compiled to WebAssembly instead of JavaScript (asm.js), it runs 34% faster in Google Chrome. That paper also showed that the performance of WebAssembly is competitive with native code: of the 24 benchmarks evaluated, the running time of seven benchmarks using WebAssembly is within 10% of native code, and almost all of them are less than 2× slower than native code. <ref type="figure" target="#fig_0">Figure 1</ref> shows that WebAssembly implementations have continuously improved with respect to these benchmarks. In 2017, only seven benchmarks performed within 1.1× of native, but by 2019, this number increased to 13.</p><p>These results appear promising, but they beg the question: are these 24 benchmarks representative of WebAssembly's intended use cases?</p><p>The Challenge of Benchmarking WebAssembly The aforementioned suite of 24 benchmarks is the PolybenchC benchmark suite <ref type="bibr" target="#b3">[5]</ref>, which is designed to measure the effect of polyhedral loop optimizations in compilers. All the benchmarks in the suite are small scientific computing kernels rather than full applications (e.g., matrix multiplication and LU Decomposition); each is roughly 100 LOC. While WebAssembly is designed to accelerate scientific kernels on the Web, it is also explicitly designed for a much richer set of full applications.</p><p>The WebAssembly documentation highlights several intended use cases <ref type="bibr">[7]</ref>, including scientific kernels, image editing, video editing, image recognition, scientific visualization, simulations, programming language interpreters, virtual machines, and POSIX applications. Therefore, WebAssembly's strong performance on the scientific kernels in PolybenchC do not imply that it will perform well given a different kind of application.</p><p>We argue that a more comprehensive evaluation of WebAssembly should rely on an established benchmark suite of large programs, such as the SPEC CPU benchmark suites. In fact, the SPEC CPU 2006 and 2017 suite of benchmarks include several applications that fall under the intended use cases of WebAssembly: eight benchmarks are scientific applications (e.g., <ref type="bibr">433.milc, 444.namd, 447.dealII, 450.soplex, and 470.lbm)</ref>, two benchmarks involve image and video processing <ref type="bibr">(464.h264ref and 453.povray)</ref>, and all of the benchmarks are POSIX applications. Unfortunately, it is not possible to simply compile a sophisticated native program to WebAssembly. Native programs, including the programs in the SPEC CPU suites, require operating system services, such as a filesystem, synchronous I/O, and processes, which WebAssembly and the browser do not provide. The SPEC benchmarking harness itself requires a file system, a shell, the ability to spawn processes, and other Unix facilities. To overcome these limitations when porting native applications to the web, many programmers painstakingly modify their programs to avoid or mimic missing operating system services. Modifying well-known benchmarks, such as SPEC CPU, would not only be time consuming but would also pose a serious threat to validity.</p><p>The standard approach to running these applications today is to use Emscripten, a toolchain for compiling C and C++ to WebAssembly <ref type="bibr" target="#b35">[39]</ref>. Unfortunately, Emscripten only supports the most trivial system calls and does not scale up to largescale applications. For example, to enable applications to use synchronous I/O, the default Emscripten MEMFS filesystem loads the entire filesystem image into memory before the program begins executing. For SPEC, these files are too large to fit into memory.</p><p>A promising alternative is to use BROWSIX, a framework that enables running unmodified, full-featured Unix applications in the browser <ref type="bibr" target="#b25">[28,</ref><ref type="bibr" target="#b26">29]</ref>. BROWSIX implements a Unix-compatible kernel in JavaScript, with full support for processes, files, pipes, blocking I/O, and other Unix features. Moreover, it includes a C/C++ compiler (based on Emscripten) that allows programs to run in the browser unmodified. The BROWSIX case studies include complex applications, such as L A T E X, which runs entirely in the browser without any source code modifications. Unfortunately, BROWSIX is a JavaScript-only solution, since it was built before the release of WebAssembly. Moreover, BROWSIX suffers from high performance overhead, which would be a significant confounder while benchmarking. Using BROWSIX, it would be difficult to tease apart the poorly performing benchmarks from performance degradation introduced by BROWSIX.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions</head><p>• BROWSIX-WASM: We develop BROWSIX-WASM, a significant extension to and enhancement of BROWSIX that allows us to compile Unix programs to WebAssembly and run them in the browser with no modifications. In addition to integrating functional extensions, BROWSIX-WASM incorporates performance optimizations that drastically improve its performance, ensuring that CPU-intensive applications operate with virtually no overhead imposed by BROWSIX-WASM ( §2).</p><p>• BROWSIX-SPEC: We develop BROWSIX-SPEC, a harness that extends BROWSIX-WASM to allow automated collection of detailed timing and hardware on-chip performance counter information in order to perform detailed measurements of application performance ( §3).</p><p>• Performance Analysis of WebAssembly: Using BROWSIX-WASM and BROWSIX-SPEC, we conduct the first comprehensive performance analysis of WebAssembly using the SPEC CPU benchmark suite <ref type="bibr">(both 2006 and 2017)</ref>. This evaluation confirms that WebAssembly does run faster than JavaScript (on average 1.3× faster across SPEC CPU). However, contrary to prior work, we find a substantial gap between WebAssembly and native performance: code compiled to WebAssembly runs on average 1.55× slower in Chrome and 1.45× slower in Firefox than native code ( §4).</p><p>• Root Cause Analysis and Advice for Implementers:</p><p>We conduct a forensic analysis with the aid of performance counter results to identify the root causes of this performance gap. We find the following results:</p><p>1. The instructions produced by WebAssembly have more loads and stores than native code (2.02× more loads and 2.30× more stores in Chrome;</p><p>1.92× more loads and 2.16× more stores in Firefox). We attribute this to reduced availability of registers, a sub-optimal register allocator, and a failure to effectively exploit a wider range of x86 addressing modes.</p><p>2. The instructions produced by WebAssembly have more branches, because WebAssembly requires several dynamic safety checks.</p><p>3. Since WebAssembly generates more instructions, it leads to more L1 instruction cache misses.</p><p>We provide guidance to help WebAssembly implementers focus their optimization efforts in order to close the performance gap between WebAssembly and native code ( §5, 6).</p><p>BROWSIX-WASM and BROWSIX-SPEC are available at https://browsix.org.</p><p>2 From BROWSIX to BROWSIX-WASM BROWSIX <ref type="bibr" target="#b26">[29]</ref> mimics a Unix kernel within the browser and includes a compiler (based on Emscripten <ref type="bibr" target="#b30">[33,</ref><ref type="bibr" target="#b35">39]</ref>) that compiles native programs to JavaScript. Together, they allow native programs (in C, C++, and Go) to run in the browser and freely use operating system services, such as pipes, processes, and a filesystem. However, BROWSIX has two major limitations that we must overcome. First, BROWSIX compiles native code to JavaScript and not WebAssembly. Second, the BROWSIX kernel has significant performance issues. In particular, several common system calls have very high overhead in BROWSIX, which makes it hard to compare the performance of a program running in BROWSIX to that of a program running natively. We address these limitations by building a new in-browser kernel called BROWSIX-WASM, which supports WebAssembly programs and eliminates the performance bottlenecks of BROWSIX.</p><p>Emscripten Runtime Modifications BROWSIX modifies the Emscripten compiler to allow processes (which run in WebWorkers) to communicate with the BROWSIX kernel (which runs on the main thread of a page). Since BROWSIX compiles native programs to JavaScript, this is relatively straightforward: each process' memory is a buffer that is shared with the kernel (a SharedArrayBuffer), thus system calls can directly read and write process memory. However, this approach has two significant drawbacks. First, it precludes growing the heap on-demand; the shared memory must be sized large enough to meet the high-water-mark heap size of the application for the entire life of the process. Second, JavaScript contexts (like the main context and each web worker context) have a fixed limit on their heap sizes, which is currently approximately 2.2 GB in Google Chrome <ref type="bibr" target="#b4">[6]</ref>. This cap imposes a serious limitation on running multiple processes: if each process reserves a 500 MB heap, BROWSIX would only be able to run at most four concurrent processes. A deeper problem is that WebAssembly memory cannot be shared across WebWorkers and does not support the Atomic API, which BROWSIX processes use to wait for system calls. BROWSIX-WASM uses a different approach to processkernel communication that is also faster than the BROWSIX approach. BROWSIX-WASM modifies the Emscripten runtime system to create an auxiliary buffer (of 64MB) for each process that is shared with the kernel, but is distinct from process memory. Since this auxiliary buffer is a SharedArrayBuffer the BROWSIX-WASM process and kernel can use Atomic API for communication. When a system call references strings or buffers in the process's heap (e.g., writev or stat), its runtime system copies data from the process memory to the shared buffer and sends a message to the kernel with locations of the copied data in auxiliary memory. Similarly, when a system call writes data to the auxiliary buffer (e.g., read), its runtime system copies the data from the shared buffer to the process memory at the memory specified. Moreover, if a system call specifies a buffer in process memory for the kernel to write to (e.g., read), the runtime allocates a corresponding buffer in auxiliary memory and passes it to the kernel. In case the system call is either reading or writing data of size more than 64MB, BROWSIX-WASM divides this call into several calls such that each call only reads or writes at maximum 64MB of data. The cost of these memory copy operations is dwarfed by the overall cost of the system call invocation, which involves sending a message between process and kernel JavaScript contexts. We show in §4.2.1 that BROWSIX-WASM has negligible overhead.</p><p>Performance Optimization While building BROWSIX-WASM and doing our preliminary performance evaluation, we discovered several performance issues in parts of the BROWSIX kernel. Left unresolved, these performance issues would be a threat to the validity of a performance comparison between WebAssembly and native code. The most serious case was in the shared filesystem component included with BROWSIX/BROWSIX-WASM, BROWSERFS. Originally, on each append operation on a file, BROWSERFS would allocate a new, larger buffer, copying the previous and new contents into the new buffer. Small appends could impose substantial performance degradation. Now, whenever a buffer backing a file requires additional space, BROWSERFS grows the buffer by at least 4 KB. This change alone decreased the time the 464.h264ref benchmark spent in BROWSIX from 25 seconds to under 1.5 seconds. We made a series of improvements that reduce overhead throughout BROWSIX-WASM. Similar, if less dramatic, improvements were made to reduce the number of allocations and the amount of copying in the kernel implementation of pipes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">BROWSIX-SPEC</head><p>To reliably execute WebAssembly benchmarks while capturing performance counter data, we developed BROWSIX-SPEC. BROWSIX-SPEC works with BROWSIX-WASM to manage spawning browser instances, serving benchmark assets (e.g., the compiled WebAssembly programs and test inputs), spawning perf processes to record performance counter data, and validating benchmark outputs.</p><p>We use BROWSIX-SPEC to run three benchmark suites to evaluate WebAssembly's performance: SPEC CPU2006, SPEC CPU2017, and PolyBenchC. These benchmarks are compiled to native code using Clang 4.0, and WebAssembly using BROWSIX-WASM. We made no modifications to Chrome or Firefox, and the browsers are run with their standard sandboxing and isolation features enabled. BROWSIX-WASM is built on top of standard web platform features and requires no direct access to host resources -instead, benchmarks make standard HTTP requests to BROWSIX-SPEC.  <ref type="formula">(5)</ref> The benchmark harness finds the Chrome thread corresponding to the Web Worker 401.bzip2 process and attaches perf to the process. <ref type="formula">(6)</ref> At the end of the benchmark, the BROWSIX-WASM userspace runtime does a final XHR to the benchmark harness to end the perf record process. When the runspec program exits (after potentially invoking the test binary several times), the harness JS POSTs (7) a tar archive of the SPEC results directory to BROWSIX-SPEC. After BROWSIX-SPEC receives the full results archive, it unpacks the results to a temporary directory and validates the output using the cmp tool provided with SPEC 2006. Finally, BROWSIX-SPEC kills the browser process and records the benchmark results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">BROWSIX-SPEC Benchmark Execution</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Evaluation</head><p>We use BROWSIX-WASM and BROWSIX-SPEC to evaluate the performance of WebAssembly using three benchmark The execution time measured is the difference between wall clock time when the program starts, i.e. after WebAssembly JIT compilation concludes, and when the program ends.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">PolyBenchC Benchmarks</head><p>Haas et al. <ref type="bibr" target="#b15">[18]</ref> used PolybenchC to benchmark WebAssembly implementations because the PolybenchC benchmarks do not make system calls. As we have already argued, the PolybenchC benchmarks are small scientific kernels that are typically used to benchmark polyhedral optimization techniques, and do not represent larger applications. Nevertheless, it is still valuable for us to run PolybenchC with BROWSIX-WASM, because it demonstrates that our infrastructure for system calls does not have any overhead. <ref type="figure" target="#fig_3">Figure 3a</ref> shows the execution time of the PolyBenchC benchmarks in BROWSIX-WASM and when run natively. We are able to reproduce the majority of the results from the original WebAssembly paper <ref type="bibr" target="#b15">[18]</ref>. We find that BROWSIX-WASM imposes a very low overhead: an average of 0.2% and a maximum of 1.2%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">SPEC Benchmarks</head><p>We now evaluate BROWSIX-WASM using the C/C++ benchmarks from SPEC CPU2006 and SPEC CPU2017 (the new C/C++ benchmarks and the speed benchmarks), which use system calls extensively. We exclude four data points that either do not compile to WebAssembly 5 or allocate more memory than WebAssembly allows. 6 <ref type="table" target="#tab_1">Table 1</ref> shows the absolute execution times of the SPEC benchmarks when running with BROWSIX-WASM in both Chrome and Firefox, and when running natively. WebAssembly performs worse than native for all benchmarks except for 429.mcf and 433.milc. In Chrome, WebAssembly's maximum overhead is 2.5× over native and 7 out of 15 benchmarks have a running time within 1.5× of native. In Firefox, WebAssembly is within 2.08× of native and performs within 1.5× of native for 7 out of 15 benchmarks. On average, WebAssembly is 1.55× slower than native in Chrome, and 1.45× slower than native in Firefox.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">BROWSIX-WASM Overhead</head><p>It is important to rule out the possibility that the slowdown that we report is due to poor performance in our implementation of BROWSIX-WASM. In particular, BROWSIX-WASM implements system calls without modifying the browser, and system calls involve copying data ( §2), which may be costly. To quantify the overhead of BROWSIX-WASM, we instrumented its system calls to measure all time spent in BROWSIX-WASM. <ref type="figure" target="#fig_5">Figure 4</ref> shows the percentage of time spent in BROWSIX-WASM in Firefox using the SPEC benchmarks. For 14 of the 15 benchmarks, the overhead is less than 0.5%.    </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Comparison of WebAssembly and asm.js</head><p>A key claim in the original work on WebAssembly was that it is significantly faster than asm.js. We now test that claim using the SPEC benchmarks. For this comparison, we modified BROWSIX-WASM to also support processes compiled to asm.js. The alternative would have been to benchmark the asm.js processes using the original BROWSIX. However, as we discussed earlier, BROWSIX has performance problems that would have been a threat to the validity of our results. <ref type="figure">Figure 5</ref> shows the speedup of the SPEC benchmarks using WebAssembly, relative to their running time using asm.js using both Chrome and Firefox. WebAssembly outperforms asm.js in both browsers: the mean speedup is 1.54× in Chrome and 1.39× in Firefox. Since the performance difference between Chrome and Firefox is substantial, in <ref type="figure">Figure 6</ref> we show the speedup of each benchmark by selecting the best-performing browser for WebAssembly and the best-performing browser of asm.js (i.e., they may be different browsers). These results show that WebAssembly consistently performs better than asm.js, with a mean speedup of 1.3×. Haas et al. <ref type="bibr" target="#b15">[18]</ref> also found that WebAssembly gives a mean speedup of 1.3× over asm.js using PolyBenchC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Case Study: Matrix Multiplication</head><p>In this section, we illustrate the performance differences between WebAssembly and native code using a C function that performs matrix multiplication, as shown in <ref type="figure" target="#fig_9">Figure 7a</ref>. Three matrices are provided as arguments to the function, and the results of A (N I × N K ) and B (N K × N J ) are stored in C (N I × N J ), where N I , N K , N J are constants defined in the program.</p><p>In WebAssembly, this function is 2×-3.4× slower than native in both Chrome and Firefox with a variety of matrix sizes <ref type="figure" target="#fig_10">(Figure 8)</ref>. We compiled the function with -O2 and disabled automatic vectorization, since WebAssembly does not support vectorized instructions. <ref type="figure" target="#fig_9">Figure 7b</ref> shows native code generated for the matmul function by clang-4.0. Arguments are passed to the function in the rdi, rsi, and rdx registers, as specified in the System V AMD64 ABI calling convention <ref type="bibr" target="#b6">[9]</ref>. Lines 2 -26 are the body of the first loop with iterator i stored in r8d. Lines 5 -21 contain the body of the second loop with iterator k stored in r9d. Lines 10 -16 comprise the body of the third loop with iterator j stored in rcx. Clang is able to eliminate a cmp instruction in the inner loop by initializing rcx with −N J , incrementing rcx on each iteration at line 15, and using jne to test the zero flag of the status register, which is set to 1 when rcx becomes 0. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Differences</head><p>The native code JITed by Chrome has more instructions, suffers from increased register pressure, and has extra branches compared to Clang-generated native code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Increased Code Size</head><p>The number of instructions in the code generated by Chrome <ref type="figure" target="#fig_9">(Figure 7c</ref>) is 53, including nops, while clang generated code <ref type="figure" target="#fig_9">(Figure 7b</ref>    perf Event Wasm Summary all-loads-retired (r81d0) <ref type="figure" target="#fig_13">(Figure 9a</ref>)</p><p>Increased register all-stores-retired (r82d0) <ref type="figure" target="#fig_13">(Figure 9b</ref>) pressure branches-retired (r00c4) <ref type="figure" target="#fig_13">(Figure 9c</ref>) More branch conditional-branches (r01c4) <ref type="figure" target="#fig_13">(Figure 9d</ref>) statements instructions-retired (r1c0) <ref type="figure" target="#fig_13">(Figure 9e</ref>   <ref type="table">Table 3</ref>: Performance counters highlight specific issues with WebAssembly code generation. When a raw PMU event descriptor is used, it is indicated by rn.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Increased Register Pressure</head><p>Code generated by Clang in <ref type="figure" target="#fig_9">Figure 7b</ref> does not generate any spills and uses only 10 registers. On the other hand, the code generated by Chrome <ref type="figure" target="#fig_9">(Figure 7c</ref>) uses 13 general purpose registers -all available registers (r13 and r10 are reserved by V8). As described in Section 5.1.1, eschewing the use of the register addressing mode of the add instruction requires the use of a temporary register. All of this register inefficiency compounds, introducing three register spills to the stack at lines 1-3. Values stored on the stack are loaded again into registers at lines 7-9 and line 18.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3">Extra Branches</head><p>Clang <ref type="figure" target="#fig_9">(Figure 7b</ref>) generates code with a single branch per loop by inverting the loop counter (line 15). In contrast, Chrome <ref type="figure" target="#fig_9">(Figure 7c</ref>) generates more straightforward code, which requires a conditional jump at the start of the loop. In addition, Chrome generates extra jumps to avoid memory loads due to register spills in the first iteration of a loop. For example, the jump at line 5 avoids the spills at lines 7-9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Performance Analysis</head><p>We use BROWSIX-SPEC to record measurements from all supported performance counters on our system for the SPEC CPU benchmarks compiled to WebAssembly and executed in Chrome and Firefox, and the SPEC CPU benchmarks compiled to native code (Section 3). <ref type="table">Table 3</ref> lists the performance counters we use here, along with a summary of the impact of BROWSIX-WASM performance on these counters compared to native. We use these results to explain the performance overhead of WebAssembly over native code. Our analysis shows that the inefficiences described in Section 5 are pervasive and translate to reduced performance across the SPEC CPU benchmark suite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Increased Register Pressure</head><p>This section focuses on two performance counters that show the effect of increased register pressure. <ref type="figure" target="#fig_13">Figure 9a</ref> presents the number of load instructions retired by WebAssemblycompiled SPEC benchmarks in Chrome and Firefox, relative to the number of load instructions retired in native code. Similarly, <ref type="figure" target="#fig_13">Figure 9b</ref> shows the number of store instructions retired. Note that a "retired" instruction is an instruction which leaves the instruction pipeline and its results are correct and visible in the architectural state (that is, not speculative).</p><p>Code generated by Chrome has 2.02× more load instructions retired and 2.30× more store instructions retired than native code. Code generated by Firefox has 1.92× more load instructions retired and 2.16× more store instructions retired than native code. These results show that the WebAssemblycompiled SPEC CPU benchmarks suffer from increased register pressure and thus increased memory references. Below, we outline the reasons for this increased register pressure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.1">Reserved Registers</head><p>In Chrome, matmul generates three register spills but does not use two x86-64 registers: r13 and r10 <ref type="figure" target="#fig_9">(Figure 7c, lines 7-9)</ref>. This occurs because Chrome reserves these two registers. <ref type="bibr">7</ref> For the JavaScript garbage collector, Chrome reserves r13 to point to an array of GC roots at all times. In addition, Chrome uses r10 and xmm13 as dedicated scratch registers. Similarly, Firefox reserves r15 as a pointer to the start of the heap, and r11 and xmm15 are JavaScript scratch registers. 8 None of these registers are available to WebAssembly code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.2">Poor Register Allocation</head><p>Beyond a reduced set of registers available to allocate, both Chrome and Firefox do a poor job of allocating the registers  <ref type="bibr" target="#b33">[36]</ref>, while Clang uses a greedy graph-coloring register allocator <ref type="bibr" target="#b1">[3]</ref>, which consistently generates better code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.3">x86 Addressing Modes</head><p>The x86-64 instruction set offers several addressing modes for each operand, including a register mode, where the instruction reads data from register or writes data to a register, and memory address modes like register indirect or direct offset addressing, where the operand resides in a memory address and the instruction can read from or write to that address. A code generator could avoid unnecessary register pressure by using the latter modes. However, Chrome does not take advantage of these modes. For example, the code generated by Chrome for matmul does not use the register indirect addressing mode for the add instruction (Section 5.1.2), creating unnecessary register pressure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Extra Branch Instructions</head><p>This section focuses on two performance counters that measure the number of branch instructions executed. <ref type="figure" target="#fig_13">Figure 9c</ref> shows the number of branch instructions retired by WebAssembly, relative to the number of branch instructions retired in native code. Similarly, <ref type="figure" target="#fig_13">Figure 9d</ref> shows the number of conditional branch instructions retired. In Chrome, there are 1.75× and 1.65× more unconditional and conditional branch instructions retired respectively, whereas in Firefox, there are 1.65× and 1.62× more retired. These results show that all the SPEC CPU benchmarks incur extra branches, and we explain why below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1">Extra Jump Statements for Loops</head><p>As with matmul (Section 5.1.3), Chrome generates unnecessary jump statements for loops, leading to significantly more branch instructions than Firefox.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.2">Stack Overflow Checks Per Function Call</head><p>A WebAssembly program tracks the current stack size with a global variable that it increases on every function call. The programmer can define the maximum stack size for the program. To ensure that a program does not overflow the stack, both Chrome and Firefox add stack checks at the start of each function to detect if the current stack size is less than the maximum stack size. These checks includes extra comparison and conditional jump instructions, which must be executed on every function call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.3">Function Table Indexing Checks</head><p>WebAssembly dynamically checks all indirect calls to ensure that the target is a valid function and that the function's type at runtime is the same as the type specified at the call site. In a WebAssembly module, the function table stores the list of functions and their types, and the code generated by WebAssembly uses the function table to implement these checks. These checks are required when calling function pointers and virtual functions in C/C++. The checks lead to extra comparison and conditional jump instructions, which are executed before every indirect function call.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Increased Code Size</head><p>The code generated by Chrome and Firefox is considerably larger than the code generated by Clang. We use three performance counters to measure this effect. (i) <ref type="figure" target="#fig_13">Figure 9e</ref> shows the number of instructions retired by benchmarks compiled to WebAssembly and executed in Chrome and Firefox relative to the number of instructions retired in native code. Similarly, <ref type="figure" target="#fig_13">Figure 9f</ref> shows the relative number of CPU cycles spent by benchmarks compiled to WebAssembly, and <ref type="figure" target="#fig_0">Figure 10</ref> shows the relative number of L1 instruction cache load misses. <ref type="figure" target="#fig_13">Figure 9e</ref> shows that Chrome executes an average of 1.80× more instructions than native code and Firefox executes an average of 1.75× more instructions than native code. Due to poor instruction selection, a poor register allocator generating more register spills (Section 6.1), and extra branch statements (Section 6.2), the size of generated code for WebAssembly is greater than native code, leading to more instructions being executed. This increase in the number of instructions executed leads to increased L1 instruction cache misses in <ref type="figure" target="#fig_0">Figure 10</ref>. On average, Chrome suffers 2.83× more I-cache misses than native code, and Firefox suffers from 2.04× more L1 instruction cache misses than native code. More cache misses means that more CPU cycles are spent waiting for the instruction to be fetched.</p><p>We note one anomaly: although 429.mcf has 1.6× more instructions retired in Chrome than native code and 1.5× more instructions retired in Firefox than native code, it runs faster than native code. <ref type="figure" target="#fig_3">Figure 3b</ref> shows that its slowdown relative to native is 0.81× in Chrome and 0.83× in Firefox. The reason for this anomaly is attributable directly to its lower number of L1 instruction cache misses. 429.mcf contains a main loop and most of the instructions in the loop fit in the L1 instruction cache. Similarly, 433.milc performance is better due to fewer L1 instruction cache misses. In 450.soplex   <ref type="table">Table 4</ref>: The geomean of performance counter increases for the SPEC benchmarks using WebAssembly.</p><p>there are 4.6× more L1 instruction cache misses in Chrome and Firefox than native because of several virtual functions being executed, leading to more indirect function calls.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Discussion</head><p>It is worth asking if the performance issues identified here are fundamental. We believe that two of the identified issues are not: that is, they could be ameliorated by improved implementations. WebAssembly implementations today use register allocators ( §6.1.2) and code generators ( §6.2.1) that perform worse than Clang's counterparts. However, an offline compiler like Clang can spend considerably more time to generate better code, whereas WebAssembly compilers must be fast enough to run online. Therefore, solutions adopted by other JITs, such as further optimizing hot code, are likely applicable here <ref type="bibr" target="#b16">[19,</ref><ref type="bibr" target="#b29">32]</ref>. The four other issues that we have identified appear to arise from the design constraints of WebAssembly: the stack overflow checks ( §6.2.2), indirect call checks ( §6.2.3), and reserved registers ( §6.1.1) have a runtime cost and lead to increased code size ( §6.3). Unfortunately, these checks are necessary for WebAssembly's safety guarantees. A redesigned WebAssembly, with richer types for memory and function pointers <ref type="bibr" target="#b20">[23]</ref>, might be able to perform some of these checks at compile time, but that could complicate the implementation of compilers that produce WebAssembly. Finally, a WebAssembly implementation in a browser must interoperate with a high-performance JavaScript implementation, which may impose its own constraints. For example, current JavaScript implementations reserve a few registers for their own use, which increases register pressure on WebAssembly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Precursors to WebAssembly There have been several attempts to execute native code in browsers, but none of them met all the design criteria of WebAssembly. ActiveX <ref type="bibr" target="#b10">[13]</ref> allows web pages to embed signed x86 libraries, however these binaries have unrestricted access to the Windows API. In contrast, WebAssembly modules are sandboxed. ActiveX is now a deprecated technology.</p><p>Native Client <ref type="bibr" target="#b8">[11,</ref><ref type="bibr" target="#b34">37]</ref> (NaCl) adds a module to a web application that contains platform specific machine code. NaCl introduced sandboxing techniques to execute platform specific machine code at near native speed. Since NaCl relies on static validation of machine code, it requires code generators to follow certain patterns, hence, supporting only a subset of the x86, ARM, and MIPS instructions sets in the browser. To address the inherent portability issue of NaCl, Portable NaCl (PNaCl) <ref type="bibr" target="#b11">[14]</ref> uses LLVM Bitcode as a binary format. However, PNaCl does not provide significant improvement in compactness over NaCl and still exposes compiler and/or platform-specific details such as the call stack layout. Both have been deprecated in favor of WebAssembly.</p><p>asm.js is a subset of JavaScript designed to be compiled efficiently to native code. asm.js uses type coercions to avoid the dynamic type system of JavaScript. Since asm.js is a subset of JavaScript, adding all native features to asm.js such as 64-bit integers will first require extending JavaScript. Compared to asm.js, WebAssembly provides several improvements: (i) WebAssembly binaries are compact due to its lightweight representation compared to JavaScript source, (ii) WebAssembly is more straightforward to validate, (iii) WebAssembly provides formal guarantees of type safety and isolation, and (iv) WebAssembly has been shown to provide better performance than asm.js.</p><p>WebAssembly is a stack machine, which is similar to the Java Virtual Machine <ref type="bibr" target="#b18">[21]</ref> and the Common Language Runtime <ref type="bibr" target="#b22">[25]</ref>. However, WebAssembly is very different from these platforms. For example WebAssembly does not support objects and does not support unstructured control flow.</p><p>The WebAssembly specification defines its operational semantics and type system. This proof was mechanized using the Isabelle theorem prover, and that mechanization effort found and addressed a number of issues in the specification <ref type="bibr" target="#b32">[35]</ref>. RockSalt <ref type="bibr" target="#b19">[22]</ref> is a similar verification effort for NaCl. It implements the NaCl verification toolchain in Coq, along with a proof of correctness with respect to a model of the subset of x86 instructions that NaCl supports.</p><p>Analysis of SPEC Benchmarks using performance counters Several papers use performance counters to analyze the SPEC benchmarks. <ref type="bibr">Panda et al. [26]</ref> analyze the SPEC CPU2017 benchmarks, applying statistical techniques to identify similarities among benchmarks. Phansalkar et al. perform a similar study on SPEC CPU2006 <ref type="bibr" target="#b24">[27]</ref>. Limaye and Adegija identify workload differences between SPEC CPU2006 and SPEC CPU2017 <ref type="bibr" target="#b17">[20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>This paper performs the first comprehensive performance analysis of WebAssembly. We develop BROWSIX-WASM, a significant extension of BROWSIX, and BROWSIX-SPEC, a harness that enables detailed performance analysis, to let us run the SPEC CPU2006 and CPU2017 benchmarks as WebAssembly in Chrome and Firefox. We find that the mean slowdown of WebAssembly vs. native across SPEC benchmarks is 1.55× for Chrome and 1.45× for Firefox, with peak slowdowns of 2.5× in Chrome and 2.08× in Firefox. We identify the causes of these performance gaps, providing actionable guidance for future optimization efforts.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Number of PolyBenchC benchmarks performing within x× of native. In 2017 [18], seven benchmarks performed within 1.1× of native. In April 2018, we found that 11 performed within 1.1× of native. In May 2019, 13 performed with 1.1× of native.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The framework for running SPEC benchmarks in browsers. Bold components are new or heavily modified ( §3).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 illustrates</head><label>2</label><figDesc>Figure 2 illustrates the key pieces of BROWSIX-SPEC in play when running a benchmark, such as 401.bzip2 in Chrome. First (1), the BROWSIX-SPEC benchmark harness launches a new browser instance using a WebBrowser automation tool, Selenium. 2 (2) The browser loads the page's HTML, harness JS, and BROWSIX-WASM kernel JS over HTTP from the benchmark harness. (3) The harness JS initializes the BROWSIX-WASM kernel and starts a new BROWSIX-WASM process executing the runspec shell script (not shown in Figure 2). runspec in turn spawns the standard specinvoke (not shown), compiled from the C sources provided in SPEC 2006. specinvoke reads the speccmds.cmd file from the BROWSIX-WASM filesystem and starts 401.bzip2 with the appropriate arguments. (4) After the WebAssembly module has been instantiated but before the benchmark's main function is invoked, the BROWSIX-WASM userspace runtime does an XHR request to BROWSIX-SPEC to begin recording performance counter stats. (5) The benchmark harness finds the Chrome thread corresponding to the Web Worker 401.bzip2 process and attaches perf to the process. (6) At the end of the benchmark, the BROWSIX-WASM userspace runtime does a final XHR to the benchmark harness to end the perf record process. When the runspec program exits (after potentially invoking the test binary several times), the harness JS POSTs (7) a tar archive of the SPEC results directory to BROWSIX-SPEC. After BROWSIX-SPEC receives the full results archive, it unpacks the results to a temporary directory and validates the output using the cmp tool provided with SPEC 2006. Finally, BROWSIX-SPEC kills the browser process and records the benchmark results.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The performance of the PolyBenchC and the SPEC CPU benchmarks compiled to WebAssembly (executed in Chrome and Firefox) relative to native, using BROWSIX-WASM and BROWSIX-SPEC. The SPEC CPU benchmarks exhibit higher overhead overall than the PolyBenchC suite, indicating a significant performance gap exists between WebAssembly and native. suites: SPEC CPU2006, SPEC CPU2017, and PolyBenchC. We include PolybenchC benchmarks for comparison with the original WebAssembly paper [18], but argue that these benchmarks do not represent typical workloads. The SPEC benchmarks are representative and require BROWSIX-WASM to run successfully. We run all benchmarks on a 6-Core Intel Xeon E5-1650 v3 CPU with hyperthreading and 64 GB of RAM running Ubuntu 16.04 with Linux kernel v4.4.0. We run all benchmarks using two state-of-the-art browsers: Google Chrome 74.0 and Mozilla Firefox 66.0. We compile benchmarks to native code using Clang 4.0 3 and to WebAssembly using BROWSIX-WASM (which is based on Emscripten with Clang 4.0). 4 Each benchmark was executed five times. We report the average of all running times and the standard error. The execution time measured is the difference between wall clock time when the program starts, i.e. after WebAssembly JIT compilation concludes, and when the program ends.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Time spent (in %) in BROWSIX-WASM calls in Firefox for SPEC benchmarks compiled to WebAssembly. BROWSIX-WASM imposes a mean overhead of only 0.2%.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :Figure 6 :</head><label>56</label><figDesc>Figure 5: Relative time of asm.js to WebAssembly for Chrome and Firefox. WebAssembly is 1.54× faster than asm.js in Chrome and 1.39× faster than asm.js in Firefox.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Figure 7c shows x86-64 code JITed by Chrome for the WebAssembly compiled version of matmul. This code has been modified slightly -nops in the generated code have been removed for presentation. Function arguments are passed in the rax, rcx, and rdx registers, following Chrome's calling convention. At lines 1-3, the contents of registers rax, rdx, and rcx are stored on the stack, due to registers spills at lines 7 -9. Lines 7-45 are the body of the first loop with iterator i stored in edi. Lines 18-42 contain the body of second loop with iterator k stored in r11. Lines 27-39 are the body of the third loop with iterator j stored in eax. To avoid memory loads due to register spilling at lines 7-9 in the first iteration of the first loop, an extra jump is generated at line 5. Similarly, extra jumps are generated for the second and third loops at line 16 and line 25 respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>) consists of only 28 instructions. The poor instruc- tion selection algorithm of Chrome is one of the reasons for increased code size. Additionally, Chrome does not take advantage of all avail- able memory addressing modes for x86 instructions. In Fig- ure 7b Clang uses the add instruction at line 14 with register addressing mode, loading from and writing to a memory ad- dress in the same operation. Chrome on the other hand loads 1 void matmul (int C[NI][NJ],</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Native code for matmul is shorter, has less register pressure, and fewer branches than the code JITed by Chrome. §6 shows that these inefficiencies are pervasive, reducing performance across the SPEC CPU benchmark suites.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Performance of WebAssembly in Chrome and Firefox for different matrix sizes relative to native code. WebAssembly is always between 2× to 3.4× slower than native.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>) Increased code size cpu-cycles (Figure 9f</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>)</head><label></label><figDesc>L1-icache-load-misses (Figure 10)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Processor performance counter samples for WebAssembly relative to native code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: L1-icache-load-misses samples counted for SPEC CPU compiled to WebAssembly executed in Chrome and Firefox, relative to native. 458.sjeng not shown in the graph exhibits 26.5× more L1 instruction cache misses in Chrome and 18.6× more in Firefox. The increased code size generated for WebAssembly leads to more instruction cache misses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 2 shows the time required to compile the SPEC benchmarks</head><label>2</label><figDesc></figDesc><table>Benchmark 

Native 

Google 
Chrome 

Mozilla 
Firefox 

401.bzip2 
370 ± 0.6 
864 ± 6.4 
730 ± 1.3 
429.mcf 
221 ± 0.1 
180 ± 0.9 
184 ± 0.6 
433.milc 
375 ± 2.6 
369 ± 0.5 
378 ± 0.6 
444.namd 
271 ± 0.8 
369 ± 9.1 
373 ± 1.8 
445.gobmk 
352 ± 2.1 
537 ± 0.8 
549 ± 3.3 
450.soplex 
179 ± 3.7 
265 ± 1.2 
238 ± 0.5 
453.povray 
110 ± 1.9 
275 ± 1.3 
229 ± 1.5 
458.sjeng 
358 ± 1.4 
602 ± 2.5 
580 ± 2.0 
462.libquantum 
330 ± 0.8 
444 ± 0.2 
385 ± 0.8 
464.h264ref 
389 ± 0.7 807 ± 11.0 
733 ± 2.4 
470.lbm 
209 ± 1.1 
248 ± 0.3 
249 ± 0.5 
473.astar 
299 ± 0.5 
474 ± 3.5 
408 ± 1.0 
482.sphinx3 
381 ± 7.1 
834 ± 1.8 
713 ± 3.6 
641.leela_s 
466 ± 2.7 
825 ± 4.6 
717 ± 1.2 
644.nab_s 
2476 ± 11 3639 ± 5.6 3829 ± 6.7 
Slowdown: geomean 
-
1.55× 
1.45× 
Slowdown: median 
-
1.53× 
1.54× 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Detailed breakdown of SPEC CPU benchmarks exe-
cution times (of 5 runs) for native (Clang) and WebAssembly 
(Chrome and Firefox); all times are in seconds. The median 
slowdown of WebAssembly is 1.53× for Chrome and 1.54× 
for Firefox. 

using Clang and Chrome. (To the best of our knowledge, Fire-
fox cannot report WebAssembly compile times.) In all cases, 
the compilation time is negligible compared to the execution 
time. However, the Clang compiler is orders of magnitude 
slower than the WebAssembly compiler. Finally, note that 
Clang compiles benchmarks from C++ source code, whereas 
Chrome compiles WebAssembly, which is a simpler format 
than C++. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Compilation times of SPEC CPU benchmarks (aver-
age of 5 runs) for Clang 4.0 and WebAssembly (Chrome); all 
times are in seconds. 

</table></figure>

			<note place="foot" n="1"> The WebAssembly standard is undergoing active development, with ongoing efforts to extend WebAssembly with features ranging from SIMD primitives and threading to tail calls and garbage collection. This paper focuses on the initial and stable version of WebAssembly [18], which is supported by all major browsers.</note>

			<note place="foot" n="2"> https://www.seleniumhq.org/</note>

			<note place="foot" n="3"> The flags to Clang are -O2 -fno-strict-aliasing. 4 BROWSIX-WASM runs Emscripten with the flags -O2 -s TOTAL_MEMORY=1073741824 -s ALLOW_MEMORY_GROWTH=1 -fno-strict-aliasing.</note>

			<note place="foot" n="5"> 400.perlbench, 403.gcc, 471.omnetpp, and 456.hmmer from SPEC CPU2006 do not compile with Emscripten. 6 From SPEC CPU2017, the ref dataset of 638.imagick_s and 657.xz_s require more than 4 GB RAM. However, these benchmarks do work with their test dataset.</note>

			<note place="foot" n="7"> https://github.com/v8/v8/blob/7.4.1/src/x64/ register-x64.h 8 https://hg.mozilla.org/mozilla-central/file/tip/js/src/ jit/x64/Assembler-x64.h</note>

			<note place="foot" n="118"> 2019 USENIX Annual Technical Conference USENIX Association</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Blazor</surname></persName>
		</author>
		<ptr target="https://blazor.net/" />
		<imprint>
			<date type="published" when="2019-01" />
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manual</forename><surname>Llvm Reference</surname></persName>
		</author>
		<ptr target="https://llvm.org/docs/CodeGenerator.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pnacl</forename><surname>Nacl</surname></persName>
		</author>
		<ptr target="https://developer.chrome.com/native-client/nacl-and-pnacl" />
		<imprint>
			<date type="published" when="2019-01" />
		</imprint>
	</monogr>
	<note>Online; accessed 5</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">PolyBenchC: the polyhedral benchmark suite</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<ptr target="https://stackoverflow.com/questions/43643406/raise-chrome-js-heap-limit" />
		<title level="m">Raise Chrome JS heap limit? -Stack Overflow</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Online</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Webassembly</surname></persName>
		</author>
		<ptr target="https://webassembly.org/." />
		<imprint>
			<date type="published" when="2019-01" />
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">System V Application Binary Interface AMD64 Architecture Processor Supplement</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">A curated list of languages that compile directly to or have their VMs in Web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Akinyemi</surname></persName>
		</author>
		<ptr target="https://github.com/appcypher/awesome-wasm-langs" />
		<imprint>
			<date type="published" when="2019-01" />
		</imprint>
	</monogr>
	<note>Online; accessed 5</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Language-independent Sandboxing of Just-in-time Compilation and Self-modifying Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Ansel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Petr</forename><surname>Marchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Úlfar</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elijah</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brad</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Derek</forename><forename type="middle">L</forename><surname>Schuff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Sehr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cliff</forename><forename type="middle">L</forename><surname>Biffle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bennet</forename><surname>Yee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;11</title>
		<meeting>the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;11</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="355" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">SPUR: A Trace-based JIT Compiler for CIL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Bebenita</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Florian</forename><surname>Brandner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Fahndrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francesco</forename><surname>Logozzo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfram</forename><surname>Schulte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikolai</forename><surname>Tillmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herman</forename><surname>Venter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications, OOPSLA &apos;10</title>
		<meeting>the ACM International Conference on Object Oriented Programming Systems Languages and Applications, OOPSLA &apos;10</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="708" to="725" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Understanding ActiveX and OLE</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Chappell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Microsoft Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">PNaCl: Portable Native Client Executables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alan</forename><surname>Donovan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brad</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Sehr</surname></persName>
		</author>
		<ptr target="https://css.csail.mit.edu/6.858/2012/readings/pnacl.pdf" />
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
		<ptr target="https://brendaneich.com/2015/06/from-asm-js-to-webassembly/" />
	</analytic>
	<monogr>
		<title level="j">Brendan Eich. From ASM.JS to WebAssembly</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">What is WebAssembly?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Elliott</surname></persName>
		</author>
		<ptr target="https://tinyurl.com/o5h6daj" />
		<imprint>
			<date type="published" when="2015-01" />
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Trace-based Just-in-time Type Specialization for Dynamic Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Gal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brendan</forename><surname>Eich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Shaver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Mandelin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohammad</forename><forename type="middle">R</forename><surname>Haghighat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Blake</forename><surname>Kaplan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graydon</forename><surname>Hoare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boris</forename><surname>Zbarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Orendorff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jesse</forename><surname>Ruderman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edwin</forename><forename type="middle">W</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rick</forename><surname>Reitmaier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Bebenita</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mason</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Franz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;09</title>
		<meeting>the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;09</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="465" to="478" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Bringing the Web Up to Speed with WebAssembly</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Rossberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Derek</forename><forename type="middle">L</forename><surname>Schuff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><forename type="middle">L</forename><surname>Titzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Holman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Gohman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alon</forename><surname>Zakai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Bastien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="185" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Design of the Java HotSpot Client Compiler for Java 6</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Kotzmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hanspeter</forename><surname>Mössenböck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Rodriguez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><surname>Russell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Cox</surname></persName>
		</author>
		<idno>7:1-7:32</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Archit. Code Optim</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Workload Characterization of the SPEC CPU2017 Benchmark Suite</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ankur</forename><surname>Limaye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tosiron</forename><surname>Adegbija</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="149" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">The Java Virtual Machine Specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Lindholm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Yellin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gilad</forename><surname>Bracha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Buckley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<publisher>Addison-Wesley Professional</publisher>
			<pubPlace>Java SE 8 Edition</pubPlace>
		</imprint>
	</monogr>
	<note>1st edition</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">RockSalt: Better, Faster, Stronger SFI for the x86</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Morrisett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gang</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Tassarotti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeanbaptiste</forename><surname>Tristan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><surname>Gan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;12</title>
		<meeting>the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;12</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="395" to="404" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">From System F to Typed Assembly Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Morrisett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Walker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><surname>Crary</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neal</forename><surname>Glew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="527" to="568" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">A compiler from Go to JavaScript for running</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Musiol</surname></persName>
		</author>
		<ptr target="https://github.com/gopherjs/gopherjs" />
		<imprint>
			<date type="published" when="2016-01" />
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">CIL: Intermediate Language and Tools for Analysis and Transformation of C Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Mcpeak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shree</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Westley</forename><surname>Rahul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Compiler Construction</title>
		<editor>R. Nigel Horspool</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="213" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Wait of a Decade: Did SPEC CPU 2017 Broaden the Performance Horizon?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reena</forename><surname>Panda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shuang</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lizy</forename><forename type="middle">K</forename><surname>John</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="271" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Analysis of Redundancy and Application Balance in the SPEC CPU2006 Benchmark Suite</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aashish</forename><surname>Phansalkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ajay</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lizy</forename><forename type="middle">K</forename><surname>John</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual International Symposium on Computer Architecture, ISCA &apos;07</title>
		<meeting>the 34th Annual International Symposium on Computer Architecture, ISCA &apos;07</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="412" to="423" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bobby</forename><surname>Powers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Vilk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emery</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Browsix</surname></persName>
		</author>
		<ptr target="https://browsix.org" />
		<title level="m">Unix in your browser tab</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Browsix: Bridging the Gap Between Unix and the Browser</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bobby</forename><surname>Powers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Vilk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emery</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS &apos;17</title>
		<meeting>the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS &apos;17</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="253" to="266" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">An Analysis of the Dynamic Behavior of JavaScript Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregor</forename><surname>Richards</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sylvain</forename><surname>Lebresne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Burg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Vitek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;10</title>
		<meeting>the 31st ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;10</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Performance Issues and Optimizations in JavaScript: An Empirical Study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marija</forename><surname>Selakovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Pradel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th International Conference on Software Engineering, ICSE &apos;16</title>
		<meeting>the 38th International Conference on Software Engineering, ICSE &apos;16</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="61" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A Dynamic Optimization Framework for a Java Just-in-time Compiler</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Toshio</forename><surname>Suganuma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Toshiaki</forename><surname>Yasue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Motohiro</forename><surname>Kawahito</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hideaki</forename><surname>Komatsu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Toshio</forename><surname>Nakatani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM SIGPLAN Conference on Object-oriented Programming, Systems, Languages, and Applications, OOPSLA &apos;01</title>
		<meeting>the 16th ACM SIGPLAN Conference on Object-oriented Programming, Systems, Languages, and Applications, OOPSLA &apos;01</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="180" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Wagner</surname></persName>
		</author>
		<ptr target="https://blog.mozilla.org/luke/2013/03/21/asm-js-in-firefox-nightly/.[Online;ac-cessed21" />
		<title level="m">asm.js in Firefox Nightly | Luke Wagner&apos;s Blog</title>
		<imprint>
			<date type="published" when="2019-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Experimental Support in Multiple Browsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">. A Webassembly</forename><surname>Milestone</surname></persName>
		</author>
		<ptr target="https://hacks.mozilla.org/2016/03/a-webassembly-milestone/" />
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Mechanising and Verifying the WebAssembly Specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Conrad</forename><surname>Watt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</title>
		<meeting>the 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="53" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Linear Scan Register Allocation on SSA Form</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Franz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization, CGO &apos;10</title>
		<meeting>the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization, CGO &apos;10</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="170" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Native Client: A Sandbox for Portable, Untrusted x86 Native Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bennet</forename><surname>Yee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Sehr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Dardyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brad</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tavis</forename><surname>Ormandy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shiki</forename><surname>Okasaka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neha</forename><surname>Narula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Fullagar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<meeting><address><addrLine>Oakland&apos;09</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Emscripten: An LLVM-to-JavaScript Compiler</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alon</forename><surname>Zakai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference Companion on Object Oriented Programming Systems Languages and Applications Companion, OOP-SLA &apos;11</title>
		<meeting>the ACM International Conference Companion on Object Oriented Programming Systems Languages and Applications Companion, OOP-SLA &apos;11</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="301" to="312" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
