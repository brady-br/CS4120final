<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:19+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">HeavyKeeper: An Accurate Algorithm for Finding Top-k Elephant Flows HeavyKeeper: An Accurate Algorithm for Finding Top-k Elephant Flows</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>July 11-13. 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junzhi</forename><surname>Gong</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tong</forename><surname>Yang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haowei</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hao</forename><surname>Li</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junzhi</forename><surname>Gong</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tong</forename><surname>Yang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haowei</forename><surname>Zhang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hao</forename><surname>Li</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Uhlig</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shigang</forename><surname>Chen</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lorna</forename><surname>Uden</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaoming</forename><surname>Li</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Peking University</orgName>
								<address>
									<addrLine>Steve Uhlig</addrLine>
									<region>Queen Mary</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Shigang Chen</orgName>
								<orgName type="department" key="dep2">UK &amp; Queen Mary</orgName>
								<orgName type="laboratory">Xiaoming Li</orgName>
								<orgName type="institution" key="instit1">University of London</orgName>
								<orgName type="institution" key="instit2">University of Florida</orgName>
								<orgName type="institution" key="instit3">Lorna Uden</orgName>
								<orgName type="institution" key="instit4">Staffordshire University</orgName>
								<orgName type="institution" key="instit5">Peking University</orgName>
								<orgName type="institution" key="instit6">Peking University</orgName>
								<orgName type="institution" key="instit7">Peking University</orgName>
								<orgName type="institution" key="instit8">Peking University</orgName>
								<orgName type="institution" key="instit9">Peking University</orgName>
								<orgName type="institution" key="instit10">University of London</orgName>
								<orgName type="institution" key="instit11">University of Florida</orgName>
								<orgName type="institution" key="instit12">Staffordshire University</orgName>
								<orgName type="institution" key="instit13">Peking University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">HeavyKeeper: An Accurate Algorithm for Finding Top-k Elephant Flows HeavyKeeper: An Accurate Algorithm for Finding Top-k Elephant Flows</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2018 USENIX Annual Technical Conference (USENIX ATC &apos;18)</title>
						<meeting>the 2018 USENIX Annual Technical Conference (USENIX ATC &apos;18) <address><addrLine>Boston, MA, USA</addrLine></address>
						</meeting>
						<imprint>
							<date type="published">July 11-13. 2018</date>
						</imprint>
					</monogr>
					<note>Open access to the Proceedings of the 2018 USENIX Annual Technical Conference is sponsored by USENIX. This paper is included in the</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>1 Finding top-k elephant flows is a critical task in network traffic measurement, with many applications in congestion control, anomaly detection and traffic engineering. As the line rates keep increasing in today&apos;s networks, designing accurate and fast algorithms for online identification of elephant flows becomes more and more challenging. The prior algorithms are seriously limited in achieving accuracy under the constraints of heavy traffic and small on-chip memory in use. We observe that the basic strategies adopted by these algorithms either require significant space overhead to measure the sizes of all flows or incur significant inaccuracy when deciding which flows to keep track of. In this paper, we adopt a new strategy, called count-with-exponential-decay, to achieve space-accuracy balance by actively removing small flows through decaying, while minimizing the impact on large flows, so as to achieve high precision in finding top-k elephant flows. Moreover, the proposed algorithm called HeavyKeeper incurs small, constant processing overhead per packet and thus supports high line rates. Experimental results show that HeavyKeeper algorithm achieves 99.99% precision with a small memory size, and reduces the error by around 3 orders of magnitude on average compared to the state-of-the-art.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Background and Motivation</head><p>Finding the largest k flows, also referred to as the topk elephant flows, is a fundamental network management function, where a flow's ID is usually defined as a combination of certain packet header fields, such as source IP address, destination IP address, source port, destination port, and protocol type, and the size of a flow is defined as the number of packets of the flow. Elephant flows contribute a large portion of network traffic. Many management applications can benefit from a function that can find them efficiently, such as congestion control by dynamically scheduling elephant flows <ref type="bibr" target="#b0">[1]</ref>, network capacity planning <ref type="bibr" target="#b1">[2]</ref>, anomaly detection <ref type="bibr" target="#b2">[3]</ref>, and caching of forwarding table entries <ref type="bibr" target="#b3">[4]</ref>. Such a function also has applications beyond networking in areas such as data mining <ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref><ref type="bibr" target="#b6">[7]</ref>, information retrieval <ref type="bibr" target="#b7">[8]</ref>, databases <ref type="bibr" target="#b8">[9]</ref>, and security <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>In real network traffic, it is well known that the distribution of flow sizes (the number of packets in a flow), is highly skewed <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref>, i.e., the majority are mouse flows, while the minority are elephant flows. most flows are small while a few flows are very large. The small flows are usually called mouse flows, while the large ones are called elephant flows.</p><p>Finding the top-k elephant flows (or top-k flows for short) in high-speed networks is a challenging task. <ref type="bibr" target="#b21">[22]</ref> Extremely high line rates of modern networks make it practically impossible to accurately track the information of all flows. Consequently, approximate methods have been proposed in the literature and gained wide acceptance <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b22">[23]</ref><ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b24">[25]</ref><ref type="bibr" target="#b25">[26]</ref><ref type="bibr" target="#b26">[27]</ref>. In order to keep up with the line rates, these algorithms are expected to use on-chip memory such as SRAM whose latency is around 1ns <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b28">29]</ref>, in contrast to a latency of around 50ns when off-chip DRAM is used <ref type="bibr" target="#b28">[29]</ref>. However, on-chip memory is small. Adding to the challenge, it is highly desirable to keep per-packet processing overhead small and constant, which helps pipelining.</p><p>Traditional solutions to finding the top-k flows follow two basic strategies: count-all and admit-all-countsome. The count-all strategy relies on a sketch (e.g., CM sketch <ref type="bibr" target="#b13">[14]</ref>) to measure the sizes of all flows, while us-ing a min-heap to keep track of the top-k flows. For each incoming packet, it records the packet in the sketch and retrieves from the sketch an estimatê n i for the size of the flow f i that the packet belongs to. IfˆnIfˆ Ifˆn i is larger than the smallest flow size in the min-heap, it replaces the smallest flow in the heap by flow f i . As a large sketch is needed to count all flows, these solutions are not memory efficient.</p><p>The admit-all-count-some strategy is adopted by Frequent <ref type="bibr" target="#b29">[30]</ref>, Lossy Counting <ref type="bibr" target="#b25">[26]</ref>, Space-Saving <ref type="bibr" target="#b23">[24]</ref> and CSS <ref type="bibr" target="#b22">[23]</ref>. These algorithms are similar to each other. To save memory, Space-Saving only maintains a data structure called Stream-Summary to counts only some flows (m flows). Each new flow will be inserted into the summary, replacing the smallest existing flow. The initial size of the new flow is set asˆnasˆ asˆn min + 1, wherê n min is the size of the smallest flow in the summary. By keeping m flows in the summary, the algorithm will report the largest k flows among them, where m &gt; k. It assumes every new incoming flow is an elephant, and expels the smallest one in the summary to make room for the new one. But most flows are mouse flows. Such an assumption causes significant error, especially under tight memory (for a limited value of m).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Our Proposed Solution</head><p>In this paper, we propose a new algorithm, HeavyKeeper, based on a different strategy, called count-withexponential-decay, which keeps all elephant flows while drastically reducing space wasted on mouse flows. Unlike count-all, our strategy only keeps track of a small number of flows. Unlike admit-all-count-some, we do not automatically admit new flows into our data structure and the vast majority of mouse flows will be by-passed. For a small number of mouse flows that do enter our data structure, they will decay away to make room for true elephants. The decay is not uniform for the flows in our data structure. The design of exponential decay is biased against small flows, and it has a smaller impact on larger flows. This design works extremely well with real traffic traces under small memory where the previous strategies will fail. Main experimental results: As shown in <ref type="table">Table 1</ref>, when compared with Space-Saving, Lossy counting, CSS, and CM sketch, HeavyKeeper achieves 99.99% percent precision, and much smaller error than all of them. Contributions: This paper makes the following contributions.</p><p>1. We propose a new data structure, named HeavyKeeper, which achieves high precision for finding top-k flows, and achieves constant and fast speed as well as high memory efficiency.</p><p>2. We develop a mathematical analysis for HeavyKeeper, to theoretically prove its high precision. <ref type="table">Table 1</ref>: Main experimental results. Precision is defined as the ratio between the number of correctly reported elephant flows and the total number of reported flows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm</head><p>Top-k precision Avg. relative error of flow sizes Space-Saving <ref type="bibr" target="#b23">[24]</ref> 0.27 172.7222 Lossy counting <ref type="bibr" target="#b25">[26]</ref> 0.39 54.8440 CSS <ref type="bibr" target="#b22">[23]</ref> 0.49 18.9356 CM sketch <ref type="bibr" target="#b13">[14]</ref> 0 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries 2.1 Problem Statement</head><p>Simply speaking, finding top-k flows refers to finding the largest k flows. Let P = P 1 , P 2 , · · · , P N be a network stream with N packets. Each packet P l (1 l N) belongs to a flow f i , where</p><formula xml:id="formula_0">f i ∈ F = { f 1 , f 2 , · · · , f M } and</formula><p>F is the set of flows. Let n i be the real flow size of flow f i in P. We order all flows (</p><formula xml:id="formula_1">f 1 , f 2 , · · · , f M ) so that n 1 n 2 · · · n M .</formula><p>Given an integer k and a network stream P, the output of top-k is a list of k flows from F with the largest flow sizes, i.e., f 1 , f 2 , · · · , f k .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Prior Art and Limitations</head><p>The count-all strategy: As mentioned above, the countall strategy uses sketches (such as the CM sketch <ref type="bibr" target="#b13">[14]</ref> or the Count sketch <ref type="bibr" target="#b24">[25]</ref>) to record the sizes of all flows, and uses a min-heap to keep track of the top-k flows, including the flow IDs and their flow sizes. Take the CM sketch as an example. It records packets in a CM sketch, consisting of a pool of counters. For each arrival packet, it hashes the packet's flow ID f to d counters and increases these d counters by one. The smallest value of the d counters is used as the estimated size of the flow.</p><p>If this estimated flow size is larger than the smallest flow size in the min-heap, we replace the smallest flow in the heap by flow f .</p><p>The problem is that all flows are pseudo-randomly mapped to the same pool of counters through hashing. Each counter may be shared by multiple flows, and thus record the sum of sizes of all these flows. Consequently, the CM sketch has an over-estimation problem, which will become severe in a tight memory space where the number of counters is far smaller than the number of flows, resulting in aggressive sharing. In such a case, a small flow may be treated as an elephant flow if all its d counters are shared with real elephant flows.</p><p>The admit-all-count-some strategy: As mentioned above, quite a few algorithms use the admit-all-countsome strategy, including Frequent <ref type="bibr" target="#b29">[30]</ref>, Lossy counting <ref type="bibr" target="#b25">[26]</ref>, and Space-Saving <ref type="bibr" target="#b23">[24]</ref>, with Space-Saving being the most widely used among them. Take Space-Saving as an example. Recognizing that it is infeasible to count the sizes of all flows, Space-Saving counts only the sizes of some flows in a data structure called Stream-Summary, which incurs O(1) overhead to search or update a flow, or find the smallest flow. The selection of which flows to store in the summary is rather simple: For each arrival packet, if its flow ID is not in the summary, the flow will be admitted into the summary, replacing the smallest existing flow. The new flow's initial size is set tô n min + 1, wherê n min is the smallest flow size in the summary before replacement. Therefore, later incoming mouse flows will be largely over-estimated, which is drastically inaccurate. In the end, the largest k flows in the summary will be reported. A recent work CSS <ref type="bibr" target="#b22">[23]</ref> is proposed based on Space-Saving. It inherits the above strategy of Space-Saving, and redesigns the data structure of Stream-Summary by using TinyTable <ref type="bibr" target="#b31">[32]</ref> to reduce memory usage.</p><p>The strategy of admit-all-count-some is to admit all new flows while expelling the smallest existing ones from the summary. To give new flows a chance to stay in the summary, their initial flow sizes are set asˆn asˆ asˆn min + 1. Such a strategy drastically over-estimates sizes of flows, and we show an example here. Assumê n min = 10, 000. Given an new incoming flow, its size will be over-estimated as 10, 001. Early arrived elephant flows with flow sizes less than 10, 008 will be expelled. Therefore, massive mouse flows will cause significant overestimation errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Design of HeavyKeeper</head><p>In this section, we present the data structure and algorithm of our HeavyKeeper, and show how to find the topk flows accurately and efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Rationale</head><p>We aim to use a small hash table to store all elephant flows. As there are a great number of flows, each bucket of the hash table will be mapped by many flows, and we aim to store only the largest flow with its size, which cannot be achieved with no error when using small memory. To address this problem, we propose a probabilistic method called exponential-weakening decay. Specifically, when the incoming flow is different from the flow in the hashed bucket, we decay the flow size with a decay probability, which is exponentially smaller as the flow size grows larger. If the flow size is decayed to 0, it replaces the original flow with the new flow. In this way, mouse flows can easily be decayed to 0, while elephant flows can easily keep stable in the bucket. There are two shortcomings: 1) With a small probability we elect the wrong flow as the largest flow; 2) The stored flow size is a little smaller than the true frequency because of the decay operations. To address these problems, we use multiple hash tables with different hash functions. An elephant flow could be stored in multiple hash tables, we choose the recorded largest size, minimizing the error of flow sizes. As shown in <ref type="figure" target="#fig_1">Figure 1</ref>, HeavyKeeper is comprised of d arrays, and each array is comprised of w buckets. Each bucket consists of two fields: a fingerprint field and a counter field. <ref type="bibr" target="#b1">2</ref> For convenience, we use A j [t] to represent the t th bucket in the j th array, and use A j <ref type="bibr">[t]</ref>.FP and A j <ref type="bibr">[t]</ref>.C to represent its fingerprint field and counter field, respectively. Arrays A 1 ...A d are associated with hash functions h 1 (.)...h d (.), respectively. These d hash functions h 1 (.)...h d (.) need to be pairwise independent. Insertion: Initially, all fingerprint fields are null, and all counter fields are 0. For each incoming packet P l belong- <ref type="bibr" target="#b1">2</ref> The fingerprint of a flow is a hash value generated by a certain function (for example, if we use h f (.) as the fingerprint hash function, the fingerprint of flow f j is h f ( f j )). Although there can be hash collisions among flows, the probability is quite small. For example, if we set the fingerprint size to 16 bits, and there are 10000 buckets in the array, the probability of fingerprint collisions is 1.52 * 10 −3 . ing to flow f i , HeavyKeeper computes the d hash functions, and maps f i to d buckets A j [h j ( f i )] (1 j d) (one bucket in each array), which we call d mapped buckets for convenience. As shown in <ref type="figure">Figure 2</ref>, for each mapped bucket, HeavyKeeper applies different strategies for the following three cases:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The HeavyKeeper Structure</head><formula xml:id="formula_2">C-1 í µí±3 ℎ í µí± (í µí±3) Case 1: if C=0 C=C+1=1</formula><p>Case 2: if C&gt;0 &amp;&amp; FP=F3 C=C+1 3) In Case 3, when C is decayed to 0, the fingerprint field will be replaced by F 3 , and then counter C is set to 1.</p><formula xml:id="formula_3">Case 1: When A j [h j ( f i )].C = 0</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>. It means that no flow has been mapped to this bucket, then HeavyKeeper sets</head><formula xml:id="formula_4">A j [h j ( f i )].FP = F i and A j [h j ( f i )].C = 1, where F i repre- sents the fingerprint of f i . Case 2: When A j [h j ( f i )].C &gt; 0 and A j [h j ( f i )].FP = F i . It means A j [h j ( f i )].C is probably the estimated size of f i . In this case, HeavyKeeper increments A j [h j ( f i )].C by 1. Case 3: When A j [h j ( f i )].C &gt; 0 and A j [h j ( f i )].FP = F i . It means that A j [h j ( f i )]</formula><p>.C is not the estimated size of f i . In here, HeavyKeeper applies the exponential-weakening decay strategy to this bucket: it decays A j [h j ( f i )].C by 1 with a probability P decay . After decay, if</p><formula xml:id="formula_5">A j [h j ( f i )].C = 0, HeavyKeeper replaces A j [h j ( f i )]</formula><p>.FP with F i , and sets A j [h j ( f i )].C to 1. Therefore, as long as flows are mapped to a bucket, its counter field will never be 0. Query: To query the size of a flow f i , HeavyKeeper first computes the d hash functions to get d buckets A j [h j ( f i )] (1 j d). Among the d mapped buckets, it chooses those buckets whose fingerprint fields are equal to F i . It then reports the maximum counter field of those buckets,</p><formula xml:id="formula_6">i.e., max 1 jd {A j [h j ( f i )].C} where A j [h j ( f i )].FP = F i . For convenience, for those d mapped buckets of f i , if A j [h j ( f i )].FP = F i , we say that f i is held at bucket A j [h j ( f i )].</formula><p>Ignoring the limited impact of fingerprint collisions, we prove that the reported size for each flow is equal to or smaller than the real flow size in Section 4.1. If a flow is held at no mapped bucket, it reports that it is a mouse flow. If a flow is held at multiple buckets, HeavyKeeper reports the maximum counter field. Decay probability: The decay probability P decay in the exponential-weakening decay strategy is an important parameter. Here, we use the following exponential function to calculate the probability:</p><formula xml:id="formula_7">P decay = b −C (b &gt; 1)</formula><p>where C is the value in the current counter field, and where b (b &gt; 1 and b ≈ 1, e.g., b = 1.08) is a pre-defined exponential base number. Therefore, the larger size a flow has, the harder its size is decayed. For elephant flows, it is held at several buckets, and the corresponding counter fields are incremented regularly, while decayed with a very small probability. Therefore, the error rate for estimated sizes of elephant flows is very small.</p><p>Note: Our data structure of d arrays may show some similarity with that of CM <ref type="bibr" target="#b13">[14]</ref>. But similarity stops there. CM records the sizes of all flows; we record the sizes of a small number of flows. CM does not store flow IDs; we do. CM stores information of each flow in d counters; we keep each flow mostly in one bucket, while dhashing helps find an empty bucket. CM does not have to worry about the issue of kicking out existing flows to make room for new ones, which is what our exponential delay does.</p><p>Example: As shown in <ref type="figure" target="#fig_1">Figure 1</ref>, given an incoming packet P 5 belonging to flow f 3 , we compute the d hash functions to obtain one bucket in each array. In the mapped bucket of the first array, the fingerprint field is not equal to F 3 and the counter field is 21, thus we decay the counter field from 21 to 20 with a probability of 1.08 −21 (assume b = 1.08). In the second mapped bucket, the fingerprint field is not F 3 yet, and with a probability of 1.08 −1 , we decay the counter field from 1 to 0. If the counter field is decayed to 0, we set the fingerprint field to F 3 , and set the counter field to 1. In the last mapped bucket, the fingerprint field is F 3 , we increment the counter field from 7 to 8.</p><p>Analysis: HeavyKeeper uses fingerprint to identify and keep elephant flows. If a mouse flow with a small flow size is held at a bucket, it will be replaced by other flows mapped to this bucket soon, because each flow mapped to this bucket with a different fingerprint will decay the counter field with a high probability (b −C → 1 when C is small). If an elephant flow is held at a bucket, the corresponding counter field can easily be incremented to a large value since elephant flows have many incoming packets. Moreover, the decay probability becomes very small (b −C → 0 when C is large) as the counter field increases to a large value. Therefore, mouse flows can hardly be held in HeavyKeeper for a long time, and thus have a large probability to be passers-by of HeavyKeeper. However, elephant flows can keep stable in HeavyKeeper, and the estimated sizes of elephant flows are accurate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Basic Version for Finding the Top-k Elephant Flows</head><p>To find top-k elephant flows, our basic version just uses a HeavyKeeper and a min-heap. The min-heap is used to store the IDs and sizes of top-k flows. For each incom-ing packet P l belonging to flow f i , we first insert it into HeavyKeeper. Suppose that HeavyKeeper reports the size of f i asˆnasˆ asˆn i . If f i is already in the min-heap, we update its estimated flow size with max( ˆ n i , min heap[ f i ]), where min heap[ f i ] is the recorded size of f i in min-heap. Otherwise, ifˆnifˆ ifˆn i is larger than the smallest flow size which is in the root node of the min-heap, we expel the root node from the min-heap, and insert f i withˆnwithˆ withˆn i into the minheap. To query top-k flows, we simply report the k flows in the min-heap with their estimated flow sizes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Optimizations</head><p>In this section, we propose further optimization methods to avoid accidental errors and improve speed. Optimization I: Fingerprint Collisions Detection. Problems: Assume that there is a bucket in HeavyKeeper where flow f i is held, and a mouse flow f j mapped to the same bucket has the same fingerprint as f i , i.e., F i = F j due to hash collisions. Then, the mouse flow f j is also held at this bucket, and its estimated size is drastically over-estimated. In the worst case, if flow f j has a fingerprint collision in all d arrays, the mouse flow f j will probably be inserted into the min-heap. It can hardly be expelled due to its drastically over-estimated size. To address this problem, we propose a solution based on the following Theorem. Theorem 1. When there is no fingerprint collision, after a flow f i is inserted into HeavyKeeper, if its estimated sizê n i is larger than n min , then we must havê havê n i = n min + 1</p><p>The proof of this Theorem is not hard to derive and we skip it due to space limitations. Solution: Based on Theorem 1, if f i is not in the minheap butˆnbutˆ butˆn i &gt; n min + 1, then f i is a mouse flow whose size is drastically over-estimated due to fingerprint collision. Therefore, we should not insert f i into the min-heap in this case. Optimization II: Selective Increment. Problem: If a flow f i is not in the min-heap, then the estimated flow size should be no larger than n min . However, due to fingerprint collisions, there could be some mapped buckets of flow f i where the fingerprint field is F i and the counter field is larger than n min . In this case, flow f i is not the flow that is held at this bucket, and thus increasing the corresponding counter field can only incur extra error. Solution: In this case, instead of incrementing or decaying the corresponding counter field, we make no change. Optimization III: Speed Acceleration. Problem: Our basic version of using the min-heap is the most memory efficient solution. However, the processing speed is limited, because the time complexity for updating and searching a flow in the min-heap is O(log(k)) and O(k) respectively, which are time-consuming. Solution: The min-heap is actually used to record the flow IDs of elephant flows and their estimated flow sizes. In this optimization version, instead of using the minheap, we use a single array to record the flow IDs. Specifically, we define a flow size threshold η (e.g., η = 1000). For each incoming flow, if its estimated size is equal to η, we record the flow ID in the array. As we record the fingerprints of elephant flows, the flow size will increases at most by 1 for each incoming packet when assuming there is no fingerprint collision. Therefore, any flow whose estimated size is larger than or equal to η is recorded in this array once in most cases. Further, this optimization of using an array is only suitable for sketches that record flow IDs or fingerprints.</p><p>Algorithm 1: Insertion process for finding top-k flows.</p><p>Input: A packet P l belonging to flow  </p><formula xml:id="formula_8">f i 1 f lag ← f alse; 2 if f i ∈ min heap then 3 f lag ← true; 4 maxv ← 0; 5 for j ← 1 to d do 6 C ← A j [h j ( f i )].C;</formula><formula xml:id="formula_9">b −C then 13 A j [h j ( f i )].C − −; 14 if A j [h j ( f i )].C = 0 then 15 A j [h j ( f i )].FP ← F i ; 16 A j [h j ( f i )].C ← 1;</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Final Version</head><p>Based on the basic version, we propose the common final version using the first two optimization methods, and propose the accelerated final version using the third optimization methods. The insertion and query processes of the common final version of our algorithm are as follows (see pseudo-code in Algorithm 1). Insertion: All counters and fingerprints in HeavyKeeper and the min-heap are initialized to 0. For each incoming packet P l belonging to flow f i , these are the following three steps for each insertion:</p><p>Step 1: Check whether flow f i is already monitored by the min-heap. For convenience, we use a boolean variable f lag to represent the result.</p><p>Step 2: Insert f i into HeavyKeeper. According to Optimization II, for each mapped bucket, if the fingerprint field is equal to F i , increment the counter field only when f lag = true or C &lt; n min , where C is the original value in the counter field.</p><p>Step 3: Get an estimated sizê n i of flow f i from HeavyKeeper. According to Optimization III, if f lag = true, we update the estimated size of flow f i in the min-heap withˆnwithˆ withˆn i . If f lag = f alse, insert flow f i into the min-heap withˆnwithˆ withˆn i in only two cases: 1) the number of flows that are in the min-heap is less than k; 2) ˆ n i = n min + 1. Query top-k flows: It reports the k flows recorded in the min-heap and their estimated flow sizes. Analysis: Since HeavyKeeper achieves very small error rate on the flow size estimation of elephant flows, it can significantly reduce the error in finding top-k elephant flows. Furthermore, the first two optimizations reduce the impact of fingerprint collisions, and enhance the precision of finding top-k elephant flows and their flow size estimation. The third optimization method has a constant processing time for insertions: 1) For most incoming packets, they are only inserted into HeavyKeeper, which requires d (e.g., d = 2) memory accesses. 2) For some packets belonging to elephant flows, they are inserted into both HeavyKeeper and the array. It requires d + 1 memory accesses in the worst case. Therefore, the time complexity of insertion process is O(d). Therefore, the processing speed of the accelerated final version is fast on average and constant in the worst case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Other uses of HeavyKeeper</head><p>Besides finding top-k flows in a network stream, HeavyKeeper can also perform other tasks in network traffic measurement, such as heavy hitter detection and change detection. Due to space limitations, here we only briefly introduce how to perform these tasks using HeavyKeeper.</p><p>Heavy hitter detection: Given a threshold θ , a heavy hitter <ref type="bibr" target="#b12">[13]</ref> is a flow whose size n i &gt; θ N, where N is the number of packets in total. The heavy hitter detection algorithm is very similar to that of finding top-k flows. The only difference is that when querying heavy hitters, it reports those flows whose estimated size is larger than θ N in min-heap.</p><p>Change detection: The network stream is divided into fixed-size time bins. Given a flow, if the difference of its flow sizes in two adjacent time bins is larger than a predefined threshold, then the flow is called a heavy change <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b32">33]</ref>. We use the very flow ID as the fingerprint of each flow. For two adjacent time bins, we insert their packets into two different HeavyKeepers. By comparing buckets in the corresponding location in the two HeavyKeepers, we obtain the estimated difference of sizes of the flows, and report the heavy changes by checking if the difference is larger than the threshold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Mathematical Analysis</head><p>In this section, we first prove that there is no overestimation in HeavyKeeper, and then derive the formula of its error bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Proof of No Over-estimation Error of HeavyKeeper</head><p>Theorem 2. Let n i (t) be the real size of flow f i at time t, and let A j [h j ( f i )](t).C be the counter field of the mapped bucket of flow f i in the j th array at time t. If there is no fingerprint collision, then</p><formula xml:id="formula_10">∀ j,t, A j [h j ( f i )](t).C n i (t)<label>(1)</label></formula><p>Proof. When t = 0, no packet maps into this bucket, so n i (0) = 0 and A j [h j ( f i )](t).C = 0. Therefore, the theorem holds at time 0. Let's now prove by induction that the theorem holds at any time. When t = 0, the theorem holds. If the theorem holds when t = v, let's prove that the theorem also holds when t = v + 1. There are three cases when t = v + 1:</p><formula xml:id="formula_11">Case 1: The new incoming packet is not mapped to bucket A j [h j ( f i )]. Then n i (v + 1) = n i (v) and A j [h j ( f i )](v + 1).C = A j [h j ( f i )](v).C. Therefore, A j [h j ( f i )](v + 1).C n i (v + 1).</formula><p>Case 2: The new incoming packet belongs to flow f i . Then n i (v + 1) = n i (v) + 1 and</p><formula xml:id="formula_12">A j [h j ( f i )](v + 1).C = A j [h j ( f i )](v).C + 1. Therefore, A j [h j ( f i )](v + 1).C n i (v + 1).</formula><p>Case 3: The new incoming packet is mapped to bucket A j [h j ( f i )] but does not belong to flow f i . Then</p><formula xml:id="formula_13">A j [h j ( f i )](v + 1).C = A j [h j ( f i )](v).C or A j [h j ( f i )](v + 1).C = A j [h j ( f i )](v)</formula><p>.C − 1, and n i (v + 1) = n i (v). Therefore, A j [h j ( f i )](v + 1).C n i (v + 1).</p><p>Therefore, for any time t,</p><formula xml:id="formula_14">A j [h j ( f i )](t).C n i (t)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Error Bound of HeavyKeeper</head><p>Definition 4.1. Given a small positive number ε, Pr{n i − ˆ n i εN} (n i ˆ n i ) represents the probability that the error of the estimated flow size n i − ˆ n i is larger than εN. If Pr{n i − ˆ n i εN} δ , the algorithm is said to achieve (ε,δ )-counting.</p><p>(ε,δ )-counting is a metric to evaluate the error rate of the algorithm. Here HeavyKeeper is proved to achieve (ε,δ )-counting, showing that HeavyKeeper achieves a low error rate in estimating the sizes of top-k flows.</p><p>Theorem 3. Let's assume that there is no fingerprint collision and the fingerprint of an elephant flow is held at its mapped bucket all the time. Let's focus on one single array of HeavyKeeper. Given a small positive number ε, and an elephant flow f i whose size is n i is held at that bucket,</p><formula xml:id="formula_15">Pr{n i − ˆ n i εN} 1 εwn i (b − 1) (2)</formula><p>where w is the width of each array, N the total number of packets, and b the exponential base.</p><p>Proof. Let's focus on the j th array. Flow f i is correctly reported, so at the end, the fingerprint of flow f i is held in the h j ( f i ) th bucket of the j th array. Let I i, j,i be a binary random variable, defined as</p><formula xml:id="formula_16">I i, j,i = 0 ( f i = f i ) ∨ (h j ( f i ) = h j ( f i )) 1 ( f i = f i ) ∧ (h j ( f i ) = h j ( f i ))<label>(3)</label></formula><p>I i, j,i = 1 i f f different flows f i and f i are held at the same bucket in the j th array. We define random variable X i, j as:</p><formula xml:id="formula_17">X i, j = M ∑ v=1 I i, j,i n i<label>(4)</label></formula><p>X i, j represents the sum of the sizes of the flows held at the same bucket as flow f i , except for the size of flow f i itself. Assume that for each incoming packet, if it belongs to flow f i , the counter field is incremented by 1; if not, the counter field is decayed with a certain probability. We have</p><formula xml:id="formula_18">n i − X i, j A j [h j ( f i )].C n i<label>(5)</label></formula><p>Specifically, if all packets that do not belong to flow f i decay the counter field, then A j [h j ( f i )].C = n i − X i, j . If those packets do not decay the counter field, then A j [h j ( f i )].C = n i . Let's define another random variable P i, j,l . Among the X i, j packets defined above, P i, j,l is defined as the probability that the l th packet decays the counter field. Therefore,</p><formula xml:id="formula_19">A j [h j ( f i )].C = n i − X i, j ∑ l=1 P i, j,l<label>(6)</label></formula><p>Given a small positive number ε, the following formula based on the Markov inequality holds</p><formula xml:id="formula_20">Pr{A j [h j ( f i )].C n i − εN} = Pr{n i − X i, j ∑ l=1 P i, j,l n i − εN} = Pr{ X i, j ∑ l=1 P i, j,l εN} E(∑ X i, j l=1 P i, j,l ) εN<label>(7)</label></formula><p>Now let's focus on E(∑ X i, j l=1 P i, j,l ). Assume that all packets are uniformly distributed, we have the following formula:</p><formula xml:id="formula_21">Pr{P i, j,l = 1 b C } = 1 A j [h j ( f i )].C = 1 n i − E(∑ X i, j l=1 P i, j,l ) (8) where 1 C n i − E(∑ X i, j l=1 P i, j,l ). Let β be n i − E(∑ X i, j l=1 P i, j,l ) for convenience. As a result, E( X i, j ∑ l=1 P i, j,l ) = E(X i, j ) ∑ l=1 E(P i, j,l ) = E(X i, j ) β ∑ C=1 1 b C 1 β = E(X i, j ) β · β ∑ C=1 1 b C = E(X i, j ) β · 1 b (1 − ( 1 b ) β ) 1 − 1 b E(X i, j ) n i b · 1 − ( 1 b ) n i 1 − 1 b = E(X i, j )(1 − ( 1 b ) n i ) n i (b − 1) (9) Furthermore, for E(X i, j ), based on Equation 4, E(X i, j ) = E( M ∑ v=1 I i, j,i n i ) M ∑ i =1 n i E(I i, j,v ) = N w (10) Therefore, based on Equation 9, E( X i, j ∑ l=1 P i, j,l ) N(1 − ( 1 b ) n i ) wn i (b − 1) N wn i (b − 1)<label>(11)</label></formula><p>then</p><formula xml:id="formula_22">Pr{A j [h j ( f i )].C n i − εN} E(∑ X i, j l=1 P i, j,l ) εN N εNwn i (b − 1) = 1</formula><p>εwn i (b − 1) Note that for an elephant flow f i , n i is very large, and To validate the correctness of this error bound, we conduct experiments on the dataset mentioned in Section 5.1. Here, we let N = 10 7 , ε = 2 −16 and 2 −17 , and vary memory size from 20KB to 100KB. As shown in <ref type="figure">Figure 3</ref> and <ref type="figure">Figure 4</ref>, the empirical probability of HeavyKeeper is always lower than the theoretical probability bound, confirming the correctness of Theorem 3. Moreover, for the CSS algorithm, achieving such a (ε,δ )-counting requires at least O(ε −1 ) buckets (i.e., m = O(ε −1 )), which requires a memory size much larger than 100KB. Therefore, HeavyKeeper is much more memory efficient than CSS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Results 5.1 Experiment Setup</head><p>Platform: Our experiments are run on a server with dual 6-core CPUs (24 threads, Intel Xeon CPU E5-2620 @2 GHz) and 62 GB total system memory. Each core has two L1 caches with 32KB memory (one instruction cache and one data cache) and one 256KB L2 cache. All cores share one 15MB L3 cache.</p><p>Dataset: 1) Campus dataset: The first dataset is comprised of IP packets captured from the network of our campus. We rely on the usual definition of a flow, through its 5-tuple, i.e., source IP address, destination IP address, source port, destination port, and protocol type. There are 10M packets in total, belonging to 1M flows. For convenience, we use campus dataset to denote this dataset.</p><p>2) CAIDA dataset: The second dataset is a CAIDA Anonymized Internet Trace from 2016 <ref type="bibr" target="#b33">[34]</ref>, made of anonymized IP packets. Each flow in this dataset is identified by the source and destination IP address. We use the first 10M packets, belonging to about 4.2M flows.</p><p>3) Synthetic datasets: We generate 10 different synthetic datasets according to a Zipf <ref type="bibr" target="#b34">[35]</ref> distribution with different skewness (from 0.3 to 3.0). Each dataset is comprised of 32M packets, belonging to 1 ∼ 10M flows depending on the skewness. Each packet is 4 bytes long.</p><p>The code of the dataset generator is the one from Web Polygraph <ref type="bibr" target="#b35">[36]</ref>. Implementation: The implementation of HeavyKeeper is done in C++. We also implemented in C++ the other related algorithms including Space-Saving (SS), Lossy counting (LC), and CM sketch. The source code of CSS was provided by its author <ref type="bibr" target="#b22">[23]</ref>, and is written in Java. It is much slower than Space-Saving written in C++. Therefore, we do not include CSS in our speed experiments. For Space-Saving, Lossy counting, and CSS, the number of buckets m is determined by the memory size, which is usually much larger than k. When querying top-k flows, they report the largest k flows of them. For CM sketch, the size of the heap is k, the number of arrays is 3, and the width of each array is determined by the memory size. In our algorithm, the number of buckets m in Stream-Summary is equal to k, and HeavyKeeper occupies the rest memory size. Here we set d = 2, and w depends on the memory size. Both the fingerprint field and the counter field are 16-bit long. For experiments on throughput, we ignore operations on the min-heap for the CM sketch, because we can only record flows whose estimated size is larger than a pre-defined threshold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Metrics</head><p>Precision: Precision is defined as C k . Only C flows belong to the real top-k flows. Average Relative Error (ARE): ARE is defined as</p><formula xml:id="formula_23">1 |Ψ | ∑ f i ∈Ψ | ˆ n i −n i | n i</formula><p>, where Ψ is estimated set of top-k flows, ˆ n i is the estimated size of flow f i , and n i is the real size of flow f i . ARE evaluates the error rate of the estimated flow size reported by the algorithm. Average Absolute Error (AAE): AAE is defined as 1 |Ψ | ∑ f i ∈Ψ | ˆ n i − n i |, similarly to ARE.</p><p>Throughput: We perform insertions of all packets, record the total time used, and calculate the throughput. The throughput is defined as N T , where N is the total number of packets, and T is the total measured time. We use Million of insertions per second (Mps) to measure the throughput.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Experiments on Precision</head><p>To achieve a head-to-head comparison, we use the same memory size for each algorithm. We perform the experiments for varying memory size and k on the campus and CAIDA datasets, and varying skewness on the synthetic datasets. For experiments of varying memory size, we set k = 100. For experiments of varying k, we set the memory size to 100KB. For experiments of varying skewness, we set the memory size to 100KB and set k = 1000. Precision vs. memory size: As shown in <ref type="figure">Figure 5</ref>, for the campus dataset, when memory size is 10KB, the precision of Space-Saving, Lossy counting, CSS, and CM sketch is respectively 10%, 11%, 19%, and 41%, while the one of HeavyKeeper is 82%. Furthermore, we find that the precision of HeavyKeeper reaches 100% for a memory size of 30KB, while the corresponding precision of Space-Saving, Lossy counting, CSS, and CM sketch is 27%, 39%, 49%, and 93%. This implies that HeavyKeeper has indeed much better precision than the other three algorithms. We find that Lossy counting is more accurate than Space-Saving. However, as will be mentioned later, Lossy counting is much slower than the other algorithms. For the CAIDA dataset (see <ref type="figure">Fig- ure 6</ref>), we find that the precision of HeavyKeeper reaches 99.99% when memory size is larger than 20KB, while for Space-Saving, Lossy counting, CSS, and CM sketch, precision is respectively 18%, 33%, 34%, and 89% when memory size is 50KB. Precision vs. k: As shown in <ref type="figure" target="#fig_3">Figure 7</ref>, for the campus dataset, as k becomes larger, the precision of HeavyKeeper stays high, while it degrades for other algorithms.</p><p>For the campus dataset, as k becomes larger, the precision of HeavyKeeper is always higher than 95.9%, while that of Space-Saving, Lossy counting, CSS, and CM sketch reaches 32.7%, 44.1%, 50.1%, and 77.9% respectively when k = 1000. This happens for two main reasons: 1) larger k requires larger memory usage to store information about more flows; 2) as k increases, the difference of flow sizes among flows becomes smaller, so it is easy to mistake other flows for top-k flows. For the CAIDA dataset <ref type="figure">(Figure 8</ref>), we find that the precision of HeavyKeeper is always above 94%, while for Space-Saving, Lossy counting, CSS, and CM sketch, it is 26.6%, 37.1%, 44%, and 70% respectively when k = 1000. Precision vs. skewness: As shown in <ref type="figure">Figure 9</ref>, the precision of HeavyKeeper reaches 99.99%. For all considered values of skewness, the precision of HeavyKeeper does not go below 94.9%, while the highest precision for Space-Saving, Lossy counting, CSS, and CM sketch is 46.8%, 41.3%, 74.5%, and 85.7%, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Experiments on AAE and ARE</head><p>In this section, we focus on the ARE and the AAE of the estimated frequency of reported top-k flows. We also conduct experiments with varying memory size, k, and skewness. The parameter settings are the same as in Section 5.3. ARE vs. memory size: As shown in <ref type="figure" target="#fig_1">Figure 10,</ref>   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Experiments on Throughput</head><p>We now turn to the throughput of the algorithms. We only report results for the campus dataset due to space limitations. We set k = 100, and vary memory size from 10KB to 50KB. Here we use CAIDA datasets. Throughput vs. memory size: As shown in <ref type="figure" target="#fig_7">Fig- ure 20</ref>, we find that the throughput of HeavyKeeper is always higher than other algorithms. Indeed, the average throughput of HeavyKeeper is 15.52Mps, while it is 12.15Mps, 11.34Mps, and 12.72Mps for Space-Saving, Lossy counting, and CM sketch. These results show that HeavyKeeper not only is more accurate than previous work, but also achieves higher throughput as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Open vSwitch Deployment</head><p>In this section, we implement our HeavyKeeper algorithm on a software switch platform: Open vSwitch (OVS). We first present details of our implementation, and then present experimental results to show the performance of our algorithm running on Open vSwitch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">OVS Implementation</head><p>The OVS implementation of our HeavyKeeper algorithm consists of three components: 1) the modified OVS datapath, 2) the shared memory buffering flow IDs, and 3) the user-space program of HeavyKeeper processing flow IDs. For each incoming packet, it will be first inserted into the OVS datapath for forwarding. Besides, we modify the source codes of OVS datapath to parse the flow ID of the incoming packet, and then insert its flow ID into the shared memory (the shared memory is created initially). Finally, the user-space program will read the flow IDs from the shared memory, and process them as incoming packets.</p><p>In order to improve the performance of OVS, we integrate OVS with DPDK (Data Plane Development Kit). DPDK implements the datapath entirely in the userspace, and thus it eliminates the overhead of a context switch and memory copies between user-space and kernel-space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">OVS Evaluation</head><p>To evaluate the performance of HeavyKeeper implemented in OVS, we conduct experiments to evaluate the throughput of HeavyKeeper and other algorithms. Besides, we also show the throughput of OVS without using any algorithm to show the impact of algorithms. We set the memory size to 50KB. As shown in <ref type="figure" target="#fig_1">Figure 21</ref>, the throughput of HeavyKeeper is near the original throughput of OVS. Specifically, the throughput of the original OVS is 19.22Mps, and that of HeavyKeeper is 18.03Mps. However, the throughput of CM sketch, Space-Saving, and Lossy Counting is 14.14Mps, 13.80Mps, and 12.64Mps, respectively. The results show that our HeavyKeeper algorithm has little impact to the performance of OVS, while other algorithms decrease the throughput significantly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>Finding the top-k elephant flows is a critical task for network traffic measurement. As the line rate increases, it is more and more challenging to design an accurate algorithm that achieves fast and constant speed. Existing algorithms for finding top-k flows cannot achieve high precision when traffic speed is high and memory usage is small, because they do not handle massive mouse flows effectively. In this paper, we propose a novel data structure, called HeavyKeeper, which achieves a much higher precision on top-k queries and a much lower error rate on flow size estimation, compared to previous algorithms. The key idea of HeavyKeeper is that it intelligently omits mouse flows, and focuses on recording the information of elephant flows by using the exponentialweakening decay strategy. Our evaluation confirms that HeavyKeeper achieves 99.99% precision for finding the top-k elephant flows, while also achieving a reduction in the error rate of the estimated flow size by about 3 orders of magnitude compared to the state-of-the-art algorithms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>1</head><label></label><figDesc>Co-primary authors: Junzhi Gong and Tong Yang. Correspond- ing author: Tong Yang (yangtongemail@gmail.com). Junzhi Gong, Haowei Zhang, Hao Li finished this work under the guidance of their supervisor: Tong Yang. This work is supported by Primary Research &amp; Development Plan of China (2016YFB1000304), National Basic Research Program of China (973 Program, 2014CB340405), NSFC (61672061), the OpenProject Funding of CAS Key Lab of Network Data Science and Technology, Institute of Computing Technology, Chi- nese Academy of Sciences.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The data structure of HeavyKeeper.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>FP</head><label></label><figDesc>Figure 2: The main insertion cases of HeavyKeeper. Note: 1) F 3 is the fingerprint of flow f 3 . 2) b &gt; 1 and b ≈ 1 (e.g., b = 1.08). 3) In Case 3, when C is decayed to 0, the fingerprint field will be replaced by F 3 , and then counter C is set to 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>7 if</head><label>7</label><figDesc>A j [h j ( f i )].FP = F i then 8 if f lag = true or C &lt; min heap.n min then 9 A j [h j ( f i )].C + +; 10 maxv ← max(maxv, A j [h j ( f i )].C); 11 else 12 if rand(1) &lt;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>17 maxv ← max(maxv, 1); 18 if f lag = true then 19 min heap[ f i ] ← max(maxv, min heap[ f i ]); 20 else 21 if min heap has empty buckets or maxv − n min = 1 then 22 min heap.insert( f i );</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Figure 3: Theoretical bound and empirical probability of HeavyKeeper (ε = 2 −16 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 17 :Figure 18 :Figure 19 :</head><label>171819</label><figDesc>Figure 5: Precision vs. memory size (Campus).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 20 :</head><label>20</label><figDesc>Figure 20: Throughput vs. memory size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 21 :</head><label>21</label><figDesc>Figure 21: Throughput on OVS platform.</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Programmable packet scheduling at line rate</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anirudh</forename><surname>Sivaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Suvinay</forename><surname>Subramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM</title>
		<meeting>ACM SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Deriving traffic demands for operational ip networks: Methodology and experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anja</forename><surname>Feldmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Albert</forename><surname>Greenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIG-COMM</title>
		<meeting>ACM SIG-COMM</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Characterization of network-wide anomalies in traffic flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anukool</forename><surname>Lakhina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Crovella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christiphe</forename><surname>Diot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM IMC</title>
		<meeting>ACM IMC</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Optimal rule caching and lossy compression for longest prefix matching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ori</forename><surname>Rottenstreich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">János</forename><surname>Tapolcai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Networking</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="864" to="878" />
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Conditional heavy hitters: detecting interesting correlations in data streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katsiaryna</forename><surname>Mirylenka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Themis</forename><surname>Palpanas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Divesh</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="395" to="414" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Finding recent frequent itemsets adaptively over online data streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hyuk</forename><surname>Joong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Won Suk</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGKDD</title>
		<meeting>ACM SIGKDD</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="487" to="492" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Mining frequent itemsets without support threshold: with and without item constraints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yin-Ling</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ada Wai-Chee</forename><surname>Fu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1052" to="1069" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Introduction to modern information retrieval</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gerard</forename><surname>Salton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mcgill</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Top-k query processing in uncertain databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mohamed A Soliman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Ihab</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin Chen-Chuan</forename><surname>Ilyas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE ICDE</title>
		<meeting>IEEE ICDE</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="896" to="905" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Identifying heavy hitters in high-speed network monitoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Binxing</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yongzheng</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science China Information Sciences</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="659" to="676" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Introduction to data security and privacy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elisa</forename><surname>Bertino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Science and Engineering</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="125" to="126" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Augmented sketch: Faster and more accurate stream processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pratanu</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arijit</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gustavo</forename><surname>Alonso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Sketch techniques for approximate query processing. Foundations and Trends in Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Cormode</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<publisher>NOW publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">An improved data stream summary: the count-min sketch and its applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Muthukrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Algorithms</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="58" to="75" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristian</forename><surname>Estan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Varghese</surname></persName>
		</author>
		<title level="m">New directions in traffic measurement and accounting</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Spatio-temporal compressive sensing and internet traffic matrices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Roughan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walter</forename><surname>Willinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lili</forename><surname>Qiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIG-COMM Computer Communication Review</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="267" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Network traffic characteristics of data centers in the wild</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Theophilus</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aditya</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David A</forename><surname>Maltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th ACM SIGCOMM conference on Internet measurement</title>
		<meeting>the 10th ACM SIGCOMM conference on Internet measurement</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="267" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A manifesto for modeling and measurement in social media</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Balachander</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Walter</forename><surname>Willinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">First Monday</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">9</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Unraveling the complexity of network management</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dave</forename><surname>Maltz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Dynamic prioritization of traffic in home networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yilun</forename><surname>Ilker Nadi Bozkurt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Theophilus</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bilal</forename><surname>Benson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dave</forename><surname>Anwer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aditya</forename><surname>Feamster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Balakrishnan</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cheng</forename><surname>Chandrasekaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruce</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Maggs</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Achievable rate maximization for cognitive hybrid satellite-terrestrial networks with af-relays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhetao</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fu</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shiguo</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tingrui</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jie</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Journal on Selected Areas in Communications</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="304" to="313" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Big data reduction methods: a survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muhammad</forename><surname>Habib Ur Rehman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chee</forename><surname>Sun Liew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Assad</forename><surname>Abbas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prem</forename><surname>Prakash Jayaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ying</forename><surname>Teh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Samee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Khan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Data Science and Engineering</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="265" to="284" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Heavy hitters in streams and sliding windows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ran</forename><surname>Ben-Basat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gil</forename><surname>Einziger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roy</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yaron</forename><surname>Kassner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE INFOCOM</title>
		<meeting>IEEE INFOCOM</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Efficient computation of frequent and top-k elements in data streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmed</forename><surname>Metwally</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Divyakant</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amr</forename><forename type="middle">El</forename><surname>Abbadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Springer ICDT</title>
		<meeting>Springer ICDT</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Finding frequent items in data streams. Automata, languages and programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moses</forename><surname>Charikar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Farachcolton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="784" to="784" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Approximate frequency counts over data streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gurmeet</forename><surname>Singh Manku</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>Motwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="346" to="357" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Dynamic compressive wide-band spectrum sensing based on channel energy reconstruction in cognitive internet of things</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhetao</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Baoming</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shiguo</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anfeng</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fanzi</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guangming</forename><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Industrial Informatics</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Flowradar: A better netflow for data centers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuliang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rui</forename><surname>Miao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Changhoon</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minlan</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="311" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Matching the speed gap between sram and dram</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hamdi</forename><surname>Mounir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE HSPR</title>
		<meeting>IEEE HSPR</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="104" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Frequency estimation of internet packet streams with limited space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erik</forename><surname>Demaine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alejandro</forename><surname>López-Ortiz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Munro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">AlgorithmsESA</title>
		<imprint>
			<biblScope unit="page" from="11" to="20" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">The source codes of heavykeeper and other related algorithms</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Counting with tinytable: Every bit counts!</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gil</forename><surname>Einziger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roy</forename><surname>Friedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDCN</title>
		<meeting>ICDCN</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Reversible sketches for efficient and accurate change detection over network data streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Schweller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elliot</forename><surname>Parsons</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yan</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM IMC</title>
		<meeting>ACM IMC</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
				<ptr target="http://www.caida.org/data/overview/" />
		<title level="m">The caida anonymized internet traces 2016</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Applications and explanations of zipf&apos;s law</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">W</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Powers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the joint conferences on new methods in language processing and computational natural language learning</title>
		<meeting>the joint conferences on new methods in language processing and computational natural language learning</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="151" to="160" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Highperformance benchmarking with web polygraph. Software: Practice and Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Rousskov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Duane</forename><surname>Wessels</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
