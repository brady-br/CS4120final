<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:06+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">RELOAD+REFRESH: Abusing Cache Replacement Policies to Perform Stealthy Cache Attacks RELOAD+REFRESH: Abusing Cache Replacement Policies to Perform Stealthy Cache Attacks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samira</forename><surname>Briongos</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pedro</forename><surname>Malagón</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">José</forename><forename type="middle">M</forename><surname>Moya</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samira</forename><surname>Briongos</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">Integrated Systems Laboratory</orgName>
								<orgName type="institution">Universidad Politécnica de Madrid</orgName>
								<address>
									<settlement>Madrid</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pedro</forename><surname>Malagón</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">Integrated Systems Laboratory</orgName>
								<orgName type="institution">Universidad Politécnica de Madrid</orgName>
								<address>
									<settlement>Madrid</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">José</forename><forename type="middle">M</forename><surname>Moya</surname></persName>
							<affiliation key="aff1">
								<orgName type="laboratory">Integrated Systems Laboratory</orgName>
								<orgName type="institution">Universidad Politécnica de Madrid</orgName>
								<address>
									<settlement>Madrid</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">University of Lübeck</orgName>
								<address>
									<settlement>Lübeck</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Worcester Polytechnic Institute</orgName>
								<address>
									<settlement>Worcester</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Thomas Eisenbarth</orgName>
								<orgName type="laboratory">Integrated Systems Laboratory</orgName>
								<orgName type="institution" key="instit1">Universidad Politécnica de Madrid</orgName>
								<orgName type="institution" key="instit2">University of Lübeck and Worcester Polytechnic Institute</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">RELOAD+REFRESH: Abusing Cache Replacement Policies to Perform Stealthy Cache Attacks RELOAD+REFRESH: Abusing Cache Replacement Policies to Perform Stealthy Cache Attacks</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Caches have become the prime method for unintended information extraction across logical isolation boundaries. They are widely available on all major CPU platforms and, as a side channel, caches provide great resolution, making them the most convenient channel for Spectre and Meltdown. As a consequence, several methods to stop cache attacks by detecting them have been proposed. Detection is strongly aided by the fact that observing cache activity of co-resident processes is not possible without altering the cache state and thereby forcing evictions on the observed processes. In this work, we show that this widely held assumption is incorrect. Through clever usage of the cache replacement policy, it is possible to track cache accesses of a victim&apos;s process without forcing evictions on the victim&apos;s data. Hence, online detection mechanisms that rely on these evictions can be circumvented as they would not detect the introduced RELOAD+REFRESH attack. The attack requires a profound understanding of the cache replacement policy. We present a methodology to recover the replacement policy and apply it to the last five generations of Intel processors. We further show empirically that the performance of RELOAD+REFRESH on cryptographic implementations is comparable to that of other widely used cache attacks, while detection methods that rely on L3 cache events are successfully thwarted.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The microarchitecture of modern CPUs shares resources among concurrent processes. This sharing may result in unintended information flows between concurrent processes. Microarchitectural attacks, which exploit these information flows, have received a lot of attention in academia, industry and, with Spectre and Meltdown <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b38">39]</ref>, even in the public news. The OS or the hypervisor in virtual environments provide strict logical isolation among processes to enable secure multi threading. Yet, a malicious process can intentionally create contention to gain information about coresident processes. Exploitable hardware resources include the branch prediction unit <ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref>, the DRAM <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b49">50,</ref><ref type="bibr" target="#b53">54]</ref> and the cache <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b46">47,</ref><ref type="bibr" target="#b47">48,</ref><ref type="bibr" target="#b60">61]</ref>. Last level caches (LLC) provide very high temporal and spatial resolution to observe and track memory access patterns. As a consequence, any code that generates cache utilization patterns dependent on secret data is vulnerable. Cache attacks can trespass VM boundaries to infer secret keys from neighboring processes or VMs <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b51">52]</ref>, break security protocols <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b52">53]</ref> or compromise the end users privacy <ref type="bibr" target="#b46">[47]</ref>, and they can leak information from within a victim memory address space <ref type="bibr" target="#b33">[34]</ref> when combined with other techniques.</p><p>Cache and other microarchitectural attacks pose a great threat and consequently, different techniques have been proposed for their detection and/or mitigation <ref type="bibr" target="#b15">[16]</ref>. Among these proposals, hardware countermeasures take years to integrate and deploy, may induce performance penalties and currently, we are not aware of any manufacturer that has implemented them. Other proposals are meant for cloud hypervisors <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b55">56]</ref> and require making small modifications to the kernel configuration. Similarly, to the best of our knowledge, no hypervisor implements them, presumably due to the overhead they entail.</p><p>As a result, the only solution that seems practical for users that want to protect themselves against this kind of threat, is to detect ongoing attacks and then react in some way. To this end, several proposals <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b48">49,</ref><ref type="bibr" target="#b63">64]</ref> use hardware performance counters (HPCs) to detect ongoing microarchitectural attacks. These counters are special registers available in all modern CPUs that monitor hardware events such as cache misses. Some of these proposals are able to detect even attacks that were specially designed to bypass other countermeasures <ref type="bibr" target="#b19">[20]</ref>. The common assumption in these works is that the attacker induces measurable effects on the victim. We, on the contrary, demonstrate that it is possible to obtain information from the victim while keeping its data in the cache and, consequently, not significantly altering its behavior, thus making attack detection harder.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association 29th USENIX Security Symposium 1967</head><p>Our Contribution: We analyze the replacement policy of current Intel CPUs and identify a new strategy that allows an attacker to monitor cache set accesses without forcing evictions of the victim 's data, thereby creating a new and stealthier cache-based microarchitectural attack. To achieve this goal, we perform the first full reverse engineering of different replacement policies present in various generations of Intel Core processors. We propose a technique that can be extended to study replacement policies of other processors. Using this technique, we demonstrate that it is possible to accurately predict which element of the set will be replaced in case of a cache miss. Then, we show that it is possible to exploit these deterministic cache replacement policies to derive a sophisticated cache attack: RELOAD+REFRESH, which is able to monitor the memory accesses of the desired victim without generating LLC misses. We analyze the covert channel that this attack creates, and demonstrate that it has similar performance to state-of-the-art attacks, with a slightly decreased temporal resolution. As a proof of concept, we demonstrate how RELOAD+REFRESH works by retrieving the key of a T- <ref type="table">Table implementation</ref> of AES and attacking the square and multiply version of RSA. We verify that our attack has a negligible effect on LLC related events, which makes it stealthy for countermeasures monitoring the LLC behavior. Instead, the attack changes the behavior of L1/L2 caches. Thus, our work stresses the need for detection mechanisms to also consider such events. Which, in turn, highlights the hardness of the performance counters set selection to detect all possible cache attacks, including ours and possible future attacks. To sum up, this work:</p><p>• introduces a methodology to test different replacement policies in modern caches.</p><p>• uncovers the replacement policy currently implemented in modern Intel Core processor generations, from fourth to eighth generation.</p><p>• expands the understanding of modern caches and lays the basis for improving traditional cache attacks.</p><p>• presents RELOAD+REFRESH, a new attack that exploits Intel cache replacement policies to extract information referring to a victim memory accesses.</p><p>• shows that the proposed attack causes negligible cache misses on the victim, which renders it undetectable by state-of-the-art countermeasures.</p><p>2 Background and related work</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Cache architecture</head><p>CPU caches are small banks of fast memory located between the CPU cores and the RAM. As they are placed on the CPU die and close to the cores, they have low access latencies and thus reduce memory access times observed by the processor, improving the overall performance. Modern processors include cache memories that are hierarchically organized; low level caches (L1 and L2) are core private, smaller and closer to the processor, whereas the last level cache (LLC or L3) is bigger and shared among all the cores. It is divided into slices interconnected by a ring bus. The physical address of each element determines its mapping to a slice by a complex addressing function <ref type="bibr" target="#b43">[44]</ref>. Intel's processors traditionally have included L3 inclusive caches: all the data which is present in the private lower caches has to be in the shared L3 cache. This approach makes cache coherence much easier to implement. However, presumably due to cache attacks, the newest Intel Skylake Server micro architecture uses a non-inclusive Last Level Cache <ref type="bibr" target="#b23">[24]</ref>.</p><p>In most modern processors caches are W -way setassociative. The cache is organized into multiple sets (S), each of them containing W lines of usually 64 bytes of data. The set in which each line is placed is derived from its address. The address bits are divided into offset (lowest-order bits used to locate data within a line), index (log 2 (S) consecutive bits starting from the offset bits that address the set) and tag (remaining bits which identify if the data is cached).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Cache replacement policies</head><p>When the processor requests some data, it first tries to retrieve this data from the cache (it starts looking in the lowest levels up to the last level). In the event of a cache hit, the data is loaded from the cache. On the contrary, in the event of a cache miss, the data is retrieved from the main memory and it is also placed in the cache assuming that it will be re-used in the near future. If there is no free space in the cache set, the memory controller has to decide which element in the cache has to be evicted. Since the processor may stall for several cycles whenever there is a cache miss, the decision of which data is evicted and which data stays is crucial for the performance.</p><p>Many replacement policies are possible including, for example, FIFO (First in First Out), LRU (Least Recently Used) or its approximations such as NRU <ref type="bibr" target="#b54">[55]</ref> (Not Recently Used), LFU (Least Frequently Used), CLOCK <ref type="bibr" target="#b28">[29]</ref>(keeps a circular list of the elements) or even pseudo-random replacement policies. Modern high-performance processors implement approximations to LRU, because a truly LRU policy is hard to implement, as it requires complex hardware to track each access.</p><p>LRU or pseudo-LRU policies have demonstrated to perform well in most situations. Nevertheless, LRU policy behaves poorly for memory-intensive workloads whose working set is bigger than the available cache size or for scans (bursts of one-time access requests). As a result, adaptive algorithms, which are capable to adapt themselves to changes in the workloads, have been proposed. In 2003, Megiddo el al. <ref type="bibr" target="#b44">[45]</ref> proposed ARC (Adaptive Replacement Cache) a hybrid of LRU and LFU. One year later, Bansal et al. <ref type="bibr" target="#b8">[9]</ref> presented their solution based on LFU and CLOCK, which they named CAR (Clock with Adaptive Replacement).</p><p>In 2007 Quereshi et al. <ref type="bibr" target="#b50">[51]</ref> suggested that performance could be improved by changing the insertion policy while maintaining the eviction policy. LIP (LRU Insertion Policy) consists in inserting each new piece of data in the LRU position whereas BIP (Bimodal Insertion Policy) most of the times places the new data in the LRU position and sometimes (in-frequently) inserts it in the MRU position. In order to decide which of the two policies behaves better, they proposed a dynamic insertion policy (DIP). DIP chooses between LIP and BIP depending on which one incurs fewer misses.</p><p>In 2010, Jaleel et al. <ref type="bibr" target="#b30">[31]</ref> proposed a cache replacement algorithm that makes use of Re-reference Interval Prediction (RRIP). By using 2 bits per cache line, RRIP predicts if a cache line is going to be re-referenced in the near future. In case of eviction, the line with the longest interval prediction will be selected. Analogously to Quereshi et al., they presented two different approaches: Static RRIP (SRRIP) which inserts each new block with an intermediate re-reference, and Bimodal RRIP (BRRIP) which inserts most blocks with a distant re-reference interval and sometimes with an intermediate re-reference interval. They also proposed using set dueling to decide which policy fits better for the running application (Dynamic RRIP or DRRIP).</p><p>Regarding Intel processors, their replacement policy is known as "Quad-Age LRU" <ref type="bibr" target="#b29">[30]</ref> and it is undocumented. The first serious attempt to reveal the cache replacement policy of different processors was made by Abel et al. <ref type="bibr" target="#b0">[1]</ref>. In their work, they were able to uncover the replacement policy of an Intel Atom D525 processor and to infer a pseudo-LRU policy in an Intel Core 2 Duo E6300 processor. They later complemented their original work <ref type="bibr" target="#b1">[2]</ref> and found a model that explained the eviction policy in other machines (Intel Core 2 Duo E6750 and E8400). Later on, Wong <ref type="bibr" target="#b59">[60]</ref> showed that Intel's Ivy Bridge processors indeed implement a dynamic insertion policy as suggested in previous proposals <ref type="bibr" target="#b30">[31,</ref><ref type="bibr" target="#b50">51]</ref>. He was able to identify the regions that apparently had a fixed policy by measuring the average latency of the accesses to arrays of different sizes and provided some test code. Such regions were similarly observed by us in our experiments ( <ref type="figure" target="#fig_1">Figure 3</ref>). These works have in common that the authors perform different sequences of memory accesses, and use a mechanism to estimate/measure the number of misses and later compare their measurements with the expected misses. However, they did not explain which concrete element in the cache would be evicted in the event of a miss.</p><p>Gruss et al. <ref type="bibr" target="#b18">[19]</ref> studied cache eviction strategies on recent Intel CPUs in order to replace the clflush instruction and build a remote Rowhammer attack. As they mention, their work is not strictly a reverse engineering of the replacement policy, rather they test access patterns to find the best eviction strategy. In a work concurrent to ours, Vila et al. <ref type="bibr" target="#b56">[57]</ref> tried to evaluate the influence of the replacement policy when obtaining the eviction set. Their results also show that some processors include adaptive policies whereas others do not.</p><p>To the best of our knowledge, our work is the first one that provides a comprehensive description of the replacement policies implemented on modern Intel processors up to the point that we are able to accurately determine which element of the set would be evicted using the information about the sequence of accesses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Cache attacks</head><p>Cache attacks monitor the utilization of the cache (the sequence of cache hits and misses) to retrieve information about a co-resident victim. Whenever the pattern of memory accesses of a security-critical piece of software depends on the actual value of sensible data, such as a secret key, this sensitive data can be deduced by an attacker and will no longer be private.</p><p>Traditionally, cache attacks have been grouped into three categories <ref type="bibr" target="#b15">[16]</ref>: FLUSH+RELOAD, PRIME+PROBE and EVICT+TIME. From those, the FLUSH+RELOAD and the PRIME+PROBE attacks (and their variants) stand over the rest due to their higher resolution.</p><p>Both attacks target the LLC, selecting one memory location that is expected to be accessed by the victim process. They consist of three stages: initialization (the attacker prepares the cache somehow), waiting (the attacker waits while the victim executes) and recovering (the attacker checks the state of the cache to retrieve information about the victim).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">FLUSH+RELOAD</head><p>This attack relies on the existence of shared memory. Thus, it requires memory deduplication to be enabled. Deduplication is an optimization technique designed to improve memory utilization by merging duplicate memory pages. Using the clflush instruction the attacker removes the target lines from the cache, then waits for the victim process to execute (or an equivalent estimated time) and finally measures the time it takes to reload the previously flushed data. Low reload times mean the victim has used the data.</p><p>It was first introduced in <ref type="bibr" target="#b21">[22]</ref>, and was later extended to target the LLC to retrieve cryptographic keys, TLS protocol session messages or keyboard keystrokes across VMs <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b60">61]</ref>. Further, Zhang et al. <ref type="bibr" target="#b64">[65]</ref> showed that it was applicable in several commercial PaaS clouds.</p><p>Relying on the clflush instruction and with the same requirements as FLUSH+RELOAD, Gruss et al. <ref type="bibr" target="#b19">[20]</ref> proposed the FLUSH+FLUSH attack. It was intended to be stealthy and bypass existing monitoring systems. This variant recovers the information by measuring the execution time of the clflush instruction instead of the reload time, thus avoiding direct cache accesses and, as a consequence, detection. However, some works <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b35">36]</ref> consider its effect also on the victim's side and succeed in its detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">PRIME+PROBE</head><p>Contrary to the FLUSH+RELOAD attack, PRIME+PROBE is agnostic to special OS features in the system. Therefore, it can be applied to virtually every system. Moreover, it can recover information from dynamically allocated data. To do so, the attacker first fills or primes the cache set in which the victim data will be placed with its own data (initialization stage). Then, he waits and finally probes the desired set looking for time variations that carry information about the victim activity.</p><p>This attack was first proposed for the L1 data cache in <ref type="bibr" target="#b47">[48]</ref> and was later expanded to the L1 instruction cache <ref type="bibr" target="#b5">[6]</ref>. These approaches required both victim and attacker to share the same core, which diminishes practicality. However, it has been recently shown to be applicable to LLC. Researchers have bypassed several difficulties to target the LLC, as retrieving its complex address mapping <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b61">62]</ref>, and recovered cryptographic keys, keyboard typed keystrokes <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b37">38]</ref> or even a RSA key in the Amazon EC2 cloud <ref type="bibr" target="#b22">[23]</ref>.</p><p>In case a defense system tries to either restrict access to the timers <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b41">42]</ref> or to generate noise that could hide timing information, cache attacks are less likely to succeed. The PRIME+ABORT attack <ref type="bibr" target="#b13">[14]</ref> overcomes this difficulty. It exploits Intel's implementation of Hardware Transactional Memory (TSX) to retrieve the information about cache accesses. It first starts a transaction to prime the targeted set, waits and finally it may or may not receive and abort depending on whether the victim has or has not accessed this set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Countermeasures</head><p>Researchers have tackled the problem of mitigating cache attacks from different perspectives. Several proposals suggest limiting the access to the shared resources that can be exploited to infer information about a victim by modifying the underlying hardware <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b57">58]</ref>. System-level software approaches, on the other hand, require modification of the current cloud infrastructure or the Linux kernel. STEALTHMEM <ref type="bibr" target="#b31">[32]</ref> uses private virtual pages that ensure the data located in them is not evicted from the cache and avoid mapping any other page with these private virtual pages. CATalyst <ref type="bibr" target="#b39">[40]</ref> uses Intel Cache Allocation Technology (CAT), which is a technology that enables system administrators to control how cores allocate data into the LLC. CACHEBAR <ref type="bibr" target="#b65">[66]</ref> designs a memory management subsystem that dynamically changes the number of lines per cache set that a security domain can occupy to defeat PRIME+PROBE attacks and changes the state of the pages to avoid FLUSH+RELOAD. As we have already stated, we are not aware of any CPU manufacturer, cloud provider or OS implementing them.</p><p>A different approach to protect sensitive applications is to specifically design them to be secure against side-channels (no memory accesses depend on private information). Developers can use specific tools <ref type="bibr" target="#b58">[59,</ref><ref type="bibr" target="#b62">63]</ref> to ensure the binary of such applications does not leak information, even if it is under attack. There are other tools, such as MASCAT <ref type="bibr" target="#b26">[27]</ref>, which use code analysis techniques to detect potential attacks before running a program. This kind of tools is effective before malware distribution or execution, but their effectiveness is reduced in cloud environments where the attacker does not need to infect the victim.</p><p>For these reasons, we believe that the only countermeasures that an attacker may have to face when trying to retrieve information from a victim, are detection based countermeasures that can be implemented at user level. Cache attacks exploit the side effects of running a program in certain hardware to gain information from it, and similarly, these countermeasures employ monitoring mechanisms to observe these effects. Detection systems can use time measurements <ref type="bibr" target="#b11">[12]</ref>, hardware performance counters <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b63">64]</ref> or place data in transactional regions <ref type="bibr" target="#b17">[18]</ref> defined with the Intel TSX instructions. These detection systems measure the effect of the last level cache misses on the victim or on both the victim and the attacker. As a consequence, an attack that does not generate cache misses on the victim's side would be undetectable by these systems.</p><p>Detection systems that use performance counters as a source of information to infer anomalies in the execution of a program, are limited by the number of counters that can be monitored simultaneously. This number varies between processors, but implies that such counters must be carefully selected. As our work shows, although the monitoring approach can still consider more counters, it is limited and can not be arbitrarily extended to detect upcoming attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Retrieval of Intel cache eviction policies</head><p>This work focuses on the LLC. Since it is shared across cores, the attacks targeting the LLC are not limited to the situation in which the victim and the attacker share the same core. It is also possible to extract fine-grained information from the LLC and many researchers are concerned about the attacks targeting the LLC. Attacks that assume a pseudo LRU eviction policy such as PRIME+PROBE or EVICT+RELOAD can benefit from detailed knowledge of the eviction policy, and can also benefit one attacker wishing to carry out a "stealthy" attack that does not cause cache misses on the victim.</p><p>In order to study the eviction policy, we try to emulate the hardware in software. We ensure that we can fill one set of the cache with our own data, access that data and force a miss when desired, to observe which element of the set is evicted. Thus, we have constructed an eviction set (a group of w different addresses that map to one specific set in w-way set-associative caches) and what we call a conflicting set (a second eviction set that maps to exactly the same set and is composed of disjoint addresses). Previous works have retrieved the complex addressing function <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b43">44,</ref><ref type="bibr" target="#b61">62]</ref> or demonstrate how to create the aforementioned sets dynamically <ref type="bibr" target="#b14">[15]</ref>. When the number of cores in our test systems is a power of 2, we compute the set and slice number using the hash function in <ref type="bibr" target="#b43">[44]</ref> and use that information to construct the eviction and conflicting sets. In the remaining situations such sets were constructed following the procedure proposed by <ref type="bibr">Liu et al.</ref> in <ref type="bibr" target="#b14">[15]</ref> (Algorithm 1).</p><p>For all the experiments, we have enabled the use of hugepages in our systems. Note that the order of the accesses is important to deduce the eviction policy. We enforce this order using lfence instructions, which act as barriers that ensure all preceding load and store instructions have finished before any load or store instruction that follows lfence. We have observed that mfence does not always serialize the instruction stream, that is, it does not completely prevent out of order execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Design of the experiments Algorithm 1 Test of the desired eviction policy</head><p>Input: Eviction_set, Conflicting_set Output: Accuracy of the policy hits/trials function TESTPOLICY(eviction_set, conflicting_set) hits = 0; while i ≤ num_experiments do j = 0,i++; control_array ← {}; address_array ← {}; initialize_set(); Fills address and control arrays lim = random(); while j ≤ lim do lfence; j++; next_data = eviction_set[random()]; measure time to read next_data; if time ≥ ll_threshold then LLC access update(control_array, next_data); con f _element = con f licting_set[random()]; read(con f _element);</p><p>Force miss candidate=getEvictionCandidate(); if (testDataEvicted() ==candidate) then hits++; return hits/num_experiments; We have performed experiments in different machines, each of them including an Intel processor from different generations. <ref type="table" target="#tab_0">Table 1</ref> presents a summary of the machines employed in this work. It includes the processor name, its number of cores, the cache size and associativity and the OS running on each machine. We have started by studying the processors of the fourth generation, which have been a common victim of published PRIME+PROBE attacks. We have extended our analysis to cover processors from fourth to eighth generation.</p><p>Before conducting the experiments to disclose the eviction policy implemented in each of the used machines, we have performed some experiments intended to verify that no cached data is evicted in the event of a cache miss if there is free room in the set. The procedure is quite straightforward: for each of the sets, we first completely fill it with the data on its corresponding eviction set. Next, we randomly flush one of these lines to ensure there is free room in the set, and we access one of the lines in the conflicting set checking that it is indeed loaded from main memory (cache miss). Finally, we make sure that all the lines in the eviction set (except for the one evicted) still reside in the cache by measuring times when re-accessing them. As expected, in all cases the incoming data was loaded in replacement of the flushed line.</p><p>The procedure we propose to retrieve the replacement policy, compares the actual evolution of the data in each of the sets with its theoretical evolution defined by an eviction policy during the runtime. Algorithm 1 summarizes this procedure. Each of the policies that has been tested had to be manually defined. We have evaluated true LRU, Tree PLRU, CLOCK, NRU, Static and Bimodal RRIP, self-defined policies using four control bits, etc. among many other possible cache eviction policies. After multiple experiments, we conclude that the policy implemented on the processors corresponds to the policy which best matches the experimental observations. Algorithm 1 tries to emulate by software the behavior of the hardware (of the cache). For this purpose, it uses two arrays of size W . On the one hand, address_array mimics the studied set, storing the memory addresses whose data is in the cache set. On the other hand, control_array contains the control bits used for deciding which address will be evicted in case of conflict. Additionally, we need to manually define one function that updates the content of the address_array, one function that updates the control_array and another one that provides the eviction candidate i.e. it returns the address of the element that will be evicted in case of conflict. These functions are defined based on the tested replacement policy.</p><p>Note that for all the experiments the initialize_set() function makes sure that the tested set is empty (by filling it and then flushing all the elements that it holds) and later fills this set with all the elements in the eviction set. That is, the address_array contains the set of addresses of the eviction set with their corresponding control bits initialized.</p><p>To set an example, we assume we want to test the NRU policy <ref type="bibr" target="#b54">[55]</ref>, which turns out to match the policy implemented in an Intel Xeon E5620 according to our experiments. According to its specification, NRU uses one bit per cache line, this bit is set whenever a cache line is accessed. If setting one bit implies that all the bits of a cache set will be equal to one, then all the bits (except for the one that has just being accessed) will be cleared. In case of conflict, NRU will remove from the cache one element whose control bit is equal to zero. Thus, in our procedure, the control bits would be -1 (line empty), 0 (line not recently used), and 1 (line recently used). When a memory line is accessed, the update function first checks if its address is already included in the address_array. If it is not, our function will add it to the address_array and set the corresponding bit in the control_array. On the contrary, the function only updates the values of the control_array. The getEvictionCandidate function will return one array position whose control bit value is -1, or, if no control bit is equal to -1, one whose control bit is equal to 0. In case multiple addresses have control bits equal to -1 or to 0, the function will return the first address whose control bits are -1 or 0, that it encounters when traversing the control_array from the beginning. Finally, after forcing a cache miss, the testDataEvicted() checks if the element evicted is the predicted by the NRU policy (the output of getEvictionCandidate).</p><p>We have noticed that only accesses to the LLC update the values of the control bits of the accessed element. That is, if the data is located in L1 or L2 caches when requested (reload time lower than ll_threshold), we do not update the values in the control_array. <ref type="figure" target="#fig_0">Figure 1</ref> shows the distinction between accesses to low and last level caches based on reload times observed in the i7-4790 machine and validated with performance counters. The value of the ll_threshold varies between the different machines and requires calibration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Results</head><p>The outcomes of our experiments highlight some differences in the cache architecture of the machines, as also noticed in <ref type="bibr" target="#b13">[14]</ref>. Traditionally, the number of slices of the cache used to be equal to the number of physical cores of the machine. This is true for the 4th and 5th generation processors. On the contrary, the newest ones have as many slices as virtual cores; that is, two times the number of physical cores. Cache sizes are similar, so they also differ in the number of sets per slice (2048 vs 1024).</p><p>Since several policies and previous works <ref type="bibr" target="#b59">[60]</ref> suggest that different sets perform differently, we have repeated the experiment in Algorithm 1 for each of the sets in the last level cache. As a result, we have found out that apparently only the machines from the 4th and 5th generation implement set dueling to dynamically select the eviction policy. We conducted several further experiments intended for determining which sets implement a fixed policy and which others change their policy based on the number of hits and misses. Locating the sets with a fixed policy is interesting for various reasons: these sets will allow us to accurately determine the two different replacement policies, and they will allow favoring one policy over the other depending on our interests. This also means that monitoring one set belonging to the group of followers, gives information about which policy is currently operating.</p><p>The strategies for locating the sets included different access patterns that would lead to a different number of misses. For example, we have simulated bursts by accessing the eviction set in an ordered way, then the whole conflicting set, and finally re-accessing the eviction set. The observed number of misses depends on the policy. Pseudo LRU policies evict all the data in the eviction set after accessing the elements in the conflicting set. Whereas other policies intended for good performance in these situations (burst accesses to memory) cause fewer misses. As a result, we have located two regions composed of 64 cache sets in each slice that control each policy as did Wong before <ref type="bibr" target="#b59">[60]</ref>. <ref type="figure" target="#fig_1">Figure 3</ref> represents all the sets of a cache slice with the control regions. The region coloured in blue controls the policy 1, and the region coloured in red controls the policy 2. Except for the Xeon machine, where these regions are located in sets 1024-1088 and 1280-1344, the remaining machines are consistent with <ref type="figure" target="#fig_1">Figure 3</ref>.</p><p>Not all the sets within the aforementioned regions implement a fixed policy. Particularly, only one of the sets in each slice controls one policy. This fact was observed and discovered after multiple experiments with different patterns. The sets with a fixed policy for each of the slices are depicted in <ref type="figure" target="#fig_2">figure 4</ref>. In processors with two slices, these control sets also alternate between slices. As a result each slice has 32 control sets. To obtain the actual control sets within the slice, it is important to test the sets and slices without order, otherwise it may seem that some sets have a fixed policy and they do not.</p><p>The policy we will uncover is the one implemented in the L3 cache. The policies implemented in the L1 and L2 caches can be different (actually, in L1 is different). We have been able to uncover a policy that seems to explain the observed evictions. In fact, over 97% of the evictions have been correctly predicted in all cases 1 , and it is likely that the errors were due to noise.</p><p>Although we have observed differences between generations and some machines implement set dueling, the decision of which data is going to be evicted is the same in all cases. The replacement policy is always the same; what changes is the insertion policy. Due to space limitations and to avoid creating confusion, we only include here the description of the policies revealed by our experiments as the ones implemented in the Intel processors. Assuming that the policy is named Quad-Age LRU, in the following we refer to ages instead of control bits. <ref type="figure">Figure 2</ref> represents the procedure followed to retrieve a piece of data when requested by the processor. It summarizes the replacement policy and our observations. If the data is retrieved from the LLC, the controller decreases the age of the requested element when giving it to the processor. If there is a cache miss and one element has to be evicted, the replacement policy will select the oldest one.</p><p>Intel's processors use two bits to represent the age of the elements in the cache. Consequently, the maximum age is three. In the case that there are multiple blocks whose age is three, the evicted one is the first one the processor finds. The cache behaves somehow like an array of data, and when searching for a block of data placed on it, the controller always starts from the same location, which would be equivalent to index 0 in an array. We have observed that when all the elements in a set reach age 0, the age of all of them is incremented so the processor is still able to track the accesses.</p><p>As we have already stated, the machines used in our experiments only differ in the insertion age; that is, the initial value for the age of a cache line when it is first loaded into the set or when it is reloaded after a cache miss. Particularly, the processors from 4th and 5th generations that implement set dueling, insert the elements with age 2 in one of the cases and with age 3 in the other. We denote each of these situations or working modes as mode 1 and mode 2, respectively. The remaining processors (6th, 7th and 8th generations) always insert the blocks with age 2, which is equivalent to the mode 1 in the previous generations.</p><p>In order to help the reader to understand how the cache works, <ref type="figure">figure 5</ref> shows an example of how the contents of a cache set are updated with each access according to each policy. When the processor requests the line "d", there is an empty block in the set, so "d" is placed in that set and it gets age 2 (Mode 1) or age 3 (Mode 2). In mode 1, the eviction candidate is now "a" because it is the only one with age 3, whereas in mode 2 the eviction candidate is "d" as it has age 3 and is on the left of "a". The processor then requests "d", so its age decreases from 2 to 1 in both cases. Accessing "g" causes a miss. The aforementioned eviction candidates will be replaced with "g", and its age will be set to 2 or 3 respectively. Eventually, when the processor requests "a", it will cause a miss in mode 1 (it was evicted on the previous step) and a hit in mode 2, so it will decrease its age. Note that in this example, we assume that all the requests are directly made to the last level cache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RELOAD+REFRESH</head><p>If any kind of sharing mechanism is implemented, an attacker knowing the eviction policy can place some data that the victim is likely to use in the cache (the target) and in the desired position among the set. Since the position of the blocks and their ages (which in turn depend on the sequence of memory accesses) determine the exact eviction candidate, the attacker can force the target to be the eviction candidate. If the victim uses the target it will no longer be the eviction candidate, because its age decreases with the access. The attacker can force a miss and check afterwards if the target is still in the cache. If it is, the attacker retrieves the desired information, that is, the victim has used the data whereas victim has loaded the data from the cache without suffering any cache misses (no attack trace). This is the main idea of the RELOAD+REFRESH attack.</p><p>OSs implement mechanisms such as Kernel Same-page Merging (KSM) in <ref type="bibr">Linux [8]</ref> that improve memory utilization by merging multiple copies of identical memory pages into one. This feature was originally designed for virtual environments where multiple VMs are likely to place the same data in memory, and was later included in the OSs.</p><p>Although most cloud providers have disabled it, it is still enabled in multiple OSs. When enabled, the attacker using the RELOAD+REFRESH technique needs some reverse engineering to retrieve the address he wants to monitor, and he also needs to find an eviction set that maps to the same set as this address.</p><p>We use <ref type="figure" target="#fig_4">Figure 6</ref> to depict the stages of the attack and the possible "states" of the cache set. The attacker first inserts the target address into the cache and then all the elements in the eviction set, except one, which will be used to force an eviction. By the time the attacker has finished filling the cache with data, the target address will be in level 3 cache. The number of ways in low level caches is lower than the number of ways in the L3 cache, and since the L3 cache is inclusive, it will remove the target address from the low level caches when loading the last elements of the eviction set. Even if the victim and the attacker are located in the same core, an access of the victim to the target address will update its age, so the attacker would be able to retrieve this information.</p><p>The data is placed in such a way that the target becomes the eviction candidate. The attacker then waits for the victim to access the target. If it does, the element inserted in the second place turns into the oldest one, and thus into the eviction candidate. If it does not, the eviction candidate is still the target address. The attacker then reads the element of the eviction set (ev W −1 ) that remains out of the cache, forcing this way a conflict in the cache set, and the eviction of the candidate. As a consequence, when reading (RELOAD) the target address again, the attacker will know if the victim has used the data (low reload time) or not (high reload time). The state of the cache has to be reverted to the initial one, so all the elements get the same age again (REFRESH). The element ev W −1 is forced out of the cache, so it could be used to create a new conflict on the next iteration.</p><p>When the cache policy is working in mode 2, each element is inserted with age 3. In this case, steps 1 to 5 are equivalent. However, step 6 changes depending on whether the victim is allocated in the same core as the attacker or not. When not, the other elements have age 3 and the target is the eviction candidate, so there is no need to refresh the data for the attack. On the other hand, when they are on the same core, the attacker needs to remove the target from the low level caches by refreshing the other elements in the cache set. Note that in this situation, the attacker could target the low level caches. The RELOAD time reveals if both victim and attacker are sharing the same core or not.</p><p>Additionally, the mode 2 policy enables a detectable fast cross core cache attack that does not require shared memory. Once the cache set is filled with the attacker's data, all the elements get age 3 and the eviction candidate is now the first element inserted by the attacker. If the victim uses the expected data, the eviction candidate will be replaced. Even if the victim uses the data multiple times, its age will not change, since it will be fetched from the low level caches. Then, the   <ref type="figure">Figure 5</ref>: Sequence of data accesses in a cache set updating their content and their associated ages for the two observed policies. Mode 1 of the 4th and 5th generations behaves exactly the same as the 6th, 7th and 8th generations. The red arrow points the eviction candidate, that is, the data that would be evicted in case of cache miss.</p><p>attacker only has to access the first element (eviction candidate) to check whether the victim has or has not accessed the target data. Note that with this access the attacker replaces the victim's data (because it became the eviction candidate when loaded with age 3) so it is equivalent to the REFRESH. If, on the contrary, the victim does not use the data, the attacker's data will still be in the cache. The attacker will then flush and reload this data to ensure it gets age 3 again.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 Reload function</head><p>Input: Eviction_set, Target_address Output: Reload time function RELOAD(Target_address,eviction_set) "rdtsc"; "lfence"; read(eviction_set[w − 1]); Forces a miss "lfence"; f lush(eviction_set[w − 1]); "lfence"; read(Target_address); f lush(Target_address); "lfence"; read(Target_address);</p><p>Reload on first position "lfence"; "rdtsc"; read(eviction_set <ref type="bibr">[0]</ref>); return time_reload; Algorithms 2 and 3 summarize the steps of the RELOAD+REFRESH attack when the insertion age is two (newest Intel generations or mode 1 in oldest generations). The cache set is filled with the target address plus W − 1 elements of the eviction set during initialization. Then, the attacker waits for the victim to run the code. Later, he performs the RELOAD and REFRESH steps. The RELOAD step gives information about the victim accesses and the RE-FRESH step gets the set ready to retrieve information from the victim. When initializing the set, we first fill the set, then flush the whole set and finally reload the data again to ensure the insertion order and that the cache state is known by us.</p><p>In the RELOAD function it is not necessary to flush the Target_address unless it has not been used by the victim. The same assumption is true for the conflicting address or the element W − 1 of the eviction set, which would have to be flushed only in that situation. However, to avoid if conditions in the code, we have chosen to implement the RELOAD function this way. Low reload times mean the data was used by the victim, whereas high reload times mean it was not.</p><p>The REFRESH function is meant for a 12 way set. Since the target and the first element of the eviction set have been loaded in the RELOAD step, the REFRESH function only has to access the remaining 10 elements of the set. To avoid out of order execution and ensure the order, which in turn ensures the ages of the elements in the eviction set are updated, such elements have to be accessed as a linked list (one element contains the address of the following one). Thus, this function is similar to the probe function in <ref type="bibr" target="#b14">[15]</ref> except for the fact that it loads W-2 elements of the linked list. Additionally, the refresh time can be used to detect if any other process is also using that set.</p><p>5) The attacker has to revert the changes. To ensure the Target gets age 2 and its placed in the "first" position, has to be flushed, as it has to be the Target, then the Target is reloaded and finally is loaded 3) The attacker forces a miss by reading . The evicted element depends on whether the victim had accessed (a) or not (b) the Target. T arget </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Noise tolerance</head><p>The proposed attack relies on the order in which the elements are inserted into the cache set to both avoid misses on the victim side and to learn information about the data that has been accessed. If other processes are running and using data that maps to the same cache slice (introducing noise), the efficiency of the attack can be lessened and also some detection mechanisms can be triggered. As mentioned before, the refresh step can reveal such situations. Then, the attacker can slightly change the approach. Assuming that only one address is being used by the noisegenerating process, the attacker can easily handle noise, avoid detection and still gain information about the victim. The trick to deal with noise is placing the target on a different place within the set (the second place in this example). In case somebody else uses any data mapping to that set, the replaced data belongs to the attacker; specifically it is the data placed in first place in the set. When the attacker forces a miss, the eviction candidate will be either the target address (if the victim did not use it) or the element inserted in third place (the victim did use the target data). The attacker can</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 3 Refresh function</head><p>Input: Eviction_set Output: Refresh time function REFRESH(Eviction_set) volatile unsigned int time; asm __volatile__( " lfence \n" " rdtsc \n" " movl %%eax, %%esi \n" " movq 8(%1), %%rdi \n" Eviction_set[1] " movq (%%rdi), %%rdi \n" " movq (%%rdi), %%rdi \n" " movq (%%rdi), %%rdi \n" " movq (%%rdi), %%rdi \n" " movq (%%rdi), %%rdi \n" " movq (%%rdi), %%rdi \n" " movq (%%rdi), %%rdi \n" " movq (%%rdi), %%rdi \n" " movq (%%rdi), %%rdi \n" " movq (%%rdi), %%rdi \n" Eviction_set[w-2] " lfence \n" " rdtsc \n" " subl %%esi, %%eax \n" Time value on %eax ); return time_re f resh;</p><p>gain information about the victim by reloading the target address, and he must begin by refreshing the third element of the eviction set and finish with the first one which will evict the "noise" from the cache, so the age of all the blocks is set to 2 again.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Comparison with previous approaches</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Covert channel</head><p>In order to study the resolution of the proposed technique and to characterize it, as well as to compare it with previous approaches (FLUSH+RELOAD and PRIME+PROBE) we construct a covert channel between two processes (referred as sender and receiver) in a similar way as previous works have done <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b42">43]</ref>. <ref type="bibr" target="#b1">2</ref> The sender transmits a 1 by accessing a memory location from a shared library and a 0 by not-accessing it. Once the memory location is accessed, he waits for a fixed time and reads that data again. The receiver monitors the cache utilization using each of the aforementioned techniques and determines whether a 1 or a 0 was transmitted. That is, whether the victim has used the data or not. The sender and the receiver are not synchronized.</p><p>In each of the experiments executed, the sender reads the target memory location once during each fixed window of time. That is, it accesses one memory location (sends 1) and then waits (transmits 0) for a fixed time before the following access. We consider as true positives when the sender accesses a piece of data and the receiver detects that access. Similarly, true negatives are non-accesses that are classified as 0. In some situations, the processor appears to be performing other tasks that do not allow the retrieval of information. Since we do not get these samples, we cannot classify them and we do not consider them for evaluation.</p><p>The PRIME+PROBE attack can be conducted following different approaches. We do not use the zig-zag pattern that was intended to avoid changes in the replacement policy <ref type="bibr" target="#b14">[15]</ref>. Accessing the elements in a cache set this way increases the number of false positives since it sometimes fails to remove the data from the cache. We access the eviction set of size W always in the same order, and the elements are accessed as a linked list. If the initial state of the cache is known, this means that at most we need 2 probes to evict the data from the cache, in the case when the access to the target happens in the middle of a probing stage. We have also tested the proposal of Gruss et al. <ref type="bibr" target="#b19">[20]</ref> with the configuration parameters S=W , C=2 and D=2. This approach is faster than accessing the elements in the eviction set as a linked list and thus, presents better time resolution. In scenarios where victim and attacker do not interfere with each other (such as the attack against AES in section 5.2), the eviction rate of this approach is around 99%. However, in a different scenario where interference is possible, as in the case of the attack against RSA (section 5.3) or when the interval between monitored accesses is low, the number of false positives slightly increases with this approach. In any case, both approaches yield to comparable results. We include in this and the following subsections, results referring to the PRIME+PROBE attack when the eviction set is accessed as a linked list.</p><p>The results of these experiments in terms of the F-Score for each fixed time window are presented in <ref type="table">Table 2</ref>. These experiments were performed in the i5-7600K machine (Table 1). The statistics for each waiting time are computed for 50000 windows. As a result, the number of samples collected for each experiment is different. Note that when the waiting time between samples is low, both PRIME+PROBE and RELOAD+REFRESH are not able to distinguish between 1 and 0. PRIME+PROBE presents a slightly better resolution in our test system. Note that, in this case, we sometimes do not get two samples for each window (access and idle), we do not consider as false positives the samples classified as 1 in that window.</p><p>Even when RELOAD+REFRESH has lower resolution than other attacks, it can be used to retrieve secret keys of cryptographic implementations. We demonstrate this statement and replicate two published attacks: one against the T-Table implementation of AES (section 5.2) and one against <ref type="table">Table 2</ref>: F-Score for the different attacks when the sender accesses the data at different and fixed intervals (ns). R+R stands for RELOAD+REFRESH F+R for </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Attacking AES</head><p>The T-Table implementation used to be a popular software implementation of AES. While still available, this implementation is not the default option when compiling the OpenSSL library due to its susceptibility to microarchitectural attacks. This implementation replaces the SubBytes, ShiftRows and MixColumns operations with table lookups (memory accesses) and XOR operations. Since the accesses to the T-Tables depend on the secret key, an attacker monitoring just one line of each T-Table is able to recover the full AES key. Our scenario is similar to the one described by Irazoqui et al. <ref type="bibr" target="#b6">[7]</ref>, which was later replicated by Briongos et al. <ref type="bibr" target="#b10">[11]</ref>. They focused on retrieving information about the last round of the AES encryption process, in which the ciphertext is obtained by performing one XOR operation between an element contained in the tables and the secret key. As the content of the tables is publicly available from the source code, they obtained the secret final round key by xoring the table content hold in the cache line, with the ciphertext.</p><p>Besides performing the attack against the AES T-Table implementation (OpenSSL 1.0.1f compiled with gcc and the no-asm and no-hw flags) using the RELOAD+REFRESH (R+R) technique, we have performed the same attack using the FLUSH+RELOAD (F+R) and PRIME+PROBE (P+P) techniques, to provide a fair comparison regarding the number of traces required to obtain the key. In order to retrieve the whole key, the attacker has to monitor at least one line of each T- <ref type="table">Table.</ref> The attacker can monitor from one up to four lines at a time. For this comparison, we monitor one table at a time. <ref type="table">Table 3</ref> shows the results for each of the approaches. In this scenario, the attacker performs one operation, then the victim performs the encryption, and finally the attacker retrieves the information about the victim. That is, the victim and the attacker do not interfere with each other while doing the different operations. To obtain the key we use cache misses <ref type="bibr" target="#b10">[11]</ref>, so false positives are measured misses when the victim used the data in the T- <ref type="table">Table.</ref> We repeated each experiment until we have recovered the key 1000 times. <ref type="table">Table 3</ref>: Mean number of samples required to retrieve each four byte group of the whole AES key when monitoring one line per encryption, and the corresponding F-Score. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Attack</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Measurement of LLC misses</head><p>RELOAD+REFRESH is able to retrieve an AES key with a negligible impact on the victim process. We compare the number of L3 cache misses that the victim suffers per encryption performed, for all the attacks and for normal executions. We use the PAPI software interface <ref type="bibr" target="#b45">[46]</ref> to read the counters referring to the victim process. PAPI allows us to insert one instruction just before, and another one just after the encryption process ending to read the L3 cache misses counter, which is mainly the information used so far for cache attack detection <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b63">64]</ref>. <ref type="figure" target="#fig_6">Figure 7</ref> shows the resulting distribution of the number of misses the victim sees for each attack and for the normal execution of the encryption.</p><p>As implied by <ref type="figure" target="#fig_6">Figure 7</ref>, our attack cannot be distinguished from the normal performance of the AES encryption process by measuring the number of L3 cache misses. As we did for the analysis of the covert channel, when performing the PRIME+PROBE attack against AES, we access the data in the same order every time. The reason is that in previous experiments that we have conducted, the eviction rate we achieved with the zig-zag pattern was below 80% using just one probe per measurement.</p><p>Additionally, we use the rdtsc instruction to measure the time it takes to complete each encryption and show the results in <ref type="figure" target="#fig_7">Figure 8</ref>. The differences observed in <ref type="figure" target="#fig_7">Figure 8</ref> between the normal encryption and the RELOAD+REFRESH approach are not significant, especially when compared with the other attacks. The mean encryption time when there is no attack is 595 cycles, whereas it increases up to 623 cycles when attacked with the RELOAD+REFRESH technique. This time difference exists because, when suffering the RELOAD+REFRESH attack, the victim has to load the data (if used) from the L3 cache instead of loading it from the L1 or L2 caches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Attacking RSA</head><p>RSA is the most widely used public key crypto system for data encryption as well as for digital signatures. Its security is based on the practical difficulty of the factorization of the product of two large prime numbers. RSA involves a public key (used for encryption) and a private key (used for decryption). There are many algorithms suitable for computing the modular exponentiation required for both encryption and decryption. In this work we focus on the square and multiply exponentiation algorithm <ref type="bibr" target="#b16">[17]</ref> as Yarom et al. did <ref type="bibr" target="#b60">[61]</ref>. As in the case of AES, this implementation has been replaced by implementations with no key-dependent memory accesses that attempt to achieve constant execution times. Square and multiply computes x = b e mod m as a sequence of Square and Multiply operations that depend on the bits of the exponent e. If the bit happens to be a 1, then the Square operation is followed by a Multiply operation. If the bit is a 0, only a Square operation is executed. As a consequence, retrieving the sequence of operations executed means recovering the exponent; that is, the key.</p><p>As a difference with the attack against AES, we monitor instructions instead of data. Additionally, an attack against RSA needs to have enough time resolution to correctly retrieve the sequence of operations. As we did before, we performed the attack using our stealthy technique as well as using the FLUSH+RELOAD and PRIME+PROBE techniques.</p><p>The targeted crypto library is libgcrypt version 1.5.0, which includes the aforementioned square and multiply implementation. The key length in our experiments was 2048 bits, and we collected information for 1000 decryptions per attack. When attacking RSA, it is possible to monitor all the functions implied in the exponentiation or just one. When monitoring all the instructions, the attacker is able to reconstruct the sequence of observations. If the attacker monitors only one instruction, he has to use the differences of times between occurrences of the monitored event to retrieve the key. We only monitor the Multiply operation. <ref type="figure">Figure 9</ref> compares part of a trace retrieved using the RELOAD+REFRESH approach with the real execution of a RSA decryption operation (we collect timestamps). The trace corresponding to the real sequence of squares and multiplies is represented as blue bars with different values: 800 means a Square was executed and 700 it was a Multiply. The slight misalignment between the two traces occurs because the RSA execution timestamp is collected after each exponent bit has been processed, and the timestamp of the attack samples after the reload operation has finished.</p><p>The results of our experiments are summarized in table 4. As in the case of the characterization of the covert channel, we do not classify as false positive or false negative the samples that are lost, that is, not collected in time. This situation happens for about 1-2% of the samples. Since we try to detect Multiply operations, false positives refer to the situation in which a Multiply was detected but not executed. The accuracy is given as the number of correctly classified samples (True positives+True negatives) divided by the number of collected samples during the RSA decryption. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Measurement of LLC misses</head><p>We have monitored the number of cache misses detected when executing a complete RSA decryption. When trying different keys, we have observed that the distributions change not only depending on the attack, but on the secret key. For this reason, the total amount of misses per encryption cannot be used to detect ongoing attacks, thus the cache misses have to be measured concurrently with the execution of the decryption. We have also monitored the victim LLC misses periodically. We have collected samples for 1000 complete RSA decryptions in each of the scenarios with a sampling rate of 100 µs. The results obtained in this case show a varying number of misses during the initialization steps. During this initialization, considering exclusively the number of misses caused in the different scenarios, is not possible to distinguish between attacks and the normal operation. Later on, the number of misses gets stable and tends to zero during the normal operation. Similarly, this trend can be observed during the RELOAD+REFRESH attacks. On the contrary, both FLUSH+RELOAD and PRIME+PROBE cause a noticeable amount of misses. The concrete mean values of the misses are presented in <ref type="table" target="#tab_6">Table 5</ref>.</p><p>Since detection mechanisms such as CacheShield <ref type="bibr" target="#b9">[10]</ref>, define a region in with some misses are tolerated to avoid false positives, and only cache misses are considered, our attack will not trigger an alarm. <ref type="figure" target="#fig_0">Figure 10</ref> shows the section of the decryption process in which the number of misses has become stable for the different scenarios.</p><p>The RELOAD+REFRESH approach (as well as the other attacks) are not synchronized with the decryption operation, as a result, there are situations in which both victim and attacker can try to access the target date simultaneously. If the victim tries to execute the Multiply operation when the attacker is flushing and reloading the mentioned line, the victim may get a miss. Therefore, a few misses can be observed in <ref type="figure" target="#fig_0">Figure 10</ref> for our approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Detection evaluation</head><p>RELOAD+REFRESH causes a negligible amount of LLC misses on the victim process. Thus, existing detection techniques would fail to detect the attack unless adapted. Our attack highlights a problem that has not been considered before in performance-counter-based detection systems: the selection of counters is a hard problem because it is unknown if future attacks could similarly evade the concrete selection of counters of such systems. Besides, the number of available counters that can be read in parallel in each platform, is limited. As a consequence, detection systems cannot be arbitrarily expanded to deal with future attacks.</p><p>With the aim of quantifying the effect that our proposal has on the victim, and in order to provide some insights about which counters should a detection system consider to deal with RELOAD+REFRESH, we have periodically monitored different counters when executing the attacks against AES and RSA and analyzed the outcomes. We have used PAPI to collect such information. The sampling rate was set to 100 µs. Given that not all the counters can be read in parallel, we have repeated the experiments multiple times. We have merged the results when the sampling intervals were in a range defined by the expected value ± a 10% of this sampling value. In the particular case of RSA, the samples that refer to the beginning of the execution have been removed (we focus on the stable part). Finally, we have randomly selected 10000 samples per algorithm and attack to conduct the analysis. The results of the analysis are summarized in <ref type="table" target="#tab_6">Table 5</ref>. Note that L2 cache misses report the same value as L3 accesses, and similarly L1 misses are L2 accesses, so only one of these values is included in the <ref type="table">Table.</ref> As it can be inferred from the <ref type="table" target="#tab_6">Table 5</ref>, a single counter referring to L3 misses or accesses cannot be used to distinguish attacks and the normal operation for both target algorithms. In the particular case of L3 accesses, it could be used for RSA but not for AES. However, the L2 instruction misses counter, could distinguish between attacks and non-attacks for both algorithms. Note that if the sampling rate of the attack is reduced, the number of L2 misses would similarly be reduced. As a solution, this value could be normalized with respect to the total number of instructions executed. Real execution Retrieved data <ref type="figure">Figure 9</ref>: Example of a retrieved trace referred to an execution of a RSA decryption. The blue bars represent the real execution of squares (points equal to 800) and multiplies (700). The yellow line represents the information retrieved, low reload times mean detection of the Multiply execution.  <ref type="figure" target="#fig_0">Figure 10</ref>: Detail of a trace of misses measured each 100 µs for each of the approaches.</p><p>We can conclude that RELOAD+REFRESH changes the performance of the system in an observable way in the low level caches only. Consequently, counters referring to the LLC are not enough to detect RELOAD+REFRESH. Then, the assumption of previous detection mechanisms <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b63">64]</ref> that LLC misses or accesses reveal the attacks does not hold for RELOAD+REFRESH. Existing detection systems thus need to be adapted or re-trained to include additional information about low level cache events if they want to be able to detect it. However, relying on low level cache events to detect the attack can be tricky, since it is unknown how benign applications that share the machine with the victim affect it. Therefore, further analysis must be conducted to build a reliable detection system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Discussion of the results</head><p>The absence of randomness in the replacement algorithm makes it possible to accurately determine which of the elements located in a cache set will be evicted in case of conflict. Also, the accurate timers included in Intel processors, altogether with the cflush instruction, allow to trace accesses to the different caches and to force the cache lines to have the desired ages. We exploit these facts to run RELOAD+REFRESH. In turn, the fact that RELOAD+REFRESH works as expected, confirms some of our results about the replacement policy.</p><p>RELOAD+REFRESH is just one way to exploit the eviction policy assuming some kind of memory sharing mechanism enabled. In the case that the victim and the attacker do not share memory, our attack can be prevented. It could be prevented as well with some other general countermeasures against cache attacks that limit the sharing of resources. However, as mentioned in Section 4, RELOAD+REFRESH can be adapted to work in the absence of shared memory. We did not further explore this attack variant, as it requires to keep the replacement policy in Mode 2, which is also not available on the newest Intel processors.</p><p>The knowledge of the eviction policy enables the usage of a different access pattern to gain the information about the victim and to ensure that its data is really evicted from the cache, reducing the amount of false positives. Thus, PRIME+PROBE attacks, EVICT+RELOAD attacks or any attack requiring to evict some data from the cache can benefit from our results. For instance, the PROBE step can, in some cases, be reduced to just one access to the eviction candidate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>This work presented a thorough analysis of cache replacement policies implemented in Intel processors covering from 4th to 8th generations. To this end, we have developed a methodology that allows us to test the accuracy of different policies by comparing the data that each policy selects as the eviction candidate with the data truly evicted after forcing a miss.</p><p>The RELOAD+REFRESH attack builds on this deep understanding of the platforms replacement policy to stealthily exploit cache accesses to extract information about a victim. We have demonstrated the feasibility of our approach by targeting AES and RSA and retrieving as much information as we can retrieve with other state-of-the-art cache attacks. Additionally, we have monitored the victim while running these attacks to confirm that our attack causes a negligible amount of last level cache misses, rendering it impossible to detect with current countermeasures. Similarly, we show that events in the L1/L2 caches can reveal the attack and should be considered in detection systems. RELOAD+REFRESH underlines a flaw on such systems; they are limited and they do not scale.</p><p>These results are not only useful for broadening the understanding of modern CPU caches and their performance, but also for improving previous attacks and eviction strategies. Our work also demonstrates that new detection countermeasures have to be designed in order to protect users against RELOAD+REFRESH.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Distribution of the access times to different data. These times depend on which memory it was located.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 2: Diagram that represents the process of data (D) retrieval whenever the processor makes a request. The blocks with green background represent a cache hit, whereas the blocks with red background represent a cache miss.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Detailed representation of the sets with fixed policy within each of the slices for the i7-4790 machine.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Sequence of possible cache set states during the attack for the mode 1 or the newest generations, starting with all elements in the set with age 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>the square and multiply exponentiation implementation in- cluded in RSA (section 5.3). Although both implementations have been replaced by new ones, we use them for comparison.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Distribution of the number of misses induced in the victim process by the different attacks, and with no attack. Each includes 1 million of samples</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Distribution of the encryption times in different situations. Each distribution includes 1 million of samples.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><head>Table 1 : Details of the machines used in this work to retrieve their Replacement Policies</head><label>1</label><figDesc></figDesc><table>Generation 
Processor 
Number of cores Cache size Associativity 
OS 
4th 
i7-4790 
4 
8Mb 
16 
CentOS Linux 7 
4th 
i5-4460 
4 
6Mb 
12 
Kali Linux 2019.2 
4th 
i7-4770K 
4 
8Mb 
16 
Kali Linux 2019.2 
4th 
Xeon E3-1226 
4 
8Mb 
16 
CentOS Linux 7 
5th 
i3-5010U 
2 
3Mb 
12 
Ubuntu 14 
5th 
i5-5200U 
2 
3Mb 
12 
Kali Linux 2019.2 
6th 
i7-6700K 
4 
8Mb 
16 
Ubuntu 16 
6th 
i5-6400 
4 
6Mb 
12 
Kali Linux 2019.2 
6th 
i7-6567U 
2 
4Mb 
16 
Kali Linux 2019.2 
7th 
i5-7600K 
4 
6Mb 
12 
CentOS Linux 7 
7th 
i7-7700HQ 
4 
6Mb 
12 
Ubuntu 16 
7th 
i7-7700 
4 
8Mb 
16 
Kali Linux 2019.2 
8th 
i7-8650U 
4 
8Mb 
16 
Debian 9.5 
8th 
i5-8400 
6 
9Mb 
12 
Kali Linux 2019.2 
8th 
i7-8550U 
4 
8Mb 
16 
Kali Linux 2019.2 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>The attacker fills the set with the Target address and all the elements of the eviction set except one 2) The attacker waits. The next state of the cache depends on whether the victim accesses (a) or not (b) the target address</head><label></label><figDesc></figDesc><table>2 
2 
2 
2 
2 

ev 1 
ev 2 
ev w−2 

T arget 

ev 0 

1 
2 
2 
2 
2 

ev 1 
ev 2 
ev w−2 

ev w−1 

T arget 

ev 0 

1) 2 
2 
2 
2 
2 

ev 1 
ev 2 
ev w−2 

T arget 

ev 0 

a) 

b) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 4 :</head><label>4</label><figDesc>Percentage of samples correctly retrieved and false positives generated by each approach when attacking RSA.</figDesc><table>Attack 
R+R 
F+R 
P+P 
Accuracy 96.1% 98.6 % 95.4% 
F-Score 
0.952 
0.99 
0.945 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Table 5 :</head><label>5</label><figDesc></figDesc><table>Mean and variance of the different counters collected during the execution of the attacks against AES and RSA. The 
results were obtained using 10000 samples collected each 100 µs for each scenario. 

Cycles 
L3 misses L3 accesses L3 reads L2 instruction misses L2 accesses 
AES Normal 
152000±750 
0±0.1 
714±62 
697±63 
31±7 
2050±74 
AES R+R 
148000±634 
0±0.1 
713±60 
702±61 
212±15 
2035±114 
AES F+R 
184000±3000 
10±2 
676±65 
676±66 
186±12 
2000±92 
AES P+P 
158000±1200 
19±3 
452±140 
451±139 
209±18 
1810±95 
RSA Normal 336000±11000 
14±26 
100 ±206 
99±204 
7±12 
139±316 
RSA R+R 
374000±38000 
26±14 
233±114 
231±113 
60±23 
308±163 
RSA F+R 
364000±50000 
127±38 
200±110 
199±108 
97±54 
285±240 
RSA P+P 
363000±55000 
112±61 
177±159 
174±156 
78±83 
211±222 

40 
45 
50 
55 
60 
65 
0 

50 

100 

150 

Sample number 
LLC misses 

no attack 
R+R 
F+R 
P+P 

</table></figure>

			<note place="foot" n="1"> These results refer to the sets with fixed policy in the machines that implement set dueling. The remaining sets were tested once the two policies were known, and we checked they followed one of them.</note>

			<note place="foot" n="2"> The source code for this test can be found at https://github.com/ greenlsi/reload_refresh</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgment</head><p>We thank our anonymous reviewers and our shepherd Daniel Gruss for their valuable comments and constructive feedback. This work was in part supported by DFG under Grant No. 427774779 and by the EU (FEDER), the Spanish Ministry of Economy and Competitiveness, under contracts AYA2015-65973-C3-3-R and RTC-2017-6090-3.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Measurement-based modeling of the cache replacement policy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Abel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Reineke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 IEEE 19th Real-Time and Embedded Technology and Applications Symposium (RTAS)</title>
		<imprint>
			<date type="published" when="2013-04" />
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Reverse engineering of cache replacement policies in intel microprocessors and their evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Abel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Reineke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)</title>
		<imprint>
			<date type="published" when="2014-03" />
			<biblScope unit="page" from="141" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">New branch prediction vulnerabilities in openssl and necessary software countermeasures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Onur</forename><surname>Aciiçmez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shay</forename><surname>Gueron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Pierre</forename><surname>Seifert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th IMA International Conference on Cryptography and Coding, Cryptography and Coding&apos;07</title>
		<meeting>the 11th IMA International Conference on Cryptography and Coding, Cryptography and Coding&apos;07<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="185" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Predicting secret keys via branch prediction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Onur</forename><surname>Aciiçmez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Çetin</forename><surname>Kaya Koç</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Pierre</forename><surname>Seifert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th Cryptographers&apos; Track at the RSA Conference on Topics in Cryptology, CT-RSA&apos;07</title>
		<meeting>the 7th Cryptographers&apos; Track at the RSA Conference on Topics in Cryptology, CT-RSA&apos;07<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="225" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">On the power of simple branch prediction analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Onur</forename><surname>Aciiçmez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Çetin</forename><surname>Kaya Koç</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Pierre</forename><surname>Seifert</surname></persName>
		</author>
		<idno>ASI- ACCS &apos;07</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2Nd ACM Symposium on Information</title>
		<meeting>the 2Nd ACM Symposium on Information<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="312" to="320" />
		</imprint>
		<respStmt>
			<orgName>Computer and Communications Security</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A Vulnerability in RSA Implementations Due to Instruction Cache Analysis and its Demonstration on OpenSSL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Onur</forename><surname>Acıiçmez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Werner</forename><surname>Schindler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Topics in Cryptology-CT-RSA 2008</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="256" to="273" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Wait a minute! A fast, crossvm attack on AES</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mehmet</forename><surname>Gorka Irazoqui Apecechea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Sinan Inci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Research in Attacks, Intrusions and Defenses -17th International Symposium</title>
		<meeting><address><addrLine>Gothenburg, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-09-17" />
			<biblScope unit="page" from="299" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Increasing memory density by using KSM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Arcangeli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Izik</forename><surname>Eidus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OLS &apos;09: Proceedings of the Linux Symposium</title>
		<imprint>
			<date type="published" when="2009-07" />
			<biblScope unit="page" from="19" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Car: Clock with adaptive replacement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sorav</forename><surname>Bansal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dharmendra</forename><forename type="middle">S</forename><surname>Modha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd USENIX Conference on File and Storage Technologies, FAST &apos;04</title>
		<meeting>the 3rd USENIX Conference on File and Storage Technologies, FAST &apos;04<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="187" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Cacheshield: Detecting cache attacks through self-observation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samira</forename><surname>Briongos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gorka</forename><surname>Irazoqui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pedro</forename><surname>Malagón</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth ACM Conference on Data and Application Security and Privacy, CODASPY &apos;18</title>
		<meeting>the Eighth ACM Conference on Data and Application Security and Privacy, CODASPY &apos;18<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="224" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Cache misses and the recovery of the full aes 256 key</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samira</forename><surname>Briongos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pedro</forename><surname>Malagón</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juan-Mariano</forename><surname>De Goyeneche</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jose</forename><forename type="middle">M</forename><surname>Moya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Applied Sciences</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Modeling side-channel cache attacks on aes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samira</forename><surname>Briongos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pedro</forename><surname>Malagón</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>José</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">José</forename><forename type="middle">M</forename><surname>Risco-Martín</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Moya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Summer Computer Simulation Conference, SCSC &apos;16</title>
		<meeting>the Summer Computer Simulation Conference, SCSC &apos;16<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="1" to="37" />
		</imprint>
	</monogr>
	<note>Society for Computer Simulation International</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Real time detection of cache-based side-channel attacks using hardware performance counters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Chiappetta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erkay</forename><surname>Savas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cemal</forename><surname>Yilmaz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Applied Soft Computing</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="1162" to="1174" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Prime+abort: A timer-free high-precision l3 cache attack using intel TSX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Disselkoen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kohlbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leo</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dean</forename><surname>Tullsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th USENIX Security Symposium (USENIX Security 17)</title>
		<meeting><address><addrLine>Vancouver, BC</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="51" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Last level Cache Side Channel Attacks are Practical</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fangfei</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qian</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gernot</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruby</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 IEEE Symposium on Security and Privacy, SP &apos;15</title>
		<meeting>the 2015 IEEE Symposium on Security and Privacy, SP &apos;15<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="605" to="622" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A survey of microarchitectural timing attacks and countermeasures on contemporary hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qian</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Cock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gernot</forename><surname>Heiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptographic Engineering</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="2018-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A survey of fast exponentiation methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">M</forename><surname>Gordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="129" to="146" />
			<date type="published" when="1998-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Strong and efficient cache side-channel protection using hardware transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julian</forename><surname>Lettner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Felix</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olya</forename><surname>Ohrimenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Istvan</forename><surname>Haller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Costa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th USENIX Security Symposium (USENIX Security 17)</title>
		<meeting><address><addrLine>Vancouver, BC</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="217" to="233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Rowhammer.js: A remote software-induced fault attack in javascript</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clémentine</forename><surname>Maurice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment</title>
		<meeting>the 13th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2016" />
			<biblScope unit="volume">9721</biblScope>
			<biblScope unit="page" from="300" to="321" />
		</imprint>
	</monogr>
	<note>DIMVA 2016</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Flush+flush: A fast and stealthy cache attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clémentine</forename><surname>Maurice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klaus</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th Conference on Detection of Intrusions and Malware &amp; Vulnerability Assessment (DIMVA)</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Cache template attacks: Automating attacks on inclusive last-level caches</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raphael</forename><surname>Spreitzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th USENIX Security Symposium (USENIX Security 15)</title>
		<imprint>
			<biblScope unit="page" from="897" to="912" />
		</imprint>
	</monogr>
	<note>Washington, D.C., 2015. USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Cache Games -Bringing Access-Based Cache Attacks on AES to Practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Gullasch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Endre</forename><surname>Bangerter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephan</forename><surname>Krenn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 IEEE Symposium on Security and Privacy, SP &apos;11</title>
		<meeting>the 2011 IEEE Symposium on Security and Privacy, SP &apos;11<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="490" to="505" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Cache Attacks Enable Bulk Key Recovery on the Cloud</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mehmet</forename><surname>Sinan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">˙</forename><surname>Inci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Gulmezoglu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gorka</forename><surname>Irazoqui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Sunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Cryptographic Hardware and Embedded Systems -CHES 2016: 18th International Conference</title>
		<editor>Benedikt Gierlichs and Axel Y. Poschmann</editor>
		<meeting><address><addrLine>Santa Barbara, CA, USA, Au</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Intel ® 64 and ia-32 architectures optimization reference manual (section 2.1.1.2)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<ptr target="https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Systematic reverse engineering of cache slice selection in intel processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Irazoqui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Sunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Euromicro Conference on Digital System Design</title>
		<imprint>
			<biblScope unit="volume">00</biblScope>
			<biblScope unit="page" from="629" to="636" />
			<date type="published" when="2015-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A Shared Cache Attack that Works Across Cores and Defies VM Sandboxing and its Application to AES</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gorka</forename><surname>Irazoqui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Sunar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>S$a</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">36th IEEE Symposium on Security and Privacy (S&amp;P 2015)</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="591" to="604" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Mascat: Preventing microarchitectural attacks before distribution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gorka</forename><surname>Irazoqui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Sunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth ACM Conference on Data and Application Security and Privacy, CODASPY &apos;18</title>
		<meeting>the Eighth ACM Conference on Data and Application Security and Privacy, CODASPY &apos;18<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="377" to="388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Lucky 13 strikes back</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gorka</forename><surname>Irazoqui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mehmet Sinan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Inci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th ACM Symposium on Information, Computer and Communications Security</title>
		<meeting>the 10th ACM Symposium on Information, Computer and Communications Security<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="85" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">A paging experiment with the multics system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">J</forename><surname>Corbato</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1968" />
			<biblScope unit="volume">20</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Power management of the third generation intel core micro architecture formerly codenamed ivy bridge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jahagirdar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>George</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Sodhi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wells</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2012 IEEE Hot Chips 24 Symposium (HCS)</title>
		<imprint>
			<date type="published" when="2012-08" />
			<biblScope unit="page" from="1" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">High performance cache replacement using re-reference interval prediction (rrip)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aamer</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><forename type="middle">B</forename><surname>Theobald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><forename type="middle">C</forename><surname>Steely</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jr</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><surname>Emer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th Annual International Symposium on Computer Architecture, ISCA &apos;10</title>
		<meeting>the 37th Annual International Symposium on Computer Architecture, ISCA &apos;10<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="60" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Stealthmem: System-level protection against cachebased side channel attacks in the cloud</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcus</forename><surname>Peinado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gloria</forename><surname>Mainar-Ruiz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Presented as part of the 21st USENIX Security Symposium (USENIX Security 12)</title>
		<meeting><address><addrLine>Bellevue, WA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="189" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Flipping bits in memory without accessing them: An experimental study of dram disturbance errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Fallin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wilkerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Lai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 ACM/IEEE 41st International Symposium on Computer Architecture (ISCA)</title>
		<imprint>
			<date type="published" when="2014-06" />
			<biblScope unit="page" from="361" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Spectre attacks: Exploiting speculative execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Kocher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jann</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anders</forename><surname>Fogh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Werner</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Hamburg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Prescher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">40th IEEE Symposium on Security and Privacy (S&amp;P&apos;19)</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Trusted browsers for uncertain times</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kohlbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th USENIX Security Symposium (USENIX Security 16)</title>
		<meeting><address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="463" to="480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Spydetector: An approach for detecting sidechannel attacks at runtime</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yusuf</forename><surname>Kulah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berkay</forename><surname>Dincer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cemal</forename><surname>Yilmaz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erkay</forename><surname>Savas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Information Security</title>
		<imprint>
			<date type="published" when="2018-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Stopwatch: a cloud architecture for timing channel mitigation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peng</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Debin</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael K</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information and System Security (TIS-SEC</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">ARMageddon: Cache Attacks on Mobile Devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raphael</forename><surname>Spreitzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Clémen-Tine Maurice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mangard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th USENIX Security Symposium, USENIX Security 16</title>
		<meeting><address><addrLine>Austin, TX, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="549" to="564" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Meltdown: Reading kernel memory from user space</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moritz</forename><surname>Lipp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Prescher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Werner</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anders</forename><surname>Fogh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jann</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Kocher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Genkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th USENIX Security Symposium (USENIX Security 18)</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="973" to="990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Catalyst: Defeating last-level cache side channel attacks in cloud computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Mckeen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rozas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on High Performance Computer Architecture (HPCA)</title>
		<imprint>
			<date type="published" when="2016-03" />
			<biblScope unit="page" from="406" to="418" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Random fill cache architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fangfei</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruby</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th Annual IEEE/ACM International Symposium on Microarchitecture, MICRO-47</title>
		<meeting>the 47th Annual IEEE/ACM International Symposium on Microarchitecture, MICRO-47<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="203" to="215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Rethinking timekeeping and performance monitoring mechanisms to mitigate side-channel attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Demme</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simha</forename><surname>Sethumadhavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Timewarp</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th Annual International Symposium on Computer Architecture, ISCA &apos;12</title>
		<meeting>the 39th Annual International Symposium on Computer Architecture, ISCA &apos;12<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="118" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">C5: Cross-cores cache covert channel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clémentine</forename><surname>Maurice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christoph</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olivier</forename><surname>Heen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aurélien</forename><surname>Francillon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment</title>
		<meeting>the 12th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2015" />
			<biblScope unit="volume">9148</biblScope>
			<biblScope unit="page" from="46" to="64" />
		</imprint>
	</monogr>
	<note>DIMVA 2015</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Reverse engineering intel last-level cache complex addressing using performance counters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clémentine</forename><surname>Maurice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicolas</forename><surname>Scouarnec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christoph</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olivier</forename><surname>Heen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aurélien</forename><surname>Francillon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Symposium on Research in Attacks, Intrusions, and Defenses</title>
		<meeting>the 18th International Symposium on Research in Attacks, Intrusions, and Defenses<address><addrLine>New York, NY, USA; New York, Inc</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2015" />
			<biblScope unit="volume">9404</biblScope>
			<biblScope unit="page" from="48" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Arc: A self-tuning, low overhead replacement cache</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nimrod</forename><surname>Megiddo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dharmendra</forename><forename type="middle">S</forename><surname>Modha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2Nd USENIX Conference on File and Storage Technologies, FAST &apos;03</title>
		<meeting>the 2Nd USENIX Conference on File and Storage Technologies, FAST &apos;03<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="115" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Papi: A portable interface to hardware performance counters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><forename type="middle">J</forename><surname>Mucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shirley</forename><surname>Browne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christine</forename><surname>Deane</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Ho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Department of Defense HPCMP Users Group Conference</title>
		<meeting>the Department of Defense HPCMP Users Group Conference</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="7" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">The spy in the sandbox: Practical cache attacks in javascript and their implications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yossef</forename><surname>Oren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vasileios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simha</forename><surname>Kemerlis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Angelos</forename><forename type="middle">D</forename><surname>Sethumadhavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Keromytis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22Nd ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;15</title>
		<meeting>the 22Nd ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1406" to="1418" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Cache Attacks and Countermeasures: The Case of AES</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arne</forename><surname>Dag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adi</forename><surname>Osvik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eran</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tromer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Topics in Cryptology -CT-RSA 2006: The Cryptographers&apos; Track at the RSA Conference</title>
		<meeting><address><addrLine>San Jose, CA, USA; Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="1" to="20" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Hexpads: A platform to detect &quot;stealth&quot; attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathias</forename><surname>Payer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Engineering Secure Software and Systems: 8th International Symposium</title>
		<editor>Juan Caballero, Eric Bodden, and Elias Athanasopoulos</editor>
		<meeting><address><addrLine>London, UK; Cham</addrLine></address></meeting>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<date type="published" when="2016-04-06" />
			<biblScope unit="page" from="138" to="154" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">DRAMA: Exploiting DRAM addressing for cross-cpu attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Pessl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gruss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clémentine</forename><surname>Maurice</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Mangard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th USENIX Security Symposium (USENIX Security 16)</title>
		<meeting><address><addrLine>Austin, TX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="565" to="581" />
		</imprint>
	</monogr>
<note type="report_type">USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Adaptive insertion policies for high performance caching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Moinuddin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aamer</forename><surname>Qureshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yale</forename><forename type="middle">N</forename><surname>Jaleel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><forename type="middle">C</forename><surname>Patt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><surname>Steely</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Emer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual International Symposium on Computer Architecture, ISCA &apos;07</title>
		<meeting>the 34th Annual International Symposium on Computer Architecture, ISCA &apos;07<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="381" to="391" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Hey, you, get off of my cloud: exploring information leakage in third-party compute clouds</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eran</forename><surname>Tromer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hovav</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Savage</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Conference on Computer and Communications Security</title>
		<meeting><address><addrLine>Chicago, Illinois, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-11-09" />
			<biblScope unit="page" from="199" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">The 9 lives of bleichenbacher&apos;s cat: New cache attacks on tls implementations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Ronen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gillham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Genkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yarom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 2019 IEEE Symposium on Security and Privacy (SP)</title>
		<imprint>
			<biblScope unit="volume">00</biblScope>
			<biblScope unit="page" from="967" to="984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Exploiting the dram rowhammer bug to gain kernel privileges</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Seaborn</surname></persName>
		</author>
		<ptr target="https://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html" />
		<imprint>
			<date type="published" when="2015-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Ultrasparc t2 supplement to the ultrasparc architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="middle">Sun</forename><surname>Inc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Microsystems</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007-09" />
		</imprint>
	</monogr>
	<note>Draft D1.4.3</note>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Scheduler-based defenses against crossvm side-channels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Venkatanathan</forename><surname>Varadarajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ristenpart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23rd USENIX Security Symposium (USENIX Security 14)</title>
		<meeting><address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2014-08" />
			<biblScope unit="page" from="687" to="702" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Theory and practice of finding eviction sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pepe</forename><surname>Vila</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boris</forename><surname>Köpf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">José F</forename><surname>Morales</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE Symposium on Security and Privacy (SP)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019" />
			<biblScope unit="page" from="39" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">New cache designs for thwarting software cache-based side channel attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhenghong</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruby</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual International Symposium on Computer Architecture, ISCA &apos;07</title>
		<meeting>the 34th Annual International Symposium on Computer Architecture, ISCA &apos;07<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="494" to="505" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Microwalk: A framework for finding side channels in binaries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Wichelmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad</forename><surname>Moghimi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Eisenbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Berk</forename><surname>Sunar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th Annual Computer Security Applications Conference, AC-SAC &apos;18</title>
		<meeting>the 34th Annual Computer Security Applications Conference, AC-SAC &apos;18<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="161" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">Intel Ivy Bridge cache replacement policy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><surname>Wong</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">FLUSH+RELOAD: A High Resolution, Low Noise, L3 Cache Side-Channel Attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katrina</forename><surname>Falkner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23rd USENIX Security Symposium (USENIX Security 14)</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="719" to="732" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Mapping the intel last-level cache</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuval</forename><surname>Yarom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qian</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fangfei</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruby</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gernot</forename><surname>Heiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="page">905</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Automated detection of instruction cache leaks in modular exponentiation software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Zankl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johann</forename><surname>Heyszl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Georg</forename><surname>Sigl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Smart Card Research and Advanced Applications: 15th International Conference</title>
		<editor>Kerstin Lemke-Rust and Michael Tunstall</editor>
		<meeting><address><addrLine>Cannes, France; Cham</addrLine></address></meeting>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<date type="published" when="2016-11-07" />
			<biblScope unit="page" from="228" to="244" />
		</imprint>
	</monogr>
	<note>Revised Selected Papers</note>
</biblStruct>

<biblStruct xml:id="b63">
	<monogr>
		<title level="m" type="main">CloudRadar: A Real-Time Side-Channel Attack Detection System in Clouds</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tianwei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yinqian</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruby</forename><forename type="middle">B</forename><surname>Lee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
			<publisher>Springer International Publishing</publisher>
			<biblScope unit="page" from="118" to="140" />
			<pubPlace>Cham</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Cross-tenant side-channel attacks in paas clouds</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yinqian</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ari</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ristenpart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;14</title>
		<meeting>the 2014 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;14<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="990" to="1003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">A software approach to defeating side channels in lastlevel caches</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ziqiao</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yinqian</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;16</title>
		<meeting>the 2016 ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="871" to="882" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
