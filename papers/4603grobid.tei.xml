<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:26+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">WAFFle: Fingerprinting Filter Rules of Web Application Firewalls</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isabell</forename><surname>Schmitt</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Nuremberg Chair for IT Security Infrastructures</orgName>
								<orgName type="institution">University of Erlangen</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Schinzel</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Nuremberg Chair for IT Security Infrastructures</orgName>
								<orgName type="institution">University of Erlangen</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">WAFFle: Fingerprinting Filter Rules of Web Application Firewalls</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>1</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Web Application Firewalls (WAFs) are used to detect and block attacks against vulnerable web applications. They distinguish benign requests from rogue requests using a set of filter rules. We present a new timing side channel attack that an attacker can use to remotely distinguish passed requests from requests that the WAF blocked. The attack works also for transparent WAFs that do not leave any trace in responses. The attacker can either conduct our attack directly or indirectly by using Cross Site Request Forgeries (CSRF). The latter allows the attacker to get the results of the attack while hiding his identity and to circumvent any practical brute-force prevention mechanism in the WAF. By learning which requests the WAF blocks and which it passes to the application, the attacker can craft targeted attacks that use any existing loopholes in the WAF&apos;s filter rule set. We implemented this attack in the WAFFle tool and ran tests over the Internet against ModSecurity and PHPIDS. The results show that WAFFle correctly distinguished passed requests from blocked requests in more than 95 % of all requests just by measuring a single request.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Web application security has become a crucial topic for the success-sometimes even for the survival-of many companies. Examples for critical security vulnerabilities in web applications are Cross Site Scripting (XSS), SQL Injection (SQLi), or Directory Traversal. To attack these vulnerabilities, the attacker sends rogue requests to a vulnerable web application. If the application confuses the payload of the rogue requests with commands, the attack succeeded and the attacker can read, change, or delete sensitive information from the application.</p><p>Web Application Firewalls (WAF) are mitigations for these vulnerabilities that do not aim at fixing the actual vulnerable application, but that try to detect and to prevent rogue requests. To distinguish normal requests from rogue requests, WAFs use a set of filter rules in the form of white-lists, black-lists, or a combination of both. Commonly, the WAF will pass only those requests to the application that are classified as normal requests. Requests classified as rogue are usually blocked and thus not passed on to the application. Creating filter rule sets is challenging because on the one hand if the WAF blocks some normal requests (false positive), then the application may not function any more. On the other hand, if the WAF does not block all rogue requests (false negative), then the attacker may circumvent the WAF and exploit a vulnerability This work was supported by Deutsche Forschungsgemeinschaft (DFG) as part of SPP 1496 "Reliably Secure Software Systems". in the application. Another obstacle is that rogue requests that aim at exploiting XSS vulnerabilities are different from those aiming at exploiting SQLi vulnerabilities, which indicates the complexity of a filter rule set that detects the most common attacks. Tightening a filter rule set such that all false positives and false negatives are prevented is thus hardly possible with the limited resources of realistic systems. Because there is no reason to believe that any given filter rule set is perfect, it is common to treat the active filter rule set as such as confidential. This is to prevent the attacker to spot and exploit weak spots in the rule set.</p><p>Side channel vulnerabilities-or side channels-are unintentional and hidden communication channels that appear if the publicly observable behavior of a process correlates with sensitive information <ref type="bibr" target="#b22">[23]</ref>. Side channel analysis was traditionally used to break implementations of cryptographic algorithms <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b2">[3]</ref>. On the web, side channel attacks are widely spread and a serious threat to the confidentiality of information on the web. They can be separated in timing side channels <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b17">[18]</ref> and storage side channels <ref type="bibr" target="#b8">[9]</ref>. Timing side channels appear if the response time of a web application correlates with confidential information. Thus, by measuring the response time, the attacker can learn confidential information. Storage side channels appear for example if protocol header data or the indentation of markup language documents correlates with confidential information.</p><p>Whereas storage side channels leak information independently of the network connection quality, timing side channels are more difficult to exploit if the network connection adds much noise in the form of random delays (jitter). If the variance of the jitter is large compared to the timing difference to be measured, the attacker has to apply filters to approximate the actual timing difference <ref type="bibr" target="#b4">[5]</ref>.</p><p>We present a practical timing side channel attack that allows to remotely distinguish passed and blocked requests. This allows a remote attacker to determine loopholes in the WAF's filter rules and to adjust the attack in a way that it evades the WAF. Furthermore, we extend the attack so that multiple unsuspecting web users perform the attack, thus hiding the identity of the actual attacker. The attack was implemented in the tool "WAF Fingerprinting utilizing timing side channels" (WAFFle). We make the following contributions:</p><p>• We describe a timing side channel attack against WAFs that directly distinguishes passed requests from blocked requests without relying on ambiguous error messages.</p><p>• We combine our timing attack with Cross Site Request Forgeries, which hides the attacker's identity and prevents the WAF from blocking the attack assuming that the attacker distributes the attack to many other users.</p><p>• We test the attack over an Internet connection against three common WAF deployment setups and show that the attack is highly practical. The paper is structured as follows. In the following, we present related work and in Section II we explain the workings of WAFs. We explain the idea behind our attack in Section III. Section IV presents our timing attack and Section V combines the timing attack with Cross Site Request Forgeries. We conclude and discuss possible mitigations in Section VI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work</head><p>Bortz, Boneh, and Nandy <ref type="bibr" target="#b1">[2]</ref> introduced the concept of cross-site timing attacks with which they could determine whether a user is currently logged on to a site. They measured whether the browser of the victim retrieves an item from the browser cache (which will be very fast) or whether the browser needs to download the item (which will be slow). We extend this approach by combining CSRF attacks <ref type="bibr" target="#b24">[25]</ref> with timing attacks, in order to hide the identity of the attacker who could also perform the attack directly.</p><p>Fingerprinting on the network level is widely known and the various tools are commonly used in day-to-day penetration testing. The most famous tool is Nmap <ref type="bibr" target="#b6">[7]</ref> which is an active network scanner that can scan large IP ranges, fingerprint the producer and version of operating systems, and learn producer and version of network services by analyzing the service banner. p0f <ref type="bibr" target="#b13">[14]</ref> is a passive network scanner that analyses network traffic and identifies producer and version of the operating system of the sender. Both tools aim at fingerprinting network stacks but fingerprint firewall filter rules.</p><p>Firewalk <ref type="bibr" target="#b14">[15]</ref> is a tool that fingerprints rules of packet filtering firewalls. It sends out TCP and UDP packets with a TTL that is one greater as the amount of hops from the sender to the firewall. If the packet passes the firewall, the next hop discards the packet and sends an ICMP TIME EXCEEDED message to the sender. Thus, this message indicates that the packet was not filtered by the firewall. Firewalk cannot be used to fingerprint application layer filtering firewalls because they create separate connections to the application, i.e. single packets are never passed from sender to the application. Samak, El-Atawy, and Al-Shaer extend this approach to intelligently choose probing packets for fingerprinting filtering rules <ref type="bibr" target="#b19">[20]</ref>.</p><p>Khakpour et al. <ref type="bibr" target="#b10">[11]</ref> were able to distinguish three different network firewall implementations by sending TCP packets with unusual flag combinations and measuring the time it took for a firewall to process the packets. They focused on distinguishing the firewall products but did not fingerprint the active filter rules of the firewalls. The purpose of their work is similar to NMAP and p0f with the difference that they aim at fingerprinting implementations of filter engines.</p><p>WAFW00f <ref type="bibr" target="#b20">[21]</ref> can detect if a web page is protected by a WAF and can differentiate between 22 different WAF producers. For this, it sends normal and rogue requests to the same URL and compares the responses. It assumes that differences in the responses such as different HTTP status codes denote that a WAF filters the requests. However, the tool does not distinguish between "blocked by WAF" error responses and "caused error in web application" error responses which were possibly rewritten (cloaked) by the WAF. Just from analyzing the responses it is therefore not possible to tell with certainty whether a request was blocked by the WAF or passed on to the web application. WAFW00F directly connects to the WAF, i.e. the WAF may learn the IP address of the attacker and block the attack. Furthermore, WAFW00F does not fingerprint the filtering rules but solely determines WAF producers. WAF Tester <ref type="bibr" target="#b5">[6]</ref> is a tool that fingerprints WAF filter rules by analyzing the HTTP status codes and whether the WAF drops or rejects the HTTP request on the TCP layer. It has similar assumptions to WAFW00F regarding the detection of blocked requests from different responses. For example, there is the case where a passed rogue request crashes the web application, which the tool may confuse for a blocked request. WAF Tester therefore tries to distinguish passed requests from blocked requests from certain error conditions in the responses, which is not always possible. Similar to WAFW00F, WAF Tester directly connects to the WAF, i.e. the WAF may learn the IP address of the attacker and block the attack. We show that instead of relying on error messages, measuring the response time of requests gives more reliable information on whether the request was blocked or passed by the WAF. Furthermore, we extend WAF Fingerprinting in a way that it uses cross site request forgeries, which only works with timing attacks. This has the advantage that the WAF does not learn the attacker's IP.</p><p>"Mutating exploits" and their effects on the detection of intrusion detection systems (IDS) were analyzed by Mutz and Vigna et al. <ref type="bibr" target="#b16">[17]</ref>, <ref type="bibr" target="#b26">[27]</ref>. Both deal with ways to obfuscate malicious code in a way such that the attack is not detected by IDS but that the attack still works. For this, they generate many variations of an exploit, run them against a victim system and correlate them with the alerts produced by the IDS. Their work is related to ours because an IDS can be modeled as a firewall that only alerts administrators but does not interfere with network traffic. However, their attacker scenario allows the attacker to access the alerts of the IDS. In our scenario, the attacker is weaker because he neither needs to receive alerts, nor does he need access to the firewall's log files.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. WEB APPLICATION FIREWALLS</head><p>Besides blocking rogue inbound requests, WAFs are also used to "cloak" those outgoing responses that contain sensitive information such as error messages or stack traces. A securely configured WAF substitutes these error messages with a single generic error page. In this paper, we assume a cloaking WAF where the different error conditions (e.g. an error occurred in application or a rogue request was detected) are indistinguishable for an attacker that analyzes the responses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Filter Rules</head><p>WAFs detect rogue requests from a set of filter rules. Although the rule languages differ from product to product, they basically consist of regular expression and an action. The WAF executes the action if the regular expression matches a request. There are a variety of actions that common WAFs support and the following list provides an excerpt of the possible actions that ModSecurity supports <ref type="bibr" target="#b15">[16]</ref>. For our purposes, we are interested in those actions that pass a request on to the web application and in those that block a request, i.e. that do not pass the request to the web application.</p><p>Examples for Passing Actions:</p><p>• log -This action causes ModSecurity to log a match in the apache error log.</p><p>• pass -This action is mostly used together with the log action if someone only wants to log a match but does not want to take further actions.</p><p>• allow -In contrast to the pass action the allow action will not only let a request pass a particular match but will allow it though the whole filter set. This action could for example be used to provide whitelisting for a particular IP address.</p><p>Examples for Blocking Actions:</p><p>• deny -This action stops further processing immediately and returns a HTTP 500 error to the client.</p><p>• block -This action stops further processing immediately and terminates the TCP connection of the client by sending a TCP FIN packet.</p><p>It is important to note that the default rule set of WAFs often consists of several dozen or hundred filter rules and that the regular expression of each rule can be quite elaborate. This makes common rule sets complex and difficult to audit, i.e. for the administrator, it is difficult to spot loopholes in a rule set even when he has full access to the rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. WAF Network Topologies</head><p>We consider three common ways to deploy a WAF. The first topology is to install the WAF standalone (reverse-proxy) as shown in <ref type="figure" target="#fig_0">Figure 1(a)</ref>. Here, clients directly connect to the IP of the WAF. The WAF connects to the IP of the web application, passes the request, retrieves the response and passes the response to the client. WAF and web application are different hosts in this scenario. If a request is blocked, the rogue request never reaches the host that runs the web application.</p><p>The second scenario is to load the WAF as a plugin into the same web server that also serves the web application as shown in <ref type="figure" target="#fig_0">Figure 1(b)</ref>. The clients connect to the web server and the web server ensures that the request is first passed to the WAF plugin and then to the actual web application. If a rogue request is blocked, the web server will never pass the request to the web server module that processes the web application.</p><p>Thirdly, there is the scenario where the WAF is directly included into the web application as a programming library as shown in <ref type="figure" target="#fig_0">Figure 1(c)</ref>. Here, the client connects to the web application and the web application passes the request to the WAF library. If a rogue request is blocked, the web application will not pass the request to the actual processing logic. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. A Timing Side Channel in WAFs</head><p>As the tools WAFW00F <ref type="bibr" target="#b20">[21]</ref> and WAF Tester [6] exploit storage side channels, all they can possibly observe are the following three different responses. (c) Lastly, the WAF could have passed the rogue request and the malicious part was executed, but it produced no visible result. An example for this are "blind SQL Injection" attacks where an attacker can execute malicious SQL commands but cannot access the result of the command <ref type="bibr" target="#b9">[10]</ref>. Thus, just from observing responses, one cannot distinguish passed requests from blocked requests because error messages can occur for both cases. In this paper, we introduce a timing side channel attack against WAFs that allows us to directly distinguish blocked requests from passed requests without relying on ambiguous error messages in responses. We exploit the fact that a blocked request finishes earlier than a request that is passed on to the web application as described in Section II-B. Thus, the response time should allow to distinguish passed and blocked requests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. GENERAL METHODOLOGY OF THE TIMING ATTACK</head><p>We expect that blocked requests finish earlier than passed requests because the actual application logic that processes the request is never reached. Thus, the timing difference between passed and blocked requests equals the processing time of the application logic. The longer this processing time is, the smaller the negative effect of jitter on the measurement, the easier it is for the attacker to distinguish passed and blocked requests. Note that the attacker is free to choose those URLs with long running processes to ease the fingerprinting process. Furthermore, the attacker may combine the fingerprinting process with denial of service attacks such as "HashDos" <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b0">[1]</ref> to artificially increase the processing time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Attack Idea</head><p>The attacker in our scenario has selected a target to attack and is now in the reconnaissance phase where he wants to find out whether a WAF protects the application and what filter rules are active in the WAF.</p><p>We assume that the WAF returns an error message immediately if a request is classified as rogue request, without passing the request to the application. In contrast, a normal request is passed on to the application. Our hypothesis is that rogue requests have a measurably shorter response time than normal requests. The attacker should thus be able to distinguish those requests that were blocked by the WAF from those that were passed on to the application.</p><p>To perform the attack, the attacker needs to guess two different requests. The first should result in a passed response and is easy to get. The second should contain maliciously looking payload that any WAF certainly blocks, e.g. the string ' OR '1'='1 which is a trivial SQLi exploit. The attacker sends these requests to the WAF and measures the response time. In the following section, we explain an efficient method to distinguish passed requests from blocked requests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Analyzing the Timing Measurements</head><p>In this section, we present our notion of possibilistic timing attacks <ref type="bibr" target="#b23">[24]</ref>. We split our attack into the learning phase and the attack phase as shown in <ref type="figure" target="#fig_2">Figure 2</ref>. In the learning phase, we measure the response times T = t 1 , t 2 , . . . t n of n passed requests and define a "blocking boundary" such that</p><formula xml:id="formula_0">t boundary = min(T ) −</formula><p>where accounts for the fact that the true minimum boundary of T may be slightly lower given more measurements.</p><p>In the attack phase, the attacker sends rogue requests and wants to know whether the WAF passed the request or blocked it. Any timing measurement t &lt; t boundary denotes a blocked request. Any timing measurement t ≥ t boundary is a candidate for a passed request. It is only a candidate because t either denotes a passed request and low jitter or it denotes a blocked request and high jitter. In order to confirm the candidate, the attacker repeats the measurement until a satisfying confidence is reached that the candidate is a passed request. This method is called "possibilistic timing analysis" because some measurements are definite and others require repetitions to confirm the result <ref type="bibr" target="#b22">[23]</ref>.</p><p>Note that t boundary can vary between different URL paths of the same site, and should therefore be calculated for each unique URL path. In the attacks scenarios described in the following sections, however, we used a single t boundary for all URL paths and got very good results with only few exceptions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. BLACK-BOX FINGERPRINTING OF WAF FILTER RULES</head><p>Now that we described the general methodology of our attack in the previous section, we constructed all three WAF network topologies described in section II-B. To test our approach, we chose the free WAF product ModSecurity <ref type="bibr" target="#b25">[26]</ref> in version 2.5.12-1 for scenarios depicted in <ref type="figure" target="#fig_0">Figure 1</ref>(a) and 1(b). To implement the scenario of <ref type="figure" target="#fig_0">Figure 1(c)</ref>, we used PHPIDS <ref type="bibr" target="#b12">[13]</ref> in version 0.5.6, which is an intrusion detection system that scores incoming requests. High scores indicate an attack, in which case we blocked the request, emulating a WAF.</p><p>We chose phpBB as web application that the WAF protects. This web application and the WAFs were hosted at the French cloud computing provider OVH. We used a host in the network of the University of Mannheim in Germany to perform the timing attack against the WAF. This intracontinental measurement setup reflects that our attack is highly practical. Our client-side Our prototype implementation of the attack (WAFFle) starts by initiating the learning phase as described in section III-B, in which it determines whether a WAF exists or not. If a WAF exists it calculates the blocking boundary for blocked requests. In this simple test, we repeatedly measure the response times of passed requests and blocked requests and plot the result in <ref type="figure" target="#fig_3">Figure 3</ref>. It shows a clearly visible timing difference between passed responses and blocked responses, which confirms that a WAF filters the requests. Below are two basic examples that ModSecurity and PHPIDS will either pass or block in their particular standard configuration.</p><p>Passed request: GET /?p=1234567890 HTTP/1.1 Blocked request: GET /?p='%20or%201=1--HTTP/1.1</p><p>In the next step, WAFFle crawls the web application to find all combination of URLs and parameters. It then sends the rogue payloads within the found parameters and measures the response time. If the response time is below the blocking boundary, it classifies the requests as blocked. A response time above the blocking boundary is marked as a candidate for a passed request. WAFFle then repeats the measurement to confirm the result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Direct Fingerprinting of WAF Filter Rules</head><p>We now compile a list of malicious payloads that are commonly used to exploit vulnerabilities (e.g. from <ref type="bibr" target="#b18">[19]</ref>) and send them to the WAF-protected web application. Our attacker ultimately aims to find a polymorphic representation of malicious payload that evades the WAF's active filter rules. Polymorphic representations are semantically identical but syntactically different to a malicious payload. Thus, we extend the list with polymorphic representations of the malicious payloads as shown in the following example.</p><p>Malicious payload ' OR '1'='1 Polymorphic representation ' OR '2'='2 Polymorphic representation ' OR '1' = '1</p><p>We sent these payloads to all URLs and all parameters of phpBB, which resulted in overall 4797 requests, and recorded  the response times. To validate these response times, we configured ModSecurity and PHPIDS in our test environment to return error messages in the case of a blocked message. We recorded the status codes along with the response times and could therefore validate the results of the timing attack. For example, if WAFFle classified a particular request as blocked, we also expected an error message. Furthermore, if WAFFle classified a request as passed, we expected no error message. Otherwise, WAFFle classified a request wrongly. <ref type="figure" target="#fig_4">Figure 4</ref> shows the results of measuring the response times of the malicious payloads in the standalone WAF scenario. We found that already 95.2 % of all measurements correctly indicated passed or blocked requests without any measurement repetitions. Thus, we can reach perfect measurement conditions with only few measurement repetitions. The scenario where the WAF is loaded as a web server plugin yields very similar results as shown in <ref type="figure" target="#fig_5">Figure 5</ref>. We expected that the attack would perform worse in the third scenario, where the WAF is deployed as a programming library, but we were surprised to find that the attacks works similarly well as shown in <ref type="figure" target="#fig_6">Figure 6</ref>. The insight here is, that the overhead of the network connection in the standalone WAF scenario is negligible compared to the delay induced by the WAF filtering engine. In summary, our timing attack correctly detected passed and blocked requests in more than 95 % of all cases  as summarized in <ref type="table" target="#tab_0">Table I</ref>. Although this attack is very efficient because in most cases the attacker only needs a single timing measurement to distinguish passed from blocked requests, badly configured WAFs may leak this information through different error messages, because they do not cloak responses. In this case, the attacker can analyze the error messages instead of the response time. The downside of both approaches is that the attacker possibly needs to send large amounts of requests to find loopholes in a filter rule set. WAFs can detect this attack and block the attacker from finishing it. We therefore extend our tool such that it tricks unsuspecting web users to perform the actual requests, thus combining Cross Site Request Forgeries (CSRF) and timing attacks. This hides the identity of the attacker and prevents the WAF from blocking the fingerprinting attack if many users simultaneously conduct the attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. CROSS-SITE FINGERPRINTING OF WAF FILTER RULES</head><p>The direct timing attack can be improved to disguise the identity of the attacker and to prevent the WAF from blocking the fingerprinting attack. For this, we combine our timing attack with a CSRF attack. Note that this is different from the Cross-Site timing attacks of Bortz, Boneh, and Nandy <ref type="bibr" target="#b1">[2]</ref> because they gain confidential information about the users, e.g. whether the user is logged on to a site. As opposed to this, we abuse other users to learn confidential information about WAFs and thus from the server side.</p><p>As a precondition for our attack, the attacker must be able to lure web users to a web site where he can place malicious HTML and JavaScript coding (step 1 in <ref type="figure">Figure 7</ref>). This code tricks the web users' browsers to send the malicious request to the victim web application (step 2 and 3). Simultaneously, the browser measures the response time of the malicious request and sends the result back the attacker (step 4). There are various ways in a browser to time a web request and in our tests we chose that same technique proposed by Bortz, Boneh, and Nandy <ref type="bibr" target="#b1">[2]</ref>. In this coding shown in <ref type="figure" target="#fig_7">Figure 8</ref>, the attacker creates an image tag. Just before he copies the malicious payload to the URL of the image (line 12), he records the starting time. As the request most certainly will not return a valid image, the browser fires the onerror function that the attacker defined in lines 4-8. In this function, the attacker records the ending time, and sends the timing difference between starting and ending time to the attacker.</p><p>It is important to note, that this cross site attack only works reliably with the timing attack, because the Same Origin Policy <ref type="bibr" target="#b27">[28]</ref> of web browsers does not allow reading or writing response bodies from other origins. Thus, in this cross-site scenario, it is not possible to read the error messages in responses of badly configured WAFs, which means that analyzing error messages is not an option in this cross site scenario. However, we show that it is still possible to read the response time of the request.</p><p>We implemented the cross site timing attack and ran it against the proxy WAF scenario. <ref type="figure" target="#fig_8">Figure 9</ref> shows that also the cross site extension to WAFFle reliably distinguishes blocked and passed requests. Note that this attack can be distributed to many different web users and if each only fingerprints a few requests, the WAF cannot prevent the attack by simply blocking the IPs of the various senders.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. CONCLUSION</head><p>We present a new fingerprinting attack that allows to remotely distinguish requests that were blocked by the WAF or passed by the WAF. The attack extends existing tools in a way that it does not rely on error messages in the responses of the WAF or the web application, which are easy to hide if the WAF is configured securely. Instead, it distinguishes blocked from passed requests solely by analyzing the response time of the requests. This makes our attack difficult to prevent.</p><p>Furthermore, we extend the timing attack by combining it with Cross Site Request Forgeries, which hides the identity of the attacker. If this attack is spread to many users, the WAF cannot block the fingerprinting attack simply by blocking IP addresses. This allows an attacker to find loopholes in filter rules with little effort. We tested the attack over the Internet against three common WAF deployment scenarios and we argue that the attack works against all WAFs.</p><p>Preventing timing attacks in networked applications by artificially delaying responses is difficult in practice, because the security depends on how the delay is chosen. Random delays are known to be ineffective and padding to the worst case execution time is not practical. Adding a deterministic and unpredictable delay may be a solution to this <ref type="bibr" target="#b21">[22]</ref>.</p><p>Our attack highlights the importance that filter rule sets need to be carefully written and audited to prevent loopholes. Thus, the best mitigation for our fingerprinting attack is to have no loopholes in the WAF's rule set. As a consequence, the attacker may still be able to fingerprint the rules but he does not find loopholes.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Different topological deployment options for WAFs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>1 )</head><label>1</label><figDesc>WAF error message. The WAF responds with a unique error message (or drops or rejects the request). This either means that (a) the rogue request was blocked by the WAF or (b) that the WAF passed the request to the web application that responded with an error message and which was then cloaked by the WAF. 2) Webapp error message. The web application responds with an error message that is different from the WAF error message. Here it is clear that the WAF neither blocked the request, nor cloaked the web application's error message. 3) Normal response. A normal response with no error is observed. There are three possibilities that may cause this behavior. (a) The WAF removed the malicious part of the rogue request, thus passing the equivalent to a normal request to the web application. (b) Another option is that the WAF passed the rogue request but the web application ignored the malicious part of the request.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Possibilistic timing analysis: Response times below the "Blocking boundary" denote blocked requests, response times above are candidates for passed requests.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Timing differences of a standalone WAF for passed responses and blocked responses</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Measuring the response time for each request in the standalone WAF scenario.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Measuring the response time for each request in the WAF as Web Server Plugin scenario.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Measuring the response time for each request in the WAF as Programming Library scenario. WAF topology Figure Timing difference Correct Standalone 1(a) 62.63 ms 95.2 % Web server plugin 1(b) 81.86 ms 95.4 % Programming library 1(c) 48.22 ms 96.3 %</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 7. Overview of the cross site timing attack.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Results of the cross site timing attack.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>TABLE I TIMING DIFFERENCE BETWEEN BLOCKED REQUESTS AND PASSED REQUESTS PER WAF TOPOLOGY.</head><label>I</label><figDesc></figDesc><table></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Efficient denial of service attacks on web application platforms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Klink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julian</forename><surname>Wälde</surname></persName>
		</author>
		<ptr target="http://events.ccc.de/congress/2011/Fahrplan/events/4680.en.html" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>28th Chaos Communication Congress</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Exposing private information by timing web applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Bortz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Palash</forename><surname>Nandy</surname></persName>
		</author>
		<editor>Carey L. Williamson, Mary Ellen Zurko, Peter F. Patel-Schneider, and Prashant J. Shenoy</editor>
		<imprint>
			<date type="published" when="2007" />
			<publisher>ACM</publisher>
			<biblScope unit="page" from="621" to="628" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Remote timing attacks are practical</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Brumley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Boneh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="701" to="716" />
			<date type="published" when="1999-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Denial of service via algorithmic complexity attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><forename type="middle">S</forename><surname>Crosby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wallach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th USENIX Security Symposium</title>
		<meeting>the 12th USENIX Security Symposium</meeting>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="2003-08" />
			<biblScope unit="page" from="29" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Opportunities and limits of remote timing attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><forename type="middle">S</forename><surname>Crosby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rudolf</forename><forename type="middle">H</forename><surname>Wallach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Riedi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information and System Security</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Waf tester v1</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deniz</forename><surname>Cevik</surname></persName>
		</author>
		<ptr target="http://ttlexpired.com/blog/?p=234" />
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Nmap network scanning -the official nmap project guide to network discovery and security scanning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Gordon Fyodor Lyon</surname></persName>
		</author>
		<ptr target="http://nmap.org/book/osdetect.html" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Timing attacks on web privacy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Edward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Felten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGSAC: 7th ACM Conference on Computer and Communications Security</title>
		<imprint>
			<publisher>ACM SIGSAC</publisher>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Detecting hidden storage side channel vulnerabilities in networked applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Felix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Freiling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schinzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th IFIP TC-11 International Information Security Conference (IFIP/SEC)</title>
		<meeting>the 26th IFIP TC-11 International Information Security Conference (IFIP/SEC)</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Blind sql injection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Spett</surname></persName>
		</author>
		<ptr target="http://www.net-security.org/dl/articles/BlindSQLInjection.pdf" />
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Firewall fingerprinting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Amir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><forename type="middle">W</forename><surname>Khakpour</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zihui</forename><surname>Hulst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><forename type="middle">X</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jia</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31th Annual IEEE Conference on Computer Communications (INFOCOM)</title>
		<meeting><address><addrLine>Orlando, Florida</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Timing attacks on implementations of diffie-hellman, RSA, DSS, and other systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kocher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CRYPTO: Proceedings of Crypto</title>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Php-intrusion detection system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mario</forename><surname>Heiderich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Matthies</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lars</forename><forename type="middle">H</forename><surname>Strojny</surname></persName>
		</author>
		<ptr target="https://phpids.org/" />
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michal</forename><surname>Zalewski</surname></persName>
		</author>
		<ptr target="http://lcamtuf.coredump.cx/p0f3/" />
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>p0f v3</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Schiffman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Goldsmith</surname></persName>
		</author>
		<ptr target="http://packetstormsecurity.org/UNIX/audit/firewalk/" />
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
	<note>firewalk v0.99.1</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Reference manual: Actions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Modsecurity</forename><surname>Wiki</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Reverse engineering of network signatures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Darren</forename><surname>Mutz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giovanni</forename><surname>Vigna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><forename type="middle">A</forename><surname>Kemmerer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PROCEEDINGS OF THE AUSCERT ASIA PACIFIC INFORMA-TION TECHNOLOGY SECURITY CONFERENCE, GOLD</title>
		<imprint>
			<biblScope unit="page" from="1" to="86499" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An independent evaluation of web timing attack and its countermeasure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshitaka</forename><surname>Nagami</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daisuke</forename><surname>Miyamoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hiroaki</forename><surname>Hazeyama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Youki</forename><surname>Kadobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Third International Conference an Availability, Reliability and Security (ARES)</title>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1319" to="1324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">RSnake&quot; Hansen. Xss (cross site scripting) cheat sheet</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Robert</surname></persName>
		</author>
		<ptr target="http://ha.ckers.org/xss.html" />
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Firecracker: A framework for inferring firewall policies using smart probing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taghrid</forename><surname>Samak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adel</forename><surname>El-Atawy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ehab</forename><surname>Al-Shaer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICNP</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="294" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Wafw00f -web application firewall detection tool (svn r33</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sandro</forename><surname>Gauci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wendel</forename><forename type="middle">G</forename><surname>Henrique</surname></persName>
		</author>
		<ptr target="http://code.google.com/p/waffit/" />
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An efficient mitigation method for timing side channels on the web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Schinzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2nd International Workshop on Constructive Side-Channel Analysis and Secure Design (COSADE)</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Unintentional and Hidden Information Leaks in Networked Software Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Schinzel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
		<respStmt>
			<orgName>Friedrich-Alexander Universität Erlangen-Nürnberg</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Time is on my side -exploiting timing side channel vulnerabilities on the web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Schinzel</surname></persName>
		</author>
		<ptr target="http://events.ccc.de/congress/2011/Fahrplan/events/4640.en.html" />
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>28th Chaos Communication Congress</note>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Foiling cross-site attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Shiflett</surname></persName>
		</author>
		<ptr target="http://shiflett.org/articles/foiling-cross-site-attacks" />
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Trustwave&apos;s SpiderLabs Team. Modsecurity -open source web application firewall</title>
		<ptr target="http://www.modsecurity.org/" />
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Testing network-based intrusion detection signatures using mutant exploits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robertson</forename><surname>Vigna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Balzarotti</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGSAC: 11th ACM Conference on Computer and Communications Security</title>
		<imprint>
			<publisher>ACM SIGSAC</publisher>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Same origin policy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wiki</surname></persName>
		</author>
		<ptr target="http://www.w3.org/Security/wiki/SameOriginPolicy" />
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
