<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:23+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Refining SQL Queries based on Why-Not Polynomials</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicole</forename><surname>Bidoit</surname></persName>
							<email>bidoit@lri.fr</email>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR8623</orgName>
								<orgName type="institution" key="instit1">LRI -Université Paris Sud</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<orgName type="institution" key="instit3">Université Paris-Saclay</orgName>
								<address>
									<postCode>91405</postCode>
									<settlement>Orsay Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Melanie</forename><surname>Herschel</surname></persName>
							<email>melanie.herschel@ipvs.uni-stuttgart.de</email>
							<affiliation key="aff1">
								<orgName type="institution">IPVS -University of Stuttgart</orgName>
								<address>
									<postCode>70569</postCode>
									<settlement>Stuttgart</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katerina</forename><surname>Tzompanaki</surname></persName>
							<email>aikaterini.tzompanaki@telecom-paristech.fr</email>
							<affiliation key="aff2">
								<orgName type="institution">INFRES-Télécom ParisTech</orgName>
								<address>
									<postCode>75013</postCode>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Refining SQL Queries based on Why-Not Polynomials</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H4 [Information Systems Applications]: Miscellaneous; D2 [Software Engineering]: Test- ing and Debugging Keywords data provenance</term>
					<term>query analysis</term>
					<term>why not questions</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Explaining why some data are not part of a query result has recently gained significant interest. One use of why-not explanations is adapting queries to meet user expectations. We propose an algorithm to automatically generate changes to a query, by using Why-Not polynomials, one form of why-not explanations based on query operators. We improve on the state of the art in three aspects: (i) we refine both selection and join predicates, (ii) we guarantee a maximum similarity to the original query, and (iii) we cover all possible cases of why the desired data was missing. A prototype implementation shows the applicability of our approach in practice.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Explaining why some data are not part of a query result has many applications ranging from information extraction ( <ref type="bibr" target="#b8">Huang et al. 2008</ref>) over query debugging <ref type="bibr">(ten Cate et al. 2015</ref>) to commercial campaign and product tuning ( <ref type="bibr" target="#b6">Gao et al. 2015</ref>). For all these applications, understanding why expected answers are missing from a result typically precedes an adjustment process designed to meet the user expectation, based on the provided explanations. For instance, upon identifying which source data has not been properly extracted, the corresponding extractor is adapted. This paper focuses on query repair, with the specific goal of semi-automatically adapting SQL queries to include expected (but missing) answers. Our approach builds on a previous contribution <ref type="bibr" target="#b0">(Bidoit et al. 2014</ref><ref type="bibr" target="#b1">(Bidoit et al. , 2015a</ref>) which, given a query Q and a Why-Not question provides a Why-Not polynomial that captures all possible explanations based on query operators. Essentially, the Why-Not polynomial pinpoints all combinations of query conditions (selections and joins) that potentially cause the missing answers. Based on these explanations, the FixTed algorithm discussed in this paper refines the original query Q to include the missing answers.   returns actors who starred in excellent movies while still young. Query conditions are denoted c1, c2, and c3. Given the query result {(Reeves, M atrix)}, one may ask the Why-Not question "Why not DiCaprio?". The first reason that comes to mind is that DiCaprio is not that young, i.e., c1 may be too selective. But let us now analyze the explanations provided by the Why-Not polynomial of <ref type="figure" target="#fig_1">Fig. 1(d)</ref>, where each addend provides one explanation (a product of query conditions) for missing DiCaprio. We observe that c1 appears in three explanations, but always in combination with another operator, e.g., in the explanation c1c2. This entails that the operator c1 is never responsible alone for pruning DiCaprio from the result. So, if we opt for changing c1, we would also need to change also c2 to obtain DiCaprio in the result. The addend 3c1c2 tells us also that there exist three different ways to adjust the values of c1c2, corresponding to the tuple pairs Id1Id7, Id2Id8, and Id3Id9. On the other hand, the addend c2 of the Why-Not polynomial, indicates that there is one possibility to recover DiCaprio by just relaxing the condition on rating. The corresponding refinement is shown in <ref type="figure" target="#fig_1">Fig. 1(c)</ref>.</p><p>Contributions. Existing work on query refinement addressing Why-Not questions ( <ref type="bibr" target="#b5">Gaasterland et al. 1992;</ref><ref type="bibr" target="#b10">Islam et al. 2013;</ref><ref type="bibr" target="#b7">He and Lo 2014;</ref><ref type="bibr" target="#b4">Chen et al. 2015;</ref><ref type="bibr" target="#b6">Gao et al. 2015</ref>), especially for relational queries <ref type="bibr" target="#b13">(Tran and Chan 2010;</ref><ref type="bibr" target="#b14">Tran et al. 2014;</ref><ref type="bibr" target="#b9">Islam et al. 2012</ref><ref type="bibr" target="#b11">Islam et al. , 2014</ref>), directly compute query refinements ignoring completely which operators or combination of operators explain the missing data. However, such information, which is provided by Why-Not polynomials, is valuable for guiding the refinement process of the original query. Indeed, explanations pinpoint the query conditions that need to be changed, reducing the search space explored by other approaches. FixTed is the first algorithm that leverages query-based explanations to compute query refinements. In addition, FixTed is the first query refinement algorithm for relational queries to rewrite joins into outer joins, thereby covering a typical source of error and enlarging the set of possible query refinements over the state of the art. Finally, the set of generated refinements guarantees two important properties not enforced by prior work. First, FixTed creates refinements with maximum similarity to the original query. Second, FixTed ensures that all possible ways to repair the original query are investigated and thus returns a comprehensive set of refinements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Preliminaries and Problem Statement</head><p>FixTed relies on various concepts formalized in prior work ( <ref type="bibr" target="#b1">Bidoit et al. 2015a</ref>). Due to space constraints, we limit the discussion here to an overview of the most central concepts. Tab. 1 summarizes the different queries and query results we rely on, as discussed below. We are given a query Q, with input schema S={R1, . . . , Rn}, output type Γ⊆Attr(S), and condition set C, with atomic conditions of the form: (i) A1θa, (ii) A1θA2, where a is a constant, Ai∈Attr(S), for i=1, 2 and θ is a comparison operator. Attr returns the attributes referred to in the parameter. For a database instance I, the query result</p><formula xml:id="formula_0">Q[I] is πΓ[σC [R1 × . . . × Rn]].</formula><p>We specify a set of tuples missing from Q[I] by a Why-Not question. This is a query WN having the same input and output schemas as Q and whose conditions in CW are defined over the projected attributes of Q. Thus, the missing tuples are given by evaluating the query WN over I, i.e., <ref type="bibr">WN [I]</ref>. The missing tuples do not appear in the original query result, hence it holds that</p><formula xml:id="formula_1">Q[I] ∩ WN [I]=∅.</formula><p>Compatible tuples play a central role in our setting. Essentially, they are those concatenations of tuples in I that would yield the missing query results if they were not filtered by Q (e.g, Id1Id7 of Ex. 1.1). We define the set CT of compatible tuples by the query eWN that is simply obtained from WN by changing the output schema to Attr(S).</p><p>As explained in the introduction, we assume available the WhyNot polynomial that, following our definition in ( <ref type="bibr" target="#b1">Bidoit et al. 2015a</ref>), is a sum of addends, where each addend includes a coefficient and a product of conditions (e.g., 3c1c2, see Ex. 1.1). We refer to each product of query conditions as explanation, denoted E and use P EX to denote the set of all explanations given by the polynomial. In the sequel, we interchangeably present an explanation as a set or a product of conditions. The explanation Eτ associated to a given compatible tuple τ ∈ CT is defined as {c|c∈C and τ |=c}. Note that each compatible tuple is pruned by a unique explanation. For instance, E Id 1 Id 7 = {c1c2}.  <ref type="bibr">Actor]</ref>. One compatible tuple is Id4Id10, denoting the concatenation of the tuples Id4 and Id10. It does not satisfy c2, thus the explanation for its exclusion is E Id 4 Id 10 = {c2}. The set of all explanations is P EX={c2, c3, c1c2, c2c3, c1c3, c1c2c3} ( <ref type="figure" target="#fig_1">Fig. 1(d)</ref>).</p><p>Given a query Q, a Why-Not question WN , a database instance I, and the set of explanations P EX, the query refinement problem is stated as follows: find queries Q such that they return (i) all</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1: FixTed</head><p>Input: Q, W N , I, CT , PEX Output: SQ: set of query refinements for</p><formula xml:id="formula_2">Q 1 SQ = ∅; 2 foreach explanation E ∈ PEX do 3 Eσ = {c|c ∈ E ∧ c a selection condition}; 4 E1 = {c|c ∈ E ∧ c a join condition}; 5 Q E = {Q}; 6 if Eσ = ∅ then 7 Q mdr = M inDistRef inement(CT, Eσ, Q); /* Sec. 3.1 */ 8 Q E = Q mdr ∪ P reciser(Q mdr , CT, Q, I); /* Sec. 3.1 */ 9 if E1 = ∅ ∧ outerJoinsApply(Q, W N, E1)/* Thm. 3.2 */ 10 then 11 Qj = JoinT oOuterJoin(Q E , E1); /* Def. 3.4 */ 12 Q E = AdjustF orSel(Qj , W N, E); /* end Sec. 3.2 */ 13 SQ = SQ ∪ Q E ; 14 return rank(SQ);</formula><p>the original result tuples i.e.,</p><formula xml:id="formula_3">Q[I] ⊂ Q [I]</formula><p>, and (ii) at least one missing tuple i.e.,</p><formula xml:id="formula_4">Q [I] ∩ WN [I] = ∅.</formula><p>A query can be refined in many ways, but FixTed uses the explanations in P EX in order to compute useful refinements. We quantify the notion of usefulness of a refinement Q by two metrics: precision and similarity. Precision is</p><formula xml:id="formula_5">|Q [I]|−F P Q |Q [I]|</formula><p>, where F P Q is the number of false positive tuples, i.e., tuples output by Q that neither exist in the result of Q nor correspond to missing tuples. Similarity. Our approach changes a query Q, by either altering existing conditions or by adding new ones. Essentially, changing a selection condition means adjusting its constant value, whereas this is not applicable for join conditions. As for adding new conditions, we do so to improve the precision. In summary, the similarity of Q w.r.t. the original query Q, is measured by (i) the number of changed conditions, (ii) the distance of the new constants to the ones of the original conditions (when applicable), and (iii) the number of added conditions.</p><p>In our current implementation, the similarity between Q and Q is a weighted sum (denoted Sim) of these three metrics. Note that we choose difference for the distance of numerical values and edit distance for string values, although any distance measure can be used as a black box. Also, the overall usefulness of a refinement is currently computed as the weighted sum of precision and similarity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">The FixTed Algorithm</head><p>We now discuss how FixTed computes a set of useful refinements SQ, given a query Q, a database instance I, a Why-Not question WN , the set of compatible tuples CT , and the set of explanations PEX. Algorithm 1 shows a high-level pseudo-code. Essentially, FixTed iterates over each explanation and first splits the conditions of an explanation into selection and join conditions. It then continues by treating the selection conditions (e.g., c2) of an explanation. First, Minimum Distance refinement optimizes similarity while relaxing the conditions. Second, the P reciser tackles precision by adding new conditions to eliminate false positives. For join conditions (e.g., c3), we opt for outer-join rewriting, when possible (as checked by outerJoinsApply. As the null values introduced by outer-joins may interfere with the query selections, we adjust the refined query so that the expected results are produced. Finally, refinements are ranked based on their usefulness.</p><p>In the remainder of this section, we further discuss the individual steps of the algorithm. Without loss of generality, we assume that an explanation E either contains only selections or only joins.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Changing Selections</head><p>Minimum Distance Refinement Let E be an explanation with selection conditions. As multiple compatible tuples may have the same explanation, we refer to them by CTE = {τ |Eτ =E}. Intuitively, we are going to relax the condition(s) of E s.t. we enable compatible tuples from CTE to contribute to the expected result. In general, each compatible tuple may lead to one query refinement. However some of them are irrelevant as there similarity to Q is guaranteed not to be minimal. To prune these irrelevant compatible tuples, we resort to computing skyline tuples ( <ref type="bibr" target="#b3">Borzsony et al. 2001;</ref><ref type="bibr" target="#b12">Papadias et al. 2003</ref>) in the set CTE and only keep tuples on the skyline for further processing. That is, a tuple τ1 is pruned if there exists another tuple τ2, whose values are 'closer' to the respective values in E, corresponding to the values of the original query Q.</p><p>The tuple value distance for a τ , on an attribute A, is denoted by ∆ A τ . As we said in Sec. 2, it is either measured by numerical difference or edit distance. Definition 3.1. (Skyline tuples) Let τ1, τ2 ∈ CTE , given an explanation E and consider the set of attributes A=Attr(E). We say that τ1 dominates τ2 (denoted τ1 A τ2) if</p><formula xml:id="formula_6">1. ∀A ∈ A : ∆ A τ 1 ≤ ∆ A τ 2 (denoted τ1 A τ2)</formula><p>, and 2. ∃A ∈ A : ∆ A τ 1 &lt; ∆ A τ 2 (denoted τ1 A τ2). Then, τ2 is a skyline tuple iff there does not exist a tuple τ1 s.t. τ1 A τ2. The set of skyline tuples w.r.t. E is denoted SLE .</p><p>Example 3.1. For the explanation E=c1c2 in <ref type="figure" target="#fig_1">Fig. 1</ref>, the involved attributes are age and rating, whereas CTc 1 c 2 ={τ2:Id2Id8, τ3:Id3Id9, τ4:Id1Id7}. <ref type="figure" target="#fig_3">Fig. 2</ref> displays these tuples in the 2-dimensional space defined by age and rating. For instance, the coordinates of τ2 result from τ2(age) = 38 and τ2(rating) = 7.6. The coordinates of the point marked by E are given by E(age) = 35 and E(rating) = 8.2. For now, ignore the other points in the diagram. By Def. 3.1, it is easy to see that τ3 dominates τ2, whereas τ3 and τ4 do not dominate one another. Thus, the skyline tuples for c1c2 are SLc 1 c 2 = {τ3, τ4}.</p><p>So far, we have considered an explanation in isolation from the other explanations. To improve the efficiency, we further prune compatible tuples not yielding better refinements w.r.t. to similarity using the concept of local skyline tuples. This is done by taking into account the skyline tuples of sub-explanations of E.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.2.</head><p>Consider explanation c2, having CTc 2 ={τ1:Id4Id10}. It is easy to prove that any compatible tuple, e.g., τ1, cannot be dominated by a compatible tuple pruned by a super-explanation, in our example c1c2. However the reverse is possible. For instance, in <ref type="figure" target="#fig_3">Fig. 2</ref>, we observe that τ1 {age,rating} τ3. So, even though τ3 is a skyline tuple for the explanation c1c2 in isolation, we know that there is a more similar Definition 3.2 (Local skyline tuples w.r.t. an explanation). Let SLE be the set of skyline tuples for an explanation E by Def. 3.1. Let E be the set of sub-explanations of E, and T = E ∈E SL E be the union of the skyline tuples for the explanations in E. Then, the set of local skyline tuples w.r.t E is lSLE ={t ∈ SLE || ∃t ∈ T s.t. t Attr(E t ) t}</p><p>Each tuple in lSLE yields one query refinement, obtained by replacing the values of the conditions in E by the values from the tuples in lSLE . If the comparison in the original condition is &lt; (&gt;), then it is changed to ≤ (≥). If it is =, it is changed to ≤ or ≥. If it is =, then the condition is completely removed. We denote by Q mdr the set of query refinements obtained in this phase.</p><p>Example 3.3. From the previous examples, we conclude two sets of local skyline tuples: lSLc2={τ1} and lSLc 1 c2={τ4}. This entails two refinements: one (resp. the other) with the effect to get τ1 (resp. τ4) appear in the result in addition to the original result tuple r1. Thus, we obtain the set of queries Q mdr ={Q1, Q4}, with condition sets C1={c1, rating ≥ 8.1, c3} and C4={age ≤ 42, rating ≥ 8.2, c3}, respectively. Note that <ref type="figure" target="#fig_1">Fig. 1(c)</ref> corresponds to Q1.</p><p>Related works <ref type="bibr" target="#b13">(Tran and Chan 2010;</ref><ref type="bibr" target="#b11">Islam et al. 2014</ref>) also use the skyline method for selection refinement. However they consider (i) all compatible tuples simultaneously and (ii) all the attributes from the selections in Q, even if these selections are not problematic (e.g., not part of any explanation). This approach renders the computation of the skyline tuples more complex and may lead to changing correct selections in the query. On the other hand, using the Why-Not polynomial we consider subsets of (partial) compatible tuples and subsets of the attributes in selections of Q, and thus we avoid unnecessary tuple comparisons and conditions changes.</p><p>As we said, the Why-Not polynomial models all the possible ways in which the conditions of the query are erroneous. For each such explanation, we guarantee to find the refinement with minimal similarity. The similarity is based on three metrics (see Sec. 2). For a given explanation E, the number of conditions is invariant, so the similarity does not depend on the first metric. As for the third metric, adding conditions for the benefit of precision can only reduce similarity. Thus, finding the minimal similarity reduces to finding the minimal value changes in conditions (second metric), which is guaranteed by the procedure described above. This leads to the following theorem. Theorem 3.1 (Maximal Similarity). Let Qm be a query refinement of Q, and let Simm be its similarity to Q. If for each Qi∈Q mdr , it holds that Simm≤Simi, then Qm∈Q mdr .</p><p>Preciser We now move to the phase that aims at improving the precision of refinements in Q mdr (generating potentially less similar, but more precise solutions the user can then choose from). To improve precision, we further constrain the queries in Q mdr by either changing more conditions or by adding new conditions. Note that we do not guarantee that the produced refinements include the most precise query refinement. The local skyline tuples again play a central role in generating the new conditions. Example 3.4. Consider the query Q1 associated with the skyline tuple τ1 in Ex. 3.3. Q1[I]={r1, τ1, f p1} contains the false positive tuple f p1:Id5Id11. In <ref type="figure" target="#fig_3">Fig. 2</ref> we see that changing the other selection condition age≤35 of Q1 to age≤34 (the minimum age to retain both r1 and τ1 in the result) does not eliminate f p1. Thus, we proceed by adding more selections, using attributes from the input query schema. For Q1 we obtain the following three refinements with a 100% precision (we only display the condition sets):</p><formula xml:id="formula_7">C 1 ={c1, rating ≥ 8.1, 194 ≤ length ≤ 136, c3} C 1 ={c1, rating ≥ 8.1, 1997 ≤ year ≤ 1999, c3} C 1 ={c1, rating ≥ 8.1, M atrix ≤ title ≤ T itanic, c3}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Changing Joins</head><p>Applicability of Refining Joins to Outer Joins We now move to processing join conditions. Again, for conciseness and without loss of generality, let us assume that E includes join conditions only.</p><p>In principle, we could employ the same technique as described above. However, this would relax equi-joins to theta joins or even cross products. Indeed, there is no other possibility to make the corresponding compatible tuple, e.g., Id6Id10 participate to the query result. However, cross products are usually not recommended for efficiency reasons typically have low precision scores. Hence, we investigate an alternative resorting to outer joins.</p><p>Central to our solution is the notion of direct relations, which contain the exact information that the user is missing. For example, Actor is a direct relation because it contains tuples with the missing value DiCaprio, whereas M ovie is indirect.</p><p>Definition 3.3 (Direct relation). Let R∈S be a relation, and CW be the condition set of the Why-Not question. Then, R is direct iff ∃c ∈ CW s.t. c is defined over R. Otherwise, R is indirect.</p><p>A join in an explanation indicates that the compatible tuples from the direct relation do not find the correct join partners. Thus, replacing a join by an outer join may solve the problem.</p><p>Example 3.5. If we replace the join c3, i.e., Actor 1c 3 M ovie by Actor c 3 M ovie and assume (for the moment) that no selections exist in the query, we obtain the tuple (DiCaprio, N U LL) that satisfies the Why-Not question.</p><p>Unfortunately, it is not always possible to refine a join condition with outer join. Intuitively, this depends on whether we can put all the direct relations as the left (resp. right) operand of the left outer join (resp. right outer join). This is necessary in order to retrieve all missing values specified by the Why-Not question in a single tuple (all other cases replace some missing values with null values, and so fail to satisfy the Why-Not question).</p><p>Let GQ denote the graph modeling the relations (nodes R) and joins (edges c) of Q. Two relations R1 and R2 are connected in the graph if there exists in CQ a join R1.A θ R2.B. The following theorem states that a join refinement is applicable if the join in the explanation does not (transitively) connect two direct relations.</p><p>Theorem 3.2. Let GQ be the join graph of a query Q and let E={c1} be a join explanation, where c1 = R1.A θ R2.B. Then, a join refinement is applicable for Q, iff c1 does not belong to any path from relation R k to R l in GQ.</p><p>Join refinement After checking that a join refinement is applicable, we proceed by changing the join to left (or right) outer-join.</p><p>Definition 3.4. (Join refinement) With the above hypothesis, and if applicable by Theorem 3.2, a join refinement Q for Q is given by Q =(S, Γ, C ) s.t. C =(C \{c1})∪{R1 θ R2}(resp.R1 θ R2) and R1 (resp. R2) is a direct relation.</p><p>Join refinements are easily extended to more than one join in E. Adjust for selections Up to this point, we have considered the join in isolation. However, if we look back to the example query and the selections c1 and c2, the join refinement of Ex. 3.5 would not return DiCaprio, as the NULL values introduced by the outer join fail the selection predicate of c2. We need to adjust our final refinement. We distinguish two cases: if the schema constraints prevent the source data to contain NULL values in attributes of a selection ci of the form R.A θ v, where R is an indirect relation, then the condition may be rewritten to (ci OR R.A IS NULL). Otherwise, we create subqueries for replacing the relations over which selections are specified. Then, the joins of the query are specified over the respective subqueries in the refined query. Example 3.6. Considering the full query of our running example and the explanation c3, the refined query corresponds to the following SQL query statement. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Outlook and Future Work</head><p>This paper presents FixTed, the first algorithm leveraging Why-Not polynomials to refine queries such that missing, but expected query results are recovered. FixTed thereby improves on the state of the art by guaranteeing refinements with maximum similarity to the original query and ensuring that all possible cases of why the desired data was missing are covered. Additionally, it is the first algorithm to refine joins using outer joins. A prototype implementation ( <ref type="bibr" target="#b2">Bidoit et al. 2015b</ref>) demonstrates the feasibility and effectiveness of our approach. Besides a thorough experimental evaluation of FixTed, we plan to extend it in several aspects,e.g, by introducing more refinement possibilities for joins.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>(</head><label></label><figDesc>d) Why-Not polynomial: each addend provides an explanation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Running example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 2 . 1 .</head><label>21</label><figDesc>The Why-Not question of Ex. 1.1 is expressed by the relational query π name,title [σ name='DiCaprio [M ovie × Actor]]. The set of compatible tuples is returned by σ name='DiCaprio [M ovie ×</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Example for minimum distance refinement</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>SELECT A.name, M.title FROM (SELECT * FROM Actor WHERE age ≤ 35) AS A LEFT OUTER JOIN (SELECT * FROM MOVIE WHERE rating &gt; 8.2) AS M ON A.film = M.title</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 1 . Preliminary queries and tuples</head><label>1</label><figDesc></figDesc><table></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Immutably answering whynot questions for equivalent conjunctive queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Bidoit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herschel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Tzompanaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX TAPP Workshop</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient computation of polynomial explanations of why-not questions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Bidoit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herschel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Tzompanaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">EFQ: Why-not answer polynomials in action</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Bidoit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herschel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Tzompanaki</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
			<publisher>PVLDB</publisher>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="1980" to="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The skyline operator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Borzsony</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kossmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Stocker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="421" to="430" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Answering why-not questions on spatial keyword top-k queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="279" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Relaxation as a platform for cooperative answering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Gaasterland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Godfrey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Minker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Intelligent Information Systems</title>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Answering why-not questions on reverse top-k queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="738" to="749" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Answering why-not questions on top-k queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Lo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TKDE</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1300" to="1315" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">On the provenance of non-answers to queries over extracted data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
			<publisher>PVDLB</publisher>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">User feedback based query refinement by exploiting skyline operator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Islam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ER</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="423" to="438" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">On answering why-not questions in reverse skyline queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Islam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Flexiq: A flexible interactive querying framework by exploiting the skyline operator</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Islam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="page" from="97" to="117" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">An optimal and progressive algorithm for skyline queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Seeger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<editor>B. ten Cate, C. Civili, E. Sherkhonov, and W. Tan</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="467" to="478" />
		</imprint>
	</monogr>
	<note>PODS</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">How to ConQueR why-not questions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">T</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-Y.</forename><surname>Chan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Query reverse engineering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">T</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">Y</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Parthasarathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB Journal</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="721" to="746" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
