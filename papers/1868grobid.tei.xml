<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:14+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Evolutionary Study of Linux Memory Management for Fun and Profit An Evolutionary Study of Linux Memory Management for Fun and Profit</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>June 22-24. 2016</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jian</forename><surname>Huang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Georgia Institute of Technology</orgName>
								<orgName type="institution" key="instit2">USENIX Association</orgName>
								<orgName type="institution" key="instit3">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moinuddin</forename><forename type="middle">K</forename><surname>Qureshi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Georgia Institute of Technology</orgName>
								<orgName type="institution" key="instit2">USENIX Association</orgName>
								<orgName type="institution" key="instit3">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karsten</forename><surname>Schwan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Georgia Institute of Technology</orgName>
								<orgName type="institution" key="instit2">USENIX Association</orgName>
								<orgName type="institution" key="instit3">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jian</forename><surname>Huang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Georgia Institute of Technology</orgName>
								<orgName type="institution" key="instit2">USENIX Association</orgName>
								<orgName type="institution" key="instit3">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moinuddin</forename><forename type="middle">K</forename><surname>Qureshi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Georgia Institute of Technology</orgName>
								<orgName type="institution" key="instit2">USENIX Association</orgName>
								<orgName type="institution" key="instit3">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karsten</forename><surname>Schwan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Georgia Institute of Technology</orgName>
								<orgName type="institution" key="instit2">USENIX Association</orgName>
								<orgName type="institution" key="instit3">Georgia Institute of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">An Evolutionary Study of Linux Memory Management for Fun and Profit An Evolutionary Study of Linux Memory Management for Fun and Profit</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2016 USENIX Annual Technical Conference (USENIX ATC &apos;16)</title>
						<meeting>the 2016 USENIX Annual Technical Conference (USENIX ATC &apos;16) <address><addrLine>Denver, CO, USA</addrLine></address>
						</meeting>
						<imprint>
							<biblScope unit="page">465</biblScope>
							<date type="published">June 22-24. 2016</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 2016 USENIX Annual Technical Conference (USENIX ATC &apos;16) is sponsored by USENIX.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We present a comprehensive and quantitative study on the development of the Linux memory manager. The study examines 4587 committed patches over the last five years (2009-2015) since Linux version 2.6.32. Insights derived from this study concern the development process of the virtual memory system, including its patch distribution and patterns, and techniques for memory optimizations and semantics. Specifically, we find that the changes to memory manager are highly centralized around the key functionalities, such as memory alloca-tor, page fault handler and memory resource controller. The well-developed memory manager still suffers from increasing number of bugs unexpectedly. And the memory optimizations mainly focus on data structures, memory policies and fast path. To the best of our knowledge, this is the first such study on the virtual memory system.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The virtual memory system has a long history. It was first proposed and implemented in face of memory scarcity in 1950s <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b78">81,</ref><ref type="bibr" target="#b83">86]</ref>. With this technique, the main memory seen by programs can be extended beyond its physical constraints, and the memory can be multiplexed for multiple programs. Over the past several decades, the virtual memory has been developing into a mature and core kernel subsystem, the components and features it has today are far more than the basic functionalities (i.e., page mapping, memory protection and sharing) when it was developed <ref type="bibr" target="#b21">[22]</ref>.</p><p>However, today's virtual memory system still suffers from faults, suboptimal and unpredictable performance, and increasing complexity for development <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b39">41,</ref><ref type="bibr" target="#b59">62,</ref><ref type="bibr" target="#b68">70,</ref><ref type="bibr" target="#b79">82]</ref>. On the other hand, the in-memory and big memory systems are becoming pervasive today <ref type="bibr" target="#b55">[57,</ref><ref type="bibr" target="#b87">91]</ref>, which drives developers to re-examine the design and implementation of the virtual memory system. A quantitative study of the virtual memory system's development process is necessary as developers move forward to next steps. The insights derived from the study can help developers build more reliable and efficient memory management systems and associated debugging tools.</p><p>In this paper, we perform a comprehensive study of the open-source Linux memory manager (mm). We examine the patches committed over the last five years from 2009 to 2015. The study covers 4587 patches across Linux versions from 2.6.32.1 to 4.0-rc4. We manually label each patch after carefully checking the patch, its descriptions, and follow-up discussions posted by developers. To further understand patch distribution over memory semantics, we build a tool called MChecker to identify the changes to the key functions in mm. MChecker matches the patches with the source code to track the hot functions that have been updated intensively.</p><p>We first investigate the overall patterns of the examined patches. We observe that the code base of Linux mm has increased by 1.6x over the last five years, and these code changes are mainly caused by bug fixes (33.8%), code maintenance (27.8%), system optimizations (27.4%) and new features (11.0%). More interestingly, we find that 80% of the mm patches are committed to 25% of the source code, indicating that its updates are highly concentrated. Such an observation discloses the targeted code regions for our study and future development on virtual memory system. Furthermore, we examine the bugs in Linux mm. We identify five types of bugs: memory error, checking, concurrency, logic and programming. These bugs are mainly located in the functional components of memory allocation, virtual memory management and garbage collection. Specifically, mm is suffering from more concurrency and logic bugs due to its complicated page state management. For example, the memory leaks are mainly caused by the incorrect settings of page states rather than non-freed pages; a significant number of logical incorrectnesses are caused by missing checks on page states.</p><p>We further investigate the system optimization patches in mm. We identify three major sources: data structure, memory policy and fast path. (1) For data structure, we find that 76.2% of patches are committed for software overhead reduction, and 23.8% of them contributed to scalability improvement, across the four popular data structures: radix tree, red-black tree, bitmap and list, and their derived structures. (2) For policy patches, we find that most of them are concentrated around five design trade-offs: lazy vs. non-lazy, local vs. global, sync vs. async, latency vs. throughput and fairness vs. performance. For example, OS developers can alleviate overhead caused by expensive operations (e.g., memory com- <ref type="table">Table 1</ref>: A brief summary of the Linux mm patch study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary</head><p>Insights/Implications Overview 4 types of patches (i.e., bug, optimization, new feature, code maintenance) were committed to 8 major mm components (e.g., memory allocation, resource controller and virtual memory management). The patch distribution is highly centralized ( § 3).</p><p>(1) the identified 13 hot files from the massive mm source code (about 90 files) unveil the focus of the recent mm development; (2) with these knowledge, developers can narrow their focus to pinpoint mm problems more effectively.</p><p>Bug 5 types of bugs (i.e., checking, concurrency, logic, memory error and programming) have various patterns: null pointer and page alignment are the popular memory errors; checking and logic bugs are pervasive due to the complicated page state management ( § 4).</p><p>(1) a set of unified and fine-grained page states can be defined to reduce the effort on page tracking for kernel developers; (2) the page state machine should be combined with lock schemes to avoid unnecessary locks; (3) a formal, machine-checked verification framework for mm is needed.</p><p>Optimization 4 types of data structure (i.e., radix tree, red-black tree, bitmap and list) optimizations on software overhead reduction and scalability improvement ( § 5.1).</p><p>(1) careful examination on nested data structures is necessary to avoid the consequential side effects as we adjust data structures; (2) the internal scalability inside system calls is not well exploited yet.</p><p>Memory policies are tackling 5 design trade-offs: lazy vs. non-lazy, local vs. global, sync vs. async, latency vs. throughput and fairness vs. performance ( § 5.2).</p><p>(1) lazy policy is preferred as mm interacts with fast devices like processor cache, while async policy is mostly used for the interaction with slow devices like disk; (2) a large amount of latency-related patches suggest that mm profilers are desired to identify more latency-critical operations; Fast path has 8 types of approaches: code reduction, lockless optimization, new function, state caching, inline, code shifting, group execution and optimistic barrier. ( § 5.3).</p><p>(1) alleviating redundant functions and reducing lock contentions are the two major contributors for reducing software overhead; (2) these techniques can be generalized and applied in other software systems. <ref type="bibr">Semantic</ref> 35 key functionalities are identified in 13 hot files in Linux mm. A majority (75.6%) of them absorb much more patches on bug fix and optimization. Certain patch pattern is seen for each functionality ( § 6).</p><p>(1) the well-developed memory allocators still have tremendous checking and lock issues due to the increasing complexity of page state management; (2) the fault handler in mm is buggy, especially for the cases of out of memory and allocation failures; (3) the patch patterns on memory policy suggest that a policy verification and validation framework is in pressing need;</p><p>paction, TLB flush) with lazy policies, but associated checking mechanism has to be implemented to guarantee the program logic is not violated (more patches on this part are committed than the optimization patch itself). (3) We identify eight types of approaches <ref type="table" target="#tab_6">(Table 6)</ref> for fast path optimization in Linux mm, such as code reduction, lockless optimization and state caching.</p><p>With the MChecker tool, we study the patch distribution over the core mm functions to understand the various patterns on memory semantics. Taking the memory policy as example, we categorize it in two types: policy definition and enforcement. We find that policy definition has more issues than enforcement. And 30% of the patches were addressing the issues caused by missing checks (e.g., whether page is dirty), missing one check fails the policy enforcement.</p><p>We briefly summarize the key findings and present the outline of the paper in <ref type="table">Table 1</ref>. We discuss the related work in § 7 and conclude the paper in § 8. In the following, we describe the methodologies used in our study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methodology</head><p>In our study, we target at open-source Linux memory managers, as they provide much more resources (e.g., source code, patches, online discussions) for such a study compared to commercial operating systems. We only select the stable versions that are still supported by the open-source community. The selected Linux kernel versions range from 2.6.32 (released on December 2, 2009) to 4.0-rc4 (released on <ref type="bibr">March 15, 2015)</ref>   difference between the release dates of two successive versions is 12 months on average. It is noted that Linux 2.6.32 is the oldest version that is still supported. Thus, we believe our study over the past five years represents the latest development trend of the Linux mm.</p><p>In order to have a comprehensive study of the selected virtual memory system, we manually examine most of the committed patches to Linux memory manager (root/mm) following the approaches described in  To precisely analyze and categorize each examined patch, we manually tag each patch with appropriate labels after checking the patch, its descriptions, corresponding source code changes, and follow-up discussions posted by developers. The labels include LinuxVersion, CommitTime, SrcFile, MMComponent, PatchType, Consequence, Keywords, Causes, Note and etc. For the patch that belongs to several categories, it will be classified into all the respective categories and studied from different viewpoints. We place all the examined patches into our patch database MPatch for patch classification and statistical analysis.</p><p>To facilitate our analysis, we break down the Linux mm into 8 components according to the functionalities (see <ref type="figure" target="#fig_0">Figure 1)</ref>. We match the examined patches with each component. Taking the Linux version 4.0-rc4 for example, we use the SLOCCount tool <ref type="bibr">[74]</ref> to count the line of codes (LoC) in each component. <ref type="figure" target="#fig_0">Figure 1</ref> shows the fraction of code serving to accomplish specific functionalities in mm. The two largest contributors to Linux mm code are memory allocation (28.7%) and virtual memory management (30.0%). This is expected with considering their core functions in virtual memory system. We will discuss how the patches are distributed among these eight components in detail in the following sections.</p><p>To further analyze the examined patches, we build a patch analysis tool called MChecker to understand the memory semantics by mining the relationships between patches and the key functions in the 'hot' files of Linux mm. This will be discussed in detail in § 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Virtual Memory Evolution</head><p>Linux mm is constantly updated like other subsystems (e.g., file systems, device drivers) in the Linux kernel. However, few quantitative studies have been done on the Linux mm. In our study, we conduct the virtual memory study from the oldest stable version 2.6.32 until the version 4.0, demonstrating what mm developers concentrated on over the past five years.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">How is the mm code changed?</head><p>Taking the Linux 2.6.32 version as the baseline, we examine the source lines of code changes in different Linux mm components.We obtain the LoC across different mm component in total 7 versions using SLOCCout.</p><p>As shown in <ref type="figure" target="#fig_1">Figure 2</ref>, the LoC is increased in all the mm components across successive years compared with the baseline 2.6.32. Overall, Linux mm code base has increased by 1.6x over the last five years. Memory allocation and virtual memory management are the two major components in mm, the updates to the two components constantly occupy a large portion of the overall patches.</p><p>Understanding the code changes is important for us to pinpoint how the Linux mm is evolved. More detailed analysis is given on where and why the mm code has been changing in the following. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Where is the mm code changing?</head><p>The patches applied to Linux mm record all the changes to its code base and provide the evidences showing how one version transforms to the next. <ref type="figure" target="#fig_2">Figure 3</ref> demonstrates the patch distribution among all the components in Linux mm. One patch may be applied to several files in mm, we count it to all the involved files. The average source LoC changed in each patch is 62, it is much less than the source LoC in feature patches. For example, the compressed swap caching (zswap) was introduced in 2013 <ref type="bibr" target="#b81">[84]</ref>, and a new file named zswap.c with 943 LoC was added in the code base of Linux mm.</p><p>We identify several interesting findings via the heat map. First, the patches are concentrated around only a few files in each component (see the darker column and blocks in the heat map of <ref type="figure" target="#fig_2">Figure 3</ref>). About 80% of the patches were applied to the 25% of the source code. These hot files generally represent the core functions of the corresponding component. Second, the patches applied to these hot files are much more than other files. For instance, the number of patches relevant to huge mem in virtual memory management component is about 12x more than that of 'cold' files. Third, for these hot files, most of them are constantly updated along the Linux evolution from one version to the next. Typical examples include the memcontrol in memory resource controller, the memory in virtual memory management.</p><p>It is understandable that more patches are committed between Linux 3.2 and 3.10 compared to other intervals, as the time between the two versions is 19 months which is longer than the average time interval (12 months).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Why is the mm code changed?</head><p>We identify that the mm source code changes come from four sources: new feature, bug fixes, optimization and code maintenance. We classify the patches into these four categories, and examine how each category contributes to the evolution of Linux mm.  <ref type="figure" target="#fig_4">Figure 4</ref> shows the patch distributions among the 8 components. Overall, 33.8% of the patches are applied for bug fixes, 27.8% of the patches are relevant to code maintenance, 27.4% are for system optimizations, and 11.0% are new features. Common sense suggests that virtual memory system has been developed into a mature system, our findings reveal that the bug fixes are still the main thread of patch contributions.</p><p>Furthermore, we examine how the four types of patches changed over time. As shown in <ref type="figure" target="#fig_5">Figure 5</ref>, we find that bug patches are increasing steadily, indicating more bugs are expected in Linux mm as the complexity of its code base is increasing (see <ref type="figure" target="#fig_1">Figure 2</ref>). The percentage of code maintenance and new feature patches keep at a constant level in general, but a slightly increase in new feature patches is seen recently. Perhaps most interestingly, optimization patches are decreasing over time, which can be expected as Linux mm becomes more adapted to current systems (e.g., multi-core processors).</p><p>Summary: Linux mm is being actively updated, The code changes are highly concentrated around its key functionalities: 80% of the patches were committed to the 25% of the source code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Memory System Bugs</head><p>In this section, we examine the bug patches in detail to understand their patterns and consequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">What are mm bugs?</head><p>With the tagging of these patches, we classify the bug patches into 5 general types: memory error (MErr), checking, concurrency, logic and programming. Each general type is further broken down into multiple subtypes according to their causes, as shown in <ref type="table" target="#tab_1">Table 2</ref>. Like the systems such as file systems <ref type="bibr" target="#b35">[37]</ref> and device drivers <ref type="bibr" target="#b28">[29]</ref>, many bugs are general software bugs (e.g., programming bugs). In this paper, we are more interested in memory-related bugs, for example the alignment bugs in MErr, and the logic bugs ( § 4.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">How mm bugs are distributed?</head><p>The heat map of Linux mm bug distribution among its eight components is shown in <ref type="figure" target="#fig_6">Figure 6</ref>. More bugs lie in  the three major components memory allocation, virtual memory management, and GC, which matches with the patch distribution as shown in <ref type="figure" target="#fig_2">Figure 3</ref>. More specifically, we identify several interesting findings in mm: Memory Error (MErr): We find that null pointer dereferences (e.g., <ref type="bibr" target="#b43">[45,</ref><ref type="bibr" target="#b65">67,</ref><ref type="bibr" target="#b73">76]</ref>) are the most common bugs because of the missing validations of pointers before using them in mm. These bugs happened even in mm's core functions such as slub, which is unexpected. The alignment of data structures and pages are important factors in mm optimizations, however bugs frequently happen at boundary checking and calculations for padding (e.g., <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>). As they usually involve many shift operations, validating the correctness of the bit manipulations is necessary.</p><p>Checking: As mm involves many state checking operations, especially in memory allocation and garbage collection (GC) components. The checking bugs appear frequently due to inappropriate and incorrect checking, for instance, the GC has to check if a page is used or not before the page migration is issued; free bootmem core may free wrong pages from other nodes in NUMA without correct boundary checking <ref type="bibr" target="#b45">[47]</ref>.</p><p>Concurrency: We find that more miss lock and lock contention bugs appeared in virtual memory management due to the complicated page states, and more efforts are required for kernel developers to track the page states. In addition, the page state machine can be combined with lock schemes to avoid unnecessary locks, for instance, when kernel pages are charged or uncharged, the page cgroup lock is unnecessary as the procedure has been serialized (e.g., <ref type="bibr" target="#b38">[40]</ref>).</p><p>Logic: We identify three important logic bugs: caseby-case, state update and fault handler. For the first two types, they may not stall the system or generate exceptions immediately, but they make the system execute in unexpected workflow or states, resulting in incorrect states or runtime error eventually. Fixing these bugs often require domain specific knowledge. For example, when shmem intends to replace a swap cache page, the original implementation calls cgroup migration without lrucare based on the incorrect assumption that the page is not on the LRU list. As for fault handler bugs, many of them were caused by lack of or inappropriate implementation of exception handling (e.g., <ref type="bibr" target="#b54">[56,</ref><ref type="bibr" target="#b74">77,</ref><ref type="bibr" target="#b82">85]</ref>).</p><p>There is still a long way to have a bug-free virtual memory system. It is much hard for formal proof to verify the correctness of concurrency events <ref type="bibr" target="#b30">[31]</ref>, and few previous work has the formal, machine-checked verification for virtual memory system specifically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">What are the mm bug consequences?</head><p>We further examine the consequences of mm bugs to understand how serious they are. We classify the bug consequences into 7 types with reference to the classification in <ref type="bibr" target="#b35">[37]</ref>. <ref type="figure" target="#fig_7">Figure 7</ref> shows that logic bugs lead to wrong behaviors and runtime errors with higher chances. Concurrency bugs are more likely to make system crash or hang, since they often produce null pointers and deadlocks if Moreover, we find that checking bugs are also the major contributors to the wrong behaviors and runtime errors in Linux mm. More interestingly, we find that the memory leaks are mainly caused by MErr and logic bugs. It is noted that most of the memory leaks in mm are not caused by not-freed memory, they are mostly caused by the accounting (e.g., the unused page is not counted as free page) and fault handler bugs (e.g., pages are not reclaimed when fault happens). For programming bugs that mainly cause compilation errors, runtime error and wrong behaviors, they are easier to be fixed compared with other types of bugs.</p><p>Summary: Memory leaks in mm were mainly caused by the accounting bugs and inappropriate implementation of fault handler (e.g., page fault), instead of non-freed memory. The complex states of pages complicate the implementation of the checking and locking mechanism, which requires large effort for kernel developers to track the correct states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Memory Optimizations</head><p>As discussed in § 3, optimization (27.4% of total patches) is one of the major contributors to the code changes in Linux mm. We identify several sources that contributed to the optimizations in mm: data structure, policy and fast path. In this section, we will explain how these optimizations were performed in improving Linux mm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Memory Data Structures</head><p>In virtual memory system, data structure is one the critical factors for its efficiency <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b19">20]</ref>. Likewise, the data structures in Linux mm are constantly tuned to reduce software overheads, and specialized data structures are leveraged for special purposes such as page lookup and memory allocation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">What are the common data structures?</head><p>We identify four popular data structures in Linux mm: radix tree, red-black tree, bitmap and list, according to their relevant patch distributions.</p><p>Radix tree <ref type="bibr" target="#b62">[65,</ref><ref type="bibr" target="#b63">66]</ref> is typically used within address space structure in Linux mm for tracking in-core pages for page caches, because of its storage efficiency for sparse trees. Red-black tree <ref type="bibr" target="#b67">[69]</ref> such as the one in vm area struct can perform lookups in logarithmic   time, and its insert and delete operation can be finished in bounded time. It is used to track VMAs. Bitmap is usually used to index pages in RAM, which involves bit manipulation frequently. Besides these specific data structures, other data structures such as list are widely used in Linux mm. Most of the recent patches are related to their derived data structures, such as LRU list which is used by multiple mm components to track page access frequency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">How are data structures optimized?</head><p>We identify that the optimization of mm data structures mostly focuses on two aspects: software overhead reduction (76.2%) and scalability improvement (23.8%).</p><p>Reducing software overhead. In Linux mm, we find that the software overhead on these data structures mainly come from the following sources: tree walk, tree balance, lock contention and storage cost. A variety of approaches have been applied to address these issues as shown in <ref type="table" target="#tab_3">Table 3</ref>. For instance, to reduce lock contentions, multiple lookups can be performed in batch once a lock is acquired.</p><p>Reorganizing data structures is another approach that usually adopted to improve memory efficiency. However, this approach may introduce additional overhead that offsets its benefits. Beyond our expectation, a significant portion of patches were applied to avoid the extra overhead caused by nested data structures. An interesting example is shown in <ref type="figure" target="#fig_8">Figure 8</ref>. The structure memcg cache param in Linux version 4.0 shrinks compared to its initial design in version 3.8. However, the saved memory does not justify, as the pointer dereference in its correlated structure kmem cache may cause extra cache line access. Thus, the pointer was replaced with embedded variable <ref type="bibr" target="#b71">[73]</ref>. As we adjust data structures in virtual memory system, their referenced data structures are often overlooked, producing side effects.</p><p>Improving scalability for data structures. Scalability issue is another major aspect of data structure optimizations. Most of the scalability issues are caused by locking for atomic access to shared data structures. We find that a main thread of the applied patches is to decentralize the data structures and replace the shared counterparts with per-core, per-node and per-device approaches.</p><p>With the increasing memory size and core counts, the scalability issues become more prominent <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b86">90]</ref>, appropriate usage of data structures is critical for both performance and memory efficiency, such as recent work <ref type="bibr" target="#b10">[11]</ref> suggested that replacing red-black tree with radix tree to track non-overlapping virtual memory regions for mmap and munmap provides better scalability. Furthermore, the system support for new memory technologies like persistent memory bring new scalability challenges, the dramatically increased physical memory capacity generates large pressure on memory management, e.g., a 1 TB of persistent memory with 4 KB page size requires 256 million page structures <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b58">61]</ref>.</p><p>To scale OS kernels, Clements et al. <ref type="bibr" target="#b11">[12]</ref> proposed a commutativity tool to guide the implementation of highlevel APIs, however it cannot expose the internal scalability issues (e.g., global vs. local data structure) inside the system calls. Our findings on mm data structures suggest that it is necessary to build tools to check the bottlenecks introduced by global and shared data structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary:</head><p>The software overhead and scalability issues caused by data structures remain big concerns for OS developers: more efforts on systemwide optimization for nested data structures, and the internal scalability inside system calls are required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Policy Design: Tackling Trade-offs</head><p>Memory is one of the most desired yet constrained resource in computer systems, multiple design trade-offs have to be made to fully utilize the resource and to improve performance. We find that a majority of the patches relevant to the policy design are concentrated on tackling these trade-offs. Through the patch study, we expect to learn from the lessons with policy designs and implementations conducted by OS developers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">What are the trade-offs?</head><p>Based on our patch study, we summarize the trade-offs that OS designers have frequently tackled in <ref type="table" target="#tab_4">Table 4</ref>, and also present a case study for each of them. The software overhead caused by expensive operations, such as memory compaction, page migration and TLB flush, can be  significantly alleviated using asynchronous or lazy policies. However, such benefit is not free because they complicate the program logic, leading into serious runtime errors like data inconsistency. We will present how the policy design decisions were made in Linux mm, with a focus on the new class of mm optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">How are the policy decisions made in mm?</head><p>Latency matters in memory manager. This trade-off of latency vs. throughput centers around the page cache and write-back component in mm. The I/O requests are issued in batch and served in a disk-friendly order to exploit the full bandwidth of disks for high throughput, but it may increase I/O latency. For instance, the original design of readahead component favors sequential access for higher I/O throughput, making the average latency of random reads disproportionately penalized <ref type="bibr" target="#b66">[68]</ref>. A general approach on decision-making for this trade-off is to prioritize the dominate workloads patterns, so systems pay little or acceptable cost on its downsides. More interestingly, we identify 137 patches committed specially for reducing the latencies of mm operations (e.g., page allocation, vma lookup, page table scanning). As in-memory systems are becoming pervasive and latency matters to today's application services, it is worthwhile to build mm profilers or test framework to identify more latency-critical operations.</p><p>Async is popular, but be careful to its faults. Asynchronous operations are widely used to hide expensive operations in mm. For example, async compaction was introduced to reduce the overhead caused by expensive memory compaction; the expensive trim command <ref type="bibr" target="#b77">[80]</ref> in SSDs should be issued in parallel with other I/O operations before actual writes happened due to its long latency. We find that the common issues in implementing async mechanisms located in their fault handlers for exceptions (e.g., early termination <ref type="bibr" target="#b44">[46]</ref>).</p><p>Trying lazy policy to alleviate expensive operations. The key idea of lazy policy is to delay several expensive operations, and batch them into a single operation or system call if semantics are allowed. <ref type="table" target="#tab_5">Table 5</ref> shows a set of cases that have leveraged lazy policy to reduce the frequency of expensive operations. In contrast to async policy used usually as mm interacts with slow devices, lazy policy is more beneficial when mm components interact with fast devices (e.g., CPU, processor cache, TLB) according to our patch studies.</p><p>Since lazy policy may change the execution order of subsequent functions, which would make systems in unexpected states temporarily, careful examination should be conducted as we decide whether a specific function should be delayed or not. For instance, the operation of flushing virtual cache on vunmap in pcpu unmap cannot be deferred as the corresponding page will be returned to page allocator, while TLB flushing can be delayed as the corresponding vmalloc function can handle it lazily <ref type="bibr" target="#b17">[18]</ref>.</p><p>Decentralizing global structures for better scalability. As seen in our patch study, more per-node, per-cpu variables are replacing their global counterparts to improve the system scalability. For example, new dynamic per-cpu allocator was introduced to avoid the lock contention involved in memory allocations. This approach has also been widely adopted in other subsystems such as device drivers, CPU scheduler and file systems.</p><p>Memory resource scheduling for fairness and performance. The trade-off between fairness and performance is a well-known yet hard problem. In Linux mm, we find that this type of patches mainly concentrated on the memory allocation and reclamation. In page allocation, round-robin algorithm is used to guarantee zone fairness. However, this algorithm did not consider the latency disparity across zones, resulting in remote memory reference and performance regression. During page reclamation, the allocator reclaimed page in LRU order which can only provide the fairness for low order pages but not for pages at higher order, which could penalize the performance of the applications (e.g., network adapter) that desire high-order pages <ref type="bibr" target="#b36">[38]</ref>.</p><p>Summary: Most of the policy patches are tackling five types of trade-offs. The experiences with mm development provide us the hints on how and where each policy would be leveraged in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Fast Path</head><p>To further reduce the software overhead, another optimization approach is to accelerate the commonly executed codes, which is named as fast path. We identify that Linux mm maintains fast paths in most of its key components, such as memory allocation, memory resource controller, and virtual memory management. These fast paths are carefully and frequently re-examined in every version of Linux kernels, contributing many patches to the code base of Linux mm. We study these patches to understand what are the common techniques leveraged in fast path optimizations.</p><p>Based on our patch study, we categorize the techniques used for fast path in Linux mm into eight types as described in <ref type="table" target="#tab_6">Table 6</ref>. We find that code reduction and lockless optimization are the most commonly used techniques for fast path, which contributed 61.4% of the fast path related patches. As case studies, we list a set of patches for these types in <ref type="table" target="#tab_6">Table 6</ref>. For instance, on the fast path for the allocation and deallocation of page table pages, there are two costly operations: finding a zeroed page and maintaining states of a slab buffer. To reduce these overheads, new component called quicklist was in-troduced to replace the allocation logic as it touches less cache lines and has less overhead of slab management. Another interesting approach is optimistic barrier, which is proposed to reduce the synchronous overheads caused by system call like barrier and fence, e.g., the full memory barriers on both reads and writes are replaced with only read barriers on the fast path, while re-executing the code with slow path when false failure is detected.</p><p>Summary: There are 8 types of optimizations for fast path. Code reduction and lockless optimization are the two most widely used techniques to alleviate redundant functions and reduce lock contention.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Memory Semantics</head><p>In order to better understand memory semantics, we build a tool named MChecker to pinpoint the modified functions in source code by leveraging the information (e.g., which lines of code are changed) provided in patches. MChecker will place the located functions under the record of the corresponding patch in MPatch. By analyzing the call graphs of specific memory operations, we can identify their core functions. And with the information provided by MPatch, we can easily understand what are the common bugs lying in these functions, how these functions were optimized and etc.</p><p>In this paper, we analyze the hot files which are evolved with more committed patches (see <ref type="figure" target="#fig_2">Figure 3)</ref>. Due to the space limitation of the paper, we only present the hot functions that were updated intensively in Table 7. Across the 35 major functionalities (the 3rd column in <ref type="table" target="#tab_7">Table 7</ref>), 75.6% of them have more patches for bugs and optimization than those for code maintenance and new feature, which demonstrates the main thread of contributions from the open-source community.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Memory Allocation</head><p>The memory allocation and deallocation functions in the kernel space are mostly implemented in page alloc, slab, slub and slob files which are the cores of the well-known buddy system. As the default memory allocator, slub absorbs 1.6-7.2x more patches than other two allocators. The functions in these hot files can be categorized into allocation/free, create/destroy and page/cache management to fulfill the implementation of the userspace malloc and free functions. As memory allocators become mature, about half of the relevant patches are concentrated on the page and cache management (e.g., cache initialization within kmem cache init, object state maintenance within show slab objects).</p><p>We find that the mature memory allocation and deallocation are still suffering from bugs. The allocation and create functions have more bugs than free and destroy functions, and these bugs are usually relevant to checking and lock contentions. The cumbersome checks and lock protections (due to complicated page states) not only increase the possibility of bug occurrence, but also incur increasing software overhead. To reduce such software overhead, an increasing number of improved versions of allocation functions with fast path are implemented. For instance, a lockless allocation algorithm based on the atomic operation this cpu compxchg double improves the allocation performance significantly <ref type="bibr" target="#b80">[83]</ref>.</p><p>Summary: The mature memory allocators still suffer from serious checking and lock issues due to the complicated states maintained for memory pages during their life cycles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Memory Resource Controller</head><p>In memory resource controller, the majority (93.8%) of its patches are committed to the memcontrol file. As more resource is available on today's machines, the OSlevel resource control named memory cgroup was proposed to support resource management and isolation. It is motivated to isolate the memory behavior of a group of tasks from the rest of the system.</p><p>To control the usage of memory, charge/uncharge functions are used to account the number of pages involved along with the running tasks. We find that 26.2% of the committed patches relate to concurrency issues, because of the complicated intrinsic operations in these functionalities. For instance, for a uncharging page, it may involve actions of truncation, reclaim, swapout and migration. Interestingly, many of these issues are caused by missing locks. However, detecting missing locks is more than a software engineering issue, as it requires program semantics (e.g., page states) provided by the virtual memory system. Such an observation may give us the hint that the decoupled memory resource controller should be integrated into the mm framework to avoid redundant data structures and software overheads, e.g., memcontrol can rely on the existing LRU lists to obtain page information and schedule pages dynamically.</p><p>Moreover, we find that fault handlers suffer from a significant portion of bugs, the involved cases include out of memory (OOM) and allocation failure. Similar trends are seen in the exception handler component which has two hot files: memory-failure and oom kill. Most of them are caused by the inappropriate or wrong handling of memory errors and exceptions (e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b18">19]</ref>). We expect these findings would reveal the weakness aspect of Linux mm and supply useful test cases to the memory testing and debugging tools like mmtests <ref type="bibr" target="#b40">[42,</ref><ref type="bibr" target="#b51">53]</ref>.</p><p>Summary: Concurrency issues (e.g., missing lock) are the major concern for the memory resource controller development. Our study discloses that the fault handler is still a weak aspect in mm. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Virtual Memory Management</head><p>The virtual memory management is the largest component in Linux mm, it has six hot files: memory, memorypolicy, huge memory, hugetlb, mmap and vmalloc. These hot files which contain the essential elements in virtual memory (e.g., page table, page fault handler, paging and TLB) has the largest number of committed patches (see <ref type="figure" target="#fig_2">Figure 3</ref>). These essential functions which have been developed for decades are still being updated to support new hardwares (e.g., NVDIMM and persistent memory <ref type="bibr" target="#b58">[61]</ref>), and new usage of memory (e.g., huge page). And they are still buggy, e.g., even in the well-developed do set pte function, missing setting the soft dirty bit <ref type="bibr" target="#b76">[79]</ref> could cause data inconsistency if a user space program is tracking memory changes <ref type="bibr" target="#b16">[17]</ref>.</p><p>A core component of memory management is the design and implementation of memory policies. We generally categorize the functions for memory policies into two categories: policy definition and policy enforcement. We find that policy definition has more optimization patches than policy enforcement, for instance, new policy is defined for choosing preferred NUMA node based on the number of private page faults; the kernel should avoid immediate memory migrations after switching nodes. As for bugs in memory policies, we find that 30% of the patches were applied to address the issues caused by missing checks, since memory policies usually count on many states (e.g., whether page is dirty) and statistics (e.g., cache hit/miss rate, number of page fault), missing one check would fail the policy enforcement.</p><p>Summary: The well-developed virtual memory management is still buggy. Specifically, a large portion of issues in policy definition and enforcement are caused by missing checks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Garbage Collection</head><p>To preserve a certain amount of available memory pages for future allocation, Linux mm will garbage collect unused pages across memory zones. In vmscan, its functions can be categorized into two major categories: kswapd (the kernel swap daemon) and shrinker. For the remaining functions, we define them as GC helper, as they either provide the statistics of page usage, or handle the page out for shrinker. The kswapd will try to free pages if the number of free pages in the system runs low, while shrinker-relevant functions will be called to scan the corresponding components (e.g., slab cache, zones), and locate the candidate pages to be freed. Most interestingly, we find that more patches (52.7%) were applied to shrinker functions, and 84.1% of them relate to memory policies, focusing on how to scan memory regions with low overhead, and which pages should be reclaimed. However, the congestion events (22 related patches, e.g., <ref type="bibr" target="#b37">[39,</ref><ref type="bibr" target="#b49">51,</ref><ref type="bibr">87]</ref>) during garbage collection make the memory performance unpredictable, it is essential to scale the GC process (e.g., per-zone scanning) and use page statistics to coordinate GC activities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary:</head><p>The shrinker is the hot spot in GC, it causes unpredictability in memory performance. A scalable and coordinated GC is desirable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>The key components of virtual memory were studied back to 70's when DRAM first appeared <ref type="bibr" target="#b15">[16]</ref>. Over the past decades, the functionalities of the core components have been enriched markedly, such as the buddy system <ref type="bibr" target="#b32">[33]</ref> was proposed in 90's to remove the internal fragmentation, and later, general OS support for huge pages was proposed <ref type="bibr" target="#b20">[21]</ref>. Today, the virtual memory system is still actively improved to support new features <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b70">72]</ref> and hardware <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b52">54,</ref><ref type="bibr" target="#b69">71,</ref><ref type="bibr" target="#b84">88]</ref>. There is no doubt that the memory manager has become one of the core subsystems in today's OS kernel. But few work has done any studies on the development of virtual memory system recently (over the past decade). Gorman et al. <ref type="bibr" target="#b21">[22]</ref> analyzed the mm source code in Linux version 2.6.0-test4 (2003), while our work focuses on the study of patches which were committed to the latest Linux versions (from 2.6.32, 2009 to 4.0-rc4, 2015).</p><p>Patch and bug studies provide us insights on issue patterns in specific system software, and the experiences along its development. A number of such studies in various systems have been conducted recently. <ref type="bibr">Lu et al. [37]</ref> studied the Linux file system patches, Chou et al. <ref type="bibr" target="#b8">[9]</ref> investigated the operating system errors in Linux kernels, <ref type="bibr">Kadav et al. [29]</ref> examined the code base of Linux device drivers, <ref type="bibr">Palix et al.</ref> [60] studied the Linux kernel to version 2.6.33. We share the same purposes with these studies, but with a focus on Linux virtual memory system. To the best of our knowledge, our work is the first to conduct such a comprehensive study, which examines 4587 committed patches to Linux memory manager.</p><p>Memory issues can lead to serious problems, such as system crash, data corruption, suboptimal performance, etc. Many tools <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b53">55]</ref> were built to address memory-related errors such as buffer overflows, dangling pointers, memory leaks in the programming and library space. Few of the related work is targeting at addressing the bugs in kernel space. <ref type="bibr">Yang et al. [89]</ref> built checkers to find the bugs in storage and file systems, Prabhakaran et al.</p><p>[63] developed a file system with better failure policies. Such efforts are also required as we build more reliable and efficient virtual memory systems. And also, a specific formal verification <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b30">31]</ref> for virtual memory system is needed to verify its policies and implementation. The insights and bug patterns disclosed in this work would facilitate the development of these tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>In this paper, we present a comprehensive study of 4587 committed patches in the Linux memory manager over the last five years. These patches reflect the development of the virtual memory system. We expect our findings to benefit the development of existing and future virtual memory systems, and their associated bug-finding and debugging tools. Our study would also shed light on the development of memory manager in relevant OSes as they share the same principles as Linux kernel.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Component breakdown of memory manager in Linux version 4.0-rc4, in terms of lines of codes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: The change in mm code in terms of LoC.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The heat map of patch distribution in each component of Linux memory management. Each block represents the patches committed to the current version since the last stable version. The darker the color, the more patches applied. The number below the bar indicates the total number of committed patches applied to the given file.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>[</head><label></label><figDesc>23, 26, 37]. Since December 2, 2009, there are totally 5358 patches relevant to Linux mm reported in the patch repositories of Linux kernel. After excluding the du- plicated and invalid patches, we examine 4587 patches (85.6% of the total patches).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Patch overview. It shows the patch distribution according to general types including bug, code maintenance, improvement and new feature.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The changes of patch distribution along the Linux mm evolution, taking Linux 2.6.32 as the baseline.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Bug distribution among Linux mm components.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Bug consequence. the shared data structures are not maintained properly. Moreover, we find that checking bugs are also the major contributors to the wrong behaviors and runtime errors in Linux mm. More interestingly, we find that the memory leaks are mainly caused by MErr and logic bugs. It is noted that most of the memory leaks in mm are not caused by not-freed memory, they are mostly caused by the accounting (e.g., the unused page is not counted as free page) and fault handler bugs (e.g., pages are not reclaimed when fault happens). For programming bugs that mainly cause compilation errors, runtime error and wrong behaviors, they are easier to be fixed compared with other types of bugs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Comparison of memcg cache params structure in Linux version 3.8 and 4.0.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><head>Table 2 : Classification of bug patches.</head><label>2</label><figDesc></figDesc><table>Sub-type 
Description 
MErr 
alignment 
data/page alignment and padding. 
null pointer 
refer to an invalid object. 

Checking 
inapt check 
inappropriate check. 
miss check 
check is required. 
unec check 
unnecessary check. 
wrong check 
check conditions are incorrect. 

Concurrency 

async opts 
faults due to async operations 
better lock 
lock is implemented in better way. 
dead lock 
two or more threads are blocked. 

lock contention 
concurrently access to shared locks or data 
structures. 
miss lock 
lock is required. 
miss unlock 
the unlock is missed. 
unec lock 
unnecessary lock. 
double unlock 
unlock twice. 

Logic 

accounting 
error in collecting statistics. 
case-by-case 
bug fix requires specific knowledge. 
fault handler 
error and exception handling. 
order 
the order of execution is violated. 
return err 
return code is not correct. 
parameter 
misuse of parameters. 
state update 
issues in updating state and data structures. 
corner case 
uncovered cases in implementations. 

Programming 
configuration 
wrong/missed configuration. 
document 
comments &amp; docs for functions. 
API 
issues caused by interface changes. 
debug 
issues happened in debugging. 
misc 
any other programming issues 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Typical examples of approaches to reduce soft-
ware overhead of different data structures. 

Type Overhead Source 
Optimization Example 

radix 
tree 
Tree walking 
Provide hints, cache intermedi-
ate states [48] 
Linear search 
Add bit-optimized iterator [64] 

rb tree 

Tree walking 
Optimized tree walking [1, 44] 
Lock contention 
Batch lookup [11] 
Balancing tree 
Reduce lazy operations [52] 

list 

List search 
Limit list length [43] 
Lock contention 
Add per-node LRU list [35] 
Storage overhead 
Dynamic allocation 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><head>Table 4 : Classification of typical design choices in Linux mm based on the analysis of optimization patches.</head><label>4</label><figDesc></figDesc><table>Trade-off 
% 
Case Study 
Latency Vs. 
Throughput 
10.9 disk access upon page fault and swapping. 

Synchronous 
Vs. 
Asynchronous 
22.3 
With asynchronous method, mm can avoid 
delays while executing expensive opera-
tions like swapping, compaction. 
Lazy Vs. 
Non-lazy 
15.6 
Expensive operations (e.g., TLB flush, 
page migration) can be executed in batch. 

Local Vs. 
Global 
33.1 
Maintaining per-process variables im-
proves scalability, but it increases storage 
overhead, e.g., slub vs. slab allocator. 
Fairness Vs. 
Performance 
18.1 
Fairness guarantee when memory is 
shared among multiple processes. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><head>Table 5 : Examples of applying lazy policy in Linux mm.</head><label>5</label><figDesc></figDesc><table>Functionality 
Example 
vmalloc 
lazy TLB flush, lazy unmapping 
mempolicy 
lazy page migration between nodes 
huge memory 
lazy huge zero page allocation 
frontswap 
lazy backend initialization 
cleancache 
lazy backend registration 
backing-dev 
lazy inode update on disk 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="true"><head>Table 6 : Classification of approaches for fast path optimization in Linux mm.</head><label>6</label><figDesc></figDesc><table>Type 
% 
Description 
Example 
Code 
Reduction 
34.1 
Simplify the fast path logic and reduce redundant 
codes. 
Avoid redundant get/put page in munlock vma range 
as pages will not be referred anymore [50]. 
Lockless 
Optimization 
27.3 Reduce the usage of lock and atomic operations. 
Lockless memory allocator in SLUB [34, 36]. 

New 
Function 
11.6 Improve with new mm functionality. 
New SLUB fast paths are implemented for 
slab alloc/free with cmpxchg local [75]. 
State 
Caching 
8.2 
Cache the states to avoid expensive functions. 
Pre-calculate the number of online nodes instead of always 
calling expensive num online nodes [59]. 
Inline 
6.4 
Inline simple functions in fast path. 
Inline buffered rmqueue [58]. 
Code 
Shifting 
4.7 
Move unfrequently executed code from fast path to 
slow path. 
In SLUB allocator, slow path executes the irq enable/disable 
handlers, fast path will execute them only at fallback [78]. 
Group 
Execution 
4.1 
Avoid calling the same function repeatedly. 
Using pte walk to avoid the repeated full page table trans-
lation and locks in munlock vma pages range [49]. 
Optimistic 
Barrier 
3.6 
Optimistically skip or reduce the number of barriers, 
and re-execute the logic once false failure is detected. 
Using only read barriers in get/put mems allowed to ac-
celerate page allocation [13]. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="true"><head>Table 7 : The heat map of patches for the hot functions in mm. Functions in each hot file are categorized into sub-types (the 3rd column). The proportion of each functionality is illustrated in the 4th column. The distribution of bugs (BUG), code maintenance (CODE), new feature (FTR) and optimization (OPT) is shown across 5-8th columns.</head><label>7</label><figDesc></figDesc><table>File Functionality 
% 
BUG 
CODE FTR 
OPT 
Representative Hot Functions 

Memory Allocation 

page alloc 

Allocation 
24.6 
8.1 
6.8 
2.2 
7.4 
alloc pages, alloc pages slowpath, rmqueue 
Free 
19.4 
4.8 
8.3 
1.3 
5.0 
free one page, free pages bulk, free zone pagesets 
Page management 
56.0 
14.1 
22.0 
4.4 
15.5 
build zonelists, zone init free lists, read page state 

slab 

Create/destroy 
11.6 
4.1 
4.9 
1.5 
1.2 
kmem cache create, kmem cache destroy 
Allocation/free 
29.8 
11.6 
12.4 
2.0 
3.8 
cache alloc, kmalloc, kmem cache free 
Shrink/grow 
6.9 
1.7 
3.2 
0.6 
1.4 
cache grow, cache reap 
Cache management 
51.7 
8.7 
22.2 
1.8 
19.1 
kmem cache init, kmem getpages 

slub 
Create/destroy 
14.9 
5.4 
4.5 
0.4 
4.5 
kmem cache create, kmem cache destroy 
Alloction/free 
33.8 
9.5 
8.1 
0.9 
15.3 
slab alloc, kmalloc large node, kfree, slab free 
Slub management 
51.4 
22.1 
9.5 
4.1 
15.8 
kmem cache init, show slab objects 

Controller 
mmcntr 
Charge/uncharge 
26.5 
9.3 
1.0 
2.4 
13.8 
mem cgroup do charge, 
mem cgroup try charge, 
mem kmem commit charge 
Cgroup management 
73.5 
35.4 
7.9 
7.2 
23.0 
mem cgroup alloc, mem cgroup handle oom 

Expt Hndler 

failure 
Fault handler 
75.9 
38.9 
13.0 
9.3 
14.8 
memory failure, collect procs file 
Hwpoison 
24.1 
13.0 
1.9 
3.7 
5.6 
hwpoison user mappings, hwpoison filter task 

OOM 
Candidate task 
53.7 
14.8 
16.6 
7.4 
14.8 
oom badness, select bad process, oom unkillable task 
OOM handler 
46.3 
24.1 
5.6 
3.7 
13.0 
out of memory, oom kill process 

Virtual Memory Management 

memory 

Page table 
26.3 
11.6 
10.0 
1.6 
3.1 
do set pte, pte alloc, copy one pte, zap pte range 
Page fault 
23.4 
8.8 
7.3 
1.5 
5.9 
do fault, handle mm fault, do shared fault 
Paging 
25.5 
7.3 
9.5 
5.1 
3.6 
vm normal page, do anonymous page, do swap page 
NUMA support 
18.2 
6.3 
2.1 
1.4 
8.4 
do numa page, access remote vm, numa migrate prep 
TLB 
6.6 
2.2 
0.5 
1.1 
2.8 
tlb flush mmu, tlb gather mmu 
mpol 
Policy definition 
47.7 
17.5 
15.1 
4.7 
10.5 
mpol new, mpol dup, mpol shared policy lookup 
Policy enforcement 
52.3 
17.4 
19.8 
9.3 
5.8 
do mbind, do set mempolicy, vma replace policy 

hugemm 
Page table support for 
hugepage 
68.5 
33.7 
19.1 
2.3 
13.5 
change huge pmd, 
do huge pmd numa page, 
copy huge pmd 
Hugepage alloc 
31.5 
9.0 
13.5 
1.1 
7.9 
hugepage init, alloc hugepage, khugepaged alloc page 

hugetlb 
Hugepage management 
33.7 
20.5 
4.8 
2.4 
6.0 
alloc huge page, free huge page, hugetlb cow 
Hugepage fault 
8.4 
3.6 
1.2 
2.4 
1.2 
hugetlb fault 
VM for hugepage 
57.8 
19.2 
27.7 
7.2 
3.6 
hugetlb change protection, vma has reserves 

mmap 
Mmap operations 
31.7 
13.3 
10.0 
5.0 
3.3 
do mmap pgoff, do munmap, exit mmap 
VM for mmap 
68.3 
23.3 
21.7 
8.3 
15.0 
mmap pgoff, mmap region, vma adjust 

alloc 
Vmalloc 
48.9 
17.8 
22.2 
2.2 
6.7 
vmalloc node range, vmalloc area node, vmalloc open 
Vmap 
51.1 
13.3 
26.7 
2.2 
8.9 
alloc vmap area, vunmap, free vmap area 

GC 
vmscan 
Kswapd 
20.0 
5.5 
7.3 
1.8 
5.5 
kswapd, wakeup kswapd 
Shrinker 
52.7 
12.7 
16.3 
7.3 
16.3 
shrink inactive list, shrink page list, shrink zones 
GC helper 
27.3 
7.3 
3.6 
1.8 
14.6 
get scan count, pageout, scan control 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This paper is dedicated to the memory of our colleague and mentor Karsten Schwan. Karsten was a prolific researcher, a great advisor, and a faculty leader in the School of Computer Science at Georgia Institute of Technology. The lead author greatly thanks him for his mentorship and guidance. We all miss you Karsten.</p><p>We thank our shepherd Zhen Xiao as well as the anonymous reviewers. We also thank Xuechen Zhang for the initial help and discussions on this work. This work was supported in part by the Center for Future Architectures Research (CFAR), one of the six SRC STARnet Centers, sponsored by MARCO and DARPA.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Add Rbtree Postorder Iteration</forename><surname>Functions</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Runtime</forename><surname>Tests</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">And</forename><surname>Update</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>To Use</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Cling: A Memory Allocator to Mitigate Dangling Pointers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akritidis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Security&apos;10</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient Virtual Memory for Big Memory Servers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Basu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gandhi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA&apos;13</title>
		<meeting><address><addrLine>Tel-Aviv, Israel</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Probabilistic Memory Safety for Unsafe Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zorn</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">G</forename><surname>Diehard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI&apos;06</title>
		<meeting><address><addrLine>Ottawa, Ontario, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<title level="m">BOOTMEM: FIX CHECKING THE BITMAP WHEN FINALLY FREEING BOOTMEM</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
				<title level="m">BOOTMEM: FIX FREE ALL BOOTMEM CORE() WITH ODD BITMAP ALIGNMENT</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Practical memory checking with Dr. Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruening</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhao</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CGO&apos;11</title>
		<imprint>
			<date type="published" when="2011-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Call Shake Page ; When Error Hits Thp Tail</forename><surname>Page</surname></persName>
		</author>
		<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm/memory-failure.c?id=09789e5de18e4e442870b2d700831f5cb802eb05" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An Empirical Study of Operating Systems Errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP&apos;01</title>
		<imprint>
			<date type="published" when="2001-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Scalable Address Spaces Using RCU Balanced Trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clements</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">T</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zeldovich</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
		<idno>ASP- LOS&apos;12</idno>
		<imprint>
			<date type="published" when="2012-03" />
			<pubPlace>London, England, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">RadixVM: Scalable Address Spaces for Multithreaded Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clements</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">T</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zeldovich</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurosys&apos;13</title>
		<meeting><address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Scalable Commutativity Rule: Designing Scalable Software for Multicore Processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clements</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">T</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mor-Ris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kohler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP&apos;13</title>
		<meeting><address><addrLine>Farmington, Pennsylvania, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
				<title level="m">CPUSET: MM: REDUCE LARGE AMOUNTS OF MEMORY BAR-RIER RELATED DAMAGE V3</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cramming More Into Struct</forename><surname>Page</surname></persName>
		</author>
		<ptr target="https://lwn.net/Articles/565097/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The UVM Virtual Memory System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cranor</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Parulkar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC&apos;99</title>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Virtual memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denning</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Survey</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1970-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Don&amp;apos;t Forget To Set Softdirty On File Mapped</forename><surname>Fault</surname></persName>
		</author>
		<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm/?id=9aed8614af5a05cdaa32a0b78b0f1a424754a958&amp;context=40&amp;ignorews=0&amp;dt=0" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fix</forename><surname>Too</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vunmap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Flushing</surname></persName>
		</author>
		<ptr target="https://lkml.org/lkml/2009/6/16/722" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fix Wrong Num Poisoned Pages In Handling Memory Error On</forename><surname>Thp</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Ralational access to Unix kernel data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fragkoulis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Spinellis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Louridas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And Bi-Las</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroSys&apos;14</title>
		<meeting><address><addrLine>Amsterdam, The Netherlands</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">General purpose operating system support for multiple page sizes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ganapathy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schimmel</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<idno>USENXI ATC &apos;98</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual Conference on USENIX Annual Technical Conference</title>
		<meeting>the Annual Conference on USENIX Annual Technical Conference</meeting>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Understanding the Linux Virtual Memory Manager</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gorman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<idno>ISBN 0-13-145348-3</idno>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">What Bugs Live in the Cloud? A Study of 3000+ Issues in Cloud Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gunawi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Leesatapornwongsa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Patana-Anake</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Adityatama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Eliazar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">J</forename><surname>Laksono</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lukman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sa-Tria</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOCC&apos;14</title>
		<meeting><address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Ironclad Apps: End-to-End Security via Automated Full-System Verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hawblitzel</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lorch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Narayan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zill</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI&apos;14</title>
		<meeting><address><addrLine>Broomfield, CO</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Unified Address Translation for Memory-Mapped SSDs with FlashMap</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Huang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Badam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Qureshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schwan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA&apos;15</title>
		<meeting><address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Understanding Issue Correlations: A Case Study of the Hadoop System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Huang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Schwan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOCC&apos;15</title>
		<meeting><address><addrLine>Kohala Coast, HI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Improving The Future By Examing The</forename><surname>Past</surname></persName>
		</author>
		<ptr target="http://isca2010.inria.fr/media/slides/Turing-Improving_the_future_by_examining_the_past.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Factors affecting the efficiency of a virtual memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jones</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computers C</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<date type="published" when="1969-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Understanding Modern Device Drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kadav</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS&apos;12</title>
		<meeting><address><addrLine>London, England, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Redundant Memory Mappings for Fast Access to Large Memories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karakostas</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Gandhi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ayar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristal</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename><surname>Nemirovsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Unsal</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA&apos;15</title>
		<meeting><address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Formal Verification of an OS Kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klein</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Elphinstone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Andronick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Derrin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Elkaduwe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Engelhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Norrish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kolanski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sewell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tuch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Winwood</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP&apos;09</title>
		<meeting><address><addrLine>Big Sky, Montana</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Unioning of the Buffer Cache and Journaling Layers with Non-volatile Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noh</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST&apos;13</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A two dimensional buddy system for dynamic resource allocation in a partitionable mesh connected system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cheng</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1990 ACM Annual Conference on Cooperation</title>
		<meeting>the 1990 ACM Annual Conference on Cooperation</meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page">90</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
				<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm?id=3b1d58a4c96799eb4c92039e1b851b86f853548a" />
		<title level="m">LIST LRU: PER-NODE LIST INFRASTRUCTURE</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lockless (and Preemptless) Fastpaths For</forename><surname>Slub</surname></persName>
		</author>
		<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm?id=8a5ec0ba42c4919e2d8f4c3138cc8b987fdb0b79" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A Study of Linux File System Evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST&apos;13</title>
		<imprint>
			<date type="published" when="2013-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lumpy</forename><surname>Reclaim</surname></persName>
		</author>
		<ptr target="https://lwn.net/Articles/211199" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
				<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm/vmscan.c?id=d6c438b6cd733834a3cec55af8577a8fc3548016" />
		<title level="m">MEMCG: FIX ZONE CONGESTION</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Memcontrol: Do Not Acquire Page Cgroup Lock For Kmem</forename><surname>Pages</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Memory Management In</forename><surname>Memcached</surname></persName>
		</author>
		<ptr target="https://code.google.com/p/memcached/wiki/MemoryManagement" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Memory-Management Testing And</forename><surname>Debugging</surname></persName>
		</author>
		<ptr target="https://lwn.net/Articles/636549/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mm Anon Rmap: Replace Smae Anon Vma Linked List With An Interval</forename><surname>Tree</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mm: Augment Vma Rbtree With Rb Subtree</forename><surname>Gap</surname></persName>
		</author>
		<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm?id=d37371870ceb1d2165397dc36114725b6dca946c" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
				<title level="m">MM: AVOID NULL-POINTER DEREFERENCE IN SYNC MM RSS</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Compaction: Terminate Async Compaction When</forename><surname>Rescheduling</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
				<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm/bootmem.c?id=5a982cbc7b3fe6cf72266f319286f29963c71b9e" />
		<title level="m">MM: FIX BOUNDARY CHECKING IN FREE BOOTMEM CORE</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mm: Keep Page Cache Radix Tree Nodes In</forename><surname>Check</surname></persName>
		</author>
		<ptr target="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/lib/radix-tree.c?id=449dd6984d0e47643c04c807f609dd56d48d5bcc" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
				<title level="m">MM: MUNLOCK: MANUAL PTE WALK IN FAST PATH INSTEAD OF FOLLOW PAGE MASK</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">MM: MUNLOCK: REMOVE REDUNDANT GET PAGE/PUT PAGE PAIR ON THE FAST PATH</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">MM: VMSCAN: FIX INAPPROPRIATE ZONE CONGESTION CLEARING</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X86: Saving Vmcore With Non-Lazy Freeing Of</forename><surname>Vmas</surname></persName>
		</author>
		<ptr target="//git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm?id=3ee48b6af49cf534ca2f481ecc484b156a41451d" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mmtests</forename></persName>
		</author>
		<ptr target="https://github.com/gormanm/mmtests" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Consistent, Durable, and Safe Memory Management for Byte-addressable Non Volatile Main Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moraru</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Andersen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G</forename><surname>Kaminsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tolia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Ranganathan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Binkert</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">TRIOS&apos;13</title>
		<meeting><address><addrLine>Farmington, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Detecting and Eliminating Memory Leaks Using Cyclic Memory Allocation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nguyen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rinard</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISMM&apos;07</title>
		<meeting><address><addrLine>Montreal, Quebec, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Numa: Do Not Trap Faults On The Huge Zero</forename><surname>Page</surname></persName>
		</author>
		<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm/huge_memory.c?id=e944fd67b625c02bda4a78ddf85e413c5e401474" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Fast Crash Recovery in RAMCloud</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ongaro</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Rumble</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Stutsman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ouster-Hout</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rosenblum</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP&apos;11</title>
		<meeting><address><addrLine>Cascais, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">USE A PRE-CALCULATED VALUE INSTEAD OF NUM ONLINE NODES(</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Page</forename><surname>Allocator</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST PATHS</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Faults in Linux: Ten Years Later</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Palix</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Saha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Calves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lawall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muller</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS&apos;11</title>
		<meeting><address><addrLine>Newport Bench, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Persistent Memory Support</forename><surname>Progress</surname></persName>
		</author>
		<ptr target="https://lwn.net/Articles/640113/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Arrakis: The Operating System is the Control Plane</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Ports</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R K</forename><surname>Woos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roscoe</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI&apos;14</title>
		<meeting><address><addrLine>Broomfield, CO</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">IRON File Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prabhakaran</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Bairavasundaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">N</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Gunawi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arpaci-Dusseau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP&apos;05</title>
		<meeting><address><addrLine>Brighton, United Kingdom</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Radix-Tree: Introduce Bit-Optimized</forename><surname>Iterator</surname></persName>
		</author>
		<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/lib/radix-tree.c?id=78c1d78488a3c45685d993130c9f17102dc79a54" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Radix</forename><surname>Trees</surname></persName>
		</author>
		<ptr target="https://lwn.net/Articles/175432" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rao</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Heger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pratt</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Examining Linux</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Page Cache Performance</surname></persName>
		</author>
		<title level="m">Ottawa Linux Symposium (OLS&apos;05</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
				<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm/readahead.c?id=70655c06bd3f25111312d63985888112aed15ac5" />
		<title level="m">READAHEAD: FIX NULL FLIP DEREFERENCE</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Readahead: Fix Sequential Read Cache Miss Detec-Tion</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Red-Black</forename><surname>Trees</surname></persName>
		</author>
		<ptr target="https://lwn.net/Articles/184495" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Logstructured Memory for DRAM-based Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rumble</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Kejriwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ousterhout</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST&apos;14</title>
		<meeting><address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Virtual memory management on flash</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saxena</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Flashvm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference&apos;10</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Page Overlays: An Enhanced Virtual Memory Framework to Enable Fine-grained Memory Management</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seshadri</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pekhimenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ruwase</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">B</forename><surname>Kozuch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Mowry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chilimbi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISCA&apos;15</title>
		<meeting><address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Slab: Embed Memcg Cache Params To Kmem</forename><surname>Cache</surname></persName>
		</author>
		<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm?id=f7ce3190c4a35bf887adb7a1aa1ba899b679872d" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<monogr>
				<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm/slub.c?id=1f84260c8ce3b1ce26d4c1d6dedc2f33a3a29c0c" />
		<title level="m">SLUB: ALTERNATE FAST PATHS USING CMPXCHG LOCAL</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Slub: Check For Page Null Before Doing The Node Match</forename><surname>Check</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Slub: Failslab</forename><surname>Support</surname></persName>
		</author>
		<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm/failslab.c?id=773ff60e841461cb1f9374a713ffcda029b8c317" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Slub Page Alloc Fallback: Enable Interrupts For Gfp</forename><surname>Wait</surname></persName>
		</author>
		<ptr target="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=caeab084deb61cd2d51cb8facc0e894a5b406aa4" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soft</forename><surname>Dirty Ptes</surname></persName>
		</author>
		<ptr target="https://www.kernel.org/doc/Documentation/vm/soft-dirty.txt" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ssd</forename><surname>Discard Command</surname></persName>
		</author>
		<ptr target="https://wiki.archlinux.org/index.php/Solid_State_Drives" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Evaluation of efficiency in a virtual memory environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steinhorst</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename><surname>Bateman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SICOSIM4</title>
		<imprint>
			<date type="published" when="1973-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Improving the Reliability of Commodity Operating Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Levy</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP&apos;03</title>
		<meeting><address><addrLine>Bolton Landing, New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">The</forename><surname>Linux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Archives</surname></persName>
		</author>
		<ptr target="https://www.kernel.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">The</forename><surname>Zswap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Swap Cache</surname></persName>
		</author>
		<ptr target="https://lwn.net/Articles/537422/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thp: Abort Compaction If Migration Page Cannot Be Charged To</forename><surname>Memcg</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title/>
		<ptr target="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/mm?id=1da58ee2a0279a1b0afd3248396de5659b8cf95b" />
	</analytic>
	<monogr>
		<title level="j">VMSCAN: COUNT ONLY DIRTY PAGES AS CONGESTED</title>
		<imprint>
			<biblScope unit="volume">87</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">ANViL: Advanced Virtualization for Modern Non-Volatile Memory Devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weiss</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sundararaman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tala-Gala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arpaci-Dusseau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST&apos;15</title>
		<meeting><address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">EXPLODE: A Lightweight, General System for Finding Serious Storage System Errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engler</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI&apos;06</title>
		<meeting><address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Performance and Scalability Evaluation of &apos;Big Memory&apos; on Blue Gene Linux</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshii</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Iskra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Beckman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Broekema</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal High Performance Applications</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2011-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">In-Memory Big Data Management and Processing: A Survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<date type="published" when="2015-04" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
