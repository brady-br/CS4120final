<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:06+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">TAP: Time-aware Provenance for Distributed Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenchao</forename><surname>Zhou</surname></persName>
							<email>wenchaoz@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ling</forename><surname>Ding</surname></persName>
							<email>lingding@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Haeberlen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zachary</forename><surname>Ives</surname></persName>
							<email>zives@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boon</forename><forename type="middle">Thau</forename><surname>Loo</surname></persName>
							<email>boonloo@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">TAP: Time-aware Provenance for Distributed Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>In this paper, we explore the use of provenance for analyzing execution dynamics in distributed systems. We argue that provenance could have significant practical benefits for system administrators, e.g., for reasoning about changes in a system&apos;s state, diagnosing protocol miscon-figurations, detecting intrusions, and pinpointing performance bottlenecks. However, to realize this vision, we must revisit several aspects of provenance management. As a first step, we present time-aware provenance (TAP), an enhanced provenance model that explicitly represents time, distributed state, and state changes. We outline our research agenda towards developing novel query processing , languages, and optimization techniques that can be used to efficiently and securely query time-aware provenance, even in the presence of transient state or un-trusted nodes.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Provenance <ref type="bibr" target="#b1">[2]</ref> has proven to be a versatile concept. It has been successfully applied to a variety of areas <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b18">19]</ref>, and this paper proposes an addition to this list. We observe that, in the context of distributed systems, it is very common for system administrators to perform analysis tasks that essentially amount to network provenance <ref type="bibr" target="#b20">[21]</ref> queries. For example, they might ask diagnostic queries to determine the root cause of a malfunction <ref type="bibr" target="#b17">[18]</ref>, forensic queries to identify the source of an intrusion <ref type="bibr" target="#b9">[10]</ref>, or profiling queries to find the reason for suboptimal performance <ref type="bibr" target="#b19">[20]</ref>. At the heart of all these queries is a question about data flows across nodes -in other words, a question about provenance. Thus, we should be able to bring to bear many of the techniques originally developed for provenance in other domains.</p><p>Prior work <ref type="bibr" target="#b20">[21]</ref> has provided initial evidence that one can efficiently maintain and query provenance in distributed systems, even at Internet scale. However, to support the full range of functionality required for analyzing distributed systems, we must still address several open challenges. Consider a simple use case from Internet interdomain routing: a network operator wants to investigate why his route to eBay changed from r 1 to r 2 a minute ago. Existing provenance systems cannot easily answer this question because it a) does not ask about the provenance of state, but rather about a state change; and b) it does not ask about state that currently exists, but rather about state that existed in the past.</p><p>Some existing systems <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b15">16]</ref> do retain certain provenance data about disappeared state and state changes; for example, PASS <ref type="bibr" target="#b15">[16]</ref> maintains versions of provenance, and infers the causes for state changes by comparing old and current versions. This is different from the property we have in mind. First, we want to explicitly capture causality: if a file A depends on a thousand other files and one of these files, say B, is changed, we want the provenance of the change in A to be attributed to the change in B. Second, since one of our potential use cases is forensics, we are interested in strong security guarantees, i.e., we would like provenance queries to be answerable even if an adversary is actively trying to cover his traces. Provenance should be remain accessible even if the adversary deletes telltale files, or even compromises some of the nodes on which the provenance is stored.</p><p>In summary, we see the main challenges as follows:</p><p>• Challenge #1: Transient and inconsistent state. We need new techniques for maintaining and querying provenance, such that consistent and complete query results are guaranteed despite network variability, such as instabilities or oscillations.</p><p>• Challenge #2: Explanations for state changes.</p><p>We need an efficient mechanism that can explain not only why a certain datum exists, but also why it has appeared, disappeared, or changed.</p><p>• Challenge #3: Security without trusted nodes.</p><p>We need a provenance system that can correctly answer provenance queries even if an attacker has managed to compromise some part of the system.</p><p>As a starting point, we introduce time-aware provenance (TAP), a novel provenance model that addresses the first two challenges. We also outline a research agenda towards addressing further aspects of provenance management in distributed systems. These include (1) new provenance models and maintenance strategies for capturing the time, distribution, and causality of updates, (2) novel query processing and optimization techniques for efficiently and securely answering queries at scale, and (3) provenance query languages that enable a declarative specification of time and changes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>To set the stage for our subsequent discussion, we first describe a basic provenance model, which we will extend in Section 3 to arrive at TAP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">System Model</head><p>We assume that the distributed system consists of a set of nodes, and that the state of each node can be expressed as a set of tuples (typically with fixed schemas). The execution logic is encoded in a set of derivation rules that specify how tuples can be derived from each other or from base tuples, which correspond to inputs. For simplicity, we will assume that the derivation rules are explicit. This is the case, e.g., for systems that are written in a declarative language such as Network Datalog (NDlog) <ref type="bibr" target="#b12">[13]</ref>. However, TAP is not specific to NDlog and can be applied to systems implemented using imperative languages.</p><p>As a concrete example, we show the rules for a very simple routing protocol, MINCOST 1 , that computes the lowest cost between each pair of nodes in a network:</p><formula xml:id="formula_0">mc1 cost(@S,D,C) :-link(@S,D,C). mc2 cost(@S,D,C) :-link(@Z,S,C1), mincost(@Z,D,C2), C=C1+C2. mc3 mincost(@S,D,MIN&lt;C&gt;) :-cost(@S,D,C).</formula><p>Note particularly that the derivation rules include state from different nodes. In NDlog, this is expressed with the location specifier @, which is followed by the name of the node on which the tuple resides. In this system, the base tuple link(@S,D,C) exists if node S has a direct link to node D with cost C. The tuple cost(@S,D,C) is be resolved by maintaining provenance in bi-temporal databases <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b10">11]</ref>, we propose, in the next section, a provenance model that inherently captures temporal information. Second, because causality 2 is not explicitly represented in the provenance graph, it is difficult to trace a state change back to its root causes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Time-aware Provenance</head><p>Time-aware provenance (TAP) addresses these limitations by adding the following two features: First, in addition to storing dependencies between tuples that currently exist, TAP also remembers dependencies between tuples that existed at some point in the past, which enables TAP to provide consistent answers to provenance queries even while the system is in a transient state. Second, TAP's provenance model explicitly represents tuple changes, as well as the dependencies between them.</p><p>Vertices. TAP's provenance graph contains the following four types of vertices:</p><p>• INSERT(n, τ, t) and DELETE(n, τ, t): Tuple τ was inserted (deleted) on node n at time t; • DERIVE(n, τ, R, t) and UNDERIVE(n, τ, R, t): Tuple τ was derived (underived) via derivation rule R on node n at time t.</p><p>The right half of <ref type="figure">Figure 2</ref> shows a piece of the TAP graph that would have been generated in the example scenario from Section 2.2. Overall, the graph shows that the tuple mincost(@c,a,5) was deleted on node c at time t 3 because the new link a-c was inserted at time t 1 . For example, the node DERIVE(mc2@b) shows that cost(@c,a,4) was derived on node b at time t 2 (and subsequently sent to node c) because a) a link b-c with cost three already existed at time t 2 (since its insertion at time t 1 ), and b) the tuple mincost(@b,a,1) was newly derived at t 2 via rule mc3. Note that, among the immediate predecessors of a DERIVE (or UNDERIVE) vertex, the INSERT (or DELETE) with the most recent timestamp is the event that triggered the rule. The latter derivation was caused by the insertion of the base tuple link(@b,a,1), which corresponds to the addition of the new link. Interestingly, the additional time dimension on the provenance graph enables another use of provenance, namely querying the effects of a state change. For example, if we want to determine how the insertion of the new link a-b has affected the system, we can simply locate the corresponding INSERT vertex in the graph and and traverse the edges in the reverse direction.</p><p>Edges. In most existing provenance models, the edges represent data flows. TAP's provenance graph contains these edges as well, but, in order to answer queries about state changes, it additionally needs to capture a 'causality flow' between updates. In many cases, the two flows are aligned, but there are cases where they differ. For example, if a primary-key constraint exists in the system, the derivation of a tuple τ 1 may cause the deletion of a tuple τ 2 that shares τ 1 's primary key, even though no data flows from τ 1 to τ 2 . A similar situation can occur for other types of constraints, such as aggregation. To represent such causality flows, TAP's provenance graph includes additional update edges.</p><p>The right part of <ref type="figure">Figure 2</ref> contains an instance of such an edge at the DELETE vertex of mincost(@c,a,5) (indicated by a dotted line). This deletion was caused by the aggregation constraint, i.e., the minimal cost changed because a lower-cost path to node a became available.</p><p>Derivations. The TAP graph can be captured via the evaluation of delta rules of the form action :-event, conditions, . . .. These rules can be obtained by rewriting the original derivation rules, using standard techniques from incremental view maintenance <ref type="bibr" target="#b4">[5]</ref>. Thus, it should be possible to leverage existing distributed query processing engines with only minor changes. Briefly, for each derivation rule p :-p1, p2, . . . ,pn, we generate two delta rules for each predicate p i -one for insertions and the other for deletions. The rules are of the form p :-p1, . . ., pi, . . ., pn. The event (in this case, p i ) is represented as an INSERT or DELETE vertex, the conditions (the other p k ) are represented as a sequence of INSERT (or DELETE) vertices that support the existence of p k , and the action itself (p) is represented as a DERIVE or UNDERIVE. Each action then in turn causes a new event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Provenance Maintenance</head><p>The graph representation of TAP can be stored in relational tables in a format similar to that in <ref type="bibr" target="#b20">[21]</ref>. Each vertex can be maintained as a tuple according to the schema presented in Section 3, along with an additional attribute that stores the (potentially distributed) pointers to its direct contributing vertices.</p><p>In theory, the additional time dimension could be implemented by performing provenance versioning, i.e., by keeping a copy of the provenance tables whenever the data dependencies change. However, the storage cost would be enormous, especially in distributed systems that run for a long time with continuous updates. We discuss three alternative approaches that are likely to be more efficient; each comes with its own set of tradeoffs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Three approaches</head><p>Provenance deltas. Instead of maintaining the full provenance information in each version, we can only record the deltas between adjacent versions. This reduces the storage cost considerably, but, when answering a query, the deltas need to be incrementally applied to regenerate the full provenance information.</p><p>Per-node input logs. If each node runs a deterministic algorithm, we can choose not to actively maintain provenance during execution time at all. Instead, we can simply record all the inputs (such as network messages, disk reads, etc) at each node. During a query, we can use deterministic replay to reproduce the system execution, and we can generate provenance on the fly.</p><p>System input logs. To reduce the storage overhead even further, we can record only the raw inputs (i.e., the base tuples) of the entire system. If the system's execution is deterministic, we can replay it based on the recorded inputs and generate the provenance information as before. This approach comes at the expense of higher querying overhead: since only the raw system-wide inputs are recorded, we cannot independently replay a single node; instead, we must replay the entire system execution.</p><p>To avoid replaying the deltas (or input logs) from the very beginning of the system execution, each node can periodically record a checkpoint of its current state. Thus, replay can start from the latest checkpoint. To save space, the checkpoints could be discarded after a certain amount of time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Tradeoffs</head><p>The maintenance approaches introduced in the previous section offer a spectrum of tradeoffs between maintenance overhead and querying performance. The best tradeoff depends on a variety of factors, some of which we discuss below.</p><p>Querying frequency. We expect that the cost for query processing will be a function of 1) how frequently queries are issued, 2) how far apart the checkpoints are in the log, and 3) how much work is required to replay a log segment. If queries are expected to be rare, we can save space by maintaining input logs, and by taking checkpoints only occasionally. In this case, answering a query can be expensive because the relevant parts of the provenance graph must be reconstructed by replaying the execution of certain nodes from their latest checkpoint.</p><p>If queries are more frequent, we can trade some space for a lower query-processing cost by 1) taking checkpoints more frequently, which reduces the expected length of the log segment that needs to be replayed, and/or 2) maintaining provenance deltas rather than input logs. The latter reduces the computational cost because replay only needs to incrementally apply the changes to the provenance data, but not repeat the processing steps that produced them.</p><p>System runtime. Many distributed systems run for an indefinite amount of time. For example, the Internet's interdomain routing system has been running for decades. In such systems, checkpoints are indispensable because it is not practical for the querier to replay the execution of the system, or even just a single node, from the very beginning. On the other hand, there are distributed systems that run only for a limited time. For example, a MapReduce cluster might be set up to process just a small number of large jobs, and many multiplayer games only last for a few hours. In this case, replaying the entire log may be practical, and if so, we can save even more space by not maintaining checkpoints at all.</p><p>Local derivations. Distributed systems differ in the relative frequency of remote derivations, which involve message exchanges between nodes, and purely local derivations. When most derivations are remote, both provenance deltas and input logs should perform equally well, since most state changes (which are recorded in provenance deltas) are due to incoming messages (which are recorded in the input logs). However, there are systems where most derivations are local; for example, a distributed machine-learning algorithm might just send a very few messages to transfer the raw data and the results. In this case, input logs should consume a lot less space than provenance deltas, but they would need a lot more computation when the provenance graph needs to be reconstructed to answer a query.</p><p>Trust. If all the nodes in the distributed system are trusted, we can safely optimize for query performance. However, if the system is large enough, it almost inevitably contains, at any given time, some nodes that are faulty or have been misconfigured or compromised. In this case, provenance deltas are risky because the querier cannot easily see whether a given delta was recorded correctly. Input logs are safer because the querier itself regenerates the provenance. Ideally, the correctness and completeness of the inputs in the logs would be verifiable through some other means.</p><p>In summary, there is no clear 'winner' among the three approaches we have proposed in Section 4.1; rather, the best approach depends on the specific use case in which TAP is applied. It would be interesting to design a provenance system that can adaptively select the best approach at runtime -for example, based on the observed query frequency and the workload characteristics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Provenance Querying</head><p>To query TAP's provenance graph, a suitable query language is needed. We are currently working on TapQL, an extension of ProQL <ref type="bibr" target="#b8">[9]</ref> that incorporates new language primitives to enable query specifications for time and changes. To illustrate, the following TapQL query can be used to analyze the (transitive) effects of a link insertion at a particular time in protocol execution: <ref type="bibr">X]</ref> binds variable X to the DELETE vertices of mincost, and <ref type="bibr">[+link $Y]</ref> binds Y to the INSERT vertices of link. INCLUDE PATH $X &lt;-+ $Y confines the search within the subgraph between vertices X and Y. The query returns the DELETE vertices of the mincost tuples that are triggered by the insertion of link tuples (with timestamps bigger than t).</p><formula xml:id="formula_1">FOR [-mincost $X] &lt;-+ [+link $Y] WHERE $Y.time&gt;t INCLUDE PATH $X &lt;-+ $Y RETURN $X [-mincost $</formula><p>If TAP maintains both forward and backward edges (i.e., from causes to effects and vice versa), provenance queries can ask for causality or effect chains, or even a combination of both. For example, to analyze the effects of a link insertion, one iterates through all the INSERT link vertices and follows the forward edges to reach DELETE mincost vertices. On the other hand, to query the cause of a deleted mincost vertex would require edge traversal in the opposite direction. We are planning to enhance TapQL to allow users to specify either cause or effect queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Querying Strategy</head><p>To process TapQL queries, we propose a novel multistaged query processing strategy (shown in <ref type="figure" target="#fig_1">Figure 3</ref>), which is specifically optimized for replays of provenance deltas or input logs. Our proposed strategy consists of the following three stages:</p><p>• A macroquery iterates through potential candidate tuples, e.g., all the mincost tuples in the example query, and issues microqueries to determine the provenance of each candidate tuple. Microqueries can be evaluated in parallel to optimize the overall query latency.</p><p>• A microquery performs a distributed recursive evaluation for the provenance of a single tuple. In essence, this amounts to a recursive traversal of the provenance graph <ref type="bibr" target="#b20">[21]</ref> until base tuples are reached. When a tuple satisfies the constraints in the query, the microquery should return the provenance of that tuple in the desired form, e.g. as a set of base tuples.  • A vertex query returns the set of vertices that are adjacent to a given vertex, as well as the corresponding edges. Vertex queries are the basic building block of the provenance querying. For instance, in <ref type="figure" target="#fig_1">Figure 3</ref>, t 2a , τ 2a is the returned result for t 2 , τ 2 . Vertex queries can be answered by replaying the provenance deltas or input logs to reproduce the relevant parts of the provenance graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Optimizations</head><p>There are several opportunities for optimizations at each stage of our proposed querying strategy. For instance, we can apply the following two optimizations, originally proposed in <ref type="bibr" target="#b20">[21]</ref>, at the microquery level:</p><p>• Early query termination. During microquery evaluation, the query can be terminated early if the results are guaranteed to be in (or out of) the result set. This is common for queries that compute monotonically increasing aggregate values with selection predicates, e.g., a query for vertices with more than a given number of unique derivations. In this case, the results can be returned (or discarded) as soon as the constraint is satisfied (or can no longer be satisfied).</p><p>• Another optimization is to cache query results, and reuse them for answering subsequent queries. Note that cache invalidation is not needed -as the query results are the fact of the execution history, and thus will not change over time.</p><p>• The overall querying performance would greatly benefit from reducing the overhead of performing vertex queries, which is carried out by replaying provenance deltas (or input logs). Existing work <ref type="bibr" target="#b11">[12]</ref> has proposed techniques that allow efficient incremental view maintenance using the already-captured provenance information.</p><p>One can also apply optimizations at the macroquery level. Traditional database optimizations, such as cost estimation of alternative query plans and heuristics, should generally be applicable here. For instance, if a provenance query involves tuples in multiple relations, we can start from relations with low cardinalities.</p><p>Interestingly, we can trade query response time for communication overhead at the macroquery level by using cached query results at the microquery level. Instead of issuing all microqueries at once, the query processor can choose to execute one microquery at a time, to maximize the likelihood of cache hits for subsequent queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Secure Provenance Querying</head><p>So far, we have assumed that all the nodes cooperate with the querier. However, in large distributed systems, it is not uncommon for some of the nodes to be faulty or compromised by an adversary. When a system contains such compromised nodes, provenance could be useful as a forensic tool; however, the adversary could attempt to cover his traces by deliberately tampering with the provenance information, causing query results to be incorrect and/or incomplete. Thus, it would be useful to have a provenance system that can give correctness guarantees even when it is under attack.</p><p>Not all adversaries are equally powerful. Often, adversaries only manage to compromise non-privileged software on the affected nodes. If the provenance information is extracted and maintained by a privileged component, such as the operating system kernel or a hypervisor, it is still possible to answer queries correctly. However, sometimes adversaries manage to compromise even privileged components, and can effectively take complete control over the affected nodes. During such attacks, correct answers to provenance queries would be particularly useful, but they are also particularly difficult to obtain.</p><p>We are currently working on a system that can answer distributed provenance queries even when some nodes have been completely compromised by an adversary. A perfect solution to this problem is impossible: for example, if the provenance of a tuple τ is stored on a set S of nodes, a query for the provenance of τ cannot be answered correctly if the adversary manages to compromise all the nodes in S. However, based on ideas from tamper-evident logging and auditing <ref type="bibr" target="#b5">[6]</ref>, it is possible to obtain a practical system with only slightly weaker guarantees.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>Figure 1: An three-node example network. The best path between node a and node c (highlighted) changes in response to a topology change.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The multi-staged querying strategy. t x , τ x refers to a tuple τ x at a given time t x .</figDesc></figure>

			<note place="foot" n="1"> The MINCOST protocol can be extended to specify more complex routing protocols, such as distance-vector and path-vector. derived when S has a (possibly indirect) path to D with total cost C, which can either be a direct link (mc1) or a path through another node Z (mc2). Rule mc3 aggregates all paths with the same sources and destinations to compute the minimal path cost. The protocol runs continuously, and updates path costs as links appear or disappear. 2.2 Network Provenance Existing provenance models, e.g., the model in [2] and [21], capture the dependencies between tuples in a graph that consists of tuple vertices and rule execution vertices, and in which the edges represent data flows. Decentralized models for distributed systems -also known as network provenance models -partition this graph in some way, e.g., by the location specifiers, and store each partition on a different node. Consider the execution of the MINCOST protocol in the three-node network that is shown in Figure 1. Initially, at time t 1 , the system is in a quiescent state. Then, at time t 2 &gt; t 1 , a link with cost 1 is inserted between nodes a and c, which changes the topology of the network. As a consequence, the cost of c&apos;s cheapest path to a changes from 5 to 4; however, due to communication delays, the change is not propagated to c until time t 3 &gt; t 2 . The left part of Figure 2 shows the provenance of the resulting tuple mincost(@c,a,4), which is generated from rule mc3 at node c. It is based on the tuple cost(@c,a,4), which corresponds to the path c-b-a. This example illustrates two limitations of existing network provenance systems. First, existing systems can correctly answer provenance queries for the updated tuple once the system is in a stable state again (after time t 3 ); however, the answer to such a query can be incorrect or incomplete between t 2 and t 3 , when some nodes have already received the update and others have not. While inconsistencies due to transient state could</note>

			<note place="foot" n="2"> Note that TAP&apos;s concept of causality is typically referred to as data lineage in the database literature. Our notion of causality differs from [14, 15], which take the lineage information to infer &apos;actual&apos; contributions of base tuples to the query results.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported by NSF grants IIS-0477972, IIS-0713267, CNS-0721541, IIS-0812270, CCF-0820208, CNS-0845552, CNS-1040672, CNS-1054229, and AFOSR MURI grant FA9550-08-1-0352.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Archiving scientific data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Tajima</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="2" to="42" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Why and where: A characterization of data provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDT</title>
		<meeting>ICDT</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Provenance and scientific workflows: challenges and opportunities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">B</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Freire</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Update exchange with mappings and provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB</title>
		<meeting>VLDB</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Maintaining Views Incrementally</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">S</forename><surname>Mumick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">S</forename><surname>Subrahmanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">PeerReview: Practical accountability for distributed systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Haeberlen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kuznetsov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Druschel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2007-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Preventing history forgery with secure provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hasan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sion</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Winslett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Storage</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="43" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Snodgrass. A glossary of temporal database concepts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Clifford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Gadia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Segev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="35" to="43" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Querying data provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Backtracking intrusions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="51" to="76" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Designing access methods for bitemporal databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">J</forename><surname>Tsotras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Knowl. and Data Eng</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1" to="20" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Maintaining recursive views of regions and connectivity in networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">E</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">T</forename><surname>Loo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Knowl. and Data Eng</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="1126" to="1141" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Declarative Networking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">T</forename><surname>Loo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Condie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Maniatis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Roscoe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="87" to="95" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Causality in databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Meliou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Gatterbauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">F</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Eng. Bull</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="59" to="67" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The complexity of causality and responsibility for query answers and nonanswers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Meliou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Gatterbauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">F</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endowment</title>
		<meeting>VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="34" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Provenance-aware storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-K</forename><surname>Muniswamy-Reddy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Holland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Seltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX ATC</title>
		<meeting>USENIX ATC</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Approximate lineage for probabilistic databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endowment</title>
		<meeting>VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A measurement framework for pinpointing routing changes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Teixeira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGCOMM Network Troubleshooting Workshop</title>
		<meeting>ACM SIGCOMM Network Troubleshooting Workshop</meeting>
		<imprint>
			<date type="published" when="2004-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Trio: A system for integrated management of data, accuracy, and lineage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CIDR</title>
		<meeting>CIDR</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Profiling network performance for multi-tier data center applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Maltz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kandula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Efficient querying and maintenance of network provenance at Internetscale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sherr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">T</forename><surname>Loo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Mao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
