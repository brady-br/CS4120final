<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:57+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Filesystem Aging: It&apos;s more Usage than Fullness</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Conway</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Rutgers University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Knorr</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Rutgers University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yizheng</forename><surname>Jiao</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">UNC</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Bender</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">Stony Brook University</orgName>
								<address>
									<addrLine>4 Williams College</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Jannen</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rob</forename><surname>Johnson</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">VMware Research</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><surname>Porter</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">UNC</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Farach-Colton</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Rutgers University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Filesystem Aging: It&apos;s more Usage than Fullness</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Filesystem fragmentation is a first-order performance problem that has been the target of many heuristic and algorithmic approaches. Real-world application benchmarks show that common filesystem operations cause many filesystems to fragment over time, a phenomenon known as filesystem aging. This paper examines the common assumption that space pressure will exacerbate fragmentation. Our mi-crobenchmarks show that space pressure can cause a substantial amount of inter-file and intra-file fragmentation. However, on a &quot;real-world&quot; application benchmark, space pressure causes fragmentation that slows subsequent reads by only 20% on ext4, relative to the amount of fragmentation that would occur on a file system with abundant space. The other file systems show negligible additional degradation under space pressure. Our results suggest that the effect of free-space fragmentation on read performance is best described as accelerating the filesystem aging process. The effect on write performance is non-existent in some cases, and, in most cases, an order of magnitude smaller than the read degradation from fragmentation cause by normal usage.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Over the course of ordinary use, filesystems tend to become fragmented, or age. Fragmentation causes performance declines in many filesystem operations, including file reads, writes, and recursive directory traversals. Aging tends to manifest as a pervasive performance decline.</p><p>Because aging is sensitive to usage patterns and can happen slowly over time, it is notoriously difficult to study. Smith and Seltzer <ref type="bibr" target="#b12">[15]</ref> studied the real-world performance of the Fast Filesystem (FFS) over the course of 3 years and showed substantial filesystem aging. However, the cost and time of repeating such a study on each new filesystem, storage device and user workload render this approach infeasible. However, their findings inspired work on tools to synthetically age file systems <ref type="bibr" target="#b3">[6,</ref><ref type="bibr" target="#b14">17]</ref>.</p><p>Because aging is difficult to repeatably measure, a certain amount of folklore has emerged. Many practitioners believe that filesystem aging is already solved and claim that aging only occurs under adversarial workloads or when the disk is full. For example Wikipedia claims that, as time progresses and the free space fragments ". . . the filesystem is no longer able to allocate new files contiguously, and has to break them into fragments. This is especially true when the filesystem becomes full and large contiguous regions of free space are unavailable." <ref type="bibr" target="#b0">[3]</ref> Recent work by Conway et al. <ref type="bibr" target="#b5">[8]</ref> and <ref type="bibr">Kadekodi et al. [12]</ref> showed that this optimism was unfounded. They showed that modern filesystems do age, often severely, even on SSDs, even under realistic workloads, even when the disk is far from full. For example, <ref type="bibr">Conway et al.</ref> showed that ext4 could exhibit slowdowns of over 20× on a realistic git-based workload on a nearly empty hard drive, and slowdowns of 2 − 4× on an SSD.</p><p>The goal of this paper is to tease out the effect of disk fullness on filesystem fragmentation. We first use a synthetic benchmark designed to stress the worst-case, fulldisk behavior of the filesystem. We find that, on an HDD, the synthetic benchmark can cause ext4 to fragment far worse on a full disk than on a nearly empty one. For the other filesystems, a full disk roughly doubles the read performance degradation from fragmentation. On SSDs, disk fullness has a modest effect on read degradation from fragmentation (typically less than 20%), except on BTRFS.</p><p>We then measure a more realistic, git-based application workload, in which disk fullness degrades read performance by only about 20% for ext4 on HDD compared to normal fragmentation. It has a negligible impact for BTRFS and XFS on HDD, and for all filesystems on SSD.</p><p>In summary, our results show that file and directory allocations on modern filesystems can be severely fragmented in the course of normal usage, even with plenty of contiguous free space. Although the fragmentation is worsened under space pressure in a few stress tests, the behavior is inconsistent across file systems. Our results suggest that normal usage will erode performance before space pressure and the resulting free-space fragmentation has the opportunity. An interesting question for future work is whether space pressure is more of a problem on a filesystem which resists use-aging, such asx BetrFS <ref type="bibr" target="#b5">[8,</ref><ref type="bibr" target="#b7">10,</ref><ref type="bibr" target="#b13">16]</ref>.</p><p>Prior work can be broadly classified into two categories: aging studies and anti-aging techniques.</p><p>Reproducing and studying aging. It takes years to collect years of traces from live systems. Moreover, traces are large, idiosyncratic, and may contain sensitive data. Consequently, researchers have created synthetic benchmarks to simulate aging. These benchmarks create files and directories and perform normal filesystem operations to induce aging <ref type="bibr" target="#b2">[5]</ref>. Once aged, a filesystem can be profiled using other benchmarking tools to understand how an initial aged state affects future operations.</p><p>Ji et al.</p><p>[11] studied filesystem fragmentation on mobile devices, confirming that fragmentation causes performance degradation on mobile devices and that existing defragmentation techniques are ineffective.</p><p>Anti-aging strategies. The perception that aging is a solved problem is likely due to the abysmal aging of the once ubiquitous FAT filesystem. FAT tracks file contents using a linked list, so a cold-cache random read is particularly expensive when compared to modern tree-structured filesystems. Moreover, most FAT implementations have no heuristics to combat aging; lack read-ahead or other latency-hiding heuristics; and, on earlier PCs with limited DRAM, suffered frequent cache misses <ref type="bibr" target="#b6">[9]</ref>. Even on more modern systems, write performance on an aged FAT filesystem degrades by two orders of magnitude <ref type="bibr" target="#b11">[14]</ref>. As a result, users were trained to defragment hard drives using an offline utility, which rendered a noticeable performance improvement. Although the works above show that modern filesystems also age, the aging is not as extreme as users experienced with FAT.</p><p>Block groups are an anti-aging strategy introduced in FFS <ref type="bibr" target="#b10">[13]</ref> and adopted by modern filesystems like ext4. Another common strategy is to pre-allocate contiguous file regions, either by inference or via explicit interfaces like fallocate(). Finally, BetrFS uses large (2-4 MB) nodes to group related data, and it incrementally rewrites data to preserve locality as the filesystem evolves <ref type="bibr" target="#b5">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Free-Space Fragmentation</head><p>This section explains how disk fullness can impact freespace fragmentation, how free-space fragmentation can impact filesystem performance, and how free-space fragmentation can lead to other kinds of fragmentation. The observations in this section will be used in the next section to design benchmarks for measuring the impact of disk fullness on filesystem aging.</p><p>Filesystem fragmentation. Several types of disk blocks should be kept together to improve filesystem performance. Fragmentation occurs when related blocks become scattered. We categorize fragmentation by the types of blocks and their relationships:</p><p>Intrafile: fragmentation of allocated blocks in a file. Interfile: fragmentation of the blocks of small files in the same directory. Free-space: fragmentation of unused disk blocks. The first two types of fragmentation directly impact the read performance of a filesystem and together can be referred to as read aging. During a scan of filesystem data, fragmented blocks will incur non-sequential reads, which on most modern storage hardware are considerably slower than sequential reads.</p><p>Free-space fragmentation, disk fullness, and write performance. This paper focuses on disk fullness and any resulting free-space fragmentation, which can have a direct effect on write performance and an indirect effect on read performance. When free space is fragmented, the filesystem must choose between scattering new data among the existing free-space fragments (fewer writes, slower future reads) or migrating old data to coalesce free-space fragments (more writes, faster future reads). If a filesystem fragments incoming writes, then free-space fragmentation gets turned into regular intra-and interfile fragmentation, i.e., read aging. A fragmented write is also slower than when free space is unfragmented, as one write is split into discrete I/Os. If the filesystem compacts the free space by moving data, the compaction slows the write operation. In either case, free-space fragmentation degrades write performance.</p><p>Note that intra-and inter-file fragmentation can exacerbate free-space fragmentation, and vice versa: fragmented files, when deleted, produce fragmented free space.</p><p>As the disk becomes full, free-space fragmentation tends to worsen. If the filesystem coalesces free-space fragments, combining several small fragments into one large fragments may involve copying already-allocated data multiple times to avoid fragmenting it <ref type="bibr" target="#b4">[7]</ref>. This cost is inversely proportional to the fraction of free space available on the disk. Even on systems that don't coalesce free-space fragments, fuller disks simply have more allocated objects and less free space, so it becomes more difficult to co-locate related data.</p><p>Free-space fragmentation and read performance. Free-space fragmentation differs from the other types of fragmentation in that it doesn't immediately impact read performance. Because HDDs and most types of SSDs have faster sequential reads than random reads, inter-and intra-file fragmentation causes scans to be slower <ref type="bibr" target="#b1">[4]</ref>. Free-space fragmentation, on the other hand, doesn't affect read performance, since free space is not accessed during a scan.</p><p>Summary. Though the different forms of fragmentation are interdependent, we can cleanly measure each type at any single moment in time. We can measure free-space fragmentation directly on ext4 using e2freefrag. For the other file systems, the allocated and free space can be inferred by scanning the data with a cold cache and using a tool such as blktrace <ref type="bibr">[1]</ref> to see which blocks are read, but we do not pursue this approach here. We can measure intra-and inter-file fragmentation by measuring read performance. Due to the complex feedback described above, we might expect that disk fullness will affect both freespace and intra-and inter-file fragmentation, and hence will affect read and write performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Measuring Fragmented Performance</head><p>The goal of our benchmarks is to understand how disk fullness affects filesystem fragmentation, and the subsequent read and write performance. In particular:</p><p>• Empty, full, and unaged disks. We measure the effects of fragmentation and full disks as follows. We first run a workload generator on a small partition (the "full disk" case). This generator may create, delete, rename, write, etc., files. It measures the disk fullness and ensures that, after initial setup, the partition is always above a certain level of fullness. We record the sequence of operations (such as git pulls or file deletions) performed and then replay them on a much larger partition (the "empty disk" case). Thus the empty and full partitions go through the exact same sequence of logical filesystem states. We run the test on the full partition, the empty partition, and on a fresh (large) partition to which we have copied the current state (the "unaged disk" case). The unaged partition thus provides the baseline performance of an unaged version of the same filesystem state.</p><p>Measuring read fragmentation: The Grep Test. To measure fragmentation, we periodically pause the workload generator and run a grep test. This is the wall-clock time it takes to perform a recursive grep on the root directory of the filesystem. This performs a recursive scan through the data and metadata. Fragmentation will cause this scan to be less sequential. Because the filesystems change over time, we report this time normalized by the filesystem size as reported by du -s.</p><p>Measuring write fragmentation. To measure write fragmentation, we use the wall-clock latency of new writes. We check that the workload is not CPU-bound.</p><p>Measuring free-space fragmentation We measure freespace fragmentation directly on ext4 using the e2freefrag tool <ref type="bibr">[2]</ref>. This tool reports a histogram of the sizes of free extents. We do not directly measure the free-space fragmentation on XFS, BTRFS or F2FS.</p><p>Experimental setup. Each experiment compares three filesystems on HDD: BTRFS, ext4 and XFS, and additionally F2FS on SSD, using the versions in Ubuntu 14.04.5 LTS, kernel version 3.11.10 with default settings. The benchmarks do not use O_DIRECT, and therefore the filesystems may use the page cache.</p><p>We use Dell PowerEdge T130 machines with 4-core 3.00 GHz Intel(R) Xeon(R) E3-1220 v6 CPU, 16 GB RAM, two 500 GB, 7,200 RPM TOSHIBA HDDs and a 250 GB Samsung SSD 860.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Results</head><p>In this section we describe the benchmarks used to generate free-space fragmentation and the results of running them on several popular filesystems.</p><p>Free-space fragmentation microbenchmark (FSFB). FSFB is a worst-case microbenchmark, designed to induce severe free-space fragmentation. FSFB first fills a filesystem with many small files. Next, it randomly selects files for deletion and creates a new directory with the same total size as the deleted files. Deleting small files creates fragmented free space, across which the new directory will need to be allocated.</p><p>FSFB starts by creating a random directory structure with 1000 directories. Then it creates files by randomly selecting a directory and creating a file there with size chosen randomly between 1KiB and 150KiB. This process creates the files out-of-directory-order, so that the initial layout is "pre-aged." This process repeats until the filesystem reaches the target level of fullness.</p><p>FSFB then ages the filesystem through a series of replacement rounds. In a replacement round, 5% of the files, by size, are removed at random and then replaced by new files of equivalent total size in a newly created directory in a random location.</p><p>FSFB read aging. We run the microbenchmark with a target fullness of 95% on a 5GB partition. We then age the filesystem for 500 replacement rounds, performing a grep test every 50 rounds. We then replay the benchmark on a 50GB partition, so that it is at most 10% full ("empty"). We also create an "unaged" version by copying the data to a fresh partition. <ref type="figure">Figure 1a</ref> shows the HDD results. All filesystems are slower in the full-disk case than the empty-disk case. However, BTRFS and XFS slow-down far more from unaged to aged than from empty to full. ext4, in contrast, only loses read performance under space pressure. <ref type="figure">Figure 1b</ref> shows the SSD results. The additional read aging from disk fullness is negligible. (b) Grep performance on SSD under FSFB. The full filesystems show no discernable slowdown compared to empty, however the empty ones are 25-50% slower than unaged. <ref type="figure">Figure 1</ref>: Read performance under FSBS on a 95% full "full" disk, a 10% full "empty" disk, and an "unaged" copy. Lower is better.</p><p>FSFB write aging. We measure write aging by measuring the wall-clock time to create each new directory of files during a replacement round. <ref type="figure" target="#fig_0">Figure 2a</ref> shows that, on an empty hard drive, none of the filesystems exhibit any write aging beyond the initial filesystem construction. When the disk is full, ext4 has 40% higher write costs, BTRFS has 25% higher write costs, and XFS has essentially the same costs. Thus disk fullness does induce some write aging, but it is an order of magnitude less than read aging on an empty disk.</p><p>On SSDs <ref type="figure" target="#fig_0">(Figure 2b</ref>), XFS is slightly faster when the disk is full, ext4 exhibits a modest 25% slowdown between the empty an full cases, BTRFS rapidly loses half its performance in the full-disk case, and F2FS has erratic but generally only slightly slower performance. Again,  except possibly for BTRFS, the performance differences between an empty and full SSD are smaller than the read aging performance losses on an empty disk.</p><p>As with the read aging effect of disk fullness, space pressure induces a significant write aging effect, but it is an order of magnitude smaller than read aging. The two outlier points were ext4 full-disk aging on an HDD and BTRFS write aging on an SSD. It might be worth investigating the design decisions that make these filesystems vulnerable to this workload on a full disk.</p><p>Git-Benchmark full-disk read aging. We also use git as a more representative application benchmark. We modify the git aging benchmark <ref type="bibr" target="#b5">[8]</ref>, so that it can be used to keep a disk in a nearly-full steady state. The git benchmark replays the commit history of the Linux kernel from github.com. The benchmark pulls each commit, running a grep test every 100 commits.</p><p>The challenge to performing the git test on a full disk is that the repository grows over time.  and eventually becomes full, at which time we cannot pull newer commits. We overcome this challenge by maintaining multiple copies of the repository. We initially fill the disk to 75% by creating multiple copies of the initial commit. Then we update the repositories round-robin by pulling one more commit, until a pull fails due to disk fullness. At that point the repository to which the pull failed is deleted, freeing up space. Then the process continues.</p><p>Every operation is also mirrored on an "empty" filesystem and an "unaged" version (see section 4). Because this workload is generally CPU-bound during the pulls, we do not present the effect on write aging.</p><p>On an HDD, there is a big difference between the empty and unaged versions <ref type="figure" target="#fig_1">(Figure 3a)</ref>, commensurate with prior results <ref type="bibr" target="#b5">[8]</ref>. For XFS and BTRFS, the full and empty versions are barely distinguishable. The read cost for ext4 on a full disk is about 20% greater than on an empty disk.</p><p>On SSD, the full and empty lines of all three filesystems 050 150 500 <ref type="bibr">20</ref>  Figure 4: Free space by extent size on ext4 for snapshots under FSFB (at 0, 50, 150 and 500 rounds) and git (at 0, 1, 3.5 and 10 thousand pulls). Each bar represents the total free space in extents of the given size.</p><p>are essentially indistinguishable, shown in <ref type="figure" target="#fig_1">Figure 3b</ref>. On ext4, F2FS and, to a lesser extent on BTRFS, the read costs of the unaged versions drift higher as the benchmark progresses. This is due to a smaller average file size.</p><p>If free-space aging were a first-order consideration, we would expect it to consistently create performance degradation in all of these experiments. In the git workload, disk fullness has at most a lower-order effect on read aging than the workload itself. Its biggest impact was on ext4 on HDD, which added 20% to the read cost, compared to a 1,200% increase from the baseline fragmentation caused by usage with an abunance of space.</p><p>Free-Space Fragmentation on ext4 <ref type="figure">figure 4</ref> shows the distribution of free-space among different extent sizes (bucketed into powers of 2), as reported by e2freefrag <ref type="bibr">[2]</ref>, on ext4 during our benchmarks.</p><p>Both benchmarks create many small free fragments. However, FSFB on a full disk immediately uses all the large free extents, whereas git on a full disk and both benchmarks on a empty disk have large free extents available throughout. Because ext4 saw a large performance impact from fullness under FSFB (figure 1), but not under git (figure 3), this suggests that the availability of large free extents is more important for ext4 performance than the existence of many small free fragments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion Topics</head><p>Our position is that, although the community acknowledges that filesystem aging degrades performance, the causes and effects of filesystem aging are poorly understood. As a result both filesystem designers and filesystem users do not know how to prevent, treat or even work around this problem.</p><p>We would like to engage the storage community about their experience with filesystem aging and full-disk fragmentation.</p><p>• Are there additional experiments that the community would find compelling to tease out and isolate the root causes of aging?</p><p>• Are there realistic application workloads-beyond git-that would generate aged filesystem states? Specifically, are there application workloads that generate significant free space fragmentation that have been observed in the wild?</p><p>• What techniques can be/are being used to combat the different causes of filesystem aging?</p><p>This paper seeks to generate discussion by challenging the commonly held belief that disk fullness has a first-order performance impact on filesystem performance. If workshop attendees have lived experiences that run counter to our findings, we hope to discuss the conditions that led to the filesystem states that they observed and diagnose the root cause of their filesystem's performance degradation.</p><p>To the extent that disk fullness presents challenges to filesystem design, we would love to discuss the theoretical and systems-design approaches which could solve the problem.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Write performance under FSFB on a 95% full "full" disk and a 10% full "empty" disk. Lower is better.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Read performance under the git benchmark. Lower is better.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>40 60</head><label>60</label><figDesc></figDesc><table>FSFB full 
Space (MiB) 

050 150 
500 
0 

5 

10 

FSFB empty 

Space (GiB) 

0 1 3.5 
10 
0 200 400 600 

git full 
Space (MiB) 

0 1 3.5 
10 
0 
2 4 6 8 

git empty 

Space (GiB) 

2GiB 
1GiB 
512MiB 
256MiB 
128MiB 
64MiB 
32MiB 
16MiB 
8MiB 
4MiB 
2MiB 
1MiB 
512KiB 
256KiB 
128KiB 
64KiB 
32KiB 
16KiB 
8KiB 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank the anonymous reviewers and our shepherd, Ethan Miller, for their helpful feedback on the paper. We gratefully acknowledge support from a NetApp Faculty Fellowship, NSF grants CCF 805476, CCF 822388, CNS</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Wikipedia: File system fragmentation</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
				<title level="m">31st ACM Symposium on Parallelism in Algorithms and Architectures, SPAA</title>
		<meeting><address><addrLine>Phoenix, AZ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019-06-22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Generating realistic impressions for file-system benchmarking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nitin</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Remzi</forename><forename type="middle">H</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<idno>16:1-16:30</idno>
	</analytic>
	<monogr>
		<title level="j">TOS</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Generating realistic impressions for file-system benchmarking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nitin</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Remzi</forename><forename type="middle">H</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX FAST</title>
		<editor>Margo I. Seltzer and Richard Wheeler</editor>
		<imprint>
			<publisher>USENIX</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="125" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Costoblivious storage reallocation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Bender</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Farach-Colton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sándor</forename><forename type="middle">P</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><forename type="middle">T</forename><surname>Fineman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seth</forename><surname>Gilbert</surname></persName>
		</author>
		<idno>38:1-38:20</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Algorithms</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">File systems fated for senescence? nonsense, says science! In</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ainesh</forename><surname>Bakshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yizheng</forename><surname>Jiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Jannen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename><surname>Zhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jun</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Bender</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rob</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bradley</forename><forename type="middle">C</forename><surname>Kuszmaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Farach-Colton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX FAST</title>
		<editor>Geoff Kuenning and Carl A. Waldspurger</editor>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="45" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Design goals and implementation of the new high performance file system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert Kelley</forename><surname>Cook</surname></persName>
		</author>
		<ptr target="http://cd.textfiles.com/megademo2/INFO/OS2_HPFS.TXT" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Betrfs: A right-optimized write-optimized file system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Jannen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jun</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename><surname>Zhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amogh</forename><surname>Akshintala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Esmet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yizheng</forename><surname>Jiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ankur</forename><surname>Mittal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prashant</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phaneendra</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leif</forename><surname>Walsh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Bender</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Farach-Colton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rob</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bradley</forename><forename type="middle">C</forename><surname>Kuszmaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Association</title>
		<editor>Jiri Schindler and Erez Zadok</editor>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="301" to="315" />
		</imprint>
	</monogr>
	<note>USENIX FAST</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An empirical study of filesystem fragmentation in mobile storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cheng</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li-Pin</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chao</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qiao</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chun</forename><forename type="middle">Jason</forename><surname>Xue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HotStorage. USENIX Association</title>
		<editor>Nitin Agrawal and Sam H. Noh</editor>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Geriatrix: Aging what you see and what you don&apos;t see. A file system aging approach for modern storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saurabh</forename><surname>Kadekodi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vaishnavh</forename><surname>Nagarajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC</title>
		<editor>Haryadi S. Gunawi and Benjamin Reed</editor>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="691" to="704" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A fast file system for UNIX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marshall</forename><forename type="middle">K</forename><surname>Mckusick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">N</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><forename type="middle">J</forename><surname>Leffler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">S</forename><surname>Fabry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="181" to="197" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Flash drive fragmentation: does it affect performance?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Han-Kwang</forename><surname>Nienhuys</surname></persName>
		</author>
		<ptr target="http://www.lagom.nl/misc/flash_fragmentation.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">File system aging -increasing the relevance of file system benchmarks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Keith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Margo</forename><forename type="middle">I</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Seltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1997 ACM SIGMETRICS international conference on Measurement and modeling of computer systems</title>
		<editor>John Zahorjan, Albert G. Greenberg, and Scott T. Leutenegger</editor>
		<meeting>the 1997 ACM SIGMETRICS international conference on Measurement and modeling of computer systems<address><addrLine>Seattle, Washington, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="203" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Optimizing every operation in a writeoptimized file system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jun</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename><surname>Zhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Jannen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prashant</forename><surname>Pandey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amogh</forename><surname>Akshintala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kanchan</forename><surname>Chandnani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pooja</forename><surname>Deo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zardosht</forename><surname>Kasheff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leif</forename><surname>Walsh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Bender</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Farach-Colton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rob</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bradley</forename><forename type="middle">C</forename><surname>Kuszmaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><forename type="middle">E</forename><surname>Porter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX FAST</title>
		<editor>Angela Demke Brown and Florentina I. Popovici</editor>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">TBBT: scalable and accurate trace replay for file server evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ningning</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiawu</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tzi-Cker</forename><surname>Chiueh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the FAST &apos;05 Conference on File and Storage Technologies</title>
		<editor>Garth Gibson</editor>
		<meeting>the FAST &apos;05 Conference on File and Storage Technologies<address><addrLine>San Francisco, California, USA. USENIX</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
