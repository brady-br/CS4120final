<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T03:02+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scaling Security for Big, Parallel File Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher>ACM</publisher>
				<availability status="unknown"><p>Copyright ACM</p>
				</availability>
				<date type="published" when="2006-10">Oct. 2006. Nov. 2006</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Leung</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ethan</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Weil</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Brandt</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">D E</forename><surname>Long</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Maltzahn</surname></persName>
						</author>
						<author>
							<affiliation>
								<orgName>1 Motivation</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Scaling Security for Big, Parallel File Systems</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 7th Symposium on Operating Systems Design and Implementation (OSDI)</title>
						<meeting>the 7th Symposium on Operating Systems Design and Implementation (OSDI) <address><addrLine>Seattle, WA</addrLine></address>
						</meeting>
						<imprint>
							<publisher>ACM</publisher>
							<date type="published" when="2006-10">Oct. 2006. Nov. 2006</date>
						</imprint>
					</monogr>
					<note>Ceph: A scalable, high-performance distributed file system. In</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The need for peta-and exabyte scale parallel file systems that support high-performance computing (HPC) has been rapidly increasing. These systems have unique demands, different from those of traditional distributed file systems. As a result, securing I/O in big, parallel file systems without significantly impacting performance has proven challenging. Parallel file systems are commonly composed of three components: clients, metadata servers, and network-attached storage devices, such as disks or object-storage devices. Security is commonly based on a capability model, where capabilities are &apos;tokens&apos; which represent single block or object I/O authorization. Capabilities are generated by metadata servers, given to clients, and presented to storage devices with I/O requests. Peta-and exabyte scale systems may have tens of thousands of clients and storage devices. Files are very large, often giga-bytes to terabytes, and are commonly striped across thousands of storage devices. HPC workloads are parallel and bursty, meaning I/O often comes from many clients at a time with very short inter-arrival times. This implies files are commonly accessed by thousands of clients within a few seconds. These factors are often worst-case scenarios for many existing solutions. While there are many security schemes for distributed file systems, few have addressed large-scale, demanding environments. In these environments existing solutions cannot sustain high performance or must weaken security to do so. HPC workloads can burden metadata and data servers with generating and verifying millions of single block or object capabilities. Reliance on shared-key cryptography introduces vulner-abilities when millions of storage devices are susceptible to attack. Also, many common security techniques, such as revocation , become difficult with so many clients and storage devices. 2 Our Approach We are developing a protocol that is designed to provide secure I/O for petabyte-scale, parallel file systems. Our approach seeks to leverage common HPC characteristics and simplify security management to improve performance and scalability. Our protocol, Maat, employs three main concepts: extended capabilities, automatic revocation, and scalable, secure delegation. Extended capabilities allow a capability to authorize I/O for any number of clients to any number of files. Grouping policies allow the MDS to decide how to include client and file authorization in a capability. By conferring access for client-file pairs, rather than single client-block or client-object pairs, and aggregating many pairs into a capability Maat is able to greatly reduce the number of capabilities in the system, as well as, exploit capability reuse. Extended capabilities are secured using asymmetric cryptography, allowing anyone in the system to verify a capability&apos;s integrity. Though asymmetric cryptography is quite slow, the reduced number of capabilities serves to greatly amortize this cost. Merkle trees are used to identify authorized client and file I/O in a capability, allowing capabilities to be fixed-size and still enforce confinement. Through the use of an update protocol, clients and storage devices can flatten these trees into lists of clients and files. A lookup mechanism allows storage devices to then map files to local blocks or objects. Automatic revocation allows access rights to be revoked without the need to contact any clients or storage devices. Each capability has a short timeout. Once a capability has timed-out it is no longer valid. Capability lifetimes can be extended using extension token that are distributed by metadata servers and cached at clients and storage devices. A single extension token can proactively prolong the timeouts for a very large number of capabilities by batching many extensions into a single token. This allows clients to reuse valid capabilities with little overhead. As a result, revocation is independent of who holds capabilities or which devices hold file data, allowing Maat to scale to very large systems. Cooperative computation, common in HPC workloads, is achieved through the use of scalable, secure delegation. A single client may open a file on behalf of any number of other clients to reduce the overhead of large, joint computations. This client generates an asymmetric key pair and uses the public key to receive a file handle and capability associated with the key from the metadata servers. The client then distributes the private key, capability, and file handle to any other clients cooperating in the computation which the other clients use to perform I/O. This provides scalable delegation and supports POSIX HPC I/O extensions openg() and openfh(). Additionally , by associating clients with computational keys at the metadata servers we are able to achieve confinement. 3 Current Status An earlier paper [1] discusses some of our initial designs. We are implementing Maat in the Ceph petabyte-scale, parallel file system [2]. Ceph is an object file system which achieves much of its scalability by pushing responsibility to intelligent network-attached object-storage devices (OSDs). This allows Maat to leverage OSD intelligence without addressing power and cache size issues common to disks. In the future Maat will address other issues, such as, on-disk security. References [1] A. Leung and E. L. Miller. Scalable security for large, high performance storage systems. In</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Our Approach</head><p>We are developing a protocol that is designed to provide secure I/O for petabyte-scale, parallel file systems. Our approach seeks to leverage common HPC characteristics and simplify security management to improve performance and scalability. Our protocol, Maat, employs three main concepts: extended capabilities, automatic revocation, and scalable, secure delegation.</p><p>Extended capabilities allow a capability to authorize I/O for any number of clients to any number of files. Grouping policies allow the MDS to decide how to include client and file authorization in a capability. By conferring access for client-file pairs, rather than single client-block or client-object pairs, and aggregating many pairs into a capability Maat is able to greatly reduce the number of capabilities in the system, as well as, exploit capability reuse. Extended capabilities are secured using asymmetric cryptography, allowing anyone in the system to verify a capability's integrity. Though asymmetric cryptography is quite slow, the reduced number of capabilities serves to greatly amortize this cost. Merkle trees are used to identify authorized client and file I/O in a capability, allowing capabilities to be fixed-size and still enforce confinement. Through the use of an update protocol, clients and storage devices can flatten these trees into lists of clients and files. A lookup mechanism allows storage devices to then map files to local blocks or objects.</p><p>Automatic revocation allows access rights to be revoked without the need to contact any clients or storage devices. Each capability has a short timeout. Once a capability has timed-out it is no longer valid. Capability lifetimes can be extended using extension token that are distributed by metadata servers and cached at clients and storage devices. A single extension token can proactively prolong the timeouts for a very large number of capabilities by batching many extensions into a single token. This allows clients to reuse valid capabilities with little overhead. As a result, revocation is independent of who holds capabilities or which devices hold file data, allowing Maat to scale to very large systems.</p><p>Cooperative computation, common in HPC workloads, is achieved through the use of scalable, secure delegation. A single client may open a file on behalf of any number of other clients to reduce the overhead of large, joint computations. This client generates an asymmetric key pair and uses the public key to receive a file handle and capability associated with the key from the metadata servers. The client then distributes the private key, capability, and file handle to any other clients cooperating in the computation which the other clients use to perform I/O. This provides scalable delegation and supports POSIX HPC I/O extensions openg() and openfh(). Additionally, by associating clients with computational keys at the metadata servers we are able to achieve confinement.</p></div>		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Current Status</head><p>An earlier paper <ref type="bibr" target="#b0">[1]</ref> discusses some of our initial designs. We are implementing Maat in the Ceph petabyte-scale, parallel file system <ref type="bibr" target="#b1">[2]</ref>. Ceph is an object file system which achieves much of its scalability by pushing responsibility to intelligent network-attached object-storage devices (OSDs). This allows Maat to leverage OSD intelligence without addressing power and cache size issues common to disks. In the future Maat will address other issues, such as, on-disk security.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Scalable security for large, high performance storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Leung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 ACM Workshop on Storage Security and Survivability</title>
		<meeting>the 2006 ACM Workshop on Storage Security and Survivability</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Ceph: A scalable, high-performance distributed file system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Weil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Brandt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">D E</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Maltzahn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<meeting>the 7th Symposium on Operating Systems Design and Implementation (OSDI)<address><addrLine>Seattle, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-11" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
