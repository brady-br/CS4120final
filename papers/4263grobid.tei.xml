<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:08+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Unpatchable Silicon: A Full Break of the Bitstream Encryption of Xilinx 7-Series FPGAs The Unpatchable Silicon: A Full Break of the Bitstream Encryption of Xilinx 7-Series FPGAs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maik</forename><surname>Ender</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amir</forename><surname>Moradi</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christof</forename><surname>Paar</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maik</forename><surname>Ender</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amir</forename><surname>Moradi</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christof</forename><surname>Paar</surname></persName>
							<affiliation key="aff3">
								<orgName type="department">Max Planck Institute for Cyber Security and Privacy</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Horst</forename><surname>Goertz</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Goertz Institute for IT Security</orgName>
								<orgName type="department" key="dep2">Max Planck Institute for Cyber Security and Privacy and Horst Goertz Institute for IT Security</orgName>
								<orgName type="institution">Ruhr University Bochum</orgName>
								<address>
									<settlement>Horst</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Institute for IT Security</orgName>
								<orgName type="institution">Ruhr University</orgName>
								<address>
									<settlement>Bochum</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Ruhr University Bochum</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Unpatchable Silicon: A Full Break of the Bitstream Encryption of Xilinx 7-Series FPGAs The Unpatchable Silicon: A Full Break of the Bitstream Encryption of Xilinx 7-Series FPGAs</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The security of FPGAs is a crucial topic, as any vulnerability within the hardware can have severe consequences, if they are used in a secure design. Since FPGA designs are encoded in a bitstream, securing the bitstream is of the utmost importance. Adversaries have many motivations to recover and manipulate the bitstream, including design cloning, IP theft, manipulation of the design, or design subversions e.g., through hardware Trojans. Given that FPGAs are often part of cyber-physical systems e.g., in aviation, medical, or industrial devices, this can even lead to physical harm. Consequently, vendors have introduced bitstream encryption, offering authenticity and confidentiality. Even though attacks against bitstream encryption have been proposed in the past, e.g., side-channel analysis and probing, these attacks require sophisticated equipment and considerable technical expertise. In this paper, we introduce novel low-cost attacks against the Xilinx 7-Series (and Virtex-6) bitstream encryption, resulting in the total loss of authenticity and confidentiality. We exploit a design flaw which piecewise leaks the decrypted bit-stream. In the attack, the FPGA is used as a decryption oracle, while only access to a configuration interface is needed. The attack does not require any sophisticated tools and, depending on the target system, can potentially be launched remotely. In addition to the attacks, we discuss several countermeasures.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Nowadays, Field Programmable Gate Arrays (FPGAs) are common in consumer electronic devices, aerospace, financial computing, and military applications. Additionally, given the trend towards a connected world, data-driven practices, and artificial intelligence, FPGAs play a significant role as hardware platforms deployed in the cloud and in end devices. Hence, trust in the underlying platform for all these applications is vital. Altera, who are (together with Xilinx) the FPGA market leader, was acquired by Intel in 2015.</p><p>FPGAs are reprogrammable ICs, containing a repetitive logic area with a few hundred up to millions of reprogrammable gates. The bitstream configures this logic area; in analogy to software, the bitstream can be considered the 'binary code' of the FPGA. On SRAM-based FPGAs, which are the dominant type of FPGA in use today, the bitstream is stored on an external non-volatile memory and loaded into the FPGA during power-up.</p><p>In order to protect the bitstream against malicious actors, its confidentiality and authenticity must be assured. If an attacker has access to the bitstream and breaks its confidentiality, he can reverse-engineer the design, clone intellectual property, or gather information for subsequent attacks e.g., by finding cryptographic keys or other design aspects of a system. If the adversary succeeds in violating the bitstream authenticity, he can then change the functionality, implant hardware Trojans, or even physically destroy the system in which the FPGA is embedded by using configuration outside the specifications. These problems are particularly relevant since access to bitstream is often effortlessly possible due to the fact that, for the vast majority of devices, it resides in the in external non-volatile memory, e.g., flash chips. This memory can often either be read out directly, or the adversary wiretaps the FPGA's configuration bus during power-up. Alternatively, a microcontroller can be used to configure the FPGA, and consequently, the microcontroller's firmware includes the bitstream. When the adversary gains access to the microcontroller, he also gains access to the configuration interface and the bitstream. Thus, if the microcontroller is connected to a network, remotely attacking the FPGA becomes possible.</p><p>In order to protect the design, the major FPGA vendors introduced bitstream encryption around the turn of the millennium, a technique which nowadays is available in most mainstream devices <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b54">56]</ref>. In this paper, we investigate the security of the Xilinx 7-Series and Virtex-6 bitstream encryption. On these devices, the bitstream encryption provides authenticity by using an SHA-256 based HMAC and also provides confidentiality by using CBC-AES-256 for encryption. By our attack, we can circumvent the bitstream encryption and decrypt an assumedly secure bitstream on all Xilinx 7-Series devices completely and on the Virtex-6 devices partially. Ad-ditionally, we are also able to manipulate the bitstream by adjusting the HMAC. Out attack setting in general is the same one as commonly encountered in mainstream practice: The adversary only needs access to the configuration interface of a fielded FPGA. In this setting, the secret decryption key has already been loaded into the FPGA, e.g., after device manufacturing, the key is stored in internal battery-backed RAM (BBRAM) or eFUSEs. As will be shown later, the adversary uses the FPGA with the stored key as an oracle to decrypt the bitstream.</p><p>According to recent business reports, Xilinx shares 50% of the FPGA market <ref type="bibr">[16]</ref>. Also evident by Xilinx's annual report in 2018 <ref type="bibr" target="#b53">[55]</ref>, around 35% of their current revenue originates from the 7-Series (meanwhile, Virtex-6 devices are not stated independently in this report, but are veiled in the 50% revenue of all old generations). Thus, the 7-Series and Virtex-6 devices are a popular choice for a variety of FPGA designs, many of which are mission-or safety-critical. Besides, we note that similar to many other digital hardware devices, FPGAs have a lifespan of decades. Replacing legacy systems or using high-performance products therefore might turn out to be a costly and cumbersome undertaking. However, Xilinx's new UltraScale and UltraScale+ devices, which are the new (highend) series and slowly replace the old ones, are not affected by our attack.</p><p>In this paper, we introduce two novel attacks against this Xilinx 7-Series bitstream encryption, which result in a total loss of authenticity and confidentiality. Furthermore, we discuss the implications of these attacks and suggest potential countermeasures. While our attacks chiefly target the Xilinx 7-Series, Virtex-6 devices are also vulnerable to our attack with the limitation that the first two bits of every 32-bit word are missing in the recovery process.</p><p>We communicated our findings to Xilinx in a vulnerability disclosure on 24 September 2019 and started cooperating on the issue: Xilinx quickly confirmed the vulnerability on 25 September and that there is no patch possible without changing the silicon. Coinciding with the publication of this paper, Xilinx plans to publish a design advisory that informs their customers of this vulnerability.</p><p>The paper is structured as follows: First, we give an executive summary of the attack. Then, we introduce the necessary background and related work in Section 2. In Section 3, we introduce the attack with all details, whereupon we validate the attack by a case study in Section 4. A discussion about the findings and countermeasures is given in Section 5. We conclude the paper in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">The Attack at a Glance</head><p>A small configuration engine loads the bitstream into the FPGA and continuously reflects the FPGA's state in status registers. If the bitstream encryption is activated, the configuration engine prohibits the readout of a bitstream. Usually, if the bitstream encryption is disabled, this readout function is legitimately used for debugging the FPGA and its design.</p><p>In our attack, we manipulate the encrypted bitstream to redirect its (decrypted) content from the fabric to a configuration register. We then read out this configuration register, which holds the unencrypted bitstream data; the readout of the configuration register is not prevented even in the presence of an encrypted bitstream anyway.</p><p>For that purpose, we use the MultiBoot address register WBSTAR. This MultiBoot feature enables the FPGA to boot from a different memory address in order to update the FPGA safely, boot with different functionality or boot from a fallback bitstream with a working design. The MultiBoot feature uses the content of the WBSTAR register as the boot address in the attached non-volatile memory. Hence, the register is not cleared during a reset. We now manipulate the encrypted bitstream to write a single 32-bit word which is part of the encrypted bitstream to the WBSTAR register in decrypted form. The bitstream's manipulation exploits the malleability of the CBC mode of operation to alter the command in the bitstream which writes data to the WBSTAR configuration register. After the configuration with the encrypted bitstream, the FPGA resets, since it detects an invalid HMAC. We use the WBSTAR configuration register for the readout, because the reset procedure does not clear it. After the reset, we finally use a second bitstream to readout the WBSTAR register to uncover the decrypted bitstream word by word. In summary, the FPGA, if loaded with the encryption key, decrypts the encrypted bitstream and writes it for the attacker to the readable configuration register. Hence, the FPGA is used as a decryption oracle. The fact that only single 32-bit words can be uncovered in each iteration determines the duration of decrypting a whole bitstream: In our experiments, we are able to uncover a complete Kintex-7 XC7K160T bitstream in 3 hours and 42 minutes, for instance.</p><p>For the second attack, we can break the authenticity of the bitstream encryption. The attacker can use the decryption oracle to encrypt arbitrary messages due to the underlying CBC mode. They can build the CBC chain starting with the last block. For that, they encrypt a random message, uses the CBC malleability, and calculates the ciphertext block to turn the plaintext into the intended value. The attacker repeats this process until the whole bitstream is encrypted. Since the HMAC key is stored in the encrypted bitstream and is not verified, the attacker can manipulate the HMAC tag as well. Thus, the attacker can craft legitimate encrypted bitstreams, which are correctly validated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>In this section, we introduce the background on FPGAs, give an overview of attacks already mounted on bitstream encryption schemes, and lastly, introduce the bitstream format of the Xilinx 7-Series.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">FPGAs</head><p>Field Programmable Gate Arrays are reconfigurable devices. They consist, in essence, of an array of configurable logic cells, also known as fabric. The main elements of the fabric are small configurable logic cells, flip-flops, and a configurable routing. Only if the user programs the FPGA, it contains the functional logic of the design. The most significant advantage of FPGAs over ASICSs is their reprogrammability, i.e., the ability to configure an FPGA arbitrarily.</p><p>All configuration information is contained in the bitstream, which specifies all details of the digital design. In SRAMbased FPGAs, it has to be stored on an external non-volatile memory chip. For programming the bitstream, the FPGA has different interfaces, e.g., SelectMAP, JTAG, ICAP2, Serial, or SPI/BPI. The difference between these interfaces are mostly their protocol, bus width, and direction of programming, i.e., the SPI interface independently reads from non-volatile memory, while the SelectMAP or JTAG can be triggered from another device and the ICAP2 is an internal port inside the fabric. Additionally, the SelectMAP, JTAG, and ICAP2 interfaces have a back-channel, i.e., they can read out debug information from the FPGA. This readout enables the user to download the configured design, e.g., extract the bitstream from the FPGA and check if anything was configured correctly or use the flip-flop content for advanced design debugging. Similarly, the user can read out the configuration and status registers from the FPGA.</p><p>The bitstream encryption feature protects the bitstream by providing confidentiality and authenticity. The encryption key is stored in either a BBRAM or eFUSEs and is programmed via JTAG only. When the bitstream encryption is enabled, the readout of the bitstream described above is blocked on all external ports. Otherwise, an attacker would be able to read out the decrypted design information. Hence, a readout from the external ports returns null values when the bitstream encryption is used. Only via the internal ICAP2 interface, it is possible to read out the encrypted bitstream. However, the ICAP2 interface is usually not connected to the outside world or should be protected. An additional security mechanism is that the entire FPGA must be reset to load a new design when the bitstream encryption has been enabled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Bitstream-Based Attacks</head><p>The consequence of our attack is the total loss of the bitstream's authenticity and confidentiality. Even when losing one of them, attacks against the system become possible <ref type="bibr" target="#b51">[53]</ref>. A recent example is the Thrangrycat attack of Kataria et al., which targets the FPGA-based root of trust in Cisco routers <ref type="bibr" target="#b21">[23]</ref>. In this section, we elaborate the following attacks and their implications: cloning, reverse engineering, tampering, spoofing, and physically harming of FPGAs and their design. Besides that, the general security of FPGAs is a well-studied topic in the literature <ref type="bibr" target="#b15">[17,</ref><ref type="bibr" target="#b26">28,</ref><ref type="bibr" target="#b27">29,</ref><ref type="bibr" target="#b43">45,</ref><ref type="bibr" target="#b44">46,</ref><ref type="bibr" target="#b51">53]</ref>, which will be discussed mainly in the next chapter.</p><p>Without bitstream confidentiality, the design can easily be cloned and counterfeit products can be built. Thus, overproduction is considered a considerably higher threat in the case of FPGAs compared to ASIC-based products. A bitstream without confidentiality also allows that the design can be reverse engineered to gain knowledge about the Intellectual Property (IP) used, mount attacks on the application, or prepare the injection of hardware Trojans. Hardware Trojans and other manipulation attacks are based on tampering with the bitstream. Thus, an adversary has also to circumvent the bitstream's authenticity. We note that manipulations allow the attacker also to circumvent other security mechanisms in the design or leak data within the design, e.g., cryptographic keys. Moreover, an attacker might be able to physically destroy the system in which it is embedded by changing parameters, akin to the Stuxnet attack (which was allegedly software-based, however) <ref type="bibr" target="#b23">[25]</ref>.</p><p>When spoofing the bitstream, the attacker replaces the bitstream rather than changing the already existing one, i.e., the attacker creates his own bitstream. Thus, no reverse engineering of the existing bitstream is needed.</p><p>Another bitstream-based attack vector is to physically destroy the FPGA by configuration outside the specifications, i.e., by implementing short circuits on the FPGA. Physical harming the FPGA through its fabric might not be necessary for an attacker with access to the hardware, as they can anyhow destroy it. However, an attacker with only remote access to the bitstream will be capable of physically harming the inside of the FPGA. Such physical attacks can be viewed as severe denial of service attacks.</p><p>Thus, almost all vendors realized means to secure the bitstream of an FPGA. First, they block the readback of the bitstream from debugging interfaces. Second, they have developed bitstream encryption schemes. The bitstream encryption should provide authenticity and confidentiality, as the confidentiality protects the bitstream against cloning, reverse engineering, and tampering <ref type="bibr" target="#b51">[53]</ref>, while the authenticity is needed to avoid loading an untrusted bitstream and prevent tampering, spoofing, and physical harm attacks. As otherwise, the attacker could run a modified bitstream on the device. Thus, the authenticity of the bitstream is as essential as its confidentiality <ref type="bibr" target="#b7">[8]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Related Works</head><p>Several attacks against bitstream encryption have been proposed in the literature. In 2012, Skorobogatov and Woods found a bug (which might be a backdoor) to circumvent the bitstream encryption of an Actel/Microsemi ProA-SIC3 A3P250 FPGA <ref type="bibr" target="#b44">[46]</ref>. They found a bug in the JTAG instruction set to read out the bitstream even when the bitstream encryption is enabled.</p><p>Already in 2011, Moradi et al. attacked the Xilinx bit-stream encryption with power side-channel attacks <ref type="bibr" target="#b27">[29]</ref>. Subsequently, in 2014, Altera FPGAs have been targeted using side-channels <ref type="bibr" target="#b47">[49]</ref> as well. After measuring the power consumption of the device, the attacker uses statistical methods and a power-model of the cipher to compute the key. Often GPUs are used to compute the key from an ample search space in a reasonable time frame. Furthermore, the PCB hosting the FPGA often needs to be modified to allow monitoring the power side-channel. This requirement is relaxed by measuring the electro-magnetic side channel instead of the power side channel <ref type="bibr" target="#b28">[30]</ref> but comes at an increase in the measurement cost and complexity. For example, Moradi et al. used an oscilloscope at a sampling rate of 5 GS/s and bandwidth of 1.5 GHz to capture EM signals. Since its introduction, these side-channel attacks have become a general thread to bitstream encryption schemes, which led to improved countermeasures in recent FPGA series. Nevertheless, the general knowledge on side-channel attacks has improved during the last decades, and the number of companies and research institutes active in the field has grown. Although this increases the feasibility of such attacks, the adversary requires a minimum set of equipment to be able to measure side-channel leakages with adequate quality. Tajik et al. introduced an attack using optical contactless probing in 2017 <ref type="bibr" target="#b49">[51]</ref>. In a nutshell, a near-infrared light source is focused on the backside of the silicon, i.e., directly on the transistors. The hereby used near-infrared light source is transparent to the substrate. Thus, it directly reaches the transistors. The transistors then reflect the emitted light depending on their load. Consequently, a detector can distinguish between a transistor in an opened or closed state. The authors used this technique to attack the bitstream encryption of a Xilinx Kintex-7 FPGA successfully. They observed the bitstream configuration engine and identified the bus transmitting the plaintext bits after the encryption. Hence, they used the FPGA as an oracle, as well. Nevertheless, this attack requires expensive electro-optical probing equipment.</p><p>Similarly, thermal laser stimulation attacks <ref type="bibr" target="#b26">[28]</ref> uses laser beams to introduce localized heating, which changes the used current. The current changes can then be linked to the stored key in the BBRAM to extract the encryption key.</p><p>Lately, security researchers at F-Secure points out two design flaws in the encrypt-only boot mode of Zynq UltraScale+ MPSoC devices <ref type="bibr" target="#b10">[11]</ref>, which compromise the processing unit (ARM core) in the SoC design. The researchers shows that the header of the first stage boot loader is not checked, which encodes the boot start address of the processing unit (ARM core). Changing the address can lead to arbitrary code execution using a return-oriented programming attack. Nevertheless, the attack is mountable in the encrypt only boot mode solely. Hence, it can be mitigated, as recommended by Xilinx before, by using system level protections or the Hardware Root of Trust boot mode, which uses RSA signatures to authenticate the boot header. In summary, the known attacks to the Xilinx bitstream encryption on 7-Series devices are all physical in nature (sidechannel analysis, optical contactless probing), and are mostly costly in terms of equipment, time, and technical expertise. Plus, they need physical access to the FPGA. In contrast, our attack requires only access to a JTAG or SelectMAP interface, which is often available through the debugging nature of the JTAG interface or may be even available via a remote channel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Bitstream Format</head><p>The Xilinx 7-Series bitstream format contains a header and the configuration for the fabric. While most of the header is documented in <ref type="bibr" target="#b54">[56]</ref>, the fabric configuration is not made public by the vendor. However, several papers show strategies to document the bitstream format <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b29">[31]</ref><ref type="bibr" target="#b30">[32]</ref><ref type="bibr" target="#b31">[33]</ref><ref type="bibr" target="#b48">50]</ref>, as the fabric configuration data is the netlist, in a different format, of the loaded design. Hence, the fabric data format is essential for reverse engineering of the design, to find Trojan horses, to build open-source tool-chains, or to formally verify the bitstream coming from the vendors' tools. <ref type="figure" target="#fig_0">Figure 1</ref> shows an overview of the 7-Series encrypted bitstream structure. Later in <ref type="figure">Figure 2</ref>, we discuss the bitstream format in detail. The bitstream starts with a SYNC word, which is followed by a configuration header. In the header, the CBC IV is configured and the length of the following encrypted part is given. After the header, the encrypted part follows, which is shaded in <ref type="figure" target="#fig_0">Figure 1</ref>. First, in the HMAC header, the HMAC key (ipad) is set, which immediately starts the HMAC calculation. Then, a secondary header configures the remaining settings. A large blob is followed to configure the fabric. A footer concludes the configuration, which is also used for alignment. The encrypted part ends with the HMAC footer, which contains the HMAC opad, and the HMAC tag, with which the encrypted part can be validated. A global footer concludes the bitstream as well as starting the FPGA's fabric.</p><p>In detail, the bitstream of 7-Series devices is organized in packages of 32-bit words. There are two types of packages, while the type 1 package is displayed in <ref type="table" target="#tab_3">Table 1</ref>. Type 1 packages contain an opcode (nop, read, write), a register address, and the word count of the read or written data. If a package writes any content to a register, the data (in multiples of 32-bit words) is attached directly after the package. The type 2 package is an extension of the type 1 with a larger address field to write a large amount of data, e.g., the fabric data.</p><p>There are 20 documented registers, which organize the configuration of the FPGA. For example, there is a CRC register verifying the checksum of the bitstream or multiple status registers to monitor the boot process. The interested reader is referred to the documentation of the bitstream header format <ref type="bibr" target="#b54">[56]</ref>.</p><p>In more detail, <ref type="figure">Figure 2</ref> shows the structure of an encrypted bitstream. The configuration logic ignores the beginning of the bitstream until the sync word 0xAA995566 is transmitted. The following unencrypted header configures only the decryption engine, i.e., turns it on and sets the CBC IV. With writing the length of the encrypted part in the configuration register 1 , the bitstream encryption engine is turned on, and only encrypted data follows. Note that we show all bytes in the encrypted part in plaintext as the FPGA configuration logic would see it after the decryption. However, the attacker would observe arbitrary encrypted data only. The first 4 AES blocks, i.e., 4 × 128 bits = 512 bits, correspond to the HMAC header. It includes the HMAC key xored with the ipad (256-bits) and the ipad value itself <ref type="bibr" target="#b38">[40]</ref>. Following the HMAC header, the already started configuration header is completed by issuing commands to prepare the configuration engine, e.g., the WBSTAR register is configured. The word following the command to write to the WBSTAR register is the content written to the register, i.e., 0x00000000. The configuration header completes with a command to write the fabric's data, which follows afterwards and is the longest part of the bitstream.</p><p>At the end of the encrypted part, the (configuration) footer and the HMAC footer is attached. The configuration footer can contain commands to configure the engine and an uninterpreted part, which is used to align the plaintext to a multiple of 512-bits since the HMAC operates on multiples of 512-bits. The HMAC footer contains the HMAC's key XORed with the opad, the opad itself, and the HMAC tag. The HMAC authenticates all encrypted content since the HMAC computation starts directly after the first HMAC header and ends right before the HMAC footer. Since the configuration engine processes all HMAC related calculations on the decrypted bitstream, the MAC-then-encrypt scheme is used. Lastly, the general footer (in plain) ends the whole bitstream. Since we can ignore it for the attack, it is not shown in <ref type="figure">Figure 2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Adversary Model</head><p>Generally, the adversary can be anyone who has access to the JTAG or SelectMAP configuration interface, even remotely, and to the encrypted bitstream of the device under attack. In contrast to side-channel and probing attacks against bitstream encryption, no adequate equipment nor expertise in electronic measurements is needed. The requirements for our adversary model are as follows:</p><p>Configuration Interfaces The attacker needs to have access to the SelectMAP or JTAG interface which allows a debug readout as well as the configuration of encrypted bitstreams. For example, the attacker can gain access to a configuration interface locally, if they have physical access. Note that only the JTAG interface can be used to load the AES key. Thus, a JTAG interface must be present on the PCB, if the BBRAM key storage is used. If the BBRAM is not used, the eFUSEs can be burned during provisioning on a different PCB, then used on the production PCB. Hence, the JTAG interface might not be present on the production PCB, if eFUSEs are used, so that another configuration interface is used, like SelectMAP.</p><p>A microcontroller is often used in addition to the FPGA and configures it. Thus, the attack can be conducted from the connected microcontroller, if it is connected to the FPGA's SelectMAP or JTAG interface. It is even possible to conduct the attack remotely if the microcontroller is connected to a network, and because of that the adversary can gain access to the microcontroller via the remote channel, e.g., by installing a rootkit, as demonstrated by the latest Thrangrycat attack on Cisco routers <ref type="bibr" target="#b22">[24]</ref>.</p><p>Bitstream Access The adversary also needs to have access to the attacked encrypted bitstream, which they can through several methods. In the case of physical access, they can wiretap the configuration bus during power-up or directly read out the non-volatile memory in which the encrypted bitstream is stored. Without physical access, however, they can extract it from the (microcontroller) firmware which configures the FPGA or download the firmware from a remote update service e.g., via a website.</p><p>Access Level A remote attack is possible only if the attacker has remote access to a configuration interface and the encrypted bitstream.</p><p>A local attack is possible otherwise, e.g., if the attacker has local access to a configuration interface and can obtain the encrypted bitstream. HMAC header</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX</head><formula xml:id="formula_0">                             0x30022001 0x00000000 0x30020001</formula><p>write WBSTAR 0x00000000 WBSTAR content 0x30008001 0x00000000 0x20000000 NOP 0x30008001</p><p>. . . HMAC footer  Key Loaded The AES key must already be loaded onto the FPGA, which is always the case for a system already in use and may be the case after the provisioning by the system manufacturer.</p><formula xml:id="formula_1">encrypted configuration header                h h h h . . . .</formula><formula xml:id="formula_2">                                                                                                                                                                                                                                  encrypted</formula><p>Known-plaintext The attacker needs only limited knowledge about the plaintext of the encrypted bitstream. Specifically, they need to know about a single 32-bit word in the encrypted bitstream header, since a single word is altered in the attack only. The bitstream generation in Vivado is deterministic, i.e., the commands in the encrypted header are the same among different bitstreams and change only in their configuration content. Thus, the adversary can predict the plaintext in the encrypted header, e.g., they know the position of the write WBSTAR command. Note that any other command can be used as long as the attacker knows the plaintext. If a defender would change the encrypted bitstream header, e.g., randomize it, an attacker can make assumptions, as there is a limited set of valid packages e.g., package construction <ref type="table" target="#tab_3">(Table 1)</ref>, valid commands, and meaningful content. Therefore, the attacker could brute-force the encrypted bitstream to gain knowledge over the plaintext; however, only a single package in the header needs to be brute-forced for this attack, so it would become more difficult, but not infeasible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Used Devices</head><p>The design under attack is any Xilinx 7-Series device or a Vertix-6 device with slight limitations (see Section 4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">CBC Malleability</head><p>Xilinx uses the Cipher Block Chaining (CBC) mode with AES as the underlying cipher for bitstream encryption. Hence, the blocks are 128 bits wide. In CBC mode, each ciphertext block C i is XORed with the next plaintext block P i+1 prior to encryption. An advantage of the CBC mode is that it encrypts probabilistically if a nonce is used as an initialization vector (IV), which is a desirable security feature. However, the CBC mode is also malleable during decryption: Flipping a bit in the ciphertext creates a random plaintext in the same block, but, as the ciphertext is XORed with the next plaintext block, bits at the same position in the next plaintext block are flipped accordingly. <ref type="figure">Figure 3</ref> illustrates this malleability, using AES as the underlying cipher, where k is the key of the cipher, C i is a ciphertext block (128 bits), P i the plaintext block (128 bits), and IV the initialization vector of 128 bits. Hence, XORing a ∆ to the ciphertext C 1 leads to a random P 1 instead of the correct plaintext P 1 . The plaintext in the next block P 2 is XORed with the ∆ as well: P 2 ⊕ ∆. So by changing C i , the attacker can flip arbitrary bits in P i+1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Attack 1: Breaking Confidentiality</head><p>The attack is essentially mounted in five steps:</p><p>1. Create a malicious bitstream and a readout bitstream 2. Configure the FPGA with the malicious bitstream 3. Reset the FPGA (automatically) 4. Read out the WBSTAR register using the readout bitstream 5. Reset the FPGA (manually) Using these five steps, the attacker can decrypt one word (32-bit) of the encrypted bitstream. They can repeat these five steps for every word of the encrypted bitstream in order to recover it entirely.</p><p>The malicious bitstream created in Step 1 is shown in <ref type="figure" target="#fig_1">Fig- ure 4</ref>, while a circled number corresponds to the block next to it; h 0 for instance corresponds to the last HMAC header block. After the HMAC header, the previously initiated configuration header is completed as well, so boot configurations are written to the FPGA. In the first block h 1 (the last two words) already, the command (0x30020001) writes one word to the WBSTAR register. In a default configuration, the content written to this register is zero, but it is irrelevant for the attack. In more detail, the first bits of the command 0x3 issues a type 1 package with a write operation, while the 0x020 points to the WBSTAR register. The 0x01 at the end states the written length in words, here a single word. Thus, the following word, 0x00000000, is written to the WBSTAR register. The bitstream generation in Vivado is deterministic, meaning that the commands in the encrypted header are the same among different bitstreams and change only in their configuration content, i.e., the words after the commands. Thus, the adversary can assume the plaintext in the encrypted header, so they can, for instance, know the position of the write WBSTAR command. We here chose the WBSTAR command, because it is the last command in the first block after the HMAC header, but any other command in the first block could be chosen.</p><p>During a reset, the whole fabric and the configuration registers are set to their default values (mostly zero), but crucially, the WBSTAR (warm boot start address) and BOOTSTS (boot status) registers are not reset. These registers are used for the MultiBoot and fallback feature, which enables the FPGA to boot from a different SPI/BPI memory address to safely update the FPGA or boot designs with different functionality. This MultiBoot feature uses the content of the WBSTAR reg-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association</head><p>29th USENIX Security Symposium 1809  ister as the boot address for the attached non-volatile memory. Hence, the WBSTAR register cannot be cleared during a reset, as its address might be needed for the boot process. The attack is also based on the fact that when writing more than one word to a single word register, only the last written word is stored in that register. For example, if the bitstream in <ref type="figure">Figure 2</ref> is changed such that the length of the WBSTAR write operation is 4 (not 1), then the four words after the command would be written to the WBSTAR register, but only the last word is finally stored there, i.e., the NOP command 0x20000000. The number of written words can even extend further, so that configuration data from the fabric, which comes later in the bitstream, is written to the WBSTAR register. Now the attacker can change this length field in the encrypted bitstream by adding a ∆ to the corresponding word of the write WBSTAR instruction of the former block h 0 , thereby exploiting the CBC malleability. Consequently, the manipulated block (the HMAC header) becomes random data (marked with X in <ref type="figure" target="#fig_1">Figure 4</ref>). However, this change is irrelevant for the bitstream, as the other changes will result in a faulty HMAC validation anyway and the bitstream is still valid for the configuration logic, since only the HMAC ipad is changed.</p><formula xml:id="formula_3">DEC P 0 k C 0 DEC P i k C 1 ⊕ ∆ DEC P 2 ⊕ ∆ k C 2 IV · · · · · · DEC P n k C n · · · · · · DEC P n k C n FIGURE 3:</formula><formula xml:id="formula_4">                                                                                         encrypted part shown in plaintext</formula><p>The length of the encrypted data, without the HMAC header and footer, must be a multiple of 512 bits as the SHA-2 operates on 512-bit chunks <ref type="bibr" target="#b27">[29]</ref>. Hence, the encrypted data must be at least four AES blocks long, so we set the length of the write WBSTAR operation to 0xD = 13 (∆ = 0xC), i.e., all data until the end of the, first and only, 512-bit chunk of encrypted data are written to the WBSTAR register. At this position, i.e., at the end of the 512-bit chunk, we place the "to be decrypted" block h 4 . This block can be any AES block from the encrypted bitstream, which includes the encrypted fabric data. Since the bitstream encryption uses the CBC mode, the former block before h 3 must be the block from the CBC chain, i.e., it is the IV for the decrypted block. An additional block h 2 is needed to fill the 512-bit chunk (which can be random). It is placed between the block of the WBSTAR write operation and the two decryption blocks. Note that this random block h 2 and the IV block h 3 are decrypted to random data. Since the WBSTAR write operation writes 13 words, all random data is interpreted as data which are stored in the WBSTAR register, but only the desired decrypted word is stored in the WBSTAR register.</p><p>To readout the other words in the last blocks h 4 , the ∆ should be changed accordingly, i.e., the write length is set to 10, 11, or 12. However, the configuration logic will interpret the last (next to last, ...) words as a standard package, which might be data from the fabric. Thus, they are not correct instructions, and they might cause unwanted random commands. Hence, a second ∆ is added to the IV block to change the 13th (and 12th, 11th) word to a NOP command, which is possible as the attacker first decrypts the last block and uses the CBC malleability again. This prevents the configuration logic from falsely interpreting the last words.</p><p>Next, in Step 2, the FPGA is configured with the malicious bitstream. Due to the changes made to the bitstream before, the HMAC is invalid. The configuration logic correctly detects this and resets the FPGA in Step 3 automatically. Nevertheless, the HMAC is only checked at the end. Thus, the WBSTAR register has already been written before the check failed.</p><p>In Step 4, a (not encrypted) readout bitstream is sent to the FPGA to obtain the content of the WBSTAR register. This bitstream is not encrypted as no interaction with the fabric is made. It reveals the one word written to the register. The full readout bitstream can be obtained from Appendix A.</p><p>Lastly, in</p><p>Step 5, the FPGA is reset manually to repeat the steps. Otherwise, multiple readouts would fail. On the JTAG interface, the JPROGRAM command is sent, and on the SelectMAP interface, the PROGRAM_B pin is pulsed low to issue the reset. This clears the fabric memory and is sufficient to reset the configuration logic as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Attack 2: Breaking Authenticity</head><p>With the first attack, the FPGA can be used to decrypt arbitrary blocks. Hence, it can also be seen as a decryption oracle. Thus, we can also use this oracle to encrypt a bitstream, as shown by <ref type="bibr">Rizzo and Duong in [41]</ref>, and generate a valid HMAC tag. Let dec KAES (·) be the decryption function of the target FPGA configured with the AES key KAES, C i a ciphertext block, and P i the corresponding plaintext block following the underlying CBC mode. Therefore, it holds (CBC function),</p><formula xml:id="formula_5">P i = dec KAES (C i ) ⊕C i−1 .<label>(1)</label></formula><p>Suppose, C i and C i−1 are arbitrarily selected. We can use the FPGA as the decryption oracle and find out P i , with using the introduced attack in Section 3.3, The goal is to find C i , which generates the desired P i inside the FPGA. To this end, we just need to set (CBC malleability)</p><formula xml:id="formula_6">C i−1 = P i ⊕C i−1 ⊕ P i .<label>(2)</label></formula><p>For the previous block P i−1 we can find (for an arbitrary selected C i−2 ),</p><formula xml:id="formula_7">P i−1 = dec KAES (C i−1 ) ⊕C i−2<label>(3)</label></formula><p>while using the FPGA as the decryption oracle again. Similarly, we can set</p><formula xml:id="formula_8">C i−2 = P i−1 ⊕C i−2 ⊕ P i−1<label>(4)</label></formula><p>which leads to generate the desired plaintext block P i−1 . This process is repeated toward the first block P 1 , and the IV is set to C 0 in the unencrypted header. Therefore the attacker can encrypt an arbitrary bitstream by means of the FPGA as a decryption oracle. The valid HMAC tag can also be created by the attacker, as the HMAC key is part of the encrypted bitstream. Hence, the attacker can set his own HMAC key inside the encrypted bitstream and calculate the corresponding valid tag. Thus, the attacker is capable of creating a valid encrypted bitstream, meaning the authenticity of the bitstream is broken as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Wrap-Up: What Went Wrong?</head><p>These two attacks show again that nowadays, cryptographic primitives hold their security assumptions, but their embedding in a real-world protocol is often a pitfall. Two issues lead to the success of our attacks: First, the decrypted data are interpreted by the configuration logic before the HMAC validates them. Generally, a malicious bitstream crafted by the attacker is checked at the end of the bitstream, which would prevent an altered bitstream content from running on the fabric. Nevertheless, the attack runs only inside the configuration logic, where the command execution is not secured by the HMAC.</p><p>Second, the HMAC key K HMAC is stored inside the encrypted bitstream. Hence, an attacker who can circumvent the encryption mechanism can read K HMAC and thus calculate the HMAC tag for a modified bitstream. Further, they can change K HMAC , as the security of the key depends solely on the confidentiality of the bitstream. The HMAC key is not secured by other means. Therefore, an attacker who can circumvent the encryption mechanism can also bypass the HMAC validation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Case Studies</head><p>We conducted several experiments to validated the attacks. We tested the attacks on the Xilinx Kintex-7 (XC7K160T), mounted on a SAKURA-X Board <ref type="bibr" target="#b41">[43]</ref>, on a Xilinx Artix-7 (XC7A35T), mounted on a Basys3 board <ref type="bibr" target="#b5">[6]</ref>, and on a Xilinx Virtex-6 (XC6VLX240T), mounted on the ML605 evaluation kit. Since the Xilinx user guid <ref type="bibr" target="#b54">[56]</ref> states no difference between the 7-Series configurations engines, we conclude that our attack is applicable to all 7-Series devices. We first attacked the SelectMAP interface on the Kintex-7. For this, we implemented a controller on the Spartan-6 FPGA, which is mounted aside the Kintex-7 on the SAKURA-X board. The Spartan-6 can configure the Kintex-7 via the SelectMAP interface. The controller on the Spartan-6 and a controlling computer are connected via UART. The computer sends the bitstream to the controller, where it is saved in a BRAM and is transmitted to the Kintex-7 under attack.</p><p>After the first successful attack, we also implemented the attack on the Basys3 board. Here, we used the opensource xc3sprog <ref type="bibr" target="#b40">[42]</ref> to configure the Artix-7 via the onboard USB programmer. In order to validate that an adversary can use the JTAG interface, we implemented the attack for the JTAG interface with a SEGGER J-Link EDU <ref type="bibr" target="#b42">[44]</ref>. We used OpenOCD <ref type="bibr" target="#b33">[35]</ref> to utilize the J-Link and used the scripting engine of OpenOCD to pass the individual bitstream's bytes  to the JTAG interface. Since there is a lot of static data, i.e., only two fabric blocks change per 32-bit readout, and the USB interface to the J-Link is slow, we implemented the attack on a microcontroller. We used the STM32F407G-DISC1 discovery kit <ref type="bibr" target="#b45">[47]</ref> equipped with an STM32 microcontroller. It emulates a JTAG controller and is connected via a UART to a controlling PC. The microcontroller retrieves the encrypted header only once, while it gets large chunks of the bitstream and sends it to the FPGA. It individually adds ∆ to the encrypted header to increase the performance as no roundtrip from and to the PC is needed. The microcontroller itself generates the JTAG clock. Inbetween the JTAG clock tick, a single bit is put on an I/O pin. Thus, there are multiple instructions on the microcontroller to transmit a single bit, i.e., at least set a data bit, reset the clock pin, set the clock pin. Hence, there might be performance improvement possible. Note that every readout needs two small bitstreams to be loaded. First, the malicious bitstream to write the WBSTAR register is transmitted. This bitstream is 211 words long. Second, the readout bitstream is sent to the FPGA, which is 22 words long. Additionally, the FPGA resets two times. Using the implementation of the microcontroller over the JTAG interface, a readout of a single 32-bit word is done in 7.9 milliseconds. Since the XC7K160T's bitstream has a size of 53,540,576 bits, the readout of the bitstream completes in 3 hours and 42 minutes. Even with the largest 7K480T with a bitstream size of 149,880,032 bits, the attack can run in approximately 10 hours. In <ref type="table" target="#tab_6">Table 2</ref>, we selected some FPGAs as examples and provided estimated runtimes of the attack. Note that the attack can also be parallelized if two FPGAs with the same bitstream are available, which can be the case, e.g., if one global key is used for bitstream encryption within a given product. Even though less desirable from a security point of view, using a global key, is without doubt, a tempting option in many real-world situations as it dramatically simplifies key management.</p><p>Running the second attack on the authentication of the bit-stream requires the same amount of time as the first attack. Because within the second attack the whole bitstream is encrypted. We can even speed up the second attack when only parts of the bitstream need to be altered, e.g., when the attacker wants to introduce a hardware Trojan and only changes to a small fraction of the design are required. We also note that no design can fully utilize the entire FPGA. Consequently, there are blocks of the bitstream that are unused by the design. If now an attacker re-encrypts the changed blocks of the design, until they reach an unused block, they can stop the re-encryption and utilize this unused block as the IV for the next regular block (CBC malleability). Consequently, the unused block will be decrypted to random data. However, since its content is not necessary for the design, it can be ignored. Thus the attacker only needs to re-encrypt a part of the bitstream rather than the whole bitstream, which speeds up the encryption process. Furthermore, we evaluated old FPGA series. The configuration logic on Virtex-6 devices is mostly identical with the 7-Series' configuration logic. Hence, we also mount our attack on the XC6VLX240T, using xc3sprog with the USB JTAG port present on the ML605 development board. The single shortcoming of the attack is the limitation of the WB-STAR register. The start address, present in the WBSTAR, is shortened by 3-bit compared to the 7-Series. Hence, the upper 3 bits are marked as reserved. But only the two leftmost bits are not implemented, i.e., writing any arbitrary value to those 2 bits will always return zero. Therefore, every upper 2 bits of all words in the bitstream cannot be read out, which leads to an imperfect recovered netlist. Imperfect netlists are an already known obstacle in the reverse-engineering community and can be tackled to a certain degree <ref type="bibr" target="#b9">[10]</ref>. Moreover, the encoding of the PIPs in the bitstream and a meaningful routing of nets can help to repair the recovered netlist <ref type="bibr" target="#b8">[9]</ref>. However, the reversed LUTs are not unambiguously recoverable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Countermeasures &amp; Defense Techniques</head><p>In this section, we discuss two possible countermeasures and four defense techniques. We define countermeasures as techniques defending current 7-Series devices, e.g., which hardware developers can use, and defense techniques as measures, which require to update the silicon, e.g., which platform companies like Xilinx can offer. Note that our attacks are based on protocol flaws that are hard-coded in the FPGA silicon. Thus, any kind of non-trivial change to the security protocol is not possible without a re-design of the FPGA hardware and is currently not available for 7-Series and Virtex-6 devices. <ref type="table" target="#tab_8">Table 3</ref> gives an overview of our proposed defence techniques and countermeasures, which are discussed in this section. We divided the section into two parts. In the first part, we discuss four defense techniques for new developments, while the first two are (seemingly) implemented in the new Xilinx series. In  the second part, we discuss about design obfuscation and a patch to the PCB as raise-the-bar countermeasures for current 7-Series devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">General Defense Techniques</head><p>Here we discuss on general defense techniques, which can be offered by Xilinx and are already partially used in the new UltraScale(+) and Zynq series.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Validate Before Use</head><p>In a sound security design, no data is interpreted before its cryptographic validation. However, one of the root causes of the decryption attack is that this principle is violated in the FPGA's encryption engine, i.e., data of the encrypted bitstream header is interpreted before it has been verified. Hence, the apparent countermeasure is to validate the configuration header before any action. If that could be implemented, the attack would be detected as it manipulates the header. Nevertheless, to our knowledge, updating the bitstream encryption engine on current devices is not possible, as it is implemented in the silicon and would require a redesign. It is instructive to look at the newer FPGA families by Xilinx. It seems that Xilinx introduced a continuous checksum in the UltraScale and UltraScale+ series, as we could not mount the attack on such devices. Xilinx used an AES-GCM scheme for the new series, where the first 32 bits of every 256-bit encrypted data block are unknown (seems random), which are also not addressed by the configuration logic. We speculate that these 32 bits are a kind of checksum used for verification/integrity. However, to the best of our knowledge, there is no official statement from Xilinx about these 32 bits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Patchable Bitstream Encryption</head><p>It might be a bit ironic that the security measures of a reconfigurable device are not reconfigurable. <ref type="bibr">Unterstein et al.</ref> showed an implementation of a patchable bitstream encryption scheme on the Zynq-7000 platform <ref type="bibr" target="#b52">[54]</ref>, which is a realization of <ref type="bibr" target="#b36">[38]</ref>. There are several variations of the same idea reported in references <ref type="bibr" target="#b17">[19,</ref><ref type="bibr" target="#b19">21,</ref><ref type="bibr" target="#b20">22]</ref>. Note that the Zynq-7000, UltraScale and UltraScale+ devices have the needed public key scheme, while the 7-Series and older devices have not. Consequently, this countermeasure does not apply to the 7-Series. In a nutshell, the FPGA loads an initial bitstream and only verifies it. This initial bitstream contains a hardened bitstream encryption engine in terms of side-channel resistance, and a Physical Unclonable Function (PUF) which generates the encryption key. This engine decrypts the original bitstream, as well as loads it via partial-reconfiguration to the fabric.</p><p>The engine is patchable as it residents in the fabric and is not hard-coded into the FPGA. Hence, it is possible to improve the engine if new attacks arise, e.g., enhanced sidechannel attacks, or if bugs are found in the system (like our attacks in this work). Additionally, no key storage is needed as a PUF is used, which reduces the risk of attacks and disadvantages of the BBRAM and eFUSES key storage implemented by Xilinx. For example, it is shown in <ref type="bibr" target="#b26">[28,</ref><ref type="bibr" target="#b51">53]</ref> how to read out keys stored in register cells of various FPGAs.</p><p>The only requirement is to verify the initial bitstream and avoid running invalid bitstreams. Accordingly, the authors of <ref type="bibr" target="#b52">[54]</ref> used the Xilinx Zynq-7000 series, where a public-key signature scheme is integrated. Besides the Zynq-7000 series, the UltraScale and UltraScale+ series also include such embedded public-key signatures. In the 7-Series devices, no such signature scheme exists. The validating prevents any modification, e.g., the insertion of hardware Trojans like modifications to the encryption engine to leak the keys or the decrypted bitstream. Since the initial bitstream only needs to be verified, it is not encrypted. Hence, the attacker can see how it is realized and implemented. Thus, the implementation and exact location of the PUF is known to the adversary. Therefore, the FPGA must suppress any non-verified bitstreams, as otherwise, the attacker can modify the bitstream to read out the PUF response, i.e., the secrets.</p><p>Admittedly, this scheme is based on trust in the public key signature scheme and its implementation. Although it lowers the unpatchable attack surface to the signature scheme only, as if a successful attack targets the encryption scheme, it is still patchable. However, an unpatchable attack surface exists. Thus, we discuss model-checking and Information Flow Analysis (IFA) as another countermeasure in the following.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3">Information Flow Analysis and Model Checking</head><p>A detailed study of the Xilinx official documents <ref type="bibr" target="#b54">[56]</ref>, together with experiments, led us to our attack. However, since the bitstream encryption and the behavior of the WBSTAR register are documented, it is perceivable that one could have developed a formal model to find the bug. Within the last years, there has been an increasing trend towards formal verification and model checking in the scientific community. The recent publication from Dessouky <ref type="bibr" target="#b4">[5]</ref> discusses various techniques to find hardware bugs. Three of them can be applied to our findings: proof assistant and theorem-proving, model checking, and IFA. Note that the formal verification of the design against the specification is not sufficient, as the bug is already visible in the documentation, i.e., the specification of configuration. Additionally, after the specification is changed, the current devices should be reproduced to apply this countermeasure.</p><p>Within proof assistant and theorem-proving, the security properties are mathematically modeled and verified with the proofs. For example, VeriCoq <ref type="bibr" target="#b3">[4]</ref> transfers a Verilog code into the Coq language and proof system. With additional labeling the signals, the flow of information is tracked, i.e., the signals are classified if they transmit secret information or not. Mathematical proofs ensure that no secret information is leaked. However, the accurate labeling of each signal is error-prone and laborious, and the proving might be infeasible for large designs.</p><p>The more general model checking is mostly built on Boolean satisfiability problems. The engineer formulates an abstract model of the specification and tests predefined assumptions of the model to be correct, e.g., a decrypted bitstream cannot flow to a configuration register.</p><p>Since model checkers are a general approach and require to write an additional model besides the specification and HDL code, IFA checks the design directly. In general, the input data are labeled, mostly in high and low, e.g., private and public information. Then, these labels are tracked while flowing through the design. If any private-labeled data influence public data, a vulnerability might be detected. For performing IFA, a variety of tools exists which operate at different layers of abstraction. Gate-Level Information Flow Tracking (GLIFT) works on the gate-level <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b32">34,</ref><ref type="bibr" target="#b50">52]</ref>, where the analysis is performed on the synthesized design. Hence, it is mostly done automated and works on existent designs but does not scale well. Caisson <ref type="bibr" target="#b25">[27]</ref>, Sapper <ref type="bibr" target="#b24">[26]</ref>, and SecVerilog <ref type="bibr" target="#b55">[57]</ref> works on the language level, while Caisson and Sapper are new HDLs, and SecVerilog extends Verilog with annotations. Therefore, it is applicable to already existing projects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.4">Open-Source Hardware</head><p>When considering a redesign, one can take open-source hardware into account. Open-source hardware has, at the least in theory, the advantage of being verifiable from a large community, similar to what is already done in software projects, e.g., OpenSSL <ref type="bibr" target="#b2">[3]</ref>. Hence, it gains its trust by transparency rather than obscurity and follows the approach of Kerckhoffs Principle <ref type="bibr" target="#b16">[18]</ref>. The recently released OpenTitan <ref type="bibr" target="#b34">[36,</ref><ref type="bibr" target="#b35">37]</ref> silicon root of trust moves into that direction. It provides a trust anchor for system security and is applicable as an IP core for custom made devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Countermeasures for Current Devices</head><p>With our attack, a product using a 7-Series (or Virtex-6) device needs to be upgraded to one with a sound bitstream encryption engine, as our findings imply a complete loss of authenticity and confidentiality and no patch is available. However, it is neither possible nor feasible to update the FPGAs used in all products. The old Virtex-6 and current 7-Series are commonly used in low-budget devices. Thus, a countermeasure that raises the bar for the attacker can be sufficient in many applications. In this section, we first introduce obfuscation as a countermeasure and then a patch to the PCB to reset the FPGA if the attack is detected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Obfuscation</head><p>One of the raise-the-bar countermeasures is obfuscation. It changes the design without changing its functionality, while the design is concealed and becomes significantly more complex to be reverse-engineered for humans and machines. Several works <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b37">39]</ref> already exist, especially for low-budget FPGAs, which do not offer any bitstream encryption. Here, two main goals exist: securing against overproduction/cloning and reverse engineering. A mechanism to secure against overproduction is always bound to an FPGA, hence often PUFs are used. Based on physical variations of each device, a devicespecific key is generated by the PUF to unlock the design. Consequently, the design would not unlock on a different FPGA, since its physical characteristics are different, and the PUF generates a different unlock key. More general obfuscation schemes defend against reverse-engineering. Often, the Finite State Machines (FSMs) of the designs are targeted; hence, dummy states are added to the design to increase the complexity of the state-transition graph. By applying a transition sequence to unlock the design, the FSM can still be used as initially intended. Subramanyan et al. benchmarked different obfuscation techniques in <ref type="bibr" target="#b46">[48]</ref>. They consider an area overhead of 5% as a realistic budget and a 10% overhead for sensitive designs acceptable. Nevertheless, the current obfuscation methods are not ideal, as shown in <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Revision Select PIN</head><p>In the second raise-the-bar countermeasure, the Revision Select (RS) pins are used to reset the FPGA and clear the BBRAM key storage, which extends the root of trust from the FPGA's silicon to the PCB.</p><p>Besides the warm boot address (bits 28-0), the WBSTAR register drives two RS pins (bit 31 and 30) during the configuration phase. The two RS pins are enabled with the RS_TS_B bit in the WBSTAR register (bit 29), which controls a tri-state, driving the RS pins. If the RS_TS_B bit is high, these two RS bits in the WBSTAR register directly drive the two RS pins. Otherwise, the RS pins are in high-Z. During regular operation, e.g., after the configuration phase, the RS pins can be used as regular I/O pins <ref type="bibr" target="#b54">[56]</ref>. We have observed this on the SAKURA-X board, where one RS pin drives one of the user's LEDs.</p><p>During the attack, the bitstream content is written into the WBSTAR register. Thus, the RS pins are driven with the bitstream contents. Exemplarily, if the RS_TS_B bit is set in any word, the two RS bits in that word drive the RS pins. In a raise-the-bar countermeasure, one could wire the RS pins to a reset logic on the PCB, to power-off the FPGA, which hinders the readout of the current word as the power-down wipes all registers, including the WBSTAR register. Accordingly, if the upper three bits of a random word in the bitstream are set, the FPGA would be reset, which hinders the readout of the WBSTAR content. Nonetheless, a defender needs to impede the readout of further bitstream words, since words where no RS and the RS_TS_B bit is set, are still possible to be read out as the FPGA is not reset during the attack. Therefore, one can also cut the battery power to the BBRAM to clear the stored key. Thus, no further encryption operations are possible since the keys are discarded. To provoke the reset via an RS pin, the defender can change the bitstream content in unused regions to drive an RS pin high, i.e., set the upper 3 bits in multiple words of the bitstream that are unused.</p><p>On the PCB, the RS pins are wired to a reset circuit to power-cycle the FPGA completely, i.e., the FPGA is reset, and the battery power to the BBRAM is cut. Whereas, the bitstream encryption's goal is to run all security-relevant measures inside the FPGA and not rely on other components. This means that the FPGA's designer needs to solely trust the FPGA's silicon and not other components, which minimizes the attack surface notably. Thus, with this countermeasure, the bitstream encryption's goal of not relying on the PCB is not fulfilled. Hence, this method is a raise-the-bar countermeasure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>In this paper, we demonstrated two attacks on the Xilinx 7-Series and Virtex-6 bitstream encryption. The first attack breaks the confidentiality of any encrypted design using the FPGA as a decryption oracle. The second attack breaks the authenticity by using the same oracle to encrypt arbitrary bitstreams and generating a valid authentication tag. In our implementation, any communication with the oracle needs 7.9 ms to reveal 32 bits of an encrypted block. Thus, it takes for example 3:42 hours to recover a Kintex-7 XC7K160T bitstream (see <ref type="table" target="#tab_6">Table 2</ref>).</p><p>For our attacks, it is sufficient to have access to the encrypted bitstream and either the JTAG or the SelectMap configuration interface. Hence, the attack can be potentially conducted remotely and does not require any sophisticated tools. We identified two roots leading to the attacks. First, the decrypted bitstream data are interpreted by the configuration logic before the HMAC validates them. Second, the HMAC key is stored inside the encrypted bitstream. Consequently, if the confidentiality is broken, the authenticity is lost as well.</p><p>We consider this as a severe attack, since (ironically) there is no opportunity to patch the underlying silicon of the cryptographic protocol. We note that the 7-Series have a substantial share of the FPGA market, which makes it even more difficult or impossible to replace these devices. As a countermeasure, we propose (for future-series devices) to verify all input data before use, apply model checkers and IFA, use when possible open-source hardware, and make use of a patchable bitstream encryption engine, like the one implemented on the Zynq-7000. For the current series, we propose to use obfuscation schemes or patching the PCB to use the FPGA's RS pins for clearing the BBRAM key storage in case of an attack. Although these countermeasures are not a substitute for a sound bitstream encryption, they still raise the bar for legacy systems until more secure devices can be provided.</p><p>The bitstream encryption for newer generations, e.g., UltaScale, appears to be an entirely new development. Thus, it is still impossible to mount the same attacks on new-generation devices, as detailed information about the bitstream packets is not yet publicly available.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>FIGURE 1 :</head><label>1</label><figDesc>FIGURE 1: Bitstream structure overview (shaded parts are encrypted) [53, 56].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>FIGURE 4 :</head><label>4</label><figDesc>FIGURE 4: Attack bitstream</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>TABLE 1 : Type 1 package header format. "R" are reserved bits and "x" are the actually used bits [56].</head><label>1</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>TABLE 2 :</head><label>2</label><figDesc></figDesc><table>Expected runtime of the attack on various Xilinx FPGAs, 
(*) extrapolated from the XC7K160T 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>TABLE 3 :</head><label>3</label><figDesc></figDesc><table>Proposed countermeasures and defense techniques and 
their adaptability on new developments, new series from Xilinx, and 
the current 7-Series discussed in Section 5 

</table></figure>

			<note place="foot" n="1"> 0x30034001 is the command (type 1 package), where 0x3 is a write command, 0x34 determine the written register, and 0x1 the length of data written to the register. The following word 0x00002250 is the data written to that register 0x34 (see Table 1). 3 Attacking Xilinx Bitstream Encryption This section presents the adversary model, the malleability of the bitstream encryption, and gives an introduction on how to forge arbitrary bitstreams. We use the following notation: A word is 32-bit long, a block is 128-bit long (AES-256 operation) and a chunk is 512-bit long (one SHA-256 input).</note>

			<note place="foot">   fabric data h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h h</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We communicate these findings with Xilinx in a responsible disclosure on 24 September 2019. We would like to thank Xilinx for their support and kind communication during this process, as well as the anonymous reviewers and our shepherd Stefan Mangard for all their helpful comments. Part of this work was supported by the European Research Council (ERC) under the European Union's Horizon 2020 Research and Innovation programme (ERC Advanced Grant No. 695022 (EPoCH)), as well as, by the German Research Foundation (DFG) within the framework of the Excellence Strategy of the Federal Government and the <ref type="bibr">States -EXC 2092 CASA -390781972.</ref> </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Using the design security features in Altera FPGAs, Appl Note AN-556</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Altera</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Register transfer level information flow tracking for provably secure hardware design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Armaiti</forename><surname>Ardeshiricham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><surname>Marxen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Kastner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Design, Automation &amp; Test in Europe Conference &amp; Exhibition</title>
		<editor>David Atienza and Giorgio Di Natale</editor>
		<meeting><address><addrLine>Lausanne, Switzerland</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017-03-27" />
			<biblScope unit="page" from="1691" to="1696" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Verified correctness and security of openssl HMAC</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lennart</forename><surname>Beringer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Petcher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katherine</forename><forename type="middle">Q</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">W</forename><surname>Appel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">24th USENIX Security Symposium, USENIX Security 15</title>
		<editor>Jaeyeon Jung and Thorsten Holz</editor>
		<meeting><address><addrLine>Washington, D.C., USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="207" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Vericoq: A verilog-to-coq converter for proof-carrying hardware automation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohammad-Mahdi</forename><surname>Bidmeshki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yiorgos</forename><surname>Makris</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE International Symposium on Circuits and Systems, ISCAS 2015</title>
		<meeting><address><addrLine>Lisbon, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="29" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Hardfails: Insights into software-exploitable hardware bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ghada</forename><surname>Dessouky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Gens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Haney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Garrett</forename><surname>Persyn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arun</forename><forename type="middle">K</forename><surname>Kanuparthi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hareesh</forename><surname>Khattri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><forename type="middle">M</forename><surname>Fung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad-Reza</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeyavijayan</forename><surname>Rajendran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28th USENIX Security Symposium, USENIX Security 2019</title>
		<editor>Nadia Heninger and Patrick Traynor</editor>
		<meeting><address><addrLine>Santa Clara, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2019" />
			<biblScope unit="page" from="213" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
				<ptr target="https://reference.digilentinc.com/reference/programmable-logic/basys-3/start" />
		<title level="m">DIGILENT. Basys3 Artix-7 FPGA Trainer Board</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Deriving an NCD file from an FPGA bitstream: Methodology, architecture and evaluation. Microprocessors and Microsystems -Embedded Hardware Design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zheng</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qiang</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yizhong</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linjie</forename><surname>Zhu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="299" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Authentication of FPGA bitstreams: Why and how</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saar</forename><surname>Drimer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">;</forename><surname>Pedro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Diniz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eduardo</forename><surname>Marques</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koen</forename><surname>Bertels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcio</forename><forename type="middle">Merino</forename><surname>Fernandes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">João</forename><forename type="middle">M P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reconfigurable Computing: Architectures, Tools and Applications, Third International Workshop</title>
		<meeting><address><addrLine>Mangaratiba, Brazil</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007-03-27" />
			<biblScope unit="volume">4419</biblScope>
			<biblScope unit="page" from="73" to="84" />
		</imprint>
	</monogr>
	<note>Cardoso</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Insights into the mind of a trojan designer: the challenge to integrate a trojan into the bitstream</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maik</forename><surname>Ender</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pawel</forename><surname>Swierczynski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Wallat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Wilhelm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><forename type="middle">Martin</forename><surname>Knopp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christof</forename><surname>Paar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Asia and South Pacific Design Automation Conference, ASP-DAC 2019</title>
		<editor>Toshiyuki Shibuya</editor>
		<meeting>the 24th Asia and South Pacific Design Automation Conference, ASP-DAC 2019<address><addrLine>Tokyo, Japan</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019" />
			<biblScope unit="page" from="112" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Reverse engineering of printed electronics circuits: From imaging to netlist extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Ahmet Turan Erozan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Hefenbrock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jasmin</forename><surname>Beigl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mehdi Baradaran</forename><surname>Aghassi-Hagmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tahoori</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Information Forensics and Security</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="475" to="486" />
			<date type="published" when="2020" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F-Secure</forename></persName>
		</author>
		<ptr target="https://github.com/f-secure-foundry/advisories/blob/master/Security_Advisory-Ref_FSC-HWSEC-VR2019-0001-Xilinx_ZU+-Encrypt_Only_Secure_Boot_bypass.txt" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
<note type="report_type">CVE-2019-5478</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">On the Difficulty of FSM-based Hardware Obfuscation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Fyrbiak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Wallat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Déchelotte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nils</forename><surname>Albartus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sinan</forename><surname>Böcker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Russell</forename><surname>Tessier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christof</forename><surname>Paar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Trans. Cryptogr. Hardw. Embed. Syst</title>
		<imprint>
			<biblScope unit="volume">2018</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="293" to="330" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">FPGA bitstream protection with pufs, obfuscation, and multi-boot</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ozgur</forename><surname>Sezer Gören</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abdullah</forename><surname>Ozkurt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yildiz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fatih Ugurdag</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Workshop on Reconfigurable Communication-centric Systems-on-Chip, ReCoSoC</title>
		<meeting>the 6th International Workshop on Reconfigurable Communication-centric Systems-on-Chip, ReCoSoC<address><addrLine>Montpellier, France</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2011-06-22" />
			<biblScope unit="page" from="1" to="2" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Partial bitstream protection for lowcost fpgas with physical unclonable function, obfuscation, and dynamic partial self reconfiguration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ozgur</forename><surname>Sezer Gören</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abdullah</forename><surname>Ozkurt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">Fatih</forename><surname>Yildiz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajat</forename><surname>Ugurdag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Debdeep</forename><surname>Subhra Chakraborty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mukhopadhyay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Electrical Engineering</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="386" to="397" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">JBits: Java based interface for reconfigurable computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Guccione</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Delon</forename><surname>Levi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prasanna</forename><surname>Sundararajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS 2011</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Finding and understanding bugs in fpga synthesis tools</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yann</forename><surname>Herklotz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Wickerson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Increased security through open source</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bart</forename><surname>Jaap-Henk Hoepman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="79" to="83" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Securing FPGA soc configurations independent of their manufacturers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nisha</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jakob</forename><surname>Wittmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johann</forename><surname>Heyszl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Hesselbarth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Florian</forename><surname>Wilde</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Pehl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Georg</forename><surname>Sigl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Fischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th IEEE International System-on-Chip Conference</title>
		<editor>Massimo Alioto, Hai Helen Li, Jürgen Becker, Ulf Schlichtmann, and Ramalingam Sridhar</editor>
		<meeting><address><addrLine>Munich, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017-09-05" />
			<biblScope unit="page" from="114" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">TikZ for Cryptographers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jérémy</forename><surname>Jean</surname></persName>
		</author>
		<ptr target="https://www.iacr.org/authors/tikz/" />
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">An autonomous, self-authenticating, and self-contained secure boot process for field-programmable gate arrays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Don</forename><surname>Owen</surname><genName>Jr</genName></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Derek</forename><surname>Heeger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Calvin</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenjie</forename><surname>Che</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fareena</forename><surname>Saqib</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Areno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Plusquellic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cryptography</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">15</biblScope>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Compact and onthe-fly secure dynamic reconfiguration for volatile fpgas</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hirak</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ricardo</forename><surname>Chaves</surname></persName>
		</author>
		<idno>11:1-11:22</idno>
	</analytic>
	<monogr>
		<title level="j">TRETS</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Defeating cisco trust anchor: A case-study of recent advancements in direct FPGA bitstream manipulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jatin</forename><surname>Kataria</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rick</forename><surname>Housley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Pantoga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ang</forename><surname>Cui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th USENIX Workshop on Offensive Technologies, WOOT 2019</title>
		<editor>Alex Gantman and Clémentine Maurice</editor>
		<meeting><address><addrLine>Santa Clara, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Defeating cisco trust anchor: A case-study of recent advancements in direct FPGA bitstream manipulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jatin</forename><surname>Kataria</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rick</forename><surname>Housley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Pantoga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ang</forename><surname>Cui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th USENIX Workshop on Offensive Technologies (WOOT 19)</title>
		<meeting><address><addrLine>Santa Clara, CA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2019-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Stuxnet: Dissecting a cyberwarfare weapon</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ralph</forename><surname>Langner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security &amp; Privacy</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="49" to="51" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Sapper: a language for hardware-level security policy enforcement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xun</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vineeth</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><forename type="middle">K</forename><surname>Oberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohit</forename><surname>Tiwari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ram</forename><surname>Vasanth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Rajarathinam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><surname>Kastner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frederic</forename><forename type="middle">T</forename><surname>Hardekopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Chong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Architectural Support for Programming Languages and Operating Systems, AS-PLOS &apos;14</title>
		<editor>Rajeev Balasubramonian, Al Davis, and Sarita V. Adve</editor>
		<meeting><address><addrLine>Salt Lake City, UT, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="97" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Caisson: a hardware description language for secure information flow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xun</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohit</forename><surname>Tiwari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Oberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vineeth</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frederic</forename><forename type="middle">T</forename><surname>Chong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Hardekopf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2011</title>
		<editor>Mary W. Hall and David A. Padua</editor>
		<meeting>the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI 2011<address><addrLine>San Jose, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="109" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Key extraction using thermal laser stimulation A case study on xilinx ultrascale fpgas</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heiko</forename><surname>Lohrke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shahin</forename><surname>Tajik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thilo</forename><surname>Krachenfels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Boit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Pierre</forename><surname>Seifert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Trans. Cryptogr. Hardw. Embed. Syst</title>
		<imprint>
			<biblScope unit="volume">2018</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="573" to="595" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">On the vulnerability of FPGA bitstream encryption against power analysis attacks: extracting keys from xilinx virtex-ii fpgas</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amir</forename><surname>Moradi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alessandro</forename><surname>Barenghi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timo</forename><surname>Kasper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christof</forename><surname>Paar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM Conference on Computer and Communications Security</title>
		<editor>Yan Chen, George Danezis, and Vitaly Shmatikov</editor>
		<meeting>the 18th ACM Conference on Computer and Communications Security<address><addrLine>Chicago, Illinois, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011-10-17" />
			<biblScope unit="page" from="111" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Improved sidechannel analysis attacks on xilinx bitstream encryption of 5, 6, and 7 series</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amir</forename><surname>Moradi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tobias</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Constructive Side-Channel Analysis and Secure Design -7th International Workshop, COSADE 2016</title>
		<editor>François-Xavier Standaert and Elisabeth Oswald</editor>
		<meeting><address><addrLine>Graz, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016" />
			<biblScope unit="volume">9689</biblScope>
			<biblScope unit="page" from="71" to="87" />
		</imprint>
	</monogr>
	<note>Revised Selected Papers</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Analysing the Bitstream of Altera&apos;s MAX-V CPLDs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Francois</forename><surname>Nguyen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Baptiste</forename><surname>Note</surname></persName>
		</author>
		<ptr target="https://github.com/djn3m0/debit/tree/master/altera" />
		<imprint>
			<date type="published" when="2008-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">From the bitstream to the netlist</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Éric</forename><surname>Jean-Baptiste Note</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rannaud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM/SIGDA 16th International Symposium on Field Programmable Gate Arrays, FPGA</title>
		<editor>Mike Hutton and Paul Chow</editor>
		<meeting>the ACM/SIGDA 16th International Symposium on Field Programmable Gate Arrays, FPGA<address><addrLine>Monterey, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008-02-24" />
			<biblScope unit="page">264</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Theoretical analysis of gate level information flow tracking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Oberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ali</forename><surname>Irturk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohit</forename><surname>Tiwari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Kastner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th Design Automation Conference, DAC 2010</title>
		<editor>Sachin S. Sapatnekar</editor>
		<meeting>the 47th Design Automation Conference, DAC 2010<address><addrLine>Anaheim, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="244" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Openocd</surname></persName>
		</author>
		<ptr target="http://openocd.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">OpenTitan open source silicon root of trust (RoT) project</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Opentitan</surname></persName>
		</author>
		<ptr target="https://opentitan.org/" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">OpenTitan open source silicon root of trust (RoT) project</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Opentitan</surname></persName>
		</author>
		<ptr target="https://github.com/lowRISC/opentitan" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Leveraging asymmetric authentication to enhance securitycritical applications using Zynq-7000 all programmable SoCs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ed</forename><surname>Peterson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Dynamic polymorphic reconfiguration for anti-tamper circuits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roy</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><forename type="middle">J</forename><surname>Stone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yong</forename><forename type="middle">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">Todd</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lavern</forename><forename type="middle">A</forename><surname>Starman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">19th International Conference on Field Programmable Logic and Applications</title>
		<editor>Martin Danek, Jiri Kadlec, and Brent E. Nelson</editor>
		<meeting><address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009-08-31" />
			<biblScope unit="page" from="493" to="497" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">The Keyed-Hash Message Authentication Code (HMAC)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fips Pub</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>Federal Information Processing Standards Publication</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Practical padding oracle attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juliano</forename><surname>Rizzo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thai</forename><surname>Duong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">4th USENIX Workshop on Offensive Technologies, WOOT &apos;10</title>
		<editor>Charlie Miller and Hovav Shacham</editor>
		<meeting><address><addrLine>Washington, D.C., USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2010-08-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Rogers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Uwe</forename><surname>Bonnes</surname></persName>
		</author>
		<ptr target="http://xc3sprog.sourceforge.net/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Side-channel AttacK User Reference Architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sakura-X</forename></persName>
		</author>
		<ptr target="http://satoh.cs.uec.ac.jp/SAKURA/index.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J-Link</forename><surname>Segger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Edu</surname></persName>
		</author>
		<ptr target="https://www.segger" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Hardware security evaluation of MAX 10 FPGA. CoRR, abs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergei</forename><surname>Skorobogatov</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1910" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Breakthrough silicon scanning discovers backdoor in military chip</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergei</forename><surname>Skorobogatov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Woods</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Emmanuel Prouff and Patrick Schaumont, editors, Cryptographic Hardware and Embedded Systems -CHES 2012 -14th International Workshop, Leuven, Belgium</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012" />
			<biblScope unit="volume">7428</biblScope>
			<biblScope unit="page" from="23" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T</forename><surname>Stm32f4discovery</surname></persName>
		</author>
		<ptr target="https://www.st.com/en/evaluation-tools/stm32f4discovery.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Evaluating the security of logic encryption algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pramod</forename><surname>Subramanyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sayak</forename><surname>Ray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sharad</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Hardware Oriented Security and Trust, HOST 2015</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2015-05-07" />
			<biblScope unit="page" from="137" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Physical security evaluation of the bitstream encryption mechanism of altera stratix II and stratix III fpgas</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pawel</forename><surname>Swierczynski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amir</forename><surname>Moradi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Oswald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christof</forename><surname>Paar</surname></persName>
		</author>
		<idno>34:1-34:23</idno>
	</analytic>
	<monogr>
		<title level="j">TRETS</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Project x-ray</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Symbiflow</surname></persName>
		</author>
		<ptr target="https://github.com/SymbiFlow/prjxray" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">On the power of optical contactless probing: Attacking bitstream encryption of fpgas</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shahin</forename><surname>Tajik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heiko</forename><surname>Lohrke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Pierre</forename><surname>Seifert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Boit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</title>
		<editor>Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu</editor>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security<address><addrLine>Dallas, TX, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017-10-30" />
			<biblScope unit="page" from="1661" to="1674" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Complete information flow tracking from the gates up</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohit</forename><surname>Tiwari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Hassan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bita</forename><surname>Wassel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shashidhar</forename><surname>Mazloom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frederic</forename><forename type="middle">T</forename><surname>Mysore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><surname>Chong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sherwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Architectural Support for Programming Languages and Operating Systems</title>
		<editor>Mary Lou Soffa and Mary Jane Irwin</editor>
		<meeting>the 14th International Conference on Architectural Support for Programming Languages and Operating Systems<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009-03-07" />
			<biblScope unit="page" from="109" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">FPGA security: Motivations, features, and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Trimberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE</title>
		<meeting>the IEEE</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">102</biblScope>
			<biblScope unit="page" from="1248" to="1265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">SCA secure and updatable crypto engines for FPGA soc bitstream decryption</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Florian</forename><surname>Unterstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nisha</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neil</forename><surname>Hanley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chongyan</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johann</forename><surname>Heyszl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd ACM Workshop on Attacks and Solutions in Hardware Security Workshop</title>
		<editor>Chip-Hong Chang, Ulrich Rührmair, Daniel E. Holcomb, and Patrick Schaumont</editor>
		<meeting>the 3rd ACM Workshop on Attacks and Solutions in Hardware Security Workshop<address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019-11-15" />
			<biblScope unit="volume">2019</biblScope>
			<biblScope unit="page" from="43" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Xilinx</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Form</surname></persName>
		</author>
		<ptr target="http://investor.xilinx.com/static-files/0c7c52e0-4f2f-46c8-b990-2e24c98e41a9" />
		<imprint>
			<date type="published" when="2018-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">UG470 7 Series FPGAs Configuration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Xilinx</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">A hardware design language for timing-sensitive information-flow security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danfeng</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yao</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">Edward</forename><surname>Suh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">C</forename><surname>Myers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS &apos;15</title>
		<editor>Özcan Öz-turk, Kemal Ebcioglu, and Sandhya Dwarkadas</editor>
		<meeting>the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS &apos;15<address><addrLine>Istanbul, Turkey</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="503" to="516" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
