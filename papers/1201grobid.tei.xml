<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-10-01T14:47+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Adaptive XML Storage or The Importance of Being Lazy</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristian</forename><surname>Duda</surname></persName>
							<email>cristian.duda@inf.ethz.ch</email>
							<affiliation key="aff0">
								<orgName type="institution">ETH Zurich Institute for Information Systems</orgName>
								<address>
									<postCode>8092</postCode>
									<settlement>Zurich</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><surname>Kossmann</surname></persName>
							<email>donald.kossmann@inf.ethz.ch</email>
							<affiliation key="aff1">
								<orgName type="department">Institute for Information Systems</orgName>
								<orgName type="institution">ETH Zurich</orgName>
								<address>
									<postCode>8092</postCode>
									<settlement>Zurich</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Adaptive XML Storage or The Importance of Being Lazy</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>XML</term>
					<term>XML Storage</term>
					<term>XML Indexing</term>
					<term>Partial Indexing</term>
					<term>Lazy Indexing</term>
					<term>Adaptivity</term>
					<term>Laziness</term>
					<term>Granularity</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Building an XML store means finding solutions to the problems of representing, accessing, querying and updating XML data. The irregularity of both the structure and usage of XML, is, however, a big obstacle in achieving good performance. Relational Database Systems rely on a fixed-schema of records to represent and manage data, but XML data, irregular in structure and content, does not seem to allow this approach. This paper describes how the notion of database record has been extended and applied to XML storage and how the resulted store abstracts the structure of the XML data from the actual storage format. Furthermore, we argue that an adaptive (lazy) XML store and partial indexing are the key points in achieving good performance facing the range of different XML usage patterns. This allows for automatic, application-specific tuning, facing the range of challenges imposed by the current XML applications.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>XML has a prominent role in current industry and research, either as a generic way to represent data or as a format for data integration and application interoperability. XML applications require, from this point of view, the capability to store, retrieve and query XML data. In order to face this range of challenges, XML research has focused on multiple angles of XML storage. The necessity to assign identifiers to nodes in an XML document, brought a variety of identifier and indexing schemes for XML <ref type="bibr" target="#b15">[16]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b16">[17]</ref> Related to this approach are works which try to map the existing relational database systems to the challenges of XML <ref type="bibr" target="#b7">[8]</ref> <ref type="bibr" target="#b18">[19]</ref> Recently, new challenges have been posed by XQuery <ref type="bibr" target="#b1">[2]</ref>, the standard language for querying XML. XQuery is defined over the very generic XQuery Data Model and raises issues such as efficient query evaluation, efficient access and retrieval of XML data and maintainment of document order. Query evaluation and optimization <ref type="bibr" target="#b15">[16]</ref>[1] have their share of research work, such as <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b8">[9]</ref> to list ones relevant to our work. Concurrency and locking protocols for XML also raise specific problems <ref type="bibr">[[12]</ref> <ref type="bibr" target="#b12">[13]</ref>. The focus switches, therefore, from optimizing queries, reads and access (index structures and identifier schemes), to optimizing XML updates -issues which are rarely be addressed together. A common solution is the simplification of the requirements (such as reducing the XQuery language to substets) in order to allow allows better results when different techniques are combined. These choices can be restrictive for the application. As an example, good identifier schemes that are well supported by index schemes in a relational database <ref type="bibr" target="#b8">[9]</ref>, help evaluating XPath <ref type="bibr" target="#b4">[5]</ref> expressions (restricted part of XQuery) based on containment, but show poor performance for updates.</p><p>What existing approaches lack is a uniform way of representing and thinking of XML; furthermore, they focus on one aspect of XML storage, and assume that the application will adapt to a particular usage pattern. Even the more flexible approaches which abstract away the underlying data model and choices made while developing the store, offer little place to real adaptation to the application (e.g., defining a threshold parameter of this notable work <ref type="bibr" target="#b14">[15]</ref>, requires a lot of knowledge of the underlying storage pattern). Another issue which affects existing approaches is that they function as all-or-nothing as what regards indexing: the previous example of the identifier scheme is a typical one, where advantages gained by knowing all node information is lost in poor performance updates. The conclusion is, one cannot achieve everything at once, but should focus on what it can achieve at a given moment, in a given usage context. Some existing approaches took the first partial approaches to doing that: either restricted at a special scenario such as query evaluation <ref type="bibr" target="#b3">[4]</ref> <ref type="bibr" target="#b18">[19]</ref> or even more generic, closer to our work: <ref type="bibr" target="#b10">[11]</ref> <ref type="bibr" target="#b11">[12]</ref> In our opinion, the desiderata for an XML store has at its center the possibility to abstract away the actual XML model of the application, and to give enough room for determining the best way to store depending on the application usage pattern. The keywords are: adaptivity, laziness and partial. Baring this in mind, our contribution is the use of a flat representation -an XML instance is a sequence of Ranges: logical units similar to tuples in relational databases, whose size and existence is defined by the application usage pattern (inserts/deletes, etc.). This unit is supported by the choice of our XML representation, and opens the way to a lazy approach to storing, accessing and indexing XML data. Ranges replace a tree model with a flat one, and offer enough flexibility to have application-dependent indexing units, while still allowing for more granular indexing, if needed. Additional issues such as identifier schemes are, therefore, orthogonal to this model. The well-known results to the problems of storing, accessing, querying, and updating data in relational database systems (RDBMS) seem to have no direct applicability when facing the irregularity of XML Data. The intrinsic tree model of XML is not compatible to the flat model of tuples complying with a welldefined schema, stored in the pages of the RDBMS. Successful stories found a niche in defining appropriate index structures and identifier schemes that have a straightforward mapping to a relational data model <ref type="bibr" target="#b15">[16]</ref>[9] <ref type="bibr" target="#b18">[19]</ref>. Querying XML data using the previously defined index structures maps better to the set-oriented relational data model <ref type="bibr" target="#b18">[19]</ref>[1] In order to address the actual storage issues, native <ref type="bibr" target="#b13">[14]</ref> XML store implementations <ref type="bibr" target="#b14">[15]</ref> find an extension of the relational data model by arguing that tree structures and tree-based keys are a natural extension of the relational model to the XML world.</p><p>This paper is structured as follows: Section 2 formally defines our requirements for an XML store and Section 3 motivates our choice for XML Representation. The partial, lazy approach we take to indexing is discussed in Sections 4 and 5. Identifier schemes are briefly taken into consideration in Section 6, and shown to be orthogonal to the main storage model. Section 7 presents experimental results. After a discussion of related work in Section 8, conclusions and future work constitute the core of Section 9.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">XML STORE DESIDERATA</head><p>In the context of the previous section, we derived the following list of requirements:</p><p>1. Store and access any instances of the XQuery DataModel support for stable and comparable identifiers should be offered.</p><p>6. Low storage overhead.</p><p>7. Support PSVI.</p><p>The XQuery Data Model <ref type="bibr" target="#b1">[2]</ref> supports a wide range of XML applications (either read-oriented, or heavy-update scenarios), and support for XQuery itself is a must for a standard-compliant XML store. PSVI should be supported in order to avoid repeated evaluation of XML schema. Low storage overhead incurs by minimizing the quantity of data actually stored. In our approach we do not store all node identifiers, but store enough information to allow us regenerate them. See Section 6 for more details on Identifiers. The index structures are discussed in Sections 4 and 5.</p><p>The Store should support read operations (entire data source, but also a single node), and update operations (XUpdate) as described in <ref type="table" target="#tab_0">Table 1</ref>. XUpdate operations specify a node and allow insertions of the data relative to this node (as previous siblings, next sibling, first child or last child of the node). </p><formula xml:id="formula_0">insertBefore(id, …) insertAfter(id, …) insertIntoFirst(id, …) insetIntoLast(id, …) read() read(id):… deleteNode(id) replaceNode(id, …) replaceContent(id, …)</formula><p>Node identifiers are assigned, according to the XQuery DataModel to each node in the data instance. In particular, executing an XUpdate operation involves more steps: locating the target ID, identifying the insert position (e.g., as previous sibling, as next sibling, as first child, as last child), and performing the actual update.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Optimizing Reads vs. Optimizing Updates</head><p>Typical storage systems are faced with challenges of optimizing read operations or update operations, as required by the application. A store that achieves both optimally is a utopia since the structures required to support the first type of operation (fast indexes) negatively influence the performance of the other. In this work we take a middle approach, and try to optimize one or the other depending on the application load. Adaptivity, flexibility and laziness are another main desiderata expressed by our requirements.</p><p>The following sections argument how these requirements have been fulfilled in the particular case of our XML store. The important choices are: the XML representation, the definition of an arbitrarily granular unit Range, and the flexible index structures based on the existence of this unit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">XML REPRESENTATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Choosing an XML Representation</head><p>Current research on XML takes one of few alternatives to represent and store XML data. XML data is either shredded on a relational database <ref type="bibr" target="#b7">[8]</ref>[19] <ref type="bibr" target="#b9">[10]</ref>, special index structures, or a combination of the two <ref type="bibr" target="#b14">[15]</ref>. There is usually a strong relationship between storing and representing XML on one side, and indexing and querying it on the other side and current approaches do not conceptually separate them. Usual approaches provide neither the data independence, nor the flexible granularity that make up our adaptivity requirement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">A Flexible Representation: Sequence of Tokens</head><p>In order to achieve our goal, we have chosen a representation which is able to express anything between very granular and very coarse instances of the Xquery Data Model. We use a representation derived from a pull-based XQuery parser and engine, already described in literature <ref type="bibr" target="#b6">[7]</ref>. We will accordingly use the notion of Token to denote each part of the XQuery Data Model, as defined in this representation.</p><p>Tokens can be defined as a materialization of enriched SAX events. The model is richer than usual SAX events (or eventbased parsing models), as it defines units that do not exist on the SAX model (attributes separated from their element, and given corresponding begin and end tokens) <ref type="bibr" target="#b6">[7]</ref>.</p><formula xml:id="formula_1">&lt;ticket&gt; &lt;hour&gt; 15 &lt;/hour&gt; &lt;name&gt; Paul &lt;/name&gt; &lt;/ticket&gt; [BEGIN_ELEMENT [ID: 1] [ticket] [BEGIN_ELEMENT [ID: 2] [hour] [TEXT_TOKEN ID: 3 15] [END_ELEMENT] [BEGIN_ELEMENT [ID:4] [name] [TEXT_TOKEN ID:5 Paul] [END_ELEMENT] [END_ELEMENT]</formula><p>Figure 1: Sample XML document and corresponding Tokens <ref type="figure">Figure 1</ref> presents the tokens corresponding to a sample XML document.. In particular, Nodes in the XQuery Data Model, who must have an associated identifier, are also represented by a sequence of tokens. Here, in particular, the first one holds the identifier. A nested node is represented by a sequence of tokens starting with a Begin token, containing the Id, and an End token <ref type="bibr" target="#b6">[7]</ref>.</p><p>This particular representation of the XQuery Data Model offers us the following properties, which make it suitable for our goals:</p><p>1. Complete representation of the XQuery Data model 2. Independence of the API used in the actual application (flat model, as opposed to tree-based or event-based representation)</p><p>3. Alows flexible data granularity: the token is the most granular unit 4. PSVI : Post schema validation infoset <ref type="bibr" target="#b6">[7]</ref> Our representation is based therefore on the following fact: a token is the most granular unit (even more granular than an XML element); tokens can be grouped in more specific units (nodes/elements are a group of tokens). Other representations, in particular tree-based ones <ref type="bibr" target="#b14">[15]</ref>, do not provide this level of flexibility and are not extensible to the detail of the complete XQuery Data Model. PSVI fulfills one of our requirements since a token sequence (and, in particular, each XML Token) can also be associated to the XML schema type derived after a schema validation.</p><p>The aforementioned level of granularity allows a store implementation to use serialized tokens as the representation of the XML data. An XML data instance is represented by the full sequence of stored tokens.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The Storage Model</head><p>The storage model of the XML data in this store consists of token sequences serialized in sequential blocks/pages, in document order, as described in <ref type="figure" target="#fig_0">Figure 2</ref>. Each time data is inserted in the store, the corresponding tokens are generated and store in the corresponding positions in the storage: blocks are allocated accordingly. Tokens offer, therefore, a flat representation of the XML data, independent of the actual data model of the application that uses the store (such as DOM, SAX, etc.). Node Ids, requested in the XQuery Data Model, are also generated at insert time. We adopt the approach of stable identifiers, generated to all begin tokens of nodes, at insert time. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">IMPLEMENTING DATABASE RECORDS FOR XML 4.1 Discarding the Option of a Full Index</head><p>As described in previous sections, the interface to the store defines read, insert and update operations. Since all operations are defined relative to a target node Identifier, it is nodes corresponding to these identifiers that need to be quickly located during the update.</p><p>Section 1 described existing approaches to XML data storage <ref type="bibr" target="#b0">[1]</ref>[16] that take the options of full data indexing -the purpose is to optimize queries and accelerate access to specific parts of XML data. We argue that this is not a valid choice: updates are too expensive in this way.</p><p>The advantages of a full index are the ability to quickly locates nodes. However, a full index has two main disadvantages: (a) inserts are expensive, and (b) storage requirements are very high. Besides the fact that the index grows in size for data-intensive applications, the vast majority of the entries will not even be used. This approach is in the way of fast updates.</p><p>A typical usage pattern will access the data based on semantic constraints, such as: insert a &lt;purchase-order&gt; element as the last child of the root (a &lt;purchase-orders&gt; element). Performing this operation means getting access to the root node and the position corresponding to its last child. The vast majority of other index entries, if this operation is repeated, will not be used. We also prove experimentally (see Section 8) a full index induces a big overhead: updates are more expensive. The lazy indexed introduces are the answer to this problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The Notion of Range</head><p>We define the notion of Range as a sequence of tokens. In the idea that a full node index cannot accommodate the entire application usage patterns, we introduce the Range as a less granular unit.</p><p>Our store defines the range as an insert unit: by populating an XML DataSource with tokens corresponding to a node we create a first range (the initial content). A successive insert of a new child, define a new range, while the existing range is split in two. The choice of the representation (tokens), as presented in Section 3, has a crucial role in making the notion of Range possible: each sequence of tokens can constitute a range. The real choice is made by the application itself.</p><p>We can draw an analogy between the implementation of relational database systems, where a Record is as a sequence of variablesized fields and our model, where a Range is a sequence of variable-sized tokens. What we add in the XML approach is that a Range is defined by the usage pattern of the application, and not by a fixed schema. In our model, we must also maintain an order between Ranges in order to preserve document order of tokens. Ranges, as also described in the previous section, are the way to obtain cheap updates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">The Range Index (Coarse-grained index)</head><p>The role of an index is to quickly locate a position in the store. The range index is to locate the range corresponding to an ID specified in an update operation. Ranges represent insert units -as opposed to a full index, which would have contained all Ids individually. The range index contains less entries, but it is also fuzzier (i.e., it refers to an interval of Identifiers instead of to a single one). The Storage level is able to retrieve a range, given its Id.</p><p>A consequence of this way to represent data is that Node Identifiers need not be stored together with the tokens they refer to. By knowing the start identifier of a Range and by successively reading successive the tokens of that range, identifiers can be generated and re-associated to the tokens they belong to. The advantage is better space utilization (low storage overhead), a valuable resource in case of variable-length IDs. Section</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">The Storage Model (revised)</head><p>Based on the existence of Ranges as the logical storage unit, the Storage level comprises chained blocks, which, at their turn, contain ordered ranges. Document order is preserved through the chaining of blocks and through the ordering of ranges inside blocks. (see <ref type="figure" target="#fig_2">Figure 3</ref>). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Functionality of the Range Index</head><p>This section presents a simple usage scenario of ranges in the store. We assume that we have on an initially empty Data Source.</p><p>The operations which are performed are:</p><p>1. Insert 2 sibling Nodes (contain 100 nodes in total)</p><p>2. Insert a child (40 nodes) as the last child of the node which is identified by 60: insertIntoLast(60,&lt;&lt;new data&gt;&gt;)</p><p>The effects on the Store are that tokens are created for the inserted data, and they are stored sequentially on the pages. Node Ids are created, but only the ranges are inserted in the Range Index.</p><p>The detailed description of the effects of each step on the Range Index are described below:</p><p>1. Allocate 100 identifiers for the inserted nodes, and create range 1 with Ids 1-100. Range 1 is stored in Block 1.    <ref type="table" target="#tab_1">Tables 2 and 3</ref> describe the configuration of the Range Index during inserts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">THE LAZY/PARTIAL INDEX</head><p>The notion of Range and that of Range Index allow us to optimize update operations: fewer entries are inserted to the range index -a big step forward in comparison to the full index approach.</p><p>The price to pay for having cheap updates is that reads become more expensive. Since the nodes cannot, in general, be accessed directly anymore (they are 'hidden' insider a certain range), additional lookups need to be performed. A full index would have been able to directly access each node. The full index has an advantage of quick lookups, but it is unacceptable because of two things: the high memory overhead and expensive update operations.</p><p>The solution to this problem is a Partial Index <ref type="bibr" target="#b17">[18]</ref>: using the advantages of the full index, but only when needed. The result of lookup operations, performed during updates is inserted in the partial index: either the range of a token, the offset of a token inside its range, the location (range, offset) of the end token of the node (i.e. node token) inside the range and the position of the end token of the node inside. With the help of this additional structure, a repeated search for the same logical position will benefit from the existence of this value in the partial index ("jump" to the end of the given node).</p><p>The partial index stores, therefore, information on the individual nodes: their exact ranges and offset inside the range (for simplicity, the example in <ref type="table" target="#tab_2">Table 3</ref> only describes the existence of the range of a token). Because this very granular functionality is the one which we try to avoid from traditional approaches, the partial index is actually a combination between a real index (such as those defined by other identifier schemes) and a cache. The combination between the Range Index and the Partial Index (see <ref type="figure">Figure 4</ref>) achieves the goal of being, adaptive, flexible and lazy in the XML world. This can be done by not trying to index everything, but only if and when needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 4: Partial Index entries enrich the coarse Range Index</head><p>Referring to the example from Section 4.5, the partial index (considered empty at the beginning), would be used as follows:</p><p>1. Inserting on an empty data source does not create entries in the Partial Index 2. Inserting a new node:</p><p>a. Locating node with Id 60 using the range index in range 1: a new entry is inserted in the partial index to idicate the range.</p><p>b. Locating the end token of the id 60. This means that after the insert, the location of the end token is the range 3: a new entry is inserted in the partial index.to indicate the range (see <ref type="table" target="#tab_3">Table 4</ref>). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">ORTHOGONALITY OF ID SCHEMES</head><p>As mentioned in the introduction, proposals for indexing and identifier schemes for XML constitute a large part of the existing research on XML <ref type="bibr" target="#b15">[16]</ref>[19][6] <ref type="bibr" target="#b18">[19]</ref>. Indexing XML data relies heavily on the fact that nodes in an XML document are assigned an identifier. In particular, update operations are expressed based on these identifiers and indexes can be build on top of them. The XQuery Data Model, which we implement, requires document order in the XML representation and unique identity of Nodes inside this representation. We use Node Is, generated at insert time, and we obtain document order by chaining blocks and maintaining order of Ranges inside blocks.</p><p>As opposed to previous approaches, our model provides a separation from the API of the application: a range can span over several nodes, or over parts of a node (represented as a sequence of tokens). Ids of nodes are, currently, orthogonal to our way of indexing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Low Storage Overhead</head><p>The Range Index is a coarse-grained index (see Section 4). This already means lower storage overhead over a full index approach. Beside its role of locating a Range in the storage, the Range Index uses properties of Ids for locating the range of a node with the given id. This functionality can be described as follows:</p><formula xml:id="formula_2">rangeIndexLocate : { ID } -&gt; { R }</formula><p>where {ID} is the set of Node identifiers in the store, and {R} is the set of all ranges in the Range Index. Currently, we achieve this by maintaining information on each <ref type="bibr">[startId, endId]</ref> interval of the ids inside a Range. Since a Range is defined as a sequence of tokens in document order, we can obtain further decrease storage overhead by only storing the Identifiers of the first node inside a range. The Id schemes with this property generate the Id of the next token ID using a simple factory function:</p><p>idFactory : {ID} X {token} -&gt; {ID} Many existing identifier schemes are compatible to our current approach, because they have the previous property. <ref type="bibr" target="#b18">[19]</ref>[17].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Stable and Comparable Identifiers</head><p>Stable identifiers are the way to build indexes on the store: such an index can be external and based on logical node identifiers. Currently, stable identifiers can be obtained by assigning unique integer number to nodes at insert times This simple approach allows us to define actual ranges of Ids (in the example of <ref type="table">Table:</ref> 1-70, 101-1). The Ids inside ranges are comparable Ids inside ranges. We can obtain a semi-stable document order at read time (since tokens are stored in document order and read sequentially).</p><p>The combination of order between ranges and order of ranges in the storage, can also be put in connection to partially-stable identifier schemes, such as those described in <ref type="bibr" target="#b18">[19]</ref>.</p><p>Ids which are both stable and fully comparable in the document order, can currently only be obtained by using a different identifier scheme (in particular <ref type="bibr" target="#b16">[17]</ref>). Further details are omitted for lack of space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">EXPERIMENTAL RESULTS</head><p>The following micro benchmarks reflect the effects of using a coarse index and a partial index, as opposed to a full index, in our representation. The identifier scheme associates unique integer values to each node, at insert time. However, only ranges become entries in the index. A memory-based partial index lazily adds information on the location of tokens inside ranges (begin and end token).</p><p>Experimental setup: our first implementation is built completely on top of a relational database system. We use Java and JDBC to define express the operations of the interface of the store. The test platform was a Pentium 4 2,8Ghz/512MB RAM, running SuSe Linux9.0, and using a MySQL as a database.</p><p>The parameters that influence the results of the benchmark are the size and number of ranges. A coarse-grained index means low update overhead but a larger overhead at read and lookup times. On the other side, an index containing many entries (even coarsegrained) also leads to performance decrease at insert time. The partial index improves reads especially in the case of more coarse-granular range sizes, as it builds entries lazily (cache-like).</p><p>The experiments involve the following micro benchmarks: Inserts, sequential reads, and random reads of small pieces of data in the presence of a full index, range index, and, respectively the combination of range index + partial index (see <ref type="table" target="#tab_4">Table 5</ref>). The metric is kilobytes/second (read speed, relative to data size). The results reflect the expected behavior: the Range Index clearly brings advantages in what regards update speed: less entries are entered the index. As the number of entries increases, however, even with smaller data quantity, the advantages diminish (many, granular entries). The Partial Index helps to achieve cheaper reads and lookups (especially when the range index is coarse). We are considering more optimizations of the read/update/storage overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">RELATED WORK</head><p>Our work bears close resemblance to existing native XML storage research[12] <ref type="bibr" target="#b10">[11]</ref>. Even though the flexible granularity is taken into consideration by the authors, the tree model of the XML data is not abstracted away but is used to define, in a similar approach, partial indexes. Other similarities to this independent research involve sequentially storing the XML data, but the notion of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>NodeID Begin Token End Token</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>60</head><p>(Range) 1 <ref type="table" target="#tab_2">(Range) 3</ref> variable-size range and varying granularity are not entirely contained in the proposed approach: element node (i.e., finegrained units) are still the storage unit in this approach. The hybrid approach taken by <ref type="bibr">Natix[15]</ref> and its tree-based model also brings ideas in the field of granularity of records, but it relies on a tree model. Logic identifiers have not been extensively studied in this research. A special mention deserves a project <ref type="bibr" target="#b2">[3]</ref> which, under the umbrella of enhancing existing identifier schemes based on containment join-based algorithms for evaluation of XPath expressions, defines the notion of 'segment' (similar to a range), as a group of elements which are treated as a single insert operation, instead of separate ones. The experiments study the effect of this coarse-granular unit, especially as the segments increase in number. Their performance is degraded because of the eager approach to indexing the content of the segment (group of elements) define lazily. Other approaches try to take adaptive and laziness in XML processing, but in the field on queries and path evaluation <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSIONS AND FUTURE WORK</head><p>This paper described a data representation and model of an XML store, inspired by the notion of records in relational databases. The immediate advantages are independence of our data format from the API used by the XML application, and the possibility to adapt to the application pattern. The store achieves this by lazily creating its storage and index structures and optimizes for reads or updates according to the how the application focuses on one or the other. The process is transparent to the application.</p><p>Our approach to XML Storage involves an exploration of a number of design options. We are currently evaluating experimentally the effects of variable-sized ranges as logical unit for XML data representation. The effect of functionality of the partial index is also to be taken into account. Structural properties of the actual elements of the XQuery DataModel, such as hierarchical or sibling relationships can also be maintained by the Partial Index.</p><p>Another aspect to explore, not addressed here, is concurrency. The flat model proposed in this paper allows the definition of these concepts on a three-layer architecture: blocks, ranges and tokens. Again, the principles of storage already defined in the context by relational database systems, have an immediate application here. The issue that differs from the relational world is the necessity to always maintain the order between ranges. This is ongoing work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>2 .</head><label>2</label><figDesc>Support for XUpdate 3. Allow optimization of reads and/or updates. 4. Indexes 5. Support different Node Identifier schemes. In particular,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 : An XML Data instance is represented by a sequence of tokens</head><label>2</label><figDesc>Figure 2: An XML Data instance is represented by a sequence of tokens</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 : The XML Data Instance as a sequence of ranges, and the Range Index</head><label>3</label><figDesc>Figure 3: The XML Data Instance as a sequence of ranges, and the Range Index</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>2 .</head><label>2</label><figDesc>Insertion of the child : a. Locate second node using the Range index (id 60 is in range 1) b. Locate range and offset of the end token of the node with the Id 60. c. Split range number 1 in two (create range 3) d. Create a new range corresponding to the inserted data (2), and allocate 40 unique identifiers e. Store the new range (Block 1) and insert the split range in the storage. (Blocks 2).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Interface of the store. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 2 .</head><label>2</label><figDesc></figDesc><table>Range Index (Coarse index) with an initial range. 

RangeId 
BlockId 
StartId 
EndId 

1 
1 
1 
100 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 3 .</head><label>3</label><figDesc></figDesc><table>The Range Index (Coarse index) after an insert 
(nodes 101-140, range 2) and split of range 1. 

RangeId 
BlockId 
StartId 
EndId 

1 
1 
1 
70 

2 
1 
101 
140 

3 
2 
71 
100 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 4 :</head><label>4</label><figDesc></figDesc><table>The Partial Index (Granular) after the second insert: 
lookup positions have been memorized 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 5 :</head><label>5</label><figDesc></figDesc><table>Experimental results: Lazy indexing in XML storage 

Indexing approach 
Insert 
(kb/s) 

Seq.scan 
(kb/s) 

Random 
reads (kb/s) 

Full Index 
(max.granularity) 
27,91 
1298,59 
672,22 

Range Index 
(many, granular entries) 
97,07 
1333,47 
136,98 

Range Index 
(few, coarse, large entries) 
91,03 
1333,47 
33,41 

Range Index 
(few, coarse, large entries) 
+ Partial Index (memory) 

182,32 1333,47 
994,36 

</table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Al-Khalifa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D.; Yuqing</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wu</surname></persName>
		</author>
		<title level="m">Structural joins: a primitive for efficient XML query pattern matching ICDE</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">XQuery 1.0 An XML Query Language, W3C Working Draft</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename><surname>Boag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Chamberlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Robie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Simeon</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Xiaoling Wang Lazy XML Updates: Laziness as a Virtue of Update and Structural Join Efficiency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Catania</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chin</forename><surname>Beng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenqiang</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005-06" />
			<publisher>ACM SIGMOD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">APEX : An adaptive path index for XML data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chin-Wan Chung J.-K</forename><forename type="middle">M</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Shim</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-06" />
			<publisher>ACM SIGMOD</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Derose</surname></persName>
		</author>
		<title level="m">XML Path Language (XPath), Version 1.0. W3C Recommandation</title>
		<imprint>
			<date type="published" when="2000-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tova</forename><surname>Haim Kaplan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Milo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Labeling Dynamic XML Trees. PODS</title>
		<imprint>
			<biblScope unit="page" from="271" to="299" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The BEA/XQRL streaming XQuery processor</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hillery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kossmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lucas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Riccardi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Westmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Carey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sundararajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Agrawal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Very Large Databases (VLDB)</title>
		<meeting>International Conference on Very Large Databases (VLDB)<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-09" />
			<biblScope unit="page" from="997" to="1008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Storing and Querying XML Data using an RDBMS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kossmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Data Engineering Bulletin</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Accelerated XPath location steps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Grust</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMOD</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="795" to="825" />
			<date type="published" when="2002-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">ROX:Relational Over XML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Halverson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Josifovski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lohman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Pirahesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moerschel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Fine-Grained Management of Natively Stored XML Documents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Haustein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Härder</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>Submitted</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Adjustable Transaction Isolation in XML Database Management Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Haustein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Theo</forename><surname>Härder</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="173" to="188" />
			<pubPlace>XSym</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Lock-based protocols for cooperation on XML documents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Helmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">C</forename><surname>Kanne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Moerkotte</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
		<respStmt>
			<orgName>the University of Mannheim</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Timber: A native XML database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jagdish</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003-06" />
			<publisher>ACM SIGMOD</publisher>
			<biblScope unit="page">672</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient storage of XML data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">C</forename><surname>Kanne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Moerkotte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE International Conference on Data Engineering (ICDE)</title>
		<meeting>IEEE International Conference on Data Engineering (ICDE)</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Indexing and querying xml data for regular path expressions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2001-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O&amp;apos;neil</forename><surname>Patrick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Elizabeth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>O&amp;apos;neil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shankar</forename><surname>Pal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Istvan</forename><surname>Cseri</surname></persName>
		</author>
		<title level="m">ORDPATHs: Insert-Friendly XML Node Labels. SIGMOD Conference</title>
		<meeting><address><addrLine>Gideon Schaller, Nigel Westbury</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The case for partial indexes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Stonebraker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="4" to="11" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Storing and Querying Ordered XML using a Relational DBMS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Tatarinov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">World Wide Web Consortium</title>
	</analytic>
	<monogr>
		<title level="m">Extensible Markup Languag (XML). W3C Recommendation</title>
		<imprint>
			<date type="published" when="1998-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">World Wide Web Consortium. Document Object Model (DOM) Level 3 Core Specification. W3C Recommendation</title>
		<imprint>
			<date type="published" when="2001-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">World Wide Web Consortium. XQuery 1.0 and XPath 2.0 Data Model, W3C Working Draft</title>
		<imprint>
			<date type="published" when="2005-04" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
