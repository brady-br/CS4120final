<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T01:50+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">xJS: Practical XSS Prevention for Web Application Development</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elias</forename><surname>Athanasopoulos</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science</orgName>
								<orgName type="institution" key="instit1">Foundation for Research and Technology -Hellas</orgName>
								<orgName type="institution" key="instit2">Microsoft Research</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vasilis</forename><surname>Pappas</surname></persName>
							<email>vpappas@ics.forth.gr</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science</orgName>
								<orgName type="institution" key="instit1">Foundation for Research and Technology -Hellas</orgName>
								<orgName type="institution" key="instit2">Microsoft Research</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antonis</forename><surname>Krithinakis</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science</orgName>
								<orgName type="institution" key="instit1">Foundation for Research and Technology -Hellas</orgName>
								<orgName type="institution" key="instit2">Microsoft Research</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Spyros</forename><surname>Ligouras</surname></persName>
							<email>ligouras@ics.forth.gr</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science</orgName>
								<orgName type="institution" key="instit1">Foundation for Research and Technology -Hellas</orgName>
								<orgName type="institution" key="instit2">Microsoft Research</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evangelos</forename><forename type="middle">P</forename><surname>Markatos</surname></persName>
							<email>markatos@ics.forth.gr</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science</orgName>
								<orgName type="institution" key="instit1">Foundation for Research and Technology -Hellas</orgName>
								<orgName type="institution" key="instit2">Microsoft Research</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Karagiannis</surname></persName>
							<email>thomas.karagiannis@microsoft.com</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science</orgName>
								<orgName type="institution" key="instit1">Foundation for Research and Technology -Hellas</orgName>
								<orgName type="institution" key="instit2">Microsoft Research</orgName>
								<address>
									<settlement>Cambridge</settlement>
									<country key="GB">United Kingdom</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">xJS: Practical XSS Prevention for Web Application Development</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We present xJS, a practical framework for preventing code-injections in the web environment and thus assisting for the development of XSS-free web applications. xJS aims on being fast, developer-friendly and providing backwards compatibility. We implement and evaluate our solution in three leading web browsers and in the Apache web server. We show that our framework can successfully prevent all 1,380 real-world attacks that were collected from a well-known XSS attack repository. Furthermore, our framework imposes negligible computational overhead in both the server and the client side, and has no negative side-effects in the overall user&apos;s browsing experience.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Code-injection attacks through Cross-Site Scripting (XSS) in the web browser have observed a significant increase over the previous years. According to a September-2009 report published by the SANS Institute <ref type="bibr" target="#b34">[34]</ref>, attacks against web applications constitute more than 60% of the total attack attempts observed on the Internet. Web application vulnerabilities such as SQL injection and Cross-Site Scripting flaws in open-source as well as custom-built applications account for more than 80% of the vulnerabilities being discovered. XSS threats are not only targeted towards relatively simple, small-business web sites, but also towards infrastructures that are managed and operated by leading IT vendors <ref type="bibr" target="#b1">[2]</ref>. Moreover, recently widely adopted technologies, such as AJAX <ref type="bibr" target="#b15">[15]</ref>, exacerbate potential XSS vulnerabilities by promoting richer and more complex client-side interfaces. This added complexity in the web browser environment provides additional opportunities for further exploitation of XSS vulnerabilities.</p><p>Several studies have proposed mechanisms and architectures based on policies, communicated from the web server to the web browser, to mitigate XSS attacks. The current state of the art includes XSS mitigation schemes proposing whitelisting of legitimate scripts <ref type="bibr" target="#b17">[17]</ref>, utilizing randomized XML namespaces for applying trust classes in the DOM <ref type="bibr" target="#b16">[16]</ref>, or detecting code injections by examining modifications to a web document's original DOM structure <ref type="bibr" target="#b26">[26]</ref>. While we believe that the aforementioned techniques are promising and in the right direction, they have weaknesses and they fail in a number of cases. As we show in this paper, whitelisting fails to protect from attacks that are based on already whitelisted scripts, while DOM-based solutions fail to protect from attacks where the DOM tree is absent <ref type="bibr" target="#b7">[7]</ref>.</p><p>To account for these weaknesses, in this paper, we propose xJS, which is a practical and simple framework that isolates legitimate client-side code from any possible code injection. Our contributions are thus twofold: i) we describe, implement and evaluate xJS and ii) we outline limitations of previous methodologies and a number of attacks that defeat existing approaches.</p><p>Our framework could be seen as a fast randomization technique. Instruction Set Randomization (ISR) <ref type="bibr" target="#b20">[20]</ref> has been proposed for defending against code injections in native code or in other environments, such as code executed by databases <ref type="bibr">[9]</ref>. However, we believe that adapting ISR to deal with XSS attacks is not trivial. This is because web client-side code is produced by the server and is executed in the client; the server lacks all needed functionality to manipulate the produced code. For example, randomizing the JavaScript instruction set in the web server requires at least one full JavaScript parser running at the server. Thus, instead of blindly implementing ISR for JavaScript, our design introduces Isolation Operators, which transpose all produced code in a new isolated domain. In our case, this is the domain defined by the XOR operator.</p><p>We design xJS with two main properties in mind:</p><p>â€¢ Backwards Compatibility. We aim for a practical, developer-friendly solution for constructing secure web applications and we ensure that the scheme 1:&lt;div&gt; 1:&lt;div&gt; 2:&lt;img onload=''render();''&gt;2:&lt;img onload=''AlCtV...''&gt; 3:&lt;script&gt; 3:&lt;script&gt; 4:alert(''Hello World''); 4: vpSUlJTV2NHGwJyW/NHY... 5:&lt;script&gt; 5:&lt;/script&gt; 6:&lt;/div&gt; 6:&lt;/div&gt; <ref type="figure">Figure 1</ref>: Example of a web page that is generated by our framework.</p><p>provides backwards compatibility. xJS allows web servers to communicate to web browsers when the scheme is enabled or not. A web browser not supporting the framework may still render web applications, albeit without providing any of the security guarantees of xJS.</p><p>â€¢ Low Computation Overhead. Our design avoids the additional overhead of applying ISR in both web server and client, which would significantly increase the computational overheads. This is because the web code would be parsed twice (one in the server during serving and one in the client during execution). Instead, the isolation operator introduced in xJS applies the XOR function to the whole source corpus of all legitimate client-side code. Thus, the randomization process is fast, since XOR exists as a CPU instruction in all modern hardware platforms, and does not depend on any particular instruction set.</p><p>We implement and evaluate our solution in three leading web browsers namely FireFox, WebKit <ref type="bibr" target="#b0">1</ref> and Chromium, and in the Apache web server.</p><p>Our evaluation shows that xJS can successfully prevent all 1,380 attacks of a well-known repository <ref type="bibr" target="#b14">[14]</ref>, imposes at the same time negligible computational overhead in the server and in the client side. Finally, our modifications appear to have no negative side-effects in the user web browsing experience. To examine user-perceived performance, we examine the behavior of xJS-enabled browsers through a leading JavaScript benchmark suite <ref type="bibr" target="#b2">[3]</ref>, which produces the same performance results in both the xJS-enabled and the original web browsers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The xJS Framework</head><p>The fundamental concepts of our framework are Isolation Operators and Action Based Policies in the browser environment. We review each of these concepts in this section and, finally, we provide information about our implementation prototypes.</p><p>xJS is a framework that can address XSS attacks carried out through JavaScript. However, our basic concept can be also applied to other client-side technologies, such as Adobe Flash. The basic properties of the proposed framework can be summarized in the following points.</p><p>â€¢ xJS prevents JavaScript code injections that are based on third party code or on code that is already used by the trusted web site.</p><p>â€¢ xJS prevents execution of trusted code during an event that is not scheduled for execution. Our framework guarantees that only the web site's code will be executed and only as the site's logic defines it.</p><p>â€¢ xJS allows for multiple trust-levels depending on desired policies. Thus, through xJS, parts of a web page may require elevated trust levels or further user authentication to be executed.</p><p>â€¢ xJS in principle prevents attacks that are based on injected data and misuse of the JavaScript eval() function. We discuss eval() semantics in detail in Sections 4 and 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Isolation Operators</head><p>xJS is based on Instruction Set Randomization (ISR), which has been applied to native code <ref type="bibr" target="#b20">[20]</ref> and to SQL <ref type="bibr">[9]</ref>. The basic concept behind ISR is to randomize the instruction set in such a way so that a code injection is not able to speak the language of the environment <ref type="bibr" target="#b21">[21]</ref> and thus is not able to execute. In xJS, inspired by ISR, we introduce the concept of Isolation Operators (IO). An IO essentially transposes a source corpus to a new isolated domain. In order to de-isolate the source from the isolated domain a unique key is needed. This way, the whole source corpus, and not just the instruction set, is randomized. Based on the above discussion, the basic operation of xJS is the following. We apply an IO such as the XOR function to effectively randomize and thus isolate all JavaScript source of a web page. The isolation is achieved since all code has been transposed to a new domain: the XOR domain. The IO is applied by the web server and all documents are served in their isolated form. To render the page, the web browser has to deisolate the source by applying again the IO and then execute it.</p><p>Note that, in xJS, we follow the approach of randomizing the whole source corpus and not just the instruction set as in the basic ISR concept. We proceed with this choice since the web code is produced in the web server and it is executed in the web browser. In addition, the server lacks all needed functionality to manipulate the produced code. For example, randomizing the JavaScript instruction set needs at least one full JavaScript parser running at the server. This can significantly increase the computational overhead and userperceived latency, since the code would be parsed twice (one in the server during serving and one in the client during execution). However, the isolation can break web applications that explicitly evaluate dynamic JavaScript code using eval(). In that case, the web developer must use a new API, xeval(), since xJS alters the semantics of eval(). We further discuss this in Section 5. Finally, we select XOR as the IO because it is in general considered a fast process; all modern hardware platforms include a native implementation of the XOR function. However, our framework may be applied with any other IO. <ref type="figure">Figure 1</ref> depicts an xJS example. On the left, we show the source code as it exists in the web server and on the right, we provide the same source as it is fetched by the web browser. The JavaScript source has been XORed and a Base64 <ref type="bibr" target="#b18">[18]</ref> encoding has been applied in order to transpose all non-printable characters to the printable ASCII range.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Action Based Policies</head><p>xJS allows for multiple trust-levels for the same web site depending on the desired operation. In general, our framework suggests that policies should be expressed as actions. Essentially, all trusted code should be treated using the policy "de-isolate and execute". For different trust levels, multiple IOs can be used or the same IO can be applied with a different key. For example, portions of client-side code can be marked with different trust levels. Each portion will be isolated using the XOR function, but with a different key. The keys are transmitted in HTTP headers (see the use of X-IO-Key, later in this section) every time the server sends the page to the browser.</p><p>Expressing the policies in terms of actions has the following benefit. The injected code cannot bypass the policy, unless it manages to produce the needed result after the action is applied to it. The latter is considered practically very hard, even for trivial actions such as the XOR operation. One possible direction for escaping the policy is using a brute force attack. However, if the key is large enough the probability to succeed is low.</p><p>Defining the desired policy set is out of the scope of this paper. For the purpose of our evaluation (see Section 4) we use one policy, which is expressed as "deisolate (apply XOR) and execute". Other example policies can be expressed as "de-isolate and execute under user confirmation", "de-isolate with the X key and execute", etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Implementation</head><p>Browser Modifications. All three modified web browsers operate in the following way. A custom HTTP header field, X-IO-Key, is identified in each HTTP response. If the key is present, this is an indication that the web server supports the framework, and the field's value denotes the key for the de-isolation process. This is also a practical way for incremental deployment of the framework in a backwards compatible fashion. At the moment, we do not support multiple keys, but extending the browser with such a feature is considered trivial. On the other hand, the web browser communicates to the web server that it supports the framework using an Accept 2 header field for every HTTP request.</p><p>As far as WebKit and Chromium are concerned, we had to modify two separate functions. First, the function that handles all events (such as onload, onclick, etc.), and second, the function that evaluates a JavaScript code block. We modified these functions to (i) decode all source using Base64 and (ii) apply the XOR operation with the de-isolation key (the one transmitted in X-IO-Key) to each byte. FireFox has a different design. It also uses two functions, one for compiling a JavaScript function and one for compiling a script. However, these functions operate recursively. We further discuss this issue in Section 4.</p><p>Server Modifications. For the server part of xJS we are taking advantage of the modular architecture of the Apache web server. During Apache's start-up phase all configuration files are parsed and modules that are concerned with processing an HTTP request are loaded. The main processing unit of the apache web server is the content generator module. A module can register content generators by defining a handler that is configurable by using the SetHandler or AddHandler directives. These can be found in Apache's configuration file (httpd.conf).</p><p>Various request phases that precede the content generator exist. They are used to examine and possibly manipulate some request headers, or to determine how the request will be handled. For example the request URL will be matched against the configuration, because a certain content generator must be used. In addition the request URL may be mapped to a static file, a CGI script or a dynamic document according to the content generator's operation. Finally after the content generator has sent a reply to the browser, Apache logs the request.</p><p>Apache (from version 2 and above) also supports filters. Consider the filter chain as a data axis, orthogonal to the request processing axis. The request data may be processed by input filters before reaching the content generator. After the generator has finished generating the response various output filters may process it before being sent to the browser.We have created an Apache module which operates as a content generator. For every request, that corresponds to an HTML file in the disk, the file is fetched and processed by our module. The file is loaded in memory and stored in a buffer. The buffer is transfered to an HTML parser (based on the HTMLParser module from libxml2 <ref type="bibr" target="#b39">[39]</ref>). This is an HTML 4.0 non-verifying parser with API compatible with the XML parser ones. When the parsing is done our module traverses the parser's XML nodes in memory and searches for all nodes that contain JavaScript (&lt;script&gt; nodes and events). If there is a match the XOR operation is applied using the isolation key to each byte of the JavaScript source. Finally all source is encoded in Base64.</p><p>After encoding all possible JavaScript source in the web page, the buffer is sent to the next operating module in the chain; this might be an output filter or the web browser. Implementing xJS as a content generator module has the benefit of isolating by encryption all JavaScript source before any dynamic content, which might include XSS attacks, is inserted. Our framework can cooperate with other server-side technologies, such as PHP, in two ways: (a) by using two Apache's servers (one running xJS and the other one the PHP module) and (b) by configuring PHP to run as a filter. All evaluation results presented in Section 4 are collected using the second setup.</p><p>Secret Key. The secret key that is used for the XOR operation is a string of random alphanumeric characters. The length of the string can be arbitrary. For all experiments presented in this paper a two-character string is used. Assuming that S l is the JavaScript source of length l and K L is the secret key of length L, the encoding works as follows:</p><formula xml:id="formula_0">Enc(S i ) = S i âŠ• K (i % L) , 0 &lt; i &lt; l.</formula><p>It is implied that the ASCII values of the characters are used. The secret key is refreshed per request. We do not consider Man-in-the-Middle (MiM) attacks, since during a MiM an attacker can alter the whole JavaScript source without the need of an injection through XSS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Attacks Covered</head><p>In this section we present a new form of XSS attack, which we refer to as return-to-JavaScript attack, in analogy with the return-to-libc attack in native code. This kind of XSS attack can escape script whitelisting, used by existing XSS mitigation schemes. We further highlight some important issues for DOM-based XSS mitigation schemes. All the attacks listed in this section can be successfully prevented by xJS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">return-to-JavaScript Attacks</head><p>A practical mitigation scheme for XSS attacks is script whitelisting, proposed in BEEP <ref type="bibr" target="#b17">[17]</ref>. BEEP works as follows. The web application includes a list of cryptographic hashes of valid (trusted) client-side scripts. The browser, using a hook, checks upon execution of a script if there is a cryptographic hash in the whitelist. If the hash is found, the script is considered trusted and executed by the browser. If not, the script is considered nontrusted and the policy defines whether the script may be rendered or not. Script whitelisting is not sufficient. Despite its novelty, we argue here that simple whitelisting may not prove to be a sufficient countermeasure against XSS attacks. To this end, consider the following.</p><p>Location of trusted scripts. As a first example, note that BEEP does not examine the script's location inside the web document. Consider the simple case where an attacker injects a trusted script, initially configured to run upon a user's click (using the onclick action), to be rendered upon document loading (using the onload 3 action). In this case the script will be executed, since it is already whitelisted, but not as intended by the original design of the site; the script will be executed upon site loading and not following a user's click. If, for example, the script deletes data, then the data will be erased when the user's browser loads the web document and not when the user clicks on the associated hyperlink.</p><p>Exploiting legitimate whitelisted code. Attacks may be further carried out through legitimate white-listed code. XSS attacks are typically associated with injecting arbitrary client-side code in a web document, which is assumed to be foreign, i.e., not generated by the web server. However, it is possible to perform an XSS attack by placing code that is generated by the web server in different regions of the web page. This attack resembles the classic return-to-libc attack <ref type="bibr" target="#b11">[11]</ref> in native code applications and thus we refer to as return-to-JavaScript. Return oriented programming suggests that an exploit may simply transfer execution to a place in libc 4 , which may cause again execution of arbitrary code on behalf of the attacker. The difference with the traditional buffer overflow attack <ref type="bibr" target="#b29">[29]</ref> is that the attacker has not injected any foreign code in the program. Instead, she transfers execution to a point that already hosts code that can assist her goal. A similar approach can be used by an attacker to escape whitelisting in the web environment. Instead of injecting her own code, she can take advantage of existing whitelisted code available in the web site. Note that, typically, a large fraction of client-side code is not executed upon document loading, but is triggered during user events, such as mouse clicks. Below we enumerate some possible scenarios for XSS attacks based on whitelisted code, which can produce (i) annoyance, (ii) data loss and (iii) complete takeover of a web site.</p><p>Annoyance. Assume the blog site shown in <ref type="figure" target="#fig_0">Figure 2</ref>. The blog contains a JavaScript function logout(), which is executed when the user clicks the corresponding hyperlink, Logout (line 4 in <ref type="figure" target="#fig_0">Fig. 2</ref>). An attacker could perform an XSS attack by placing a script that calls logout() when a blog entry is rendered (see line 7 in <ref type="figure" target="#fig_0">Fig. 2)</ref>. Hence, a user reading the blog story will be forced to logout. In a similar fashion, a web site that uses JavaScript code to perform redirection (for example using window.location.href = new-site) can be also attacked by placing this whitelisted code in an onload event (see line 8 in <ref type="figure" target="#fig_0">Fig. 2)</ref>.</p><p>Data Loss. A web site hosting user content that can be deleted using client-side code can be attacked by injecting the whitelisted deletion code in an onload event (see line 9 in <ref type="figure" target="#fig_0">Fig. 2</ref>). AJAX <ref type="bibr" target="#b15">[15]</ref> interfaces are popular in social networks such as Facebook.com and MySpace.com. This attack can be considered similar to a SQL injection attack <ref type="bibr" target="#b5">[5]</ref>, since the attacker is implicitly granted access to the web site's database.</p><p>Complete Takeover. Theoretically, a web site that has a full featured AJAX interface can be completely taken over, since the attacker has all the functionality she needs a-priori whitelisted by the web server. For example, an ebanking site that uses a JavaScript transact() function for all the user transactions is vulnerable to XSS attacks that perform arbitrary transactions.</p><p>A workaround to mitigate the attacks presented above is to include the event type during the whitelisting process. Upon execution of script S1, which is triggered by an onclick event, the browser should check the whitelist for finding a hash key for S1 associated with an onclick event. However, this can mitigate attacks which are based on using existing code with a different event type than the one initially intended to by the web programmer. Attacks may still happen. Consider the Data Loss scenario described above, where an attacker places the deletion code in onclick events associated with new web document's regions. The attacker achieves to execute legitimate code upon an event which is not initially scheduled. Although the attacker has not injected her own code, she manages to escape the web site's logic and associate legitimate code with other user actions. Attacks against whitelisting, based on injecting malicious data in whitelisted scripts, have been described in <ref type="bibr" target="#b26">[26]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">DOM-based Attacks</head><p>There is a number of proposals <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b26">26,</ref><ref type="bibr" target="#b13">13]</ref> against XSS attacks, which are based on information and features provided by DOM <ref type="bibr" target="#b24">[24]</ref>. Every web document is rendered according to DOM, which represents essentially its esoteric structure. This structure can be utilized in order to detect or prevent XSS attacks. One of the most prominent and early published DOM-based techniques is DOM sandboxing, introduced originally in BEEP.</p><p>DOM sandboxing works as follows. The web server places all scripts inside div or span HTML elements that are attributed as trusted. The web browser, upon rendering, parses the DOM tree and executes client-side scripts only when they are contained in trusted DOM elements. All other scripts are marked as non-trusted and they are treated according to the policies defined by the web server. We discuss here in detail three major weaknesses of DOM sanbdoxing as an XSS mitigation scheme: (i) element annotation and (ii) DOM presence.</p><p>Element annotation. Enforcing selective execution in certain areas of a web page requires identification of those DOM elements that may host untrusted code or parts of the web application's code that inject unsafe content. This identification process is far from trivial, since the complexity of modern web pages is high, and web applications are nowadays composed of thousands lines of code. To support this, in <ref type="table">Table 1</ref> we highlight the number of script, div and span elements of a few representative web page samples. Such elements can be in the order of thousands in modern web pages. While there is active research to automate the process of marking untrusted data <ref type="bibr" target="#b35">[35,</ref><ref type="bibr" target="#b23">23]</ref> or to discover taint-style vulnerabilities <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b25">25]</ref>, we believe that, currently, the overhead of element annotation is prohibitive, and requires, at least partially, human intervention. On the contrary, xJS does not require taint-tracking or program analysis to identify trusted or untrusted parts of a web document or a web application.  <ref type="table">Table 1</ref>: Element counts of popular home pages indicating their complexity.</p><p>DOM presence. All DOM-based solutions require the presence of a DOM tree. However, XSS attacks do not always require a DOM tree to take place. For example, consider an XSS attack which bypasses the contentsniffing algorithm of a browser and is carried within a PostScript file <ref type="bibr" target="#b7">[7]</ref>. The attack will be launched when the file is previewed, and there is high probability that upon previewing there will be no DOM tree to surround the injected code. As browsers have been transformed to a generic preview tool, we believe that variants of this attack will manifest in the near future.</p><note type="other">1: &lt;html&gt; 2: &lt;head&gt; &lt;title&gt; Blog! &lt;/title&gt; &lt;head&gt; 3: &lt;body&gt; 4: &lt;a onclick="logout();"&gt;Logout&lt;/a&gt; 5:</note><p>&lt;div class="blog_entry" id="123"&gt; {...} &lt;input type="button" onclick="delete(123)"&gt;&lt;/div&gt; 6: &lt;div class="blog_comments"&gt; &lt;ul&gt; 7:</p><p>&lt;li&gt; &lt;img onload="logout();" src="logo.gif"&gt; 8:</p><p>&lt;li&gt; &lt;img onload="window.location.href='http://www.google.com';" src="logo.gif"&gt; 9:</p><p>&lt;li&gt; &lt;img onload="delete(123);"&gt; 10: &lt;/div&gt; 11: &lt;a onclick="window.location.href='http://www.google.com';"&gt;Google&lt;/a&gt; 12: &lt;/body&gt; 13:&lt;/html&gt; Another example is the unofficially termed DOMBased XSS or XSS of the Third Kind attacks <ref type="bibr" target="#b22">[22]</ref>. This XSS type alters the DOM tree of an already rendered page. The malicious XSS code does not interact with the sever in any way. In such an attack, the malicious code is embedded inside a URI after the fragment identifier. <ref type="bibr" target="#b5">5</ref> This means that the malicious code (a) is not part of the initial DOM tree and (b) is never transmitted to the server. Unavoidably, DOM-based solutions <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b26">26]</ref> that define trust classes in the DOM tree at server side will fail. The exploit will never reach the server and, thus, never be associated with or contained in a trust class.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Attacks Not Addressed</head><p>xJS aims on protecting against XSS attacks that are based on JavaScript injections. The framework is not designed for providing defenses against iframe injections and drive-by downloads <ref type="bibr" target="#b30">[30]</ref>, injections that are non-JavaScript based (for example, through arguments passed in Flash objects) and Phishing <ref type="bibr" target="#b12">[12]</ref>. However, some fundamental concepts of xJS can be possibly applied to non-JavaScript injections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Evaluation</head><p>In this section we evaluate the xJS prototype. Our evaluation seeks to answer four questions: (a) how many real XSS attacks can be prevented, (b) what the overhead on the server is, (c) what the overhead on the web browser is and, finally, (d) if the framework imposes any sideeffects in the user's browsing experience.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Attack Coverage</head><p>We first evaluate the effectiveness of the xJS framework to prevent real-world XSS attacks. xJS aims on preventing traditional XSS attacks, as well as the XSS attacks described in Section 3.</p><p>Real-world exploits. To verify that xJS can cope with real-world XSS exploits, we use the repository hosted by XXSed.com <ref type="bibr" target="#b14">[14]</ref> which includes a few thou- <ref type="bibr" target="#b5">5</ref> For more details about the fragment identifier, we refer the reader to http://www. <ref type="bibr">w3</ref>.org/DesignIssues/Fragment.html. sands of XSS vulnerable web pages. This repository has been also used for evaluation in other papers <ref type="bibr" target="#b26">[26]</ref>. The evaluation of the attack coverage through the repository is not a straightforward process. First, XSSed.com mirrors all vulnerable web pages with the XSS code embedded in their body. Some of them have been fixed after the publication of the vulnerability. These updated pages cannot be of use, since xJS prevents the code injection before it takes place and there is no way for us to have a copy of the original vulnerable web page (without the XSS code in its body). Second, we have no access to the vulnerable web server and, thus, we cannot use our server-side filter for the evaluation.</p><p>To address the aforementioned limitations, we conduct the evaluation as follows. First, we resolve all web sites that are still vulnerable. To this end, we download all 10,154 web pages listed in XSSed.com, along with their attack vectors. As the attack vector we define the URL along with the parameters that trigger the vulnerability. <ref type="bibr" target="#b6">6</ref> Since XSS attacks that are based on a redirection without using any JavaScript cannot be addressed by xJS, we remove all such cases. Thus, we exclude 384 URLs that have an iframe as attack vector, 416 URLs that have a redirection to XSSed.com as attack vector and 60 URLs that have both an iframe and a redirection to XSSed.com as attack vector.</p><p>After this first pre-processing stage, the URL set contains all web pages that were vulnerable at some period in time and their vulnerability can be triggered using JavaScript; for example, the attack vector contains a call to the alert() function. We then exclude from the set all web-pages for which their vulnerability has been fixed after it became public in XSSed.com. To achieve this, we request each potentially vulnerable page through a custom proxy server we built using BeautifulSoup <ref type="bibr" target="#b31">[31]</ref>. The task of the proxy is to attach some JavaScript code that overrides the alert() function with a URL request to a web server located in our local network. Since all attack vectors are based on the alert() function the web server recorded all successful attacks in its access logs. Using this methodology we manage to identify 1,381 web pages which are still vulnerable as of early September 2009. Our methodology suggests that about 1 in 9 web pages have not been fixed even after the vulnerability was published.</p><p>We use the remaining 1,381 pages as our final testing set. Since we cannot install our modified Apache in each of the vulnerable web sites, we use our proxy for simulating the server-side portion of xJS. More precisely, for each vulnerable page, we request the vulnerable document through our proxy with a slightly altered vector. For example, for the following attack vector, http://site.com/page? id=&lt;script&gt;alert("XSS");&lt;/script&gt; the proxy instead requests the URL, http://site.com/page? id=&lt;xscript&gt;alert("XSS");&lt;/xscript&gt;.</p><p>Notice that the script tag has been modified to xscript. Using this methodology, we manage to build all vulnerable web pages with the attack vector embedded but not in effect. However, the JavaScript code contained in the web document is not isolated. Thus, the next step is to force the proxy to parse all web documents and apply the XOR function to the JavaScript code. At this point, all vulnerable web pages have the JavaScript code isolated and the attack vector defunct. Hence, the last step is to re-enable the attack vector by replacing the xscript with script and return the web page to the browser. All web pages also include some JavaScript code responsible for the alert() overloading. This code modifies all alert() calls to perform a web request to a web server hosted in our local network. If our web server records requests, the alert() function is called or, in other words, the XSS exploit run.</p><p>To summarize the above process, our experiment to evaluate the efficacy of the xJS framework is the following. We request each web page from the collected set which includes 1,381 still vulnerable web pages through a custom proxy that performs all actions described above. All web pages are requested using a modified Firefox. We select the modified Firefox in Linux, because it is easier to instrument through a script. We manually tested a random sample of attacks with modified versions of WebKit and Chromium and recorded identical behavior.</p><p>After Firefox has requested all 1,381 vulnerable pages through our custom proxy, we inspect our web server's logs to see if any of the XSS attacks succeeded. Our web server recorded just one attack. We carefully examined manually this particular attack and found out that it is a web page that has the XSS exploit stored inside its body and not in its attack vector <ref type="bibr" target="#b4">[4]</ref>. The particular attack succeeded just as a side-effect of our evaluation methodology. If xJS were deployed in the vulnerable web server, this particular attack would also have been prevented. Hence, all 1,380 real-world XSS attacks were prevented successfully by our framework.</p><p>Attacks presented in Section 3. For the attacks presented in Section 3, since to our knowledge they have not been observed in the wild yet, we performed various custom attack scenarios using a popular web framework, Ruby on Rails <ref type="bibr" target="#b37">[37]</ref>. We created a vulnerable blog and then installed the vulnerable blog service to a modified Apache server and browsed the blog using all three modified web browsers. As expected, in all cases, xJS succeeded in preventing the attacks.</p><p>We now look at specific attacks such as the ones based on a code injection in data and the careless use of eval(). The injected code is in plain text (nonisolated), but unfortunately it is attached to the isolated code after the de-isolation process. The injected code will be executed as if it is trusted. However, there is a way to prevent this. In fact, the internal design of Firefox gives us this feature with no extra cost. Firefox uses a js CompileScript() function in order to compile JavaScript code. The design of this function is recursive and it is essentially the implementation of the actual eval() function of JavaScript. When Firefox identifies the script eval($ GET('id'));, de-isolates it, calls the eval() function, which in principle calls itself in order to execute the $ GET('id') part. At the second call, the eval() again de-isolates the $ GET('id') code, which is in plain text. The second de-isolation process fails and thus the code does not execute.</p><p>Our Firefox implementation can address this type of attack. WebKit and Chromium must be further modified to support this functionality. We have successfully implemented this process in Chromium after a small amount of code changes. However, this modification affects the semantics of eval(). For a more detailed discussion, please see Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Server Overhead</head><p>We now measure the overhead imposed on the server by xJS. To this end, we request a set of web pages that embed a significant amount of JavaScript. We choose to use the SunSpider suite <ref type="bibr" target="#b2">[3]</ref> for this purpose. The SunSpider suite is a collection of JavaScript benchmarks that ship with WebKit and measure the performance of JavaScript engines. It is composed of nine different groups of programs that perform various complex operations. We manually select three JavaScript tests from the SunSpider suite. The heavy test involves string operations with many lines of JavaScript. This is probably the most Figure 4: Server side evaluation when the Apache benchmark tool (ab) is requesting each web page through a DSL link. In the worst case (heavy) the server imposes a fixed delay of a few tens of milliseconds, like in the case of the Fast Ethernet setup (see <ref type="figure" target="#fig_1">Figure 3)</ref>. However, this delay does not dominate the overall delivery time.</p><p>processing-intensive test in the whole suite, composed of many lines of code. The normal test includes a typical amount of source code like most other tests that are part of the suite. Finally, the light test includes only a few lines of JavaScript involving bit operations.</p><p>We conduct two sets of experiments. For the first set we use ab <ref type="bibr" target="#b0">[1]</ref>, which is considered the de-facto tool for benchmarking an Apache web server, over a Fast Ethernet (FE) network. We configure ab to issue 100 requests for the heavy, normal and light web pages, while the xJSmodule is enabled. Then, we perform the same experiments using the tests and with the xJS Apache module removed. We repeat all the above with the ab client running in a typical downstream DSL line (8 Mbps). <ref type="figure" target="#fig_1">Figure 3</ref> summarizes the results for the case of the ab tool connecting to the web server through a FE connection. The modified Apache imposes an overhead that ranges from a few (less than 6 ms and less than 2 ms for the normal and light test, respectively) to tens of milliseconds (about 60 ms) in the worst case (the heavy web page). While the results are quite promising for the majority of the tests, the processing time for the heavy page, which is over a factor of five greater, could be considered significant. In <ref type="figure">Figure 4</ref> we present the same experiments over the DSL link. The overhead is still the same and it is negligible (less than a roundtrip in today's Internet) since now the delivery overhead dominates. This drives us to conclude that the Apache module imposes a fixed overhead of a few milliseconds per page, which is not the dominating overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Client Overhead</head><p>Having examined the server-side overhead, we now measure the overhead imposed on the browser by xJS. We use the SunSpider test suite with 100 iterations, with every test executed 100 times. We use the gettimeofday() function to measure the execution time of the modified functions in each browser. Each implementation has two functions altered. The one that is responsible for handling code associated with events, such as onclick, onload, etc., and the one that is responsible for evaluating JavaScript code blocks. The modifications of WebKit and Chromium are quite similar (Chromium is based partially on WebKit). The modifications of Firefox are substantially different. In Firefox we have modified internally the JavaScript eval() function which is recursive. These differences affect the experimental results in the following way. In WebKit and Chromium we record fewer long calls in contrast with Firefox, in which we record many short calls. In <ref type="figure" target="#fig_2">Figure 5</ref> we present the cumulative distribution of the delays imposed by all modified recorded function calls for Firefox, WebKit and Chromium, during a run of the SunSpider suite for 100 iterations. As delay we define the time needed for the modified function to complete minus the time needed for the unmodified one to complete. Observe that the Firefox implementation seems to be the faster one. All delays are less than 1 millisecond. However, recall that Firefox is using a lot of short calls, compared to the other two browsers. Firefox needs about 500,000 calls for the 100 iterations of the complete test suite. In <ref type="figure" target="#fig_2">Figure 5</ref> we plot the first 5,000 calls for Firefox (these calls correspond to one iteration only) of the complete set of about 500,000 calls, for visualization purposes and to facilitate comparison, and all 4,800 calls needed for WebKit and Chromium to complete the test suite, respectively. Chromium imposes an overhead of a few milliseconds per call, while WebKit seems to impose larger overheads. Still, the majority of WebKit's calls impose an overhead of a few tens of milliseconds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">User Browsing Experience</head><p>We now identify whether user's browsing experience changes due to xJS. As user browsing experience we define the performance of the browser's JavaScript engine (i.e., running time), which would reflect the userperceived rendering time (as far as the JavaScript content is concerned) for the page. We run the SunSpider suite as-is for 100 iterations with all three modified web browsers and with the equivalent unmodified ones and record the output of the benchmark. In <ref type="figure">Figure 6</ref> we plot the results for all different categories of tests. Each category includes a few individual benchmark tests. As expected there is no difference between a modified and a non modified web browser for all three platforms, Firefox, WebKit and Chromium. This result is reasonable,  <ref type="figure">Figure 6</ref>: Results from the SunSpider test suite. Notice that for each modified browser the results are comparable with the results of its unmodified equivalent. That is, all de-isolated JavaScript executes as expected in both modified and unmodified browser. since after the de-isolation process the whole JavaScript source executes normally as it is in the case with a non compatible with the xJS framework web browser. Moreover, this experiment shows that xJS is not restrictive with legitimate web sites, since all the SunSpider suite (some thousands of JavaScript LoCs) run without any problem or side-effect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussion</head><p>We now discuss potential limitations of our approach and offer possible workarounds. JavaScript Obfuscation. Web pages served by xJS have all JavaScript encoded in Base64. Depending on the context this may be considered as a feature or not. For example, there are plenty of custom tools that obfuscate JavaScript on purpose. Such tools are used by certain web sites for protecting their JavaScript code and prevent visitors from copying the code. We should make clear that emitting all JavaScript encoded does not harden the development process, since all JavaScript manipulation takes place during serving time. While debugging, web developers may safely switch off xJS. Blueprint <ref type="bibr" target="#b38">[38]</ref> also emits parts of a web page in Base64.</p><p>eval() Semantics and Dynamic Code. As previously discussed (see Section 4), in order for xJS to cope with XSS attacks that are based on malicious injected data, the semantics of eval() must change. More precisely, our Firefox modifications alter the eval() function in the following way. Instead of simply evaluating a JavaScript content, the modified eval() function performs deisolation before evaluation. This behavior can break web applications that are based on the generation of dynamic JavaScript code, which is executed using eval() at serving time. While this type of programming might be considered inefficient and error-prone, we suggest the following workaround. The JavaScript engine can be enhanced with an xeval() variant which does not perform any de-isolation before evaluation. The web programmer must explicitly call xeval() if this is the desired behavior. Still, there is no possibility for the attacker to evaluate her code (using xeval()), since the original call to xeval() must be already isolated.</p><p>Code Templates and Persistent XSS. Web developers frequently use templates in order to produce the final web pages. These templates are stored usually in a database and sometimes they include JavaScript. The database may also contain data produced by user inputs. In such cases, the code injection may take place within the database (Persistent XSS). This may occur if trusted code and a user input containing malicious code are merged together before included in the final web page. This case is especially hard to track, since it involves the programmer's logic to a great extent. The challenge lies in that client-side code is hosted in another environment (the database) which is also vulnerable to code injections. xJS assumes that all trusted JavaScript is stored in files and not in a database. If the web developer wishes to store legitimate JavaScript in a database then she can place it in read-only tables. With these assumptions, xJS can cope with persistent XSS. Recall from Section 2 that xJS module is the first to run in the Apache module chain and, thus, all JavaScript isolation will take place before any content is fetched from databases or other external sources.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>The closest studies to xJS are BEEP <ref type="bibr" target="#b17">[17]</ref>, Noncespaces <ref type="bibr" target="#b16">[16]</ref> and DSI <ref type="bibr" target="#b26">[26]</ref>. Throughout the paper, we have highlighted certain cases where the aforementioned methodologies fail (e.g., see Section 3). We have presented attacks that escape whitelisting (proposed in <ref type="bibr" target="#b17">[17]</ref>) and cases where DOM-based solutions <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b26">26]</ref> are not efficient. Our framework, xJS, can cope with XSS attacks that escape whitelisting <ref type="bibr" target="#b6">[6]</ref>, and does not require any information related to DOM; xJS can also prevent attacks that leverage the content-sniffing algorithms of web browsers <ref type="bibr" target="#b7">[7]</ref>.</p><p>Our technique is based on Isolation Operators and it is inspired by Instruction Set Randomization (ISR) <ref type="bibr" target="#b20">[20]</ref>. Solutions based on ISR have been applied to native code and to SQL injections <ref type="bibr">[9]</ref>. Keromytis discusses ISR as a generic methodology for countering code injections in <ref type="bibr" target="#b21">[21]</ref> and he mentions that the technique can be potentially applied in XSS mitigation. However, to the best of our knowledge there has been no systematic effort towards this approach before.</p><p>In <ref type="bibr" target="#b40">[40]</ref> the authors propose to use dynamic tainting analysis to prevent XSS attacks. Taint-tracking has been partially or fully used in other similar approaches <ref type="bibr" target="#b26">[26,</ref><ref type="bibr" target="#b35">35,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b27">27]</ref>. Although xJS does not rely at all on tainting, a source-code based tainting technique <ref type="bibr" target="#b43">[43]</ref> can certainly assist in separating all server-produced JavaScript. The server side of xJS will be able to efficiently mark all legitimate client-side code and also identify malicious data. However, the performance might degrade.</p><p>Blueprint <ref type="bibr" target="#b38">[38]</ref> is a server-only approach which guarantees that untrusted content is not executed. The application server pre-renders the page and serves each web document in a form in which all dynamic content is correctly escaped to avoid possible code injections. However, Blueprint requires the web programmer to inject possible unsafe content (for example comments of a blog story) using a specific Blueprint API in PHP. Spotting all unsafe code fragments of a web application is not trivial. Blueprint imposes further a significant overhead compared to solutions based on natively browser modifications, like xJS.</p><p>Enforcing separation between structure and content is another prevention scheme for code injections <ref type="bibr" target="#b32">[32]</ref>. This proposed framework can deal with XSS attacks as well as SQL injections. As far as XSS is concerned, the basic idea is that each web document has a well defined structure in contrast to a stream of bytes, as it is served nowadays by web servers. This allows the authors to enforce a separation between the authentic document's structure and the untrusted dynamic content from user input, which is attached to it. However, in contrast to xJS, this technique cannot deal with attacks that are based on the content-sniffing algorithms of browsers <ref type="bibr" target="#b7">[7]</ref> as well as attacks that modify the DOM structure using purely client-side code <ref type="bibr" target="#b22">[22]</ref>.</p><p>Script accenting <ref type="bibr" target="#b10">[10]</ref> is based also on XOR for isolating scripts in the web browser. Script accenting aims on providing an efficient mechanism for implementing the same origin policy in a web browser, but it is not explicitly related with XSS. Leaks that can take place due to the DOM separation from the JavaScript engine, inside a web browser, and can lead to browser compromising have been studied in <ref type="bibr" target="#b8">[8]</ref>. These attacks can be considered more severe than XSS and cannot be captured by xJS. <ref type="bibr">MashupOS [41]</ref> and subsequent work Gazelle <ref type="bibr" target="#b42">[42]</ref> view browsers as a multi-principal OS where a principal is labeled by a web site's origin following the same-origin policy <ref type="bibr" target="#b33">[33]</ref>. MashupOS analyzed and proposed protection and communications abstractions that a browser should expose for web application developers. In particular, &lt;sandbox&gt; is proposed to embed untrusted content and can be used by developers to prevent XSS attacks as long as they can correctly differentiate trusted content from untrusted ones. In comparison, our work does not require explicit inclusion of untrusted content from developers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this paper we present xJS, a practical and developerfriendly framework against the increasing threat of XSS attacks. The motivation for developing xJS is twofold. First, we want an XSS prevention scheme that can cope with the new return-to-JavaScript attacks presented in this paper and second, we want the solution to be easily adopted by web developers.</p><p>We implement and evaluate our solution in three leading web browsers and in the Apache web server. Our evaluation shows that (a) every examined real-world XSS attack can be successfully prevented, (b) negligible computational overhead is imposed on the server and browser side, and (c) the user's browsing experience and perceived performance is not affected by our modifications.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: A minimal Blog site demonstrating the whitelisting attacks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Server side evaluation when the Apache benchmark tool (ab) is requesting each web page through a Fast Ethernet link. In the worst case (heavy) the server imposes delay of a factor of five greater, while in the normal case the delay is only a few milliseconds.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Cumulative distribution for the delay imposed by all modified function calls in the Firefox, WebKit and Chromium implementation, respectively. As delay we assume the time needed for the modified function to complete minus the time needed for the unmodified one to complete. Notice that the majority of function calls imposes a delay of a few milliseconds.</figDesc></figure>

			<note place="foot" n="1"> WebKit is not a web browser itself, it is more like an application framework that provides a foundation upon which to build a web browser. We evaluate our modifications on WebKit using the Safari web browser.</note>

			<note place="foot" n="2"> For the definition of the Accept field in HTTP requests, see: http://www.w3.org/Protocols/HTTP/HTRQ Headers. html#z3</note>

			<note place="foot" n="3"> One can argue that the onload action is limited and usually associated with the &lt;body&gt; tag. The latter is considered hard to be altered through a code-injection attack. However, note, that the onload event is also available for other elements (e.g. images, using the &lt;img&gt; tag) included in the web document. 4 This can also happen with other libraries as well, but libc seems ideal since (a) it is linked to every program and (b) it supports operations like system(), exec(), adduser(), etc., which can be (ab)used accordingly. More interestingly, the attack can happen with no function calls but using available combinations of existing code [36].</note>

			<note place="foot" n="6"> For example, consider the attack vector: http://www. needforspeed.com/undercover/home.action?lang= \&quot;scriptalert(document.cookie);/script &amp;region=us</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank the anonymous reviewers for their feedback, Professor Angelos D. Keromytis for early discussions and our shepherd Helen Wang. Her assistance for improving the paper was invaluable. Elias Athanasopoulos, Antonis Krithinakis, Spyros Lygouras and Evangelos P. Markatos are also with the University of Crete. Elias Athanasopoulos is funded by the Microsoft Research PhD Scholarship project, which is provided by Microsoft Research Cambridge.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<ptr target="http://httpd.apache.org/docs/2.0/programs/ab.html" />
		<title level="m">ab -Apache HTTP server benchmarking tool</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mcafee</surname></persName>
		</author>
		<ptr target="http://www.readwriteweb.com/archives/mcafeeenablingmalwaredistributionandfraud.php" />
		<title level="m">Enabling Malware Distribution and Fraud</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sunspider Javascript Benchmark</surname></persName>
		</author>
		<ptr target="http://www2.webkit.org/perf/sunspider-0" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">/</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Xxsed</surname></persName>
		</author>
		<ptr target="http://www.xssed.com/mirror/35059/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Advanced SQL injection in SQL server applications. White paper, Next Generation Security Software Ltd</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Anley</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Code-Injection Attacks in Browsers Supporting Policies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Athanasopoulos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pappas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Markatos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd Workshop on Web 2.0 Security &amp; Privacy (W2SP)</title>
		<meeting>the 2nd Workshop on Web 2.0 Security &amp; Privacy (W2SP)<address><addrLine>Oakland, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Secure Content Sniffing for Web Browsers or How to Stop Papers from Reviewing Themselves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Barth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Caballero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th IEEE Symposium on Security &amp; Privacy</title>
		<meeting>the 30th IEEE Symposium on Security &amp; Privacy<address><addrLine>Oakland, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Cross-Origin JavaScript Capability Leaks: Detection, Exploitation, and Defense</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Barth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Weinberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th USENIX Security Symposium</title>
		<meeting>the 18th USENIX Security Symposium<address><addrLine>Montreal, Quebec</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">SQLrand: Preventing SQL Injection Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">W</forename><surname>Boyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd Applied Cryptography and Network Security (ACNS) Conference</title>
		<meeting>the 2nd Applied Cryptography and Network Security (ACNS) Conference</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="292" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An Analysis of Browser Domain-Isolation Bugs and a LightWeight Transparent Defense Mechanism</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th ACM conference on Computer and Communications Security (CCS)</title>
		<meeting>the 14th ACM conference on Computer and Communications Security (CCS)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="2" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Return-to-libc attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Designer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bugtraq</title>
		<imprint>
			<date type="published" when="1997-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Why Phishing Works</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Dhamija</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tygar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hearst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGCHI Conference on Human Factors in Computing Systems</title>
		<meeting>the SIGCHI Conference on Human Factors in Computing Systems<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="581" to="590" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Talking to Strangers Without Taking their Candy: Isolating Proxied Content</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Felt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hooimeijer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SocialNets &apos;08: Proceedings of the 1st Workshop on Social Network Systems</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="25" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Fernandez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Pagkalos</surname></persName>
		</author>
		<ptr target="http://www.xssed.com" />
		<title level="m">XSSed.com. XSS (Cross-Site Scripting) information and vulnerable websites archive</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Garrett</surname></persName>
		</author>
		<title level="m">A New Approach to Web Applications. Adaptive path</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Noncespaces: Using Randomization to Enforce Information Flow Tracking and Thwart Cross-Site Scripting Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">V</forename><surname>Gundy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the 16th Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-08-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Defeating Script Injection Attacks with Browser-Enforced Embedded Policies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Swamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WWW &apos;07: Proceedings of the 16th international conference on World Wide Web</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="601" to="610" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">RFC 4648: The Base16, Base32, and Base64 Data Encodings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Josefsson</surname></persName>
		</author>
		<ptr target="http://tools.ietf.org/html/rfc4648" />
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Pixy: A Static Analysis Tool for Detecting Web Application Vulnerabilities (Short Paper)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Jovanovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th IEEE Symposium on Security and Privacy</title>
		<meeting>the 27th IEEE Symposium on Security and Privacy<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="258" to="263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Countering Code-Injection Attacks with Instruction-Set Randomization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Keromytis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Prevelakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th ACM conference on Computer and Communications Security</title>
		<meeting>the 10th ACM conference on Computer and Communications Security<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="272" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Randomized Instruction Sets and Runtime Environments Past Research and Future Directions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="18" to="25" />
			<pubPlace>Piscataway, NJ, USA</pubPlace>
		</imprint>
	</monogr>
	<note>IEEE Educational Activities Department</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">DOM Based Cross Site Scripting or XSS of the Third Kind. Web Application Security Consortium</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Klein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Articles, 4.7.</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A General Dynamic Information Flow Tracking Framework for Security Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">C</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T.-C</forename><surname>Chiueh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACSAC &apos;06: Proceedings of the 22nd Annual Computer Security Applications Conference</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="463" to="472" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Document Object Model (DOM) Level 3 Core Specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Le Hors</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">Le</forename><surname>Hegaret</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nicol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Robie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Champion</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Byrne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">World Wide Web Consortium, Recommendation REC-DOM-Level</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Automatic Generation of XSS and SQL Injection Attacks with Goaldirected Model Checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th USENIX Security symposium</title>
		<meeting>the 17th USENIX Security symposium<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="31" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Document Structure Integrity: A Robust Basis for Cross-site Scripting Defense</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Nadji</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the 16th Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-08-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Dynamic Multi-Process Information Flow Tracking for Web Application Security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Nanda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Chiueh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th ACM/IFIP/USENIX international conference on Middleware</title>
		<meeting>the 8th ACM/IFIP/USENIX international conference on Middleware<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Automatically Hardening Web Applications Using Precise Tainting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nguyen-Tuong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guarnieri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Greene</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Evans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th IFIP International Information Security Conference</title>
		<meeting>the 20th IFIP International Information Security Conference</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="372" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Smashing the stack for fun and profit. Phrack magazine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>One</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="volume">49</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">All your iFRAMES point to us</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Provos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mavrommatis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rajab</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Monrose</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th conference on Security symposium</title>
		<meeting>the 17th conference on Security symposium</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Beautiful Soup-HTML/XML parser for Python</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Richardson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Static Enforcement of Web Application Integrity Through Strong Typing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th USENIX Security Symposium</title>
		<meeting>the 18th USENIX Security Symposium<address><addrLine>Montreal, Quebec</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">The same-origin policy</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ruderman</surname></persName>
		</author>
		<ptr target="http://www.mozilla.org/projects/security/components/same-origin.html" />
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">The Top Cyber Security Risks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sans Insitute</surname></persName>
		</author>
		<ptr target="http://www.sans.org/top-cyber-security-risks/" />
		<imprint>
			<date type="published" when="2009-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">An Efficient Black-box Technique for Defeating Web Application Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>the 16th Annual Network and Distributed System Security Symposium (NDSS)<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-08-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">The Geometry of Innocent Flesh on the Bone: return-into-libc without Function Calls (on the x86)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Shacham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS &apos;07: Proceedings of the 14th ACM conference on Computer and Communications Security</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="552" to="561" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Ruby on Rails: Up and Running</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Tate</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hibbs</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<publisher>O&apos;Reilly Media, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Blueprint: Precise Browser-neutral Prevention of Cross-site Scripting Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Ter</forename><surname>Louw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Venkatakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th IEEE Symposium on Security &amp; Privacy</title>
		<meeting>the 30th IEEE Symposium on Security &amp; Privacy<address><addrLine>Oakland, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Libxml2 project web page</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Veillard</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Cross-Site Scripting Prevention with Dynamic Data Tainting and Static Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vogt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Nentwich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Jovanovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kirda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of the 14th Annual Network and Distributed System Security Symposium (NDSS)</title>
		<meeting>eeding of the 14th Annual Network and Distributed System Security Symposium (NDSS)</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Protection and Communication Abstractions for Web Browsers in MashupOS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Jackson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<editor>T. C. Bressoud and M. F. Kaashoek</editor>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">The Multi-Principal OS Construction of the Gazelle Web Browser</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Grier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Moshchuk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Choudhury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Venter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th USENIX Security Symposium</title>
		<meeting>the 18th USENIX Security Symposium<address><addrLine>Montreal, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Taint-Enhanced Policy Enforcement: A Practical Approach to Defeat a Wide Range of Attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Bhatkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th USENIX Security Symposium</title>
		<meeting>the 15th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="121" to="136" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
