<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:27+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">go-pmem: Native Support for Programming Persistent Memory in Go go-pmem: Native Support for Programming Persistent Memory in Go</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>July 15-17, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shaji</forename><surname>Jerrin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Pratap Subrahmanyam VMware</orgName>
								<orgName type="institution" key="instit1">VMware</orgName>
								<orgName type="institution" key="instit2">VMware</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohit</forename><surname>George</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Pratap Subrahmanyam VMware</orgName>
								<orgName type="institution" key="instit1">VMware</orgName>
								<orgName type="institution" key="instit2">VMware</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajesh</forename><surname>Verma</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Pratap Subrahmanyam VMware</orgName>
								<orgName type="institution" key="instit1">VMware</orgName>
								<orgName type="institution" key="instit2">VMware</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pratap</forename><surname>Venkatasubramanian</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Pratap Subrahmanyam VMware</orgName>
								<orgName type="institution" key="instit1">VMware</orgName>
								<orgName type="institution" key="instit2">VMware</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>VMware</roleName><surname>Subrahmanyam</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Pratap Subrahmanyam VMware</orgName>
								<orgName type="institution" key="instit1">VMware</orgName>
								<orgName type="institution" key="instit2">VMware</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shaji</forename><surname>Jerrin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Pratap Subrahmanyam VMware</orgName>
								<orgName type="institution" key="instit1">VMware</orgName>
								<orgName type="institution" key="instit2">VMware</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>George</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Pratap Subrahmanyam VMware</orgName>
								<orgName type="institution" key="instit1">VMware</orgName>
								<orgName type="institution" key="instit2">VMware</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohit</forename><surname>Verma</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Pratap Subrahmanyam VMware</orgName>
								<orgName type="institution" key="instit1">VMware</orgName>
								<orgName type="institution" key="instit2">VMware</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajesh</forename><surname>Venkatasubramanian Vmware</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Pratap Subrahmanyam VMware</orgName>
								<orgName type="institution" key="instit1">VMware</orgName>
								<orgName type="institution" key="instit2">VMware</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">go-pmem: Native Support for Programming Persistent Memory in Go go-pmem: Native Support for Programming Persistent Memory in Go</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2020 USENIX Annual Technical Conference</title>
						<meeting>the 2020 USENIX Annual Technical Conference						</meeting>
						<imprint>
							<date type="published">July 15-17, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the 978-1-939133-14-4 Open access to the Proceedings of the 2020 USENIX Annual Technical Conference is sponsored by USENIX. https://www.usenix.org/conference/atc20/presentation/george</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Persistent memory offers persistence and byte-level ad-dressability at DRAM-like speed. Operating system support and some user-level library support for persistent memory programming has emerged. But we think lack of native programming language support is an impediment to a programmer&apos;s productivity. This paper contributes go-pmem, an open-source extension to the Go language compiler and runtime that natively supports programming persistent memory. go-pmem extends Go to introduce a runtime garbage collected persistent heap. Often persistent data needs to be updated in a transactional (i.e., crash consistent) manner. To express transaction boundaries , go-pmem introduces a new txn block which can include most Go statements and function calls. go-pmem compiler uses static type analysis to log persistent updates and avoid logging volatile variable updates whenever possible. To guide our design and validate our work, we developed a feature-poor Redis server go-redis-pmem using go-pmem. We show that go-redis-pmem offers more than 5x through-put than unmodified Redis using a high-end NVMe SSD on memtier benchmark and can restart up to 20x faster than unmodified Redis after a crash. In addition, using compiler microbenchmarks, we show go-pmem&apos;s persistent memory allocator performs up to 40x better and transactions up to 4x faster than commercial libraries like PMDK and previous work like Mnemosyne.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>At present, there is a large gap between the access latency for memory and storage hierarchy. The fastest tier of storage, e.g., SSDs, which provide persistence, can be 100x-1000x slower than DRAM, which are volatile and lose all their data on a power cycle. Applications carefully place their working set data in DRAM where the access latency is between 50-100ns, and every so often, perhaps under the guidance of the user via policies, save the data from DRAM to the storage tier. Over * Co-first authors ordered alphabetically the past three decades, applications and operating systems have evolved to orchestrate this data movement in a highly efficient way.</p><p>Persistent memory (pmem) is a new type of random-access memory that offers persistence and byte-level addressability at DRAM-like access speed <ref type="bibr">[19]</ref>. Intel c</p><p>Optane TM DC Persistent Memory <ref type="bibr">[12]</ref> is an example of a readily available persistent memory product. Persistent memory is now becoming increasingly available in servers <ref type="bibr" target="#b0">[1]</ref>. Operating systems such as Linux have had support to use pmem as faster storage disks for some time now <ref type="bibr" target="#b4">[6]</ref>.</p><p>The obvious way to consume pmem is as a faster storage device (block mode access) by running an unchanged application on top of a file system. We demonstrate a significant improvement in the throughput of Redis when it is run on top of Linux ext4 filesystem using persistent memory as the block storage device. But, we were also able to show even further performance improvements with a Redis that was hand modified to use byte-addressable persistent memory for its in-memory database. Unsurprisingly, we were also able to show that a good bit of the application's I/O processing code that store the data from volatile DRAM to storage, can now be retired as data is being immediately persisted all over the application. So, using the byte-addressable mode of pmem delivers more performance than using it in block mode, and also lowers the overall complexity in the application code. We delve deeper into this in ยง2.</p><p>We argue that databases like Redis are fast and popular because they highly optimize the data structures used in volatile memory. However, applications must write these data structures into serial buffers for persistence and these optimizations are lost. With byte-addressable persistent memory, applications can directly persist and retrieve their data structures without serialization. And so, the main focus of this work is that we strive to make manipulating persistent memory similar to manipulating volatile memory.</p><p>Towards this, we contribute go-pmem, an open source extension to the popular Go programming language. go-pmem provides a familiar Go-esque programming model to the appli-cation developers to use persistent memory at byte-level granularity. We arrived at our current model by implementing a feature-poor implementation of Redis (go-redis-pmem) ( ยง5.3) that directly uses byte-addressable pmem. With go-pmem, we contribute a programming model with the following design goals:</p><p>1. Single type system. No separate persistent types as in <ref type="bibr">[18,</ref><ref type="bibr" target="#b20">32]</ref>. 2. Pointers remain unchanged, i.e., no fat pointers. A consequence of this is we implement pointer swizzling ( ยง4.3.2). 3. Support two heaps, volatile and persistent: go-pmem extends Go runtime to manage pmem and uses pointers to identify objects in pmem. 4. Allow pointers both across and within the persistent and volatile heap, but make system safe across crash and recovery. To do this, go-pmem extends Go's garbage collector (GC) to work across both the heaps. 5. After restart, allow applications to retrieve back data stored in pmem by associating it with a string name. These are called named-objects ( ยง4.4.1). 6. Allow transactional code blocks by requiring the user to demarcate these with a new Go txn keyword. 7. Reuse functions to operate on data in volatile or persistent memory. 8. Allow allocation and update of pmem resident data structures outside a transaction as long as they are not reachable from a named object. In case of a crash-andrecovery, go-pmem's GC will garbage collect such objects thus avoiding any persistent memory leaks. In a set of microbenchmarks, we see that go-pmem performs up to 40x better than other pmem libraries languages. go-redis-pmem offers 5x more throughput than unmodified Redis on an SSD against memtier benchmark and restarts up to 20x faster than unmodified Redis. We explain our evaluation methodologies more in ยง6. To the best of our knowledge, ours is the first expansive effort to change Go to support persistent memory. In ยง5, we explain how Go's existing design features helped and challenged us towards our idea of supporting pmem.</p><p>go-pmem is developed from the Go 1.11 code base, and is fully open-sourced. Links to the respective repositories can be found at https://vmware.github.io/persistent-memoryprojects/.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>To give more context into our work, we begin by asking why should anyone care about persistent memory?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Experiments with Redis</head><p>Over the years, a lot of work has gone into optimizing data intensive applications. To reduce the latency of data access, these applications keep frequently used data in DRAM, and flush the dirty data from DRAM to disks/SSD at certain welldefined points. For example, Redis <ref type="bibr">[24]</ref> allows users to persist their data to disks/SSD in an append-only-file (AOF). But if no persistence mode is used, a crash at any point would cause all the in-memory data to be lost. If the user cannot afford any data loss at all, he has to write to the AOF file after each write request and as such sees significantly reduced throughput.</p><p>In all the experiments in this section, we run Redis in the zero data loss mode, as that is the fair way to compare with byte addressable persistent memory which provides zero data loss. To see the benefits of persistent memory, we now conduct the following experiment:</p><p>1. Use the memtier benchmark as the load generating input workload <ref type="bibr" target="#b13">[25]</ref>, configured to issue read-write requests in a 70:30 ratio. 2. Run unmodified Redis-3.2, in the following two modes:</p><p>(a) saving the AOF on an SSD and (b) saving the AOF on a persistent memory device. 3. Run Redis-3.2 hand modified for byte-addressability taken from <ref type="bibr">[11]</ref>. <ref type="figure">Figure 1</ref> shows that just by running unchanged Redis on a pmem device as block storage, the throughput increases by up to 4x. This configuration gives a higher throughput owing to the inherent faster access time of persistent memory. <ref type="figure">Figure 1</ref>'s Pmem Block IO curve confirms this. The third curve (PMDK-Redis) <ref type="bibr">[11]</ref> shows the performance of a Redis server modified to write data to persistent memory used in byteaddressable mode. In fact, PMDK-Redis even outperforms Redis running on pmem as block-storage.</p><p>To understand this, we perform another experiment. We run unmodified Redis-3.2 once with AOF disabled and once with always-fsync-AOF option on nullfsvfs virtual file system <ref type="bibr" target="#b1">[2]</ref>. This file system treats all read and write system calls to the storage media as no-ops. So the difference in performance is entirely due to serializing data in the application and the overheads in making system calls. This is the reason why in <ref type="figure" target="#fig_0">Fig. 2</ref> Redis with AOF enabled on nullfsvfs is slower than Redis with AOF disabled. Because pmem is faster than SSD, the time spent accessing the device is significantly reduced and the overhead of the software stack become a significant portion of the overall application latency.</p><p>These two experiments convince us that using persistent memory can give significant throughput improvements in data intensive applications and that the most efficient way for applications to access persistent memory is through direct CPU load/store instructions bypassing any file-system/PCIe overheads. A more extensive study on persistent memory can be found in <ref type="bibr" target="#b25">[37]</ref>. Since memory is accessed in 64-byte cache lines, the CPU reads only what it needs to read, instead of rounding every access up to a block size, like storage. Linux also allows persistent memory to be used in a direct-access (DAX) mode <ref type="bibr" target="#b4">[6,</ref><ref type="bibr" target="#b11">20,</ref><ref type="bibr">21]</ref>. This mode allows users to mmap files in persistent memory into their virtual address space and access it through loads/stores, bypassing the OS page cache and file systems. In the rest of this work, we use pmem in byte-addressable mode, unless we specifically mention block storage mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Why Change a Programming Language?</head><p>Hand porting applications to use byte-addressable pmem can introduce fragility in the code. Just think of a situation, where the developer misses to guard a single store to persistent memory within a transaction -the bug will be very difficult to discover. So, the next question is: how can the porting process be made easier? Ideally, any acceptable solution should have the following features:</p><p>1. Be similar to existing programming models. 2. Work transparently for systems not supporting persistent memory. I.e., we want to be able to write functions that can operate on data in persistent memory or volatile memory. 3. Fast execution time. One approach is via ad hoc libraries. As we will discuss in ยง3 and ยง4, these libraries expose a programming model different than existing programming models for volatile memory. In particular, memory management becomes tricky and these solutions either don't provide a simple and complete programming model, or go through complicated steps to keep it simple. We argue that programming languages already manage volatile memory. So, persistent memory which is a special type of memory and is also byte-addressable, should also be managed by programming languages.</p><p>Such a language should at least provide:</p><p>1. Persistent memory allocations on heap 2. Garbage collection of persistent heap objects 3. Support modifying persistent memory in a crashconsistent way 4. Support recovery from crashes, i.e., include support for reverting inconsistent updates. 5. Not require offline processing of persistent data regions 6. Similar to existing programming models, for easier adoption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Why Go?</head><p>We chose Go because it is a high-level managed language with an easily extendable runtime. Moreover, we use some of Go's design to our advantage. For example, we reuse Go's mark-and-sweep garbage collector to garbage collect pmem.</p><p>Go uses static escape analysis to determine the scope of objects at compile time and intelligently places objects on the stack or the heap. We extend this to track accesses to volatile and persistent heap and prevent unnecessary pmem accesses. Additionally, the potential benefits of high-level languages are well understood. Automatic memory management in HLLs like Go reduce programmer effort and use-after-free bugs. These kinds of bugs are more dangerous with the use of pmem because any memory leak will survive crashes/restarts. Go's type-safety helped us to avoid special data types and invalid memory accesses. Go also has an active developer community with increasing adoption in systems community (e.g. popular software such as Kubernetes, Docker etc. are written in Go) and this fits well with our plan to open-source our changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Related Work</head><p>Most of the previous efforts to program persistent memory fall into two categories:</p><p>1. Ad hoc library to support pmem. This library usually allows special objects to be created/updated/destroyed in a crash-consistent way through special APIs <ref type="bibr">[17,</ref><ref type="bibr">18,</ref><ref type="bibr" target="#b18">30]</ref>. 2. Programming language enhancements to manage pmem and instrument user code with transactions <ref type="bibr" target="#b14">[26,</ref><ref type="bibr" target="#b15">27,</ref><ref type="bibr" target="#b20">32,</ref><ref type="bibr" target="#b33">45,</ref><ref type="bibr" target="#b34">46]</ref>. In section 6, we compare go-pmem's performance with works in both categories, PMDK <ref type="bibr">[18]</ref> (a library) and Mnemosyne <ref type="bibr" target="#b33">[45]</ref>, Makalu <ref type="bibr" target="#b14">[26]</ref> (language changes).</p><p>Previous efforts often provide a new allocator for pmem and require the user to free memory allocated in pmem <ref type="bibr">[7,</ref><ref type="bibr">18,</ref><ref type="bibr" target="#b14">26]</ref>. Either they don't handle leaks in persistent memory <ref type="bibr" target="#b33">[45]</ref> or use special objects and data types to maintain reference counts <ref type="bibr" target="#b14">[26,</ref><ref type="bibr" target="#b18">30,</ref><ref type="bibr" target="#b20">32]</ref>   <ref type="bibr">[18,</ref><ref type="bibr" target="#b14">26]</ref>. Some require that users must do pmem memory allocations within transactions <ref type="bibr">[18]</ref>. To access data in pmem they usually provide fat pointers <ref type="bibr">[18,</ref><ref type="bibr" target="#b18">30]</ref> or allow direct pointers and ignore pointer swizzling <ref type="bibr" target="#b14">[26,</ref><ref type="bibr" target="#b34">46]</ref>. We did not find any previous work that handled growing persistent heap at runtime. In section 6.4.2 we discuss why this is important. <ref type="bibr" target="#b19">[31,</ref><ref type="bibr" target="#b33">45]</ref> also provide concurrency through transactions. Of course, transactions for programming languages has been a well-researched topic <ref type="bibr" target="#b22">[34]</ref>. However, we don't pursue transactions as a way of solving concurrency, but more from a point of view of crash-consistent/atomic updates while minimally getting in the way of Go's existing concurrency paradigms. In this regard, we are similar to <ref type="bibr" target="#b20">[32,</ref><ref type="bibr" target="#b31">43]</ref> but are more flexible (see section 4.5).</p><p>Similar to <ref type="bibr" target="#b15">[27,</ref><ref type="bibr" target="#b20">32]</ref> we use a modular SSA pass to inject undo transaction logging statements to user code. But unlike <ref type="bibr" target="#b20">[32]</ref> we do not ask the user to provide special pragmas for faster execution. We believe these optimizations complicate the programming model. We also allow function calls within transactions unlike <ref type="bibr" target="#b33">[45]</ref> and want the functions to be reused for persistent and volatile data.</p><p>Another design point is how to demarcate the transactional code block. For example, Atlas <ref type="bibr" target="#b15">[27]</ref> uses existing locks and constructs a happens-before graph to determine order of logs and updates. Autopersist <ref type="bibr" target="#b31">[43]</ref> on the other hand, is quite different. Like go-pmem, they allow users to explicitly demarcate transactional code blocks. But, they also allow users to write normal Java code and when they point to a volatile data from a pmem root, Java runtime moves the transitive closure of the volatile data to pmem transactionally. go-pmem allows updates to pmem-resident objects outside transactions as long as they are not pointed to by a named object.</p><p>So far, most of these efforts have been confined to C, C++ with some work in Java <ref type="bibr">[17,</ref><ref type="bibr" target="#b31">43,</ref><ref type="bibr" target="#b34">46]</ref> and OpenJDK <ref type="bibr" target="#b9">[15]</ref>. There have been calls for these programming languages to support persistent memory <ref type="bibr" target="#b3">[4]</ref> but we don't know of any concrete changes yet. <ref type="table">Table 1</ref> presents a concise summary comparing the features of various pmem libraries. Fn calls captures whether the transaction semantics allows function calls inside a transaction. Heap Growth indicates whether the library supports a growable heap design and Heap Reloc. states if the library supports relocating the pmem heap on an application restart.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Design</head><p>The design of go-pmem is driven mainly by two considerations:</p><p>1. The changes should be accepted to the Go language. This translated to reusing existing Go compiler techniques and keeping our changes to a minimum. 2. Provide a familiar programming model to developers that has a minimal interface and is congruent with the existing Go infrastructure. This would help in easier acceptance and adoption by the Go community.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Programming Model</head><p>Listing 1 shows how to add a new node to a linkedlist resident in pmem using go-pmem. We have highlighted how this is different than normal Go code adding a node to a linkedlist in volatile memory. Memory in pmem is allocated using pnew, similar to Go's new and all updates are made transactional using codeblock txn("undo"). We argue that this is very similar to how Go code is written today. How we managed to get a programming model like Listing 1 is discussed in the rest of this section. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Language Constructs</head><p>We have added two new APIs to Go semantics to support persistent memory allocations:</p><p>func pnew(Type) *Type func pmake(t Type, size ...IntType) Type</p><p>Just like new <ref type="bibr" target="#b5">[8]</ref>, pnew creates a zero-value object of the Type argument in pmem and returns a pointer to this object. The pmake API is used to create a slice in pmem. The semantics of pmake is the same as the make API in Go.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Runtime Design</head><p>Go runtime uses datastructures such as mcache, mspan, mcentral, mheap, etc. to store the metadata related to the heap. A span is a contiguous region in memory (one or more pages) from which the allocator allocates similar-sized objects. mspan stores metadata about a span. mcache is used to cache spans at a thread level. If an allocation request can be satisfied using the cached span, then it can be done so without acquiring any locks, making such allocations very fast. If not, a new span is obtained from the mcentral or mheap. mcentral is a central store of small spans (object size &lt;= 32K) and mheap is a central store of freed spans and large spans. The heap is managed in arenas of size 64MB. Each arena data-structure stores the following metadata:</p><p>1. Span table -Span table is an array that holds a reference to the mspan object corresponding to that virtual page index. 2. Heap type bitmap -The heap type bits are used by the GC to identify what regions in memory have pointers in them. The GC uses these bits while walking the heap. The heap type bits corresponding to an object is set by the allocator when it allocates that object. Linux exposes pmem to applications as a file. Byte-level load/store access to pmem is available once a pmem file has been mmap'd to an application's address space <ref type="bibr" target="#b21">[33]</ref>. We do all this in Go runtime and abstract these out through a Go package called pmem. We have incorporated a simple approach to enabling pmem support in Go -one with minimal changes to the design of the existing memory allocator and garbage collector (GC). Rather than make all the runtime data-structures crash-consistent, we log additional metadata to keep track of allocated regions. This saves us from extensive code changes that would have been necessary in the runtime and aids in the implementation of a robust design. A novelty of our approach is the minimal amount of additional metadata that we log. The runtime maps the pmem file into memory in arenas of sizes that are a multiple of 64MB. <ref type="figure" target="#fig_2">Figure 3(a)</ref> shows the layout of the global header stored in the beginning of the pmem file. magic constant is an 8-byte random number which helps to distinguish between first and subsequent initialization of persistent memory. mapped size is the size of the file currently mapped. root pointer is used to store the pointer to the application named objects ( ยง4.4.1). swizzle state is used for implementing pointer swizzling ( ยง4.3.2). type map is used to cache a fixed number of data types which are the most frequently allocated, helping pmem allocations of such types to be completed significantly faster ( ยง5.1.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Growable Heap Design</head><p>Each arena is divided into two sections -the arena header section and the region managed by the allocator. <ref type="figure" target="#fig_2">Figure 3(b)</ref> shows the layout of the header section in each arena. arena size is the size of the arena and mapped address stores the address at which the arena is currently mapped. swizzle delta and bytes swizzled help to implement the pointer swizzling algorithm. The log section helps to implement a minimal undo log in runtime which is used only during swizzling. The metadata section stores the runtime metadata for this arena as mentioned in ยง5.1.3. Whenever runtime runs out of persistent memory space, the persistent memory file is grown to accommodate a new arena. The metadata in the global header is updated in a consistent manner to reflect the addition of this new arena.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Pointer Swizzling</head><p>Pointer swizzling is a powerful feature that allows direct pointers to be stored in persistent memory and dereferenced, even after multiple invocations of the application. Since persistent memory is exposed through files mapped into memory, the virtual address of the mapping can change during each invocation. In the common scenario, go-pmem is able to map arenas at the same address, avoiding the need to swizzle pointers. If the mapping address changes, then all pointers stored in the pmem heap becomes garbage. Pointer swizzling is the process of 'fixing' these pointers by re-writing them with their new mapped address. Some libraries such as PMDK work around this problem by using a base, offset pair object as a reference to an object in persistent memory. Dereferencing such an object involves a hashmap lookup and offset computation which can get expensive.</p><p>Swizzling is done during pmem initialization in a per-arena manner. The algorithm uses the swizzle delta field in arena header to store the offset by which pointers that point into this arena should be changed. bytes swizzled help track how many pointers have already been swizzled. The log section in the arena help update pointers transactionally. The swizzling algorithm is resilient to crashes during swizzling. If a crash occurs, any partially executed swizzling is completed on the next run, before swizzling all pointers to the new mapped address. go-pmem uses a parallelized algorithm to swizzle pmem arenas. As an added advantage, the swizzle algorithm also implements pointer safety. On application restart, any pointer stored in the pmem heap that point outside the pmem heap are garbage. The swizzle algorithm zeroes out any such pointers to ensure applications do not access such rogue pointers. This gives users the freedom to store both pmem and volatile pointers in the pmem heap.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Restarting After a Crash/Exit</head><p>Our design currently handles graceful exits and noncorrupting failures. Listing 2 shows code starting/recovering from a crash. We provide a pmem package that handles initializing pmem and restarts.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.1 Roots/Named Objects: pmem Package</head><p>Any data in volatile memory is lost on restart, so volatile pointers pointing to data in pmem will be lost too. This means only pointers residing in pmem pointing to data in pmem can be used to access pmem-resident data after a restart. We allow the applications to retrieve these pointers through string names. These can then be used to navigate other objects stored in pmem. We call these objects "named objects" and they can be pointers to native types, structs, or Go slices. Any updates to these named objects must be made through pmem package APIs as shown in Listing 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Transactions as a Part of Go: txn Block</head><p>To make sure no data is left in an inconsistent state, we use transactions. We change Go compiler to natively support undo transactions. We pursue transactions in Go with the intention of providing crash consistency and durability for updates to data in pmem. We introduce a new keyword to Go called txn that automatically intercepts stores to pmem and logs them in an undo log. We add a new SSA (Static Single Assignment) pass to Go compiler's backend that injects statements to Go's intermediate representation of the user code. Our design is derived from a similar technique used in Go compiler to add write barriers for garbage collection to stores in volatile heap <ref type="bibr" target="#b8">[14]</ref>. Our new LogStore SSA pass comes after most of the existing Go SSA passes, so we don't lose on the existing optimizations. For example, successive stores to a pmem resident location can be eliminated by Go's deadstore elimination SSA pass even after our changes.</p><p>To demarcate transactions, we require users to contain their code within a txn("undo") code block. The "undo" indicates we currently support automatic code generation only for undo logging. We briefly discuss how we provide typical transaction properties below.</p><p>1. Atomicity: The pmem.Init() call (see Listing 2) initializes pmem and reverts any incomplete updates stored in the transaction logs of an application in case of a restart. 2. Consistency: We rely on the user to explicitly demarcate updates to pmem-resident data by using a txn block around the code. 3. Isolation: Simultaneous transactions accessing common data must not see any updates till a transaction is committed. We do not support isolation through software transactional memory but rely on programmers to use Go's mutex locks for critical sections. Our concurrency model is simple:</p><p>(a) All the locks acquired within a transaction must be released within the transaction. (b) All the locks acquired outside a transaction must be released outside the transaction.</p><p>Our design then makes sure that all the updates to shared data structures are visible only at the end of a transaction. This is achieved by delaying unlocking any locks acquired within a transaction until the end of the transaction. This is similar to the 2PL locking strategy used in database transactions <ref type="bibr" target="#b28">[40]</ref>. 4. Durability: All the changes made to data in pmem are made durable at the end of a transaction by flushing relevant data stored in the processor caches or buffers. We point out a couple of limitations that our locking model introduces -1. Multiple lock() and unlock() operations on the same lock do not work inside a txn block. 2. Holding all locks taken inside a transaction until the end of the transaction can make lock-based critical sections in go-pmem slower than other models such as Atlas <ref type="bibr" target="#b15">[27]</ref> that allow dependent transactions to run concurrently (as soon as required locks get unlocked). In order to provide isolation, they capture transaction dependency between multiple threads in their logs.</p><p>Listing 3 shows the compiler generated code of the txn{} code block in listing 1. Additional code added by the compiler to ensure transactional semantics is highlighted. Line 8 of listing 3 shows how a mutex unlock is delayed until the end of the transaction. go-pmem also allows function calls within a transaction, as explained further in ยง5.2.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">No Persistent Data Types</head><p>go-pmem intentionally does not introduce new data types. Previous works have often introduced data types like pint, p&lt;int&gt; or persistent int. They usually do this because they offer a library implementation and overload the assignment operator <ref type="bibr">[18]</ref> or they want type-safety, reference counting etc. for pmem resident data <ref type="bibr" target="#b20">[32]</ref>. We believe this complicates the programming model and instead rely on Go's in-built typesafety and garbage collection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation</head><p>go-pmem adds about 4000 lines of code and removes 300 lines of code from Go runtime, excluding code documentation. This does not include the code in the CPUID package from Intel <ref type="bibr" target="#b6">[10]</ref> that is used by runtime to identify CPU features for flushing CPU caches. The two Go packages (pmem and transaction) took close to 2300 lines of Go code. These changes were made on top of Go 1.11 release and don't include the code for testing these changes. Our implementation currently works only for 64-bit Linux 4.15 and above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Runtime Details</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Data Structure Support</head><p>To support persistent memory allocations, runtime datastructures such as the mspan, mcache, mheap, mcentral were extended to store persistent memory metadata. The mspan structure was augmented to identify if this is a pmem span or volatile memory span. Similarly, mcache, mcentral, and mheap were doubled in size to store pmem spans separately. It should be noted that no Go runtime data-structures are stored in pmem. Instead, minimal additional metadata is logged in pmem arena header to capture pmem state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Memory Allocation</head><p>A persistent memory allocation request results in the following workflow -if a cached pmem span is available in the mcache with a free slot, it is used to satisfy the allocation request. Otherwise, a new pmem span is requested from the mcentral/mheap. If no pmem span is available, a new pmem arena is mapped to memory. The required span is then carved out from the pmem arena to satisfy the allocation request. Any required metadata is also logged ( ยง5. <ref type="bibr">1.3</ref>). An advantage of the go-pmem allocator is that these steps can be done without invoking transactions. This is because any pmem leaks are plugged by the GC during heap recovery ( ยง5.1.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3">Metadata Logging</head><p>The metadata that is logged is the minimum amount of information that the runtime needs to reconstruct the memory allocator and garbage collector state on the subsequent execution of the application. The benefits of keeping the metadata to a minimum are twofold: we do not need to introduce complex transactions in the runtime to maintain consistency and the allocator performance is only slightly affected due to the additional logging.</p><p>Two kinds of runtime metadata are logged. The first is the GC heap type bits. Whenever the allocator sets heap type bits for a pmem object, it is also logged in the pmem arena header section. Like its volatile memory representation, heap type bits occupy 2 bits for every 8 bytes of heap data. In ยง5.1.5 we talk about an optimization that helps avoid heap type bitmap logging for frequently allocated data-types. The second is the span table. The span table captures information such as which spans are in use and the size class of the span. Span table logging happens when a new span is created by the allocator or freed up by the GC. Span table reserves 32 bits for every pmem page in the arena (Go uses a page size of 8KB). For a 64MB pmem arena, the arena header section occupies 2024KB, and 63512KB is available for the allocator. The arena section includes 80 bytes for the header, 31756 bytes for the span table and 1984.75KB for the heap bitmap, making the pmem arena memory overhead as 3.09%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.4">Reconstruction</head><p>All runtime data structures related to memory allocator and garbage collector are stored in volatile memory. So, if an application crashes, all state information is lost. Reconstruction is the term used in our project to denote the process of bringing back the state of the memory allocator and garbage collector related to persistent memory as it was before the crash. The additional metadata stored in pmem aids in this reconstruction process. No persistent memory data is modified during reconstruction. Hence the reconstruction process is resilient to any crashes that happen while it is ongoing. Briefly, reconstruction works as following:</p><p>1. GC is disabled until reconstruction finishes so that it does not interfere with the reconstruction process. 2. Spans are recreated using the logged span metadata table.</p><p>3. The logged heap type bitmap is copied as-is to the arena metadata in volatile memory. 4. Pointers are swizzled, if necessary 5. GC is re-enabled GC walks the reconstructed pmem heap starting from the named root objects. It marks all reachable objects as being in-use, and makes any leaked pmem objects available for reuse. This GC walk runs in the background, making the reconstruction process execute quickly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.5">Using Go's Typesystem to Optimize Pmem Allocations</head><p>An allocation of an object that has pointers in it results in the allocator setting the heap type bits for it. If this is a pmem object, these type bits are also logged in the pmem arena header. If a datatype is heuristically found to be a frequently allocated type, then that type is promoted to be cached specially in mcache to speed up allocations of such objects. The heuristic used is the following -the number of allocations of such an object has exceeded the number of slots available in a span corresponding to this object sizeclass and its allocation frequency is greater than 100 objects per second. A span specially so cached is used only to allocate objects of one type. This makes it possible that the heap type bits be logged only for the first object allocated, making further allocations from this span very fast. We employ the typemap ( ยง4.3.1) in the global header to store what types have been specially promoted. Our design supports promoting up to 50 types to be specially cached. In our experience, the maximum number of types frequently allocated by various pmem applications were far fewer. Each type is represented in the typemap section in the pmem header using an 8-byte identifier, making typemap occupy a total of 400 bytes. Each undo log entry has the layout as shown in <ref type="figure" target="#fig_6">figure 4</ref>. gen.# stores current undo log generation number. On a successful abort/commit, the generation number is bumped up to mark all entries as no longer valid. size stores the size of the data logged. pointer is the address at which this data originally resided. data contains the logged copy of the data. Since we do not anticipate a transaction abort in the common case, log entries are populated using movnt instructions so that data is directly moved to the pmem device bypassing the processor cache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.6">Undo Log Implementation</head><p>We also employ a number of optimizations to make logging fast in go-pmem:</p><p>1. Empty transactions do not incur any runtime overhead as no cache flushes or memory fences are issued. 2. Logging the same object multiple times incur minimal overhead. We maintain a map to track what objects have already been logged. 3. As byte arrays are very common in Go, we specially optimize logging 1-byte data. We try to pack consecutive 1-byte data objects in a single log entry rather than create separate entries for each.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.7">Working Around Go's GC to Optimize Undo Logging</head><p>Go uses a mark-and-sweep GC. It scans the heap in a breadthfirst fashion, traversing the heap through the live pointers it finds. The scan starts from the pointers found in goroutine stacks and global variables. We want objects pointed at from the logged data to be kept alive until the transaction completes. But since data is logged in a byte-array, runtime no longer has the type information of each data item logged. Our initial logging library used Go's reflect package which gave a poor performance, so we decided to use Go's byte arrays. To identify pointers in the byte array, whenever a data is logged, all pointers within this data item is stored separately in an array of pointers residing in volatile memory. This ensures that GC finds these pointers while traversing the heap.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.8">Cache Flushing</head><p>Data written to persistent memory can be guaranteed to be persistent only after they are flushed from the processor cache to the persistent memory media. The runtime provides the PersistRange API to flush the processor cache over the address range passed to it.</p><p>func PersistRange(addr unsafe.Pointer, len int)</p><p>If the persistent memory device supports direct-access, this function takes care of executing the most optimized cache flush instruction supported on the processor (such as clwb, clflushopt, or clflush) and any necessary memory barriers <ref type="bibr" target="#b30">[42]</ref>. If the device does not support direct-access, then PersistRange invokes the msync system call to flush data at a page size granularity. Transactions in go-pmem automatically call into the runtime to flush data from the caches, freeing the programmer from having to do it manually.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">LogStore SSA Pass</head><p>The LogStore SSA pass can automatically interpose stores to persistent memory and redirect this to an undo transaction. The user can wrap any codeblock with a txn("undo") keyword and engage this new SSA pass. In the absence of any txn block, this SSA pass does not do anything. Because we wanted to keep the changes to a minimum, this SSA pass can be plugged into/out of the Go compiler's usual workflow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Handling Volatile Memory Access Inside Transactions</head><p>Go uses escape analysis <ref type="bibr" target="#b16">[28]</ref> to figure out life time of variables, and thereby avoids unnecessary memory allocations to volatile heap. We extend this to avoid unnecessary allocations to persistent heap and track pointers in volatile heap.</p><p>With this static analysis, we know the probable location of an update within the transaction. If this update can be proven to be a location in volatile memory, we do not do anything.</p><p>Otherwise we store the current value of the data in a persistent log which will be replayed in case of a crash.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Handling Function Calls Inside Transactions</head><p>Go compiles each function independently and cannot know if this method will be called from a transaction, or a nontransactional code at compile time. Instead of cloning the function for transactional access, we maintain a per Go-routine handle and ask the user to wrap any potentially transactional code within a txn code block. Based on whether a transaction is already ongoing or not, we intelligently start a new transaction or continue the same transaction at runtime. In case this function is called from a non-transactional code, the function simply operates on volatile data without any side effects. Using the techniques mentioned in ยง5.2.1 we try to keep the performance overhead to minimum in this case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Implementing Go-redis-pmem</head><p>We implement a multithreaded feature-poor redis server called go-redis-pmem written using go-pmem. go-redis-pmem currently supports storing/retrieving string KV pairs in pmem and can run traffic generated from memtier benchmark. It currently has 6800 lines of code across 11 files and 360 functions.</p><p>As we were implementing go-redis-pmem, we realized that as the applications become complicated it becomes increasingly difficult to keep track of exactly which variables and pointers are in persistent memory. Our desire to support function calls and ability to reuse functions for data in volatile and persistent memory was driven by the implementation of go-redis-pmem and the ease this offered to the programmer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Limitations</head><p>go-pmem is a work in progress and will continue to evolve as we gain more experience in programming applications for persistent memory. Below, we enumerate the current limitations of go-pmem:  <ref type="bibr" target="#b22">[34]</ref> and by providing safe IO <ref type="bibr" target="#b32">[44]</ref>. We can do something similar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>We use the benchmarks from Computer Language Benchmarks Game (CLBG) <ref type="bibr">[5]</ref> as the microbenchmarks to compare the performance of our memory allocator and transactions.  <ref type="bibr" target="#b27">[39]</ref>. Go has also used some of these benchmarks to optimize their implementation in the past <ref type="bibr">[23]</ref>. We extend some of these benchmarks to test how they perform when run on pmem, and don't focus on others as they test other language features such as arithmetic precision, hashtable performance etc. which is not our focus here. To test multicore scalability of go-pmem, we use the microbenchmarks from the Phoenix suite <ref type="bibr" target="#b29">[41]</ref>. The phoenix suite was originally written to evaluate the MapReduce model for multi-core systems. We use the pthread version of these benchmarks to port to various pmem libraries. We also compare the performance of go-redis-pmem with other Redis implementations. In these evaluations, we ensure there is no remote persistent memory traffic by keeping only one CPU socket on. We compare our work against PMDK stable version (1.7 release commit bc5e30948) and we write code in C++ using C++ bindings from PMDK (stable version 1.8 commit ab4ff69b7) <ref type="bibr" target="#b12">[22]</ref>. The Mnemosyne examples build on implementation code from <ref type="bibr">[7]</ref> and Makalu examples run on implementation code from <ref type="bibr" target="#b10">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Experimental Setup</head><p>Our system is a 24-core Intel Cascade Lake machine with hyperthreading disabled and only one socket to avoid remote pmem traffic. It has 4 Intel c Optane TM DC Persistent Memory Module, each of 128GB, and 64GB of DRAM. In all the runs, the deviation observed across runs was &lt;2%. We report the average runtime across 3 runs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Change in Compile Time</head><p>The compilation time of Go source code increased by 3.4% (from 42.71s to 44.16s) because of all our changes to Go compiler. In the compilation of go-redis-pmem (which has 6800 lines of code and 11 files), we did not see any noticeable difference in the compile time with and without the new ssa pass. The difference was &lt;1% (0.71s vs 0.713s). These numbers were obtained for a fresh compilation with go's build cache cleaned. With the build cache enabled, the observed difference was even smaller (less than 1ms).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Memory Allocator Performance</head><p>The Binary Tree allocator microbenchmark from CLBG stresses the pmem allocator by creating several perfect binary trees. One of these stresses memory to see maximum memory available. One is a long-lived binary tree and there are several short-lived trees which are created and then deallocated. <ref type="figure">Figure 5</ref> compares the performance of go-pmem's pmem allocator to PMDK, Mnemosyne and Makalu. We note that because go-pmem can garbage collect pmem we did not have to free any tree nodes. Makalu and go-pmem do not write to pmem for each new allocation and so are at least an order of magnitude faster than PMDK and Mnemosyne. PMDK must do all allocations and deallocations within a transaction and performs the worst.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Performance of Transactions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.1">Long Running Transactions</head><p>We use fannkuch from CLBG and sps to model programs with a long-running transaction. Fannkuch takes a byte array of size n and shuffles around elements for all n! permutations of this array. We model all this to happen inside a single transaction. This lends it the behavior of a long running transaction. We also noticed that both PMDK and go-pmem use undo logs and maintain minimal state in pmem (only the oldest value of the array) whereas Mnemosyne uses redo log and quickly starts to use a lot of pmem. The sps microbenchmark has been used previously <ref type="bibr" target="#b18">[30,</ref><ref type="bibr" target="#b19">31]</ref> to report throughput of transactions. sps randomly performs swaps between entries of an integer array. The number of these swaps is equal to the number of elements. We change the number of elements in this array from 1k to 10 million and do all the swaps within one single transaction. So unlike Fannkuch, the size of data being operated on also increases as the transaction becomes longer. and sps for PMDK, Mnemosyne and go-pmem. We note that Mnemosyne curves stop early as the public implementation does not support large amounts of data within a transaction. Similar results for Mnemosyne were reported in <ref type="bibr" target="#b19">[31]</ref>. The PMDK curves stop early as the default PMDK implementation does not allow creating a pmem file of 2GB or larger. For both these cases, we consistently outperform PMDK by 3-4x as the transactions become larger.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.2">How Much Data do Applications Store to pmem?</head><p>We also want to highlight that the existing programming models are inept for long-running applications like the ones we model above. PMDK asks the user to specify the pmem file size at the beginning. It crashes if this size is exceeded. Mnemosyne always creates a pmem file of fixed size. We think it is very difficult to predetermine the pmem capacity that commercial applications will use. With the ability to grow pmem heaps ( ยง4.3.1), our programming model is more flexible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.3">Several Short Transactions</head><p>We use n-body microbenchmark from CLBG to model a program with several short transactions. For short transactions, the overhead in setting up the transactions is not amortized, and we try to capture this overhead here. n-body models the orbits of planets using an algorithm. The input is the number of steps that the planets move from a starting point and the output is the new coordinates of the planets. We change one step movement of the planets to be one transaction. <ref type="figure">Figure 8</ref> shows the running time as we vary the number of small transactions. go-pmem consistently performs 2-3x faster than PMDK and Mnemosyne even as the number of small transactions in the application increase to 10 million.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Multicore Scalability</head><p>We run all 7 benchmarks from the Phoenix 2.0 suite <ref type="bibr" target="#b29">[41]</ref> to evaluate how go-pmem scales on multithreaded benchmarks. We modified these benchmarks to keep the data manipulated by each thread in pmem. <ref type="figure" target="#fig_2">Figure 13</ref> captures the relative running time of PMDK compared to go-pmem. All benchmarks use 24 threads and run on the largest input configuration provided by Phoenix. Unlike PMDK and go-pmem, Mnemosyne stores more data in its redo logs and we were not able to get it running on any of these benchmarks. go-pmem scales much better than PMDK on all benchmarks other than linear regression. Linear regression stores very little data on pmem and incurs minimal transactional overheads. The benchmark kmeans uses 2D arrays in pmem and is significantly slower for PMDK. PMDK uses fat pointers and accessing 2D arrays requires multiple indirections. Although <ref type="figure" target="#fig_2">figure 13</ref> shows results with 24 threads, we ran the benchmarks varying the number of threads from 2 to 24. The results with different thread counts are similar to the results shown in figure 13.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6">Restart Time Comparison</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6.1">Undo Transaction Recovery Time After a Crash</head><p>We reuse sps benchmark from ยง6.4.1 to measure time spent by undo transactions in PMDK and go-pmem to revert back to consistent application state. We change the number of integers swapped in sps and crash at the last integer swap. <ref type="figure">Fig- ure 9</ref> shows go-pmem performs at par with PMDK when the amount of data to recover is less but gets slower by 20% as the amount of data to recover increases. We have not optimized the recovery path too much as this is not the common path. One obvious optimization is to store application data in cacheline aligned chunks. This will reduce the number of writes to pmem when we write back the consistent data during restart. Optimizing this path without affecting the performance of common cases remains on our future agenda.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6.2">Restart Time of Persistent Heaps</head><p>We use fill-heap benchmark from Makalu <ref type="bibr" target="#b14">[26]</ref> to compare the restart time as the size of the persistent heap changes. fillheap creates 64-byte objects to fill up a specified heap size. It makes half of these objects reachable from the pmem root objects. On restarting the fill-heap application, we measure the time taken by go-pmem, PMDK, and Makalu to recover  <ref type="figure">figure 10</ref>, go-pmem recovers the pmem heap much faster than Makalu as Makalu has to go through an expensive offline GC phase. PMDK recovers almost instantaneously, because their allocator is inherently transactional, and hence incurs minimal startup cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.6.3">Restart Time of Redis Variations</head><p>To measure how go-pmem heap's recovery fares on a pmem application, we compared the restart time of go-redis-pmem against various other Redis configurations as shown in <ref type="figure">figure  11</ref>. Go Redis swizzle measures the cost of swizzling pointers by force mapping all arenas at a different address than where it was originally mapped. C Redis SSD persists its data as an AOF file on SSD, whereas C Redis Pmem block persists the AOF file on pmem used in block IO mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.7">Go Benchmarks</head><p>We run a set of 4 macro-benchmarks used by Go community to monitor Go performance regressions as new features are added to the compiler <ref type="bibr">[9]</ref>. These benchmarks stress the memory allocator, GC, compiler, etc.  <ref type="table" target="#tab_2">Table 2</ref>: Go benchmark comparison mance of go-pmem versus Go-1.11 upon which our changes are based on. Our changes add little to no performance difference in these benchmarks.</p><p>6.8 Go-redis-pmem <ref type="figure" target="#fig_0">Figure 12</ref> shows the throughput of go-redis-pmem on the same memtier benchmark used in <ref type="figure">figure 1</ref>. Even though goredis-pmem is multithreaded this configuration uses one client thread for a fair comparison. We can see that go-redis-pmem matches the performance of pmdk-redis reconfirming our observation that if applications use persistent memory in byte addressable mode, they will perform the best. In data not shown here, we did see that go-redis-pmem performed better than pmdk-redis and redis-3.2 when there are multiple client threads because it is multithreaded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this work, we presented go-pmem, an opensource extension to the Go language that allows programmers to develop pmem applications in Go. go-pmem is a natural extension of Go for pmem support, following the normal idioms of the Go language. We present a simple programming model and demonstrate its effectiveness by developing a feature-poor Redis equivalent key-value store in Go.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 1: Redis throughput comparison against memtier</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: (a) pmem file header (b) arena header layout. Storage space in bytes adjacent to each field.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Listing 3: Compiler generated code for listing 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Undo log design Undo logs are stored within a linked list of Go's byte arrays. Each undo log entry has the layout as shown in figure 4. gen.# stores current undo log generation number. On a successful abort/commit, the generation number is bumped up to mark all entries as no longer valid. size stores the size of the data logged. pointer is the address at which this data originally resided. data contains the logged copy of the data. Since we do not anticipate a transaction abort in the common case, log entries are populated using movnt instructions so that data is directly moved to the pmem device bypassing the processor cache. We also employ a number of optimizations to make logging fast in go-pmem: 1. Empty transactions do not incur any runtime overhead as no cache flushes or memory fences are issued. 2. Logging the same object multiple times incur minimal overhead. We maintain a map to track what objects have already been logged. 3. As byte arrays are very common in Go, we specially optimize logging 1-byte data. We try to pack consecutive 1-byte data objects in a single log entry rather than create separate entries for each.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>Figure 5: Runtime as depth of largest tree changes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Figure 8: n-body: Runtime as num. of steps a planet moves varies</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 13 :</head><label>13</label><figDesc>Figure 11: Comparing restart time of various Redis versions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><head>Table 2 compares perfor-</head><label>2</label><figDesc></figDesc><table>Benchmark go-1.11 go-pmem 
delta 
Build-24 
23.9s 
23.9s 
0% 
Garbage-64 23.4ms 
23.6ms 
0.87% 
JSON-24 
84.0ms 
84.3ms 
0.44% 
HTTP-24 
73.9ยตs 
75.5ยตs 
2.15% 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank the anonymous reviewers and our shepherd Changhee Jung for their invaluable feedback.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="870">2020 USENIX Annual Technical Conference</head><p>USENIX Association</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Intel optane dc persistent memory</title>
		<ptr target="https://cloud.google.com/blog/topics/partners/available-first-on-google-cloud-intel-optane-dc-persistent-memory" />
		<imprint/>
		<respStmt>
			<orgName>Available first on google cloud</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
				<ptr target="https://github.com/abbbi/nullfsvfs" />
		<title level="m">A black hole file system that behaves like</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<ptr target="http://joeduffyblog.com/2010/01/03/a-brief-retrospective-on-transactional-memory/" />
		<title level="m">A brief retrospective on transactional memory</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">A call for a data persistence study group</title>
		<ptr target="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1026r0.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Direct access for files, kernel</title>
		<ptr target="https://www.kernel.org/doc/Documentation/filesystems/dax.txt" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The go prgramming language</title>
		<ptr target="https://golang.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Intel corporation. cpuid library for go prgramming language</title>
		<ptr target="https://github.com/intel-go/cpuid" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Profiler</forename><surname>Intel Vtune</surname></persName>
		</author>
		<ptr target="https://software.intel.com/en-us/vtune" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Introduction to the go compiler&apos;s ssa backend</title>
		<ptr target="https://github.com/golang/go/tree/master/src/cmd/compile/internal/ssa" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Non-volatile mapped byte buffers</title>
		<ptr target="https://openjdk.java.net/jeps/352" />
	</analytic>
	<monogr>
		<title level="j">Jep</title>
		<imprint>
			<biblScope unit="volume">352</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Makalu : Nvram memory allocator</title>
		<ptr target="https://github.com/HewlettPackard/Atlas/tree/makalu/makalu_alloc" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Persistent memory in linux</title>
		<ptr target="https://www.snia.org/sites/default/files/PM-Summit/2017/presentations/Coughlan_Tom_PM_in_Linux.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
		<ptr target="https://github.com/pmem/libpmemobj-cpp" />
	</analytic>
	<monogr>
		<title level="j">Pmdk c++ bindings</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Redis labs. redis and memcached traffic generation and benchmarking tool</title>
		<ptr target="https://github.com/RedisLabs/memtier_benchmark" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Makalu: Fast recoverable allocation of nonvolatile memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kumud</forename><surname>Bhandari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Dhruva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hans-J</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Boehm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="677" to="694" />
			<date type="published" when="2016" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Atlas: Leveraging locks for non-volatile memory consistency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hans-J</forename><surname>Dhruva R Chakrabarti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kumud</forename><surname>Boehm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bhandari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="433" to="452" />
			<date type="published" when="2014" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Escape analysis for java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jong-Deok</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manish</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mauricio</forename><surname>Serrano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Vugranam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sam</forename><surname>Sreedhar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Midkiff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acm Sigplan Notices</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1" to="19" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">From aries to mars: Transaction support for next-generation, solid-state drives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><surname>Coburn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trevor</forename><surname>Bunker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meir</forename><surname>Schwarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajesh</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Swanson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the twenty-fourth ACM symposium on operating systems principles</title>
		<meeting>the twenty-fourth ACM symposium on operating systems principles</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="197" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Nv-heaps: making persistent objects fast and safe with next-generation, non-volatile memories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><surname>Coburn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adrian</forename><forename type="middle">M</forename><surname>Caulfield</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ameen</forename><surname>Akel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laura</forename><forename type="middle">M</forename><surname>Grupp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Rajesh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ranjit</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Jhala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Swanson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Sigplan Notices</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="105" to="118" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Romulus: Efficient algorithms for persistent transactional memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreia</forename><surname>Correia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pascal</forename><surname>Felber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pedro</forename><surname>Ramalhete</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th on Symposium on Parallelism in Algorithms and Architectures</title>
		<meeting>the 30th on Symposium on Parallelism in Algorithms and Architectures</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="271" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Nvl-c: Static analysis techniques for efficient, correct programming of non-volatile main memory systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><forename type="middle">E</forename><surname>Denny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seyong</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey S</forename><surname>Vetter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th ACM International Symposium on High-Performance Parallel and Distributed Computing</title>
		<meeting>the 25th ACM International Symposium on High-Performance Parallel and Distributed Computing</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="125" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">SNIA NVM Programming Technical Working Group et al. Nvm programming model</title>
		<imprint>
			<biblScope unit="page">2017</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Language support for lightweight transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keir</forename><surname>Fraser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Sigplan Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="388" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Nvthreads: Practical persistence for multi-threaded applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terry Ching-Hsiang</forename><surname>Hsu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Helge</forename><surname>Brรผgner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Indrajit</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kimberly</forename><surname>Keeton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Eugster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twelfth European Conference on Computer Systems</title>
		<meeting>the Twelfth European Conference on Computer Systems</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="468" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Failure-atomic persistent memory updates via justdo logging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Izraelevitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terence</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aasheesh</forename><surname>Kolli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="427" to="442" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Basic performance measurements of the intel optane dc persistent memory module</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Izraelevitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jian</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juno</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiao</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amirsaman</forename><surname>Memaripour</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yun</forename><forename type="middle">Joon</forename><surname>Soh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zixuan</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yi</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Subramanya R Dulloor</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1903.05714</idno>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">ido: Compiler-directed failure atomicity for nonvolatile memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qingrui</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Izraelevitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Se Kwon Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Scott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Sam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Changhee</forename><surname>Noh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Jung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">51st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="258" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Cross-language compiler benchmarking: are we fast yet?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Marr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benoit</forename><surname>Daloze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hanspeter</forename><surname>Mรถssenbรถck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="120" to="131" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Database management systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raghu</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johannes</forename><surname>Gehrke</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>McGraw Hill</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Evaluating mapreduce for multi-core and multiprocessor systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Colby</forename><surname>Ranger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ramanan</forename><surname>Raghuraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arun</forename><surname>Penmetsa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gary</forename><surname>Bradski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christos</forename><surname>Kozyrakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 13th International Symposium on High Performance Computer Architecture</title>
		<imprint>
			<publisher>Ieee</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="13" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Persistent memory programming. Login: The Usenix Magazine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andy</forename><surname>Rudoff</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="34" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Autopersist: an easy-to-use java nvm framework based on reachability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Shull</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jian</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Josep</forename><surname>Torrellas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019" />
			<biblScope unit="page" from="316" to="332" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">xcalls: safe i/o in memory transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haris</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andres</forename><forename type="middle">Jaan</forename><surname>Tack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neelam</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Swift</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Welc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th ACM European conference on Computer systems</title>
		<meeting>the 4th ACM European conference on Computer systems</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="247" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Mnemosyne: Lightweight persistent memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haris</forename><surname>Volos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andres</forename><forename type="middle">Jaan</forename><surname>Tack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael M</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGARCH Computer Architecture News</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="91" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Espresso: Brewing java for more non-volatility with non-volatile memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mingyu</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ziming</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haoyu</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heting</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haibo</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Binyu</forename><surname>Zang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haibing</forename><surname>Guan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="70" to="83" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
