<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:51+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Who Watches the Watchmen? -Protecting Operating System Reliability Mechanisms</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Björn</forename><surname>Döbel</surname></persName>
							<email>doebel@tudos.org</email>
							<affiliation key="aff0">
								<orgName type="institution">Technische Universität Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hermann</forename><surname>Härtig</surname></persName>
							<email>haertig@tudos.org</email>
							<affiliation key="aff1">
								<orgName type="institution">Technische Universität Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Who Watches the Watchmen? -Protecting Operating System Reliability Mechanisms</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We present the design and initial evaluation of a resilient operating system architecture that leverages HW archi-tectures combining few resilient with many non-resilient CPU cores. To this end, we build our system around a Reliable Computing Base (RCB) consisting of those software components that must work for reliable operation, and run the RCB on the resilient cores. The remainder of the system runs replicated on unreliable cores. Our system&apos;s RCB consists of an L4 microkernel, a runtime environment and a replication manager. In this paper we state and justify assumptions about the hardware architecture , motivate the corresponding software architecture and evaluate communication mechanisms between the RCB and the replicas.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>With every new processor generation used in general purpose computers the number and complexity of functional units increases, which is made possible by decreasing structure sizes. The downside of this development is that processors become more vulnerable to permanent and transient hardware errors <ref type="bibr" target="#b6">[7]</ref>. This trend is expected to increase and poses a serious threat to future hardware generations <ref type="bibr" target="#b15">[16]</ref>.</p><p>In this paper, we focus on transient faults caused by single-event upsets (SEUs) <ref type="bibr" target="#b17">[18]</ref>, which are commonly caused by particle strikes, e.g., cosmic radiation. An SEU striking a transistor may result in a corresponding register to change its state, which in turn may lead to erroneous behavior visible at the software level.</p><p>Researchers and computer system vendors introduced various mechanisms to cope with SEUs. Hardware-level approaches introduce dedicated hardware circuitry that validates computations <ref type="bibr" target="#b1">[2]</ref> and transistor timing <ref type="bibr" target="#b8">[9]</ref>, enhances data passing through the CPU with redundant signatures <ref type="bibr" target="#b18">[19]</ref>, or performs lock-stepped execution of processing units <ref type="bibr" target="#b13">[14]</ref>. Unfortunately, such approaches are often too expensive (in terms of energy consumption, production cost, or runtime overhead) to be employed in general purpose computer systems.</p><p>Software-level solutions exploit application and developer knowledge to decrease the runtime overhead required by a specific fault tolerance strategy <ref type="bibr" target="#b23">[24]</ref>. These approaches are often built into a compiler <ref type="bibr" target="#b20">[21]</ref>, which requires the applications' source code to be available. Applicability of these strategies is limited, because many applications either make use of third-party libraries (often only distributed in binary form) or are provided through mobile app stores where users have no control over the tools used for implementing these applications. Furthermore, most of these solutions are only developed for user-level software <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b23">24]</ref>, whereas the operating system kernel and low-level services are implicitly assumed to work correctly. The few existing wholesystem solutions <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b14">15]</ref>   In contrast, it is our goal to support reliable operation of binary-only applications, to include operating system services, and to use inexpensive, heterogeneous multicores. We strive to design an operating system architecture that continues correct execution in the presence of transient hardware faults. We focus on SEUs affecting functional units of the CPU, whereas we assume memory contents to be protected by hardware mechanisms, such as Error-Correcting Codes (ECC) <ref type="bibr" target="#b17">[18]</ref>.</p><p>Our approach is based on low-overhead replicated execution of processes, called redundant multithreading (RMT) <ref type="bibr" target="#b19">[20]</ref>. In contrast to previous approaches <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b23">24]</ref>, we implement RMT as an operating system service, called Romain. In this paper we focus on the lower-level part of the system: In order to reliably provide RMT, a subset of software components always needs to function correctly. We call this subset the Reliable Computing Base (RCB) and want find out how to protect it against SEUs. The overall architecture, called ASTEROID, is depicted in <ref type="figure" target="#fig_0">Figure 1</ref>.</p><p>We briefly describe our implementation of RMT as an OS service in Section 2. In Section 3 we review existing trends in processor architecture and reason that a heterogeneous architecture consisting of few resilient CPU cores and many non-resilient ones appears a promising way of protecting the RCB. In order to combine the AS-TEROID design with such a hardware platform we require efficient signalling between CPUs. We evaluate three different signalling implementations in Section 4. Finally, we review the resulting system design and identify points in our system that still remain vulnerable to SEUs in Section 5. We show that the software and hardware components to address these issues already exist, although nobody has yet combined them to provide faulttolerant execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Redundant Multithreading as an Operating System Service</head><p>We now briefly describe the current state of ASTEROID, our resilient operating system shown in <ref type="figure" target="#fig_0">Figure 1</ref>. For a more detailed description, please refer to <ref type="bibr" target="#b7">[8]</ref>. ASTER-OID splits the system into two layers: user applications and the Reliable Computing Base. We detect hardware errors that occur during the execution of user applications by transparently replicating those applications and comparing their states before any state is externalized. Our implementation, Romain, is based on the idea of redundant multithreading (RMT) <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b21">22,</ref><ref type="bibr" target="#b23">24]</ref>. A replicated application as depicted in <ref type="figure" target="#fig_1">Figure 2</ref> is created by instantiating a master process. The master process then creates identical replicas of the application, each running in a dedicated address space in order to achieve isolation in the case of a faulting replica. Leveraging manycore systems, we schedule each replica on its own physical CPU core so that replicas can execute independently as long as they don't interact with the outside world. Whenever a replica thread raises a CPU exception (the most important ones being system calls and page faults), the kernel migrates the thread from the replica to the master address space. The faulting thread then waits for all other replicas to do the same. At this point the replicas have reached an identical state if no hardware fault occurred. After comparing all replica states, one replica handles the fault locally on its own CPU: page faults are resolved directly within the master, system calls are redirected to the underlying kernel. The result of this handling is applied to all other replicas and thereafter each replica moves back to its respective address space and resumes execution. For later reference, we call this fault handling mechanism Local Fault Handling.</p><p>ASTEROID is based on the L4/Fiasco.OC microkernel and the L4 Runtime Environment (L4Re) <ref type="bibr" target="#b16">[17]</ref>. Building on this design, we run traditional operating system services, such as device drivers and protocol stacks as user-space applications. This has the key advantage that most OS services can be protected against SEUs by employing replicated execution.</p><p>The RCB of our system comprises the microkernel, a couple of L4Re services and the Romain replication framework. Unfortunately, we cannot protect the RCB against hardware errors using the RMT mechanism we implemented for user applications. Hence, we need to harden it using a different approach, which is the contribution of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Protecting the RCB</head><p>The elements of the RCB are under our full control and with their source code available, we could use compilerbased solutions for protecting against hardware errors. Techniques such as software-encoded processing <ref type="bibr" target="#b9">[10]</ref> claim to detect all kinds of erroneous deviations. However, these have only been developed and tested for userlevel software. In order to apply them to kernel code, we expect that we'd have to pay special attention to asynchronous activities, such as interrupt handlers. Furthermore, we cannot predict the performance impact these techniques would have on kernel code, which is often highly optimized for heavily used code paths. We explore a different direction for protecting the RCB: We believe that protection can efficiently be achieved by relying on hardware support.</p><p>Highly resilient applications in space and avionics usually employ radiation-hardened hardware <ref type="bibr" target="#b2">[3]</ref>, which is unfortunately too expensive to be available in consumer electronics. In contrast, we propose a heterogeneous manycore hardware platform that is based on already existing hardware components and consists of a few resilient and many non-resilient cores. Resilient cores (ResCores) are specially designed to deal with SEUs at the hardware level, whereas non-resilient cores (NonResCores) are designed using the cheapest possible implementation that fits the hardware vendors' needs (e.g., in terms of area cost, energy usage etc.).</p><p>Splitting hardware into these two resilience classes allows for flexibility and increased utilization: instead of over-provisioning hardware resources in order to always guarantee correct execution, our design allows to dynamically assign cores to different purposes. A NonResCore may be used to execute an application that was hardened using compile-time encoding and does not require any replication. Other NonResCores may be assigned to execute an unprotected application in a replicated manner, requiring a ResCore for coordination.</p><p>As OS researchers we don't have the expertise to implement the required hardware changes ourselves. We don't know whether these issues should be addressed by replicating functional units, modifying the hardware production process, or relying on alternative implementations of the same hardware feature. However, we observe trends towards heterogeneous platforms in modern hardware architectures and therefore believe that it is realistic to expect the arrival of a ResCore hardware platform in the mainstream market soon.</p><p>Back in 1999, Austin proposed the DIVA architecture <ref type="bibr" target="#b1">[2]</ref>, which contained 'checker cores' built with a larger structure size than other computational units on the same chip. This design was never used in general purpose hardware, though. However, today we are seeing the widespread introduction of heterogeneous hardware in general purpose systems:</p><p>• ARM recently introduced its big.LITTLE architecture <ref type="bibr" target="#b0">[1]</ref>, which combines complex and less-complex processors on a single chip. The purpose of this split is to save energy by keeping the more complex core switched off whenever possible. Nevertheless, we can also see this split as a first step towards making ResCores and NonResCores available.</p><p>• The Cell microarchitecture <ref type="bibr" target="#b11">[12]</ref> combines one fullfledged processor with eight vector processing units, which can be used for non-arithmetic processing as well. In Section 5 we will see that this microarchitecture has additional benefits with respect to resilient computing.</p><p>• Researchers are investigating the use of general purpose graphics processors (GPGPUs) at various levels of the software stack. While this research focusses on the computational power provided by GPGPUs, these findings may be generalized and apply to fault-tolerant systems as well.</p><p>Given these observations, we assume for the rest of this paper that a heterogeneous many-core platform consisting of ResCores and NonResCores will be available. We now look at how to design a resilient OS around such an architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">From ResCores to Reliability</head><p>The fundamental idea for protecting the RCB based on ResCores is simple: all RCB code executes on ResCores, whereas everything else runs on NonResCores. This idea is not new. Split operating system architectures, such as FlexSC <ref type="bibr" target="#b22">[23]</ref> and <ref type="bibr">Nix [4]</ref>, demonstrated that splitting the system into dedicated cores for handling certain classes of work allows to efficiently utilize manycore systems. However, their authors did not focus on resilience against hardware faults. The Romain replication framework allows for a natural split: replicas execute on NonResCores and CPU exceptions raised by replicas are handled by code running on a ResCore. The interesting question is: How do we efficiently switch between these cores? And, can we deal with faults that occur while such a switch is in progress?</p><p>We implemented three alternatives for splitting Romain: migration, split handling with synchronous notifications, and shared-memory polling.</p><p>1. Migration <ref type="figure" target="#fig_0">(Figure 3.1</ref>  replica raises a CPU exception, it notifies the handler using the synchronous IPC mechanism provided by L4/Fiasco.OC. The replica then blocks waiting for a reply.</p><p>The notification wakes up the handler thread, which then waits for notifications from the other replicas. Once these notifications arrived, the handler thread performs state comparison and fault handling, applies results to the replicas, and finally sends wakeup notifications to the replicas. 3. Split handling with shared-memory polling <ref type="figure" target="#fig_2">(Fig- ure 3.</ref>3): The split handling approach above still requires synchronous notifications. In terms of reliability, this means that the underlying kernel mechanism must work correctly at all times. Additionally, FlexSC <ref type="bibr" target="#b22">[23]</ref> demonstrated that asynchronous calls through shared memory may lead to better system call throughput and latency than synchronous ones. Therefore, we implemented a third notification mechanism that works similar to the previous one. However, instead of using synchronous IPC, the fault handler thread as well as the replicas await notifications by polling a predefined memory location to switch to a certain value.</p><p>We now compare these notification mechanisms to the Local Fault Handling approach described in Section 2. First, all three mechanisms provide fault-tolerant com- parison of replica states and handling of CPU exceptions by executing the respective code on a ResCore. In contrast, local fault handling is unaware of the existence of ResCores and hence cannot reliably handle exceptions.</p><p>To assess performance, we executed two programs from the MiBench benchmark suite <ref type="bibr" target="#b12">[13]</ref> using Romain <ref type="bibr" target="#b0">1</ref> . We first ran the benchmarks natively on top of the L4/Fiasco.OC microkernel. Thereafter, we executed the benchmarks with Romain in double (DMR) and triple modular redundancy (TMR) using the four different notification mechanisms. The test machine was a computer with 12 physical Intel Core2 CPUs running at 2.6 GHz. Hyperthreading was turned off. Replica threads as well as the RCB exception handler thread were each pinned to a dedicated CPU. <ref type="figure" target="#fig_3">Figure 4</ref> shows the overhead of our benchmarks relative to single-threaded execution. We see that in comparison to local handling (green bar), migrating threads (red bar) or using synchronous notifications (yellow bar) add substantial amounts of overhead. While these effects could be seen as tolerable in DMR, TMR overhead for synchronous IPC notifications is up to twice as high as the overhead for local fault handling.</p><p>In contrast, polling a shared memory location (blue bar) appears to be even faster than the local fault handling mechanism. The reason for this observation is that for local fault handling the participating threads need to synchronize and decide who is going to perform the actual handling. In the case of the split handler thread, this is not necessary, as only this dedicated thread is able to perform exception handling. This result is not surprising, but in line with the observations of Soares' FlexSC <ref type="bibr" target="#b22">[23]</ref>.</p><p>It needs to be noted that these numbers were measured on an SMP architecture providing uniform memory access and cache coherence. Modern multicore systems often use a non-uniform memory hierarchy. Blagodurov et al. showed that performing wrong memory placement in such an architecture may substantially increase memory access latencies <ref type="bibr" target="#b5">[6]</ref>. On such systems the benefit of using shared memory polling may decrease.</p><p>Experimental architectures, such as the Intel Single Chip Cloud Computer (SCC) <ref type="bibr" target="#b10">[11]</ref>, remove cache coherence completely. In such an architecture, polling becomes impossible and we need to resort to one of the other notification mechanisms. We draw the conclusion, that our envisioned resilient hardware platform will require a fast inter-CPU messaging mechanism. Such a feature, called Message Passing Buffers, already exists in Intel's SCC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Hardware Requirements</head><p>We showed that the ASTEROID resilient system architecture can be mapped to a hardware platform providing ResCores. However, even with such a system in place, there remain points at which an SEU might remain undetected or cause havoc. These points reside at the transitions between non-reliable and reliable execution.</p><p>First, our whole system relies on CPU exceptions being triggered at the right point in time. An SEU might lead a CPU to either fail triggering an exception or to trigger a spurious exception. These kinds of errors will be detected by our system: comparison with non-faulty replicas will pinpoint the spurious exception. Using a watchdog mechanism that forces CPUs to trigger an exception after a limited amount of time, failure to do so can be detected as well.</p><p>Before notifying the exception handler, the replica thread's state needs to be stored somewhere in memory, so that a separate exception handler thread is able to access it. As a second potential error, the state may become corrupted while writing it to memory. This will also be detected by our architecture once replica states are compared.</p><p>Third, any memory accesses performed while executing on a NonResCore may write to the wrong memory location, thereby overwriting either other replicas' states or critical data of the Romain master. As described in Section 2, we use address spaces to isolate replicas. Hence, we require a correctly working MMU on every NonResCore. However, only ResCores must be able to configure the MMU of a NonResCore in order to prevent an SEU from triggering page table entries to be modified. If this is not easily possible, we alternatively imagine an additional layer of memory protection that limits the accessibility of physical memory to certain cores.</p><p>Such feature already exists in today's hardware: IOMMUs perform an additional translation between physical and device-physical addresses. Furthermore, Intel's SCC <ref type="bibr" target="#b10">[11]</ref> allows configuring memory regions to be accessible only by a specific core. As another solution, in the Cell microarchitecture <ref type="bibr" target="#b11">[12]</ref>, each core has private memory that no other core can access. Such a design might be extended to implement private memory on NonResCores that can still be accessed by ResCores, so that replica state stored in private memory is safe from faulting replicas, but can still be read and modified by master code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>In this paper we presented an overview of the ASTER-OID operating system architecture providing transparent redundant multithreading for user-level applications. We pointed out that in order for this system to work, its Reliable Computing Base needs to be protected as well. As a way of protecting the RCB, we proposed the idea of structuring our OS on top of a heterogeneous hardware platform that provides resilient cores to run RCB code and cheap, non-resilient cores to run application code. We evaluated three alternative methods for sending notifications between application and RMT code and discussed the remaining weak spots that may still be vulnerable to SEUs.</p><p>Previous approaches tried to address SEUs by inventing completely new hardware. In contrast, we identified hardware features our OS needs to rely on: memory protection using MMUs and CPU-private memory, efficient inter-CPU messaging, and the possibility to implement a watchdog mechanism. These features already exist in state-of-the-art computer architectures. Therefore, it is feasible to expect them to be combined into a completely fault-tolerant architecture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgments</head><p>This work was partially supported by the German Research Foundation (DFG) as part of the priority program "Dependable Embedded Systems" (SPP 1500 -spp1500.itec.kit.edu).</p><p>Our colleagues Philip Axer and Michael Roitzsch provided valuable feedback on drafts of this paper. Furthermore, we would like to thank our colleague Michael Engel for fruitful discussions on the concept of the Reliable Computing Base.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: ASTEROID Resilient OS Architecture</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Replicated Application</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Notification variants: 1) Replica thread (Rep) is migrated from NonResCore to ResCore for fault handling. 2) Rep thread sends a synchronous notification to activate a handler thread on a ResCore. 3) Split handler thread and replica poll on shared memory location for activation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Replication runtime overhead for different notification mechanisms. Overhead is calculated with respect to single-threaded execution in Local Fault Handling mode.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head></head><label></label><figDesc>are prohibitively expensive for general purpose computers.</figDesc><table>Replicated 
Driver 

Replicated 
Application 

L4 Runtime 
Environment 
Romain 

L4/Fiasco.OC microkernel 

Reliable 
Computing 
Base 

</table></figure>

			<note place="foot" n="1"> The subset was selected by selecting those benchmarks that showed the highest overheads in [8].</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arm</forename><surname>Ltd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Big</surname></persName>
		</author>
		<title level="m">LITTLE processing with ARM Cortex-A15. Whitepaper</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">DIVA: A reliable substrate for deep submicron microarchitecture design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Austin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings. 32nd Annual International Symposium on</title>
		<meeting>32nd Annual International Symposium on</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="196" to="207" />
		</imprint>
	</monogr>
	<note>Microarchitecture</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bae</forename><surname>Systems</surname></persName>
		</author>
		<ptr target="http://www.baesystems.com/product/BAES_028145" />
		<title level="m">RAD750 family of products</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">High performance cloud computing is Nix</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ballesteros</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">J</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Forsyth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Guardiola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Mckie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Minnich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Soriano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 Bell Labs Technical Conference</title>
		<meeting>the 2011 Bell Labs Technical Conference</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Advanced architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernick</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Bruckert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Vigna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Jar-Dine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klecka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Smullen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nonstop</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Dependable Systems and Networks, 2005. DSN 2005. Proceedings. International Conference on</title>
		<imprint>
			<date type="published" when="2005-07" />
			<biblScope unit="page" from="12" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A case for NUMA-aware contention management on multicore systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Blagodurov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zhuravlev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dashti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fe-Dorova</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference</title>
		<meeting>the USENIX Annual Technical Conference</meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Designing reliable systems from unreliable components: the challenges of transistor variability and degradation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Borkar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="10" to="16" />
			<date type="published" when="2005-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Operating system support for redundant multithreading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D ¨ Obel</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Artig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Engel</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th International Conference on Embedded Software (EMSOFT)</title>
		<meeting><address><addrLine>Tampere, Finland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Razor: a low-power pipeline based on circuitlevel timing speculation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ernst</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">S</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ziesler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Blaauw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Austin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Flautner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mudge</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Microarchitecture, 2003. MICRO-36. Proceedings. 36th Annual IEEE/ACM International Symposium on (dec. 2003)</title>
		<imprint>
			<biblScope unit="page" from="7" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">ANencoding compiler: Building safety-critical systems with commodity hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fetzer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Schiffel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>And S ¨ Usskraut</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th International Conference on Computer Safety, Reliability, and Security</title>
		<meeting>the 28th International Conference on Computer Safety, Reliability, and Security<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="283" to="296" />
		</imprint>
	</monogr>
	<note>SAFECOMP &apos;09</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">SCC: A flexible architecture for many-core platform research</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gries</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Konow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Riepen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing in Science and Engineering</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="79" to="83" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Chip multiprocessing and the Cell broadband engine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gschwind</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd conference on Computing frontiers</title>
		<meeting>the 3rd conference on Computing frontiers<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
	<note>CF &apos;06, ACM</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">MiBench: A free, commercially representative embedded benchmark suite</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guthaus</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">R</forename><surname>Ringenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Austin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename><surname>Mudge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workload Characterization</title>
		<meeting>the Workload Characterization<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="3" to="14" />
		</imprint>
	</monogr>
	<note>WWC-4</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
				<title level="m">IBM. PowerPC 750GX Lockstep facility. IBM Application Note</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
				<ptr target="http://www-03.ibm.com/systems/z/os/zos/" />
		<title level="m">IBM. z/OS -a smarter operating system for smarter computing</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<ptr target="http://www.itrs.net/Links/2011ITRS/Home2011.htm" />
		<title level="m">ITRS. International Technology Roadmap for Semiconductors</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Taming Subsystems: Capabilities as Universal Resource Access Control in L4</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lackorzynski</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Warg</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IIES &apos;09: Proceedings of the Second Workshop on Isolation and Integration in Embedded Systems</title>
		<meeting><address><addrLine>Nuremberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="25" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Architecture Design for Soft Errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mukherjee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<pubPlace>San Francisco, CA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Fault-tolerant design of the IBM Power6 Microprocessor</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reick</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sanda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Swaney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kellington</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Floyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henderson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Micro</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="30" to="38" />
			<date type="published" when="2008-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Transient fault detection via simultaneous multithreading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reinhardt</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mukherjee</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGARCH Comput. Archit. News</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="25" to="36" />
			<date type="published" when="2000-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Software implemented fault tolerance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reis</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">A</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vachharajani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Rangan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">August</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">I</forename><surname>Swift</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Code Generation and Optimization</title>
		<meeting>the International Symposium on Code Generation and Optimization</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="243" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Using process-level redundancy to exploit multiple cores for transient fault tolerance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shye</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Moseley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">J</forename><surname>Blomstedt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Connors</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename></persName>
		</author>
		<idno>DSN &apos;07</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks</title>
		<meeting>the 37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="297" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">FlexSC: flexible system call scheduling with exception-less system calls</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soares</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stumm</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX conference on Operating systems design and implementation</title>
		<meeting>the 9th USENIX conference on Operating systems design and implementation<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
	<note>OSDI&apos;10, USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Compilermanaged software-based redundant multi-threading for transient fault detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-S</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ying</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Code Generation and Optimization</title>
		<meeting>the International Symposium on Code Generation and Optimization<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="244" to="258" />
		</imprint>
	</monogr>
	<note>CGO &apos;07</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
