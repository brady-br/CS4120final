<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T01:50+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Block-level RAID is dead</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raja</forename><surname>Appuswamy</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Vrije Universiteit</orgName>
								<address>
									<settlement>Amsterdam</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">C</forename><surname>Van Moolenbroek</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Vrije Universiteit</orgName>
								<address>
									<settlement>Amsterdam</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">S</forename><surname>Tanenbaum</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Vrije Universiteit</orgName>
								<address>
									<settlement>Amsterdam</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Block-level RAID is dead</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The common storage stack as found in most operating systems has remained unchanged for several decades. In this stack, the RAID layer operates under the file system layer, at the block abstraction level. We argue that this arrangement of layers has fatal flaws. In this paper, we highlight its main problems, and present a new storage stack arrangement that solves these problems.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The concept of RAID <ref type="bibr" target="#b12">[13]</ref> is a landmark in the history of storage systems. Taking advantage of the traditional block interface used by file systems, RAID algorithms were integrated at the block level, thus, retaining perfect backward compatibility with existing installations. As installations became larger, administrative tools like volume managers <ref type="bibr" target="#b19">[20]</ref> followed suit. These tools broke the "one file system per disk" bond and made it possible to resize file systems on the fly. Volumes also served as a convenient point for policy assignment (choosing RAID levels for instance) and quota enforcement. Together, we refer to RAID and volume management solutions as the RAID layer.</p><p>The compatibility-driven integration of the RAID layer at the block-level has remained unchanged despite significant changes in the storage hardware landscape. We believe that it is time to retire block-level RAID. In this paper, we highlight several significant problems associated with the traditional block-level RAID implementation (Section 2). We briefly discuss proposed solutions and explain why they do not solve all the problems (Section 3). We then present Loris, a clean-slate design of the storage stack (Section 4), and highlight how it solves all the problems by design (Section 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Problems with block-level RAID</head><p>In this section, we will provide an in-depth look at some of the problems that plague block-level RAID implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Silent data corruption</head><p>Modern disk drives exhibit a range of partial failures <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b5">6]</ref>, like lost, misdirected, and torn writes. In all these cases, the drive reports back a success, resulting in data being silently corrupted.</p><p>Various checksumming techniques have been developed to detect data corruption <ref type="bibr" target="#b15">[16]</ref> and they offer varying levels of reliability. One technique that is capable of detecting all the aforementioned sources of corruption, involves storing the checksum of a block with its parent (the inode for instance). This has been referred to as parental checksumming. Since such a technique involves knowledge of block relationships, it can only be employed by file systems.</p><p>However, parental checksumming loses its benefit when used in combination with block level RAID. This is due to the fact that while file system-initiated reads undergo verification, RAID-initiated reads (a subtractive read to recompute parity for instance) are completely unverified. As a result, RAID can propagate data corruption, leading to data loss <ref type="bibr" target="#b11">[12]</ref>. For instance, if a corrupt unverified data block is used for parity computation, the parity block becomes corrupted. Parental checksumming detects this problem on the next read request, but the data cannot be recovered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">System failure</head><p>Crashes and power failures in RAID systems result in the consistent update problem where two or more disks must be updated in a consistent manner. A window of vulnerability exists between a crash and complete recovery, during which a disk failure can result in data loss. This has also been referred to as the "write hole" <ref type="bibr" target="#b3">[4]</ref>. While hardware RAID relies on NVRAM to solve this problem, crash recovery in software RAID systems is provided by either doing an expensive whole disk resynchronization or using journaling. Resynchronization adversely affects availability <ref type="bibr" target="#b6">[7]</ref> and is impractical with disk sizes doubling every few years. Using journaling in block-level RAID on the other hand has a significant impact on performance, and results in functionality being replicated in both the file system and RAID layers <ref type="bibr" target="#b8">[9]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Device failure</head><p>Research has revealed the benefits of a storage array that degrades gracefully <ref type="bibr" target="#b16">[17]</ref> when unexpected failures occur. To achieve such a property, a storage array must (1) replicate metadata selectively to make sure that the whole directory hierarchy remains navigable, (2) provide fault-isolated positioning of files such that a failure of any single disk does not render all files unavailable. An array that is block-liveliness aware can avoid restoring unused data blocks during recovery and thus, reduce the data loss window before another failure occurs. It is impossible to provide any of these functionalities in a traditional block-level RAID implementation, because it is unaware of both relationship between blocks and liveliness of blocks <ref type="bibr" target="#b4">[5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Administration nightmare</head><p>Block-level volume management is a tedious process involving a series of error-prone steps. A simple operation such as adding a new disk drive requires several steps like adding space to a volume group, expanding a logical volume, and then expanding a file system <ref type="bibr" target="#b19">[20]</ref>.</p><p>Software-based RAID solutions expose an array of tunable parameters for configuring a storage array based on the expected workload. It has been shown that an improperly configured array can render layout optimizations employed by a file system futile <ref type="bibr" target="#b17">[18]</ref>. This is an example of the more general "information gap" problem <ref type="bibr" target="#b7">[8]</ref> -different layers in the storage stack performing their own optimizations oblivious to the effect that these optimizations might have when combined.</p><p>Different files have different levels of importance and need different levels of protection. However, policies like the RAID level to use, encryption, and compression, are only available on a per-volume basis rather than on a per-file basis. We argue that an ideal storage system should be flexible enough to support policy assignment on a per-file, per-directory, or a per-volume basis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Heterogeneity issues</head><p>New devices are emerging with different data access granularities and new storage interfaces. Integrating these devices into the storage stack has been done in two ways. The first approach involves building file systems that are aware of device-specific abstractions <ref type="bibr" target="#b9">[10]</ref>. However, the traditional block-based RAID layer is incompatible with devices that offer an abstraction different from the block abstraction (like byte-granular flash devices). As a result, device-specific file systems cannot be positioned on top of the traditional RAID layer.</p><p>The other approach involves adding a layer that translates block requests to match device-specific abstractions <ref type="bibr" target="#b9">[10]</ref>. Such a translation layer could then be positioned below the RAID layer. Not only does this cause duplication of functionality, but it also widens the information gap. The only way to avoid this duplication is by redesigning the storage stack from scratch <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b1">2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Proposed solutions</head><p>There are several approaches to solving the problems mentioned in the previous section. We outline the most important ones here, namely, (1) inferring semantic information, (2) sharing semantic information, (3) merging file system and RAID layers, and (4) stackable filing. However, as we will show, none of these approaches tackle all the problems.</p><p>Internal information of one layer can be inferred by another layer. Semantically smart disks <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b16">17]</ref> infer file system specific information to improve reliability and performance at the RAID level. This approach requires the RAID layer to know or guess the file system layout, making it nonportable and error-prone.</p><p>Instead of inferring information, one can share layerinternal information between these layers. For example, ExRAID <ref type="bibr" target="#b7">[8]</ref> exposes size and performance characteristics about individual RAID disks to the file system. While sharing information can be used to make informed decisions <ref type="bibr" target="#b7">[8]</ref>, it does not provide a new division of labor among cooperating layers. As a result, the reliability and heterogeneity problems cannot be solved.</p><p>A few projects have refactored the traditional file system/RAID layering. For example, the ZFS <ref type="bibr" target="#b3">[4]</ref> proposes a new stack made up of three layers. The lowest layer, called the Storage Pool Allocator (SPA), provides both block allocation and RAID support. However, because the SPA exposes a block interface, its algorithms suffer from the same heterogeneity problems as the traditional RAID layer.</p><p>RAIF <ref type="bibr" target="#b10">[11]</ref> is a stackable file system that introduces RAID policies on a per-file basis, without changing the underlying file systems. While this provides more flexibility, it does not solve the reliability or heterogeneity problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The Loris storage stack</head><p>In this section, we discuss the design of Loris, our new storage stack. Loris is made up of four layers as shown in <ref type="figure" target="#fig_0">Figure 1</ref>. The interface of each layer to the layer above (its client) is a standardized file interface that supports operations such as create, delete, read, write, and truncate. In addition to file manipulation operations, the interface also has operations for setting and retrieving attributes. The use of attributes in Loris is to (1) share information between layers, and (2) store out-of-band data on a per-file basis, as will become clear when we describe the internals of each layer.</p><p>We now detail the division of labor between layers in a bottom-up fashion. Just like the network protocol stack, each layer in Loris has well-defined functionalities. Similar to networking protocols, different protocols can be used within each of these layers to provide dif- ferent functionalities. For each layer, we first provide an abstract description of its responsibilities. We then describe the protocol we implemented for that layer, in our prototype, to make things more concrete. Our prototype has been implemented on MINIX 3 <ref type="bibr" target="#b18">[19]</ref>. Our protocols attempt to mirror the MINIX 3 file system's algorithms, so that we can make a fair evaluation of any overheads introduced by Loris.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Physical layer</head><p>The physical layer provides device specific layout schemes to store files and attributes, exposing a physical file abstraction to its clients. By working with physical files, the clients are abstracted away from device specific protocols employed by the physical layer. All physical layer protocols are also required to implement parental checksumming.</p><p>Our prototype physical layer protocol provides a modified MINIX 3 file system layout scheme for block devices. Each file is represented on disk by an inode. Like the traditional UNIX inode, our inode stores direct and indirect block pointers. Each block pointer is accompanied in the inode by a CRC32 checksum for the block it points to. We refer to this block pointer -checksum pair as a "safe block pointer." The indirect blocks similarly store sets of safe block pointers. In addition to these safe pointers, the inode has a fixed amount of space available for storing attribute data.</p><p>In order to make it possible to checksum metadata blocks, there are three special files on the disk: the inode bitmap file, the block bitmap file, and the "root file." The bitmap files contain checksums for the bitmap blocks. The root file forms the root of the parental hierarchy. Its data blocks contain pairs of inode numbers and corresponding checksums. Each inode on the disk is checksummed individually, in contrast to the bitmaps which are checksummed on a per-block basis. The root file's checksum is stored in the superblock. In order to prevent each individual block write from triggering cascading checksum updates all the way to the root, we use a small metadata cache to delay the checksum computation of metadata blocks until they are written out.</p><p>We run multiple instances of this layout protocol, one per disk drive, as separate processes, in our prototype stack. Each disk is assigned a global device identifier when it is added to Loris. Each layout instance registers itself to the logical layer using this identifier during system startup.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Logical layer</head><p>The logical layer combines multiple physical files to provide a virtualized, logical file abstraction. Clients of the logical layer perceive the logical file to be a single, flat file. The logical layer abstracts away the details of how many physical files there are, and where they are stored, which may differ on a per-file basis. Protocols in the logical layer provide the traditional RAID and volume management functionalities.</p><p>Our prototype logical layer protocol provides support for RAID levels 0, 1, 4, and 5. The central data structure in our protocol is the mapping file. The mapping file is array of entries, one per logical file. Each entry contains: (1) the file identifier used by clients to identify the file, (2) the RAID level for this file, (3) stripe size used for this file and (4) device identifiers -inode number pairs, to identify the physical files that make up this logical file. Thus, a crucial difference between our implementation and any traditional block-level RAID implementation is the fact that RAID levels are assigned on a per-file basis. We will describe how these entries are created when we describe the naming layer. Since the mapping file is a crucial piece of metadata, it is mirrored on all devices.</p><p>Once an entry has been made in the mapping, processing a request involves looking up the entry corresponding to the file identifier received, and forwarding the call to the right physical instances. Let us consider a read request for a logical file. Let us assume that the mapping entry for this file looks like &lt;F, 0, 4096, PF1=&lt;D1, I1&gt;, PF2=&lt;D2, I2&gt;&gt;. It maps file identifier F to RAID level 0, stripe size 4096, and two physical files, PF1, the file on device D1 with inode number I1, and PF2, the file on device D2 with inode number I2. When the logical layer receives a request to read, say, 40960 bytes, from offset 0, it determines that the logical byte ranges 0-4096, 8192-12288 and so on, map onto the byte range 0-20480 in physical file PF1 and the logical byte ranges 4096-8192, 12288-16384 map onto the byte range 0-20480 in physical file PF2. The logical layer now forwards the read request to the physical instances that handle PF1 and PF2, for the aforementioned byte ranges, to satisfy the read request. Once the read results come back, they are combined into a properly-ordered flat result.</p><p>The logical layer also provides on-the-fly failure recovery on a per-file basis. For instance, if one of the physical instances responds back with a checksum error for a read request, the logical layer tries to recover the corrupt data, if possible, by recomputing valid data from redundant information, and restoring it onto the physical instance that failed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Cache layer</head><p>The cache layer provide the in-core file abstraction to the naming layer. Cache layer protocols are responsible for providing file data caching in collaboration with the virtual memory subsystem. In systems that provide a unified page cache at the VFS level, the naming layer could communicate directly with the logical layer.</p><p>Our prototype uses a static file cache to buffer user data, as MINIX 3 does not have a unified page cache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Naming layer</head><p>The naming layer provides support for naming, organizing and searching files. For example, a naming layer protocol could support POSIX style naming while another could support a more search-friendly, attributebased naming.</p><p>Our prototype naming protocol provides a POSIX front-end. On file creation, the naming layer picks a file identifier and stores the name/identifier mapping as a directory entry. It is important to note here that directories are also stored as regular files-below the naming layer, there are no directories, only files. All POSIX attributes, like file mode and access time, are stored as Loris attributes. The naming layer uses the setattribute call to pass down the attribute data. The physical layer processes the setattribute call by storing the attribute data in the inode.</p><p>The naming layer also uses attributes to mirror directories on all disks for providing graceful degradation. When a directory is created, the naming layer sends a create call to the cache layer. In addition to passing the file identifier for this directory, the naming layer also passes the RAID level (RAID 1) as an attribute. The cache forwards the create call to the logical layer, which then uses the attribute to construct a new entry for this file in the mapping, and forwards the create call to all of the physical instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Legacy support in Loris</head><p>The new division of labor among layers in Loris makes it incompatible with the traditional file system design.</p><p>The naming, cache and physical layers in Loris together perform the role of the traditional file system layer. The logical layer in Loris corresponds to the RAID layer in the traditional stack. This essentially means that one cannot integrate a traditional file system with the new stack. However, because Loris runs under VFS, one could run legacy file systems unmodified next to it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Solving problems the Loris way</head><p>In this section, we describe how Loris solves the problems we mentioned in Section 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Data corruption</head><p>As a result of repositioning the RAID layer, the physical layer serves requests originating from the logical layer just like application-issued requests. Thus, a physical layer that implements parental checksumming acts as a single point of data verification. Therefore, by requiring all layout schemes in the physical layer to implement parental checksumming, we convert fail-partial failures <ref type="bibr" target="#b13">[14]</ref> into fail-stop failures. The logical layer can then work on fail-stop devices to protect against data loss without worrying about spreading data corruption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Crash recovery</head><p>While traditional crash recovery techniques guarantee that the storage array or the file system is brought back to a consistent state, none of them guarantee atomic updates of user data. Data journaling is one way to provide such atomicity but is generally considered too expensive since it involves writing all data twice. With a highly flexible policy selection in place, we have an infrastructure where users are free to specify policies like RAID level on a per-file basis. An approach to crash recovery that we are investigating makes use of this fact to provide "metadata replay."</p><p>Metadata replay is based on the counterintuitive idea that it is user data that must be protected and atomically updated, not the system metadata. To make this possible, we intend to (1) provide support for write-ahead logging for selective user data, and (2) add support for maintaining metadata consistency using a technique similar to doublefs <ref type="bibr" target="#b0">[1]</ref>. With this infrastructure, when a crash occurs, the logical layer coordinates the recovery of all physical layers to the last globally consistent state. The write-ahead log can now be replayed to atomically update user data and, as a side effect, regenerate system metadata.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Graceful failure and file-aware rebuild</head><p>Our new design is a natural fit for implementing graceful degradation: (1) the availability of per-file policy selection makes it possible to provide selective metadata replication, and (2) since the physical layers expose files rather than blocks, the logical layer can choose to store whole files in a single device, thereby providing faultisolated positioning. In addition, since the RAID algorithms are file-aware, no unused data blocks need to be recovered thereby reducing the reconstruction time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Simplified administration</head><p>By positioning RAID and associated functionalities in the logical layer, the new stack provides direct support for (1) Storage pool <ref type="bibr" target="#b3">[4]</ref> style device management, and (2) AFS-style volume management <ref type="bibr" target="#b14">[15]</ref>.</p><p>When a new device is added to Loris, it will be assigned a new device identifier. A new physical instance will be started for this device and it registers itself with the logical layer as a source of physical files. From here on, the logical layer can use this physical instance to create new files or migrate existing files.</p><p>By using AFS-style volume management, volumes can be created on a per-user or per-project basis, for instance. These would serve as units of administration and quota enforcement. The logical layer would support operations for creating and deleting these volumes. All volumes would share the storage space, since files belonging to any volume can be located on any physical instance. We are working on implementing such a volume manager for Loris.</p><p>In addition to these advantages, the new stack provides a policy/mechanism split. While the mechanism to provide RAID algorithms is in the logical layer, the policy that assigns RAID levels to files can be enforced by any layer. For instance, the naming layer can specify the policy on a per-file basis similar to RAIF <ref type="bibr" target="#b10">[11]</ref>. For instance, cherished photographs could be replicated on multiple devices while compiler-temporary files are not. Thus, policies can be applied at several granularities -per-file, per-directory, per-volume or even globally, across all files.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Embracing heterogeneity</head><p>By providing the traditional volume management techniques at the file level, Loris makes these functionalities device-independent. Thus, Loris can support heterogeneous installations where block-based disks coexist with byte-granular flash devices and object-granular OSDs <ref type="bibr" target="#b2">[3]</ref>. Functionalities like RAID and snapshotting would apply across these device types without requiring any modification. In addition, as physical layer protocols work on devices directly, they can exploit device-specific properties to improve reliability and performance.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The figure depicts (a) the arrangement of layers in the traditional stack, and (b) the new layering in Loris. Only the layers above the dotted line are file-aware.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>The integration of RAID algorithms at the block level has remained the same over several decades. We investigated the compatibility-driven block-level integration of RAID and presented several problems inherent to this integration. We proposed Loris, a clean-slate design of the storage stack that solves all these problems by design. The new layering in Loris opens up several interesting questions for future research.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Double the metadata, double the fun: A cow-like approach to file system consistency</title>
		<ptr target="http://valerieaurora.org/review/doublefs.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<ptr target="http://www.linux-mtd.infradead.org/" />
	</analytic>
	<monogr>
		<title level="j">Memory technology devices</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Object-based storage device commands, ansi standard incits</title>
		<imprint>
			<biblScope unit="page" from="400" to="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Sun microsystems, solaris zfs file storage solution. solaris 10 data sheets</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Semantically-smart disk systems: past, present, and future. SIGMETRICS Perform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arpaci-Dusseau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename><surname>Bairavasun-Daram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">N</forename><surname>Denehy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">E</forename><surname>Popovici</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">I</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sivathanu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Eval. Rev</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="29" to="35" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An Analysis of Data Corruption in the Storage Stack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bairavasundaram</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">N</forename><surname>Goodson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arpaci-Dusseau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Sixth USENIX Conf. on File and Storage Technologies (FAST &apos;08</title>
		<meeting>of the Sixth USENIX Conf. on File and Storage Technologies (FAST &apos;08</meeting>
		<imprint>
			<date type="published" when="2008-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Towards availability benchmarks: a case study of software raid systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patterson</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 2000 USENIX Ann. Tech. Conference</title>
		<meeting>of the 2000 USENIX Ann. Tech. Conference</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="263" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Bridging the Information Gap in Storage Protocol Stacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denehy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">E</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arpaci-Dusseau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Proc. of the USENIX Ann. Tech. Conf. (USENIX &apos;02</title>
		<imprint>
			<date type="published" when="2002-06" />
			<biblScope unit="page" from="177" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Journal-guided resynchronization for software raid</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denehy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">E</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arpaci-Dusseau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST&apos;05: Proc. of the Fourth USENIX Conf. on File and Storage Technologies</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="7" to="7" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Dfs: A file system for virtualized flash storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Josephson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">K</forename><surname>Bongo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Flynn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">I</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST&apos;10: Proc. of the Eighth USENIX Conf. on File and Storage Technologies</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>Association</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">RAIF: Redundant Array of Independent Filesystems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joukov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Krishnakumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patti</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Satnur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Traeger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zadok</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Twenty-Fourth IEEE Conf. on Mass Storage Systems and Technologies (MSST</title>
		<meeting>of Twenty-Fourth IEEE Conf. on Mass Storage Systems and Technologies (MSST</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007-09" />
			<biblScope unit="page" from="199" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Parity lost and parity regained</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krioukov</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bairavasundaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">N</forename><surname>Goodson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Srini-Vasan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Thelen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arpaci-Dussea</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FAST&apos;08: Proc. of the Sixth USENIX Conf. on File and Storage Technologies</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A case for redundant arrays of inexpensive disks (raid)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patterson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Gibson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD &apos;88: Proc. of the 1988 ACM SIGMOD Intl. Conf. on Management of data</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1988" />
			<biblScope unit="page" from="109" to="116" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Iron file systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prabhakaran</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Bairavasundaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">N</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Gu-Nawi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arpaci-Dusseau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;05: Proc. of the twentieth ACM Symp. on Operating Systems Principles</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="206" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Volumes: the andrew file system data structuring primitive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sidebotham</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EUUG&apos;86</title>
		<imprint>
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Ensuring data integrity in storage: techniques and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sivathanu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zadok</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">StorageSS &apos;05: Proc. of the 2005 ACM workshop on Storage security and survivability</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="26" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Improving storage system availability with dgraid</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sivathanu</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">C</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arpaci-Dusseau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Storage</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="133" to="170" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Stupid file systems are better</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Stein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HOTOS&apos;05: Proc. of the Tenth Conf. on Hot Topics in Operating Systems</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="5" to="5" />
		</imprint>
	</monogr>
	<note>USENIX Association</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Operating Systems Design and Implementation (Third Edition)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tanenbaum</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Woodhull</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Volume managers in linux</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Teigland</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mauelshagen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Ann. Tech. Conference, FREENIX Track</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="185" to="197" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
