<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:09+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. Programmable In-Network Security for Context-aware BYOD Policies Programmable In-Network Security for Context-aware BYOD Policies</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qiao</forename><surname>Kang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Lei Xue</orgName>
								<orgName type="institution" key="instit1">Rice University</orgName>
								<orgName type="institution" key="instit2">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit3">Rice University</orgName>
								<orgName type="institution" key="instit4">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit5">Rice University</orgName>
								<orgName type="institution" key="instit6">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit7">Rice University</orgName>
								<orgName type="institution" key="instit8">Rice University</orgName>
								<orgName type="institution" key="instit9">Rice University</orgName>
								<orgName type="institution" key="instit10">The Hong Kong Polytechnic University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Morrison</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Lei Xue</orgName>
								<orgName type="institution" key="instit1">Rice University</orgName>
								<orgName type="institution" key="instit2">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit3">Rice University</orgName>
								<orgName type="institution" key="instit4">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit5">Rice University</orgName>
								<orgName type="institution" key="instit6">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit7">Rice University</orgName>
								<orgName type="institution" key="instit8">Rice University</orgName>
								<orgName type="institution" key="instit9">Rice University</orgName>
								<orgName type="institution" key="instit10">The Hong Kong Polytechnic University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuxin</forename><surname>Tang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Lei Xue</orgName>
								<orgName type="institution" key="instit1">Rice University</orgName>
								<orgName type="institution" key="instit2">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit3">Rice University</orgName>
								<orgName type="institution" key="instit4">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit5">Rice University</orgName>
								<orgName type="institution" key="instit6">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit7">Rice University</orgName>
								<orgName type="institution" key="instit8">Rice University</orgName>
								<orgName type="institution" key="instit9">Rice University</orgName>
								<orgName type="institution" key="instit10">The Hong Kong Polytechnic University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ang</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Lei Xue</orgName>
								<orgName type="institution" key="instit1">Rice University</orgName>
								<orgName type="institution" key="instit2">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit3">Rice University</orgName>
								<orgName type="institution" key="instit4">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit5">Rice University</orgName>
								<orgName type="institution" key="instit6">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit7">Rice University</orgName>
								<orgName type="institution" key="instit8">Rice University</orgName>
								<orgName type="institution" key="instit9">Rice University</orgName>
								<orgName type="institution" key="instit10">The Hong Kong Polytechnic University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qiao</forename><surname>Kang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Lei Xue</orgName>
								<orgName type="institution" key="instit1">Rice University</orgName>
								<orgName type="institution" key="instit2">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit3">Rice University</orgName>
								<orgName type="institution" key="instit4">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit5">Rice University</orgName>
								<orgName type="institution" key="instit6">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit7">Rice University</orgName>
								<orgName type="institution" key="instit8">Rice University</orgName>
								<orgName type="institution" key="instit9">Rice University</orgName>
								<orgName type="institution" key="instit10">The Hong Kong Polytechnic University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lei</forename><surname>Xue</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Lei Xue</orgName>
								<orgName type="institution" key="instit1">Rice University</orgName>
								<orgName type="institution" key="instit2">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit3">Rice University</orgName>
								<orgName type="institution" key="instit4">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit5">Rice University</orgName>
								<orgName type="institution" key="instit6">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit7">Rice University</orgName>
								<orgName type="institution" key="instit8">Rice University</orgName>
								<orgName type="institution" key="instit9">Rice University</orgName>
								<orgName type="institution" key="instit10">The Hong Kong Polytechnic University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Morrison</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Lei Xue</orgName>
								<orgName type="institution" key="instit1">Rice University</orgName>
								<orgName type="institution" key="instit2">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit3">Rice University</orgName>
								<orgName type="institution" key="instit4">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit5">Rice University</orgName>
								<orgName type="institution" key="instit6">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit7">Rice University</orgName>
								<orgName type="institution" key="instit8">Rice University</orgName>
								<orgName type="institution" key="instit9">Rice University</orgName>
								<orgName type="institution" key="instit10">The Hong Kong Polytechnic University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuxin</forename><surname>Tang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Lei Xue</orgName>
								<orgName type="institution" key="instit1">Rice University</orgName>
								<orgName type="institution" key="instit2">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit3">Rice University</orgName>
								<orgName type="institution" key="instit4">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit5">Rice University</orgName>
								<orgName type="institution" key="instit6">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit7">Rice University</orgName>
								<orgName type="institution" key="instit8">Rice University</orgName>
								<orgName type="institution" key="instit9">Rice University</orgName>
								<orgName type="institution" key="instit10">The Hong Kong Polytechnic University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ang</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Lei Xue</orgName>
								<orgName type="institution" key="instit1">Rice University</orgName>
								<orgName type="institution" key="instit2">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit3">Rice University</orgName>
								<orgName type="institution" key="instit4">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit5">Rice University</orgName>
								<orgName type="institution" key="instit6">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit7">Rice University</orgName>
								<orgName type="institution" key="instit8">Rice University</orgName>
								<orgName type="institution" key="instit9">Rice University</orgName>
								<orgName type="institution" key="instit10">The Hong Kong Polytechnic University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiapu</forename><surname>Luo</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Lei Xue</orgName>
								<orgName type="institution" key="instit1">Rice University</orgName>
								<orgName type="institution" key="instit2">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit3">Rice University</orgName>
								<orgName type="institution" key="instit4">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit5">Rice University</orgName>
								<orgName type="institution" key="instit6">The Hong Kong Polytechnic University</orgName>
								<orgName type="institution" key="instit7">Rice University</orgName>
								<orgName type="institution" key="instit8">Rice University</orgName>
								<orgName type="institution" key="instit9">Rice University</orgName>
								<orgName type="institution" key="instit10">The Hong Kong Polytechnic University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX. Programmable In-Network Security for Context-aware BYOD Policies Programmable In-Network Security for Context-aware BYOD Policies</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the 978-1-939133-17-5 https://www.usenix.org/conference/usenixsecurity20/presentation/kang</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Bring Your Own Device (BYOD) has become the new norm for enterprise networks, but BYOD security remains a top concern. Context-aware security, which enforces access control based on dynamic runtime context, is a promising approach. Recent work has developed SDN solutions to collect device contexts and enforce access control at a central controller. However, the central controller could become a bottleneck and attack target. Processing context signals at the remote controller is also too slow for real-time decision change. We present a new paradigm, programmable in-network security (Poise), which is enabled by the emergence of pro-grammable switches. At the heart of Poise is a novel security primitive, which can be programmed to support a wide range of context-aware policies in hardware. Users of Poise specify concise policies, and Poise compiles them into different configurations of the primitive in P4. Compared with traditional SDN defenses, Poise is resilient to control plane saturation attacks, and it dramatically increases defense agility.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>BYOD refers to the practice where enterprise employees could use privately owned tablets, phones, and laptops at work <ref type="bibr" target="#b27">[32]</ref>. This practice has become the new norm in many organizations <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b11">13,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr">17,</ref><ref type="bibr" target="#b18">23,</ref><ref type="bibr" target="#b24">29]</ref>, and its market is projected to grow and exceed $73 billion by 2021 <ref type="bibr">[17]</ref>.</p><p>One of the top concerns, however, is BYOD security. As BYOD devices are generally less well-managed than their enterprise counterparts, they are easier targets to compromise <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b41">47,</ref><ref type="bibr" target="#b95">101]</ref>. This is further exacerbated by the fact that such devices are used to access sensitive enterprise resources as well as untrustworthy services in the wild <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b17">22]</ref>. At its core, BYOD security represents a concrete instance of a fundamental challenge, sometimes known as the "end node problem" <ref type="bibr">[11,</ref><ref type="bibr" target="#b10">12]</ref>. The "end nodes" are not subject to the same level of centralized control, management, and protection as the enterprise infrastructure. We can easily update the access control lists on the gateway router, or patch newly discovered vulnerabilities on a server, but ensuring that Kang, Xue, and Morrison contributed to this work equally; Chen and Luo are the corresponding authors.</p><p>the individual end points are properly patched is much more difficult. As such, insecure end devices tend to become the weakest link in the security chain <ref type="bibr" target="#b20">[25]</ref>.</p><p>One promising approach to BYOD security is to use context-aware policies, which enforce access control based on devices' runtime contexts <ref type="bibr" target="#b52">[58]</ref>. For instance, a policy may deny access from devices whose TLS libraries have not been updated <ref type="bibr" target="#b92">[98]</ref>, or grant access to devices that are physically located in the enterprise boundary <ref type="bibr" target="#b82">[88]</ref>, or allow the use of a sensitive service only if administrators are online <ref type="bibr" target="#b50">[56,</ref><ref type="bibr" target="#b81">87]</ref>. In each of these scenarios, the policy makes security decisions based on additional "threat signals", such as the device location, library version, or even the status of other devices in the network. Context-aware policies are in a class of their own-they are much more dynamic, as contexts can change frequently (e.g., GPS location), and they require global visibility of the entire network (e.g., administrators online).</p><p>Supporting context-aware policies in enterprise networks presents interesting research challenges. Some traditional systems operate at the server side <ref type="bibr" target="#b83">[89,</ref><ref type="bibr" target="#b88">94]</ref>, which enables easier management and update of security policies; others operate at the client side <ref type="bibr" target="#b85">[91]</ref>, making it easier to access device context. A common limitation, however, is that the individual nodesclients or servers-only have local visibility. Such a "tunnel vision" hinders the ability to make synchronized security decisions network-wide <ref type="bibr" target="#b80">[86]</ref>. Latest proposals address this using OpenFlow-based SDN, where a software controller collects context signals from all devices and enforces network-wide access control <ref type="bibr" target="#b52">[58]</ref>. However, the central controller is vulnerable to control plane saturation attacks <ref type="bibr" target="#b76">[82]</ref>, and processing threat signals in a remote software controller incurs delay and decreases agility.</p><p>Our contribution. We present a novel design called Poise, or programmable in-network security, whose goal is to address the limitations of OpenFlow-based SDN defense. Poise has a new security primitive that runs in switch hardware, and it can change defense decisions at hardware speeds. Clients embed context signals in network traffic, and Poise parses these signals and enforces security policies without involving a remote software controller. This primitive is also reprogrammable in a declarative language to support a wide range of context-aware policies. These declarative policies are</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association</head><p>29th USENIX Security Symposium 595 compiled by Poise into different configurations of the security primitive as P4 programs. Compared with traditional SDN defenses <ref type="bibr" target="#b52">[58,</ref><ref type="bibr" target="#b69">75,</ref><ref type="bibr" target="#b76">82]</ref>, this new paradigm results in defenses that are highly efficient, agile, and resilient to control plane saturation attacks <ref type="bibr" target="#b76">[82]</ref>.</p><p>The key enabler for Poise is the emerging programmable data planes developed by the latest networking technology. New switches, such as Intel FlexPipe <ref type="bibr" target="#b14">[16]</ref>, Cavium XPliant <ref type="bibr" target="#b8">[9]</ref>, and Barefoot Tofino <ref type="bibr" target="#b2">[3]</ref>, can be programmed in P4 <ref type="bibr" target="#b15">[19]</ref> to support user-defined network protocols, custom header processing, and sophisticated state in hardware. P4-programmable networks represent a major step beyond OpenFlow-based SDN. OpenFlow switches have fixedfunction hardware, and they can only support programmable forwarding by occasionally invoking remote software controllers. P4 switches, on the other hand, offer hardware-based programmability, which can be applied to every single packet without performance slowdown. The novelty of Poise lies in leveraging these new hardware features for context-aware security-we encode context signals with user-defined protocols, compute access control decisions using programmable packet processing, and support stateful, network-wide policies by designing hardware data structures.</p><p>After motivating our problem further in §2, we present:</p><p>• The concept of programmable in-network security ( §3);</p><p>• A language and compiler for context-aware policies ( §4);</p><p>• A novel in-network security primitive ( §5);</p><p>• The Poise orchestration service and device module ( §6);</p><p>• Discussions and limitations of Poise ( §7);</p><p>• Prototype and evaluation of Poise that demonstrate its practicality, as well as its higher resilience to control plane saturation attacks and increased defense agility compared with OpenFlow-based SDN defense ( §8);</p><p>We then describe related work in §9, and conclude in §10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and Motivation</head><p>Context-aware security (CAS) stands in stark contrast to conventional security mechanisms-existing mechanisms can only support static policies, but CAS uses dynamic policies based on runtime contexts. For instance, NAC (network access control) mechanisms such as IEEE 802.1x <ref type="bibr" target="#b28">[33]</ref> and Cisco Port/VLAN/IOS ACLs <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b21">26]</ref> statically configure access control policies, whether for a device, an IP prefix, or a VLAN ID. Role-or attribute-based access control mechanisms [52, 53, 76] also perform access control based on statically-defined roles or attributes. CAS, on the other hand, uses the runtime contexts of a request as threat signals (e.g., location/time of access, status of the network); whenever the signals change, the security decisions would adapt accordingly. The theoretical underpinnings of CAS have been studied more than a decade back <ref type="bibr" target="#b35">[41]</ref>, but it recently found an array of new applications in securing IoT and mobile devices <ref type="bibr" target="#b33">[39,</ref><ref type="bibr" target="#b45">51,</ref><ref type="bibr" target="#b52">58,</ref><ref type="bibr" target="#b54">60,</ref><ref type="bibr" target="#b85">91]</ref>. These devices, just like the BYOD clients in our scenario, suffer from the "end node problem" <ref type="bibr">[11,</ref><ref type="bibr" target="#b10">12]</ref>. CAS has proven to be effective for such scenarios, because it can enable a more precise protection based on threat signals collected from the end nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Design space</head><p>The concept of CAS by itself does not necessitate a client-, server-, or network-based design; rather, these design points have different tradeoffs. First off, purely server-side solutions are often ineffective, as we desire to collect context signals from client devices at runtime. Therefore, typical CAS systems <ref type="bibr" target="#b52">[58,</ref><ref type="bibr" target="#b85">91]</ref> need to install a context collection module at the clients. In terms of policy enforcement, one could co-locate enforcement with context collection, resulting in a purely client-based solution <ref type="bibr" target="#b85">[91]</ref>. The main drawbacks, however, are that a) individual devices only have local views, making network-wide decisions hard to come by, and that b) policy management is much harder, as policies are distributed to each device; this might raise additional concerns if some policies are themselves sensitive data. Another option is to enforce the policies inside the network. The network has a global view for holistic protection, and it enables centralized policy management and update. Poise adopts this design option.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Traditional networks are not enough</head><p>However, traditional network devices (i.e., switches and middleboxes) are not up to the task, because they are built with fixed-function hardware that is customized for specific purposes. For instance, traditional switch hardware is optimized for a fixed set of protocols (e.g., TCP/IP), but it does not understand context information, such as GPS location, time of access, or library versions. Similarly, hardware middleboxes also come with fixed functions, e.g., firewalls or deep packet inspection (DPI); function updates are typically constrained by the speed of hardware upgrades, which is much slower than the need for defense adaptation. As a result, traditional innetwork security mechanisms merely provide fixed-function security, such as static access control lists, firewalls, and traffic filters. There is a fundamental gap between the dynamic nature of CAS and the static nature of the network devices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">How about OpenFlow-based SDN?</head><p>Software-defined networking (SDN) <ref type="bibr" target="#b61">[67]</ref> can partially address this by the use of a software controller for control plane programmability. Although the OpenFlow switch hardware remains fixed in function, switches can send PacketIn messages to the central controller for programmable decisions. This paradigm underlies many recent developments in network security <ref type="bibr" target="#b52">[58,</ref><ref type="bibr" target="#b69">75,</ref><ref type="bibr" target="#b71">77,</ref><ref type="bibr" target="#b74">80,</ref><ref type="bibr" target="#b75">81,</ref><ref type="bibr" target="#b76">82]</ref>. In particular, a recent work PBS <ref type="bibr" target="#b52">[58]</ref> supports context-aware security by running</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Memory</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ALU</head><p>Match/ Action <ref type="table">Table   Match/  Action  Table   Match/  Action  Table   Programmable  Parser   Programmable  Deparser   Switch control plane</ref> PCIe bus</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Stages Stages</head><p>Figure 1: P4 switches are programmable in hardware. Packets first go through a programmable parser, which supports userdefined protocols. Packet headers are then streamed through a number of hardware stages, each of which contains stateful registers, arithmetic logic units (ALUs), and match/action tables. Packets can be recirculated to go through the stages multiple times to trigger different programmable elements.</p><p>the policy enforcement module as an "SDN app" in a centralized controller. This app can collect context signals from all devices and enforce access control in a global manner. However, in traditional SDN, programmability comes at a great cost, as it resides in a centralized software controller. First, PacketIn messages incur a round-trip time delay between the switch and the remote controller, whereas packets in the data plane are processed at hardware speeds. As such, we can only programmatically process a small set of packetstypically one packet per flow (e.g., the first packet). Second, traditional SDNs are vulnerable to control plane saturation attacks <ref type="bibr" target="#b76">[82]</ref>, where an adversary can cause high-volume traffic to be sent to the software controller. A recent work OFX <ref type="bibr" target="#b78">[84]</ref> has further highlighted that, for security applications that require dynamic, fine-grained decisions, centralized SDN controllers would pose a severe bottleneck. The key goal of Poise is to address the limitations of traditional SDN defenses by enforcing CAS in switch hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Opportunity: Programmable data planes</head><p>Data plane programmability represents the latest step in the networking technology. In contrast to OpenFlow-based SDN, P4-programmable networks provide new features that can be reconfigured in hardware <ref type="figure">(Figure 1</ref>). The key novelty of Poise is to leverage them for in-network policy enforcement. 1. Customized header support for CAS. P4 switches can recognize customized protocols and headers beyond TCP/IP via the use of a programmable parser, without the need for hardware upgrades. Our observation is that this allows us to programmatically define context signals as special header fields, and embed them in network traffic. P4 switches can directly parse context signals from client traffic. 2. Security decision changes at hardware speeds. Each hardware stage is integrated with ALUs (Arithmetic Logic Units) that can perform computation over header fields at linespeed. The implication for security is that, without involving a remote software controller, switches can evaluate context values (e.g., GPS locations) and make security decisions (e.g., location-based access control) directly in hardware. 3. Cross-packet state for network-wide security. Last but not least, the hardware stages also have persistent memory in read/write registers, and they can process packets based on persistent state. We observe that this enables the network to make coordinated security decisions in a network-wide manner-decisions for one client could depend on past network behaviors, or activities from other parts of the network.</p><p>These hardware features are programmable in P4 <ref type="bibr" target="#b15">[19,</ref><ref type="bibr" target="#b37">43]</ref>. Switch programs can be compiled and installed from the switch control plane <ref type="figure">(Figure 1)</ref>, which typically runs a customized version of Linux and has general-purpose CPUs. The P4 compiler maps a switch program to the available hardware resources <ref type="bibr" target="#b58">[64]</ref>. Programs that successfully compile on a target are guaranteed to run at linespeed, due to the pipelined nature of the hardware. Programs that exceed available hardware resources would be rejected by the P4 compiler.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Trust model</head><p>Poise shares the same trust model as existing CAS solutions <ref type="bibr" target="#b52">[58,</ref><ref type="bibr" target="#b85">91]</ref>-the context collection module at the clients and policy enforcement module at the switch are both trusted. As a network-based design, Poise also trusts the network infrastructure (switches and access points). The context collection module can be installed as a pre-positioned Android kernel module with OEM support; this is common in Enterprise Mobility Management solutions <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b22">27,</ref><ref type="bibr" target="#b26">31,</ref><ref type="bibr" target="#b85">91]</ref>. It only collects and propagates context signals when devices are connected to the enterprise network; standard BYOD frameworks such as Android for Work <ref type="bibr" target="#b1">[2]</ref> or Samsung <ref type="bibr">Knox [24]</ref> can support this. Users can install unmodified Android apps. CAS specifically protects against malicious apps, and following existing work <ref type="bibr" target="#b52">[58,</ref><ref type="bibr" target="#b85">91]</ref>, we assume that malicious apps cannot compromise the kernel or obtain root privileges. It is possible to further relax these assumptions by directly establishing the root of trust in hardware <ref type="bibr" target="#b23">[28,</ref><ref type="bibr" target="#b25">30,</ref><ref type="bibr" target="#b68">74]</ref>. In the case where untrusted devices may connect to the network, Poise needs to perform authentication on context signals before using them for decision making, e.g., by adding support for cryptography in P4 switches. We discuss this in more detail in §7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Programmable In-Network Security</head><p>We call this new paradigm programmable in-network security.</p><p>Scenario. Consider the enterprise network shown in <ref type="figure" target="#fig_0">Figure 2</ref>, which hosts several types of private data, such as employee records and sales records, and also provides connectivity to the Internet. The operator wants to enforce dynamic access control of sensitive enterprise data in the presence of BYOD clients. For instance, the policy might specify that a) sales records should only be accessed by devices belonging to the sales department; b) during regular work hours; c) from devices that are properly patched to address some recently discovered vulnerability; and, d) a device can only access the sales records if the sales manager is online. Poise is designed for context-aware security policies such as these. The Poise system. At the heart of Poise is a novel switch primitive that can enforce CAS policies in hardware. The design of this primitive also tackles a practical challenge. Since P4 programs specify low-level packet processing behaviors, they are akin to "assembly-level" programs, and one often needs to hand-optimize P4 programs to reduce resource usage. Therefore, we allow network operators to specify CAS policies in a declarative language that is much higher-level than P4. Our compiler can then generate optimized P4 programs automatically, which are different versions of the security primitive. The Poise compiler also generates configurations for the context collection module at the clients. It collects context signals based on the configuration, and sends out periodic context packets to the network. Policy changes can be easily supported by a recompilation. Client configurations need not be affected by policy updates, unless the new policies require new types of context signals to be collected. Next, we first describe the Poise language and compiler, then the switch primitive, and finally, the client module and how these components work together.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The Poise Language and Compiler</head><p>The policy language in Poise is inspired by the Frenetic family of SDN programming languages <ref type="bibr" target="#b32">[38,</ref><ref type="bibr" target="#b48">54,</ref><ref type="bibr" target="#b62">68,</ref><ref type="bibr" target="#b63">69,</ref><ref type="bibr" target="#b73">79]</ref>, but we adapt them a) from an OpenFlow setting to P4, which supports richer header operations and state, and b) from a network management setting to security, by supporting security contexts. Specifically, we have designed the Poise language based on Pyretic NetCore <ref type="bibr" target="#b63">[69]</ref>, where network policies are written as a series of match/action statements. In terms of the semantics of the language, a policy represents a function that maps an incoming packet to zero (i.e., drop), one (i.e., unicast), or more (i.e., multicast) outgoing packets. A policy could be as simple as drop, which drops all packets, although practically, the policy would make a decision based on the context a packet carries, such as if match(dip==66.220.144.0) then drop, which blacklists a block of destination IP addresses, or if match(0800&lt;=time&lt;=1800) then drop, which denies access depending on the time of day. <ref type="figure" target="#fig_1">Figure 3</ref> summarizes the language syntax, and the highlighted portions show the differences from NetCore, which we explain more below.</p><formula xml:id="formula_0">Primitive Actions A ::= drop | fwd(port) | flood | log Expressions E ::= v | e 1 + e 2 | e 1 − e 2 | e 1 * e 2 | M Constant Lists L ::= nil | v, L Predicates P ::= match(e 1 • e 2 ) | match(h • e) | match(h in l) | P&amp;P | (P|P) | !P Monitors M ::= count(P) Policies C ::= A | if P then C else C | (C|C)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Key language constructs</head><p>Security contexts. Poise encodes context fields in customized headers, such as time or dev. When a policy refers to multiple context fields, Poise structures the context headers in the order in which they appear in the policy program. Context operations. Poise also supports sophisticated operations over context headers, as indicated in the expressions and predicates in <ref type="figure" target="#fig_1">Figure 3</ref>. An expression could be a constant, an arithmetic operation over header fields, or a complex expression over subexpressions. Security decisions are made based on predicates over expressions, where the • operator indicates comparisons such as &gt;, &lt;, and so on. Contexts can also be tested against constant lists, which are pre-defined in the policy to encode membership relations. For instance, one could define a list of devices with administrative roles as def adminlst = ["dev1", "dev2"]. Then, the policy could refer to the lists as part of the decision-making process, such as if match(!dev in adminlst) then fwd(mbox), which forwards traffic from non-admin devices to a middlebox for traffic scrubbing. We note that the original NetCore does not support the use of contexts or sophisticated context operations; rather, Poise adds such extensions based on the extra processing power in P4 for security support. Stateful monitors. Unlike NetCore, Poise supports stateful policies which make security decisions based on networkwide state. This is done via monitor expressions, which monitor activities of interest in persistent state. A monitor expression is written as count(pred), which counts the number of packets that satisfy the predicate pred in the current time window; for instance, count(match(is_admin)) counts the number of packets generated from a device with an administrative role. The counters are periodically reset to zero when a new time window begins. These monitors enable programmers to write network-wide policies. This is different from stateless NetCore policies, where monitors passively collect traffic statistics, but do not affect forwarding decisions. Actions. The decision of a Poise policy is represented by its action field. Currently, Poise supports four types of actions. The drop decision denies access. The fwd decision allows access, and can be further parameterized by an outgoing switch port, so that it can actuate further processing-e.g., sending packets through an DPI device that can be reached via a particular port. The flood decision broadcasts a packet. The log decision sends a packet to a logger that detects potentially suspicious activity; this is achieved by aliasing the fwd decision and specifying a special port for the local switch CPU. Packets sent for logging will be pumped to the control plane of the switch, which runs a logging component. This can be easily generalized to enable remote logging, e.g., by wrapping the packet inside another IP header, where the destination IP represents a network activity logger. Composing policies. Similar as NetCore, Poise can compose multiple policies P1|P2|...|Pn and compile them into a single switch program. This is useful, e.g., when Pi and Pj check different context signals and the enterprise wants to apply them in combination. The Poise compiler rejects the composition of conflicting policies at compilation time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Example policies</head><p>The Poise language is expressive enough to capture a wide range of existing and new policies, and it is much more concise than low-level languages such as P4. Next, we describe seven practical BYOD policies, where the first two are adapted from existing work <ref type="bibr" target="#b52">[58]</ref> and the rest are new policies supported by Poise. Variables dev, time, lat, lon, and usr are customized header fields.</p><p>P1: Block certain services in work hours <ref type="bibr" target="#b52">[58]</ref>: A common BYOD policy is to block access from certain devices to entertainment websites during work hours:</p><formula xml:id="formula_1">def businesslst = [" dev1 " , " dev2 "] if match( dip ==66.220.144.0 &amp; dev in businesslst &amp; ( time &gt;=0800)&amp;( time &lt;=1800)) then drop</formula><p>P2: Direct traffic from guest devices through a middlebox <ref type="bibr" target="#b52">[58]</ref>: Another useful policy is to distinguish traffic from authorized devices and guest devices, and direct guest traffic through a middlebox for traffic scrubbing:</p><formula xml:id="formula_2">def authlst = [" dev1 " , " dev2 "] if match( dev in authlst ) then fwd( server ) else fwd( mbox )</formula><p>New policies. There are also useful policies in Poise that cannot be easily supported in traditional networks; they are implementable in Poise due to the use of programmable data planes, which can perform arithmetic operations over context headers, and maintain network-wide state to make coordinated security decisions. We give an example of each below.</p><p>P3: Distance-based access control: This policy grants access to a service only if the user is within a certain distance from a physical location (e.g., the server room); this requires performing arithmetic operations over GPS coordinates embedded in the packet header:</p><formula xml:id="formula_3">if (( lat -x )*( lat -x )+( lon -y )*( lon -y) &lt; D)</formula><p>then fwd( server ) else drop P4: Allow access only if admin is online: Poise can support coordinated, network-wide policies by monitoring security events of interest and making decisions based on the result. For instance, a policy might grant access to a service only if the admin is online:</p><formula xml:id="formula_4">def adminlst = [" Bob " , " Alice "] c = count(match( usr in adminlst )) if match(c &gt;0) then fwd( server )</formula><p>Advanced policies. Inspired by the literature of "continuous authentication" <ref type="bibr" target="#b31">[37,</ref><ref type="bibr" target="#b43">49,</ref><ref type="bibr" target="#b44">50,</ref><ref type="bibr" target="#b86">92]</ref>, we propose a set of advanced policies that use device context to detect subtle but important indicators of potential attacks. Due to space constraints, we only describe the high-level policies, but not the programs. P5: Block requests without explicit user interaction, which denies access to a sensitive service if all apps are running in the background and there is no user interaction with the touchscreen to trigger the request; such requests are likely generated by malware. P6: Scrub traffic if UIs are overlapping, which forwards traffic through a middlebox if the context information shows that app UIs are overlapping-a potential sign for UI hijacking <ref type="bibr" target="#b49">[55]</ref>. P7: Conduct deep packet inspection if camera/recorder is on, which detects if sensitive information is being leaked through an active camera/recorder app [36].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Compilation</head><p>Next, we discuss how the Poise compiler processes the key language constructs and generates P4 implementations.</p><p>Compiling security contexts. The Poise compiler generates P4 headers for each context. Context packets have special IP protocol numbers (143 for TCP, 144 for UDP), and they have no payload. Context headers follow the TCP/UDP headers (e.g., Eth|IP|TCP|Ctxt). Poise switches recognize the context headers by the IP protocol number, whereas legacy switches forward these packets based on destination IPs. User traffic is not modified by Poise in any way. (See <ref type="figure" target="#fig_1">Figure 13</ref>    headers, as discussed above. Then, for arithmetic, bitwise, or comparison operations over header fields, such as lat*lat, sensors&amp;0x01, or time&lt;10, our compiler forms expressions using the corresponding P4 operations over the headers. For arithmetic operations, the current P4 specification supports addition, subtraction, and multiplication, which are all supported by the Poise compiler. Notably missing from the list are division and modulo operations, which tend to be expensive to implement in switch hardware (although sometimes they can be approximated by bit shifts if the divisor is a power of two). If a Poise program involves operations unimplementable in P4, our compiler would reject the policy during compilation.</p><p>As an example, <ref type="figure" target="#fig_3">Figure 4</ref>(b) shows simplified P4 snippets that our compiler generates for computing the distance between a pair of GPS coordinates to a pre-defined center (assumed to be (0,0)). Our compiler also generates conditional statements based on the policy, e.g., if-else branches to test if the distance exceeds a threshold. Context operations are performed within an apply block at control Ingress, which means the switch ingress pipeline.</p><p>Context matches, on the other hand, are compiled into match/action tables in P4. A match can be an exact match, which requires matching a context field against a list of keys bit by bit. It could be a range match, which compares a context field against a range of values in TCAM (Ternary Content Addressable Memory). By default, Poise uses 4-byte headers for exact matches, and 2-byte headers for range matches. Context matches can also be performed against a user-specified constant list that defines membership, e.g., a set of devices owned by the sales department. For a list with k items [a 1 , a 2 ,· · · , a k ], our compiler will construct a match/action table with k entries, where each entry corresponds to an item in the list. The actions associated with the entries depend on the mode of access defined in the policy program.</p><p>For instance, consider the P4 snippet in <ref type="figure" target="#fig_3">Figure 4</ref>(c), which shows a match/action table generated from a constant list of two entries: Bob and Alice. The table implements an exact match on the device ID field. If the context match is successful, then the device will be granted access; unsuccessful matches indicate that the context fails the membership test, and these requests will be denied access.</p><p>Compiling stateful monitors. The Poise compiler generates a read/write register for each stateful monitor in the policy, as well as code components for detecting monitored events and updating the monitor values. Such monitors are implemented as a number of registers in P4, which are supported in switch SRAM. Updates to the registers are linespeed, so they can be performed on a per-packet basis. Specifically, for each incoming packet, the generated code checks whether this corresponds to an event of interest, using either a context match, or a match over a membership list. If this event should be monitored, the code additionally updates the monitor register and records the event timestamp. If a long time has elapsed after the previous event took place, then this register is cleared to indicate that the monitored event is absent. As discussed before, monitors enable network-wide policies that make coordinated security decisions-a policy can test if a monitored event is detected, and make decisions accordingly.</p><p>Concretely, the snippet in <ref type="figure" target="#fig_3">Figure 4</ref>(d) shows an example. It instantiates a 32-bit register to hold the monitor value, and updates the register when the admin context is active in a packet. The code associates a timestamp to this monitor, and resets the monitor upon timeout.</p><p>Compiling actions. An action will be taken on each packet to represent the final decision made on its context. In P4, decisions are represented by attaching special metadata fields to a packet, which will be recognized and processed by a traffic manager, which schedules packets to be sent on the correct outgoing port(s) or dropped. Logging a packet is achieved by setting the outgoing port to be the switch CPU. Summary. So far, we have described the basic compilation algorithm as if each packet is tagged with context information. This makes it easy for a switch to access a packet's context without keeping state, but it results in high traffic overhead. Next, we will relax this assumption by the design of a stateful, efficient, programmable in-network security primitive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">The In-Network Security Primitive</head><p>Poise has a security primitive that runs in a programmable switch, which is dynamic, efficient, and programmable.</p><p>Goal: A dynamic and efficient security primitive. The innetwork primitive should ideally allow the level of protection to be adjusted between per-packet and per-flow granularities, by supporting a tunable frequency of context packets for each connection. At one end of the spectrum, per-flow granularity of protection degenerates into a static security mechanism that does not support context changes within a connection. Thus the protection is very coarse-grained, especially for long-lived connections that persist for an extended period of time (e.g., push-based mobile services, such as email <ref type="bibr" target="#b87">[93]</ref>). At the other end, per-packet granularity is extremely fine-grained, but it may incur unnecessary resource waste unless context changes from packet to packet. As a concrete example, if there are 20 context fields across policies, then each client needs to send 20 × 4/500 = 16% extra traffic, assuming typical 500-byte packets and 4-byte context fields. The Poise primitive supports a property that we call subflow-level security, which achieves a tunable tradeoff between security granularity and overhead when enforcing context-aware security.</p><p>Property: Subflow-level security. We state this property more formally below. Consider a sequence of packets in the same flow c i , p i 1 , · · · , p i k , c i+1 , where c represents a context packet and p a data packet. Subflow-level security requires that decisions made on the context packet c i should be applied to subsequent data packets p i j , i j ∈ [i 1 , i k ], but fresh decisions should be made for data packets that follow c i+1 . The decision granularity can be tuned by f , the frequency of context packets. This results in an overhead of s · f , where s is the size of context packets. For instance, assuming 80-byte context packets and a frequency of one context packet per ten seconds, the overhead would be as low as 8 bytes per second.</p><p>Challenges. Designing a primitive that supports subflowlevel security, however, requires tackling three key challenges.  another hardware data structure akin to a cache to make conservative decisions for buffered flows. (c) Mitigating DoS attacks that could arise due to the interaction between data and control planes. This defends against malicious clients that craft special context packets to degrade the performance of selected clients, or even the entire network. In the next three subsections, we detail each of these techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Approximating per-flow state</head><p>The key problem in the first challenge stems from the fact that the switch needs to process data packets without contexts attached to them. Therefore, when a switch processes a context packet, it needs to remember the decision and apply it to subsequent data packets in the same connection, until the next context packet refreshes the decision. A naïve design would require keeping per-flow state on the switch, which leads to high memory overhead.</p><p>To address this, Poise approximates per-flow state using a key/value store consisting of two data structures, FullConn and Decision, as shown in <ref type="figure" target="#fig_4">Figure 5</ref>. The FullConn schema is [sip, sport, proto]→idx. The match key is the source IP/port and protocol for the client, and the value is an index to a register array R. The indexed register R <ref type="bibr">[idx]</ref> holds the decision made on the latest context packet within this connection, and it can be refreshed entirely in the data plane. Insertions to this key/value store require control plane involvement, but they are relatively infrequent and only needed for new connections. Since the match key does not include the destination IP/port, this introduces some inaccuracy when a client reuses a source port across connections. Therefore, for short-lived connections, data packets may see slightly outdated decisions. To ensure that such inaccuracy does not misclassify a "deny" as an "allow", we blacklist the source IP addresses that have recently violated the enterprise policy: all connections from these clients would be blocked temporarily.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Buffering control plane updates</head><p>Insertions to FullConn requires control plane involvement, so they take much longer than updating policy decisions for an existing connection. As a result, when data packets in a new connection arrive at the switch, the FullConn match/action  <ref type="figure" target="#fig_6">(Figure 6a</ref>), it immediately adds the entry to Cache, and then invokes the control plane API to insert the match/action entry in FullConn. Since CRC functions are not collision resistant, different connections may be mapped to the same entry; hence, we evict old entries upon collision. When a data packet comes in <ref type="figure" target="#fig_6">(Figure 6b</ref>), Poise first matches it against the FullConn table and applies the decision upon success. If there is no entry for this packet, then Poise indexes the Cache table instead. Upon a cache hit, the corresponding decision is applied to the data packet. Upon a cache miss, one of two situations has happened: a) the switch has not seen a context packet from this client, or b) the entry for this client has been evicted due to collision. Poise distinguishes between these cases using the following cache eviction algorithm.</p><p>Handling cache evictions. Upon collision, we always replace the existing entry with the new one. This is because Poise has already invoked the control plane to install the corresponding entry in FullConn, which will complete in time. Therefore, if a packet does not match any entry in FullConn and experiences a collision in Cache, we use a special instruction to recirculate the packet inside the data plane to delay its processing. Recirculated packets are sent back to the switch ingress to be matched against the FullConn table one more time. This recirculation is repeated up to k times, where the latency is chosen to be larger than the expected time for the control plane to populate an entry. If a packet has reached this threshold, and the FullConn table still has not been populated, then we consider this to be case a) above and drop the packet.</p><p>Early denies. To reduce the amount of recirculated packets, we make early decisions to drop a packet if its context is evaluated to a "deny". Specifically, when evicting an entry from Cache, we add its source IP address into a blacklist Bloom filter (BF in <ref type="figure" target="#fig_6">Figure 6</ref>) if the decision is to drop. Source addresses in BF represent devices that have violated the policy recently and need to be blacklisted for a period of time. If a packet cannot find an entry in either Cache or FullConn, but hits BF, we drop it without recirculation. Since Bloom filters can only produce false positives, but never false negatives, we will always correctly reject an illegal connection. However, we might err on the conservative side and reject legal connections as well, if the BF produces a false positive. This is a rare case, however, as this will only happen during the window in which FullConn has not been populated, the Cache entry has been evicted, and the BF happens to produce a false positive. Nevertheless, Poise periodically clears this Bloom filter to reduce false positive rates, which grow with the number of contained elements. When the BF is being cleared, packets will be recirculated until the operation completes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Handling denial-of-service attacks</head><p>Since Poise requires extra processing inside the network, we need to ensure that it does not introduce new attack vectors. Specifically, we have identified two potential denial-of-service attack vectors and hardened the primitive against them. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Orchestrating Poise</head><p>Next, we explain how we orchestrate the Poise in-network primitive using a software controller, and describe the client module that runs on the mobile devices for context collection. The Poise client module. Our client module PoiseDroid is installed at BYOD devices to collect context signals and embed them into packets. PoiseDroid does not require modification of existing Android apps, but rather acts as a pre-positioned kernel module. When the device connects to the enterprise network, it needs to go through an authentication phase (e.g., using WPA3 <ref type="bibr" target="#b89">[95]</ref>, or additionally using two-factor authentication <ref type="bibr" target="#b65">[71]</ref>). The module stops propagating context signals when the device leaves the network. <ref type="figure" target="#fig_7">Figure 7</ref> shows the architecture of PoiseDroid with three submodules.</p><p>The context submodule. It collects context information from the Android system services <ref type="bibr" target="#b91">[97]</ref> using usermode-helper APIs <ref type="bibr">[34,</ref><ref type="bibr" target="#b57">63]</ref>, and it registers a virtual device to redirect the context data to our kernel module. The information to be collected is specified by a BYOD client configuration, which includes a) app information, such as UIDs of active apps, b) system information, such as screen light status, and c) device status, such as accelerometer and gyroscope readings. The protection submodule. It protects the registered virtual device, the system tools (e.g., dumpsys), and the system services using LSM hooks in Android kernel <ref type="bibr" target="#b34">[40,</ref><ref type="bibr" target="#b66">72]</ref>. It monitors invocations of selected system calls, such as ptrace(), open(), mprotect() and chown(), and prevents any other processes to write false data to these protected components.</p><p>The network submodule. It crafts and sends special context packets with signals needed for the enterprise policies, using a frequency specified in the configuration. When an app opens a new socket, or when an existing socket sends packets after being dormant for a while, it also generates a context packet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Limitations and Discussions</head><p>Authentication. As an access control mechanism, Poise focuses on resource authorization and should be used with an authentication method, e.g., the SAE (simultaneous authentication of equals) protocol <ref type="bibr" target="#b51">[57]</ref> in WPA3 <ref type="bibr" target="#b89">[95]</ref>, or two-factor authentication with TOTP <ref type="bibr" target="#b65">[71]</ref>. Only authenticated users can further access enterprise resources in Poise.</p><p>Context integrity and privacy. One limitation of the current Poise prototype is that it relies on external cryptographic mechanisms to secure context packets. This is because today's P4 switches do not have built-in support for cryptography. Adding cryptography support in P4 switches can be achieved in two ways. First, the P4 standard allows cryptographic modules to be added as "externs". The main Poise program can invoke such an extern module to encrypt, decrypt, and authenticate context packets. Second, a recent project SPINE <ref type="bibr" target="#b42">[48]</ref> shows that the current P4 language is expressive enough to implement a keyed hash function. SPINE further leverages this to generate one-time pads to encrypt/decrypt IP and TCP headers at linespeed. Poise could use a similar design, where clients encrypt context packets and the switch decrypts them using shared keys. To protect integrity, Poise can additionally use the keyed hash function to generate a MAC (message authentication code) of the context fields at the clients, and verify the MAC at the switch. To protect against replay attacks, the context packets also need to include timestamps or sequence numbers. Either way, the Poise switch or the "extern" module needs to be configured with key pairs with each enterprise client.</p><p>Existing security mechanisms in enterprise networks can also offer some support. Typically, client devices connect to the network via wireless access points (APs), and then to the wired network. Communication between clients and APs can be protected by WPA3 <ref type="bibr" target="#b89">[95]</ref>, and communication between the APs and the wired network by MACsec <ref type="bibr" target="#b13">[15]</ref>; both can protect the integrity and confidentiality of packets and are secure against replay attacks <ref type="bibr" target="#b13">[15,</ref><ref type="bibr" target="#b89">95]</ref>. Under these protections, context packets are always encrypted on (wired and wireless) network links, therefore secure against network reconnaissance attacks. However, supporting cryptography in P4 switches would provide stronger, end-to-end guarantees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Evaluation</head><p>In this section, we describe the experimental results obtained using our Poise prototype. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Prototype implementation</head><p>We have implemented the Poise prototype using 5918 lines of code in C/C++ and Python <ref type="bibr" target="#b16">[20]</ref>. The Poise compiler is implemented in C++, using Bison 2.3 as the syntax parser, and Flex 2.5.35 as the lexer. It can generate switch programs in P4 for the Tofino hardware. The PoiseDroid client module is implemented in C as a pre-positioned kernel module on Linux 3.18.31. It extends the default LSM framework, SEAndroid, to implement the protection submodule. For evaluation, PoiseDroid runs on a Pixel smartphone with a Qualcomm Snapdragon 821 MSM8996 Pro CPU (4 cores) and Android v7.1.2. The Poise control plane is implemented in Python, and runs as part of the control plane software suite for the Tofino switch. It manages the match/action table entries and reconfigures the data plane programs. It can also be configured to invoke the hardware-based packet generator on the switch to send traffic at linespeed (100 Gbps per port), which we have used to test the latency and throughput of Poise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Experimental setup</head><p>We set up a testbed with one Wedge 100BF Tofino switch and two servers. The Tofino switch has a linespeed of 100 Gbps per port, and 32 ports overall, achieving an aggregate throughput of 3.2 Tbps when all ports are active. It also has a 200 Gbps pipeline-separate from the 32 regular ports-for handling packet recirculation. Each server is equipped with six Intel Xeon E5-2643 Quad-core CPUs, 128 GB RAM, 1 TB hard disk, and four 25 Gbps Ethernet ports, which collectively can emulate eight forwarding decisions (one per server port). The servers are connected to the Tofino switch using breakout cables from the 100 Gbps switch ports to the 25 Gbps server Ethernet ports. At linespeed, the testbed should achieve full 100 Gbps bandwidth per switch port.</p><p>On the first server, one of its ports is configured to be an enterprise server, and other ports are configured to emulate a DPI device, a traffic scrubber, and a logger, respectively. The other server functions as an enterprise client. The mobile traces are first collected from our Pixel smartphone, and then "stretched" to higher speeds to be replayed. The replay can be initiated from a) the enterprise client, or b) the hardware generator for Poise at linespeed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Compiler</head><p>We start by evaluating the performance of the Poise compiler and its generated programs. All programs support one million connections in the FullConn table. Compilation speed. In order to understand the performance of our compiler, we measured the time it took to generate switch programs for each of the seven policies. We found that compilation finished within one second across all policies. P1 and P3 took slightly more time than the rest, because they involve more context fields and our compiler needs to generate more logic for header processing. <ref type="figure" target="#fig_9">Figure 8</ref> shows the results. Generated P4 programs. The generated P4 programs have 855-975 lines of code, which are significantly more complex than the original policy programs that only contain a few lines of code. For one million connections across policies, the utilization of Poise for SRAM (used for exact match) is roughly 43%, for TCAM (used for longest-prefix match) is below 1.1%, and for VLIWs (Very Long Instruction Words, used for header modifications) is below 7%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">In-network processing overhead</head><p>Next, we turn to evaluate the overhead of Poise in terms of packet processing latency and switch throughput. Packet processing latency. Poise increases the overhead of packet processing, because it needs to process context headers and approximate per-flow state. To quantify this overhead, we have tested the latency for Poise to process a) a context packet, b) a data packet, and compared them with c) the latency for directly forwarding a packet without any processing. <ref type="figure">Figure 9</ref> shows that for all tested policies, the extra latency on average is 72 nanoseconds for processing data packets, Switch throughput. Next, we measured the throughput per switch port using the hardware packet generator for stress testing. The generator ingested mobile traces collected from our phone, and stretched the trace to be 100 Gbps. <ref type="figure">Figure 10</ref> shows the per-port throughput for all policies. As we can see, although there is additional processing delay in Poise, the pipelined nature of the switch hardware makes it achieve full bandwidth nevertheless. In other words, Poise leverages programmable data planes to enforce context-aware security at linespeed, a key goal that we have designed for.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Scalability</head><p>Next, we evaluate how well Poise scales to complex policies. As policies may perform different numbers of checks on different numbers of contexts, we define a "unit policy" to be one that performs a single check on a single context. We then create many unit policies, and use the Poise compiler to compose them together. We characterize the complexity of the composed policy in two dimensions: a) the number of checks per context, and b) the number of contexts. For a), we further distinguish between exact vs. range checks, and for b), we distinguish between regular (i.e., non-monitor) vs. monitor contexts. For instance, consider the following unit policies: We say that the composed policy has two regular contexts and performs two exact checks-one check per context.</p><p>Number of checks. Poise compiles each check into a match/action entry, so the number of checks a switch can support depends on its available memory (SRAM and TCAM). Exact checks (e.g., X==1) are supported by SRAM and range checks (e.g., 10&lt;X&lt;20) by TCAM, so they are bottlenecked by the SRAM and TCAM sizes, respectively. We first measured the maximum number of exact checks Poise can perform on a single context, by asking the compiler to compose more and more unit policies until the compilation failed. We found that our switch can support 1.2 million checks, which are spread across 5 hardware stages. We then modified all unit policies to perform range checks, and found that Poise can perform 55 k checks, as the TCAM size is smaller.</p><p>Number of contexts. Poise compiles each regular context into a match/action table, so the number of contexts is bottlenecked by the number of tables a switch can support. We increased the number of contexts (e.g., time, library version) from one to the maximum until compilation failed, and found that Poise can support a maximum of 40 contexts-each of the 5 stages can support 8 context tables.</p><p>For each data point, we also measured the number of checks Poise can perform per context. We found that the number of checks per context decreases as we add more contexts, as the context tables need to multiplex switch memory. With 40 contexts, Poise can perform 21 k exact checks or 0.8 k range checks per context <ref type="figure">(Figure 11a)</ref>. In other words, Poise can support at least 21 k distinct context values (e.g., user IDs for per-user policies) or 0.8 k distinct context intervals (e.g., time intervals for time-based access control).</p><p>We then modified all unit policies to check against networkwide monitors. A monitor is compiled into two tables-one for monitor updates, and another for monitor checks. Poise supports a maximum of 20 monitors in 40 tables. Policies can also use a mix of monitors and regular contexts. The constraint on the number of monitors m and the number of regular contexts c is 2 × m + c ≤ 40, as they are all compiled into tables under the hood. In terms of the number of checks per monitor, the results for a policy with m monitors are similar as those for a policy with 2 × m regular contexts <ref type="bibr">(Appendix A.3</ref>).</p><p>Overhead. We define a "baseline" to be the latency and throughput for a unit policy, where a context packet traverses the hardware stages exactly once without recirculation. A packet with k contexts would be recirculated to traverse the stages ⌈ k 5 ⌉ times, every time matching against 5 tables, one in each stage. At the maximum, Poise supports 7 recirculations for 40 contexts at a latency of 6.5µs <ref type="figure">(Figure 11b)</ref>, which is still orders of magnitude lower than typical enterprise RTTs (ms). Recirculation also causes extra traffic overhead. We measured the overhead using 1 million connections and one context packet per second per connection. As <ref type="figure">Figure 11c</ref> shows, the maximum recirculation overhead is 0.37 Gbps per port. A monitor policy with m monitors has similar results as a policy with 2 × m regular contexts <ref type="bibr">(Appendix A.3</ref>). Exact and range checks have similar results, as the types of checks do not affect the number of recirculations. Context packets with more than 5 contexts need to be recirculated multiple times; Poise supports a maximum of 7 recirculations, which leads to a latency of 6.5µs and an additional 0.37 Gbps traffic per port in a dedicated recirculation pipeline. Poise supports fewer range checks (55 k for one context, 0.8 k for 40 contexts) than exact checks, as the former are supported in TCAM, which is smaller than SRAM; but the latency and bandwidth overheads are similar, as they do not depend on the types of checks. Data packets are not affected by policy complexity, as they simply look up the decisions from the connection table.</p><p>We note that recirculation traffic is contained in a dedicated 200 Gbps switch pipeline-it does not compete with normal user traffic. Also, recirculation only incurs latency on context packets, as data packets simply look up previous decisions in a single stage traversal. Therefore, even when recirculating context packets, Poise still processes data packets at baseline latency and full linespeed <ref type="figure">(Figures 11b-11c)</ref>.</p><p>Discussion: Per-user policies. Poise supports per-user policies by including the user ID as a context. Therefore, per-user policies merely reduce the number of total contexts by one, from 40 to 39. The number of user IDs Poise can check against is 21k, assuming the policy has 39 contexts. As another dimension of constraint, assuming each user may launch 1k concurrent connections, then Poise would support a maximum of 1M/1k=1k users. To put this into perspective, Microsoft headquarter reports 80 k employees in 125 buildings <ref type="bibr">[18]</ref>; assuming that each building has its own access control switch, then every switch needs to support 0.64 k users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.6">Client overhead</head><p>We now evaluate the overhead of the client module, using vanilla Android without PoiseDroid as the baseline system. CPU overhead. We tuned the frequency at which the client module sends context packets, and measured the CPU overhead for each frequency. In a naïve design where PoiseDroid tags every packet with context information, the CPU overhead is as much as 11%. With an optimized design where the client module sends one context packet per second, the CPU overhead is drastically reduced to 1.3%. <ref type="figure" target="#fig_4">Figure 15a</ref> in <ref type="bibr">Appendix A.4</ref> shows the results. Traffic overhead. Next, we measured the traffic overhead due to the context packets. This experiment assumes four context fields (16 bytes). We found that, at one context packet per second, the traffic overhead is less than 0.01%, a negligible amount. <ref type="figure" target="#fig_4">Figure 15b</ref> in <ref type="bibr">Appendix A.4</ref> shows the results. Battery overhead. We used PCMark <ref type="bibr" target="#b29">[35]</ref>, a battery life benchmark tool to test smartphones and tablets, to quantify the amount of battery overhead. <ref type="table" target="#tab_7">Table 1</ref> in <ref type="bibr">Appendix A.4</ref> shows the results. The overall overhead across benchmarked activities introduced by PoiseDroid is only 1.02%, and even for the activities that introduce the highest overhead (i.e., writing), the overhead is only 2.87%. Overall benchmark. Next, we used CF-Bench, a comprehensive benchmark tool designed for multicore mobile devices, to quantify the overall overheads of PoiseDroid. This tool can further measure the overheads introduced by native code, Java code, and an overall benchmark score, where higher scores mean better performance. <ref type="figure" target="#fig_6">Figure 16</ref> in <ref type="bibr">Appendix A.4</ref> shows that PoiseDroid only introduces 5%, 4%, and 5% additional overhead for the native, Java, and overall scores.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.7">Poise vs. OpenFlow-based SDN</head><p>Last but not least, we compare the paradigm of programmable in-network security, as embodied in Poise, against the paradigm of OpenFlow-based SDN security, in terms of a) the speed for security decision change, and b) resilience to control plane saturation attacks <ref type="bibr" target="#b76">[82]</ref>. As we motivated before, one key advantage of Poise over traditional SDN security solutions is the avoidance of software-based packet processing on a remote controller, because Poise uses programmable data planes to directly process context signals in hardware. Setup. We set up a Floodlight v1.2 SDN controller on a separate server, and configured other servers to use the controller via OpenFlow as implemented in OpenvSwitch v2.9.2. We implemented our example policies (P1-P7) as software "SDN apps" in the controller. These apps listen for client context updates, and push OpenFlow rules to the clients for access control. This closely mirrors the setup in state-of-the-art security solutions based on OpenFlow-based SDN <ref type="bibr" target="#b52">[58,</ref><ref type="bibr" target="#b69">75,</ref><ref type="bibr" target="#b76">82]</ref>. Defense agility. We quantify the defense agility of a security system by measuring δ, the time it takes to change its access control decision after seeing a new context packet. For OpenFlow-based SDN, this includes the round-trip time delay (We did not include the additional latency of OpenvSwitch because a hardware OpenFlow switch can reduce this significantly.) We found that, depending on the network load, the agility of the baseline system is δ =5 ms-2.47 s. In comparison, Poise directly processes context changes on the fast path, achieving δ &lt; 500 ns in all cases, which is three to seven orders of magnitude faster than the baseline. Control plane saturation attacks <ref type="bibr" target="#b76">[82]</ref>. An attacker can also create high loads on the channel between the data plane and the control plane by generating a large number of context changes. This effectively degrades the performance of legitimate users for establishing new connections, as the PacketIn messages go through the same channel. As <ref type="figure" target="#fig_0">Figure 12</ref> shows, the central controller struggles to keep up with the amount of context changes that it needs to process. At an attack strength of 1M context changes per second, legitimate clients clients were not able to establish new connections (99%+ connection requests from legitimate clients were dropped; the rest experienced a latency 30× higher than normal on average). Poise, on the other hand, processes context changes entirely in the data plane at hardware speeds. The performance for legitimate clients stays almost constant during the attacks. Programmable data planes. Poise builds upon the emerging trend of using data plane programmability <ref type="bibr" target="#b37">[43,</ref><ref type="bibr" target="#b38">44,</ref><ref type="bibr" target="#b79">85]</ref> for innetwork computation, e.g., load balancing <ref type="bibr" target="#b59">[65]</ref>, network monitoring <ref type="bibr" target="#b67">[73]</ref>, key-value cache <ref type="bibr" target="#b56">[62,</ref><ref type="bibr" target="#b60">66]</ref>, and coordination <ref type="bibr" target="#b55">[61]</ref>, but it focuses on a very different goal: security. The closest to our work is a recent workshop paper <ref type="bibr" target="#b64">[70]</ref>, but it neither has a full system implementation nor evaluation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Conclusion</head><p>We have described Poise, a system that can enforce contextaware security using a programmable, efficient, in-network primitive. In Poise, administrators can express a rich set of policies in a high-level language. Our compiler then compiles the policies down to switch programs written in P4. These programs run inside modern switches with programmable data planes, and can enforce security decisions at linespeed. Our evaluation shows that Poise has reasonable overheads, and that compared to OpenFlow-based defense, it is highly agile and resilient to control plane saturation attacks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Appendix</head><p>In this appendix, we include more discussions and results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Poise protocol format</head><p>In this subsection, we extend the discussion in §4.3 and describe the Poise protocol format in more detail. The Poise client module periodically sends context packets for each active connection. Context packets have the same flow tuples (source IP, destination IP, source port, destination port) with data packets from the same TCP/UDP flows. The only differences are that a) context packets have a special IP protocol number (IPProto=143 for TCP, IPProto=144 for UDP; both are unassigned protocol numbers <ref type="bibr">[21]</ref>), b) context headers come after the transport-layer (TCP/UDP) header, and c) context packets do not have payload. Poise never propagates context packets to external networks but rather drops them at the switch, and it does not modify data packets. <ref type="figure" target="#fig_1">Figure 13</ref> shows the format for TCP flows. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Compiler optimizations</head><p>This subsection extends §4.3 and describes in more detail the compiler optimizations. Consider now a policy that checks many context fields one by one, and only arrives at the final decision afterwards. The key challenge for handling such a policy is that these checks create "dependent tables", which due to P4 constraints must reside in separate stages. In essence, such a policy would result in a long chain of tables, which might exceed the number of available stages (O <ref type="figure">(1-10)</ref>) in a switch. Our optimization collapses a chain of tables of length k into multiple shorter chains k 1 , k 2 , .., k t , each of which stays within the number of available stages. Due to another P4 constraint-a packet can only match against a single table per stage, matching against all subchains k 1 , k 2 , .., k t would require recirculating the packet t times, each for a subchain. Recirculation of context packets would cause additional latency, as such packets now need to traverse the switch multiple times before finishing processing, and also additional recirculation traffic in a dedicated switch pipeline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Scalability</head><p>This subsection includes more results for §8.5. <ref type="figure" target="#fig_3">Figure 14</ref> shows the scalability of Poise for monitor policies, in terms of a) the number of monitors, and the number of checks per monitor <ref type="figure" target="#fig_3">(Figure 14a</ref>), b) the latency of context and data packets <ref type="figure" target="#fig_3">(Figure 14b)</ref>, and c) the throughput of recirculated context traffic and data traffic <ref type="figure" target="#fig_3">(Figure 14c</ref>).</p><p>Policies could also use a mix of monitor and regular context types. At a high level, a monitor is just another type of context, except that it uses two tables instead of one. <ref type="bibr">Figures 17, 18, 19</ref>, and 20 present the scalability results assuming 1, 2, 5, and 10 monitors in the policies; the rest of the available tables are used for regular contexts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.4 Client overhead</head><p>This subsection includes the full results for §8.6 on the client overhead due to the extra PoiseDroid module.  CPU and traffic overheads. <ref type="figure" target="#fig_4">Figures 15a and 15b</ref> show the CPU and traffic overheads at different frequencies of context packets. For each data point, we uploaded a video file of 1.73 GB to a remote FTP server using the mobile app AndFTP <ref type="bibr" target="#b0">[1]</ref>, and measured the CPU overhead as collected from the /proc/loadavg file. As we can see, if Poise were to tag each data packet with context information, then the CPU and traffic overheads are prohibitive (∼10%). Because the innetwork primitive is stateful, it can remember past decisions for each connection; this enables an optimized design where client modules can send out context packets periodically. The Poise primitive can look up its stateful data structure and apply access control decisions accordingly. For instance, at the frequency of one context packet per second, the CPU and traffic overheads are both low enough to be practical. Battery overhead. <ref type="table" target="#tab_7">Table 1</ref> shows the battery overhead of the PoiseDroid client, as measured by PCMark <ref type="bibr" target="#b29">[35]</ref>. PCMark tests capture a wide variety of activities, such as browsing, video playback, photo editing, writing, and data manipulation. In the beginning of the experiment, the phone was charged with full capacity (100%), and the tests ran until the battery dropped to less than 20%. We can see that, the highest overhead across all scenarios is only 2.87%. Overall benchmark. <ref type="figure" target="#fig_6">Figure 16</ref> shows the results obtained by CF-Bench, a comprehensive benchmark tool for testing multicore mobile devices. PoiseDroid introduces 5%, 4%, and 5% additional overheads for the native code, Java code, and overall scores, compared to the baseline system of a vanilla Android system without PoiseDroid installed.    </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Poise compiles high-level policies into a) switch programs, and b) device configurations. The clients send periodic context packets to the network, and Poise enforces the policy in the switches.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The language syntax for Poise policies. Context fields are represented as h. Expressions are represented as e, or v (constants). The • operator indicates comparisons.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>in Ap- pendix.) As a concrete example, Figure 4(a) shows the P4 headers for the gps signals: latitude and longitude.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>(a) Security context (b) Context operations (c) Constant lists + membership tests (d) Network-wide monitorsFigure 4 :</head><label>4</label><figDesc>Figure 4: The Poise compiler processes the key language constructs and generates P4 implementations. The P4 snippets shown are simplified for clarity of presentation. For instance, in (b), the instantiation of the thresh register is not shown; in (d), the timestamp of a packet is obtained via the ingress_global_timestamp field instead of a variable called NOW.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: The key/value store with example entries.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>(</head><label></label><figDesc>a) Keeping per-flow state requires a prohibitive amount of memory, but modern switches only have O(10MB) SRAM. Poise addresses this by approximating per-flow state using a on-chip key/value store. (b) Buffering control plane updates is necessary for handling new flows. Although context changes can be entirely handled by the data plane, new flows require installing match/action entries from the switch CPU, which takes time. Before updates are fully populated, Poise uses</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Poise uses a combination of match/action tables and stateful registers to process context and data packets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: The architecture of the PoiseDroid client module.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Our experiments are designed to answer five research questions: a) How well does the Poise compiler work? b) How efficiently can Poise process the security contexts inside the network? c) How well does Poise scale to complex policies? d) How much overhead does the Poise client incur on mobile devices? and e) How does Poise compare with traditional SDN-based security?</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Poise compiles the policies efficiently.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :Figure 10 :</head><label>910</label><figDesc>Figure 9: The amount of processing latency of Poise is small.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>if match ( usr == Bob ) then fwd( mbox ) if match ( lib ==1.0.2) then fwd( server )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Figure 11: Poise can perform 1.2 million exact checks for a single context, or 21k exact checks for a maximum of 40 contexts. Context packets with more than 5 contexts need to be recirculated multiple times; Poise supports a maximum of 7 recirculations, which leads to a latency of 6.5µs and an additional 0.37 Gbps traffic per port in a dedicated recirculation pipeline. Poise supports fewer range checks (55 k for one context, 0.8 k for 40 contexts) than exact checks, as the former are supported in TCAM, which is smaller than SRAM; but the latency and bandwidth overheads are similar, as they do not depend on the types of checks. Data packets are not affected by policy complexity, as they simply look up the decisions from the connection table.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 12 :</head><label>12</label><figDesc>Figure 12: Poise is resilient to control plane saturation attacks. Attack strength is measured by the number of context changes per second that the attacker generates. In the OpenFlow-based solution, new connections and context changes would generate PacketIn and FlowMod events between the OpenFlow switch and the central controller. for the context packet to reach the controller and for the controller to push new OpenFlow rules back to the OpenvSwitch. (We did not include the additional latency of OpenvSwitch because a hardware OpenFlow switch can reduce this significantly.) We found that, depending on the network load, the agility of the baseline system is δ =5 ms-2.47 s. In comparison, Poise directly processes context changes on the fast path, achieving δ &lt; 500 ns in all cases, which is three to seven orders of magnitude faster than the baseline. Control plane saturation attacks [82]. An attacker can also create high loads on the channel between the data plane and the control plane by generating a large number of context changes. This effectively degrades the performance of legitimate users for establishing new connections, as the PacketIn messages go through the same channel. As Figure 12 shows, the central controller struggles to keep up with the amount of context changes that it needs to process. At an attack strength of 1M context changes per second, legitimate clients clients were not able to establish new connections (99%+ connection requests from legitimate clients were dropped; the rest experienced a latency 30× higher than normal on average). Poise, on the other hand, processes context changes entirely in the data plane at hardware speeds. The performance for legitimate clients stays almost constant during the attacks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: Context packets have a special IP protocol number. Data packets from Poise clients have unchanged headers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>Figure 14: The scalability of Poise with monitor policies. The high-level takeaways are similar as those for regular, non-monitor policies (Figure 11 in §8.5). The only difference is that a monitor uses two tables, whereas a regular context uses one table.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Figure 15 :Figure 16 :</head><label>1516</label><figDesc>Figure 15: CPU and traffic overheads of PoiseDroid under different frequencies of context packets. Baseline: Android.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>Figure 17: Scalability results for policies with one monitor and 1-38 regular contexts. The number of (exact or range) checks Poise can perform is the same for a regular or monitor context. Similarly for all figures below.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head></head><label></label><figDesc>Figure 18: Scalability results for policies with two monitors and 1-36 regular contexts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><label></label><figDesc>Figure 19: Scalability results for policies with five monitors and 1-30 regular contexts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head></head><label></label><figDesc>Figure 20: Scalability results for policies with ten monitors and 1-20 regular contexts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head></head><label></label><figDesc>Compiling context operations. The Poise compiler distin- guishes between five classes of context operations: arithmetic operations, bitwise operations, comparisons, context matches, and membership tests. The first three classes are simpler to handle, as they can be directly translated into their P4 coun- terparts; the latter two require the compiler to generate ad- ditional code components in P4. First off, all context fields are compiled into header definitions and references to these</figDesc><table>header gps_t { 
bit&lt;32&gt; lat; 
bit&lt;32&gt; lon; 
} //ctxt def. 

struct headers { 
ethernet_t ether; 
ipv4_t 
ipv4; 
tcp_t 
tcp; 
gps_t 
gps; 
} //ctxt stack def. 

control Ingress { 
//switch ingress def. 
apply { 
bit&lt;32&gt; d; 
d=lat^2+lon^2; 
if (d &lt; thresh) 
fwd (1) 
else 
drop 
} //context operations 
… 
} 

//part of control Ingress. 
table admin { 
key = {dev: exact} 
actions = {allow, deny} 
const entries = { 
"Bob": allow 
"Alice": allow 
} //other users denied 
} 
… 
apply(admin) 

//part of control Ingress 
register&lt;32&gt; monitor; 
register&lt;32&gt; ts; 

if (admin.isValid()) { 
//update monitor result 
monitor++; 
} else if (NOW-ts &gt; timeo){ 
//timeout 
monitor=0; 
} 
ts = NOW; 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>eliminate redundant context tables and save mem- ory. (b) If a policy performs more context checks than the number of available stages, Poise will collapse the policy by recirculating context packets to traverse the stages multiple times, triggering different tables at each recirculation.</head><label></label><figDesc>Compiler optimizations. Programmable data planes have three types of notable constraints. Stages: There is a fixed number of hardware stages, and a packet can only match against one single context table per stage. Tables: A single stage can only hold a fixed number of tables. Memory: Each stage has a limited amount of memory. The Poise compiler performs two types of optimizations, which are particularly useful when Poise needs to compose many policies together. (a) If multiple policies check against the same context signal, our compiler will perform table dedu-plication to</figDesc><table>This 
addresses the switch constraint that a packet can only trigger 
a single table per stage. Our optimization creates the illusion 
of a larger number of stages with the cost of slightly increased 
latency for recirculated packets. We refer interested readers 
to Appendix A.2 for more details. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>table may not</head><label>may</label><figDesc></figDesc><table>have been populated with the corresponding 
entry yet. To address this, Poise uses a level of indirection 
by creating a small hardware Cache to buffer decisions for 
pending table updates, which resides on the data plane and 
can be updated at linespeed. All decisions in Cache are up-to-
date, since writes to this cache are immediately effective; but 
this table has a smaller capacity. The FullConn table takes 
more time to update, but it holds more connections. 

The cache design. As shown in Figure 5, Cache has a 
fixed number of entries. Our implementation uses 2 16 entries, 
which corresponds to the output size of a CRC-16 hash func-
tion. Each entry is of the form h→[sip,sport,proto,dec], 
where h is the CRC hash of the flow's three tuple, i.e., 
h=CRC(sip,sport,proto), and dec is the decision made 
based on the context packet. The size of Cache is 2 16 × (7 + 
1)=0.38 MB memory. When Poise receives a context packet 
from a new connection </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head></head><label></label><figDesc>from Cache that are mapped to the same bucket. Although the attacker may not know the hash seed, therefore cannot predict who would be the victim of the attack, she could degrade the performance of the connection that shares the same hash entry, if one exists. To prevent such attacks, we enhance the cache eviction strategy. When replacing an old entry e o with a new entry e n , we check whether these two entries are from the same source IP. If so, we immediately replace the entries. If not, we opportunistically perform the replacement. By doing so, we limit the amount of damage an attack can cause by sending frequent context packets.</figDesc><table>Total residency attacks. Different from stateless, IP-based 
routing, Poise keeps state in the FullConn table. Therefore, 
an attacker could initiate many new connections and try to 
a) overwhelm the FullConn table and b) constantly involve 
the switch CPU to install new entries. A defense, for instance, could rate limit the number of active connections and to con-
trol the growth of the FullConn table. In addition, the Poise 
control plane periodically scans through the FullConn table 
and expires inactive entries (using hardware support) to make 
room for new connections. 
Cache eviction attacks. The above algorithm defends against 
a malicious attacker that generates many connections to over-
whelm the FullConn table. However, an attacker can also 
launch targeted DoS attacks without initiating a suspiciously 
large number of connections. Specifically, she could send 
context packets more frequently than usual, and try to evict 
cache entries </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Table deduplication .</head><label>deduplication</label><figDesc></figDesc><table>Suppose that we would like to compose 
two policies that perform checks on the same context type. 
A naïve compiler would simply compile each check into a 
separate match/action table. With this approach, the number of 
policies that can be supported would be limited by the number 
of match/action tables in a switch. Depending on the switch 
model, this number is on the order of O(10), which is quite 
small. Our compiler can recognize that policies share the same 
context type, and it merges checks on the same context type 
by creating one table for each unique context across policies. 
Then, it compiles each check into a match/action table entry 
instead of a separate table. This optimization allows Poise 
to scale the number of context types to the number of table 
entries a switch can support, not the number of unique tables. 
This number is on the order of O(1M). 
Policy collapsing. </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>Table 1 : The battery overhead of PoiseDroid (lower is better).</head><label>1</label><figDesc></figDesc><table>Attribute 
Overall Browsing Video Writing Photo 
Data 
Android 
5493 
4278 
5458 
4530 
11432 
4136 
PoiseDroid 
5591 
4303 
5597 
4660 
11746 
4145 
Overhead 
1.02% 
0.06% 
2.55% 
2.87% 
2.75% 0.22% 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Andftp</surname></persName>
		</author>
		<ptr target="http://www.lysesoft.com/products/andftp" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Android For Work</surname></persName>
		</author>
		<ptr target="https://www.android.com/enterprise/employees/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barefoot</forename><surname>Tofino</surname></persName>
		</author>
		<ptr target="https://www.barefootnetworks.com/technology/#tofino" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">The benefits and risks of BYOD</title>
		<ptr target="https://goo.gl/ym9ATg" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emm</forename><surname>Blackberry</surname></persName>
		</author>
		<ptr target="https://www.blackberry.com/us/en/solutions/enterprise-mobility-management-emm" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Bring your own risk with BYOD</title>
		<ptr target="https://goo.gl/bn1rN4" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">BYOD: A global perspective</title>
		<ptr target="https://goo.gl/BTrSm4" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
				<ptr target="https://goo.gl/phTav6" />
		<title level="m">BYOD: Mobile devices threats and vulnerabilities</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cavium</forename><surname>Xpliant</surname></persName>
		</author>
		<ptr target="https://www.cavium.com/xpliant-ethernet-switch-product-family.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
				<ptr target="https://www.cisco.com/c/en/us/td/docs/switches/lan/catalyst6500/ios/12-2SX/configuration/guide/book/vacl.html" />
		<title level="m">Cisco Port ACLs (PACLs) and VLAN ACLs (VACLs</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">How to solve the end node problem</title>
		<ptr target="https://goo.gl/9wWqJr" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ibm Mobile</surname></persName>
		</author>
		<ptr target="https://goo.gl/zafGxN" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">IBM opens up smartphone, tablet support for its workers</title>
		<ptr target="https://goo.gl/WBn3vP" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">1AE: MAC security</title>
		<ptr target="https://1.ieee802.org/security/802-1ae/" />
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<biblScope unit="volume">802</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel Flexpipe</surname></persName>
		</author>
		<ptr target="https://www.intel.com/content/www/us/en/products/network-io/ethernet/switches.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<ptr target="https://github.com/p4lang" />
		<title level="m">P4 language repositories</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">The Poise code repository</title>
		<ptr target="https://github.com/qiaokang92/poise" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">The</forename></persName>
		</author>
		<ptr target="https://www.druva.com/blog/the-rise-and-risk-of-byod/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Byod</forename><surname>Samsung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Solutions</surname></persName>
		</author>
		<ptr target="https://goo.gl/GmZ1io" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samsung</forename><surname>Knox</surname></persName>
		</author>
		<ptr target="http://www.samsung.com/global/business/mobile/solution/security/samsung-knox" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Securing your weakest link: Your mobile devices</title>
		<ptr target="https://goo.gl/Z769MG" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Security configuration guide: Access control lists</title>
		<ptr target="https://goo.gl/zTJaUL" />
	</analytic>
	<monogr>
		<title level="j">Cisco IOS XE Release 3S</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emm</forename><surname>Symantec</surname></persName>
		</author>
		<ptr target="https://www.symantec.com/content/dam/symantec/docs/data-sheets/endpoint-protection-mobile-for-emm-en.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
				<ptr target="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/a-technical-report-on-tee-and-arm-trustzone" />
		<title level="m">A technical report on TEE and ARM TrustZone</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Top 21 companies in the BYOD market</title>
		<ptr target="https://goo.gl/MuRr66" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
				<ptr target="https://source.android.com/security/verifiedboot/" />
		<title level="m">Android Open Source Project</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vmware</forename><surname>Airwatch</surname></persName>
		</author>
		<ptr target="https://www.air-watch.com/capabilities/enterprise-mobility-management/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title/>
		<ptr target="https://goo.gl/H71Nji" />
	</analytic>
	<monogr>
		<title level="j">What is BYOD and why is it</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">1x remote authentication dial in user service (RA-DIUS) usage guidelines, RFC 3580</title>
		<ptr target="https://www.rfc-editor.org/info/rfc3580" />
	</analytic>
	<monogr>
		<title level="j">IEEE</title>
		<imprint>
			<biblScope unit="volume">802</biblScope>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pcmark</surname></persName>
		</author>
		<ptr target="https://play.google.com/store/apps/details?id=com.futuremark.pcmark.android.benchmark" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">I-pic: A platform for privacy-compliant image capture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Aditya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">Joon</forename><surname>Oh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Benenson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fritz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Schiele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bhattacharjee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">T</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. MobiSys</title>
		<meeting>MobiSys</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Authentication of smartphone users using behavioral biometrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Alzubaidi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kalita</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Communications Surveys&amp; Tutorials</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">NetKAT: Semantic foundations for networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-B</forename><surname>Jeannin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kozen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Schlesinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. POPL</title>
		<meeting>POPL</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Discovering smart home Internet of Things privacy norms using contextual integrity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Apthorpe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Shvartzshnaider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mathur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Reisman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IMWUT</title>
		<meeting>IMWUT</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Android security framework: Extensible multi-layered access control on android</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Backes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bugiel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gerling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Von Styp-Rekowsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACSAC</title>
		<meeting>ACSAC</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Privacy and contextual integrity: Framework and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Barth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Datta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Nissenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE S&amp;P</title>
		<meeting>IEEE S&amp;P</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Don&apos;t mind the gap: Bridging network-wide objectives and device-level configurations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Beckett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Padhye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">P4: Programming protocol-independent packet processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bosshart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Izzard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Schlesinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Talayco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Vahdat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGCOMM CCR</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Forwarding metamorphosis: Fast programmable match-action processing in hardware for SDN</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bosshart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gibb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Izzard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Mujica</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Horowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Ethane: Taking control of the enterprise</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pettit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">SANE: A protection architecture for enterprise networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Casado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Garfinkel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Akella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Security</title>
		<meeting>USENIX Security</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Comparing intention to avoid malware across contexts in a BYOD-enabled Australian university: A protection motivation theory approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dang-Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pittayachawan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Security</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="281" to="297" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">SPINE: Surveillance protection in the network elements</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Datta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FOCI</title>
		<meeting>FOCI</meeting>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Evaluating behavioral biometrics for continuous authentication: Challenges and metrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Eberz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">B</forename><surname>Rasmussen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Lenders</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Martinovic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AsiaCCS</title>
		<meeting>AsiaCCS</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Continuous authentication of smartphone users based on activity pattern recognition using passive mobile sensing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ehatisham-Ul-Haqa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Azama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Naeemb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Amina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Looc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Network and Computer Applications</title>
		<imprint>
			<biblScope unit="volume">109</biblScope>
			<biblScope unit="page" from="24" to="35" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">FlowFence: Practical data protection for emerging IoT application frameworks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Fernandes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Paupore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rahmati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Simionato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Conti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Prakash</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Security</title>
		<meeting>USENIX Security</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">RoleBased Access Control. Artech House</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">F</forename><surname>Ferraiolo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chandramouli</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Proposed NIST standard for role-based access control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">F</forename><surname>Ferraiolo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sandhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gavrila</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chandramouli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information and System Security (TISSEC)</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="224" to="274" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Frenetic: A network programming language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Monsanto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Story</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFP</title>
		<meeting>ICFP</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Cloak and dagger: From two permissions to complete control of the UI feedback loop</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Fratantonio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE S&amp;P</title>
		<meeting>IEEE S&amp;P</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Flexible team-based access control using contexts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">K</forename><surname>Georgiadis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Mavridis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pangalos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">K</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SACMAT</title>
		<meeting>SACMAT</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Simultaneous authentication of equals: A secure, password-based key exchange for mesh networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Harkins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SensorComm</title>
		<meeting>SensorComm</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Towards SDN-defined programmable BYOD (bring your own device) security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Baykov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Nadimpalli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Poisoning network visibility in software-defined networks: New attacks and countermeasures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">ContexIoT: Towards providing contextual integrity to appified IoT platforms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">J</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">A</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rahmati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Fernandes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">M</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Prakash</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">NetChain: Scale-free sub-RTT coordination</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Soule</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">NetCache: Balancing key-value stores with fast in-network caching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Soulé</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title level="m" type="main">Invoking user-space applications from the kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Jones</surname></persName>
		</author>
		<ptr target="https://www.ibm.com/developerworks/library/l-user-space-apps/index.html" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Compiling packet programs to reconfigurable switches</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Jose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Varghese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NSDI</title>
		<meeting>NSDI</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">HULA: Scalable load balancing using programmable data planes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Katta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sivaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSR</title>
		<meeting>SOSR</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">IncBricks: Toward in-network computation with an in-network cache</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Atreya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ASPLOS</title>
		<meeting>ASPLOS</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">OpenFlow: Enabling innovation in campus networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mckeown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Parulkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGCOMM Computer Communication Review</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="69" to="74" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">A compiler and run-time system for network programming languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Monsanto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. POPL</title>
		<meeting>POPL</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Composing software-defined networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Monsanto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Reich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rexford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSI</title>
		<meeting>NDSI</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Enforcing contextaware BYOD policies with in-network security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Morrison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Luo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotCloud</title>
		<meeting>HotCloud</meeting>
		<imprint>
			<date type="published" when="2018-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<monogr>
		<title level="m" type="main">Time-based one-time password algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>M&amp;apos;raihi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Machani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rydell</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>RFC 6238</note>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">ASM: A programmable interface for extending Android security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nadkarni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Security</title>
		<meeting>USENIX Security</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Language-directed hardware design for network performance monitoring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Narayana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sivaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Nathan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Goyal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Arun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Alizadeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Jeyakumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Beyond kernel-level integrity measurement: Enabling remote attestation for the Android platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Nauman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-P</forename><surname>Seifert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TRUST</title>
		<meeting>TRUST</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">PivotWall: SDN-based information flow control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Oconnor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Enck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">M</forename><surname>Petullo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Verma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSR</title>
		<meeting>SOSR</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<title level="m" type="main">eXtensible Access Control Markup Language (XACML) specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parducci</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">A security enforcement kernel for OpenFlow networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Porras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Yegneswaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tyson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotSDN</title>
		<meeting>HotSDN</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Fattire: Declarative fault tolerance for software-defined networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Reitblatt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Canini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotSDN</title>
		<meeting>HotSDN</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Concurrent NetCore: From policies to pipelines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Schlesinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Greenberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Walker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFP</title>
		<meeting>ICFP</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Cloudwatcher: Network security monitoring using OpenFlow in dynamic cloud networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICNP</title>
		<meeting>ICNP</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Fresco: Modular composable security services for software-defined networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Porras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Yegneswaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Tyson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">AVANT-GUARD: Scalable and vigilant switch flow management in software-defined networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Yegneswaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Porras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CCS</title>
		<meeting>CCS</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Effective topology tampering attacks and defenses in software-defined networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Skowyra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hobson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Dedhia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Landry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Okhravi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. DSN</title>
		<meeting>DSN</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Enabling practical software-defined networking security applications with OFX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sonchack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aviv</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Protocol-oblivious forwarding: Unleash the power of SDN through a future-proof forwarding plane</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotSDN</title>
		<meeting>HotSDN</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<monogr>
		<title level="m" type="main">Synchronized security: Best-of-breed defense that&apos;s more coordinated than attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sophos</surname></persName>
		</author>
		<ptr target="https://www.sophos.com/en-us/medialibrary/gated-assets/white-papers/sophos-security-heartbeat-wpna.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Access control in collaborative systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Tolone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G.-J</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Pai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="29" to="41" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<monogr>
		<title level="m" type="main">Enforcing mobile security with location-aware role-based access control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Ulltveit-Moe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Oleshchuk</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
			<publisher>Security and Communication Networks</publisher>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="429" to="439" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Next generation security with VMware NSX and Palo Alto Networks VM-series</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vmware</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">White Paper</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<monogr>
		<title level="m" type="main">Don&apos;t configure the network, program it! Domain-specific programming languages for network systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Voellmy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hudak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Feamster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Burnett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Launchbury</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
		<respStmt>
			<orgName>Yale University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b85">
	<analytic>
		<title level="a" type="main">Deepdroid: Dynamically enforcing enterprise policy on Android devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Jing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">Towards continuous and passive authentication across mobile devices: an empirical study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Mengshoel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Tague</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. WiSec</title>
		<meeting>WiSec</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">An untold story of middleboxes in cellular networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">M</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SIGCOMM</title>
		<meeting>SIGCOMM</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<monogr>
		<title level="m" type="main">BeyondCorp: A new approach to enterprise security. USENIX ;login</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Beyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="6" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<monogr>
		<title level="m" type="main">Alliance introduces Wi-Fi Certified WPA3 security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wi-Fi</surname></persName>
		</author>
		<ptr target="https://www.wi-fi.org/news-events/newsroom/wi-fi-alliance-introduces-wi-fi-certified-wpa3-security" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Attacking the brain: Races in the SDN control plane</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Gu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX Security</title>
		<meeting>USENIX Security</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<monogr>
		<title level="m" type="main">Android System Programming: Porting, customizing, and debugging Android HAL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ye</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
			<publisher>Packt Publishing</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">PSI: Precise security instrumentation for enterprise networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Fayaz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Seshan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NDSS</title>
		<meeting>NDSS</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b93">
	<analytic>
		<title level="a" type="main">Handling a trillion (unfixable) flaws on a billion devices: Rethinking network security for the Internet-of-Things</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Seshan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotNets</title>
		<meeting>HotNets</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b94">
	<analytic>
		<title level="a" type="main">Scenario-based programming for SDN policies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">T</forename><surname>Loo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. CoNEXT</title>
		<meeting>CoNEXT</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b95">
	<analytic>
		<title level="a" type="main">BYOD security engineering: A framework and its analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Zahadat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Blessner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Blackburn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Olson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers &amp; Security</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page" from="81" to="99" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
