<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:30+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A graph model of data and workflow provenance</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Umut</forename><surname>Acar</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Max-Planck Institute for Software Systems</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
								<orgName type="institution" key="instit3">Hasselt University</orgName>
								<orgName type="institution" key="instit4">Hasselt University</orgName>
								<orgName type="institution" key="instit5">Université Libre de Bruxelles</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Buneman</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Max-Planck Institute for Software Systems</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
								<orgName type="institution" key="instit3">Hasselt University</orgName>
								<orgName type="institution" key="instit4">Hasselt University</orgName>
								<orgName type="institution" key="instit5">Université Libre de Bruxelles</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Cheney</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Max-Planck Institute for Software Systems</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
								<orgName type="institution" key="instit3">Hasselt University</orgName>
								<orgName type="institution" key="instit4">Hasselt University</orgName>
								<orgName type="institution" key="instit5">Université Libre de Bruxelles</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Max-Planck Institute for Software Systems</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
								<orgName type="institution" key="instit3">Hasselt University</orgName>
								<orgName type="institution" key="instit4">Hasselt University</orgName>
								<orgName type="institution" key="instit5">Université Libre de Bruxelles</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Natalia</forename><surname>Kwasnikowska</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Max-Planck Institute for Software Systems</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
								<orgName type="institution" key="instit3">Hasselt University</orgName>
								<orgName type="institution" key="instit4">Hasselt University</orgName>
								<orgName type="institution" key="instit5">Université Libre de Bruxelles</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stijn</forename><surname>Vansummeren</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Max-Planck Institute for Software Systems</orgName>
								<orgName type="institution" key="instit1">University of Edinburgh</orgName>
								<orgName type="institution" key="instit2">University of Edinburgh</orgName>
								<orgName type="institution" key="instit3">Hasselt University</orgName>
								<orgName type="institution" key="instit4">Hasselt University</orgName>
								<orgName type="institution" key="instit5">Université Libre de Bruxelles</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A graph model of data and workflow provenance</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Provenance has been studied extensively in both database and workflow management systems, so far with little convergence of definitions or models. Provenance in databases has generally been defined for relational or complex object data, by propagating fine-grained annotations or algebraic expressions from the input to the output. This kind of provenance has been found useful in other areas of computer science: annotation databases, probabilistic databases, schema and data integration , etc. In contrast, workflow provenance aims to capture a complete description of evaluation-or enact-ment-of a workflow, and this is crucial to verification in scientific computation. Workflows and their prove-nance are often presented using graphical notation, making them easy to visualize but complicating the formal semantics that relates their run-time behavior with their provenance records. We bridge this gap by extending a previously-developed dataflow language which supports both database-style querying and workflow-style batch processing steps to produce a workflow-style provenance graph that can be explicitly queried. We define and describe the model through examples, present queries that extract other forms of provenance, and give an exe-cutable definition of the graph semantics of dataflow expressions .</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A number of standard database provenance models tailored to relational, complex-object or XML query languages have emerged. These models include lineage <ref type="bibr" target="#b8">[9]</ref>, where-provenance <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2]</ref>, why-provenance <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref>, and more recent innovations such as dependencyprovenance <ref type="bibr" target="#b6">[7]</ref>, how-provenance <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b10">11]</ref>, and provenance traces <ref type="bibr" target="#b5">[6]</ref>. These models have been presented in a number of different ways and founded on several different motivations. Recently, further study has revealed that these models share a great deal of structure once they are defined in a common language and data model <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b5">6]</ref>.</p><p>Provenance models have also been developed for a variety of workflow systems, such as Chimera <ref type="bibr" target="#b9">[10]</ref>, Taverna <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr">Kepler [1]</ref>, Karma <ref type="bibr" target="#b23">[24]</ref>, and ZOOM <ref type="bibr" target="#b25">[26]</ref>; also, many other systems such as PASS and PASOA employ similar ideas <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b22">23]</ref>. These systems model and record provenance as a directed acyclic graph that, informally, describes the macroscopic computation steps (e.g., whole program executions) performed in constructing intermediate and final results. Recently, the Open Provenance Model (OPM) <ref type="bibr" target="#b21">[22]</ref> has been developed as a consensus exchange format for representing provenance graphs.</p><p>Workflow systems employ a much wider variety of programming constructs than databases, including concurrency, procedures, service calls, and queries to external databases. However, these systems are seldom accompanied by formal specifications of their intended semantics, with or without provenance. As a result, it can be hard to understand provenance information produced by a workflow system, since the meaning intended by the implementer may not match the expectations of the user. This is a particularly vexing problem because some users and implementers might not even be aware of the possibility of misinterpretation, leading to further confusion.</p><p>The scarcity of clear specifications of the semantics and provenance behavior of workflow systems makes it difficult to integrate database and workflow provenance or compare provenance graphs generated by different systems. Therefore, we believe that it is essential to study the semantics of workflow provenance models and relate them to existing models of database provenance.</p><p>To compare and unify these different techniques, we need to define a common provenance model. Database provenance models can be visualized as graphs. Whereprovenance, lineage, and dependency-provenance can be visualized as bipartite graphs linking parts of the output with parts of the input. How-provenance and whyprovenance are more complex, but can also be visualized as directed acyclic graphs linking parts of the output to parts of the input, where nodes are labeled with symbolic algebraic operations. Graphs provide a natural common formalism for workflow and database provenance.</p><p>We also need a common language that can express both database queries and workflows. In this paper, we use a core calculus for dataflows, called DFL, based on the Nested Relational Calculus (NRC). DFL has been previously introduced by Hidders et al. <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref> and we also build upon some prior work on provenance in this setting <ref type="bibr" target="#b18">[19]</ref>. We develop a graphical model of provenance for both database queries and simple workflows in a uniform way. This should provide a foundation for studying more complex workflow language features such as nondeterminism, concurrency and while-loops.</p><p>The structure of the rest of this paper is as follows. In Section 2 we review the dataflow calculus DFL. In Section 3 we describe the structure of provenance graphs and give examples showing how typical dataflows are translated to graphs. In Section 4 we describe the provenance semantics of DFL programs, and give an executable, yet still high-level implementation in Haskell. Section 5 discusses how to express queries over the graphs, particularly inspired by where-and and why-provenance in databases, and outlines some future directions. Section 6 discusses related work and Section 7 concludes.</p><p>Note. Our graphical model is fundamentally very similar to the trace model developed in prior, unpublished work with Acar and Ahmed <ref type="bibr" target="#b5">[6]</ref>. However, we make a different contribution: namely, we feel our graphtheoretic presentation is more widely accessible than the syntactic traces and operational semantics rules employed to simplify proofs of their main results in <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>The dataflow language DFL <ref type="bibr" target="#b16">[17]</ref> is an extension of the Nested Relational Calculus (NRC) that includes atomic values and functions. As we can only briefly introduce DFL here due to space reasons, we encourage readers unfamiliar with DFL and NRC to consult <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b16">17]</ref> for more details. In brief, the syntax of DFL is as follows:</p><formula xml:id="formula_0">e, e ::= x | let x = e in e | c | f (e 1 , . . . , e n ) | π A (e) | A 1 :e 1 , . . . , A n :e n | empty?(e) | True | False | if e then e 1 else e 2 | ∅ | {e} | e 1 ∪ e 2 | {e | x ∈ e} | e</formula><p>Here, c denotes a constant atomic data value, drawn from a set D, and f denotes a function. Atomic data values may be values of base types such as integers or booleans or strings, but they may also be more complicated objects such as images or data files. Functions include primitive operations on basic data types, such as integer addition and equality. Furthermore, functions can also represent large computational steps such as external program or service calls: for example, to model the first Provenance Challenge workflow we might use base types such as Image, Header, or WarpFile and function symbols such as align warp : Image × Header × Image × Header → WarpFile or reslice : WarpFile → Image × Header to represent the macroscopic computation steps. The remaining syntactic constructs above are standard components of the Nested Relational Calculus: we include record and field projection operations, booleans and conditionals, and set operations. We employ the syntax {e (x) | x ∈ e} for the "for-loop" or set comprehension operation which evaluates e to a set {v 1 , . . . , v n } and returns the set of values {e (v 1 ), . . . , e (v n )} obtained by evaluating e with x bound to each v i . The expression e flattens a nested collection. The expression empty?(e) tests whether collection e is empty.</p><p>We will use ordered-pair syntax (e 1 , e 2 ) to abbreviate fst : e 1 , snd : e 2 , and write fst(e) or snd(e) instead of π fst (e) or π snd (e), respectively, for the first and second projections of an ordered pair. We also assume a fixed, finite set of attribute names Attr.</p><p>DFL and NRC are statically typed languages with an arbitrary but fixed collection of atomic types, and an arbitrary but fixed signature that assigns types to the constants and function symbols <ref type="bibr" target="#b4">[5]</ref>. The static typing discipline ensures that expressions are always well-defined on input values of the correct type. For ease of presentation in what follows, we will ignore typing issues and silently restrict attention to expressions and evaluations that are well-defined in the conventional sense <ref type="bibr" target="#b4">[5]</ref>. So whenever we apply, for example, e 1 ∪ e 2 , e 1 and e 2 are assumed to correctly evaluate to sets.</p><p>3 Value, evaluation and provenance graphs DFL expressions are normally evaluated over complex values, which are nested combinations of atomic data values d, tuples of complex values A 1 : v 1 , . . . , A n : v n , and sets of complex values {v 1 , . . . , v n }. As we show in Section 3.1, we can easily represent complex values as trees or (with sharing) as directed acyclic graphs. Using such value graphs, we are going to represent the evaluation of a DFL expression by means of a provenance graph in Section 3.3. A provenance graph is a two-sorted graph, consisting of a value graph and an evaluation graph (introduced in Section 3.2), that documents the evaluation of a program. Moreover, there is a connection between the evaluation graph and the value graph in that each evaluation node is linked to a value node.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Value graphs</head><p>A value graph G is a directed acyclic graph (V, E) with labels on the nodes and edges. The nodes are labeled using the alphabet {{}, , copy} ∪ D. The edges are optionally labeled using the alphabet {elem} ∪ Attr. We use the formula lab l (n) to indicate that n has label l in G and n l → n to indicate that there is an edge (n, n ) with label l in G.</p><p>To illustrate, the following graph represents the value {{A : 1, B : 2, A : 1, B : 3}: The meaning of these patterns is that a value graph v can be constructed from another valid graph by adding new nodes and edges (shown using solid lines) linked to some existing nodes (shown using dotted lines). Sharing among the nodes of the value graph is allowed. Also, the empty graph is valid and the union of two disjoint value graphs is valid. A tree-shaped value graph is called a value tree. Clearly, one can canonically represent any complex value by the root node of a value tree. Moreover, any value graph can be converted to a value tree by duplicating shared nodes and by merging copy nodes with their targets. In any value graph, any node from which the unraveling yields this canonical value tree, is said to also represent the same complex value.</p><p>In what follows, we often say "n is a copy of n (in G)" as shorthand meaning that n is a copy node and its (sole, unlabeled) outgoing edge is n .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Evaluation graphs</head><p>An evaluation graph G = (V, E) is a labeled directed acyclic graph with node labels drawn from the set</p><formula xml:id="formula_1">{x, c, f, , π A , let x , if, ∅, {}, ∪,</formula><p>, for x } and optional edge labels drawn from the set {A, head, body, test, then, else, 1, 2, . . .}</p><p>As with value graphs, we write lab l (m) to indicate that node x has label l and m l → m to indicate that nodes m and m are linked by an edge labeled l.</p><p>A valid evaluation graph is one that can be constructed using the following rules: where, again, the meaning of each pattern is that we can extend the graph by adding new nodes and edges (shown using solid lines) by linking to existing nodes (shown using dotted lines). The existing nodes need not be disjoint, so sharing can occur in evaluation graphs. Also, the empty graph is valid and the union of two disjoint graphs is valid.</p><formula xml:id="formula_2">...</formula><p>Finally, we introduce the following terminology: A node labeled let x or for x is said to bind x. We say that a variable node e x labeled by x is in the scope of a node e that binds x, if there is a path from e to e x that does not pass through another node that binds x. We require each variable node to be in the scope of at most one binding node.</p><p>For example, the following is a valid evaluation graph: Essentially, this graph says that a value was obtained by doing a conditional test x = 1 which failed, and then evaluating the else-branch to return x * 5. Note that there is no information about the actual value of x or the result of the computation, although we can infer that x = 1 holds.  value or evaluation labels, such that:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Provenance Graphs</head><formula xml:id="formula_3">1. V = V V V E , 2</formula><p>. prov is a partial injective function from V V to V E so that each evaluation node e has a unique value node val (e), 3. G is a value graph if we disregard the evaluation graph structure, and 4. G is an evaluation graph if we merge each pair of nodes (e, val (e)) and disregard the value structure. In the following examples, by convention, we highlight parts of the input expression that are considered "inputs" using gray boxes.</p><p>Here is a simple example, showing the computation 3 + 4 = 7:</p><formula xml:id="formula_4">+ 3 1 4 2 7</formula><p>Here is a more complicated example, showing the evaluation of expression π 2 ( 3 + 4 , 5 ) = 5 involving constructing a pair and then selecting the second argument:  Given a provenance graph G and an evaluation node e, there is a natural notion of (G, e) being locally consistent, with the intuition that the computation depicted in the part of the evaluation graph reachable from e matches the assignment of value nodes to evaluation nodes by the val-edges. The graphs used as examples so far are all consistent in this sense; however, the following graphs are inconsistent: The left example is obviously silly: the claimed result of a function should be consistent with the function's meaning. The right example is more subtle: the labels of the branches in conditional nodes need to match the boolean value of the test.</p><p>Moreover, we expect the evaluation graph to be globally consistent, in the sense that the whole trace is an "unfolding" of the evaluation of a particular expression e. All of the graphs we have seen so far are globally con-sistent with an expression. However, the following graph is globally inconsistent:</p><p>The inconsistency here is between the two evaluation bodies of the for-loop: the body of a comprehension cannot be both a constant 3 and a constant 4. In a globally consistent graph the control flow leading to different values for different iterations must be made explicit.</p><p>It is possible to enforce local consistency using firstorder constraints on the provenance graph. Moreover, global consistency can also be defined using first-order constraints by induction on the structure of expressions e. We omit the actual constraints due to space limits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The provenance graph semantics</head><p>In this section we will show how to construct a consistent provenance graph by evaluating DFL expressions to construct both a value and evaluation graph, with appropriate links. <ref type="figure" target="#fig_8">Figure 2</ref> illustrates the semantics schematically using some graph rewriting rules, where the rounded boxes describe the expression structure. Each rule schematically shows how an expression locally evaluates to values and expression nodes. These rules can be applied to build a provenance graph "bottom-up".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">An executable definition</head><p>Defining an algorithm to actually construct a provenance graph can be tricky due to the large number of details we need to manage. We present a definition using Haskell <ref type="bibr" target="#b17">[18]</ref>, a functional language that provides sophisticated facilities for defining side-effecting operations such as those involved in building a graph. Using these features we can define a function that traverses an expression, evaluates it and constructs the associated provenance graph in only a few hundred lines of code. Haskell programs are precise definition that is still relatively readable and clear. Moreover, it is an executable specification that can be used to generate small examples and experiment with alternative definitions.</p><p>In general while evaluating an expression with free variables, we need to keep track of the values associated with variables, so we will introduce a little more notation to help with this bookkeeping.</p><p>For a finite set X of variables, a value assignment for X is a mapping σ : X → Val that assigns to each x ∈ X a complex value. We can model value assignments in a provenance graph G as follows.  the evaluation graph of G, such that for each x ∈ X, we have lab x (γ(x)). Then for each x, the value node γ(x) corresponds to a complex value. In particular, given an ordinary assignment σ : X → Val, we can always construct a graph G that defines value nodes for the values of σ(x) and whose evaluation nodes correspond exactly to the variables in X.</p><p>In Haskell, it is more convenient to represent the graph as a collection of finite maps from nodes to datatypes that we shall call constructors. In our implementation, a single node will correspond to a pair (m, n) of an expression and value node in the previous development. We map each node to a value constructor and optionally an evaluation constructor. Constructors encode both the node and edge labels. For example, we use a constructor EIf True n1 n2 to represent an if node with testedge to n 1 , a test value of True, and then-edge to n 2 . This approach builds many of the basic validity properties of provenance graphs into the Haskell type system, making it easier to avoid trivial bugs. Of course, the constructor-based graph can be translated to the explicitly edge-labeled graphs used earlier. <ref type="figure">Figure 8</ref> shows the basic datatypes for nodes, variables, contexts, and evaluation and value constructors in Haskell. Note that for simplicity we use Haskell's built-in list type for collections; we also restrict attention to ordered pairs rather than general records. These differences are inessential.</p><p>We also employ a feature of Haskell called monads <ref type="bibr" target="#b20">[21]</ref> to structure the computation of the provenance graph for a given expression. Basically, a monad is a generic type M a. A value of type M a is a computation that produces a value of type a and may have some sideeffects. Because Haskell is a pure functional language, all side-effects need to be encapsulated within a monad. Monads can also handle contextual information such as tracking the current values of variables.</p><p>Our monad will employ the type:</p><formula xml:id="formula_5">type M a = Ctx -&gt; Int -&gt; Graph -&gt; (Int,Graph,a)</formula><p>Here, Ctx represents the variable context, the Int parameter/result is a counter used for generating fresh node ids, and the Graph parameter/result is the graph being built. The definition of the monad type and its operations in Haskell is slightly different for technical reasons. For presentation reasons we suppress these differences. A monad is always equipped with two operations, here called "&gt; &gt; =" (or "bind") and "return". The "return" operation simply takes a value of type a and produces a monad returning that value:</p><p>return :: a → M a return a = λγ.λi.λG.(i, G, a) Furthermore, the "bind" operation takes an M a (i.e., a computation producing values of type a) and a function from a to M b and produces a computation M b returning a value of type b. Its definition is as follows:</p><formula xml:id="formula_6">&gt; &gt; = :: M a → (a → M b) → M b f &gt; &gt; = g = λγ.λi.λG. let (i , G , a) = f γ i G in (g a) γ i G</formula><p>Finally, we define a number of operations that allow us to read the current state of the computation or perform a side-effecting operation. We give some examples in detail and then just describe the remaining operations.</p><p>To read the current value of a variable in the context, we define the lookup operation:</p><formula xml:id="formula_7">lookup :: Var → M Node lookup x = λγ.λi.λG.(i, G, γ(x))</formula><p>To create a fresh node, we define the following monadic operation that creates a new node using the current index and increments the index:</p><formula xml:id="formula_8">fresh :: M Node fresh = λγ.λi.λG.(i + 1, G, Node(i))</formula><p>Similar operations can be defined to access the current context, add a variable binding to the context, and so on. These operations are shown in <ref type="figure" target="#fig_11">Figure 3</ref>. We also include monadic versions of primitive functions (interp) and complex operations such as flattening (</p><p>). The operation link econ vcon extends the graph with a new node n bound to the constructors econ and vcon, returning n. Second, e * x∈vs evaluates e repeatedly, with x bound in turn to each element of vs. The examples in <ref type="figure" target="#fig_4">Figure 1</ref> were generated using the Haskell implementation and the graphviz Unix tool 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Querying the provenance graph</head><p>The provenance graph is a relational structure, and as such there are a wide variety of languages available for querying the graph, ranging from simple path or reachability queries, to SQL-like relational queries, to more expressive languages supporting recursive queries, such as Datalog. Thus, in a sense the problem of querying  the provenance graph is already solved by known techniques for querying arbitrary graphs that happen to be provenance.</p><p>However, it still seems to be a challenge to define known forms of provenance in databases in terms of provenance graphs. In this section, we sketch preliminary ideas towards this goal, using Datalog over the raw provenance graphs.</p><p>In order to define forms of where-provenance and why-provenance, we need a partial orders on evaluation nodes. We start by ordering the evaluation nodes in G based on the following two orders:</p><p>1. Child (n 1 , n 2 ) if n 2 l → n 1 (i.e., there is an edge from n 2 to n 1 ) 2. Left(n 1 , n 2 ) if</p><p>• n 1 is the test-node of a conditional and n 2 is one of the branches • n 1 is the head-node of a let or for-node n and n 2 is a body-node of n The partial order Before is defined as follows:</p><formula xml:id="formula_9">Below (e, e) ← Eval(e) Below (e, f ) ← Below (e, g), Child (g, f ) Before(e, f ) ← Below (e, f ) Before(e, f ) ← Before(e, e ), Below (e , g), Left(g, h), Before(f, h)</formula><p>where in the first rule we ensure safety by constraining e − :: Expr → M Node</p><formula xml:id="formula_10">x = lookup x let x = e1 in e2 = e1 &gt; &gt; = λn1. bindVar x n1 e2 &gt; &gt; = λn2. link(ELet x n1 n2) (VCopy n2) i = link(EInt i) (VInt i) f (e) = e † &gt; &gt; = λ(n, v). interp f (v) &gt; &gt; = λv . link(EFun f (n)) (v )</formula><p>Figure 4: Monadic semantics for building provenance graphs, part 1 (variables, let, primitive functions) to be an evaluation node using a predicate Eval(e) that lists all evaluation nodes. We also define the Copy relation on value nodes as the reflexive, transitive closure of the copy edge relation. We use the predicate V alue(n) in the first rule to constrain n to be a value node, ensuring safety:</p><formula xml:id="formula_11">− † :: Expr → M (Node, VCon) e † = e &gt; &gt; = λn. getVCon(n) &gt; &gt; = λv. return (n, v) − * x∈[] = return [] e * x∈n 0 :ns = bindVar x n0 e &gt; &gt; = λn 0 . e * x∈ns &gt; &gt; = λns . return (n 0 : ns )</formula><formula xml:id="formula_12">Copy(n, n) ← V alue(n) Copy(n, n ) ← Copy(n, n ), n copy → n</formula><p>We will define where-provenance and whyprovenance queries on pairs (e, v) such that v is reachable by a directed path (possibly including copy-links) from e. We will call such pairs instances.</p><formula xml:id="formula_13">(e1, e2) = e1 &gt; &gt; = λn1. e2 &gt; &gt; = λn2. link(EPair(n1, n2)) (VPair(n1, n2)) πi(e) = e † &gt; &gt; = λ(n, VPair(n1, n2)) link(EProj i n) (VCopy ni) b = link(EBool b) (VBool b) if e then e1 else e2 = e † &gt; &gt; = λ(n, VBool b). if b then e1 &gt; &gt; = λn . link(EIf True n n ) (VCopy n ) else e2 &gt; &gt; = λn .</formula><p>link(EIf False n n ) (VCopy n ) <ref type="figure">Figure 6</ref>: Monadic semantics for building provenance graphs, part 2 (pairs, conditionals) </p><formula xml:id="formula_14">∅ = link(EEmpty) (VSet []) {e} = e &gt; &gt; = λn. link(ESng n) (VSet [n]) e1 ∪ e2 = e1 † &gt; &gt; = λ(n1, VSet(vs1)). e2 † &gt; &gt; = λ(n2, VSet(vs2)). link(EUnion n1 n2) (VSet(vs1 + + vs2)) {e | x ∈ e0} = e0 &gt; &gt; = λ(n0, VSet(ns)). e * x∈vs &gt; &gt; = λns . link(EFor</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Where-provenance</head><p>We now can define a form of where-provenance on instances (e, v) as follows:</p><formula xml:id="formula_15">Where((e 1 , v 1 ), (e 2 , v 2 )) ← Before(e 1 , e 2 ), Copy(v 2 , v 1 )</formula><p>Intuitively, this says that the where-provenance of the value v 2 returned by the evaluation ending at e 2 is the same as that of the value v 1 returned by e 1 . Clearly, there should be a unique least (e 1 , v 1 ) with respect to Before so we can define the where-provenance as that instance (e 1 , v 1 ). This definition relies on the fact that our provenance graph already corresponds closely to the highlevel view of where-provenance defined via annotationpropagation in previous work <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b1">2]</ref>. One important difference is that here, we can refer to intermediate steps in the provenance graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Why-provenance</head><p>Why-provenance was defined in <ref type="bibr" target="#b2">[3]</ref> using witnesses. There, a witness to the existence of a part p of the output of a query Q on input data d was defined as a subtree of the input d such that rerunning Q on the subtree still produces output part p. We generalize this idea as follows.</p><p>Let G be a provenance graph with a distinguished evaluation node r whose value is v. Let U be a connected subset of the result value nodes that contains v. Then a witness to U in G is a consistent subgraph of G that contains r and U . The why-provenance of V is then the set of all minimal witnesses to U in G.</p><p>Alternatively, we could give a low-level definition that traverses the graph to construct a witness starting from a set of output value nodes, following similar lines to the low-level definition of Where above. We omit the details; the main differences are in rules for conditionals and primitive functions where we continue tracking the dependencies of the test or input values respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Discussion</head><p>This discussion suggests a number of interesting observations and questions which we will not attempt to resolve here, including:</p><p>• The first definition of Where appears equivalent to the where-provenance model of <ref type="bibr" target="#b1">[2]</ref>. Can we make this connection precise? Likewise, can we formally relate the why-provenance subgraphs to definitions of whyprovenance or lineage for NRC (e.g. <ref type="bibr" target="#b10">[11]</ref>)?</p><p>• The above definitions characterize whereprovenance structurally by following a chain of copies from the input to the output (or vice versa). This exhibits a symmetry between querying the provenance graph "forward" vs. "backward". Is this a unique feature of where-provenance or are there other provenance queries that have this property?</p><p>• In some prior work (e.g. <ref type="bibr" target="#b1">[2]</ref>), forms of provenance have been defined by translating NRC queries to queries that explicitly manage their own provenance information. Is this possible for provenance graphs?</p><p>• We explored a number of design choices that could be revisited. For example, we considered treating let transparently and avoiding using explicitly labeled variable nodes. Another controversial choice was the use of copy-links rather than directly sharing value nodes. Are these differences important, and how can we determine this?</p><p>• How should updates be modeled? We conclude this section with some sheer speculation. Sensible provenance queries Consider all queries on provenance graphs expressible in, say, relational calculus or Datalog. Clearly, this includes many strange queries that test properties of the graph that seem irrelevant to provenance. For example, a query might select all value nodes that appear exactly three times in the graph, or all graphs that contain fewer than seventeen nodes, or all graphs such that function f is called an even number of times. Is there a natural characterization of "sensible" provenance queries?</p><p>Provenance query answerability Consider the following problem: given two provenance graph queries q 1 , q 2 , can we answer q 2 using the results of q 1 (without access to the original graph, expression or input data)? If so, it is reasonable to say that q 1 is more general than q 2 . This problem is an instance of the problem of answering queries using views, which has been studied for relational and XML databases. Can these results be applied or adapted to provenance queries?</p><p>Query rewriting and provenance query equivalence Many equivalent queries become inequivalent in the provenance graph semantics -for example, union is no longer commutative. Does this matter, or is it acceptable to optimize queries using ordinary equivalence rules? Under what conditions is this reasonable?</p><p>Efficient provenance querying Provenance graphs may be too large to construct or retain in practice. Given a provenance graph query q, can we compute the answer to q more efficiently and without materializing the full provenance graph? Can we compute provenance graphs "lazily" or for just a part of the result, in response to a query, rather than "eagerly" computing the whole graph?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>We have attempted to remain close to de facto standards for visualizing provenance as graphs, particularly the Open Provenance Model <ref type="bibr" target="#b21">[22]</ref>, which distinguishes between "process" (evaluation) and "artifact" (value) nodes. However, we have not included other aspects of OPM and have not tried to make our graphs fit OPM exactly. Collections are not modeled directly in OPM 1.0, although a proposal for describing the provenance of collections in OPM is under development <ref type="bibr" target="#b14">[15]</ref>. OPM is an exchange and representation format for provenance information and so some of the the semantic issues we investigate are outside its scope.</p><p>Semantics and models of provenance have been studied in formal detail for some systems. Sroka et al. <ref type="bibr" target="#b24">[25]</ref> develop a semantics for Taverna workflows based on a core language similar to NRC over lists, but including implicit coercions from elements to collections and also incorporating operations such as zip that are not expressible in plain NRC. Missier et al. <ref type="bibr" target="#b19">[20]</ref> discuss lightweight lineage annotations for Taverna workflows but does not fully detail how to the full language presented in <ref type="bibr" target="#b24">[25]</ref>.</p><p>Graphical notations for provenance have been used extensively in many systems. Recent work of interest in some of these systems includes work on consistency and optimization for user views (abstractions) of provenance graphs <ref type="bibr" target="#b25">[26]</ref> and efficiently representing and storing provenance graphs over nested collections <ref type="bibr" target="#b0">[1]</ref>. Again, however, these papers focus on structural aspects of provenance graphs as produced by some workflow system, whereas we are studying the relationship between a provenance graph and the computation performed by the system.</p><p>Our work is inspired partly by "provenance traces" <ref type="bibr" target="#b5">[6]</ref>, an approach to provenance for NRC in which evaluation of expressions yields both a value and a "trace", or detailed record of evaluation. Traces in that work are complete in the sense that they can be used to replay the computation under arbitrary changes to the input; our provenance graphs do not try to support replay under arbitrary changes, but may therefore be more compact. Moreover, our provenance graphs explicate the relationship between workflow and database provenance models, a question not addressed in <ref type="bibr" target="#b5">[6]</ref>.</p><p>Another closely related line of work is on the NRCbased dataflow language DFL, starting with Hidders et al. <ref type="bibr" target="#b16">[17]</ref>. Hidders et al. <ref type="bibr" target="#b15">[16]</ref> developed a run semantics for dataflow calculus programs along with a sketch of how to extract provenance from runs. Subsequently Kwasnikowska and van den Bussche <ref type="bibr" target="#b18">[19]</ref> showed how to represent the run semantics using OPM. This work also modeled nondeterministic service (external function) calls and modeled procedures using OPM accounts. These refinements have been left out in our presentation but can easily be handled. Our work improves on this approach by directly defining a provenance graph semantics that seems closer to typical workflow provenance, and avoiding some technical complications involved in the previous approach, particularly the use of paths to refer to parts of values and expressions indirectly. On the other hand, our pervasive use of freshly generated graph nodes introduces complications of its own, which we have addressed using the Haskell monadic programming style. We also discuss specific provenance queries defined using Datalog queries on the provenance graph, although we only have preliminary results and many open questions are evident.</p><p>Although the semantics we propose here may not be universally acceptable or usable off-the-shelf in these other settings, we believe the methods we outline are re-usable. In particular, the idea of using Haskell-style monads to define a precise semantics is very flexible, since monads can incorporate many other kinds of sideeffects besides fresh node identifier generation. It may be worthwhile to model the provenance semantics of more realistic workflow languages in Haskell, facilitating di-rect comparisons of the behavior and provenance of different workflow languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>Although provenance has been studied in both database and workflow settings for more than a decade, little has been done to relate the approaches. In this paper we make two contributions in this direction, in the context of the previously-introduced dataflow calculus DFL. First, we detail a semantics that evaluates dataflow calculus expressions to provenance graphs containing values, evaluation nodes, and links showing how the expression evaluated, and we discuss interesting kinds of queries on the resulting structure, related to where-provenance and why-provenance in databases. Second, we present a concise and precise formal version of this model implemented using Haskell, a high-level functional language.</p><p>We believe our work helps bridge a gap between the theoretical approaches that so far have largely been employed for database provenance and the practical, but sometimes loosely-specified techniques developed in workflow systems. We also identified a number of interesting research questions concerning where-and whyprovenance queries over the provenance graph and their relationships to these forms of provenance in databases. We are investigating these in ongoing work. Although there is still room for debate about the particular design choices made in our approach, our formal model at least makes it easier to hold such a debate, and to experiment with alternatives.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>We restrict our attention in what follows to legal value graphs that can be constructed using the following rules:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>A</head><label></label><figDesc>provenance graph G = (V, E, val ) is a directed acyclic graph with nodes and edges labeled with either</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Examples (a) SELECT a+b FROM R WHERE a=b, where R = {(1, 2), (1, 1)} and (b) R MINUS S where {R = {1, 2} and S = {1}. Ovals are value nodes; boxes are evaluation nodes; gray edges are value-graph edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Finally, here is a larger example demonstrating let-binding, showing the evaluation of an expression let x = 3 in let y = 4 in x * x + y * y.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 1 (</head><label>1</label><figDesc>Figure 1(a) and (b) are two larger examples, corresponding to simple SQL queries. Given a provenance graph G and an evaluation node e, there is a natural notion of (G, e) being locally consistent, with the intuition that the computation depicted in the part of the evaluation graph reachable from e matches the assignment of value nodes to evaluation nodes by the val-edges. The graphs used as examples so far are all consistent in this sense; however, the following graphs are inconsistent:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Graph rewriting rules for constructing provenance graphs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Figures 4, 6 and 7 show how to evaluate an expres- sion in a provenance graph, producing a value node in an augmented provenance graph. The helper functions − † and − * shown in Figure 5 help simplify the def- inition. First, e † simply evaluates an expression e to its value node and also returns the node's constructor.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Figure 8: Haskell code defining provenance graphs. The type Map a b consists of finite maps from type a to b, from the Haskell standard library.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Graph monad operations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Helper functions e † and e * x∈vs .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Monadic semantics for building provenance graphs, part 3 (collections)</figDesc></figure>

			<note place="foot" n="1"> http://www.graphviz.org</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Efficient provenance storage over nested data collections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anand</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Bowers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mcphillips</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And Lud¨ascherlud¨ Lud¨ascher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="958" to="969" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">On the expressiveness of implicit provenance in query and update languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Buneman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vansummeren</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page">28</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Why and where: A characterization of data provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Buneman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1973" />
			<biblScope unit="page" from="316" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On propagation of deletions and annotations through views</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Buneman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="150" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Principles of programming with complex objects and collection types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Buneman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Naqvi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">A</forename><surname>Tannen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wong</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comp. Sci</title>
		<imprint>
			<biblScope unit="volume">149</biblScope>
			<biblScope unit="page" from="3" to="48" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cheney</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Acar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><forename type="middle">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmed</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
		<idno>abs/0812.0564</idno>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
<note type="report_type">Provenance traces. CoRR</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Provenance as dependency analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cheney</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Acar</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><forename type="middle">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DBPL 2007</title>
		<editor>M. I. Schwartzbach</editor>
		<meeting><address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="page" from="139" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Provenance in databases: Why, how, and where</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cheney</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations and Trends in Databases</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="379" to="474" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Tracing the lineage of view data in a warehousing environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cui</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Widom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wiener</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="179" to="227" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Chimera: A virtual data system for representing, querying, and automating data derivation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Foster</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Vockler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilde</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhao</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SSDBM</title>
		<imprint>
			<date type="published" when="2002-07" />
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Annotated XML: queries and provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Foster</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">N</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tannen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="271" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Freire</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Koop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moreau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">5272</biblScope>
			<date type="published" when="2008" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Provenance semirings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tannen</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A protocol for recording provenance in service-oriented grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Groth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Luck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moreau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OPODIS &apos;04</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">A proposal for handling collections in the open provenance model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Groth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Miles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Missier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moreau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A formal model of dataflow repositories</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hidders</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kwasnikowska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Sroka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tyszkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">And</forename><surname>Van Den</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DILS</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="volume">4544</biblScope>
			<biblScope unit="page" from="105" to="121" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">DFL: A dataflow language based on petri nets and nested relational calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hidders</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kwasnikowska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Sroka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tyszkiewicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">And</forename><surname>Van Den</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bussche</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="261" to="284" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Programming in Haskell</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hutton</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Mapping the NRC dataflow model to the open provenance model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kwasnikowska</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">And</forename><surname>Van Den</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bussche</surname></persName>
		</author>
		<editor>Freire et al.</editor>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="3" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Data lineage model for taverna workflows with lightweight annotation requirements</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Missier</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Belhajjame</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Roos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Goble</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A</forename></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="17" to="30" />
		</imprint>
	</monogr>
	<note>In Freire et al. [12</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Notions of computation and monads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moggi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Comput</title>
		<imprint>
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="page" from="55" to="92" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">The open provenance model: An overview</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moreau</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Futrelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mcgrath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paulson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="323" to="326" />
		</imprint>
	</monogr>
	<note>In Freire et al. [12</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Provenance-aware storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muniswamy-Reddy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-K</forename><surname>Holland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seltzer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ATC</title>
		<imprint>
			<date type="published" when="2006-06" />
			<biblScope unit="page" from="43" to="56" />
		</imprint>
	</monogr>
	<note>USENIX</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Provenance management for data-driven workflows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simmhan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">L</forename><surname>Plale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gannon</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Karma2</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Web Service Res</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1" to="22" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A formal semantics for the taverna 2 workflow model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sroka</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hidders</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Missier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Goble</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences In Press, Corrected Proof</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Detecting and resolving unsound workflow views for correct provenance analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sun</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">B</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="549" to="562" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
