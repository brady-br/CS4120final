<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:05+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Bypassing Races in Live Applications with Execution Filters</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jingyue</forename><surname>Wu</surname></persName>
							<email>jingyue@cs.columbia.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Columbia University New York</orgName>
								<address>
									<postCode>10027</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heming</forename><surname>Cui</surname></persName>
							<email>heming@cs.columbia.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Columbia University New York</orgName>
								<address>
									<postCode>10027</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junfeng</forename><surname>Yang</surname></persName>
							<email>junfeng@cs.columbia.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Columbia University New York</orgName>
								<address>
									<postCode>10027</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Bypassing Races in Live Applications with Execution Filters</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Deployed multithreaded applications contain many races because these applications are difficult to write, test, and debug. Worse, the number of races in deployed applications may drastically increase due to the rise of multicore hardware and the immaturity of current race detectors. LOOM is a &quot;live-workaround&quot; system designed to quickly and safely bypass application races at runtime. LOOM provides a flexible and safe language for developers to write execution filters that explicitly synchronize code. It then uses an evacuation algorithm to safely install the filters to live applications to avoid races. It reduces its performance overhead using hybrid instrumen-tation that combines static and dynamic instrumentation. We evaluated LOOM on nine real races from a diverse set of six applications, including MySQL and Apache. Our results show that (1) LOOM can safely fix all evaluated races in a timely manner, thereby increasing application availability; (2) LOOM incurs little performance overhead; (3) LOOM scales well with the number of application threads; and (4) LOOM is easy to use.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Deployed multithreaded applications contain many races because these applications are difficult to write, test, and debug. These races include data races, atomicity violations, and order violations <ref type="bibr" target="#b30">[33]</ref>. They can cause application crashes and data corruptions. Worse, the number of "deployed races" may drastically increase due to the rise of multicore and the immaturity of race detectors.</p><p>Many previous systems can aid race detection (e.g., <ref type="bibr" target="#b28">[31,</ref><ref type="bibr" target="#b29">32,</ref><ref type="bibr" target="#b34">37,</ref><ref type="bibr" target="#b44">47,</ref><ref type="bibr" target="#b51">54]</ref>), replay <ref type="bibr" target="#b6">[9,</ref><ref type="bibr" target="#b15">18,</ref><ref type="bibr" target="#b25">28,</ref><ref type="bibr" target="#b33">36,</ref><ref type="bibr" target="#b40">43]</ref>, and diagnosis <ref type="bibr" target="#b39">[42,</ref><ref type="bibr" target="#b46">49]</ref>. However, they do not directly address deployed races. A conventional solution to fixing deployed races is software update, but this method requires application restarts, and is at odds with high availability demand. Live update systems <ref type="bibr" target="#b7">[10,</ref><ref type="bibr" target="#b9">12,</ref><ref type="bibr" target="#b12">15,</ref><ref type="bibr" target="#b32">35,</ref><ref type="bibr" target="#b35">38,</ref><ref type="bibr" target="#b36">39,</ref><ref type="bibr" target="#b48">51]</ref> can avoid restarts by adapting conventional patches into hot patches and applying them to live systems, but the reliance on conventional patches has two problems.</p><p>First, due to the complexity of multithreaded applications, race-fix patches can be unsafe and introduce new errors <ref type="bibr" target="#b30">[33]</ref>. Safety is crucial to encourage user adoption, yet automatically ensuring safety is difficult because conventional patches are created from general, difficult-toanalyze languages. Thus, previous work <ref type="bibr" target="#b35">[38,</ref><ref type="bibr" target="#b36">39]</ref> had to resort to extensive programmer annotations.</p><p>Second, creating a releasable patch from a correct diagnosis can still take time. This delay leaves buggy applications unprotected, compromising reliability and potentially security. This delay can be quite large: we analyzed the Bugzilla records of nine real races and found that this delay can be days, months, or even years. Table 1 shows the detailed results.</p><p>Many factors contribute to this delay. At a minimum level, a conventional patch has to go through code review, testing, and other mandatory software development steps before being released, and these steps are all time-consuming. Moreover, though a race may be fixed in many ways (e.g., lock-free flags, fine-grained locks, and coarse-grained locks), developers are often forced to strive for an efficient option. For instance, two of the bugs we analyzed caused long discussions of more than <ref type="bibr" target="#b27">30</ref> messages, yet both can be fixed by adding a single critical section. Performance pressure is perhaps why many races were not fixed by adding locks <ref type="bibr" target="#b30">[33]</ref>. This paper presents LOOM, a "live-workaround" system designed to quickly protect applications against races until correct conventional patches are available and the applications can be restarted. It reflects our belief that the true power of live update is its ability to provide immediate workarounds. To use LOOM, developers first compile their application with LOOM. At runtime, to workaround a race, an application developer writes an execution filter that synchronizes the application source to filter out racy thread interleavings. This filter is kept separate from the source. Application users can then download the filter and, for immediate protection, install  <ref type="table">Table 1</ref>: Long delays in race fixing. We studied the delays in the fix process of nine real races; some of the races were extensively studied <ref type="bibr" target="#b6">[9,</ref><ref type="bibr" target="#b28">31,</ref><ref type="bibr" target="#b30">33,</ref><ref type="bibr" target="#b39">42,</ref><ref type="bibr" target="#b40">43]</ref>. We identify each race by "Application − Bugzilla #." Column Report indicates when the race was reported, Diagnosis when a developer confirmed the root cause of the race, Fix when the final fix was posted, and Release when the version of application containing the fix was publicly released. We collected all dates by examining the Bugzilla record of each race. An N/A means that we could not derive the date. The days between diagnosis and fix range from a few days to a month to a few years. For all but two races, the bug reports from the application users contained correct and precise diagnoses. Mozilla-201134 and Mozilla-133773 caused long discussions of more than 30 messages, though both can be fixed by adding a critical region.</p><p>it to their application without a restart. LOOM decouples execution filters from application source to achieve safety and flexibility. Execution filters are safe because LOOM's execution filter language allows only well formed synchronization constraints. For instance, "code region r 1 and r 2 are mutually exclusive." This declarative language is simpler to analyze than a general programing language such as C because LOOM need not reverse-engineer developer intents (e.g., what goes into a critical region) from scattered operations (e.g., lock() and unlock()).</p><p>As temporary workarounds, execution filters are more flexible than conventional patches. One main benefit is that developers can make better performance and reliability tradeoffs during race fixing. For instance, to make two code regions r 1 and r 2 mutually exclusive when they access the same memory object, developers can use critical regions larger than necessary; they can make r 1 and r 2 always mutually exclusive even when accessing different objects; or in extreme cases, they can run r 1 and r 2 in single-threaded mode. This flexibility enables quick workarounds; it can benefit even the applications that do not need live update.</p><p>We believe the execution filter idea and the LOOM system as described are worthwhile contributions. To the best of our knowledge, LOOM is the first liveworkaround system designed for races. Our additional technical contributions include the techniques we created to address the following two challenges.</p><p>A key safety challenge LOOM faces is that even if an execution filter is safe by construction, installing it to a live application can still introduce errors because the application state may be inconsistent with the filter. For instance, if a thread is running inside a code region that an execution filter is trying to protect, a "doubleunlock" error could occur. Thus, LOOM must (1) check for inconsistent states and (2) install the filter only in consistent ones. Moreover, LOOM must make the two steps atomic, despite the concurrently running application threads and multiple points of updates. This problem cannot be solved by a common safety heuristic called function quiescence <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b10">13,</ref><ref type="bibr" target="#b18">21,</ref><ref type="bibr" target="#b36">39]</ref>. We thus create a new algorithm termed evacuation to solve this problem by proactively quiescing an arbitrary set of code regions given at runtime. We believe this algorithm can also benefit other live update systems.</p><p>A key performance challenge LOOM faces is to maintain negligible performance overhead during an application's normal operations to encourage adoption. The main runtime overhead comes from the engine used to live-update an application binary. Although LOOM can use general-purpose binary instrumentation tools such as Pin, the overhead of these tools (up to 199% <ref type="bibr" target="#b31">[34]</ref> and 1065.39% in our experiments) makes them less suitable as options for LOOM. We thus create a hybrid instrumentation engine to reduce overhead. It statically transforms an application to include a "hot backup", which can then be updated arbitrarily by execution filters at runtime.</p><p>We implemented LOOM on Linux. It runs in user space and requires no modifications to the applications or the OS, simplifying deployment. It does not rely on non-portable OS features (e.g., SIGSTOP to pause applications, which is not supported properly on Windows). LOOM's static transformation is a plugin to the LLVM compiler <ref type="bibr" target="#b2">[3]</ref>, requiring no changes to the compiler either.</p><p>We evaluated LOOM on nine real races from a diverse set of six applications: two server applications, MySQL and Apache; one desktop application PBZip2 (a parallel compression tool); and implementations of three scientific algorithms in SPLASH2 <ref type="bibr" target="#b4">[7]</ref>. Our results show that 1. LOOM is effective. It can flexibly and safely fix all races we have studied. It does not degrade application availability when installing execution filters. Its evacuation algorithm can install a fix within a second even under heavy workload, whereas a live update approach using function quiescence cannot install the fix in an hour, the time limit of our experiment. 2. LOOM is fast. LOOM has negligible performance overhead and in some cases even speeds up the applications. The one exception is MySQL. Running MySQL with LOOM alone increases response time by 4.11% and degrades throughput by 3.76%. 3. LOOM is scalable. Experiments on a 48-core ma- chine show that LOOM scales well as the number of application threads increases. 4. LOOM is easy to use. Execution filters are concise, safe, and flexible (able to fix all races studied, often in more than one way). This paper is organized as follows. We first give an overview of LOOM ( §2). We then describe LOOM's execution filter language ( §3), the evacuation algorithm ( §4), and the hybrid instrumentation engine ( §5). We then present our experimental results ( §6). We finally discuss related work ( §7) and conclude ( §8).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Overview</head><p>Figure 1 presents an overview of LOOM. To use LOOM for live update, developers first statically transform their applications with LOOM's compiler plugin. This plugin injects a copy of LOOM's update engine into the application binary; it also collects the application's control flow graphs (CFG) and symbol information on behalf of the live update engine.</p><p>LOOM's compiler plugin runs within the LLVM compiler <ref type="bibr" target="#b2">[3]</ref>. We choose LLVM for its compatibility with GCC and its easy-to-analyze intermediate representation (IR). However, LOOM's algorithms are general and can be ported to other compilers such as GCC. Indeed, for clarity we will present all our algorithms at the source level (instead of the LLVM IR level).</p><p>To fix a race, application developers write an execution filter in LOOM's filter language and distribute the filter to application users. A user can then install the filter to immediately protect their application by running % loomctl add &lt;pid&gt; &lt;filter-file&gt;</p><p>Here loomctl is a user-space program called the LOOM controller that interacts with users and initiates live update sessions, pid denotes the process ID of a buggy application instance, and filter-file is a file containing the execution filter. Under the hood, this controller compiles the execution filter down to a safe update plan using the CFGs and symbol information collected by the compiler plugin. This update plan includes three parts: (1) synchronization operations to enforce the constraints described in the filter and where, in the application, to add the operations; (2) safety preconditions that must hold for installing the filter; and (3) sanity checking code to detect potential errors in the filter itself. The controller sends the update plan to the update engine running as a thread inside the application's address space, which then monitors the runtime states of the application and carries out the update plan only when all the safety preconditions are satisfied.</p><p>If LOOM detects a problem with a filter through one of its sanity checks, it can automatically remove the problematic filter. It again waits for all the safety preconditions to hold before removing the filter.</p><p>Users can also remove a filter manually, if for example, the race that the filter intends to fix turns out to be benign. They do so by running % loomctl ls &lt;pid&gt; % loomctl remove &lt;pid&gt; &lt;filter-id&gt;</p><p>The first command "loomctl ls" returns a list of installed filter IDs within process pid. The second command "loomctl remove" removes filter filter-id from process pid.</p><p>Users can replace an installed filter with a new filter, if for example the new filter fixes the same race but has less performance overhead. Users do so by running % loomctl replace &lt;pid&gt; &lt;old-id&gt; &lt;new-file&gt; where old-id is the ID of the installed filter, and new-file is a file containing the new filter. LOOM ensures that the removal of the old filter and the installation of the new filter are atomic, so that the application is always protected from the given race.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Usage Scenarios</head><p>LOOM enables users to explicitly describe their synchronization intents and orchestrate thread interleavings of live applications accordingly. Using this mechanism, we envision a variety of strategies users can use to fix races. Live update At the most basic level, users can translate some conventional patches into execution filters, and use LOOM to install them to live applications. Temporary workaround Before a permanent fix (i.e., a correct source patch) is out, users can create an execution filter as a crude, temporary fix to a race, to provide immediate protection to highly critical applications. Preventive fix When a potential race is reported (e.g., by automated race detection tools or users of the application), users can immediately install a filter to prevent the race suspect. Later, when developers deem this report false or benign, users can simply remove the filter.</p><p>Cooperative fix Users can share filters with each other. This strategy enjoys the same benefits as other cooperative protection schemes <ref type="bibr" target="#b14">[17,</ref><ref type="bibr" target="#b23">26,</ref><ref type="bibr" target="#b41">44,</ref><ref type="bibr" target="#b47">50]</ref>. One advantage of LOOM over some of these systems is that it automatically verifies filter safety, thus potentially reducing the need to trust other users. Site-specific fix Different sites have different workloads. An execution filter too expensive for one site may be fine for another. The flexibility of execution filters allows each site to choose what specific filters to install. Fix without live update For applications that do not need live update, users can still use LOOM to create quick workarounds, improving reliability.</p><p>Besides fixing races, LOOM can be used for the opposite: demonstrating a race by forcing a racy thread interleaving. Compared to previous race diagnosis tools that handle a fixed set of race patterns <ref type="bibr" target="#b22">[25,</ref><ref type="bibr" target="#b38">41,</ref><ref type="bibr" target="#b39">42,</ref><ref type="bibr" target="#b46">49]</ref>, LOOM's advantage is to allow developers to construct potentially complex "concurrency" testcases.</p><p>Although LOOM can also avoid deadlocks by avoiding deadlock-inducing thread interleavings, it is less suitable for this purpose than existing tools (e.g., Dimmunix <ref type="bibr" target="#b23">[26]</ref>). To avoid races, LOOM's update engine can add synchronizations to arbitrary program locations. This engine is overkill for avoiding deadlocks: intercepting lock operations (e.g., via LD PRELOAD) is often enough.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Limitations</head><p>LOOM is explicitly designed to work around (broadly defined) races because they are some of the most difficult bugs to fix and this focus simplifies LOOM's execution filter language and safety analysis. LOOM is not intended for other classes of errors. Nonetheless, we believe the idea of high-level and easy-to-verify fixes can be generalized to many other classes of errors.</p><p>LOOM does not attempt to fix occurred races. That is, if a race has caused bad effects (e.g., corrupted data), LOOM does not attempt to reverse the effects (e.g., recover the data). It is conceivable to allow developers to provide a general function that LOOM runs to recover occurred races before installing a filter. Although this feature is simple to implement, it makes safety analysis infeasible. We thus rejected this feature.</p><p>Safety in LOOM terms means that an execution filter and its installation/removal processes introduce no new correctness errors to the application. However, similar to other safe error recovery <ref type="bibr" target="#b43">[46]</ref> or avoidance <ref type="bibr" target="#b23">[26,</ref><ref type="bibr" target="#b49">52]</ref> tools, LOOM runs with the application and perturbs timing, thus it may expose some existing application races because it makes some thread interleavings more likely to occur. Moreover, execution filters synchronize code, and may introduce deadlocks and performance problems. LOOM can recover from filter-introduced deadlocks ( §3.3) using timeouts, but currently does not deal with performance problems.</p><p>At an implementation level, LOOM currently supports a fixed set of synchronization constraint types. Although adding new types of constraints is easy, we have found the existing constraint types sufficient to fix all races evaluated. Another issue is that LOOM uses debugging symbol information in its analysis, which can be inaccurate due to compiler optimization. This inaccuracy has not been a problem for the races in our evaluation because LOOM keeps an unoptimized version of each basic block for live update ( §5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Execution Filter Language</head><p>LOOM's execution filter language allows developers to explicitly declare their synchronization intents on code. This declarative approach has several benefits. First, it frees developers from the low-level details of synchronization, increasing race fixing productivity. Second, it also simplifies LOOM's safety analysis because LOOM does not have to reverse-engineer developer intents (e.g., what goes into a critical section) from lowlevel synchronization operations (e.g., scattered lock() and unlock()), which can be difficult and error-prone. Lastly, LOOM can easily insert error-checking code for safety when it compiles a filter down to low-level synchronization operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Example Races and Execution Filters</head><p>In this section, we present two real races and the execution filters to fix them to demonstrate LOOM's execution filter language and its flexibility.</p><p>The first race is in MySQL (Bugzilla # 791), which causes the MySQL on-disk transaction log to miss records. <ref type="figure">Figure 2</ref> shows the race. The code on the left (function new file()) rotates MySQL's transaction log file by closing the current log file and opening a new one; it is called when the transaction log has to be flushed. The code on the right is used by MySQL to append a record to the transaction log. It uses doublechecked locking and writes to the log only when the log is open. The race occurs if the racy is open() (T2, line 3) catches a closed log when thread T1 is between the close() (T1, line 5) and the open() (T1, line 6).</p><p>Although a straightforward fix to the race exists, performance demands likely forced developers to give up the fix and choose a more complex one instead. The straightforward fix should just remove the racy check (T2, line 3). Unfortunately, this fix creates unnecessary overhead if MySQL is configured to skip logging for speed; this overhead can increase MySQL's response time by more than 10% as observed in our experiments. The concern to this overhead likely forced MySQL developers to use a more involved fix, which adds a new flag field to MySQL's transaction log and modifies the 1: // log.cc. thread T1 2: void MYSQL LOG::new file(){ 3:</p><p>lock(&amp;LOCK log); 4:</p><p>. . .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5:</head><p>close(); // log is closed 6:</p><p>open(. . .); 7:</p><p>. . . 8:</p><p>unlock(&amp;LOCK log);</p><formula xml:id="formula_0">9: } 1: // sql insert.cc. thread T2 2: // [race] may return false 3: if (mysql bin log.is open()){ 4:</formula><p>lock(&amp;LOCK log); 5:</p><p>if (mysql bin log.is open()){ 6:</p><p>. . . // write to log 7:</p><formula xml:id="formula_1">} 8:</formula><p>unlock(&amp;LOCK log); 9: } close() function to distinguish a regular close() call and one for reopening the log.</p><p>In contrast, LOOM allows developers to create temporary workarounds with flexible performance and reliability tradeoffs. These temporary fixes can protect the application until developers create a correct and efficient fix at the source level. <ref type="figure">Figure 3</ref> shows several execution filters that can fix this race. Execution filter 1 in the figure is the most conservative fix: it makes the code region between T1, line 5 and T1, line 6 atomic against all code regions, so that when a thread executes this region, all other threads must pause. We call such a synchronization constraint unilateral exclusion in contrast to mutual exclusion that requires participating threads agree on the same lock. <ref type="bibr" target="#b0">1</ref> Here operator "&lt;&gt;" expresses mutual exclusion constraints, its first operand "{log.cc:5, log.cc:6}" specifies a code region to protect, and its second operand " * " represents all code regions. This "expensive" fix incurs only 0.48% overhead ( §6.1) because the log rotation code rarely executes.</p><p>Execution filter 2 reduces overhead by refining the " * " operand to a specific code region, function MYSQL LOG::is open(). This filter makes the two code regions mutually exclusive, regardless of what memory locations they access. Execution filter 3 further improves performance by specifying the memory location accessed by each code region.</p><p>The second race causes PBZip2 to crash due to a useafter-free error. <ref type="figure">Figure 4</ref> shows the race. The crash occurs when fifo is dereferenced (line 10) after it is freed (line 5). The reason is that the main() thread does not wait for the decompress() threads to finish. To fix this race, developers can use the filter in <ref type="figure" target="#fig_2">Figure 5</ref>, which constrains line 10 to run for numCPU times before line 5.</p><formula xml:id="formula_2">// pbzip2.cpp. thread T1 1: main() { 2:</formula><p>for(i=0;i&lt;numCPU;i++) 3:</p><p>pthread create(. . ., 4:</p><p>decompress, fifo); 5:</p><p>queueDelete(fifo); 6: } // pbzip2.cpp. thread T2 7 : void *decompress(void *q){ 8 :</p><p>queue *fifo = (queue *)q; 9 :</p><p>. . . 10: pthread mutex lock(fifo−&gt;mut); 11: . . . 12: } <ref type="figure">Figure 4</ref>: A real PBZip2 race, simplified for clarity.  <ref type="table" target="#tab_1">Table 2</ref> summarizes the main syntax and semantics of LOOM's execution filter language. This language allows developers to express synchronization constraints on events and regions. An event in the simplest form is "f ile : line," which represents a dynamic instance of a static program statement, identified by file name and line number. An event can have an additional "(expr)" component and an "{n}" component, where expr and n refer to valid expressions with no function calls or dereferences. The expr expression distinguishes different dynamic instances of program statements and LOOM synchronizes the events only with matching expr values. The n expression specifies the number of occurrences of an event and is used in execution order constraints. A region represents a dynamic instance of a static code region, identified by a set of entry and exist events or an application function. A region representing a function call can have an additional "(args)" component to distinguish different calls to the same function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Syntax and Semantics</head><p>LOOM currently supports three types of synchronization constraints (the bottom three rows in <ref type="table" target="#tab_1">Table 2</ref>). Although adding new constraint types is easy, we have found existing ones enough to fix all races evaluated. An execution order constraint as shown in the table makes event e 1 happen before e 2 , e 2 before e 3 , and so forth. A mutual exclusion constraint as shown makes every pair of code regions r i and r j mutually exclusive with each other. A unilateral exclusion constraint conceptually makes the execution of a code region single-threaded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Language Implementation</head><p>LOOM implements the execution filter language using locks and semaphores. Given an execution order constraint e i &gt; e i+1 , LOOM inserts a semaphore up() operation at e i and a down() operation at e i+1 . LOOM implements a mutual exclusion constraint by inserting lock() at region entries and unlock() at region exits. LOOM implements a unilateral exclusion constraint reusing the evacuation mechanism ( §4), which can pause threads at safe locations and resume them later.  The up() and down() operations LOOM inserts behave slightly differently than standard semaphore operations when n, the number of occurrences, is specified. Given e1{n 1 } &gt; e2{n 2 }, up() conceptually increases the semaphore counter by 1 n1 and down() decreases it by 1 n2 . Our implementation uses integers instead of floats. LOOM stores the value of n the first time the corresponding event runs and ignores future changes of n.</p><p>LOOM computes the values of expr and n using debugging symbol information. We currently allow expr and n to be the following expressions: a (constant or primitive variable), a+b, &amp;a, &amp;a <ref type="bibr">[i]</ref>, &amp;a-&gt;f, or any recursive combinations of these expressions. For safety, we do not allow function calls or dereferences. These expressions are sufficient for writing the execution filters in our evaluation.</p><p>We implemented this feature using the DWARF library and the parse exp 1() function in GDB. Specifically, we use parse exp 1() to parse the expr or n component into an expression tree, then compile this tree into low level instructions by querying the DWARF library. Note this compilation step is done inside the LOOM controller, so that the live update engine does not have to pay this overhead.</p><p>LOOM implements three mechanisms for safety. First, by keying synchronization objects based on filter and constraint IDs, it uses a disjoint set of synchronization objects for different execution filters and constraints, avoiding interference among them. Second, LOOM inserts additional checking code when it generates the up-5 6 date plan. For example, given a code region c in a mutual exclusion constraint, LOOM checks for errors such as c's unlock() releasing a lock not acquired by c's lock(). Lastly, LOOM checks for filter-induced deadlocks to guard against buggy filters. If a buggy filter introduces a deadlock, one of its synchronization operations must be involved in the wait cycle. LOOM detects such deadlocks using timeouts, and automatically removes the offending filter. <ref type="figure" target="#fig_4">Figure 6</ref> shows three unsafe scenarios LOOM must handle. For a mutual exclusion constraint that turns code regions into critical sections, LOOM must ensure that no thread is executing within the code regions when installing the filter to avoid "double-unlock" errors. Similarly, for an execution order constraint e 1 &gt; e 2 , LOOM must ensure either of the following two conditions when installing the filter: (1) both e 1 and e 2 have occurred or (2) neither has occurred; otherwise the up() LOOM inserts at e 1 may get skipped or wake up a wrong thread. Note that a na¨ıvena¨ıve approach is to simply ignore an unlock() if the corresponding lock is already unlocked, but this approach does not work with execution order constraints. Moreover, it mixes unsafe program states with buggy filters, and may reject correct filters simply because it tries to install the filters at unsafe program states.</p><formula xml:id="formula_3">7 8 9 @ A B 9 C A 8 D E F G H E I G G B P Q R S T U V W R S T U X Y R ` V a b E B 9 G c d 8 C e f g d B b P U X Y R `</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Avoiding Unsafe Application States</head><p>A common safety heuristic called function quiescence <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b10">13,</ref><ref type="bibr" target="#b18">21,</ref><ref type="bibr" target="#b36">39]</ref>   <ref type="figure">Figure 7</ref>: A contrived race.</p><p>close table(). The race in <ref type="figure">Figure 7</ref> occurs when multiple clients concurrently access the same table.</p><p>To fix this race, an execution filter can add a lock acquisition at line 13 in open table() and a lock release at line 18 in close table(). To safely install this filter, however, the quiescence of open table() and close table() is not enough, because a thread may still be running at line 8 and cause a double-unlock error. An alternative fix is to add the lock acquisition and release in function handle client(), but this function hardly quiesces because of the busy loop (line 3-10) and the blocking call recv().</p><p>LOOM solves the unsafe state program using an algorithm termed evacuation that can proactively quiesce arbitrary code regions. From a high level, this algorithm takes a filter and computes a set of unsafe program locations that may interfere with the filter. It does so conservatively to avoid marking an unsafe location as safe. Then, it "evacuates" threads out of the unsafe locations and blocks them at safe program location. After that, it installs the filter and resumes the threads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Computing Unsafe Program Locations</head><p>LOOM uses slightly different methods to compute the unsafe program locations for mutual exclusion and for execution order constraints. To compute unsafe program locations for mutual exclusion constraints, LOOM performs a static reachability analysis on the interprocedural control flow graph (ICFG) of an application. An ICFG connects each function's control flow graphs by following function calls and returns. <ref type="figure" target="#fig_7">Figure 8a</ref> shows the ICFG for the code in <ref type="figure">Figure 7</ref>. We say statement s 1 reaches s 2 or reachable(s 1 , s 2 ) if there is a path from s 1 to s 2 on the ICFG. For example, the statement at line 13 reaches the statement at line 8 in <ref type="figure">Figure 7</ref>.</p><p>Given an execution filter f with mutual exclusion constraint r 1 &lt;&gt; r 2 &lt;&gt; ... &lt;&gt; r n , LOOM in- cludes any statement s potentially inside one of the regions in unsaf e(f ), the set of unsafe program locations for filter f . Specifically, unsaf e(f ) is the set of statements s such that {reachable(r i .entries, s) ∧ reachable(s, r i .exits)} for i ∈ <ref type="bibr">[1, n]</ref>, where r i .entries are the entry statements to region r i and r i .exits are the exit statements. LOOM computes unsafe program locations for an execution order constraint by first deriving code regions from the constraint, then reusing the method for mutual exclusion to compute unsafe program locations. Specifically, given e 1 &gt; e 2 &gt; ... &gt; e n , LOOM first computes a dominator statement s d such that s d dominates all e i (i.e., s d is on every path from the program start to e i ); it then computes unsaf e(f ) as the set of statements inside each {s d ; e i } region.</p><p>Since e i may be in different threads, LOOM augments the ICFG of an application into thread interprocedural control flow graph (TICFG) by adding edges for thread creation and thread join statements. Currently our analysis constructs the TICFG by treating each pthread create(func) statement as a function call to func(): it adds an edge from the statement to the entry of func() and a thread join edge from the exit of func() to the statement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Controlling Application Threads</head><p>LOOM needs to control application threads to pause and resume them. It does so using a read-write lock called the update lock. To live update an application, LOOM grabs this lock in write mode, performs the update, and releases this lock. To control application threads, LOOM's compiler plugin instruments the application so that the application threads hold this lock in read mode in normal operation and check for an update once in a while by releasing and re-grabbing this lock.</p><p>LOOM carefully places update-checks inside an application to reduce the overhead and ensure a timely update. <ref type="figure" target="#fig_7">Figure 8b</ref> shows the placement of these update-checks. LOOM needs no update-checks inside straight-line code with no blocking calls because such code can complete  quickly. LOOM places one update-check for each cycle in the control flow graph, including loops and recursive function call chains, so that an application thread cycling in one of these cycles can check for an update at least once each iteration. Currently LOOM instruments the backedge of a loop and an arbitrary function entry in a recursive function cycle. LOOM does not instrument every function entry because doing so is costly. LOOM also instruments an application to release the update lock before a blocking call and re-grab it after the call, so that an application thread blocking on the call does not delay an update. For the example in <ref type="figure">Figure 7</ref>, LOOM can perform the update despite some threads blocking in recv(). LOOM instruments only the "leaf-level" blocking calls. That is, if foo() calls bar() and bar() is blocking, LOOM instruments the calls to bar(), but not the calls to foo(). Currently LOOM conservatively considers calls to external functions (i.e., functions without source), except Math library functions, as blocking to save user annotation effort.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Pausing at Safe Program Locations</head><p>Besides the update lock, LOOM uses additional synchronization variables to ensure that application threads pause at safe locations. LOOM assigns a wait flag for each backedge of a loop and the chosen function entry of a recursive call cycle. To enable/disable pausing at a safe/unsafe location, LOOM sets/clears the corresponding flag. The instrumentation code for each CFG cycle (left of <ref type="figure" target="#fig_0">Figure 10</ref>) checks for an update only when the corresponding wait flag is set. These wait flags allow application threads at unsafe program locations to run until they reach safe program locations, effectively evacuating the unsafe program locations. Note that the statement "if(wait[stmt id])" in <ref type="figure" target="#fig_0">Figure 10</ref> greatly improves LOOM's performance. With this statement, application threads need not always release and re-grab the update lock which can be costly, and hardware cache and branch prediction can effectively hide the overhead of checking these flags. This technique speeds up LOOM significantly ( §6) because wait flags are almost always 0 with read accesses.</p><p>LOOM cannot use the wait-flag technique to skip a blocking function call because doing so changes the application semantics. Instead, LOOM assigns a counter to each blocking callsite to track how many threads are at the callsites (right of <ref type="figure" target="#fig_0">Figure 10</ref>). LOOM uses a counter instead of a binary flag because multiple threads may be doing the same call. Now that LOOM's instrumentation is in place, wake up and advance to safe locations. Next, it updates the application ( §5), clears the wait flags, and releases the update lock.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Correctness Discussion</head><p>We briefly discuss the correctness of our evacuation algorithm in this subsection; for a complete proof, please refer to our technical report <ref type="bibr" target="#b50">[53]</ref>.</p><p>In program analysis terms, our reachability analysis ( §4.1) is interprocedural and flow-sensitive. We use a crude pointer analysis to discover thread functions, thread join sites, and function pointer targets. We could have refined our analysis to improve precision, but we find it sufficient to compute unsafe locations for all evaluated races because (1) our analysis is sound and never marks an unsafe location safe and (2) execution filters are quite small and slight imprecision does not matter. In the worst case, if our analysis turns out too imprecise for some filters, the flexibility of LOOM allows developers to easily adjust their filters to pass the safety analysis.</p><p>Server programs frequently use thread pools, creating problems for our reachability analysis. Specifically, these servers tend to create a fixed set of threads during initialization, then reuse them for independent requests. If we compute dominators using the creation sites of these threads, we would find that dominators only run during server initialization. Fortunately, we can annotate the reuse of a thread as a special thread creation site, so that our algorithm computes correct dominators. In our experiments, we did not (and need not) annotate any thread reuse.</p><p>Our reachability analysis gives correct results despite compiler reordering. In order to pause application threads at safe locations, our reachability analysis returns only the set of unsafe backedges and external callsites. These locations are instrumented by LOOM; this instrumentation acts as barriers and prevents compilers from reordering instructions across them.</p><p>The synchronization between the instrumentation in <ref type="figure" target="#fig_0">Figure 10</ref> and the evacuation algorithm in <ref type="figure" target="#fig_0">Figure 11</ref> is correct under two conditions: (1) read and write to wait flags are atomic and (2) the operations to the update lock contain correct memory barriers that prevent hardware reordering. Currently we implement wait flags using aligned integers; our update lock operations use atomic operations similar to the Linux kernel's rw spinlock. Thus, our evacuation algorithm works correctly on X86 and AMD64 which do not reorder instructions across atomic instructions. We expect our algorithm to work on other commodity hardware that also provides this guarantee. To cope with more relaxed hardware (e.g., , Alpha), we can augment these operations with full barriers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Hybrid Instrumentation</head><p>Most previous live update systems update binaries by compiling updated functions and redirecting old functions to the new function binaries using a table or jump instructions. This approach requires source patches to generate the updates, thus it has the limitations described in §1. Moreover, this approach pays the overhead of position independent code (PIC) because application functions must be compiled as PIC for live update. It also suffers the aforementioned function quiescence problem. <ref type="bibr" target="#b1">2</ref> Another alternative is to use general-purpose binary instrumentation tools such as vx32 <ref type="bibr" target="#b17">[20]</ref>, Pin <ref type="bibr" target="#b31">[34]</ref> and DynamoRIO <ref type="bibr" target="#b11">[14]</ref>, but they tend to incur significant runtime overhead just to run their frameworks alone. For example, Pin has been reported to incur 199% overhead <ref type="bibr" target="#b31">[34]</ref>, and we observed 10 times slowdown on Apache with a CPU-bound workload ( §6).</p><p>LOOM's hybrid instrumentation engine reduces runtime overhead by combining static and dynamic instrumentation. This engine statically transforms an application's binary to anticipate dynamic updates. The static transformation pre-pads, before each program location, a slot function which interprets the updates to this program location at runtime. <ref type="figure" target="#fig_0">Figure 12</ref> shows the pseudo code of this function. It iterates though a list of synchronization operations assigned to the current statement and performs each. To update a program location at runtime, LOOM simply modifies the corresponding operation list.</p><p>Inserting the slot function at every statement incurs</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Race ID Description</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>MySQL-791</head><p>Calls to close() and open() to flush log file are not atomic. <ref type="figure">Figure 2</ref> shows the code. <ref type="table">MySQL-169  Table update</ref> and log write in mysql delete() are not atomic. MySQL-644</p><p>Calls to prepare() and optimize() in mysql select() are not atomic. Apache-21287</p><p>Reference count decrement and checking are not atomic. Apache-25520</p><p>Threads write to same log buffer concurrently, resulting in corrupted logs or crashes. PBZip2</p><p>Variable fifo is used in one thread after being freed by another. <ref type="figure">Figure 4</ref> shows the code. SPLASH2-fft</p><p>Variable finishtime and initdonetime are read before assigned the correct values. SPLASH2-lu</p><p>Variable rf is read before assigned the correct value. SPLASH2-barnes</p><p>Variable tracktime is read before assigned the correct value. <ref type="table">Table 3</ref>: All races used in evaluation. We identify races in MySQL and Apache as "application name − Bugzilla #", the only race in PBZip2 "P BZip2", and races in SPLASH2 "SP LASH2 − benchmark name".</p><p>high runtime overhead and hinders compiler optimization. LOOM solves this problem using a basic block cloning idea <ref type="bibr" target="#b26">[29]</ref>. LOOM keeps two versions of each basic block in the application binary, an originally compiled version that is optimized, and a hot backup that is unoptimized and padded for live update. To update a basic block at runtime, LOOM simply updates the backup and switches the execution to the backup by flipping a switch flag. LOOM instruments only function entries and loop backedges to check the switch flags because doing so for each basic block is expensive. Similar to the wait flags in ( §4), the switch flags are almost always 0, so that hardware cache and branch predication can effectively hide the overhead of checking them. This technique makes live-update-ready applications run as fast as the original application during normal operations ( §6). <ref type="figure" target="#fig_7">Figure 8c</ref> shows the final results after all LOOM transformations.</p><p>Note that the accesses to switch flags are correctly protected by the update lock. An application checks the switch flag when holding the update lock in read mode, and the update engine sets the switch flag when holding the update lock in write mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>We implemented LOOM in Linux. It consists of 4,852 lines of C++ code, with 1,888 lines for the LLVM compiler plugin, 2,349 lines for the live-update engine, and 615 lines for the controller.</p><p>We evaluated LOOM on nine real races from a diverse set of applications, ranging from two server applications MySQL <ref type="bibr">[5]</ref> and Apache <ref type="bibr" target="#b8">[11]</ref>, to one desktop application PBZip2 <ref type="bibr" target="#b3">[6]</ref>, to three scientific applications fft, lu, and barnes in SPLASH2 <ref type="bibr" target="#b4">[7]</ref>. <ref type="bibr" target="#b2">3</ref>  <ref type="table">Table 3</ref> lists all nine races. Our race selection criteria is simple: (1) they are extensively used in previous studies <ref type="bibr" target="#b28">[31,</ref><ref type="bibr" target="#b39">42,</ref><ref type="bibr" target="#b40">43]</ref> and (2) the application can be compiled by LLVM and the race can be reproduced on our main evaluation machine, a 2.66 GHz Intel quad-core machine with 4 GB memory running 32-bit Linux 2.6.24.</p><p>We used the following workloads in our experiments. For MySQL, we used SysBench <ref type="bibr" target="#b5">[8]</ref> (advanced transaction workload), which randomly selects, updates, deletes, and inserts database records. For Apache, we used ApacheBench <ref type="bibr" target="#b0">[1]</ref>, which repeatedly downloads a webpage. Both benchmarks are multithreaded and used by the server developers. We made both SysBench and ApacheBench CPU bound by fitting the database or web contents within memory; we also ran both the client and the server on the same machine, to avoid masking LOOM's overhead with the network overhead. Unless otherwise specified, we ran 16 worker threads for MySQL and Apache because they performed best with 8-16 threads. We ran four worker threads for PBZip2 and SPLASH2 applications because they are CPU-intensive and our evaluation machine has four cores.</p><p>We measured throughput (TPUT) and response time (RESP) for server applications and overall execution time for other applications. We report LOOM's relative overhead, the smaller the better. We compiled the applications down to x86 instructions using llvm-gcc -O2 and LLVM's bitcode compiler llc. For all the performance numbers reported, we repeated the experiment 50 times and take the average.</p><p>We focus our evaluation on five dimensions: 1. Overhead. Does LOOM incur low overhead? 2. Scalability. Does LOOM scale well as the number of application threads increases? 3. Reliability. Can LOOM be used to fix the races listed in <ref type="table">Table 3</ref>? What are the performance and reliability tradeoffs of execution filters? 4. Availability. Does LOOM severely degrade application availability when execution filters are installed? 5. Timeliness. Can LOOM install fixes in a timely way? <ref type="figure" target="#fig_0">Figure 13</ref> shows the performance overhead of LOOM during the normal operations of the applications. We also show the overhead of bare Pin for reference. LOOM incurs little overhead for Apache and SPLASH2 benchmarks. It increases MySQL's response time by 4.11% and degrades its throughput by 3.76%. In contrast, Pin incurs higher overhead for all applications evaluated, es-   pecially for Apache and MySQL. We also evaluated how the optimizations we do reduce LOOM's overhead. <ref type="figure" target="#fig_0">Figure 14</ref> shows the effects of these optimizations. Both cloning and wait-flag are very effective at reducing overhead. Cloning reduces LOOM's response-time overhead on Apache from 100% to 17%. It also reduces LOOM's overhead on fft from 15 times to 8 times. Wait-flag actually makes Apache run faster than the original version. Inlining does not help the servers much, but it does help for SPLASH2 applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Overhead</head><formula xml:id="formula_4">E S P M y S Q L -T P U T M y S Q L -R E S P S P L A S H 2 -f f t S P L A S H 2 -b</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Scalability</head><p>LOOM synchronizes with application threads via a readwrite lock. Thus, one concern is, can LOOM scale well as the number of application threads increases? To evaluate LOOM's scalability, we ran Apache and MySQL with LOOM on a 48-core machine with four 1.9 GHz 12-core AMD CPUs and 64 GB memory running 64-bit Linux 2.6.24. In each experiment, we pinned the benchmark to one CPU and the server to the other three to avoid unnecessary CPU contention between them. <ref type="figure" target="#fig_0">Figure 15</ref> shows LOOM's relative overhead vs. the number of application threads for Apache and MySQL.   <ref type="table">Table 5</ref>: Execution filter stats for order errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Race ID</head><p>LOOM scales well with the number of threads. Its relative overhead varies only slightly. Even with 32 server threads, the overhead for Apache is less than 3%, and the overhead for MySQL is less than 12%. Our initial MySQL overhead was around 16%. We analyzed the execution counts of the LOOMinserted functions and immediately identified two update-check sites (cycle check() calls) that executed exceedingly many times. These update-check sites are in MySQL functions ptr compare 1 and Field varstring::val str. The first function compares two strings, and the second copies one string to another. Each function has a loop with a few statements and no function calls. Such tight loops cause higher overhead for LOOM, but rarely need to be updated. We thus disabled the update-check sites in these two functions, which reduced the overhead of MySQL down to 12%. This optimization can be easily automated using static or dynamic analysis, which we leave for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Reliability</head><p>LOOM can be used to fix all races evaluated. (We verified this result by manually inspecting the application binary.)  <ref type="table" target="#tab_5">Table 4</ref> shows the statistics for the execution filters that fix atomicity errors. <ref type="table">Table 5</ref> shows the statistics for the execution filters that fix order errors. In all cases, we can fix the race using multiple execution filters, demonstrating the flexibility of LOOM. (The filters for MySQL-791 are shown in <ref type="figure">Figure 3</ref>.) We only show the statistics of one execution filter of each constraint type; other filters of the same type are similar. Our results show that the filters are fairly small, 3.79 events on average and no more than 16 events, demonstrating the ease of use of LOOM. Most filters incur only a small overhead on top of LOOM. Unilateral filters tend to be slightly smaller than mutual exclusion filters, but they can be expensive sometimes. They incur little overhead for two of the MySQL bugs because the code regions protected by the filters rarely run.</p><p>These different reliability and performance overheads present an interesting tradeoff to developers. For example, users can choose to install a unilateral filter for immediate protection, then atomically replace it with a faster mutual exclusion filter. Moreover, a user can choose an "expensive" filter as long as their workload is compatible with the filter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Availability</head><p>We show that LOOM can improve server availability by comparing LOOM to the restart-based software update approach. We restarted a server by running its startup script under /etc/init.d. We chose two races, MySQL-791 and Apache-25520, and measured how software updates (conventional or with LOOM) might degrade performance. Note this comparison favors conventional updates because we only compare the installation of the fix, but LOOM also makes it quick to develop fixes. <ref type="figure" target="#fig_0">Figure 16</ref> shows the comparison result. Using the restart approach, Apache is unavailable for 4 seconds, and MySQL is unavailable for 2 seconds. Moreover, the restarts also cause Apache and MySQL to lose their internal cache, leading to a ramp-up period after the restart. In contrast, installing an filter using LOOM (at second 5) does not degrade throughput for MySQL and only degrades throughput slightly for Apache.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Timeliness</head><p>The more timely LOOM installs a filter, the quicker the application is protected from the corresponding race. This timeliness is critical for server applications because malicious clients may exploit a known race and launch attacks. In this subsection, we compare how timely LOOM's evacuation algorithm installs an aggressive filter vs. an approach that passively waits for function quiescence. We chose Apache-25520 as the benchmark race. We wrote a simple mutual exclusion filter that fixes the race by making function ap buffered log writer a critical region. We then measured the latency from the moment LOOM receives a filter to the moment the filter is installed. We simulated a function quiescence approach by running LOOM without making any wait flag false, so that a thread can pause wherever we insert update-checks. We used the same SysBench and ApacheBench workload. Our results show that LOOM can install the filter within 368 ms. It spends majority of the time waiting for threads to evacuate. In contrast, an approach based on function quiescence fails to install the filter in an hour, our experiment's time limit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Live update LOOM differs from previous live update systems <ref type="bibr" target="#b7">[10,</ref><ref type="bibr" target="#b9">12,</ref><ref type="bibr" target="#b12">15,</ref><ref type="bibr" target="#b32">35,</ref><ref type="bibr" target="#b35">38,</ref><ref type="bibr" target="#b36">39,</ref><ref type="bibr" target="#b48">51]</ref> in that it is explicitly designed for developers to quickly develop temporary workarounds to races. Moreover, it can automatically ensure the safety of the workarounds. In contrast, previous work focuses only on live update after a source patch is available, thus it does not address the automaticsafety and flexibility problems LOOM addresses. The live update system closest to LOOM is STUMP <ref type="bibr" target="#b35">[38]</ref>, which can live-update multithreaded applications written in C. Its prior version Ginseng <ref type="bibr" target="#b36">[39]</ref> works with single-threaded C applications. Both STUMP and Ginseng have been shown to be able to apply arbitrary source patches and update applications across major releases. Unlike LOOM, both STUMP and Ginseng require source modifications and rely on extensive user annotations for safety because the safety of arbitrary live updates has been proven undecidable <ref type="bibr" target="#b19">[22]</ref>.</p><p>A number of live update systems can update kernels without reboots <ref type="bibr" target="#b9">[12,</ref><ref type="bibr" target="#b12">15,</ref><ref type="bibr" target="#b32">35]</ref>. The most recent one, <ref type="bibr">Ksplice [12]</ref>, constructs live updates from object code, and does not require developer efforts to adapt existing source patches. Unlike LOOM, Ksplice uses function quiescence for safety, and is thus prone to the unsafe state problem discussed in §4. Another kernel live update system, DynAMOS <ref type="bibr" target="#b32">[35]</ref>, requires users to manually construct multiple versions of a function to update non-quiescent functions. This technique is different from basic block cloning ( §5): the former is manual and for safety, whereas the later is automatic and for speed. Error workaround and recovery We compare LOOM to recent error workaround and recovery tools. ClearView <ref type="bibr" target="#b41">[44]</ref>, ASSURE <ref type="bibr" target="#b47">[50]</ref>, and Failure-oblivious computing can increase application availability by letting them continue despite errors. Compared to LOOM, these systems are unsafe, and do not directly deal with races. <ref type="bibr">Rx [46]</ref> can safely recover from runtime faults using application checkpoints and environment modifications, but it does not fix errors because the same error can re-appear. Vigilante <ref type="bibr" target="#b14">[17]</ref> enables hosts to collaboratively contain worms using self-verifiable alerts. By automatically ensuring filter safety, LOOM shares similar benefits.</p><p>Two recent systems, <ref type="bibr">Dimmunix [26]</ref> and Gadara <ref type="bibr" target="#b49">[52]</ref>, can fix deadlocks in legacy multithreaded programs. Dimmunix extracts signatures from occurred deadlocks (or starvations) and dynamically avoids them in future executions. Gadara uses control theory to statically transform a program into a deadlock-free program. Both systems have been shown to work on real, large applications. They may possibly be adapted to fix races, albeit at a coarser granularity because these systems control only lock operations.</p><p>Kivati <ref type="bibr" target="#b13">[16]</ref> automatically detects and prevents atomicity violations for production systems. It reduces performance overhead by cleverly using hardware watch points, but the limited number of watch points on commodity hardware means that Kivati cannot prevent all atomicity violations. Nor does Kivati prevent execution order violations. LOOM can be used to workaround these errors missed by Kivati. Program instrumentation frameworks Previous work <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b16">19,</ref><ref type="bibr" target="#b37">40]</ref> can instrument programs with low runtime overhead, but instrumentation has to be done at compile time. Translation-based dynamic instrumentation frameworks <ref type="bibr" target="#b11">[14,</ref><ref type="bibr" target="#b17">20,</ref><ref type="bibr" target="#b31">34]</ref> can update programs at runtime but incur high overhead. In particular, vx32 <ref type="bibr" target="#b17">[20]</ref> is a novel user-level sandbox that reduces overhead using segmentation hardware; it can be used as an efficient dynamic binary translator. Jump-based instrumentation frameworks <ref type="bibr" target="#b21">[24,</ref><ref type="bibr" target="#b45">48]</ref> have low overhead but automatically ensuring safety for them can be difficult due to low-level issues such as position-dependent code, short instructions, and locations of basic blocks.</p><p>One advantage of these instrumentation frameworks over LOOM is that LOOM requires CFGs and symbol information to be distributed to user machines, thus it risks leaking proprietary code information. However, this risk is not a concern for open-source software. Moreover, LOOM only mildly increases this risk because CFGs can often be reconstructed from binaries, and companies such as Microsoft already share symbol information <ref type="bibr">[4]</ref>.</p><p>The advantage of LOOM is that it combines static and dynamic instrumentation, thus allowing arbitrary dynamic updates issued by execution filters with negligible runtime overhead. LOOM borrows basic block cloning from previous work by Liblit et al. <ref type="bibr" target="#b26">[29]</ref>, but their framework is static only. This idea has also been used in other systems (e.g., LIFT <ref type="bibr" target="#b42">[45]</ref>). Other related work Our work was inspired by many observations made by <ref type="bibr">Lu et al. [33]</ref>. Aspect-oriented programming (AOP) allows developers to "weave" in synchronizations into code <ref type="bibr" target="#b24">[27,</ref><ref type="bibr" target="#b27">30]</ref>. LOOM's execution filter language shares some similarity to AOP, and can be made more expressive by incorporating more aspects. However, to the best of our knowledge, no existing AOP systems were designed to support race fixing at runtime. We view the large body of race detection and diagnosis work (e.g., <ref type="bibr" target="#b28">[31,</ref><ref type="bibr" target="#b29">32,</ref><ref type="bibr" target="#b34">37,</ref><ref type="bibr" target="#b39">42,</ref><ref type="bibr" target="#b44">47,</ref><ref type="bibr" target="#b46">49,</ref><ref type="bibr" target="#b51">54]</ref>) as complimentary to our work and LOOM can be used to fix errors detected and isolated by these tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We have presented LOOM, a live-workaround system designed to quickly and safely fix application races at runtime. Its flexible language allows developers to write concise execution filters to declare their synchronization intents on code. Its evacuation algorithm automatically ensures the safety of execution filters and their installation/removal processes. It uses hybrid instrumentation to reduce its performance overhead during the normal operations of applications. We have evaluated LOOM on nine real races from a diverse set of applications. Our results show that LOOM is fast, scalable, and easy to use. It can safely fix all evaluated races in a timely manner, thereby increasing application availability.</p><p>LOOM demonstrates that live-workaround systems can increase application availability with little performance overhead. In our future work, we plan to extend this idea to other classes of errors (e.g., security vulnerabilities).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: LOOM overview. Its components are shaded.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Figure 2: A real MySQL race, slightly modified for clarity. // Execution filter 1: unilateral exclusion {log.cc:5, log.cc:6} &lt;&gt; * // Execution filter 2: mutual exclusion of code {log.cc:5, log.cc:6} &lt;&gt; MYSQL LOG::is open // Execution filter 3: mutual exclusion of code and data {log.cc:5 (this), log.cc:6 (this)} &lt;&gt; MYSQL LOG::is open(this)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Execution filter for the PBZip2 race in Figure 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Constructs Syntax Event (short as e) f ile : line f ile : line (expr) e{n}, n is # of occurrence Region (short as r) {e1, ..., ei; ei+1, ..., en} f unc (args) Execution Order e1 &gt; e2 &gt; ... &gt; en Mutual Exclusion r1 &lt;&gt; r2 &lt;&gt; ... &lt;&gt; rn Unilateral Exclusion r &lt;&gt; *</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Unsafe program states for installing filters.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Evacuation. Curved lines represent application threads, solid triangles (in black) represents the threads' program counters (PC), and solid stripes (in red) represents an unsafe code region.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>(</head><label></label><figDesc>a) ICFG of the code in Figure 7. (b) After update-checks inserted. (c) After basic blocks cloned.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Static transformations that LOOM does for safe and fast live update. Subfigure (a) shows the ICFG of the code in Figure 7; (b) shows the resulting CFG of function process client() after the instrumentation to control application threads ( §4); (c) shows the final CFG of function process client() after basic block cloning ( §5).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>/</head><label></label><figDesc>Figure 10: Instrumentation to pause application threads.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Figure 11: Pseudo code of the evacuation algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>void</head><label></label><figDesc>Figure 12: Slot function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Effects of LOOM's optimizations. Label unopt represents the versions with no optimizations; cloning represents the version with basic block cloning ( §5); wait-flag represents the version with statement "if(wait[stmt id])" added ( §4.2); and inlining indicates the version with all LOOM instrumentation inlined into the applications.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 13 :</head><label>13</label><figDesc>Figure 13: LOOM's relative overhead during normal operation. Smaller numbers are better. We show Pin's overhead for reference. Some Pin bars are broken.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 15 :</head><label>15</label><figDesc>Figure 15: LOOM's relative overhead vs. the number of application threads.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 16 :</head><label>16</label><figDesc>Figure 16: Throughput degradation for fixing races with LOOM vs. with conventional software update.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 2 : Execution filter language summary. LOOM</head><label>2</label><figDesc>creates the needed locks and semaphores on demand. The first time a lock or semaphore is refer- enced by one of the inserted synchronization operations, LOOM creates this synchronization object based on the ID of the filter, the ID of the constraint, and the value of expr if present. It initializes a lock to an unlocked state and a semaphore to 0. It then inserts this object into a hash table for future references. To limit the size of this table, LOOM garbage-collects these synchronization ob- jects. Freeing a synchronization object is safe as long as it is unlocked (for locks) or has a counter of 0 (for semaphores). If this object is referenced later, LOOM simply re-creates it. The default size of this table is 256 and LOOM never needed to garbage-collect synchroniza- tion objects in our experiments.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head></head><label></label><figDesc>cannot address this unsafe state problem. This technique updates a function only when no stack frame of this function is active in any call stack of the application. Unfortunately, though this technique can ensure safety for many live updates, it is insufficient for execution filters because their synchronization con- straints may affect multiple functions.</figDesc><table>We demonstrate this point using a race example. Fig-
ure 7 shows the worker thread code of a contrived 
database. Function process client() is the main 
thread function. It takes a client socket as input and re-
peatedly processes requests from the socket. For each 
request, function process client() opens the cor-
responding database table by calling open table(), 
serves the request, and closes the table by calling 

1 : // database worker thread 
2 : void handle client(int fd) { 
3 : 
for(;;) { 
4 : 
struct client req req; 
5 : 
int ret = recv(fd, &amp;req, . . .); 
6 : 
if(ret &lt;= 0) break; 
7 : 
open table(req.table id); 
8 : 
. . . // do real work 
9 : 
close table(req.table id); 
10: 
} 
11: } 
12: void open table(int table id) { 
13: 
// fix: acquire table lock 
14: 
. . . // actual code to open table 
15: } 
16: void close table(int table id) { 
17: 
. . . // actual code to close table 
18: 
// fix: release table lock 
19: } 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><head>Table 4 : Execution filter stats for atomicity errors. Col- umn Events counts the number of events in each filter.</head><label>4</label><figDesc></figDesc><table>Race ID 
Events 
Overhead 
PBZip2 
6 
1.26% 
SPLASH2-fft 
6 
0.08% 
SPLASH2-lu 
2 
1.68% 
SPLASH2-barnes 
2 
1.99% 

</table></figure>

			<note place="foot" n="1"> Note that unilateral exclusion differs (subtly) from single-threaded execution: unilateral exclusion allows no context switches.</note>

			<note place="foot" n="2"> The function quiescence problem can be addressed by transforming loop bodies into functions [38, 39] but only if the CFGs are reducible [23].</note>

			<note place="foot" n="3"> We include applications that do not need live update for two reasons. First, as discussed in §1, LOOM can provide quick workarounds for these applications as well. Second, we use them to measure LOOM&apos;s overhead and scalability.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>We thank Cristian Cadar, Jason Nieh, Jinyang Li, Michael Kester, Xiaowei Yang, Vijayan Prabhakaran (our shepherd), and the anonymous reviewers for their tremendous feedback and comments, which have substantially improved the content and presentation of this paper. We thank Shan Lu for providing many of the races used in our evaluation. We thank Jane-Ellen Long for time management. This work was supported by the National Science Foundation (NSF) through Contract CNS-1012633 and CNS-0905246 and the United States Air Force Research Laboratory (AFRL) through Contract FA8650-10-C-7024 and FA8750-10-2-0253. Opinions, findings, conclusions, and recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the US Government.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<ptr target="http://httpd.apache.org/docs/2.2/programs/ab.html" />
		<title level="m">ab -Apache HTTP server benchmarking tool</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>The</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Project</surname></persName>
		</author>
		<ptr target="http://www.research.ibm.com/K42/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>The Llvm Compiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Framework</surname></persName>
		</author>
		<ptr target="http://llvm.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bzip2</forename><surname>Parallel</surname></persName>
		</author>
		<ptr target="http://compression.ca/pbzip2/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Stanford Parallel Applications for Shared Memory (SPLASH)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sysbench</surname></persName>
		</author>
		<ptr target="http://sysbench.sourceforge.net" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">ODR: output-deterministic replay for multicore debugging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Altekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM Symposium on Operating Systems Principles (SOSP &apos;09)</title>
		<meeting>the 22nd ACM Symposium on Operating Systems Principles (SOSP &apos;09)</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="193" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">OPUS: online patches and updates for security</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Altekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Bagrak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Burstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schultz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th USENIX Security Symposium</title>
		<meeting>the 14th USENIX Security Symposium</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Apache Web</forename><surname>Server</surname></persName>
		</author>
		<ptr target="http://www.apache.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Ksplice: Automatic rebootless kernel updates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">M</forename><surname>Kaashoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th ACM European Conference on Computer Systems (EUROSYS &apos;09)</title>
		<meeting>the 4th ACM European Conference on Computer Systems (EUROSYS &apos;09)</meeting>
		<imprint>
			<date type="published" when="2009-04" />
			<biblScope unit="page" from="187" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Providing dynamic update in an operating system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Baumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Appavoo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">Da</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Krieger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">W</forename><surname>Wisniewski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kerr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference (USENIX &apos;05)</title>
		<meeting>the USENIX Annual Technical Conference (USENIX &apos;05)</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="32" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Efficient, transparent, and comprehensive runtime code manipulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Bruening</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<publisher>SupervisorAmarasinghe</publisher>
			<pubPlace>Saman</pubPlace>
		</imprint>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Live updating operating systems using virtualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Zang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-C</forename><surname>Yew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Conference on Virtual Execution Environments (VEE &apos;06)</title>
		<meeting>the 2nd International Conference on Virtual Execution Environments (VEE &apos;06)</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="35" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Kivati: fast detection and prevention of atomicity violations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Chew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroSys &apos;10: Proceedings of the 5th European conference on Computer systems</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="307" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Vigilante: end-to-end containment of internet worms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Crowcroft</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rowstron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Barham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th ACM Symposium on Operating Systems Principles (SOSP &apos;05)</title>
		<meeting>the 20th ACM Symposium on Operating Systems Principles (SOSP &apos;05)</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="133" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Execution replay of multiprocessor virtual machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">W</forename><surname>Dunlap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G</forename><surname>Lucchetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Fetterman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th International Conference on Virtual Execution Environments (VEE &apos;08)</title>
		<meeting>the 4th International Conference on Virtual Execution Environments (VEE &apos;08)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="121" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Checking system rules using system-specific, programmer-written compiler extensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hallem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourth Symposium on Operating Systems Design and Implementation (OSDI &apos;00)</title>
		<meeting>the Fourth Symposium on Operating Systems Design and Implementation (OSDI &apos;00)</meeting>
		<imprint>
			<date type="published" when="2000-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Vx32: lightweight user-level sandboxing on the x86</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference (USENIX &apos;08)</title>
		<meeting>the USENIX Annual Technical Conference (USENIX &apos;08)</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="293" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Dynamic ML without dynamic types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gilmore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Walton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
		<respStmt>
			<orgName>Lab. for the Foundations of Computer Science, University of Edinburgh</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A formal framework for online software version change</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Jalote</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Barua</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="120" to="131" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Characterizations of reducible flow graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Hecht</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="367" to="375" />
			<date type="published" when="1974" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Detours: Binary interception of win32 functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Brubacher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd USENIX Windows NT Symposium</title>
		<meeting>the 3rd USENIX Windows NT Symposium</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="135" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A randomized dynamic program analysis technique for detecting real deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Naik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2009 Conference on Programming Language Design and Implementation (PLDI &apos;09)</title>
		<meeting>the ACM SIGPLAN 2009 Conference on Programming Language Design and Implementation (PLDI &apos;09)</meeting>
		<imprint>
			<date type="published" when="2009-06" />
			<biblScope unit="page" from="110" to="120" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Deadlock immunity: Enabling systems to defend against deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Jula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tralamazza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Cristian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>George</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth Symposium on Operating Systems Design and Implementation (OSDI &apos;08)</title>
		<meeting>the Eighth Symposium on Operating Systems Design and Implementation (OSDI &apos;08)</meeting>
		<imprint>
			<date type="published" when="2008-12" />
			<biblScope unit="page" from="295" to="308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Aspect-oriented programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kiczales</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lamping</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mendhekar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Maeda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lopes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Marc Loingtier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Irwin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Transparent, lightweight application execution replay on commodity multiprocessor operating systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Laadan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Viennot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nieh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems</title>
		<meeting>the 2010 ACM SIGMETRICS Conference on Measurement and Modeling of Computer Systems</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Bug isolation via remote program sampling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Liblit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">X</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI &apos;03: Proceedings of the ACM SIGPLAN 2003 conference on Programming language design and implementation</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="141" to="154" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">CiAO: An aspect-oriented operating-system family for resource-constrained embedded systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lohmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hofer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Schrder-Preikschat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Streicher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Spinczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference (USENIX &apos;09)</title>
		<meeting>the USENIX Annual Technical Conference (USENIX &apos;09)</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Avio: Detecting atomicity violations via access interleaving invariants</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Twelfth International Conference on Architecture Support for Programming Languages and Operating Systems (ASPLOS &apos;06)</title>
		<imprint>
			<date type="published" when="2006-10" />
			<biblScope unit="page" from="37" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Muvi: automatically inferring multi-variable access correlations and detecting related semantic and concurrency bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Popa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="103" to="116" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Learning from mistakes: a comprehensive study on real world concurrency bug characteristics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASPLOS XIII: Proceedings of the 13th international conference on Architectural support for programming languages and operating systems</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="329" to="339" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Pin: building customized program analysis tools with dynamic instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Hazelwood</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2005 Conference on Programming Language Design and Implementation (PLDI &apos;05)</title>
		<meeting>the ACM SIGPLAN 2005 Conference on Programming Language Design and Implementation (PLDI &apos;05)</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="190" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Dynamic and adaptive updates of nonquiescent subsystems in commodity operating system kernels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Makris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ryu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd ACM SIGOPS/EuroSys European Conference on Computer Systems</title>
		<meeting>the 2nd ACM SIGOPS/EuroSys European Conference on Computer Systems</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page">340</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Capo: a software-hardware interface for practical deterministic multiprocessor replay</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Montesinos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Torrellas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fourteenth International Conference on Architecture Support for Programming Languages and Operating Systems (ASPLOS &apos;09)</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="73" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Finding and reproducing heisenbugs in concurrent programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Qadeer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Basler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">A</forename><surname>Nainar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Neamtiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth Symposium on Operating Systems Design and Implementation (OSDI &apos;08)</title>
		<meeting>the Eighth Symposium on Operating Systems Design and Implementation (OSDI &apos;08)</meeting>
		<imprint>
			<date type="published" when="2008-12" />
			<biblScope unit="page" from="267" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Safe and timely dynamic updates for multi-threaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Neamtiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2009 Conference on Programming Language Design and Implementation (PLDI &apos;09)</title>
		<meeting>the ACM SIGPLAN 2009 Conference on Programming Language Design and Implementation (PLDI &apos;09)</meeting>
		<imprint>
			<date type="published" when="2009-06" />
			<biblScope unit="page" from="13" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Practical dynamic software updating for C</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Neamtiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Stoyle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Oriol</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006-06" />
			<biblScope unit="page" from="72" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">CIL: Intermediate Language and Tools for Analysis and Transformation of C Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mcpeak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rahul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Conference on Compilier Construction</title>
		<meeting>Conference on Compilier Construction</meeting>
		<imprint>
			<date type="published" when="2002-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Randomized active atomicity violation detection in concurrent programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM SIGSOFT International Symposium on Foundations of Software Engineering (SIGSOFT &apos;08/FSE-16)</title>
		<meeting>the 16th ACM SIGSOFT International Symposium on Foundations of Software Engineering (SIGSOFT &apos;08/FSE-16)</meeting>
		<imprint>
			<date type="published" when="2008-11" />
			<biblScope unit="page" from="135" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">CTrigger: exposing atomicity violation bugs from their hiding places</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fourteenth International Conference on Architecture Support for Programming Languages and Operating Systems (ASPLOS &apos;09)</title>
		<imprint>
			<date type="published" when="2009-03" />
			<biblScope unit="page" from="25" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">PRES: probabilistic replay with execution sketching on multiprocessors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM Symposium on Operating Systems Principles (SOSP &apos;09)</title>
		<meeting>the 22nd ACM Symposium on Operating Systems Principles (SOSP &apos;09)</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="177" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Automatically patching errors in deployed software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Perkins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Amarasinghe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Carbin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pacheco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Sherwood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Sullivan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-F</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zibin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rinard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM Symposium on Operating Systems Principles (SOSP &apos;09)</title>
		<meeting>the 22nd ACM Symposium on Operating Systems Principles (SOSP &apos;09)</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="87" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Lift: A low-overhead practical information flow tracking system for detecting security attacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MICRO 39: Proceedings of the 39th Annual IEEE/ACM International Symposium on Microarchitecture</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="135" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Rx: Treating bugs as allergies-a safe method to survive software failures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sundaresan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">7</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Anderson. Eraser: A dynamic data race detector for multithreaded programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sobalvarro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">E</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="page" from="391" to="411" />
			<date type="published" when="1997-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Scalable dynamic binary instrumentation for blue gene/l</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bernat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">R</forename><surname>De Supinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">Y</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Rountree</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGARCH Comput. Archit. News</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="9" to="14" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Race directed random testing of concurrent programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2008 Conference on Programming Language Design and Implementation (PLDI &apos;08)</title>
		<meeting>the ACM SIGPLAN 2008 Conference on Programming Language Design and Implementation (PLDI &apos;08)</meeting>
		<imprint>
			<date type="published" when="2008-06" />
			<biblScope unit="page" from="11" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">ASSURE: automatic software self-healing using rescue points</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sidiroglou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Laadan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Perez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Viennot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nieh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fourteenth International Conference on Architecture Support for Programming Languages and Operating Systems (ASPLOS &apos;09)</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="37" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Dynamic software updates: a vm-centric approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hicks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2009 Conference on Programming Language Design and Implementation (PLDI &apos;09)</title>
		<meeting>the ACM SIGPLAN 2009 Conference on Programming Language Design and Implementation (PLDI &apos;09)</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Gadara: Dynamic deadlock avoidance for multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kudlur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lafortune</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mahlke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth Symposium on Operating Systems Design and Implementation (OSDI &apos;08)</title>
		<meeting>the Eighth Symposium on Operating Systems Design and Implementation (OSDI &apos;08)</meeting>
		<imprint>
			<date type="published" when="2008-12" />
			<biblScope unit="page" from="281" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Bypassing races in live applications with execution filters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<imprint/>
		<respStmt>
			<orgName>Columbia University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">RaceTrack: efficient detection of data race conditions via adaptive tracking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Rodeheffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP &apos;05: Proceedings of the twentieth ACM symposium on Operating systems principles</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="221" to="234" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
