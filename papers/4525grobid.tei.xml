<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:23+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Provenance-Only Integration</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Gehani</surname></persName>
							<email>ashish.gehani@sri.com</email>
							<affiliation key="aff0">
								<orgName type="institution">SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawood</forename><surname>Tariq</surname></persName>
							<email>dawood.tariq@sri.com</email>
							<affiliation key="aff0">
								<orgName type="institution">SRI International</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Provenance-Only Integration</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>As provenance records are collected from an increasingly diverse set of sources, the need to integrate them grows. The alternative approach of reconciling semantics scales when the records are queried infrequently. However, as the use of provenance grows, normalizing the diverse provenance via formal integration will yield better query performance. We describe two motivating cases for integrating provenance only, provide an initial formal model for integration that is domain-agnostic, and identify a possible direction for optimizing the integration process itself.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The provenance of data can either be explicitly collected or retrospectively reconstructed. By interposing in systems that transform data, corresponding provenance metadata can be recorded. Alternatively, postfact analysis of artifacts can be performed to infer the provenance relationships between pieces of data. Finally, provenance may be constructed by a hybrid approach that combines instrumentation and inference.</p><p>Regardless of the methodology by which provenance is obtained, the information is increasingly likely to arrive from a heterogeneous set of sources (rather than a single source or homogeneous group). The heterogeneity here refers to the variation in the identifiers, syntax, ontologies, completeness, and fidelity of the provenance elements.</p><p>Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. <ref type="bibr">TaPP '14, June 12-13, 2014</ref> When a diverse set of provenance sources are used together, they introduce a challenge for reasoning about the origins of information. One approach maintains the diversity in the metadata, deferring the reconciliation of semantics till the resolution of queries. An alternative strategy utilizes explicit provenance integration to merge the metadata into a unified form, as long as the sources have compatible semantics and the same level of abstraction. We report on the case where a single underlying system is monitored at multiple vantage points, giving rise to the need for provenance-only integration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Basic Integration</head><p>The Open Provenance Model <ref type="bibr" target="#b9">[11]</ref> handles the problem of representing records from diverse domains by using graphs with all the application-specific semantics retained only as annotations on vertices and edges. This allows us to reduce the provenance-only integration challenge to a graph optimization problem.</p><p>Without loss of generality, we consider the problem of integrating two graphs G 1 = (V 1 , E 1 ) and G 2 = (V 2 , E 2 ), given an arbitrary predefined threshold of matching, ⌧ .</p><p>The matching between a vertex v 1 2 V 1 and another vertex v 2 2 V 2 is defined as:</p><formula xml:id="formula_0">m(v 1 , v 2 ) = X a i 2(A(v 1 )\A(v 2 )) w(a i )</formula><p>where A(v) is the set of annotations a i on the vertex v, and w(a i ) is the weight accorded to a matching of annotation a i -that is, the occurrence of a i in the set of annotations A(v 1 ) on vertex v 1 as well as in the set of annotations A(v 2 ) on vertex v 2 .</p><p>During graph integration, the intermediate graph</p><formula xml:id="formula_1">G I = (V I , E I ) = G 1 ] G 2 will contain a single ver- tex v = v 1 ] v 2 instead of v 1 2 V 1 and v 2 2 V 2 if m(v 1 , v 2 ) 񮽙 ⌧ , where A(v) = A(v 1 ) [ A(v 2 )</formula><p>contains all the annotations from the pair of vertices being integrated. (] denotes integration.) Similarly, if v 0 = v 3 ] v 4 , where v 2 G I , v 3 2 G 1 , and v 4 2 G 2 , then an edge e = (v, v 0 ) 2 G I will be defined in the intermediate graph. The annotations on the edge e will contain all the annotations on the edges e 1 2 G 1 = (v 1 , v 3 ) and e 2 2 G 2 = (v 2 , v 4 ), if one or more of e 1 and e 2 exist -that is, A(e) = A(e 1 )[A(e 2 ).</p><p>The combined integrated graph G C will contain the intermediate graph G I and all remaining unintegrated vertices and edges in the source graphs</p><formula xml:id="formula_2">G 1 and G 2 - that is, G C = (G 1 ] G 2 ) [ G r , where G r = (V r , E r ) is the residue graph with V r = (V 1 [ V 2 ) 񮽙 V I and E r = (E 1 [ E 2 ) 񮽙 E I . It is worth noting that if ⌧ = 1, then G C = G 1 [ G 2</formula><p>-that is, if the threshold of matching is too high, the combined graph will just be the two original graphs without any integration. It is also worth noting that if ⌧ = 0, then G C will contain just one vertex v with all the source annotations -that is:</p><formula xml:id="formula_3">A(v) = [ v i 2(V 1 [V 2 ) A(v i )</formula><p>Provenance graphs differ from data flow graphs in an important aspect, which is that each process or data artifact vertex is under the influence (or owned) by an agent. This results in a set of integration constraints, that limit whether two vertices under different influences can be combined. These constraints are formulated as costs -that is, when matching two vertices v 1 2 V 1 and v 2 2 V 2 , the associated cost ⇣(v 1 , v 2 ) is based on the relationship between their owners ⌦(v 1 ) and ⌦(v 2 ), respectively. By definition, ⇣(v 1 , v 2 ) = 0 if ⌦(v 1 ) = ⌦(v 2 ). If the owners are from the same group, a low cost is imposed for integrating the vertices. If the owners are completely unrelated, ⇣(v 1 , v 2 ) = 1, which will prevent the vertices from being integrated unless the matching threshold is 0.</p><p>Ideally the cost of integration would be 0 -that is, only subsets of each graph under the influence of the same agent are integrated. In practice, due to the heterogeneity in sources from which provenance records arrive, parts of graphs that come from related owners can be merged with an associated integration cost, where</p><formula xml:id="formula_4">v = v 1 ] v 2 : ⇣(G 1 , G 2 ) = X v2G I ⇣(v 1 , v 2 )</formula><p>Intuitively, the more we are willing to trust that different owners' provenance records can be merged, the higher we can set the trust tolerance ⌥. Since provenance graphs may be used for precision-sensitive applications (such as system diagnostics or identifying the source of anomalous activity after an intrusion), we must ensure that integration only occurs as long as the cost remains below ⌥. Provenance graph integration can therefore be formulated as the optimization problem of finding the minimum threshold ⌧ where the integration cost ⇣(G 1 , G 2 ) remains below the trust tolerance ⌥:</p><formula xml:id="formula_5">min ⌧, ⇣(G 1 , G 2 )  ⌥</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Integration of Heterogeneous Provenance</head><p>In the formulation above, two vertices from source graphs could be integrated into a single vertex if their match exceeded a predefined threshold. This corresponds to consuming the matching "budget" uniformly (or homogeneously) across all candidates. In an alternative formulation, the matching "budget" can be consumed heterogeneously, with some vertex pairs being better matched while other pairs being less matched, as long as the aggregate matching benefit when summed over all pairs exceeds a predefined threshold of matching. This formulation is harder to optimize since more permutations must be analyzed but is more useful in practice since it corresponds to the situation where there is diversity in the semantics of the vertex pairs in the graphs being integrated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Case Study: Speech Processing</head><p>We now describe the first of two motivating case studies for provenance-only integration that we have encountered in practice. This case occurs when recording the details of speech processing workflows. Global data provenance from one source is combined with temporal overhead measurements from another. Together they allow a distributed application to be profiled to identify bottlenecks in input and output operations. The NIGHTINGALE project <ref type="bibr" target="#b10">[12]</ref> aimed to let monolingual users query information from newscasts and documents in multiple languages. Input data is transformed multiple times for automatic speech recognition, machine translation between languages, and distillation to extract responses to a query. The project used Berkeley Customs <ref type="bibr">[4]</ref> Grid middleware to manage distributed computations running on more than 1,000 processors, accessing thousands of files that ranged in size from a few kilobytes to gigabytes, with a total of one petabyte of data. <ref type="figure">Figure 1</ref>. Application-specific temporally-enriched provenance records facilitate profiling. However, the high overhead of collecting these records prevents it from being done on a global basis. Instead these records are integrated with system-wide provenance from an alternative source. The combination allows resource-intensive parts of the computation to be identified, as visualized with this "heat map". A typical computation run by a speech researcher executes hundreds of scripts and binaries on hundreds of processors that read and write thousands of files. Consequently, substantial amounts of time are spent on input and output (I/O). The scientists are therefore particularly interested in optimizing the workflow with respect to I/O.</p><p>One source of provenance is the operating system's audit trail, from which the file dependencies of all processes can be reconstructed. These records are collected across the entire system, for all processes executing and every file accessed. This results in a graph</p><formula xml:id="formula_6">G 1 = (V 1 , E 1 ).</formula><p>Consequently, the level of detail that can be recorded is limited to manage the runtime overhead introduced.</p><p>Since the temporal overhead of input and output is of particular interest, a second source of provenance is used to obtain this information. This is possible in practice by limiting the collection of these records to a subset of system activity. Information gathered with system call interposition allows high fidelity monitoring. Its overhead is minimized by activation on just the part of the filesystem where applications of interest store their data. This results in a graph G 2 = (V 2 , E 2 ).</p><p>In previous work <ref type="bibr" target="#b6">[8]</ref>, we used an integration policy to specify how provenance elements from disparate sources relate. The current model allows integration to be defined by specifying only the trust tolerance ⌥.</p><p>In this case study, annotations are unweighted. This is captured by using w(a i ) = 1 for all annotations a i 2 A(v 1 ) [ A(v 2 ), where v 1 2 V 1 and v 2 2 V 2 . Therefore the match m(v 1 , v 2 ) is the number of annotations shared by v 1 and v 2 .</p><p>We use ⌥ = 0 to limit integration to pairs of vertices v 1 and v 2 with the same owner -that is, ⌦(v 1 ) = ⌦(v 2 ). The integration process starts with a threshold of matching ⌧ = 0. This allows arbitrary pairs of vertices to be matched, but results in an integration cost ⇣(G 1 , G 2 ) &gt; 0 (since some pairs of vertices have different owners). ⌧ is increased repeatedly until the integration cost</p><formula xml:id="formula_7">⇣(G 1 , G 2 ) drops to ⌥ = 0.</formula><p>The integration completes when ⌧ = 2 since this is the lowest value for which ⇣(G 1 , G 2 )  0. This is because corresponding process vertices from G 1 and G 2 have matching process and group identifiers, and corresponding artifact vertices have matching file paths and modification times. No other annotations are shared.</p><p>The integration results in a provenance graph with the global coverage of the first source and the temporal fidelity of the second. Together they allow the identification of bottleneck "hot" areas in a distributed computation, as illustrated in <ref type="figure">Figure 1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Fast Integration</head><p>Section 2 described a basic framework for integrating data provenance. In practice, the characteristics of the provenance may allow further simplification of the graph. In the basic framework, once a vertex v 1 2 G 1 is matched to another vertex v 2 2 G 2 , the combined vertex v = v 1 ] v 2 is eliminated from consideration for further integration. However, other vertices in G 2 may have also been matches. Indeed, other vertices in G 1 may be similar enough that they can be represented by v. Consequently, the provenance-only integration can use an alternative algorithm that combines all vertices that are similar enough in a single fell swoop.</p><p>Combining the above simplification with basic integration has an important consequence. It eliminates the implicit step of identifying the specific pairs of vertices v 1 2 G 1 and v 2 2 G 2 that should be considered as candidates for matching. Optimally identifying such pairs is equivalent to solving the subgraph isomorphism</p><formula xml:id="formula_8">Algorithm 1 Input: G 1 = (V 1 , E 1 ), G 2 = (V 2 , E 2 ), (⌧ v , ⌧ e ), ⌥ 1: V V 1 [ V 2 2: E E 1 [ E 2 3: M ; 4: for v i 2 V do 5: V i {v i } 6:</formula><p>for v j 2 V do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7:</head><p>if match(v i , v j , ⌧ v , ⌥) then 8: </p><formula xml:id="formula_9">V i V i [ {v j } 9: c i integrate(V i ) 10: M M [ {(c i , V i )} 11: V (V 񮽙 V i ) [ {c i } 12</formula><formula xml:id="formula_10">E (E 񮽙 E i ) [ {f i } 27: return G = (V, E)</formula><p>problem, which is NP-hard <ref type="bibr" target="#b2">[3]</ref>. Only in the rare case that the provenance graphs are planar can this problem be solved efficiently <ref type="bibr" target="#b5">[7]</ref>.</p><p>In addition to the pair of provenance graphs that are to be integrated, the algorithm takes as input the threshold of matching ⌧ and trust tolerance ⌥ that were described in Section 2. Empirical analysis motivated a refined definition for ⌧ = (⌧ v , ⌧ e ) to allow different thresholds ⌧ v for vertex matching and ⌧ e for edge matching. Algorithm 1 describes how to perform optimized provenance integration.</p><p>The algorithm consists of three phases. In the first (on lines 4 to 11), all vertices that have at least ⌧ v identical annotations and no more than ⌥ dissimilar annotations if the owners differ, are combined into a single vertex. In the second phase (on lines 12 to 19), any edge with a source or destination vertex that was combined in the previous step is updated. The original vertex is replaced by the combined vertex. In the last phase (on lines 20 to 26), any pair of edges with ⌧ e identical annotations and no more than ⌥ dissimilar ones when the owners differ is combined into a single edge. Note that integrate() takes a set of vertices or edges as input and emits a single combined vertex c i or fused edge f i , as described in Section 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Case Study: Intrusion Detection</head><p>Our second case study is that of intrusion detection, where sensors may be deployed at multiple locations on a host that is being monitored. Each sensor will collect different types of information. For example, on Android devices one source describes intra-application activity while another source tracks inter-application communication.</p><p>As the details in the logs increase and the granularity of monitoring becomes finer, the likelihood of detecting an intrusion increases. However, the storage overhead for retaining all the logs, the processing overhead for analyzing them, and the network overhead for distributed correlation all increase as well. To retain many of the benefits without the accompanying overhead, we can filter the logs as they are generated to extract and retain data provenance semantics. The provenance is represented as typed graphs. Sufficient information is present to identify users, processes, files, and network connections in the system.</p><p>When intrusion detection systems use automatically generated provenance records, they are faced with the challenge of integrating the information from multiple sources first. This is because different sensors contain provenance information at distinct levels of abstraction, have different levels of completeness, and use separate sets of identifiers to refer to the same concepts.</p><p>In the case of the Android mobile device platform, the audit subsystem in the kernel can be configured to emit a stream of events that allow the details of the agents, processes, and artifacts to be reconstructed, resulting in graph G 1 = (V 1 , E 1 ). These details are collected when system calls occur from applications to the operating system kernel. In contrast, the Android Binder framework monitors communication between applications and operates at a higher level of abstraction, resulting in graph G 2 = (V 2 , E 2 ).</p><p>To understand the need for integrating these two sources of provenance, we can consider a small example. When an application sends a text message, the audit log will only record the ioctl() system call. The fact that a text message was sent is lost since this information is only present in data structures that are passed by reference. The values of such arguments are not recorded since this would introduce significant overhead for system call auditing. Binder operates at the abstraction level of Android applications. It can therefore observe not only that a text message was sent but what the message was.</p><p>By combining one source's global view of the kernel's audit trail with another source's detailed visibility into inter-application communication, it is possible to create a more comprehensible reconstruction of system activity from the integrated provenance. Such an integrated view can be created with a trust tolerance of ⌥ = 0, as in the speech processing case. In practice, ownership changes may be benign -for example, a file may be modified by multiple users. Such differences can be eliminated during integration by using higher values of ⌥. However, this can have unintended sideeffects as well. We defer further analysis till Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Implementation</head><p>SPADE <ref type="bibr">[13]</ref> is SRI's open source data provenance middleware. Its provenance kernel supports the simultaneous use of multiple reporter modules. Each such module can collect and report provenance about an independent activity domain. The kernel filters these provenance streams before committing them to persistent storage. Previously, we have implemented online provenance integration as filters in the kernel. Such online integration is useful for stream processing, such as aggregating provenance elements into abstracted versions <ref type="bibr" target="#b6">[8]</ref>.</p><p>Stream processing uses finite buffers that limit the history available to an integration algorithm. In contrast, offline provenance integration can operate on provenance graphs in their entirety. To augment SPADE's online filtering capability, we developed an offline provenance integration utility that implements Algorithm 1. SPADE supports representing data provenance graphs in a fragment of the Graphviz project's DOT language <ref type="bibr" target="#b4">[6]</ref>. SPADE's Graphviz Reporter takes as input a provenance graph in this language, and the kernel can be configured to emit output in this language with</p><formula xml:id="formula_11">graph : digraph [ ID ] '{' stmt_list '}' stmt_list : [ stmt [ ';' ] [ stmt_list ] ] stmt : node_stmt | edge_stmt | attr_stmt attr_stmt : (graph | node | edge) attr_list attr_list : '[' [ a_list ] ']' [ attr_list ] a_list : ID '=' ID [ (';' | ',') ] [ a_list ] edge_stmt : node_id '-&gt;' node_id [ attr_list ] node_stmt : node_id [ attr_list ]</formula><p>node_id : ID the Graphviz Storage. To integrate a pair of provenance graphs with the utility, they must be represented in the fragment of DOT shown in <ref type="figure" target="#fig_0">Figure 2</ref>. We have used SPADE on Android for a number of purposes, including system diagnosis <ref type="bibr" target="#b8">[10]</ref> and analyzing malware. Activity at the interface between applications and the operating system is recorded by the Android kernel's audit subsystem. SPADE uses this to collect system-wide provenance. However, interactions between applications occur through Binder, a user space message passing subsystem on Android. SPADE can treat this as a second source of provenance. Previously, whole system analysis required elements from the second source to be custom grafted into the provenance generated by the first. The provenance integration utility now allows this to be automated. We used a test workload generated by sending an SMS message on Android 4.2.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Evaluation</head><p>The need for provenance-only integration arises when a single underlying phenomenon is being reported on from multiple vantage points. Both of our case studies fall into this category. In this setting, the correctness of the integration can be judged by comparing the result to a reference model of the phenomenon. In our evaluation, we use knowledge of the semantics of the operating systems domain to validate the integration.</p><p>It is worth noting that provenance integration may also be used when independent data sets are combined. However, such integration is limited by the extent to which the semantics of the annotations are related. If the accompanying provenance records are judged to have compatible schema, the metric used to establish this can be applied to validate integration correctness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Integration as Abstraction</head><p>We hypothesized that as graphs were increasingly integrated (using lower thresholds of matching), similar types of vertices would be collapsed together into unified vertices, effectively performing conceptual abstraction. We studied this by varying the threshold matching ⌧ and looking for inflection points in the size of the integrated graph, shown in <ref type="figure" target="#fig_1">Figure 3</ref>, and the integration cost ⇣, shown in <ref type="figure" target="#fig_2">Figure 4</ref>. A high threshold of matching ensures that no abstraction occurs. Only vertices that are very similar can be combined into a single vertex in the integrated graph. When the threshold of matching ⌧ is 8 (which is the maximum number of annotations), no integration is seen in <ref type="figure" target="#fig_1">Figure 3</ref>.</p><p>As ⌧ drops to 6, vertices corresponding to different threads in a single process are combined together. Note that process vertices initially have eight annotations for the vertex type, program name, owner, owner group, process identifier, parent process, thread group, and the command line used to invoke the program.</p><p>When ⌧ drops below 3, vertices that represent different versions of the same file are combined together. Note that artifact vertices initially have three annotations for the vertex type, filesystem path, and last modification time.</p><p>Recall that the cost of integrating provenance graphs arises from the conflation of agents that control processes. As more vertices with different owners are combined together, the integration cost grows.</p><p>If the graph size shrinks but the integration cost remains the same, vertices with the same owner are being integrated (as seen when ⌧ drops from 7 to 6 in <ref type="figure" target="#fig_1">Figures 3 and 4)</ref>. As the threshold of matching ⌧ drops below 6 in <ref type="figure" target="#fig_2">Figure 4</ref>, the integration cost starts to grow. When ⌧ drops below 4, the cost increases significantly because unrelated process vertices are being combined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fidelity of Attribution</head><p>A significant reason for capturing, storing, and querying provenance is to be able to correctly attribute ownership of data and its antecedents. When integration conflates ownership information, the utility of the provenance decreases. This motivated us to study the effect of varying the tolerance to ownership conflation, as specified by ⌥, when integrating provenance records.</p><p>In this case study, the ownership of a process is defined by its user, group, and thread group. If all three are identical, the cost of integrating process vertices is 0. As more ownership elements differ, the cost of integration grows. For example, if a pair of process vertices have different thread groups but the same user and group, the cost of merging them is 1. Similarly, if 1" 2" 3" 4" 5" 6" 7" 8" 9" <ref type="figure">Figure 5</ref>. As the threshold of matching ⌧ increases, more vertices can be integrated resulting in fewer distinct ones. When the tolerance of trust ⌥ is increased more vertices with different owners can be integrated, resulting in fewer distinct vertices after integration (for a given value of ⌧ ).</p><p>they have the same group but different users and thread groups, the cost of integrating them is 2. Unlike the basic integration algorithm, which tries to discover an optimal threshold of matching ⌧ , the fast integration algorithm takes ⌧ as a parameter. A pair of process vertices will only be integrated if they have at least ⌧ annotations in common and the cost of integration is no greater than the trust tolerance ⌥.</p><p>When an infinite tolerance is used, the integration cost is effectively ignored. As ⌧ increases, fewer process vertices can be matched. This is seen in the plot for ⌥ = 1 in <ref type="figure">Figure 5</ref>, where the number of distinct process vertices after integration grows with ⌧ .</p><p>Using ⌥ = 0 specifies that no loss of fidelity of attribution information will be tolerated. So only vertices and edges with non-ownership information that is close enough (as specified by ⌧ ) can be integrated. As ⌧ increases (for a given ⌥), more vertices can be matched, resulting in fewer distinct vertices after integration. Note that the drop in the resulting number of vertices always has a floor below based on the count when ⌥ = 1 (since at this point the matching cost does not matter).</p><p>When we are willing to tolerate lower fidelity attribution, we can obtain more aggressive provenance-only integration. As <ref type="figure">Figure 5</ref> illustrates, in practice it is best to select the lowest tolerance ⌥ that yields an acceptable level of integration. This will maintain the maximum fidelity of attribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Related Work</head><p>The need to integrate data arises in a wide variety of contexts. It has given rise to an extensive literature on techniques to address the problem in various settings, such as relational databases, the semantic web, and logic programming environments. Doan et al. <ref type="bibr" target="#b3">[5]</ref> cover a broad set of approaches in their text on the topic, including some that apply to integrating data provenance.</p><p>Provenance metadata differs from generic data in multiple respects. It is structured, may be manually generated, often arrives in-order and is only appended to. These and other properties provide both challenges and opportunities for integrating provenance metadata. In earlier work, we have studied policy-based approaches for provenance integration <ref type="bibr" target="#b6">[8]</ref>. Others have studied it in the context of the semantic web <ref type="bibr" target="#b11">[14]</ref>, Grid computing <ref type="bibr" target="#b12">[15]</ref>, interoperability of systems <ref type="bibr" target="#b0">[1]</ref>, and sharing provenance across organizations <ref type="bibr" target="#b1">[2]</ref>.</p><p>Our provenance-only work aims to be agnostic to the system domain, provides an optimization algorithm to effect the integration, and evaluates integration as a means of abstraction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>We described a framework for integrating provenance only. The need for this arises when multiple provenance traces (with different properties, such as temporal fidelity, monitored aspects, or abstraction levels) are collected for the same underlying phenomenon. We provided a provenance-only integration algorithm that merges provenance elements (vertices or edges) with sufficiently similar annotations (as defined by userspecified thresholds). It seeks to avoid integrating elements with different owners by imposing a cost for doing so. By finding the lowest thresholds that suffice for a given cost, provenance-only integration can be viewed as an optimization problem.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Graphviz [9], created by AT&amp;T Research for graph visualization, defines the DOT language [6]. SPADE supports the above fragment of the grammar for input and output. "Terminals are shown in bold font and nonterminals in italics. Literal characters are given in single quotes. Parentheses ( and ) indicate grouping. Square brackets [ and ] enclose optional items. Vertical bars | separate alternatives." [6] An ID can be an alphanumeric string or a numeral.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. A lower threshold of matching ⌧ allows vertices with fewer common annotations to be combined together. This results in a smaller provenance graph with fewer distinct vertices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. The integration cost ⇣ drops as fewer vertices with different owners are combined together (when the threshold of matching ⌧ is increased).</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank the reviewers for their useful comments.</p><p>This material is based upon work supported by the National Science Foundation under Grant IIS-1116414. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the National Science Foundation.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elaine</forename><surname>Angelino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Uri</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Holland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Macko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Margo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Margo</forename><surname>Seltzer</surname></persName>
		</author>
		<title level="m">Provenance integration requires reconciliation, 3rd USENIX Workshop on Theory and Practice of Provenance</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Getting it together: Enabling multiorganization provenance exchange, 3rd Workshop on Theory and Practice of Provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adriane</forename><surname>Chapman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barbara</forename><surname>Blaustein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Len</forename><surname>Seligman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The complexity of theorem-proving procedures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd ACM Symposium on Theory of Computing</title>
		<imprint>
			<date type="published" when="1971" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Principles of data integration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anhai</forename><surname>Doan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alon</forename><surname>Halevy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zachary</forename><surname>Ives</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<publisher>Elsevier</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dot</forename><surname>Graphviz</surname></persName>
		</author>
		<ptr target="http://www.graphviz.org/content/dot-language" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Subgraph isomorphism in planar graphs and related problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Eppstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">6th ACM-SIAM Symposium on Discrete Algorithms</title>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Policy-based integration of provenance metadata</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Gehani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawood</forename><surname>Tariq</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Basim</forename><surname>Baig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tanu</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th IEEE International Symposium on Policies for Distributed Systems and Networks</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Graphviz</surname></persName>
		</author>
		<ptr target="http://www.graphviz.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathaniel</forename><surname>Husted</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sharjeel</forename><surname>Qureshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawood</forename><surname>Tariq</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Gehani</surname></persName>
		</author>
		<title level="m">Android Provenance: Diagnosing Device Disorders, 5th USENIX Workshop on the Theory and Practice of Provenance (TaPP)</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The Open Provenance Model core specification (v1.1), Future Generation Computer Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luc</forename><surname>Moreau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Clifford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juliana</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yolanda</forename><surname>Gil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Groth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joe</forename><surname>Futrelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Natalia</forename><surname>Kwasnikowska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><surname>Miles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Missier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yogesh</forename><surname>Simmhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Stephan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Van Den Bussche</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
				<ptr target="http://www.speech.sri.com/projects/GALE/" />
		<title level="m">Novel Information Gathering and Harvesting Techniques for Intelligence in Global Autonomous Language Exploitation</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Trustworthiness assessment of knowledge on the semantic sensor web by provenance integration, Trust Computing and Assurance Workshop</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denise</forename><surname>Umuhoza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robin</forename><surname>Braun</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A provenance-integration framework for distributed workflows in Grid environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jing</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fan</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlo</forename><surname>Torniai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amol</forename><surname>Bakshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Viktor</forename><surname>Prasanna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Grid and Utility Computing</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
