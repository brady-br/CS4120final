<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:24+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fine-grained provenance for linear algebra operators</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhepeng</forename><surname>Yan</surname></persName>
							<email>zhepeng@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Val</forename><surname>Tannen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zachary</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
							<email>zives@cis.upenn.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">University of Pennsylvania</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Fine-grained provenance for linear algebra operators</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Provenance is well-understood for relational query operators. Increasingly , however, data analytics is incorporating operations expressed through linear algebra: machine learning operations, network centrality measures, and so on. In this paper, we study prove-nance information for matrix data and linear algebra operations. Our core technique builds upon provenance for aggregate queries and constructs a K−semialgebra. This approach tracks prove-nance by annotating matrix data and propagating these annotations through linear algebra operations. We investigate applications in matrix inversion and graph analysis.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>For many years, data provenance was modeled purely as graphs capturing dataflows among "black box" operations: this representation is highly flexible and general, and has ultimately led to the PROV-DM standard. However, the database community has shown that fine-grained provenance with "white-box" operations <ref type="bibr" target="#b2">[3]</ref> (specifically, for relational algebra operations) enables richer reasoning about the relationship between derived results and data provenance. The most general model for relational algebra queries, provenance semirings <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b0">1]</ref>, ensures that equivalent relational algebra expressions, as produced by a query optimizer, have equivalent provenance encodings. Moreover, there is a natural means of computing trust <ref type="bibr" target="#b5">[6]</ref> and authoritativeness <ref type="bibr" target="#b15">[16]</ref> scores for data, using provenance semiring expressions. Provenance can even be used to support incremental updates to views <ref type="bibr" target="#b5">[6]</ref>. Finally, there are probabilistic mechanisms for learning weights or authoritativeness scores for different provenance tokens in the semiring model <ref type="bibr" target="#b15">[16]</ref>.</p><p>A natural question is whether the provenance semiring approach, to this point limited to variations on relational queries, can be extended to a greater subset of data analytics tasks, e.g., to other "bulk operations" over collections of data. We present a preliminary set of provenance primitives, for one such class of operations: those from linear algebra. Matrices and linear algebra are heavily used in many data analytics applications, including image detection, signal processing, network science, and machine learning. While provenance libraries have been developed for matrix operations <ref type="bibr" target="#b16">[17]</ref>, no techniques currently exist for automatically extracting provenance from the various operations, and for reasoning based on this provenance. Our work in this paper develops primitives for matrix opPermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.  erations such as addition, multiplication and inversion. We show building blocks towards applications in principal component analysis (PCA), frequently used for dimensionality reduction, and in computing PageRank-style scores over network graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Tracking matrix data</head><p>Consider a d×n matrix A, and, as is often the case in machine learning, consider an algorithm that begins by computing AA T . In a typical situation A records n samples from a d-dimensional feature space. Suppose we wish to track the provenance of the data by partitioning both the features and samples. In a very simple example the features might be of two types and we associate the provenance tokens x, respectively y, with these types of features.</p><p>Suppose also that the samples come from two sources and we associate the provenance tokens u, respectively v, with these sources. Again for simplicity, we assume that all the features associated with x correspond to adjacent rows, and similar for y, u, v. This partitions A into four submatrices B, C, D, E, see <ref type="figure" target="#fig_1">Figure 1</ref>.</p><p>Let x, y, u, v be from some set X of provenance tokens and let N[X] be the provenance semiring of polynomials developed in <ref type="bibr" target="#b6">[7]</ref>. Now we wish to annotate the submatrix B with the polynomial xu corresponding to its source and feature subset, and similarly C with xv, D with yu, and E with yv. From this, we will later want to track which sources and feature subsets were used to produce which portions of an output matrix.</p><p>Observe that</p><formula xml:id="formula_0">A = Sx B Tu + Sx C Tv + Sy D Tu + Sy E Tv</formula><p>with appropriate selectors Sx, Sy, Tu, Tv. Selectors (see Section 4) are certain matrices whose elements are 0 or 1, and serve like a "mask" specifying entries to exclude or include, respectively. In our case, let p, respectively q, be the number of rows of provenance x, respectively of provenance y, where p + q = d. Let also k, respectively l, be the number of columns of provenance u, respectively of provenance v, where k + l = n. The dimensions of the selectors are Sx : d × p, Sy : d × q, Tu : k × n, Tv : l × n. Each of them consists of an identity matrix adjacent to a zero matrix, see <ref type="figure" target="#fig_1">Figure 1</ref>. Note that the selectors do not contain data that is subject to provenance tracking. We used x, y, u, v as subscripts in the notation to make it easier to connect the formulas to the figure.</p><p>In this form we can annotate B, etc. with provenance polynomials. Indeed, let M be the many-sorted 1 ring of matrices of real numbers. In Section 3 we show how to embed M into a semialgebra of matrices annotated with polynomials, namely the tensor product N[X] ⊗ M. Indeed, B corresponds to 1 ⊗ B ∈ N[X] ⊗ M and annotation with xu ∈ N[X] corresponds to multiplication with scalars: xu * (1 ⊗ B) = xu ⊗ B. In turn, the selectors, since they do not contain data that needs to be tracked, remain with the neutral annotation, e.g., 1 ⊗ Sx. For simplicity we denote 1 ⊗ M with M for any matrix M . Hence</p><formula xml:id="formula_1">A = Sx (xu * B) Tu + Sx (xv * C) Tv + Sy (yu * D) Tu + Sy (yv * E) Tv</formula><p>The decomposition into submatrices using selectors is nicely compatible with transposition. Indeed we have:</p><formula xml:id="formula_2">A T = T T u (xu * B T ) S T x + T T u (yu * D T ) S T y + T T v (xv * C T ) S T x + T T v (yv * E T ) S T y</formula><p>Now to multiply AA T we can (as will be justified in Section 3) use any identity that is valid in matrix algebra (associativity, distributivity, etc.). We multiply two sums of four products each so that will give a sum of sixteen products. Let's just look at two of them</p><formula xml:id="formula_3">Sx(xu * B)TuT T u (yu * D T )S T y Sx(xv * C)TvT T v (yv * E T )S T y</formula><p>We will show in Section 4 that Tu T T u and Tv T T v are actually identity matrices. Moreover, it will follow from Section 3 that</p><formula xml:id="formula_4">(xu * B) (yu * D T ) = xyu 2 * BD T (xv * C) (yv * E T ) = xyv 2 * CE T</formula><p>With these observations it has become clear that</p><formula xml:id="formula_5">AA T = Sx(x 2 u 2 * BB T + x 2 v 2 * CC T )S T x + Sx(xyu 2 * BD T + xyv 2 * CE T )S T y + Sy(xyu 2 * DB T + xyv 2 * EC T )S T x + Sy(y 2 u 2 * DD T + y 2 v 2 * EE T )S T y</formula><p>Where are the other eight products? They become 0 since we show in Section 4 that Tu T T v and Tv T T u are actually 0 matrices! Finally, to illustrate the flexibility of the framework that we develop in Section 3 we remark that the terms of the expressions can often be rewritten to emphasize various contributions by provenance. For example we can rearrange the expression for AA T :</p><formula xml:id="formula_6">AA T = x 2 * (u 2 * SxBB T S T x + v 2 * SxCC T S T x ) + xy * [ u 2 * (SxBD T S T y + SyDB T S T x ) + v 2 * (SxCE T S T y + SyEC T S T x ) ] + y 2 * (u 2 * SyDD T S T y + v 2 * SyEE T S T y )</formula><p>3. The semialgebra of annotated matrices</p><p>The m×n real matrices for various m, n ≥ 1 form a many-sorted ring (M, +, ·, 0, I). As usual with matrices, when we write A + B or CD we will assume that the sorts (dimensions) of A, B and C, D are such that the operations are defined.</p><p>1 Because matrices can be added or multiplied only when their dimensions are compatible.</p><p>Although in Section 2 we only made use of embedding the ring of matrices into a N[X]-semialgebra, the construction works more generally and this generality might prove useful in future research projects that use different provenance semirings, as in <ref type="bibr" target="#b5">[6]</ref>.</p><formula xml:id="formula_7">Let (K, + K , · K , 0 K , 1 K )</formula><p>be a commutative semiring. In previous work <ref type="bibr" target="#b0">[1]</ref> it was shown, using a tensor product-like construction, how to embed aggregation domains, (specifically, commutative monoids) into "most economical" K-semimodules that allow us to track the provenance captured by the elements of K. Here we consider matrices, a more complicated aggregation domain, since it has two operations (+ and ·) so we aim for a richer algebraic structure, that of (many-sorted) semialgebra. We shall embed M into a structure that, like M, forms a ring (K⊗M, +, ·, 0, I) (for simplicity we use for the operations the same notation we used for M). In addition, K⊗M forms a K-semialgebra, i.e., it also has * , a binary operation K × (K⊗M) → K⊗M that satisfies the following algebraic identities.</p><formula xml:id="formula_8">DEFINITION 1. ∀ k, k1, k2 ∈ K ∀ A, A1, A2 ∈ K⊗M k * (A1 + A2) = k * A1 + k * A2 (1) k * 0 = 0 (2) (k1 + K k2) * A = k1 * A + k2 * A (3) 0 K * A = 0 (4) (k1 · K k2) * A = k1 * (k2 * A) (5) 1 K * A = A (6) (k1 * A1)(k2 * A2) = (k1 · K k2) * (A1A2) (7) (In particular, (K⊗M, +, 0, * ) is a (many-sorted) K-semimodule.) In Section 2 we used the identity (xu * B) (yu * D T ) = xyu 2 * BD T .</formula><p>Indeed, this is an instance of semialgebra axiom <ref type="formula">(7)</ref> above.</p><p>We proceed to sketch the construction of K⊗M.</p><p>Tensor product construction We start with K×M, sorted just like M, denote its elements k⊗A instead of k, A and call them "simple tensors". Next we consider the set Bag(K×M) of finite bags of such simple tensors, i.e., functions f : K×M → N whose support, i.e., supp(f ) = {k⊗A ∈ K×M | f (k⊗A) = 0}, is finite. Let be the usual bag union and ∅ + be the empty bag. For f1, f2 ∈ Bag(K×M) define the ("convolution") product as</p><formula xml:id="formula_9">f1 f2 = λ(k⊗A). f1(k1⊗A1)f2(k2⊗A2)</formula><p>where the sum is over all k1⊗A1 ∈ supp(f1) and k2⊗A2 ∈ supp(f2) such that k1 · K k2 = k and A1A2 = A. 2 Like matrix multiplication, is not commutative.</p><formula xml:id="formula_10">PROPOSITION 2. (Bag(K×M), , , ∅ + , 1 K ⊗I) is a semiring.</formula><p>Define a function ι : M → Bag(K×M) such that ι(A) = 1 K ⊗A (actually, the singleton bag with element 1 K ⊗A). It is easy to see that ι is injective and is a homomorphism with respect to multiplication. However, it is not a homomorphism with respect to addition. This will be one of the things we will fix when we take equivalence modulo a certain congruence, but there will be a price to pay: ι will not stay injective, in general. Next we define multiplication with scalars from K on Bag(K×M):</p><formula xml:id="formula_11">k * f = λ(k ⊗A). (k · K k ) ⊗ A PROPOSITION 3. (Bag(K×M), , , ∅ + , 1 K ⊗I) satisfies axioms</formula><p>(1,2,5,6,7) of Definition 1 but not axiom (3) or axiom (4). Thus we have found that the algebraic structure on bags does not identify enough elements to insure that it is a K-semialgebra and that ι is a semiring homomorphism. Thus, we will enforce the desired identifications by quotienting with a congruence. Let ∼ be the smallest congruence on Bag(K×M) with respect to , and * that satisfies (for all k1, k2, A, A1, A2):</p><formula xml:id="formula_12">(k1 + K k2)⊗A ∼ k1⊗A k2⊗A (8) 0 K ⊗A ∼ ∅ + (9) 1 K ⊗(A1 + A2) ∼ 1 K ⊗A1 1 K ⊗A2 (10) 1 K ⊗0 ∼ ∅ +<label>(11)</label></formula><p>Denote by K⊗M = Bag(K×M)/ ∼. Its elements could be called "tensors" since they are equivalence classes of bags of simple tensors modulo ∼ and this whole construction generalizes a tensor product construction (to the "semi-" situation). Because ∼ is a congruence with respect to , and * , corresponding operations are defined on the quotient set. As before, we abuse notation by denoting them again by +, ·, * , We also use ι again for the function that maps every A ∈ M to the ∼-equivalence class of 1 K ⊗A.</p><p>PROPOSITION 4. K⊗M is a K-semialgebra and ι : M → K⊗M is a semiring homomorphism satisfying the following universality property: for any K-semialgebra S and any semiring homomorphism f : M → S there exists a unique homomorphism of</p><formula xml:id="formula_13">K-semialgebras f * : K⊗M → S such that f = f * • ι.</formula><p>Therefore , K⊗M is the "most economical" (freely generated) Ksemialgebra that M can be embeded into. As discussed in <ref type="bibr" target="#b0">[1]</ref>, ι is not injective, in general. However, it is injective for</p><formula xml:id="formula_14">K = N[X].</formula><p>This justifies the identification of the annotated matrices 1⊗A with A in Section 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Provenance propagation by decomposition</head><p>We have seen in Section 2 an example, in which a matrix is decomposed into several contiguous blocks, each annotated with a provenance polynomial. We have also illustrated there how to propagate provenance under several operators. However, elements with the same annotation are not necessarily adjacent. In this section, we generalize provenance decomposition and propagation to noncontiguous cases. We will build upon the notion of selector matrix.</p><p>DEFINITION 5. A matrix S is a selector matrix if it is a zero matrix or can be constructed from inserting rows and columns of zeros into an identity matrix. A selector matrix has at most a 1 in each row and in each column. Fix a matrix Am×n. We consider its submatrix defined by a set of rows and columns, as follows. Let R = {r1, r2, · · · , r m } consist of m distinct row indices and C = {c1, c2, · · · , c n } consist of n distinct column indices, where ∀i, ri ≤ ri+1 and ∀j, cj ≤ cj+1. Let A be such matrix that A (i, j) = A(i, j) when i ∈ R ∧ j ∈ C, and A (i, j) = 0 otherwise. Let As be such matrix that As(i, j) = A(ri, cj). There exist selectors S and T such that</p><formula xml:id="formula_15">SAsT = A ,</formula><p>where row ri of S has a 1 in column i and column cj of T has a 1 in row j. We visualize S below (T is similarly structured).</p><formula xml:id="formula_16">S m×m =                   O (r 1 −1)×n r1 1 0 · · · 0 O (r 2 −r 1 −1)×n r2 0 1 · · · 0 . . . . . . . . . . . . r m 0 · · · 0 1 O (m−r m )×n PROPOSITION 6</formula><p>. Given a matrix Am×n, let {(Ri, Ci)} be a set of pairs of rows and columns such that {Ri} forms a partition of <ref type="bibr">[1.</ref>.m] and {Ci} forms a partition of [1..n]. Let Ai be the submatrix defined by Ri and Ci (as above). Then, there exist selector matrices Si and Ti such that</p><formula xml:id="formula_17">A = i SiAiTi.</formula><p>This decomposition method enables analysis of provenance propagation under various linear operations. For example, </p><formula xml:id="formula_18">A T = ( i SiAiTi) T = i (SiAiTi) T = i T T i A T i S T i . For multiplying two matrices A = i SiAiTi and B = j UjBjVj, AB = i,j SiAi(TiUj)BjVj.<label>(12)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Application: matrix inversion</head><p>Tracking provenance through determinant computation and through exact matrix inversion seems to involve provenance that is too complex to be easily usable. Instead, we illustrate in the following example the Jacobi method <ref type="bibr" target="#b3">[4]</ref> for iteratively computing solutions to systems of linear equations. <ref type="bibr" target="#b2">3</ref> We consider the solution to (A + B)x = b, where A and B are from two sources, with provenance p and q, respectively:</p><formula xml:id="formula_19">A = p * 2 1 1 2 , B = q * 0 0 −2 0 , b = 1 −1</formula><p>The iterative method first splits A + B = M − N , where ] T . Provenance tracking also enables incremental deletion propagation: when p = 1, q = 0, we have</p><formula xml:id="formula_20">M = p * 2 0 0 2 , N = p * 0 −1 −1 0 + q * 0 0 2 0 Then it iteratively computes u k+1 = M −1 N u k + M −1 b. Suppose that we start from u0 = [0, 0] T , then u1 = p * 1 2 − 1 2 , u2 = p * 1 2 − 1 2 + p 3 * 1 4 − 1 4 + p 2 q * 0 − 1 2 , · · ·</formula><formula xml:id="formula_21">u k = [1 − 1 2 k , −1 + 1 2 k ] T .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Application: largest eigenvalue</head><p>In principal component analysis (PCA), the largest eigenvalue describes the amount of variance of data projected onto the corresponding eigenvector. Here we illustrate provenance tracking in computing the largest eigenvalue using the power method. Suppose that V is the following matrix:</p><formula xml:id="formula_22">V = p * 2 1 1 2 + q * 3 1 1 3 ,</formula><p>The first summand's eigenvalues λ1 = 3 and λ2 = 1 while the second's are λ1 = 4 and λ2 = 2. The power method starts <ref type="bibr" target="#b2">3</ref> Matrix inversion can be reduced to solving systems of linear equations with a vector u0, iteratively computes ut+1 = V ut, and returns u 1 t +1 /u 1 t for some t . Starting from u0 = [2, 1] T , we have:</p><formula xml:id="formula_23">u T 2 = p 2 * [14, 13] T + pq * [38, 34] T + q 2 * [26, 22] T u T 3 = p 3 * [41, 40] T + p 2 q * [165, 161] T + pq 2 * [222, 210] T + q 3 * [100, 92] T</formula><p>This procedure can continue, however, we shall use deletion propagation to verify that three iterations give a pretty good approximation. With p = 1 and q = 0 we have u 1 3 /u 1 2 = 41/14 ≈ 3, while with p = 0 and q = 1 we have u 1 3 /u 1 2 = 100/26 ≈ 4. We now add some annotations. Suppose that A and B are annotated with p1 and p2 respectively, to capture the coefficients (i.e., M = p1 * A + p2 * B). In addition, outgoing edges from nodes 1-3 are annotated with q1 and the outgoing edge from node 4 is annotated with q2. The annotated PageRank matrix is given by M = M0 + p1q1 * M1 + q2 * M2 + p2 * B, where</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Application: PageRank</head><formula xml:id="formula_24">M0 = [1, 1, 1, 1, 1] T [0, 0, 0, 0, 1/5] M1 =         0 1/2 1/3 0 0 1/2 0 1/3 0 0 1/2 1/2 0 0 0 0 0 0 0 0 0 0 1/3 0 0 M2 = [0, 0, 0, 0, 1] T [0, 0, 0, 1, 0]</formula><p>The power method starts from an initial PageRank score vector ] T and iteratively computes vt+1 = M vt. We can track provenance as in previous examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Related work</head><p>The core building block of our algebraic construction is based on provenance semirings <ref type="bibr" target="#b6">[7]</ref>. Our framework goes beyond provenance for aggregate queries <ref type="bibr" target="#b0">[1]</ref>, by constructing a K-semialgebra instead of just a K-semimodule. Although there are several array database management systems such as SciDB <ref type="bibr" target="#b14">[15]</ref> and RasDaMan <ref type="bibr" target="#b1">[2]</ref>, only until recently have various aspects of provenance been investigated. This line of work includes APIs for encoding and querying for lineage <ref type="bibr" target="#b16">[17]</ref> and supporting uncertain array data <ref type="bibr" target="#b13">[14]</ref>. Our work differs in automatically tracking provenance from the operations, and in preserving the semantics of the matrix operations.</p><p>Many systems support distributed machine learning based on MapReduce or iterative linear algebra programs <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b8">9]</ref>. In addition, LINView <ref type="bibr" target="#b12">[13]</ref> proposes methods for incremental computation of iterative linear algebra programs when there are only small changes (low-rank updates) to input matrices. Generalizations of our preliminary work could be incorporated into such platforms based on their linear algebra operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Contributions and future work</head><p>This paper has presented the first steps towards a semanticspreserving notion of fine-grained provenance for linear algebra operations. While more work needs to be done, we believe there is great promise for automatically tracking provenance in a wide variety of applications. In the future, building upon our basic construction, we seek to investigate provenance for more complex linear algebra operators. We will also study how to implement this framework in a real system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Appendix</head><p>We first prove Proposition 2.</p><p>LEMMA 8. Let X be a set. <ref type="figure">(Bag(X)</ref>, , ∅ + ) is a commutative monoid. Moreover, every non-empty bag can be uniquely expressed a a bag union of singletons, specifically, as the union of all its possibly repreated elements, i.e., A = ai for all ai ∈ supp(A), each ai appearing in the union A(ai) times. Proof We show that the following three axioms hold for any A, B, C ∈ Bag(X).</p><p>•</p><formula xml:id="formula_25">(commutativity) A B = λx. A(x) + B(x) = λx. B(x) + A(x) = B A. • (associativity) (A B) C = (λx. A(x) + B(x)) C = λx. (A(x) + B(x)) + C(x) = λx. A(x) + (B(x) + C(x)) = A (λx. B(x) + C(x)) = A (B C). • (identity for plus) Since ∅ + (x) = 0 for any x, we have A∅ + = ∅ + B = ∅ + .</formula><p>Therefore, (Bag(X), , ∅ + ) is a commutative monoid.</p><p>Moreover, it follows immediately that for any bag A we have</p><formula xml:id="formula_26">A = a∈supp(A)</formula><p>A(a) a (where for integer n &gt; 0 and bag B, n B is short for the of n copies of B). For the uniqueness of this representation suppose that for some bag A we have A = ai where the ai's are singleton bags as well as elements of X (in view of our abuse of notation). Then supp(A) must consist exactly of the ai's and each ai appears in the exactly A(ai) times.</p><p>LEMMA 9. Let M be a monoid and A, B ∈ Bag(M ).</p><formula xml:id="formula_27">(i) supp(A B) is finite. (ii) ( ai) ( bj) = ai · M bj.</formula><p>(iii) For any finite Y, Z ⊆ M such that supp(A) ⊆ Y and supp(B) ⊆ Z we have</p><formula xml:id="formula_28">A B = λx. A(y)B(z)</formula><p>where the sum is over all y ∈ Y and z ∈ Z such that y· M z = x.</p><p>Proof For each part: (i) Let x ∈ M . Because N is "positive", if (A B)(x) = 0 then at least one of the numbers in the sum A(y)B(z) is non-zero so there exist y ∈ supp(A) and z ∈ supp(B) such that y · M z = x. Therefore, · M defines a surjection from supp(A) × supp(B) to supp(A B) which makes the latter finite.</p><p>(ii) To check this, observe that an x appears in ai · M bj exactly as many times as there are appearances of a y in ai and of a z's in bj such that x = y · M z.</p><p>(iii) Indeed, each y ∈ Y \ supp(A) has A(y) = 0 and thus contributes 0 to the sum. Same with z ∈ Z \ supp(B).</p><formula xml:id="formula_29">PROPOSITION 2. (Bag(K×M), , , ∅ + , 1 K ⊗I) is a semiring.</formula><p>Proof Let M be K×M. We have already seen (Lemma 8) that (Bag(M ), , ∅ + ) is a commutative monoid. We need to show that (Bag(M ), , 1 M ) is also a monoid (not necessarily commutative), that distributes over , and that ∅ + is the "zero" element for . Let A, B and C be any elements in Bag(M ).</p><p>• We now show that (Bag(M ), , 1 M ) is a monoid as well, in other words, that is associative and that 1 M is the "neutral element" for . We have</p><formula xml:id="formula_30">(A B) C = λx. (u· M v)· M w=x A(u)B(v)C(w) = λx. u· M (v· M w)=x A(u)B(v)C(w) = A (B C).</formula><p>We also have, because supp(1 M ) = {1 M }:</p><formula xml:id="formula_31">A 1 M = λx. y· M 1 M =x A(y) 1 = λx. A(x) = A,</formula><p>and similarly 1 M A = A.</p><p>• For distributivity, we have</p><formula xml:id="formula_32">A (B C) = λx. u· M v=x A(u)(B(v) + C(v)) = λx. u· M v=x A(u)B(v) + A(u)C(v) = (A B) (A C).</formula><p>where we make us Lemma 9, Part (iii), to extend the unions from supp(B) and supp(C) to supp(B) ∪ supp(C) = supp(B C). Similarly (A B) C = (A C) (B C).</p><p>• Since supp(∅ + ) is empty, we have A ∅ + = ∅ + B = ∅ + .</p><p>Hence, (Bag(M ), , , ∅ + , 1 M ) is a semiring.</p><p>We now proceed to Proposition 3.</p><p>LEMMA 10. The function ι : M → Bag(K × M) that maps s ∈ M to the singleton bag with elements 1K ⊗s is injective and is a homomorphism between the multiplicative structures of M and Bag(K × M).</p><p>Proof ι is clearly injective. Let s1, s2 ∈ M, we have Proof We show the following for any k, k ∈ K, A = ki⊗si ∈ Bag(K × M) and A = k j ⊗s j ∈ Bag(K × M).</p><formula xml:id="formula_33">ι(s1)ι(s2) = (1K ⊗s1)(1K ⊗s2) = (1K · K 1K )⊗(s1 · M s2) = 1K ⊗(s1 · M s2) = ι(s1 · M s2).</formula><p>• k * (A A ) = (k * A) (k * A ) directly by definition of * .</p><p>• k * ∅ + = ∅ + also directly by definition of * .</p><p>• We have</p><formula xml:id="formula_34">(k+ K k ) * A = ((k+ K k )· K ki)⊗si = (k· K ki+ K k · K ki)⊗si</formula><p>and we also have</p><formula xml:id="formula_35">(k * A) (k * A) = (k · K ki)⊗si (k · K ki)⊗si</formula><p>To complete the verification of axiom (3) we would like to have (k1 + K k2)⊗s = k1⊗s k2⊗s but this does not hold in general.</p><p>• We have 0K * A = (0K · K ki)⊗si = 0K ⊗si. To complete the verification of axiom (4) we would like to have</p><formula xml:id="formula_36">0 K ⊗s = ∅ + but again this does not hold in general. • (k · K k ) * A = ((k · K k )· K ki)⊗si = (k · K (k · K ki))⊗si = k * (k · K ki)⊗si = k * (k * A). • 1K * A = (1K · K ki)⊗si = ki⊗si = A. • (k * A) A = ( i (k · K ki)⊗si) ( j k j ⊗s j ) = i,j ((k · K ki)⊗si)(k j ⊗s j ) = i,j ((k · K ki) · K k j )⊗(si · M s j ) = i,j (k · K (ki · K k j ))⊗(si · M s j ) = k * i,j (ki · K k j )⊗(si · M s j ) = k * (A A ) • A (k * A ) = ( i ki⊗si) ( j (k · K k j )⊗s j ) = i,j (ki⊗si)((k j · K k)⊗s j ) = i,j (ki · K (k · K k j ))⊗(si · M s j ) = i,j (k · K (ki · K k j ))⊗(si · M s j ) = k * (A A ).</formula><p>Note that for the last axiom we have made essential use of the fact that K is a commutative semiring. Finally, we prove Proposition 4.</p><p>PROPOSITION 4. K⊗M is a K-semialgebra and ι : M → K⊗M is a semiring homomorphism satisfying the following universality property: for any K-semialgebra S and any semiring homomorphism f : M → S there exists a unique homomorphism of</p><formula xml:id="formula_37">K-semialgebras f * : K⊗M → S such that f = f * • ι.</formula><p>Proof As is the case with any algebraic congruence, equational axioms that hold in the original structure continue to hold in the quotient structure. Therefore,</p><formula xml:id="formula_38">(K ⊗ M, + K⊗M , · K⊗M , 0 K⊗M , 1 K⊗M )</formula><p>is also a semiring, * K⊗M satisfies axioms (1,2,5,6,7) of semialgebras and ι is a homomorphism for the multiplicative structures. Moroever, after the quotienting, axioms (3,4) also hold as we have shown in the proof of Proposition 3 and ι is also a homomorphism for the additive structures because (8,9) now hold in K ⊗ M.</p><p>We now proceed to the second part. We use + S , · S , * S for operators in S and + K⊗M , · K⊗M , * K⊗M for operators in K ⊗ M. Define f * first on bags of simple tensors as follows</p><formula xml:id="formula_39">f * ( ki⊗si) = ki * S f (si).</formula><p>The first total sum uses + K⊗M and the second uses + S . Thus f * (ι(s)) = f * (1 K ⊗s) = 1 K * A f (s) = f (s). Then, we check that f * is a homomorphism with respect to + S , · S and * S , as follows.</p><p>•</p><formula xml:id="formula_40">f * (( ki⊗si) + K⊗M ( k j ⊗s j )) = ( ki * S f (si)) + S ( k j * S f (s j )) = f * ( ki⊗si) + S f * ( k j ⊗s j ). • f * (( ki⊗si) · K⊗M ( k j ⊗s j )) = f * ( i,j (ki⊗si) · K⊗M (k j ⊗s j )) = f * ( i,j (ki · K k j )⊗(si · M s j )) = i,j (ki · K k j ) * S f (si · M s j ) = i,j (ki · K k j ) * S (f (si) · S f (s j )) = i,j (ki * S f (si)) · S (k j * S f (s j )) = ( i (ki * S f (si))) · S ( j (k j * S f (s j ))) = f * ( ki⊗si) · S f * ( k j ⊗s j ). • For any k ∈ K, f * (k * K⊗M ( ki⊗si)) = f * ( (k · K ki)⊗si) = (k · K ki) * S f (si) = k * S ( ki * S f (si)) = k * S f * ( ki⊗si).</formula><p>This implies that for f * to preserve ∼ it suffices to preserve <ref type="bibr" target="#b7">(8,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b10">11)</ref>, which is checked as follows.</p><p>• f * ((k1 + K k2)⊗s) = (k1 + K k2) * S f (s) = k1 * S f (s) + S k2 * S f (s) = f * (k1⊗s + K⊗M k2⊗s)</p><formula xml:id="formula_41">• f * (0 K ⊗s) = 0 K * S f (s) = ∅ + = f * (0 K⊗M ). • f * (1 K ⊗(s1 + S s2)) = 1 K * S f (s1 + S s2) = 1 K * S (f (s1) + S f (s2)) = 1 K * S f (s1) + S 1 K * S f (s2) = f * (1 K ⊗s1 + K⊗M 1 K ⊗s2)</formula><p>• Since f is a semiring homomorphism, for any s we have f (s) = f (s + 0 S ) = f (s) + S f (0 S ), which yields that f (0 S ) must be ∅ + . Now,</p><formula xml:id="formula_42">f * (1 K ⊗0 S ) = 1 K * S f (0 S ) = ∅ + = f * (0 K⊗M ).</formula><p>Since f * preserves ∼ it can be defined as above by picking a representative from each equivalence class. Now let g : K⊗S → A be another K-semialgebra homomorphism such that g • ι = f . Then</p><formula xml:id="formula_43">g( ki⊗si) = g( ki * K⊗M (1 K ⊗si)) = ki * S g(ι(si)) = ki * S f (si) = f * ( ki⊗si)</formula><p>hence g = f * , thus verifying the uniqueness of f * .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>TaPP 2016 ,</head><label>2016</label><figDesc>June 8-9, 2016, Washington, DC. Copyright remains with the owner/author(s).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Provenance partitioning and its selectors</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. A sample graph. Consider the sample graph in Figure 2, with transition matrix</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>PROPOSITION 3 .</head><label>3</label><figDesc>(Bag(K×M), , , ∅ + , 1 K ⊗I) satisfies axioms (1,2,5,6,7) of Definition 1 but not axiom (3) or axiom (4).</figDesc></figure>

			<note place="foot" n="2"> These algebraic constructions are related to those of [11].</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Provenance for aggregate queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Amsterdamer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="153" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The multidimensional database system rasdaman</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Baumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dehmel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Furtado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ritsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Widmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGMOD Record</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Provenance in databases: Why, how, and where. Foundations and Trends in Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="379" to="474" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Introduction to numerical linear algebra and optimisation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">G</forename><surname>Ciarlet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Miara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-M</forename><surname>Thomas</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Systemml: Declarative machine learning on mapreduce</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ghoting</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Pednault</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Reinwald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sindhwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tatikonda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Vaithyanathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Update exchange with mappings and provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
		<idno>MS-CIS-07-26</idno>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
<note type="report_type">of Pennsylvania report</note>
	<note>Amended version available as Univ</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Provenance semirings</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PODS</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">The MADlib analytics library: or MAD skills, the SQL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Schoppmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Fratkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gorajek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Welton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Li</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<publisher>PVLDB</publisher>
			<biblScope unit="volume">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Cumulon: Optimizing statistical data analysis in the cloud</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Babu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Dryad: distributed data-parallel programs from sequential building blocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Birrell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fetterly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EuroSys</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="59" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Incremental query evaluation in a ring of databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Koch</surname></persName>
		</author>
		<idno>183766</idno>
	</analytic>
	<monogr>
		<title level="j">EPFL</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
<note type="report_type">Technical Report</note>
	<note>Extended version of the PODS 2010 paper</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">MLbase: A distributed machine-learning system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kraska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Talwalkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Duchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Griffith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Linview: incremental view maintenance for complex analytical queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Nikolic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Elseidy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Koch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Supporting data uncertainty in array databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Diao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Requirements for science data bases and scidb</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Becla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-T</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Ratzesberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">B</forename><surname>Zdonik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Learning to create data-integrating queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">P</forename><surname>Talukdar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Mehmood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Crammer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Pereira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Subzero: a fine-grained lineage system for scientific databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">GraphX: A resilient distributed graph system on Spark</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Xin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Graph Data Management Experiences and Systems</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Resilient distributed datasets: A fault-tolerant abstraction for in-memory cluster computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zaharia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chowdhury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mccauley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NSDI</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
