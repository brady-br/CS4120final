<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:01+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Scripting the cloud with Skywriting</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Derek</forename><forename type="middle">G</forename><surname>Murray</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge Computer Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Hand</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge Computer Laboratory</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Scripting the cloud with Skywriting</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Recent distributed computing frameworks-such as MapReduce, Hadoop and Dryad-have made it simple to exploit multiple machines in a compute cloud. However , these frameworks use coordination languages that are insufficiently expressive for many classes of computation , including iterative and recursive algorithms. To address this problem, and generalise previous approaches , we introduce Skywriting: a Turing-powerful, purely-functional script language for describing distributed computations. In this paper, we introduce the main features of Skywriting, and outline our novel cooperative task farming execution engine.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Recent frameworks for data-intensive computing have made it much easier to exploit multiple computers in parallel <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b9">11,</ref><ref type="bibr" target="#b16">18]</ref>. One reason for this success is that the frameworks provide a high-level interface that frees the user from concerns about sockets, remote procedure calls, data movement and machine failure. Instead, the user specifies the computation in a coordination language (such as Sawzall <ref type="bibr" target="#b20">[22]</ref>, Pig <ref type="bibr" target="#b19">[21]</ref>, Hive <ref type="bibr" target="#b22">[24]</ref> or DryadLINQ <ref type="bibr" target="#b24">[26]</ref>) that describes the data flow at a high level. While these languages are useful, there are important classes of algorithm that they cannot express. In this paper, we introduce Skywriting: a new coordination language that generalises the existing languages and increases their expressivity.</p><p>For example, others have observed that MapReduce and Dryad cannot express iterative computations <ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b15">17]</ref>. Such computations repeatedly apply the same algorithm in order to improve the current result until it meets a convergence criterion: the PageRank algorithm is a well-known example <ref type="bibr" target="#b8">[10]</ref>. Since the number of iterations is not known in advance, we need to express unbounded iteration, but existing frameworks and languages force the user to specify the entire computation when a job is submitted. Hence an additional driver program running on the client must ship data out of the cluster to evaluate convergence, and, if required, submit multiple jobs: this leads to additional job submission latency. Moreover, dividing a computation into several jobs reduces the opportunity for high-level optimisations <ref type="bibr" target="#b18">[20,</ref><ref type="bibr" target="#b23">25]</ref>.</p><p>We distinguish between coordination languages and task languages for data-intensive computing. The task language is a general-purpose programming language that is used to express an individual step in a larger computation. For example, the normal task language in Hadoop is Java, which is used to implement the map() and reduce() functions, but other languages may be used <ref type="bibr" target="#b1">[2]</ref>. The task language is usually Turing-powerful. By contrast, existing coordination languages are less expressive, as they only describe a static, acyclic graph of tasks and their dependencies.</p><p>In order to add unbounded iteration to the coordination language, we must make it Turing-powerful. As a proof-of-concept, we have developed the Skywriting script language (Section 2). Skywriting is a dynamicallytyped, purely-functional language, which provides an executable representation of a distributed job. A script can create new tasks asynchronously, evaluate data dependencies and perform unbounded (while-loop) iteration. This enables Skywriting to describe a more general class of distributed computations than previous languages.</p><p>We have also developed a new execution engine that can execute Skywriting scripts. Our system must support dynamically growing jobs, and therefore we have developed cooperative task farming (Section 3). In a typical task-farming architecture, the master has complete control over the set of tasks that are assigned to workers. Our system allows workers to spawn additional tasks in a manner similar to Cilk <ref type="bibr" target="#b7">[9]</ref>. Hence the workers cooperate with the master in order to complete a distributed computation. We describe our prototype system, and how it can be used to execute Skywriting scripts. 21 input_data = [ref("file://cluster-1-37/input0"), 22</p><p>ref("file://cluster-2-23/input1"), <ref type="bibr" target="#b21">23</ref> ...];</p><p>24 return iterative_alg(input_data); <ref type="figure">Figure 1</ref>: Iterative computation implemented in Skywriting. input data is a list of n input chunks (e.g. of a matrix), and curr is initialised to a list of n partial results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Skywriting language</head><p>Skywriting is a Turing-powerful language for describing distributed computations. In order to maximise developer familiarity, we have designed our language to resemble JavaScript, with first-class functions, lexical scoping and dynamic typing <ref type="bibr" target="#b10">[12]</ref>. However, in order to make the language purely functional, we impose the restriction that captured variables and parameters are readonly. This restriction makes it straightforward to parallelise the execution of a Skywriting script, which we discuss in Section 3. <ref type="figure">Figure 1</ref> shows an example of Skywriting syntax for an iterative computation. The iterative alg() function takes a list of input data, makes an initial estimate of the result, and repeatedly spawns tasks to process the data until convergence is reached. The example highlights three novel features of our language, which we discuss in the remainder of this section. The input data are provided as references ( §2.1). Distributed computation is initiated by spawn()-ing tasks ( §2.2). Finally, data dependencies are dereferenced using the * -operator ( §2.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">References</head><p>Skywriting uses references to add a layer of indirection between the scripting language and the data-intensive processing. In the simplest case, a reference is a name for data that is stored in the cluster. It serves the same role as a file name in GFS <ref type="bibr" target="#b12">[14]</ref>, or a DryadTable object in DryadLINQ <ref type="bibr" target="#b24">[26]</ref>. This indirection enables the language to describe manipulations of a large volume of data without loading it all into memory.</p><p>A reference is created by calling the built-in ref() function, which takes one or more URIs that refer to the data <ref type="figure" target="#fig_0">(Figure 1, lines 21-23)</ref>. By providing multiple URIs, a reference can point to several instances of the same data, which enables data replication. Although the ref() function allows a script to refer to arbitrary data, we expect that most users will use library functions to manage collections of references, in a similar manner to how a DryadTable represents a list of data partitions in DryadLINQ <ref type="bibr" target="#b24">[26]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Task spawning</head><p>The built-in spawn() function asynchronously spawns a new task with the given arguments. Its arguments include the function to be invoked, and optional arguments. It returns one or more future references, which behave like references ( §2.1), but may refer to data that have not yet been computed. This feature is based on explicit futures <ref type="bibr" target="#b13">[15]</ref>, which become determined only when dereferenced ( §2.3).</p><p>A task is executed using our cooperative task farming system, described in Section 3. Typically, one or more of the arguments to spawn() will be a reference. If any of the arguments is a future reference, the spawned task will not be scheduled until all of the referenced data has been computed by earlier tasks: thus the script implicitly builds an acyclic graph of task dependencies ( §3.1). Once the task is runnable, it is allocated to a worker, and the framework ensures that all referenced data are available locally at the worker. We use a multiple-queue scheduler to ensure that a task usually runs "close" to its input, which reduces the volume of data that must be transferred across the network. In the future, we will investigate more advanced scheduling algorithms, including flow network approaches <ref type="bibr" target="#b17">[19]</ref>, and decentralised work stealing <ref type="bibr" target="#b7">[9]</ref>.</p><p>Task spawning does not compromise the functional purity of our language. As in other systems, we assume that individual task execution-which may involve code written in other languages-is deterministic and idempotent <ref type="bibr" target="#b9">[11,</ref><ref type="bibr" target="#b16">18]</ref>. Furthermore, the execution of a task has no effect on the script's execution context. However, repeated execution of a task with the same arguments may lead to generating two different references to identical data. This will not affect correctness, but reduces the efficiency of the system, by wasting storage and ignoring opportunities for local execution. Therefore, we are investigating ways of memoising task execution, in a manner similar to cached function calls in Vesta <ref type="bibr" target="#b14">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Dereferencing</head><p>Skywriting's most powerful feature is its ability to include data dependencies in the computation. As Figure 1 (line 17) shows, the language includes a * -operator, which dereferences the result of a previous task (in this case, a convergence test). When the operator is applied to a reference, the referenced value can be used like any other Skywriting value. In particular, it can be used in loops and conditional statements, which enables datadependent control-flow. We borrow the syntax from C, because a reference in Skywriting is conceptually similar to a pointer in C and its related languages.</p><p>When a variable is dereferenced, the corresponding data must be fetched and brought into the script environment. Since Skywriting was not designed to be a high-performance language, it is impractical to dereference large volumes of data. Therefore, the example in <ref type="figure">Figure 1</ref> spawns an additional task that combines the partial results from the distributed computation, and returns a single boolean value. In order to dereference the result, the referenced data must have been written in a compatible serialisation format: the present implementation uses JavaScript Object Notation (JSON), due to its similarity with the Skywriting syntax, and the availability of parsers and serializers for many programming languages <ref type="bibr">[4]</ref>. <ref type="figure">Figure 1</ref> shows the * -operator being applied to a future reference ( §2.2). Since spawn()-ed tasks execute asynchronously, the result may not yet have been produced when the dereference attempt is made. We support this case by blocking the current task and scheduling a continuation ( §3.4). The * -operator thereby provides implicit synchronisation with other tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Other features</head><p>As we have developed Skywriting, we have discovered a need for additional language features, and we have implemented these features as a set of built-in functions that comprise our "standard library". Here, we briefly summarise the most important additional features.</p><p>Skywriting is an expressive coordination language, but it is unlikely to be the most efficient implementation language for data-or CPU-intensive computations. Therefore we allow scripts to execute external code using the built-in exec() function. We currently have bindings for C, Java, .NET and UNIX pipe-based programs, and other languages are supported through a plugin interface.</p><p>For advanced use, we have added features to Skywriting that allow introspection on both the cluster and the currently-running job. For example, a script can call the task() function on a future reference to obtain information about the status of a spawned task. We support task cancellation using the abort() function. The script can also obtain information about the cluster nodes using the workers() function. Hence it is possible to tailor a job's execution to the available facilities in the cluster, by-for example-altering the degree of parallelism to match the number of idle workers.</p><p>We also support custom scheduling policies using the waituntil() function. The function takes a predicate and a list of future references, and returns when the predicate becomes true. For example, we provide predicates that fire when any, all or m-out-of-n tasks complete, and the user may supply custom predicates as a Skywriting function. The combination of introspection and custom scheduling enables us to implement straggler detection and speculative task execution <ref type="bibr" target="#b9">[11]</ref> in pure Skywriting, and we are continuing to investigate more advanced policies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Cooperative task farming</head><p>In order to run Skywriting programs, we need an execution framework that can execute jobs with a dynamic number of tasks. To this end, we have developed a "cooperative" task farming system, which distributes work between a pool of worker machines, and allows workers to spawn new tasks.</p><p>In this section, we describe the key features of our prototype system. We begin by describing how task dependencies are used to express a distributed data flow ( §3.1). We then introduce spawn lists, which enable workers to spawn additional tasks and modify the workflow dynamically ( §3.2). We present two methods for executing Skywriting scripts in our system: a master-based interpreter ( §3.3), and distributed execution ( §3.4). Finally, we discuss how our system can unify different coordination languages within a single framework ( §3.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Task dependencies</head><p>The recent major systems for distributed computingincluding but not limited to MapReduce <ref type="bibr" target="#b9">[11]</ref>, Hadoop <ref type="bibr" target="#b1">[2]</ref>, Dryad <ref type="bibr" target="#b16">[18]</ref>, Condor <ref type="bibr" target="#b21">[23]</ref> and BOINC <ref type="bibr" target="#b5">[7]</ref>form an equivalence class. Each system is capable of executing a collection of tasks in parallel on a network of computers, using the common task farming architecture. A master (alternatively: JobTracker <ref type="bibr" target="#b1">[2]</ref>, job manager <ref type="bibr" target="#b16">[18]</ref>, matchmaker <ref type="bibr" target="#b21">[23]</ref> or scheduling server <ref type="bibr" target="#b5">[7]</ref>) maintains a queue of tasks, and several workers loop forever retrieving tasks, processing them and storing the results.</p><p>There may also be dependencies between tasks: typically, this means that one task consumes the output of another. These dependencies may be explicit (as in Dryad's dataflow graph), implicit (e.g. all map() tasks must complete before any reduce() task begins in MapReduce) or trivial (i.e. a bag of independent tasks in BOINC or Condor). The dependency graph must be acyclic: otherwise the system would deadlock as two tasks would (directly or indirectly) depend on each other <ref type="bibr" target="#b16">[18]</ref>. <ref type="figure" target="#fig_0">Figure 2</ref> shows the structure of a task in our system. A task depends on one or more data items, which may be produced by other tasks: these are equivalent to Skywriting references ( §2.1). Therefore a task becomes runnable when all of its input data items are available: data items are decoupled from the task that produces them, which enables additional dynamism in the dependency graph (see the following subsection). The outputs of a task must be named in advance, which allows the scheduler to ensure that dependencies are acyclic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Spawn lists</head><p>A key feature of cooperative task farming is that a worker may spawn additional tasks in the execution of a job. This requires functionality that is similar to fork()-ing a process in UNIX, or spawning a function in Cilk <ref type="bibr" target="#b7">[9]</ref>. Therefore, the workers must have a mechanism for accessing the task queue. We use spawn lists for this purpose: as <ref type="figure" target="#fig_0">Figure 2</ref> shows, a task may optionally emit a list of task descriptors. The spawn list is a list of tasks to be scheduled after the task has completed, and it is populated dynamically at run-time. This feature makes it possible to express unbounded iteration in a task farming system.</p><p>For additional flexibility, a task may delegate its output to a task in its spawn list. This is particularly useful when implementing recursive, divide-and-conquer computations. For example, consider the case shown in <ref type="figure" target="#fig_1">Fig- ure 3</ref>. Task A takes a single input, x, and produces a single output, y. However, A may decide that it can split its work into two parallel tasks: B and C. We want A's successors-which are waiting for y to be produced-to see the combined result of B and C. Therefore, A spawns a continuation task, D, to which it delegates output y, and which combines the results of B and C.</p><p>In order to maintain schedulability, we enforce two constraints: (i) a task must produce all of its outputs or spawn tasks to produce them, and (ii) a spawned task can only depend on the inputs and outputs of the task that spawned it. Together, these ensure that no task will become orphaned and that no cycles will ever form in the dependency graph. Of course, one corollary of delega- tion (and the Turing-powerfulness of Skywriting) is that a scheduled task may never become runnable, but we do not consider this to be a problem in practice. We prevent "fork bombs" by limiting the number of tasks that can be outstanding for a single job (or user).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Master-based interpreter</head><p>We now turn to executing a Skywriting script on our system. The simplest approach is to run the interpreter in a thread within the master process. This is similar to the approach taken in Dryad <ref type="bibr" target="#b16">[18]</ref> and Hadoop <ref type="bibr" target="#b1">[2]</ref>, which both maintain the graph of dependent tasks in a single process. In this model, the interpreter runs over the Skywriting script until it reaches a spawn() function or * -operator. At this point, control returns to the execution framework, which schedules a new task or fetches the referenced data, respectively. However, if the script attempts to dereference a future reference that has not yet been produced, the interpreter must block until that result is available.</p><p>The main advantage of this scheme is that it is extremely efficient for simple scripts, such as MapReduceor Dryad-style jobs with no data dependencies. In this case, the interpreter terminates quickly, after spawning the necessary tasks. Since the interpreter and task scheduler are colocated in the same process, the task spawning latency is minimal.</p><p>For more complicated scripts that include data dependencies and hence may be long-lived, this approach may place too much load on the master. The master must maintain a thread for each running script, and handle all incoming dereferenced data. It may therefore become a bottleneck if several scripts dereference data concurrently. Furthermore, an uncooperative user could carry </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Distributed execution</head><p>Interpreting a Skywriting script is a simple computation, and therefore we can run the interpreter as a task on the cluster. Since Skywriting is a functional language, we can easily exploit parallelism and data locality in the script environment itself. However, in order to make the interpreter fit within our cooperative task farming model, we must decompose a script into one or more subtasks, each comprising sequences of statements that can run in a single task. An individual interpreter task takes an execution context (stack and environment) as input, executes one or more statements, and outputs the updated context. As <ref type="figure" target="#fig_2">Figure 4</ref> shows, it may have other inputs and outputs:</p><p>Dereferenced data Any data dependencies are treated as inputs to the task. This ensures that the task is only executed when the necessary data have become available, and it enables the scheduler to choose the appropriate worker on which to execute the task, for better data locality. Continuation If the task attempts to use data that are not yet available, it will spawn a continuation task to be scheduled when the data become available. Other spawned tasks If the task contains any invocations of the spawn() function, it will also output a list of tasks to schedule.</p><p>The simplest way to subdivide a script is to block and create a continuation every time the * -operator ( §2.3) is encountered. The continuation task would then receive the dereferenced data as an input. However, if the script dereferences several data items in succession, this may not give the best performance. Therefore, we delay the creation of a new task until the first time the dereferenced data is used. We achieve this by creating lazily-evaluated thunks for each instance of the * -operator. Since Skywriting is a purely functional language, we can evaluate independent functions, and even individual expressions, as parallel tasks. However, it is clear that not every expression should be parallelised in this manner. We are investigating simple annotation-based and adaptive schemes as future work.</p><p>Distributed execution provides many advantages over a master-based interpreter. It reduces load on the master, which improves scalability. The system handles all necessary data movement, which simplifies the master and gives the potential to exploit data locality. The cluster scheduler can also account for the resources used by the interpreter, which improves resource isolation.</p><p>However, because spawning tasks involves network communication with the master, the job latency can increase, which is noticeable for very short tasks. In our implementation, we first attempt master-based interpretation ( §3.3), and only switch to distributed execution when the script first attempts to perform a dereference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Unifying other frameworks</head><p>Cooperative task farming is strictly more general than the task farming schemes used in MapReduce, Hadoop, Dryad and other frameworks. Other authors have remarked that it would be useful to combine multiple frameworks on the same cluster <ref type="bibr" target="#b15">[17]</ref>. We concur, and we are implementing compatibility layers for Hadoop and DryadLINQ. Our approach is to transform a Hadoop or DryadLINQ job into the equivalent Skywriting script, and execute it using our cooperative task farming system. We must also provide Hadoop and DryadLINQ driver programs to execute MapReduce tasks and DryadLINQ vertices, respectively. This contrasts with Nexus <ref type="bibr" target="#b15">[17]</ref>, which uses lightweight OS virtualisation to run existing frameworks in isolated containers. We prefer to unify the frameworks under a common job representation, which raises the possibility of combining Hadoop and DryadLINQ execution in a single job.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Related work</head><p>Several other projects have investigated new programming models for cloud computing, beyond MapReduce and Dryad.</p><p>There have been many projects that add programming language support for data-intensive computing. DryadLINQ uses the Language Integrated Query (LINQ) extensions in recent .NET languages to allow users to specify queries on top of distributed data sets <ref type="bibr" target="#b24">[26]</ref>. Yahoo's Pig is a dataflow language that can be used to define a graph of dependent Hadoop jobs <ref type="bibr" target="#b19">[21]</ref>. Facebook's Hive provides a more declarative, SQL-like query language that can also generate a plan for Hadoop jobs <ref type="bibr" target="#b22">[24]</ref>. None of these languages supports unbounded iteration or recursion as a first-class construct: however, each can be straightforwardly compiled into Skywriting, and we are pursuing this as described in Subsection 3.5.</p><p>The Berkeley Orders Of Magnitude (BOOM) project also introduces a new programming model for dataintensive computing: "declarative, data-centric programming" <ref type="bibr" target="#b3">[5]</ref>. The authors use the Overlog logic language to reimplement key pieces of distributed infrastructure, such as Hadoop and HDFS. They reproduce previous enhancements to these systems using Overlog, and show that it is possible to add new features (such as Paxos replication <ref type="bibr" target="#b4">[6]</ref>) with a small number of Overlog statements. However, BOOM-MapReduce maintains the traditional map() and reduce() interface to Hadoop, so it does not change the programming model from the user's perspective. Skywriting, by contrast, is an attempt to enhance the programming model for the cluster user.</p><p>CGL-MapReduce adds unbounded iteration to the MapReduce programming model <ref type="bibr" target="#b11">[13]</ref>.</p><p>A CGLMapReduce computation has an additional "merge" stage that combines all reduce() outputs together and evaluates a termination condition on them. Therefore, CGL-MapReduce can keep intermediate data in RAM between iterations, if the input data are sufficiently small. However, the programming model is limited to MapReduce-style computation, and it is not possible to compose CGL-MapReduce jobs into larger computations. It is straightforward to express iterative MapReduce jobs as part of a Skywriting script.</p><p>Zaharia et al. have developed the Spark cluster computing framework, which is optimised for iterative and interactive computation <ref type="bibr" target="#b25">[27]</ref>. Spark uses "resilient distributed datasets", which are cached in RAM between jobs, and which can be reconstructed if a machine fails. A driver program-written in Scala-manipulates these datasets through an optimised job submission interface, which provides sufficient performance for interactive applications, and a substantial improvement over the equivalent Hadoop invocations. The main goal of Skywriting has been to obviate the need for a driver program, which enables the whole computation to run in the cluster. This reduces job submission overhead, and improves reliability because the execution engine provides fault tolerance for the whole job. However, Spark-like DryadLINQprovides the benefits of a strongly-typed high-level language, and we are investigating how to augment an existing language with Skywriting's distributed execution features.</p><p>Spark runs on top of the Nexus "cluster operating system" (recently renamed Mesos), which shares Skywriting's aim of unifying and extending existing programming models for data-intensive computing <ref type="bibr" target="#b15">[17]</ref>. However, Nexus takes an operating system approach that contrasts with our language-based approach. A Nexus cluster can be shared between several frameworks at once, including Hadoop, Spark and MPI. Nexus uses lightweight OS virtualistion to isolate the different frameworks, and a second level of scheduling to allocate resources between the frameworks. Existing framework schedulers then perform task allocation for their individual jobs. Nexus achieves the aim of running many frameworks on a single cluster, but it focuses on sharing physical resources between existing cluster computing frameworks. By contrast, we advocate (automatically) translating computations from different frameworks into the unified Skywriting representation, which makes it possible to mix paradigms (e.g. MapReduce and Dryad) in a single job.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions, status and future work</head><p>In this paper, we have introduced Skywriting, a new script language for coordinating distributed computation. Skywriting is more expressive than existing coordination languages, and is particularly suited to expressing iterative and recursive computation. We have also introduced cooperative task farming, which is an extension of task farming that supports dynamically-growing jobs, such as those expressed in Skywriting scripts. Together, Skywriting and its execution engine allow any distributed computation to be implemented in a single job.</p><p>We have implemented a prototype of Skywriting that includes all of the features described in this paper. The interpreter and distributed execution engine comprise approximately 4000 lines of Python code. The source code and a tutorial are available from the project website:</p><p>http://www.cl.cam.ac.uk/netos/skywriting/.</p><p>We are continuing to develop Skywriting and our prototype execution engine. In future work, we also intend to address the following questions, among others:</p><p>• How can we incorporate message-passing computation efficiently in our framework? Other frameworks handle this by maintaining frequently-used data in RAM <ref type="bibr" target="#b11">[13,</ref><ref type="bibr" target="#b25">27]</ref>, and we seek general abstractions that can provide this support in Skywriting.</p><p>• Can we execute a Skywriting script across multiple clouds? For example, we might store web service data in Google App Engine <ref type="bibr" target="#b2">[3]</ref>, but want to process it on Amazon EC2 <ref type="bibr" target="#b0">[1]</ref>.</p><p>• Could we achieve benefits by integrating Skywriting with an existing high-level language? Existing frameworks harness the strong typing and library support of mature languages, which further simplifies distributed programming <ref type="bibr" target="#b24">[26,</ref><ref type="bibr" target="#b25">27]</ref>.</p><p>• Does the Skywriting programming model extend to multi-and many-core systems? As message passing becomes more prevalent, there is a need for new programming abstractions beyond shared memory <ref type="bibr" target="#b6">[8]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Structure of a task, showing inputs and outputs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Example of output delegation for recursive tasks. In this example, Task A spawns B, C and D, and delegates its output, y, to D.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Structure of a Skywriting interpreter task. A continuation is spawned if the task blocks on unavailable data.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Thanks are due to our colleagues Malte Schwarzkopf, Chris Smowton and Anil Madhavapeddy, who have contributed to the further development of Skywriting. We would also like to thank the anonymous reviewers for their constructive comments and suggestions, and Matei Zaharia for information about Spark and Nexus. This work is supported by an AWS in Education Research Grant from Amazon Web Services.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ec2</forename><surname>Amazon</surname></persName>
		</author>
		<ptr target="http://aws.amazon.com/ec2/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Apache</forename><surname>Hadoop</surname></persName>
		</author>
		<ptr target="http://hadoop.apache.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google App Engine</surname></persName>
		</author>
		<ptr target="http://code.google.com/appengine/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Exploring Data-Centric, Declarative Programming for the Cloud</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alvaro</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Condie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Elmeleegy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sears</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Analytics</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroSys</title>
		<meeting>EuroSys</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">I do declare: consensus in a logic language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alvaro</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Condie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sears</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of NetDB</title>
		<meeting>NetDB</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">BOINC: A system for public-resource computing and storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anderson</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th international workshop on Grid Computing</title>
		<meeting>the 5th international workshop on Grid Computing</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The Multikernel: A new OS architecture for scalable multicore systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Baumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-E</forename><surname>Dagand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Isaacs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Peter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Roscoe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sch¨upbach</forename><surname>Sch¨upbachsch¨</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Singhania</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Cilk: an efficient multithreaded runtime system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Blumofe</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">D</forename><surname>Joerg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">F</forename><surname>Kuszmaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Leiser-Son</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Randall</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhou</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Parallel Distrib. Comput</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The anatomy of a large-scale hypertextual Web search engine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Page</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of WWW</title>
		<meeting>WWW</meeting>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">MapReduce: simplified data processing on large clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dean</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ghemawat</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">ECMA-262: ECMAScript Language Specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ecma</forename><surname>International</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
	<note>5th ed.</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">MapReduce for Data Intensive Scientific Analyses</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ekanayake</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pallickara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fox</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of eScience</title>
		<meeting>eScience</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The Google File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ghemawat</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gobioff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leung</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Multilisp: A Language for Concurrent Symbolic Computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Halstead</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">H</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Program. Lang. Syst</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="501" to="538" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Caching function calls using precise dependencies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heydon</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of PLDI</title>
		<meeting>PLDI</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Nexus: A Common Substrate for Cluster Computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hindman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Konwinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zaharia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ghodsi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stoica</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename></persName>
		</author>
		<idno>UCB/EECS- 2009-158</idno>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
		<respStmt>
			<orgName>University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Dryad: distributed data-parallel programs from sequential building blocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isard</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Birrell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fet-Terly</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EuroSys</title>
		<meeting>EuroSys</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Quincy: fair scheduling for distributed computing clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isard</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Prabhakaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Currey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wieder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Talwar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Goldberg</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Automatic optimization of parallel dataflow programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olston</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Silberstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srivastava</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of USENIX</title>
		<meeting>USENIX</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Pig Latin: A Not-So-Foreign Language for Data Processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olston</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomkins</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGMOD</title>
		<meeting>SIGMOD</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Interpreting the data: Parallel analysis with Sawzall</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pike</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Dorward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Griesemer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Quinlan</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scientific Programming</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Distributed computing in practice: the Condor experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thain</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tannenbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Livny</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="323" to="356" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Hive -A Petabyte Scale Data Warehouse Using Hadoop</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thusoo</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Chakka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antony</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Murthy</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICDE</title>
		<meeting>ICDE</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Distributed Aggregation for Data-Parallel Computing: Interfaces and Implementations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Gunda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K</forename><surname>And Isard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A System for General-Purpose Distributed Data-Parallel Computing Using a High-Level Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fetterly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Gunda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Currey</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dryadlinq</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of OSDI</title>
		<meeting>OSDI</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Spark: Cluster Computing with Working Sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zaharia</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chowdhury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stoica</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of HotCloud</title>
		<meeting>HotCloud</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
