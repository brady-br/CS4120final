<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-10-01T14:47+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Approximate XML Query Answers</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neoklis</forename><surname>Polyzotis</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of California</orgName>
								<orgName type="institution" key="instit2">Santa Cruz Bell Labs</orgName>
								<orgName type="institution" key="instit3">Lucent Technologies University of Athens</orgName>
								<address>
									<settlement>Hellas</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minos</forename><surname>Garofalakis</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of California</orgName>
								<orgName type="institution" key="instit2">Santa Cruz Bell Labs</orgName>
								<orgName type="institution" key="instit3">Lucent Technologies University of Athens</orgName>
								<address>
									<settlement>Hellas</settlement>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yannis</forename><surname>Ioannidis</surname></persName>
							<email>yannis@di.uoa.gr</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of California</orgName>
								<orgName type="institution" key="instit2">Santa Cruz Bell Labs</orgName>
								<orgName type="institution" key="instit3">Lucent Technologies University of Athens</orgName>
								<address>
									<settlement>Hellas</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Approximate XML Query Answers</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>The rapid adoption of XML as the standard for data representation and exchange foreshadows a massive increase in the amounts of XML data collected , maintained, and queried over the Internet or in large corporate data-stores. Inevitably, this will result in the development of on-line decision support systems, where users and analysts interactively explore large XML data sets through a declarative query interface (e.g., XQuery or XSLT). Given the importance of remaining interactive, such on-line systems can employ approximate query answers as an effective mechanism for reducing response time and providing users with early feedback. This approach has been successfully used in relational systems and it becomes even more compelling in the XML world, where the evaluation of complex queries over massive tree-structured data is inherently more expensive. In this paper, we initiate a study of approximate query answering techniques for large XML databases. Our approach is based on a novel, conceptually simple, yet very effective XML-summarization mechanism: TREESKETCH synopses. We demonstrate that, unlike earlier techniques focusing solely on selectivity estimation, our TREESKETCH synopses are much more effective in capturing the complete tree structure of the underlying XML database. We propose novel construction algorithms for building TREESKETCH summaries of limited size, and describe schemes for processing general XML twig queries over a concise TREESKETCH in order to produce very fast, approximate tree-structured query answers. To quantify the quality of such approximate answers, we propose a novel, intuitive error metric that captures the quality of the approximation in terms of both the overall structure of the XML tree and the distribution of document edges. Experimental results on real-life and synthetic data sets verify the effectiveness of our TREESKETCH synopses in producing fast, accurate approximate answers and demonstrate their benefits over previously proposed techniques that focus solely on selectivity estimation. In particular, TREESKETCHes yield faster, more accurate approximate answers and selectivity estimates, and are more efficient to construct. To the best of our knowledge, ours is the first work to address the timely problem of producing fast, approximate tree-structured answers for complex XML queries.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Since its introduction six years ago, XML has evolved from a mark-up language for web documents to an emerging standard for data exchange and integration over the Internet. Being self-describing and hierarchical in nature, the XML data model is suitable for representing a diverse range of data sources and promises to enable the next-generation of search applications that will allow users to query effectively the information available on the Web.</p><p>With the rapid growth of available XML data, one can expect a proliferation of on-line decision support systems that enable the interactive exploration of large-scale XML repositories. In a typical exploratory session, a domain expert poses successive queries in a declarative language, such as XQuery <ref type="bibr" target="#b3">[4]</ref> or XSLT <ref type="bibr" target="#b6">[7]</ref>, and uses an appropriate visualization of the results in order to detect interesting patterns in the stored data. Obviously, the successful deployment of decision-support systems depends crucially on their ability to provide timely feedback to users' queries. This requirement, however, conflicts with the inherently expensive evaluation of XML queries which involve complex traversals of the data hierarchy, coupled with non-trivial predicates on the path structure and the value content.</p><p>Generating approximate answers is a cost-effective solution for offsetting the high evaluation cost of XML queries. In short, the system processes the query over a concise synopsis of the XML data and returns an approximation of the true result. Ideally, this approximate answer is computed very fast and is accurate in the sense that it preserves with low error the statistical traits of the true result. The user can then examine this "preview", assess the information content of the true answer, and decide whether it needs to be retrieved by executing the query over the base data. Overall, by providing the user with fast and accurate feedback on the form of the results, the system can reduce the number of queries that need to be evaluated in order to support effectively the data exploration task.</p><p>In a typical scenario, the result of an XML query is an XML fragment that is constructed by appropriate projections on the original data; an approximate answer, therefore, is an XML document that resembles the true answer in terms of hierarchical structure and value content. Clearly, the effectiveness of an approximate answering system hinges upon the existence of accurate synopsis structures that capture the key statistical characteristics of the base XML data and can thus produce low-error approximate answers to queries that project parts of it. Note that the problem of efficient XML summarization also arises in the context of selectivity estimation, where the synopsis is only used to estimate the size of the result. Approximating the structure of the result, however, is a strictly more complex problem since there are documents where the same query produces results of equal size but with very different structure. Summarizing, therefore, an XML document in order to compute approximate answers is more involved than building synopses for selectivity estimation, which in itself is known to be a hard problem <ref type="bibr" target="#b17">[18]</ref>. <ref type="bibr" target="#b0">1</ref> . Previous studies on approximate query answering <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">10]</ref> have focused on the relational model, where the result of a query is typically a multi-set of values. The key idea is to process a query over an appropriate relational synopsis (such as, histograms, wavelets, or sample-based summaries) and compute an approximation of the true value set. The proposed techniques and summarization methods, however, are suitable for flat relational data and are not easily extended to the case of general XML hierarchies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work</head><p>As noted earlier, approximate XML query answering is closely tied to the problem of building effective XML synopses. Recent studies have looked at the related problem of summarizing XML data for estimating the selectivity of single XPath expressions <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b21">22]</ref>, or the number of binding tuples for twig queries <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b17">18]</ref>. Even though a selectivity estimate is essentially an approximate answer to an aggregate query (COUNT), the proposed summarization techniques do not store detailed enough information in order to approximate the structure of the query result.</p><p>Buneman et al. <ref type="bibr" target="#b1">[2]</ref> have recently introduced a query-able compression scheme for tree-structured XML data. The proposed technique compresses the XML tree by using an appropriate bisimulation relation and evaluates an XPath query directly over the compressed instance. The goal, therefore, is to compute an exact answer to a path query, whereas our focus is on computing an approximate answer to a twig query, which typically involves the joint evaluation of multiple path expressions.</p><p>Our Contributions. In this paper, we initiate the study of approximate query answering for XML queries. In order to gain intuition on the complexity of the problem, this initial study focuses on approximate answers for twig queries with branching path expressions, i.e., we consider the structural part of the problem and ignore for now the value content of the document. As we show in this paper, even this constrained version is quite complex and requires non-trivial solutions. Our approach is based on a novel type of structural XML synopses, termed TREESKETCHes, that capture, in limited space, the key properties of the underlying path distribution and enable low-error approximate answers for a large class of interesting XML queries. We develop a systematic query evaluation framework for generating approximate answers over concise TREESKETCH synopses and describe an efficient construction algorithm for building an accurate TREESKETCH summary within the constraints of a limited space budget. Finally, we present experimental results on real-life and synthetic data sets that demonstrate the effectiveness of our approach and its benefits over previously proposed techniques, not only for generating approximate answers, but also for enabling accurate selectivity estimation. To the best of our knowledge, ours is the first study to look into the problem of computing approximate answers for complex XML queries. More concretely, the key contributions of our work can be summarized as follows:</p><p>TREESKETCH Summarization Model and Query Evaluation Framework. Our TREESKETCH summarization model is based on the novel concept of count-stability which captures very effectively the intrinsic similarity of sub-structures in an XML document. Briefly, a TREESKETCH summary represents a clustering of document elements, where each cluster represents elements with similarly structured sub-trees. We develop an efficient evaluation algorithm that processes a query over a concise TREESKETCH and produces another TREESKETCH synopsis that summarizes the structure of the result. Futhermore, we discuss how the same algorithm can be used to estimate the result size of a complex twig query.</p><p>Efficient TREESKETCH Construction Algorithm. We describe an efficient heuristic algorithm that starts from a detailed summary and incrementally merges element clusters that are "close" in terms of element sub-structure. To make our algorithm applicable on large data sets, we devise an effective heuristic that limits the number of possible merges in every step, without compromising the quality of the resulting synopsis.</p><p>New Distance Metric for XML Documents. We argue that traditional graph-theoretic distance metrics, such as tree-edit distance, are not suitable for evaluating the quality of an approximate answer relative to the true result. To overcome this difficulty, we introduce a novel distance metric that quantifies the differences between two trees in terms of both the overall path structure and the distribution of document edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Experimental Study Verifying the Effectiveness of</head><p>TREESKETCHes. We validate our approach experimentally with an extensive study on real-life and synthetic data sets. Our results demonstrate that TREESKETCHes perform consistently better than previously proposed summarization techniques: they enable more accurate approximate answers and selectivity estimates, and at the same time are more efficient to construct. Moreover, our scaling experiments with large data sets show that even small-size TREESKETCHes are extremely effective in enabling low error selectivity estimates to complex twig queries (e.g., less than 5% estimation error for a 10KB summary of a 100MB input document). Combined with the affordable construction times of TREESKETCH summaries, these results indicate that TREESKETCHes constitute an effective and viable in practice solution for the structural summarization of large XML data sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head><p>XML Data Model. Following common practice, we model an XML document as a large, node-labeled tree</p><formula xml:id="formula_0">¡ £ ¢ ¥ ¤ § ¦ © ¨ £</formula><p>. Each node ¤ corresponds to an XML element and is characterized by a unique object identifier (oid) and a label (or, tag) assigned from some alphabet of string literals, that captures the element's semantics. Edges to denote the label and set of child nodes for element node ¤ .) As an example, <ref type="figure">Figure 1</ref> depicts a sample XML data tree containing bibliographical data. The document consists of author elements, each comprising a name, and several paper and book sub-elements. Each paper contains a title, a year of publication and one or more keywords, whereas a book just gives its title. Note that element nodes in the tree are named with the first letter of the element's tag plus a unique identifier. Leaf elements in We consider twig queries using XPath expressions involving only the child and descendant-or-self axes (i.e., "/" and "//" operators) and may include existential branching predicates of the form "   l ", where  l is, in general, a label path whose existence is required under a given parent node in the XPath expression. As an example, the "//a[//b]" predicate in <ref type="figure" target="#fig_1">Figure 2</ref> specifies author tree nodes that are located at any depth under the current binding of variable IS (the document root) and have at least one book descendant. Intuitively, the evaluation of a twig query , which contains all the elements of ¡ that appear in the bindings of different variables and in addition preserves their ancestor/descendant relationships as specified by the query paths. <ref type="figure" target="#fig_1">Figure 2(c)</ref> shows the nesting tree for the example query of <ref type="figure" target="#fig_1">Figure 2(b)</ref>. Obviously, the nesting tree can be used to reproduce the binding tuples of a query and ultimately its result.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">TREESKETCH SYNOPSIS MODEL</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">General Graph-Synopsis Model</head><p>Abstractly, our general graph-synopsis model for an XML data tree</p><formula xml:id="formula_1">¡ £ ¢ ¥ ¤ § ¦ © ¨ </formula><p>is defined by a partitioning of the element nodes in ¤ (or, equivalently, by an equivalence relation</p><formula xml:id="formula_2">   ¤    ¤</formula><p>) that respects element labels; that is, if  <ref type="bibr" target="#b13">[14]</ref> and A(m )-indexes <ref type="bibr" target="#b10">[11]</ref>), as well as statistical summaries for XML databases (including XSKETCHes <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> and twig-XSKETCHes <ref type="bibr" target="#b17">[18]</ref>) are all based on the abstract "node-partitioning" idea described above. As an example, the basic twig-XSKETCH summary mechanism, which targets selectivity-estimation of complex twig queries, augments our general graph-synopsis model with (1) per-node count information that records the size of each synopsis node's extent, (2) localized per-edge stability information, indicating whether the synopsis edge is backward-and/or forward-stable, and <ref type="formula">(3)</ref>  .</p><formula xml:id="formula_3">¢ © ¦ © Y  then label ¢ ¥ e d label ¢ .</formula><p>Limitations of Selectivity-Estimation Synopses. Given the amount of earlier work on XML summarization and the number of alreadyexisting synopsis data structures for XML, a natural question that arises is whether there is a real need for a new summarization mechanism for approximate XML query answering. Our key observation here is that the focus of all earlier work in the area has been on the problem of selectivity estimation (for XPath expressions <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> or twig queries <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b17">18]</ref>) and, unfortunately, even the state-of-the-art solutions for XML selectivity estimates prove to be inadequate in accurately capturing the complete tree structure of the underlying document. We illustrate our observation with a simple example on twig-XSKETCH synopses (we focus on the twig-XSKETCH model since it also uses a graph-synopsis and it is applicable in the general case of schema-less documents.) Consider the two XML document trees  . Note, however, that the tree structure for the binding tuples of P is in fact very different across our two example documents. For example, looking at the edge distribution in the query result, for document Again, the key observation here is that, while twig-XSKETCHes and edge histograms provide an accurate summarization mechanism for twig selectivity estimation, they cannot model the details of the tree structure for the twig query's binding tuples; thus, we expect them to be inadequate as a general-purpose approximate query answering tool (the results of our empirical study in Section 6 clearly verify our expectations.) Furthermore, as this paper demonstrates, our new synopses are also conceptually simpler, significantly easier to build, and provide more accurate results than twig-XSKETCHes even for the simpler selectivity estimation problem.</p><formula xml:id="formula_4">( ( X X X X  e  e  d  y Ò Ò Õ Õ Õ Õ  ¢ g  £  d  ¢ g    e  (d) (e) (f)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Count-Stability and the TREESKETCH Synopsis</head><p>Our proposed TREESKETCH synopsis data structure is a specific instantiation of the generic graph-synopsis model outlined earlier in this section. TREESKETCHes rely on a novel, intuitive concept of localized stability, termed count stability, defined formally as follows.  It is easy to see that our notion of count stability is a refinement of the traditional Fstability relation for trees employed by both XSKETCHes <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref> and twig-XSKETCHes <ref type="bibr" target="#b17">[18]</ref>; in other words, the equivalence classes for the count-stability relation are generated by further partitioning the equivalence classes for F-stability.</p><p>Intuitively, our concept of count stability tries to define a class of equivalence relations where element nodes are grouped together only if the data sub-tree structures underneath them are identical. As the following lemma shows, the count-stable graph-synopsis for a data tree ¡ is uniquely defined and, furthermore, it accurately captures the structure of</p><formula xml:id="formula_5">¡ . LEMMA 3.1. Given a data tree ¡ £ ¢ ¥ ¤ § ¦ © ¨ </formula><p>, there exists a unique minimal (in terms of the number of equivalence classes) countstable equivalence relation</p><formula xml:id="formula_6"> «  ¤  ¬ ¤ . Furthermore, there exists a function ­ ¯ ® W ° ² ± Y ³ µ ´</formula><p>from stable relations to XML trees, such that</p><formula xml:id="formula_7">­ h ® ¶ ° ² ± Y ³ ² ´ ¢  is isomorphic to the original document tree ¡ .</formula><p>Thus, the tree structure of the original document ¡ can be retrieved with zero-error from a synopsis</p><formula xml:id="formula_8">· g ¢ 8 ¡ k if </formula><p>is stable. The problem, of course, is that the size of a count-stable synopsis can become very large -it can easily be in the order of the original document size. Given the stringent time and storage limitations typically associated with interactive approximate query answering, it is clear that perfect count-stable summaries cannot be very useful as a data-approximation tool for real-time XML data exploration. Instead, our proposed TREESKETCH synopses try to approximately capture the underlying document-tree structure within a predefined space budget. Intuitively, the key idea behind TREESKETCHes is to locally approximate count-stable relations in the graph-synopsis wherever structural correlations exist in the underlying data, while relaxing the count-stability requirement where such correlations are not dominant and independence/uniformity assumptions are sufficient. Our TREESKETCH synopsis model is simply defined as follows. Thus, instead of storing complex histograms for edge combinations in a B/F-stable neighborhood of a node (like twig-XSKETCHes <ref type="bibr" target="#b17">[18]</ref>), our TREESKETCHes simply maintain a localized average child count for each edge in the synopsis (without requiring any stability properties for that edge). is mapped to a point</p><formula xml:id="formula_9">¢ 6 v d ¢ ¦ ¼ ' ¼ # ¼ ' ¦ © v º ¢ © if it has v¢ children to node j , l ¾ ½ C ¿ k ½ « » .</formula><p>The recorded average edge counts essentially map all points in this</p><formula xml:id="formula_10">space to point ¢ count ¢ ¦ j d ¦ f ¼ ' ¼ ' ¼ ' ¦ count ¢ ¦ j a º ©</formula><p>, which actually represents the centroid of the cluster. We can thus characterize the quality of a TREESKETCH synopsis by using a metric that quantifies the quality of the induced clustering. The metric that we adopt in our work is the squared error of the clustering, which essentially measures the euclidean distance between points and their corresponding centroid. The squared error for a single cluster is defined as</p><formula xml:id="formula_11">À # I ¢ ¯ d ~ H Á Â t ~ d © Ã Ã º ¢ 6 v¢ R Ä count ¢ ¦ j © e</formula><p>, while the squared error</p><formula xml:id="formula_12">À ' I ¢ ¸ i f for a synopsis¸i synopsis¸ synopsis¸i f</formula><p>is simply the sum of squared errors for all the induced clusters. Note, of course, that the squared error for a count-stable synopsis is zero since all edgecount centroids are exact, i.e., the child counts for any element in a given synopsis-node extent are identical (and equal to the corresponding edge counts). We have chosen the squared error metric since it captures a notion of weighted variance, but it is possible to use other metrics such as the Manhattan distance or the pairwise intra-cluster distance. Irrespective of the actual choice, the existence of a workload-independent TREESKETCH-quality metric is a major difference from earlier summarization techniques which are also based on graph synopses, but quantify the quality of summaries on a per-workload basis (examples include both XSKETCHes and twig-XSKETCHes.) As we will see later, this feature will enable fast construction times, since the quality of a summary in the space of possible TREESKETCHes can be determined very efficiently, without requiring the costly evaluation of a query workload (as in the case of XSKETCH and twig-XSKETCH construction).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SYNOPSIS CONSTRUCTION AND QUERY PROCESSING</head><p>In this section, we start by describing novel, efficient bottom-up construction procedures for count-stable summaries and our TREESKETCH synopses (for a given space budget). We then introduce algorithms for approximating the results as well as the selectivities of XML twig queries over TREESKETCH synopses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Building the Count-Stable Summary</head><p>Our algorithm for constructing the complete count-stable summary of an input XML tree ¡ (termed BUILDSTABLE) is depicted in <ref type="figure">Figure 4</ref>. In a nutshell, BUILDSTABLE processes element nodes in a post-order traversal of time; note that, for building the "child-count signature" in Step 3, only the element's child classes are necessary, and these can be easily accessed using a stack during the post-order traversal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Building TREESKETCH Synopses</head><p>As already mentioned in Section 3.2, the size of an exact countstable synopsis typically renders it useless in the context of a real- </p><formula xml:id="formula_13"> := Í  A Î    h Ï ' Î is a node in È and Ð children  Ê  µ Ñ extent   Î Ð Ò  h Ó  Ô 4. if  ¬ Õ label  Ê  ©  × Ö Ò É  then 5. Add node Î to È with label   Î ¶  Ò label  Ê  6.  ¬ Õ label  Ê  s  × Ö := Î 7. for  A Î    Ë  do add edge Î  s Ø Ù  Ú Î to È 8. endif 9. Î :=  ¬ Õ label  Ê  ©  × Ö ; extent  A Î ¶  := extent   Î ¶  ² Û Í f Ê Ô</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">endfor end</head><p>Figure 4: Algorithm BUILDSTABLE.</p><p>life approximate query processing system. Such systems usually place tight limits on the space budget for building synopses of the underlying data collection. Thus, there is a clear need for effectively constructing compressed TREESKETCH synopses under a given space budget, while maintaining a high-quality XML-data approximation in order to enable meaningful approximate answers. Given the aforementioned natural analogy between TREESKETCHes and data clustering (Section 3.2), our goal of constructing an effective synopsis can be translated to computing an effective clustering of the XML elements. Here, of course, an element cluster is "tight" if it encompasses data elements with similar sub-trees, and "tightness" can be quantified using the squared error for the clustering (as discussed in Section 3.2). Thus, our goal is to build a TREESKETCH synopsis¸i synopsis¸ synopsis¸i f that fits within a given space budget, such that the overall square error</p><formula xml:id="formula_14">À ' I ¢ ¸ i f</formula><p>for the synopsis is minimized. The analogy with clustering also highlights the difficulty of TREESKETCH construction, since such clustering problems are known to be Ü Þ Ý -hard even in the simple case of points in a low-dimensional space <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b23">23]</ref>. Furthermore, TREESKETCH construction typically deals with a high-dimensional space which is defined by the clustering itself (i.e., the space itself changes as elements are assigned to clusters)! Thus, the problem is significantly more complex and existing clustering algorithms are not directly applicable.</p><p>Our approach is based on a generic bottom-up clustering paradigm: starting from the count-stable synopsis, our algorithm (termed TS-BUILD) incrementally reduces the synopsis size by merging nodes with similar sub-structures, until the budget constraint is met. This resembles agglomerative hierarchical clustering algorithms, which start with one cluster per input data point and successively reduce the number of clusters by merging neighboring groups (according to some appropriate distance metric). Another possible option is a top-down approach that starts from a coarse summary and gradually expands it by splitting nodes (this is actually the approach taken in the XSKETCH work <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b17">18]</ref>). In the clustering literature, however, bottom-up algorithms have been shown to perform better than their top-down counterparts; in addition, we have experimentally verified that bottom-up TREESKETCH construction yields much better results, without significantly increasing construction time.</p><p>The TSBUILD Algorithm. We now describe our TREESKETCHconstruction algorithm in more detail. In a nutshell, TSBUILD maintains a pool of candidate operations to be applied to the working TREESKETCH synopsis¸i  </p><note type="other">Procedure TSBUILD(à , ¢ ,á T â , ã ä â ) Input: XML document à ; space budget ¢ ; upper/lower bounds for heap</note><formula xml:id="formula_15">ß ¼ # þ Y þ ù d À ' I ¢ ß ¢ ¸ k f © Ä À ' I ¢ ¸ i f</formula><p>to be the increase in squared error from¸i</p><formula xml:id="formula_16">from¸ from¸i f to ß ¢ ¸ i f</formula><p>, and</p><formula xml:id="formula_17">ß ¼ À # ¿ ¥ ÿ ù d size ¢ ¸ i f Ä size ¢ ß ¢ ¸ i f ©</formula><p>to be the corresponding decrease in synopsis size. The pool of candidate operations is organized in a min-heap according to the marginal-gain ratio</p><formula xml:id="formula_18">ß ¼ # þ Y þ ù ¡ ß ¼ À ' ¿ ¥ ÿ ù</formula><p>, i.e., the operation at the top of the heap offers the least increase in squared error per unit of space that is saved. At each step of the construction algorithm, the operation at the top of the heap is applied, the pool is updated with new merge operations for the new node, and the þ þ ù ¦ À ' ¿ F ÿ ù metrics are recomputed for the new pool of candidate merge operations. This process is repeated until the heap is exhausted (i.e., no merge operations are possible) or the size of the¸¹ the¸ the¸¹ f synopsis drops below the allotted space budget.</p><p>The pseudo-code for our TSBUILD algorithm is shown in <ref type="figure">Fig- ure 5</ref>. TSBUILD initializes the min-heap ¢ of candidate merge operations through function CREATEPOOL (discussed below), and then applies successive merges according to our marginal-gain criterion (Steps 5-15). In order to limit the memory requirements of the algorithm and increase efficiency, the size of the operations heap is bounded by the supplied parameter £ â . As operations are performed, the size of the heap is gradually reduced and when it drops below a supplied threshold ¤ â , the heap is re-generated and the process repeated.</p><p>A potential performance bottleneck for the construction process is the re-computation of the more efficient by storing "sufficient" statistics in each synopsis node. Briefly, each node stores the sum and the sum of squares for the child counts of its elements along each outgoing edge in the synopsis. It is straightforward to show that these statistics are sufficient in order to compute the squared-error metric for the synopsis</p><formula xml:id="formula_19">À ' I ¢ ¸ i f</formula><p>without accessing the base data. In addition, in certain cases, these statistics can be combined in order to derive the statistics of new nodes (created through merge operations). The complete details are beyond the scope of this presentation and can be found in the full paper <ref type="bibr" target="#b16">[17]</ref>. Note that this idea is similar to the one proposed in the BIRCH clustering algorithm <ref type="bibr" target="#b23">[23]</ref>, where clusters are represented only by a collection of similar sufficient statistics throughout the computation. In our case, however, the stored statistics do not obviate the need to access a small subset of the base data (although this can be done very efficiently, by accessing only the relevant parts of the count-stable summary). Again, we defer the details to the full version of this paper <ref type="bibr" target="#b16">[17]</ref>. merge operations, where  is the number of nodes in the count-stable summary and, thus, becomes prohibitively expensive as the size and complexity of the data grows. Given that CREATEPOOL is invoked repeatedly during the TREESKETCH-construction process, this increased complexity has a significant negative impact on construction times. On the other hand, reducing the number of operations considered increases the efficiency of the candidate-generation stage, but it also runs the risk of "polluting" the heap with less effective merge operations that can affect the quality of the generated TREESKETCHes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Generation</head><p>To overcome this difficult problem, we adopt a heuristic that limits the number of merge operations considered while ensuring that the heap only contains operations that are likely to be beneficial.</p><p>The key observation here is that a merge of two nodes and j leads to a "good" clustering of the elements involved only if and j have similarly structured sub-trees. Thus, our TREESKETCHconstruction algorithm is much more likely to apply merge operations on the children of and j first, before merging and j themselves. This observation suggests a bottom-up approach for populating the heap with merge operations, starting with nodes close to the leaves of the current synopsis and proceeding upward to the root. <ref type="figure">Figure 6</ref> shows the pseudo-code for our CREATEPOOL algorithm that implements the aforementioned heuristic. CREATEPOOL uses the concept of a node's depth in order to examine merge operations in a bottom-up fashion. More specifically, let be a document element. of the operations seen thus far (this can be implemented efficiently through a double-ended heap). Candidate generation terminates when the current depth has been exhausted and the heap holds the maximum allowed number of operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Approximate Query Processing</head><p>We now turn our attention to the problem of generating approximate answers from a concise TREESKETCH synopsis. At an abstract level, our query evaluation algorithm, termed EVALQUERY, processes the input query (the full nesting tree can be retrieved by expanding¸¹ expanding¸ expanding¸¹ f Q ). As noted in Section 2, the full nesting tree can be used to reconstruct the binding tuples of P and ultimately its result. The evaluation algorithm uses the structure information of¸i of¸ of¸i f in order to identify matches of the query's path expressions, while the stored edge counts are used to approximate the cardinalities of the corresponding result sets. Similar to any summarization method, the use of the stored information is coupled with a set of appropriate statistical assumptions that compensate the lack of detailed distribution information at certain parts of the synopsis. As we will see, the validity of these assumptions depends on the quality of element clustering within each synopsis node and is thus directly linked to the heuristics of the TSBUILD algorithm. Intuitively, this direct relationship between the build algorithm and the query processing framework leads to the construction of summaries that compute highly accurate approximate answers. <ref type="figure">Figure 7</ref> shows the pseudo-code for algorithm EVALQUERY. , and the number of descendants along each path is computed with algorithm EVALEM-BED. The separate invocations of EVALEMBED essentially apply an independence assumption between the different variables of the query, which translates to an independence assumption on the underlying path distribution. We defer this point to the end of the section, where we discuss the relationship of the processing assumptions to the general TREESKETCH framework. , then all elements in satisfy the branching predicate and the selectivity is equal to 1. In the opposite case (all descendant counts are strictly less than 1), each count is treated as the fraction of elements in that have descendants along the corresponding embedding of the branching predicate. Since an element satisfies the branching predicate if it is the root of at least one matching embedding, the overall selectivity is computed using the inclusion-exclusion principle on the recorded fractions (line 11). We note that the application of the exclusion/inclusion principle essentially makes use of an independence assumption on the distribution of document edges, which, as we discuss below, is derived from the interpretation of the TREESKETCH summarization model and is closely related to the squared error of the synopsis.   <ref type="figure">Figure 4</ref>.3(c) (synopsis nodes are annotated with the corresponding query node).</p><p>As noted previously, the evaluation algorithm applies a set of independence assumptions during the processing of an input query over a concise TREESKETCH summary. At a closer inspection, all the processing assumptions can be reduced to a basic independence assumption that de-correlates the distribution of document edges along different paths of the document. This assumption is essentially derived from the interpretation of the TREESKETCH synopsis model: given a synopsis edge Þ n j , all elements in</p><formula xml:id="formula_20">have count ¢ ¦ j children in j</formula><p>, independent of incoming or outgoing paths (Section 3). Obviously, this interpretation is trivially satisfied on a stable synopsis where, by virtue of count-stability, all elements in the extent of a node have the same edge counts to child nodes. As a result, EVALQUERY will compute the exact nesting tree of a query when the accessed edges of the synopsis are count-stable. In the general case of a compressed TREESKETCH, it is straightforward to observe that the validity of the assumption is directly related to the error of the induced element clustering: if the error is low, i.e., the clusters are tight, then the elements are closer to the centroid (which is defined by the recorded average edge counts), and the assumption becomes more valid. In essence, there is a close relationship between the squared error of the synopsis, which quantifies the tightness of the clusters, and the quality of the generated approximate answers. This observation provides the "missing link" between the construction algorithm and the evaluation framework: although the build process does not use a workload-based approach to ensure high-quality approximate answers, it achieves the same goal by keeping the squared error low and thus making the basic independence assumption more valid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Selectivity Estimation</head><p>In this section we briefly discuss the use of TREESKETCHes for estimating the selectivity of twig queries. As shown in earlier studies <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b12">13]</ref>, accurate estimation for the number of bindings tuples for twig queries is a key requirement in producing effective query plans for complex declarative queries over XML data.</p><p>Our proposed estimation framework uses the result of the EVAL-QUERY algorithm to efficiently compute an estimate of the query's selectivity. More specifically, the estimation algorithm performs a single post-order traversal of the structural summary¸é summary¸ summary¸é f Q and computes, for each node, the average number of binding tuples per element in its extent. Given the bounded size of¸i of¸ of¸i f Q , it becomes clear that the estimation process has low memory requirements and can be performed very efficiently. In the interest of space, we do not discuss the estimation algorithm further. The full details can be found in the full version of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">AN ERROR METRIC FOR APPROXIMATE XML QUERY ANSWERS</head><p>In order to evaluate the effectiveness of the proposed approximate query answering framework, it is necessary to measure the degree of similarity between the approximate nesting tree between the two XML trees which essentially quantifies the error of approximation. There are numerous proposals for distance metrics over trees, the most widely used being the tree-edit distance metric <ref type="bibr" target="#b19">[20]</ref>. As we will see next, however, the proposed metrics essentially measure the syntactic differences between the two XML trees and thus fail to capture the semantics of approximate answers. We note that our discussion will focus on the tree-edit distance metric, but our observations hold for other graph-theoretic metrics as well.</p><p>The tree-edit distance</p><formula xml:id="formula_21">ý ¿ F À</formula><p>The previous example illustrates that the syntactic difference between two documents, as measured by tree-edit distance or other similar graph-theoretic metrics, is not a suitable similarity metric for approximate answers. Intuitively, an approximate answer is useful if it preserves the statistical traits of the true answer, without necessarily being identical to it, and the distance metric should capture this type of "approximate" similarity. Similar observations have been made in the context of approximate answers for relational queries <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">10]</ref>, where the result of a query is a multi-set of values. In short, these studies have argued convincingly that settheoretic metrics, which correspond to syntax-oriented metrics in the XML world, do not yield intuitive results when comparing two value sets (the approximate and the true answer). This has led to the introduction of new distance metrics, such as the MAC <ref type="bibr" target="#b9">[10]</ref> and the EMD <ref type="bibr" target="#b2">[3]</ref>, in order to measure effectively the quality of approximate answers to relational queries.</p><p>A New Distance Metric for XML Trees. We introduce a novel distance metric, termed Element Simulation Distance (ESD), that avoids the shortcomings of syntax-oriented metrics by capturing regions of approximate similarity between the compared XML trees. To the best of our knowledge, ours is the first metric that considers both the overall path structure and the distribution of document edges, when computing the distance between two XML trees.</p><p>We now describe the ESD metric in more detail. can now be measured as the sum of distances for children of matching tags:</p><formula xml:id="formula_22">¨ · v u ¢ ¦ j ¯ d ~ S ý ¿ F À ) 1 x T ¢ £ v S ¦ h ¤ S .</formula><p>In effect, two elements are more (or less) similar if their children with matching tags are more (or less) similar themselves, which recursively extends to the whole sub-structure underneath the two elements. . This, however, is a common characteristic of metrics that measure the approximate distance between complex objects (e.g., a similar observation holds for the MAC and EMD metrics). We note that it is possible to compute the ESD metric efficiently by first building the stable  on the fly and then evaluating the metric on the stable synopses. The key observation is that a stable summary preserves the path structure and the edge distributions of the original document, while containing fewer nodes. A detailed description of the computation of ESD on stable summaries can be found in the full version of the paper <ref type="bibr" target="#b16">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EXPERIMENTAL STUDY</head><p>In this section, we present an extensive experimental study of TREESKETCHes on real-life and synthetic data sets. Our results verify the effectiveness, in terms of accuracy and construction time, of the TREESKETCH synopses as structural summaries for large XML data sets. These benefits become even more apparent in a comparison to previously proposed techniques, where TREESKETCHes perform consistently better in all aspects. Overall, this empirical study indicates that TREESKETCHes are a viable and effective solution for the structural summarization of large XML data sets in real-world applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Testbed and Methodology</head><p>Techniques. We have experimented with two techniques. TREESKETCHes. We have implemented a fully functional prototype of the TREESKETCH framework that we describe in this paper. Throughout our experiments, the construction algorithm uses an upper limit of £ operations. Twig-XSKETCHes. Twig-XSKETCHes <ref type="bibr" target="#b17">[18]</ref> have been proposed as a summarization technique for estimating the selectivity of complex twig queries. Since the original proposal focused solely on selectivity estimation, we have developed an algorithm for producing approximate answers from a twig-XSKETCHThe algorithm traverses the query tree and uses the distribution information of the recorded edge histograms in order to sample the number of descendants for each element in the approximate result tree. For the construction of twig-XSKETCH summaries, we have used the same parameters that were reported in the original study <ref type="bibr" target="#b17">[18]</ref>. Data Sets. We have used four data sets in our experiments: IMDB, a real-life data set from the Internet Movie Database Project; XMark, a synthetic data set that models transactions on a on-line auction site; Swiss Prot, a real-life data set with annotations on proteins; and DBLP, a real-life data set with bibliographical data. The main characteristics of the corresponding XML documents are summarized in <ref type="table" target="#tab_15">Table 1</ref>. The TX documents have been used in the twig-XSKETCH study <ref type="bibr" target="#b17">[18]</ref>, and we include them here for the comparison of TREESKETCHes against twig-XSKETCHes. Looking at the sizes of the stable summaries, we observe that count-stability is very effective in compressing, without loss, the structural information of the original documents. Still, processing a query over so large a summary becomes prohibitively expensive relative to the stringent time requirements of an approximate answering system. Query Workloads. For each data set, we evaluate the performance IMDB-TX XMark-TX SProt-TX  of the generated summaries against a workload of 1000 positive queries, i.e., queries that have non-empty results sets. Our experiments with negative workloads have shown that TREESKETCHes consistently produce empty answers as approximations and we therefore omit these workloads from our presentation in the interest of space. The workload is generated by sampling sub-trees from the stable synopsis and converting them to twig queries. <ref type="table" target="#tab_18">Table 2</ref> contains the average number of binding tuples per query in the workloads that we have generated.</p><p>Evaluation Metrics. We quantify the accuracy of approximate answers with the ESD metric which was defined in Section 5. More specifically, we compute the ESD between the approximate and the true nesting tree of each query in the workload and report the average over all queries. Our implementation uses a slightly revised version of MAC (kindly provided by Y. Ioannidis and V. Poosala) as the underlying set-distance metric, and limits comparisons to the binding elements of the same query variables. As always, the complete details can be found in the full paper <ref type="bibr" target="#b16">[17]</ref>. For experiments on selectivity estimation, we measure the accuracy of the synopses with the average absolute relative error over all queries in the workload. More formally, if þ is the true and the estimated selectivity for a query in the workload, the absolute relative error is defined as</p><formula xml:id="formula_23">{þ R Ä  { ß o  4  ¢ ¦ À .</formula><p>The sanity bound À is used to avoid the artificially high percentages of low-count queries. Following common practice <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b17">18]</ref>, we set À to the 10-percentile of true query counts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Results</head><p>Approximate Query Answers. In this experiment, we evaluate the effectiveness of our novel TREESKETCH synopses as a practical solution for generating approximate answers to complex twig queries. We present a comparison against the previously proposed twig-XSKETCH synopses, focusing on two measures: the quality of the generated approximate answers, and the efficiency of the construction process. <ref type="figure" target="#fig_14">Figure 11</ref> shows the average ESD metric for approximate answers computed with TREESKETCHes and twig-XSKETCHes on a workload of 1000 twig queries, and for the XMark-TX, IMDB-TX, and SwissProt-TX data sets. We note that the increased distance numbers are partly due to the underlying MAC metric, which assigns a heavy penalty if the compared element sets contain the same sub-tree in different multiplicities. The interpretation of the results is therefore based on the relative performance of the two techniques, rather than on the absolute distances. Clearly, our novel TREESKETCH synopses consistently produce approximate answers of lower error. In all three data sets, the average distance for twigXSKETCHes is at least four times higher than the one for TREESKETCHes, and the error for a 10KB TREESKETCH synopsis (lowest budget) is less than the error for a 50KB twig-XSKETCH (highest budget). The effectiveness of TREESKETCHes can be attributed to our novel clustering-based summarization model, which captures very accurately the intrinsic sub-structure similarity found in XML data. The edge-histogram model used by twig-XSKETCHes, In terms of construction efficiency, we present a qualitative comparison between the two techniques since the twig-XSKETCH code base is not optimized for speed. The twig-XSKETCH construction algorithm starts from a coarse label-split graph, which contains exactly one node for all elements of the same tag, and gradually expands it through incremental refinement operations (basically, node splits, and histogram refinements). To evaluate the benefit of a candidate refinement, the algorithm measures the accuracy of the resulting twig-XSKETCH on a sample workload of twig queries (workload-based evaluation). Our proposed TSBUILD algorithm, on the other hand, compresses the stable summary down to the available space budget, using the squared error as a workloadindependent quality metric.   <ref type="table" target="#tab_20">Table 3</ref> compares the construction time for TREESKETCHes and twig-XSKETCHes for the IMDB-TX, XMark-TX, and SwissProt-TX data sets. All times are reported in minutes and were measured on an unloaded Pentium4 3GHz machine, running Linux. For TREESKETCH synopses, we measure the time to compress the stable summary down to the smallest summary possible, the label split graph; for twig-XSKETCHes, we measure the time needed to expand the original coarse summary to 10KB of storage. This represents a worst case scenario for TREESKETCHes since the distance from the stable summary to the label-split graph is certainly "longer" than the distance from the label-split-graph to 10KB. Still, a qualitative comparison of the measured times indicates that TREE-SKETCH construction is much more efficient. As we described in Section 4.2, the TSBUILD algorithm uses effective heuristics to explore limited, yet promising regions of the search space, while the squared error metric, which is workload-independent, avoids the most expensive step of the twig-XSKETCH algorithm, namely evaluating the accuracy of candidate summaries against sample workloads.</p><p>We have also evaluated the accuracy of TREESKETCH-generated approximate answers for the large datasets of <ref type="table" target="#tab_15">Table 1</ref>. The results remain qualitatively the same as for the smaller data sets and we omit them in the interest of space. A detailed presentation can be found in the full version of this paper <ref type="bibr" target="#b16">[17]</ref>. Note that we were not able to evaluate the performance of the twig-XSKETCH approach on the large data sets due to the high construction times.</p><p>Selectivity Estimation. In this experiment, we evaluate the effectiveness of our proposed synopses in estimating the selectivity of complex twig queries with branching path expressions. <ref type="figure" target="#fig_1">Fig- ure 12</ref> shows the average relative estimation error on a workload of 1000 queries for TREESKETCHes and twig-XSKETCHes, and for the XMark-TX and SwissProt-TX data sets. The results for the IMDB-TX data set are similar to XMark-TX and are omitted in the interest of space. As in the previous experiment, the results show that TREESKETCHes are effective in summarizing the key properties of the underlying path distribution. We observe that the estimation error remains well below 10% for all three data sets, even for small space budgets of 10KB-20KB that represent a small fraction of the original document sizes. Compared to twig-XSKETCHes, our new TREESKETCH synopses produce significantly more accurate estimates and exhibit more stable behavior. <ref type="figure" target="#fig_3">Figure 13</ref> shows the TREESKETCH estimation error over a workload of 1000 queries and for the XMark, IMDB, SwissProt, and DBLP data sets (the large data sets of <ref type="table" target="#tab_15">Table 1</ref>). The results verify the effectiveness of TREESKETCHes in computing accurate selectivity estimates for complex twig queries and demonstrate their nice scaling properties in terms of data size. In all four data sets, the estimation error drops below 5% for a space budget of 50KB, which in turn represents an extremely small fraction of the original document size. At the same time, the construction times remain affordable given the complexity and size of the involved data sets: 38 minutes for Swiss Prot, 11 minutes for DBLP, 2.5 minutes for IMDB, while the largest XMark data set required 4 hours.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS</head><p>Approximate answers constitute an effective solution for offsetting the high execution cost of complex XML queries in an interactive data exploration environment. In this paper, we have initiated the study of approximate query answering for XML data. We have proposed the TREESKETCH synopses, a novel class of structural summaries that capture very effectively the sub-structure similarity that is commonly found in XML data sets. We have developed a systematic evaluation algorithm for computing approximate answers over a concise TREESKETCH summary, and we have described an efficient heuristic construction algorithm for building an effective TREESKETCH for a limited space budget. To quantify the quality of the generated approximate answers, we have proposed a novel distance metric between XML trees that avoids the shortcomings of existing graph-theoretic metrics. Experimental results on real-life and synthetic data sets have verified the effectiveness of our approach and have demonstrated its benefits over previously proposed techniques.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 : (a) Twig Query, (b) Query Tree, (c) Nesting Tree.</head><label>2</label><figDesc>Figure 2: (a) Twig Query, (b) Query Tree, (c) Nesting Tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>P proceeds by jointly evalu- ating all XPath expressions in P over the XML tree, and generating the full set of binding element tuples for P 's variables. Each such binding tuple essentially specifies an assignment of element nodes to all the I query variables such that all structural constraints spec- ified in the query's ¢ I  ¦ I a edges are met. We will represent the binding tuples of a query P with a nesting tree  £  ¢ P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 (</head><label>3</label><figDesc>a,b). Both documents have the same set of distinct label-paths and differ only in the num- ber of v children for the different w elements (the corresponding counts/multiplicities are shown along the edge). It is straightfor- ward to verify that any twig query will have the same selectivity in either of the two documents and, in effect, both documents map to the same, zero-error twig-XSKETCH synopsis, shown in Fig- ure 3(c), with the (exact) edge histograms for nodes x and y de- picted in Figure 3(d). Consider, for instance, the twig query P shown in Figure 3(e</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :, (c) Twig-XSKETCH, (d) Edge-histograms, (e) Twig query ¤ , (f) Count-Stable Synopses.</head><label>3</label><figDesc>Figure 3: (a) Document</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>, j in the above definition es- sentially correspond to the extents of synopsis nodes inAs an example, the count stable summaries for the XML trees of Figure 3(a,b) are shown in Figure 3(f), where the summary edges are annotated with the corresponding m .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>DEFINITION 3 . 2 .</head><label>32</label><figDesc>A TREESKETCH synopsis¸i synopsis¸ synopsis¸i f for an XML data tree ¡ is a node-and edge-labeled graph-synopsis for ¡ , where: (1) each node in¸¹ in¸ in¸¹ f stores an element count count ¢ § d { extent ¢ ' { ; and, (2) each edge ¢ ¦ j in¸i in¸ in¸i f stores an (average) child count count ¢ ¦ j equal to the average number of children in extent ¢ j for each element in extent ¢ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>¡ and constructs the count-stable synop- sis graph f in a bottom-up fashion. A hash table s Å  z F ¦ h AE  is used to maintain the collection of equivalence classes (i.e., synopsis nodes) built thus far, hashed on the (common) class label z and the identi- fying tuple of child counts AE to other equivalence classes. The key observation here is that, by virtue of the post-order traversal, when visiting an element node , its children in ¡ have already been as- signed to equivalence classes in f ; thus, the equivalence clas for can be determined (with the help of s Å  ) based on its label and the classes and counts of its children (Step 3). If a class for does not already exist, a new class/synopsis node is created and the appro- priate edges and counts are added to f (Steps 4-8). Finally, is added to the extent of the corresponding synopsis node (Step 9). Algorithm BUILDSTABLE constructs the count-stable summary of an XML tree in linear Ç ¢  {¡  {</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>synopsis¸ synopsis¸i f (initialized to the count-stable graph), where each operation ß in the pool merges two nodes of¸¹ of¸ of¸¹ f (de-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>The pseudo-code for algorithm EVALEMBED is shown in Fig- ure 8. The final descendant count is computed as the number of descendants » T S along the main path of the embedding, scaled by the selectivity factors of the branch embeddings. The count » T S is estimated simply as the product of the corresponding edge counts, using the assumption that every element in source node has count ¢ © ¦ U d children to target node U d (this is the basic interpretation of the TREESKETCH model.) To estimate the selec- tivity À of branching predicate  l , the algorithm calls itself recur- sively to compute the number of descendants for each element of node (the source of the branch) along the different embeddings of  l . If there exists at least one embedding such that the descen- dant count is § l</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Algorithm EVALEMBED.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Figure 9: (a) Query</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 11 : Average ESD metric for approximate answers: (a) XMark-TX, (b) IMDB-TX, (c)</head><label>11</label><figDesc>Figure 11: Average ESD metric for approximate answers: (a) XMark-TX, (b) IMDB-TX, (c) SwissProt-TX</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 12 : Average selectivity estimation error: (a) XMark-TX, (b) SwissProt-TX. Figure 13 :</head><label>1213</label><figDesc>Figure 12: Average selectivity estimation error: (a) XMark-TX, (b) SwissProt-TX. Figure 13: TREESKETCH estimation error on large data sets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>e., a subset of (identically-labeled) data elements in ¡ (termed the extent of</head><label></label><figDesc></figDesc><table>The graph synopsis defined for 

¡ 

by such an equiva-
lence relation 

 

, denoted by 

f 
h g 
¢ 
8 ¡ 
i 

, can be represented as a graph, 
where: (1) each node 

j 

in 

f 
g 
¢ 
8 ¡ 
i 

corresponds to an equivalence 
class of 

 

, i.j 

and denoted by extent 

¢ 
j 


); and, (2) 
an edge 

¢ 

¦ 
j 


exists in 

f 
g 
¢ 
8 ¡ 
k 

if and only if some element node in 
extent 

¢ 



has a child element in extent 

¢ 
j 


. (We use label 

¢ 
j 


to denote the common label of all data elements in extent 

¢ 
j 


.) 
At a high level, several recently-proposed techniques for build-
ing path-index structures for XML (including 

l 

-indexes </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head></head><label></label><figDesc>edge distribution information, that captures the distribution of child counts for the elements in the node's extent, across different stable ancestor or de- scendant edges. These localized edge distributions are maintained selectively on a per-node basis in the form of edge histograms, and essentially enable the computation of selectivity estimates for twig queries. For a simple example, consider a synopsis node</figDesc><table>and two 
emanating synopsis edges 


o n 
j 

and 


p n 
r q 

. A two-dimensional 
edge histogram 

s 
u t 
¢ 
6 v 
d 
¦ 
 v 
e 


would capture the fraction of data ele-
ments in extent 

¢ 



that have exactly 

v 
d 

children in extent 

¢ 
j 


and 

v 
e 

children in extent 

¢ 
q 


</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>m -stable. Note that the element partitions</head><label></label><figDesc></figDesc><table>DEFINITION 3.1. Let 

 
¥  
¤ 
  
¦ ¤ 

denote a (label-respecting) 
equivalence relation over the nodes of 

¡ 
£ ¢ 
¥ ¤ 
 § ¦ 
 ¨ 
£ 

, and let 

¢ 

¦ 
j 


de-
note a pair of equivalence classes (i.e., element-node partitions) 
induced by 

 

. We say that the pair 

¢ 

¦ 
j 


is 

m 

-stable (where 

m 
¨  § 
© 

) 
if and only if each element 



ª 

has exactly 

m 

child elements in 

j 

. The relation 

 

and the graph synopsis 

f 
h g 
¢ 
8 ¡ 
i 

resulting from 
the corresponding element partitioning are said to be count stable 
if and only if, for every possible pair of element partitions 

¢ 

¦ 
j 


there exists some 

m 
¨  § 
© 

such that 

¢ 

¦ 
j 


is 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>The interpretation of the stored average is simple: all elements in the extent of</head><label></label><figDesc></figDesc><table>have count 

¢ 

¦ 
j 


child elements in the extent of 

j 

. Obviously, this is trivially satis-
fied in a stable synopsis where each edge 

¢ 

¦ 
j 


is count stable for 

m 
d 

count 

¢ 

¦ 
j 


. 
There is an interesting and intuitive connection between TREE-
SKETCHes and the clustering of points in multi-dimensional spaces. 
More specifically, let 

be a synopsis node with outgoing edges 


C n 
j 
d 

, . . . , 


C n 
j 
a º 

. The set of outgoing edges defines a 

» 

-
dimensional space, where an element 



ª 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head></head><label></label><figDesc>for the intermediate result synopsis, stems from the interpretation of the TREESKETCH sum- marization model: all elements in contain identically structured sub-trees and thus need to be represented only once in the synopsis (regardless of their ancestor nodes.) The query node I is included in the association in order to correctly handle the case where elements of the same node appear in the bindings of different query nodes. In order to compute the set of bindings</figDesc><table>The algorithm processes query 

P 

over the input synopsis¸¹ 

synopsis¸ synopsis¸¹ f 

and 
incrementally builds the result TREESKETCH¸i 

TREESKETCH¸ TREESKETCH¸i f 
Q 

. Each node 


Q 

¸ 
i f 
Q 

corresponds to a set of elements with tag label 

¢ 

Q 
 § 

, 
which come from the extent of a node¸i 


node¸ node¸i f 

and will appear 
in the bindings of query variable is a descendant count. Essentially, 
each 

¢ 
j 
¦ 
m 


y 
¢ 
I 
 
¦ 

Q 


specifies that every element in 


Q 

(the 
current binding for 

I 

) has exactly 

m 

descendants in 

j 

along path 

U 
V 
Y X 
a ` 
¢ 
I 
¦ 
I 
 


. The new bindings are recorded with the insertion of 
a node 

j 
Q 
¢ 
j 
¦ 
I 
 


and an edge 


Q 
n 
j 
Q 

. Since an element in 


Q 

can have descendants in the same node 

j 

through multiple paths 

procedure EVALQUERY(å 

¯ È 

,¤ ) 
Input: TREESKETCH 

å 
Ì È 

of document 

 

; twig query 

¤ 

Output: TREESKETCH 

å 
 È 
Q 

that approximates the nesting tree 

@ 

 
 
¤ 
 

begin 
1. Initialize 

å 
 È 
Q 

with root 

 
Q 
 

A 
" B 
C B 

9 
 
å 
 È 
 
cS 
 

2. for each 

c 
Ë 
õ ¤ 

in a pre-order traversal do 
3. 
for each 

Î 
Q 
 
 Î 
 
c 
 
Ë 
 
ð 
 
ö 
Õ 
c 
Ö 
6  
c 
 
Ë 

children 

 
c 
 

do 
4. 
Let 

í 
ò 

be the main path of 

) 
$9 

E D 

 
c 
 
c 
 
 

. 
5. 

F 

:= 

Í 
f Ê 

Ð 
Ê 

Ò 
Î 

H G 

ì 
ì 
 ì 

G 
¨ 
C I 

is an embedding of 

í 
ò 
¹ Ô 

6. 
for all 

Ê 

Ò 
Î 

H G 

ì 
ì 
 ì 

G 
¨ 
C I 

R Ë 

7 F 

do 
7. 

 

I 

:= EVALEMBED 

 
í 
 
Ê 
 

; 

 
k  
c 
 
Î 
Q 
 
è 
 

¨ 
C I 

 
F  

I 

 

8. 
done 
9. 
for 

 

¨ 

 
©  
 

in 

 
i  
c 
 
Î 
Q 
 

do 
10. 
Add nodë 

Q 
 

¨ 

 
c 
 
 

to 

å 
 È 
Q 

if it does not exist 
11. 
Add edge 

Î 
Q 
Ú 

¨ 

Q 

to 

å 
Ì È 
Q 

if it does not exist 
12. 
count 

 
 Î 
Q 
 

¨ 

Q 
 

Ò 
 

13. 
done 
14. 
done 
15. 
if 

 

¦ P 

c 
 
Ë 
 
ç 
ð 

¦  § 

£ ö 
 
Ê 
 
Õ 
c 
Ö 
Ï 
ð 
 
ö 
Õ 
c 
 
Ö 
Ò 

R Q 

 

then 
16. 
return 

Q 

// The answer is empty 
17. done 
18. return 

å 
Ì È 
Q 

end 

Figure 7: Algorithm EVALQUERY. 

in the synopsis, all counts 

m 

that correspond to the same 

j 

are ag-
gregated in count 

¢ 

Q 
¦ 
j 
Q 
e 

(line 12). Note that the algorithm in-
serts exactly one node 


Q 
¢ 

¦ 
I 


for each pair 

¢ 

¦ 
I 


, thus forming 
a graph-structured summary¸¹ 

summary¸ summary¸¹ f 
Q 

. This optimization, which guar-
antees a worst case size of 

Ç 
¢ 
 { 
¸ 
¹ f 
{ 
v } 
h { 
P 
{ 

y 
¢ 
I 
 
¦ 

Q 


for variable 

I 
 

, 
the algorithm first identifies the synopsis paths that possibly con-
tain descendants of 


Q 

along 

U 
W V 
Y X 
Y ` 
¢ 
I 
¦ 
I 
 


</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head>EXAMPLE 4 .1. Consider the invocation of EVALQUERY on the query P and synopsis¸i synopsis¸ synopsis¸i fiteration of EVALQUERY, variable I SI d to Ig . Starting from node  , which appears in the bindings of I dof I # g , therefore, will be the descendants of  along the given embedding. To compute the number of descendants for each element in  (algorithm EVALEMBED), we first observe that</head><label>4</label><figDesc></figDesc><table>shown in Figure 4.3. Initially, the result 
synopsis contains a root 

þQ 
¢ 
6 þ 
Y ¦ 
IS 


only and 

w 
¿ 
¥ » 
ü ý 
 IS 
d 
þQ 

. On 
the first is processed and the 
bindings of child variable 

I 
d 

are computed. In this case, it is easy 
to verify that each element in 

þ 
Y Q 

has 10 descendants along path 
//a to node 
 
. As a result, node 
 

Q 
Ì ¢ 

 

¦ 
I 
d 


is inserted in¸¹ 

in¸ in¸¹ f 
Q 

along with edge 
2 

Q 
n 

 

Q 

, and count 

¢ 

¦ 2 

 
¦ 

 

Q 

 § d 
l 
# 

. 
Let us consider now the processing of 

I 
d 

, and more specifically, 
the computation of bindings from 

, we can identify exactly 
one simple embedding of 

U 
W V 
X 
a ` 
¢ 
I 
d 
¦ 
Ig 

õ d 

  

 


" d 

 


¡ 
" e 
, namely 


ë d 

 

C f 
g 
" h 
. The bindings . The overall branch selectivity is 
computed as 

À 
d 

¼j 

# 

ª 
¼k 
¹ Ä 

¼j 
¹ } 

¼k 
õ d 

¼ 
 
a  

. Thus, the number 
of descendants along d[/g]//f for each binding in 

I 
d 

is 

l 
} 

¼ 
 
a  

and¸i 

and¸ and¸i f 
Q 

is updated accordingly. The final result synopsis¸i 

synopsis¸ synopsis¸i f 
Q 

is shown in </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13" validated="false"><head>and j be the left  elements of ¡ and ¡ d respectively. Elements ¦ j have children of tags v and ý (the roots of sub-trees ·  and · ù</head><label></label><figDesc></figDesc><table>In the case where one 
of 
£ 
v S 

¦ 
h ¤ 

S 
is empty, we apply a straightforward transformation so 
that the computation of 

ý 
¿ 
F À 

) 
1 x 

T ¢ 

£ 
w S 

¦ 
h ¤ 

S 

is well defined. More con-
cretely, assume without loss of generality that 

¤ 

S 

d 

z y 
. For each 
element 




£ 
w S 
, we insert a unique (artificial) element 

" { 
in 

¤ 

S 
with distancë 

distancë 
· 

v u 

¢ 

¦ 
© { 

k d 
{ 
{ 

, where 

{ 
{ 

is the sub-tree size of 

, and¨· 

and¨ and¨· 

v u 

¢ 

ó 
¦ 
 

$ { 

a 
 d 

} | 

G ¦ 

d ~ 

ü 
ó 


£ 
v S 

¦ 
© 
ó 

  

d 


. This transforma-
tion essentially models the insertion of the missing sub-trees under 

j 

and allows the set-distance metric to be computed on the new 
non-empty set 

¤ 

S 
. 

EXAMPLE 5.1. Consider the example of Figure 10 and let 

) 
and thus¨· 

thus¨ thus¨· 

v u 

¢ 

¦ 
j 

d 
ý 
¿ 
F À 

) 
1 x 

T ¢ 

£ 

 
¦ 
 ¤ 
 


# 

ª ý 
¿ 
F À 

) 
1 x 

T ¢ 

£ 

ù 
¦ 
¤ 
ù 


. In order 
to compute 

ý 
¿ 
F À 

) 
x 

¢ 

£ 

 
¦ 
 ¤ 
 


, we observe that the pairwise distances¨· 

distances¨ distances¨· 

v u 

¢ 
6 v¦ 
© v 

¦ 
© v 


£ 

 
¦ 
© v 

¤ 
 

are equal to 0, since the elements 
have identical sub-trees. Essentially, the two value sets contain 
equal values but at different multiplicities. If we use the MAC met-
ric [10], then the computed distance 

ý 
¿ 
F À 

) 
1 x 

T ¢ 

£ 

 
¦ 
 ¤ 
 


is equal to 8 
due to the difference in value frequencies. On the other hand, sets 

£ 

ù 

and 

¤ 
ù 

have the same elements at the same frequencies and thus 

ý 
¿ 
F À 

) 
x 

¢ 

£ 

ù 
¦ 
¤ 
ù 

Ì d 


. Overall, 

¨ 
· 

v u 

¢ 

¦ 
j 

e d 
 

 # 

© 
d 
 

. Now, as-
sume that 

j 
ó 

i s the left 

 

element of 

¡ 
e 

. It is straightforward to show 
that, under the same MAC metric, 

¨ 
· 

v u 

¢ 

¦ 
j 
ó 

é d 

 j 
and thus, as 
expected intuitively, the element of 

¡ 
e 

simulates better the element 
of the true result. 

Having defined the ESD metric between any two elements, we 
define the ESD metric between two trees 

¡ 
d 
¦ 
s ¡ 
e 

as¨· 

as¨ as¨· 

v u 

¢ 
8 ¡ 
d 
¦ 
s ¡ 
e 

¯ d 
¨ 
· 

v u 

¢ 

¦ 2 
4 3 
5 3 

X 
¢ 
8 ¡ 
d 

¦ 

( 2 
3 
5 3 

X 
¢ 
8 ¡ 
e 

© 

. We note that¨· 

that¨ that¨· 

v u 

¢ 
8 ¡ 
d 
¦ 
s ¡ 
e 


does not 
lend itself to a meaningful interpretation, except that a lower value 
represents increased similarity between 

¡ 
d 

and 

¡ 
e 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15" validated="false"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table>Data set characteristics 

summaries of 

¡ 
d 

and 

¡ 
e 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18" validated="false"><head>Table 2 : Workload characteristics</head><label>2</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_20" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Construction times (in minutes) for TREESKETCHes 
and twig-XSKETCHes 

</table></figure>

			<note place="foot" n="1"> Due to space constraints, a more detailed overview of related work can be found in the full version of this paper [17]</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Estimating the Selectivity of XML Path Expressions for Internet Scale Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashraf</forename><surname>Aboulnaga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alaa</forename><forename type="middle">R</forename><surname>Alameldeen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">F</forename><surname>Naughton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th Intl. Conf. on Very Large Data Bases</title>
		<meeting>the 27th Intl. Conf. on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Path Queries on Compressed XML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Grohe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Koch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Intl. Conf. on Very Large Data Bases</title>
		<meeting>the 29th Intl. Conf. on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Approximate Query Processing Using Wavelets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaushik</forename><surname>Chakrabarti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minos</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>Rastogi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyuseok</forename><surname>Shim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th Intl. Conf. on Very Large Data Bases</title>
		<meeting>the 26th Intl. Conf. on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">XQuery 1.0: An XML Query Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Don</forename><surname>Chamberlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniela</forename><surname>Florescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Robie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jérôme</forename><surname>Siméon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mugur</forename><surname>Stefanescu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
	<note>W3C Working Draft</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">From Tree Patterns to Generalized Tree Patterns: On Efficient Eavluation of XQuery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">V</forename><surname>Zhimin Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">S</forename><surname>Laks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stelios</forename><surname>Laksmanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Paparizos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Intl. Conf. on Very Large Data Bases</title>
		<meeting>the 29th Intl. Conf. on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Counting Twig Matches in a Tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">V</forename><surname>Zhiyuan Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Flip</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Korn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><surname>Muthukrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Divesh</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th Intl. Conf. on Data Engineering</title>
		<meeting>the 17th Intl. Conf. on Data Engineering</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">XSL Transformations (XSLT), Version 1.0&quot;. W3C Recommendation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Clark</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">XML Path Language (XPath), Version 1.0&quot;. W3C Recommendation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Derose</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">StatiX: Making XML Count</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juliana</forename><surname>Freire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jayant</forename><forename type="middle">R</forename><surname>Haritsa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maya</forename><surname>Ramanath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prasan</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J  Er  Ome</forename><surname>Sim  Eon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 ACM SIGMOD Intl. Conf. on Management of Data</title>
		<meeting>the 2002 ACM SIGMOD Intl. Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Histogram-Based Approximation of Set-Valued Query Answers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Yannis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Viswanath</forename><surname>Ioannidis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Poosala</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Intl. Conf. on Very Large Data Bases</title>
		<meeting>the 25th Intl. Conf. on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Exploiting Local Similarity for Efficient Indexing of Paths in Graph Structured Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raghav</forename><surname>Kaushik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pradeep</forename><surname>Shenoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phillip</forename><surname>Bohannon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ehud</forename><surname>Gudes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th Intl. Conf. on Data Engineering</title>
		<meeting>the 18th Intl. Conf. on Data Engineering</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">XPathLearner: An On-Line Self-Tuning Markov Histogram for XML Path Selectivity Estimation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Padmanabhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Vitter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Parr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th Intl. Conf. on Very Large Data Bases</title>
		<meeting>the 28th Intl. Conf. on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Query Optimization for XML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Mchugh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jennifer</forename><surname>Widom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Intl. Conf. on Very Large Data Bases</title>
		<meeting>the 25th Intl. Conf. on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Index structures for Path Expressions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tova</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th Intl. Conf. on Database Theory (ICDT&apos;99)</title>
		<meeting>the 7th Intl. Conf. on Database Theory (ICDT&apos;99)</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Statistical Synopses for Graph Structured XML Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Polyzotis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garofalakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 ACM SIGMOD Intl. Conf. on Management of Data</title>
		<meeting>the 2002 ACM SIGMOD Intl. Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Structure and Value Synopses for XML Data Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Polyzotis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garofalakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th Intl. Conf. on Very Large Data Bases</title>
		<meeting>the 28th Intl. Conf. on Very Large Data Bases</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Approximate XML Query Answers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neoklis</forename><surname>Polyzotis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minos</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yannis</forename><surname>Ioannidis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
		<respStmt>
			<orgName>University of California Santa Cruz</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Selectivity Estimation for XML Twigs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neoklis</forename><surname>Polyzotis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minos</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yannis</forename><surname>Ioannidis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th Intl. Conf. on Data Engineering</title>
		<meeting>the 20th Intl. Conf. on Data Engineering</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Geometric Techniques for Clustering: Theory and Practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Procopiuc</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
		<respStmt>
			<orgName>Duke Univ.</orgName>
		</respStmt>
	</monogr>
<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Fast algorithms for the unit cost editing distance between trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sasha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Jnl. of Algorithms</title>
		<imprint>
			<biblScope unit="page">11</biblScope>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Containment join size estimation: Models and methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haifeng</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hongjun</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey Xu</forename><surname>Yu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM SIGMOD Intl. Conf. on Management of Data</title>
		<meeting>the 2003 ACM SIGMOD Intl. Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Estimating Answer Sizes for XML Queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuqing</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jignesh</forename><forename type="middle">M</forename><surname>Patel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th</title>
		<meeting>the 8th</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Conf</surname></persName>
		</author>
		<title level="m">on Extending Database Technology</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">BIRCH: An Efficient Data Clustering Method for Very Large Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Livny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1996 ACM SIGMOD Intl. Conf. on Management of Data</title>
		<meeting>the 1996 ACM SIGMOD Intl. Conf. on Management of Data</meeting>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
