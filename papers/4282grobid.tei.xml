<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T04:09+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">FuzzGen: Automatic Fuzzer Generation FuzzGen: Automatic Fuzzer Generation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 12-14, 2020</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyriakos</forename><surname>Ispoglou</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Google Inc</orgName>
								<orgName type="institution" key="instit2">Mathias Payer</orgName>
								<orgName type="institution" key="instit3">Google Inc</orgName>
								<orgName type="institution" key="instit4">Google Inc</orgName>
								<orgName type="institution" key="instit5">Google Inc</orgName>
								<address>
									<region>EPFL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Austin</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Google Inc</orgName>
								<orgName type="institution" key="instit2">Mathias Payer</orgName>
								<orgName type="institution" key="instit3">Google Inc</orgName>
								<orgName type="institution" key="instit4">Google Inc</orgName>
								<orgName type="institution" key="instit5">Google Inc</orgName>
								<address>
									<region>EPFL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vishwath</forename><surname>Mohan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Google Inc</orgName>
								<orgName type="institution" key="instit2">Mathias Payer</orgName>
								<orgName type="institution" key="instit3">Google Inc</orgName>
								<orgName type="institution" key="instit4">Google Inc</orgName>
								<orgName type="institution" key="instit5">Google Inc</orgName>
								<address>
									<region>EPFL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyriakos</forename><forename type="middle">K</forename><surname>Ispoglou</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Google Inc</orgName>
								<orgName type="institution" key="instit2">Mathias Payer</orgName>
								<orgName type="institution" key="instit3">Google Inc</orgName>
								<orgName type="institution" key="instit4">Google Inc</orgName>
								<orgName type="institution" key="instit5">Google Inc</orgName>
								<address>
									<region>EPFL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Austin</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Google Inc</orgName>
								<orgName type="institution" key="instit2">Mathias Payer</orgName>
								<orgName type="institution" key="instit3">Google Inc</orgName>
								<orgName type="institution" key="instit4">Google Inc</orgName>
								<orgName type="institution" key="instit5">Google Inc</orgName>
								<address>
									<region>EPFL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vishwath</forename><surname>Mohan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Google Inc</orgName>
								<orgName type="institution" key="instit2">Mathias Payer</orgName>
								<orgName type="institution" key="instit3">Google Inc</orgName>
								<orgName type="institution" key="instit4">Google Inc</orgName>
								<orgName type="institution" key="instit5">Google Inc</orgName>
								<address>
									<region>EPFL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>EPFL</roleName><forename type="first">Mathias</forename><surname>Payer</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Google Inc</orgName>
								<orgName type="institution" key="instit2">Mathias Payer</orgName>
								<orgName type="institution" key="instit3">Google Inc</orgName>
								<orgName type="institution" key="instit4">Google Inc</orgName>
								<orgName type="institution" key="instit5">Google Inc</orgName>
								<address>
									<region>EPFL</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">FuzzGen: Automatic Fuzzer Generation FuzzGen: Automatic Fuzzer Generation</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 29th USENIX Security Symposium</title>
						<meeting>the 29th USENIX Security Symposium						</meeting>
						<imprint>
							<date type="published">August 12-14, 2020</date>
						</imprint>
					</monogr>
					<note>This paper is included in the Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Fuzzing is a testing technique to discover unknown vul-nerabilities in software. When applying fuzzing to libraries, the core idea of supplying random input remains unchanged, yet it is non-trivial to achieve good code coverage. Libraries cannot run as standalone programs, but instead are invoked through another application. Triggering code deep in a library remains challenging as specific sequences of API calls are required to build up the necessary state. Libraries are diverse and have unique interfaces that require unique fuzzers, so far written by a human analyst. To address this issue, we present FuzzGen, a tool for automatically synthesizing fuzzers for complex libraries in a given environment. FuzzGen leverages a whole system analysis to infer the library&apos;s interface and synthesizes fuzzers specifically for that library. FuzzGen requires no human interaction and can be applied to a wide range of libraries. Furthermore, the generated fuzzers leverage LibFuzzer to achieve better code coverage and expose bugs that reside deep in the library. FuzzGen was evaluated on Debian and the Android Open Source Project (AOSP) selecting 7 libraries to generate fuzzers. So far, we have found 17 previously unpatched vul-nerabilities with 6 assigned CVEs. The generated fuzzers achieve an average of 54.94% code coverage; an improvement of 6.94% when compared to manually written fuzzers, demonstrating the effectiveness and generality of FuzzGen.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Modern software distributions like Debian, Ubuntu, and the Android Open Source Project (AOSP) are large and complex ecosystems with many different software components. Debian consists of a base system with hundreds of libraries, system services and their configurations, and a customized Linux kernel. Similarly, AOSP consists of the ART virtual machine, Google's support libraries, and several hundred third party components including open source libraries and vendor specific code. While Google has been increasing efforts to fuzz test this code, e.g., OSS-Fuzz <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b35">36]</ref>, code in these repositories does not always go through a rigorous code review process. All these components in AOSP may contain vulnerabilities and could jeopardize the security of Android systems. Given the vast amount of code and its high complexity, fuzzing is a simple yet effective way of uncovering unknown vulnerabilities <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b26">27]</ref>. Discovering and fixing new vulnerabilities is a crucial factor in improving the overall security and reliability of Android.</p><p>Automated generational grey-box fuzzing, e.g., based on AFL <ref type="bibr" target="#b43">[44]</ref> or any of the more recent advances over AFL such as AFLfast <ref type="bibr" target="#b5">[6]</ref>, AFLGo <ref type="bibr" target="#b4">[5]</ref>, collAFL <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr">Driller [37]</ref>, VUzzer <ref type="bibr" target="#b30">[31]</ref>, T-Fuzz <ref type="bibr" target="#b27">[28]</ref>, QSYM <ref type="bibr" target="#b41">[42]</ref>, or Angora <ref type="bibr" target="#b7">[8]</ref> are highly effective at finding bugs in programs by mutating inputs based on execution feedback and new code coverage <ref type="bibr" target="#b23">[24]</ref>. Programs implicitly generate legal complex program state as fuzzed input covers different program paths. Illegal paths quickly result in an error state that is either gracefully handled by the program or results in a true crash. Code coverage is therefore an efficient indication of fuzzed program state.</p><p>While such greybox-fuzzing techniques achieve great results regarding code coverage and number of discovered crashes in programs, their effectiveness does not transfer to fuzzing libraries. Libraries expose an API without dependency information between individual functions. Functions must be called in the right sequence with the right arguments to build complex state that is shared between calls. These implicit dependencies between library calls are often mentioned in documentation but are generally not formally specified. Calling random exported functions with random arguments is unlikely to result in an efficient fuzzing campaign. For example, libmpeg2 requires an allocated context that contains the current encoder/decoder configuration and buffer information. This context is passed to each subsequent library function. Random fuzzing input is unlikely to create this context and correctly pass it to later functions. Quite the contrary, it will generate a large number of false positive crashes when library dependencies are not enforced, e.g., the configuration function may set the length of the allocated decode buffer in the internal state that is passed to the next function. A fuzzer that is unaware of this length field may supply a random length, resulting in a spurious buffer overflow. Alternatively, "invalid state checks" in library functions will likely detect dependency violations and terminate execution early, resulting in wasted fuzzing performance. To effectively fuzz libraries, a common approach is to manually write small programs which build up state and call API functions in a "valid" sequence. This allows the fuzzer to build up the necessary state to test functionality deep in the library.</p><p>libFuzzer <ref type="bibr" target="#b32">[33]</ref> facilitates library fuzzing through the help of an analyst. The analyst writes a small "fuzzer stub", a function that (i) calls the required library functions to set up the necessary state and (ii) leverages random input to fuzz state and control-flow. The analyst must write such a stub for each tested component. Determining interesting API calls, API dependencies, and fuzzed arguments is at the sole discretion of the analyst. While this approach mitigates the challenge of exposing the API, it relies on deep human knowledge of the underlying API and its usage. Hence, this approach does not scale to many different libraries.</p><p>FuzzGen is based on the following intuition: existing code on the system utilizes the library in diverse aspects. Abstracting the graph of possible library dependencies allows us to infer the complex library API. Different aspects of the API are tested by automatically generating custom fuzzer stubs based on the inferred API. The automatically generated fuzzers will execute sequences of library calls that are similar to those present in real programs without the "bloat" of real programs, i.e., removing all computation that is not strictly necessary to build the state required for fuzzing. These fuzzers will achieve deep coverage, improving over fuzzers written by an analyst as they consider real deployments and API usage.</p><p>On one hand, many libraries contain unit tests that exercise simple aspects of the library. On the other hand, programs that utilize a library's API build up deep state for specific functions. Leveraging only individual test cases for fuzzing is often too simplistic and building on complex programs results in low coverage as all the program functionality is executed alongside the target library. Test cases are too simple and fail to expose deep bugs while full programs are too complex. A mechanism that automatically constructs arbitrarily complex fuzzer stubs with complex API interactions and library state allows sufficient testing of complex API functions. The set of all test cases and programs which use a library covers nearly all relevant API invocations and contains code to set up the necessary complex state to execute API calls. The vast amount of different library usages implicitly defines an Abstract API Dependence Graph (A 2 DG). Based on this A 2 DG it is possible to automatically create fuzzer stubs that test different aspects of a library <ref type="figure" target="#fig_0">(Figure 1)</ref>.</p><p>To address the challenges of fuzzing complex libraries, we propose FuzzGen. FuzzGen consists of three parts: an API inference, an A 2 DG construction mechanism, and a fuzzer generator that leverages the A 2 DG to produce a custom libFuzzer "fuzzer stub". The API inference component builds an A 2 DG based on all test cases and programs on a system that use a given library. The A 2 DG is a graph that records all API interactions, including parameter value range and possible interactions. Our analysis infers library use and constructs a generic A 2 DG based on this use. The fuzzer generator synthesizes fuzzers that build up complex state and leverage fuzz input to trigger faults deep in the library. FuzzGen automates the manual process of the analyst in creating custom-tailored fuzzers for libraries and specific library functions. The key contribution of FuzzGen is an automatic way to create new libFuzzer <ref type="bibr" target="#b32">[33]</ref> stubs, enabling broad and deep library fuzzing.</p><p>FuzzGen performs a whole system analysis, iterating over all programs and libraries that use the target library to infer the A 2 DG. It then automatically generates fuzzer stubs (ranging from 1, 000 to 10, 000 LoC) that encode the A 2 DG and use libFuzzer to fuzz individual API components. FuzzGen was evaluated on Debian and Android <ref type="bibr" target="#b1">[2]</ref>.</p><p>Our evaluation of FuzzGen so far, resulted in 17 discovered vulnerabilities in the Android media framework, with 6 assigned CVEs: CVE-2019-2176 <ref type="bibr" target="#b15">[16]</ref>, CVE-2019-2108 <ref type="bibr" target="#b14">[15]</ref>, CVE-2019-2107 <ref type="bibr" target="#b13">[14]</ref> and CVE-2019-2106 <ref type="bibr" target="#b12">[13]</ref> (critical), CVE-2017-13187 <ref type="bibr" target="#b11">[12]</ref> (high) and -duplicate-CVE-2017-0858 <ref type="bibr" target="#b10">[11]</ref> (medium). (in Appendix C we provide more details on these vulnerabilities). Finding and eliminating vulnerabilities in these components is crucial to prevent potential attacks such as StageFright <ref type="bibr" target="#b16">[17]</ref>. So far, FuzzGen has reported 17 new vulnerabilities in Android native libraries and Debian. The discovered bugs range from denial of service to stack buffer overflows, as shown in Section 6. Overall FuzzGen makes the following contributions:</p><p>• Design of a whole system analysis that infers valid API interactions for a given library based on existing programs and libraries that use the target libraryabstracting the information into an Abstract API Dependence Graph (A 2 DG);</p><p>• Based on the A 2 DG, FuzzGen creates libFuzzer stubs that construct complex program state to expose vulnerabilities in deep library functions was developed-fuzzers are generated without human interaction;</p><p>• Evaluation of the prototype on AOSP and Debian demonstrates the effectiveness and the generality of the FuzzGen technique. Generating fuzzers for 7 libraries, FuzzGen discovered 17 bugs. The generated fuzzers achieve 54.94% code coverage on average, compared to 48.00% that fuzzer stubs-written manually by expertsachieve.</p><p>A note on disclosure: All bugs have been responsibly disclosed, and fixes have been pushed to the corresponding projects. The source code of our prototype is available at https://github.com/HexHive/FuzzGen, allowing other researchers to reproduce our results and to extend our automatic fuzzer generation technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The case for API-aware fuzzer construction</head><p>Writing an effective API-aware fuzzer requires an in-depth understanding of the target library and pinpointing the interesting components for fuzzing. Consider the libmpeg2 library, which provides encoding and decoding functions for MPEG2 video streams. The library contains several functions to build up a per-stream context that other functions take as a parameter. This approach of encapsulating state is common in libraries. <ref type="figure" target="#fig_2">Figure 2</ref> shows a code snippet for properly initializing an MPEG2 decoding object. A fully initialized decoder object is required to decode a video frame. Without this decoder object, frames cannot be decoded.</p><p>While a target-agnostic fuzzer (invoking all functions with random arguments in a random order) may find simple issues, deep bugs will likely be missed due to their dependence on complex state. Naive fuzzers are also prone to false positives due to lack of API awareness. Consider a fuzzer that targets frame decoding. If the context does not contain a valid length with a pointer to an allocated decode buffer then the fuzzer will trigger a false positive crash when the decoded frame is written to unallocated memory. However, this is not a bug in the decode function. It is simply improper initialization. Orthogonally, by supplying random values to certain arguments, such as function pointers or sizes, a fuzzer may trigger memory errors. These crashes do not correspond to actual bugs or vulnerabilities as such an illegal context cannot be generated through any possible execution of a benign use of the library. Inferring API dependencies, such as generating a common <ref type="bibr" target="#b0">1</ref>   <ref type="figure" target="#fig_2">Figure 2</ref>: Source code that initializes an MPEG2 decoder object. Low level details such as struct field initializations, variable declarations, or casts are omitted for brevity.</p><p>context, initializing the necessary buffers, and preparing it for usage, is challenging because dependencies are not encoded as part of the library specification. However, by observing a module that utilizes libmpeg2 (i.e., a library consumer), we could observe the dependencies between the API calls and infer the correct order of context initialization calls. Such dependencies come in the form of (a) control flow dependencies and (b) shared arguments (variables that are passed as arguments in more than one API call). Furthermore, arguments that hold the state of the library (e.g., the context), should not be fuzzed, but instead they should be passed, without intermediate modification, from one call to the next. Note that this type of information is usually not formally specified. The libmpeg2 library exposes a single API call, impeg2d_api_function, that dispatches to a large set of internal API functions. Yet, this state machine of API dependencies is not made explicit in the code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Background and Related Work</head><p>Early fuzzers focused on generating random parameters to test resilience of code against illegal inputs. Different forms of fuzzers exist depending on how they generate input, handle crashes, or process information. Generational fuzzers, e.g., PROTOS <ref type="bibr" target="#b31">[32]</ref>, SPIKE <ref type="bibr" target="#b0">[1]</ref>, or PEACH <ref type="bibr" target="#b17">[18]</ref>, generate inputs based on a format specification, while mutational fuzzers, e.g., AFL <ref type="bibr" target="#b43">[44]</ref>, honggfuzz <ref type="bibr" target="#b38">[39]</ref>, or zzuf <ref type="bibr" target="#b21">[22]</ref>, synthesize inputs through random mutations on existing inputs, according to some criterion (e.g., code coverage). Typically, increasing code coverage and number of unique crashes is correlated with fuzzer effectiveness.</p><p>Mutational fuzzers have become the de-facto standard for fuzzing due to their efficiency and ability to adapt input. The research community developed additional metrics to classify fuzzers, based on their "knowledge" about the target program.</p><p>Blackbox fuzzers, have no information about the program under test. That is, they treat all programs equally, which allows them to target arbitrary applications. Whitebox fuzzers are aware of the program that they test and are target-specific. They adjust inputs based on some information about the target program, targeting more "interesting" parts of the program. Although whitebox fuzzers are often more effective in finding bugs (as they focus on a small part of the program) and therefore have lower complexity, they require manual effort and analysis and allow only limited reuse across different programs (the whitebox fuzzer for program A cannot be used for program B). Greybox fuzzers attempt to find a balance between blackbox and whitebox fuzzing by inferring information about the program and feeding that information back to guide the fuzzing process. Evaluating fuzzers is challenging. We follow proposed guidelines <ref type="bibr" target="#b23">[24]</ref> for a thorough evaluation.</p><p>Code coverage is often used in greybox fuzzers to determine if an input should be further evaluated. The intuition is that the more code a given input can reach the more likely is to expose bugs that reside deep in the code. Fuzzers are limited by the coverage wall. This occurs when the fuzzer stops making progress, and could be due to limitations of the model, input generation, or other constraints. Any newly generated input will only cover code that has already been tested. Several recent extensions of AFL have tried to address the coverage wall using symbolic or concolic execution techniques <ref type="bibr" target="#b22">[23]</ref> and constraint solving. Driller <ref type="bibr" target="#b36">[37]</ref> detects if the fuzzer no longer increases coverage and leverages program tracing to collect constraints along paths. Driller then uses a constraint solver to construct inputs that trigger new code paths. Driller works well on CGC binaries but the constraint solving cost can become high for larger programs. VUzzer <ref type="bibr" target="#b30">[31]</ref> leverages static and dynamic analysis to infer control-flow of the application under test, allowing it to generate application-aware input. T-Fuzz <ref type="bibr" target="#b27">[28]</ref> follows a similar idea but instead of adding constraint solving to the input generation loop, it rewrites the binary to bypass hard checks. If a crash is found in the rewritten binary, constraint solving is used to see if a crash along the same path can be triggered in the original binary. FairFuzz <ref type="bibr" target="#b25">[26]</ref> increases code coverage by prioritizing inputs that reach "rare" (i.e., triggered by very few inputs) areas of the program, preventing mutations on checksums or strict header formats. FuzzGen addresses the coverage wall by generating multiple different fuzzers with different API interactions. The A 2 DG allows FuzzGen to quickly generate alternate fuzz drivers that explore other parts of the library under test.</p><p>Although the aforementioned fuzzing approaches are effective in exposing unknown vulnerabilities, they assume that the target program has a well defined interface to supply random input and observe for crashes. These methods cannot be extended to deal with libraries. A major challenge is the interface diversity of the libraries, where each library provides a different interface through its own set of exported API calls. DIFUZE <ref type="bibr" target="#b9">[10]</ref> was the first approach for interface-aware fuzzing of kernel drivers. Kernel drivers follow a well-defined interface (through ioctl) allowing DIFUZE to reuse common structure across drivers. FuzzGen infers how an API is used from existing use cases and generates fuzzing functions based on observed usage. SemFuzz <ref type="bibr" target="#b40">[41]</ref>, used naturallanguage processing to process the CVE descriptions and extract the location of the bug. Then it uses this information to synthesize inputs that target this specific part of the vulnerable code.</p><p>Developed concurrently and independently from FuzzGen, FUDGE <ref type="bibr" target="#b3">[4]</ref> is the most recent effort on automated fuzz driver generation. FUDGE leverages a single library consumer to infer valid API usages of a library to synthesize fuzzers. However there are two major differences to our approach: First, FUDGE extracts sequences of API calls and their context (called "snippets") from a single library consumer and then uses these snippets to create fuzz drivers which are then tested using a dynamic analysis. Instead of extracting short snippets from consumers, FuzzGen minimizes consumers (iterating over the consumer's CFG) to only the library calls, their dependent checks, and dependent arguments/data flow. Second, FUDGE creates many small fuzz drivers from an extracted snippet. In comparison, FuzzGen merges multiple consumers to a graph where sequences of arbitrary length can be synthesized. Instead of the 1-N approach of FUDGE, FuzzGen uses an M-N approach to increase flexibility. Compared to FUDGE, FuzzGen fuzzers are larger, more generic, focusing on complex API interaction and not just short API sequences.</p><p>Beside fuzzing, there are several approaches to infer API usage and specification. One way to infer API specifications <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b29">30]</ref> is through dynamic analysis. This approach collects runtime traces from an application, analyzes objects and API calls and produces Finite State Machines (FSMs) that describe valid sequences of API calls. This set of API specifications is solely based on dynamic analysis. Producing rich execution traces that utilize many different aspects of the library requires the ability to generate proper inputs to the program. Similarly, API Sanitizer <ref type="bibr" target="#b42">[43]</ref> finds violation of API usages. APISan infers correct usages of an API from other uses of the API and ranks them probabilistically, without relying on whole-program analysis. APISan leverages symbolic execution to create a database of (symbolic) execution traces and statistically infers valid API usages. APISan suffers from limited scalability due to symbolic execution. As a static analysis tool, it may result in false positives. SSLint <ref type="bibr" target="#b20">[21]</ref> targets SSL/TLS libraries and discovers API violations based on an analyst-encoded API graph. MOPS <ref type="bibr" target="#b6">[7]</ref> is a static analyzer that uses a set of safe programming rules and searches for violations of those rules. Yamaguchi et. al <ref type="bibr" target="#b39">[40]</ref> present a technique that mines common vulnerabilities from source code, representing them as a code property graph. Based on this representation, they discover bugs in other programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Design</head><p>To synthesize customized fuzzer stubs for a library, FuzzGen requires both the library and code that exercises the library (referred to as library consumer). FuzzGen leverages a whole system analysis to infer the library API, scanning consumers for library calls. The analysis detects all valid library usage, e.g., valid sequences of API calls and possible argument ranges for each call. This information is essential to create reasonable fuzzer stubs and is not available in the library itself.</p><p>By leveraging actual uses of API sequences, FuzzGen synthesizes fuzzer code that follows valid API sequences, comparable to real programs. Our library usage analysis allows FuzzGen to generate fuzzer stubs that are similar to what a human analyst would generate after learning the API and learning how it is used in practice. FuzzGen improves over a human analyst in several ways: it leverages real-world usage and builds fuzzer stubs that are close to real API invocations; it is complete and leverages all uses of a library, which could be manually overlooked; and FuzzGen scales to full systems due to its automation without requiring human interaction.</p><p>At a high level, FuzzGen consists of three distinct phases, as shown in <ref type="figure" target="#fig_0">Figure 1</ref>. First, FuzzGen analyzes the target library and collects all code on the system that utilizes functions from this library to infer the basic API. Second, FuzzGen builds the Abstract API Dependence Graph (A 2 DG), which captures all valid API interactions. Third, it synthesizes fuzzer stubs based on the A 2 DG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Inferring the library API</head><p>FuzzGen leverages the source files from the consumers to infer the library's exported API. First, the analysis enumerates all declared functions in the target library, F lib . Then, it identifies all functions that are declared in all included headers of all consumers, F incl . Then, the set of potential API functions, F API is:</p><formula xml:id="formula_0">F API ← F lib ∩ F incl (1)</formula><p>FuzzGen's analysis relies on the Clang framework to extract this information during the compilation of library and consumer. To address over-approximation of inferred library functions (e.g., identification of functions that belong to another library that is used by the target library), FuzzGen applies a progressive library inference. Each potential API function is checked by iteratively compiling a test program linked with the target library. If linking fails, the function is not part of the library. Under-approximations are generally not a problem as functions that are exported but never used in a consumer are not reachable through attacker-controlled code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">A 2 DG construction</head><p>FuzzGen iterates over library consumers that invoke API calls from the target library and leverages them to infer valid API interactions. It builds an abstract layout of library consumers which is used to construct fuzzer stubs. Recall that FuzzGen fuzzer stubs try to follow an API flow similar to that observed in real programs to build up complex state. FuzzGen fuzzer stubs allow some flexibility as some API calls may execute in random order at runtime, depending on the fuzzer's random input. The A 2 DG represents the complicated interactions and dependencies between API calls, allowing the fuzzer to satisfy these dependencies. It exposes which functions are invoked first (initialization), which are invoked last (tear down), and which are dependent on each other.</p><p>The A 2 DG encapsulates two types of information: control dependencies, and data dependences. Control dependencies indicate how the various API calls should be invoked, while data dependencies describe the potential dependencies between arguments and return values in the API calls (e.g., if the return value of an API call is passed as an argument in a subsequent API call).</p><p>The A 2 DG is a directed graph of API calls, similar to a coarse-grained Control-Flow Graph (CFG) that expresses sequences of valid API calls in the target library. Edges are also annotated with valid parameter ranges to further improve fuzzing effectiveness as discussed in the following sections. Each node in the A 2 DG corresponds to a single call of an API function, and each edge represents control flow between two API calls. The A 2 DG encodes the control flow across the various API calls and describes which API calls are reachable from a given API call. <ref type="figure" target="#fig_1">Figure 3 (a)</ref> shows an instance of the CFG from a libopus consumer. The corresponding A 2 DG is shown in <ref type="figure" target="#fig_1">Figure 3 (b)</ref>.</p><p>Building the A 2 DG is two step process. First, a set of basic A 2 DGs is constructed, one A 2 DG for each root function in each consumer. Second, the A 2 DGs of all consumers are coalesced into a single A 2 DG.</p><p>Constructing a basic A 2 DG. To build a basic A 2 DG, FuzzGen starts with a consumer's CFG. If the consumer is a library, FuzzGen builds CFGs for each exported API function, otherwise it starts with the main function. To reconcile the collection of CFGs, FuzzGen leverages the Call Graph of the consumer. An individual analysis starts at the entry basic block of every root function in the call graph to explore the full consumer. This may lead to a large number of A 2 DGs for a library consumer.</p><p>Starting from the entry basic block of a root function, FuzzGen iteratively removes every basic block that does not contain a call instruction to an API call. If a basic block contains multiple call instructions to API functions, the basic block is split into multiple A 2 DG nodes with one API call each. If a basic block calls a non-API function, FuzzGen recursively calculates the A 2 DG for the callee and results are integrated  Select any two A 2 DG graphs and try to coalesce them together. Repeat this process until there are no two A 2 DG that can be coalesced together.</p><p>To coalesce two A 2 DGs they must have at least one node in common. Two nodes are considered "common" if they invoke the same API call with the same arguments of the same type. FuzzGen starts from the root and selects the first common node. FuzzGen then removes the node from one graph and migrates all children, along with their sub trees, to the other A 2 DG, continuously merging common nodes. A common node is a requirement, as placing the nodes from the second A 2 DG at random positions will likely result in illegal target states. If there are no common nodes, FuzzGen keeps the A 2 DGs separate, synthesizing two different fuzzers. <ref type="figure" target="#fig_1">Figure 3</ref> (d) shows an example of the A 2 DG produced after coalescing the two A 2 DGs in <ref type="figure" target="#fig_1">Figure 3</ref> (b) and (c). The nodes with function opus_decoder_destroy are coalesced (as the argument is a handle, which has the same type), but other nodes like opus_decoder_ctl are not coalesced as the arguments are different. It is possible for the coalesced A 2 DG to result in an inconsistent state, which results in an API misuse. That is, the coalesced A 2 DG may contain a path (i.e., a subset of API calls) that violates API usage and therefore causes problems to execution state of the library. In Appendix A, we explain this problem in detail.</p><p>Our experiments showed that it may be feasible to coalesce two A 2 DGs without common nodes by backward-slicing and locating function usages that invoke the API call. We leave this along with other heuristics to coalesce A 2 DGs into a single one, for future work.</p><p>Precision of A 2 DG construction. The current FuzzGen A 2 DG construction has two sources of imprecision: static analysis and merging. First, the static analysis results in an over-approximation of paths. This may result in false posi-</p><formula xml:id="formula_1">Algorithm 1: A 2 DG construction. Input: Function F to start A 2 DG construction Output: The corresponding A 2 DG 1 Function make_AADG(Function F) 2 "A ∪ = B" is shorthand for "A = A ∪ B" 3 if F ∈ C S then return ( / 0, / 0) else C S ∪ = {F} 4 G A 2 DG ← (V A 2 DG , E A 2 DG ) 5 foreach basic block B ∈ CFG F do 6</formula><p>An empty vertex is not associated with an API call tives due to illegal API sequences that do not occur in real programs. Second, the merging process may over-eagerly merge two A 2 DGs with different or slightly different parameters, resulting in illegal API sequences. We will discuss these sources of false positives in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Argument flow analysis</head><p>To create effective fuzzers, the A 2 DG requires both control and data dependencies. To construct the data dependencies between API calls FuzzGen leverages two analyses: argument value-set inference (what values are possible) and argument dependence analysis (how are individual variables reused).</p><p>Argument value-set inference. Argument value-set inference answers two questions: which arguments to fuzz and how to fuzz these arguments. Supplying arbitrary random values (i.e., "blind" fuzzing) to every argument imposes significant limitations both in the efficiency and the performance of fuzzing. Contexts, handles, and file/socket descriptors are examples that result in large numbers of false positives. Supplying random values for a descriptor in an API call results in shallow coverage as there are sanity checks at the beginning of the function call. Some arguments present diminishing returns when being fuzzed. Consider an argument that is used to hold output, or an argument that is part of a switch statement. In both cases, a fuzzer will waste cycles generating large inputs, where only a few values are meaningful. To better illustrate this, consider a fuzzer for memcpy:</p><formula xml:id="formula_2">void *memcpy(void *dest, const void *src, size_t n);</formula><p>Supplying arbitrary values to n makes it inconsistent with the actual size of src, which results in a segmentation fault. However this crash does not correspond to a real bug. Also, the fuzzer may invest many cycles generating random values for the dest argument, which is never read by memcpy() (please ignore the corner case of overlapping source and destination arguments for the sake of the example).</p><p>Our analysis classifies arguments into two categories according to their type: primitive arguments (e.g., char, int, float, or double) and composite arguments (e.g., pointers, arrays, or structs). The transitive closure of composite arguments are a collection of primitive arguments-pointers may have multiple layers (e.g., double indirect pointers), structures may contain nested structures, or arrays-and therefore they cannot be fuzzed directly. That is, they cannot be assigned a random (i.e., fuzz) value, upon the invocation of the API call but require type-aware construction. Consider an API call with a pointer to an integer as the first argument. Clearly, fuzzing this argument results in segmentation faults when the function dereferences a likely invalid pointer. Instead, the pointer should point to an integer. The pointed-to address can be safely fuzzed. FuzzGen performs a data-flow analysis in the target library for every function for every argument, to infer the possible values that an argument could get.</p><p>Argument dependence analysis. Data-flow dependencies are as important as control-flow dependencies. A fuzzer must not only follow the intended sequence of API calls but must also provide matching data flow. For example, after creating a context, it must be passed to specific API calls for further processing. If this does not occur, it will likely result in a violation of a state check or a spurious memory corruption.  <ref type="figure">Figure 4</ref>: FuzzGen implementation overview.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX</head><p>Data-flow dependencies in an A 2 DG can be intraprocedural and inter-procedural. First, FuzzGen identifies data dependencies through static per-function alias analysis of the code using libraries, tracking arguments and return values across API calls. Static alias analysis has the advantage of being complete, i.e., allowing any valid data-flow combinations but comes at the disadvantage of imprecision. For example, if two API calls both leverage a parameter of type struct libcontext then our static analysis may be unable to disambiguate if the parameters point to the same instance or to different instances. This over-approximation can result in spurious crashes. FuzzGen leverages backward and forward slicing on a per-method basis to reduce the imprecision due to basic alias analysis.</p><p>Second, FuzzGen identifies dependencies across functions: For each edge in the A 2 DG, FuzzGen performs another data flow analysis for each pair of arguments and return values to infer whether whether they are dependent on each other.</p><p>Two alternative approaches could either (i) leverage concrete runtime executions of the example code which would result in an under-approximation with the challenge of generating concrete input for the runtime execution or (ii) leverage an inter-function alias analysis that would come at high analysis cost. Our approach works well in practice and we leave exploration of more precise approaches as future work.</p><p>The A 2 DG (i.e., API layout) exposes the order and the dependencies between the previously discovered API calls. However, the arguments for the various API calls may expose further dependencies. The task of this part is twofold: First, it finds dependencies between arguments. For example, if an argument corresponds to a context that is passed to multiple consecutive API calls it should likely not be fuzzed between calls. Second, it performs backward slicing to analyze the data flow for each argument. This gives FuzzGen some indication on how to initialize arguments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Fuzzer stub synthesis</head><p>Finally, FuzzGen creates fuzzer stubs for the different API calls and its arguments through the now complete A 2 DG. An important challenge when synthesizing fuzzer stubs is to balance between depth and breadth of the A 2 DG exploration. For example, due to loops, a fuzzer stub could continuously call the same API function without making any progress.</p><p>Instead of generating many fuzzer stubs for each A 2 DG, FuzzGen creates a single stub that leverages the fuzzer's entropy to traverse the A 2 DG. At a high level, a stub encodes all possible paths (to a certain depth) through the A 2 DG. The first bits of the fuzzer input encode the path through the API calls of the A 2 DG. Note that FuzzGen only encodes the sequence of API calls through the bits, not the complete control flow through the library functions themselves. The intuition is that an effective fuzzer will "learn" that if certain input encodes an interesting path, mutating later bits to explore different dataflow along that path. As soon as the path is well-explored, the fuzzer will flip bits to follow an alternate path.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation</head><p>The FuzzGen prototype is written in about 19,000 lines of C++ code, consisting of LLVM/Clang <ref type="bibr" target="#b24">[25]</ref> passes that implement the analyses and code to generate the fuzzers. FuzzGen generated fuzzers use libFuzzer <ref type="bibr" target="#b32">[33]</ref> and are compiled with Address Sanitizer <ref type="bibr" target="#b33">[34]</ref>.</p><p>FuzzGen starts with a target library and performs a whole system analysis to discover all consumers of the library. The library and all consumers are then compiled to LLVM bitcode as our passes work on top of LLVM IR. <ref type="figure">Figure 4</ref> shows a high level overview of the different FuzzGen phases.</p><p>The output of FuzzGen is a collection (one or more) of C++ source files. Each file is a fuzzer stub that utilizes libfuzzer <ref type="bibr" target="#b32">[33]</ref> to fuzz the target library.</p><p>Target API inference. FuzzGen infers the library API by intersecting the functions implemented in the target library and those that are declared in the consumers' header files.</p><p>A 2 DG construction. FuzzGen constructs a per-consumer A 2 DG by filtering out all non-API calls from each consumer's CFG, starting from the root functions. For program consumers, the root function is main. To support libraries as consumers, root functions are functions with no incoming edges (using a backwards data-flow analysis to reduce the imprecision through indirect control-flow transfers).  <ref type="table" target="#tab_9">libhevc  video  303  113049  314  1  2  2  3880  0.002  1  10  5  29  58  libavc  video  190  83942  581  1  2  2  4064  0.002  1  9  4  29  53  libmpeg2 video  118  19828  179  1  2  2  4230  0.001  1  9  5  30  56  libopus  audio  315  50983  276  65  23  4</ref>    </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Attribute</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>Evaluating fuzzing is challenging due to its inherent nondeterminism. Even similar techniques may exhibit vastly different performance characteristics due to randomness of input generation. Klees. et al <ref type="bibr" target="#b23">[24]</ref> set out guidelines and recommendations on how to properly compare different fuzzing techniques. Key to a valid comparison are (i) a sufficient number of test runs to assess the distribution using a statistical test, (ii) a sufficient length for each run, and (iii) standardized common seeds (i.e., a small set of valid corpus files in the right format). Following these guidelines, we run our fuzzers five (5) times each (since results from a single run can be misleading), with twenty-four (24) hour timeouts. In the FuzzGen experiments, coverage tails off after a few hours with only small changes during the remainder of the test run (see <ref type="figure" target="#fig_5">Figure 5</ref>). Longer timeouts appear to have a negligible additional effect on our results.</p><p>The effectiveness of a fuzzer depends on the number of discovered bugs. However, code coverage is a complementing metric that reflects a fuzzer's effectiveness to generate inputs that cover large portions of the program. Performance is an orthogonal factor as more executed random tests broadly increase the chances of discovering a bug.</p><p>Due to the lack of extensive previous work on library fuzzing, we cannot compare FuzzGen to other automatic library fuzzers. As mentioned in Section 1, the primary method for library fuzzing is to (manually) write a fuzzer stub that leverages the libFuzzer <ref type="bibr" target="#b32">[33]</ref> engine. We evaluate our FuzzGen prototype on AOSP and Debian. Evaluating and testing FuzzGen on two different systems demonstrates the ability to operate in different environments with different sets of library consumers. Additionally, we compare FuzzGen against libFuzzer stubs written by a human analyst. A second method is to find a library consumer (which is a standalone application) and use any of the established fuzzing techniques. We forfeit the second method as the selection of the standalone application will be arbitrary and highly influence the results. There is no good metric on how an analyst would select the "best" standalone application.</p><p>To compare FuzzGen, we select seven <ref type="formula">(7)</ref> widely deployed codec libraries to fuzz. There are two main reasons for selecting codec libraries. First, codec libraries present a broad attack surface especially for Android, as they can be remotely reached from multiple vectors as demonstrated in the StageFright <ref type="bibr" target="#b16">[17]</ref> attacks. Second, codec libraries must support a wide variety of encoding formats. They consist of complex parsing code likely to contain more bugs and vulnerabilities.</p><p>We manually analyzed the API usage of each library and wrote manual fuzzer stubs for libhevc, libavc, libmpeg2, and libgsm. Luckily AOSP already provides manually written fuzzers libopus, libvpx, and libaom which we can readily use. Some libraries such as libmpeg2 have complicated interface (see Section 2) and it took several weeks to sufficiently understand all libraries and write the corresponding fuzzer stubs. In comparison, FuzzGen generates a fuzzer in a few minutes given the LLVM IR of the library and the consumers. <ref type="table">Table 2</ref> shows all libraries that we used in the evaluation for AOSP and Debian. Note that the libhevc, libavc, and libmpeg2 libraries have a single API call (see <ref type="figure" target="#fig_2">Figure 2</ref> for an example) that acts as a dispatcher to a large set of internal functions. To select the appropriate operation, the program initializes a command field of a special struct which is passed to the function. Such dispatcher functions are challenging for fuzzer synthesis and we chose these libraries to highlight the effectiveness of FuzzGen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Consumer Ranking</head><p>When synthesizing fuzzers, methods for consumer selection are important. Fuzzers based on more consumers tend to include more functionality. This functionality, represented by new API calls and transitions between API functions, can   increase the fuzzer's complexity. An efficient fuzzer must take both the amount of API calls and the underlying complexity into account. It is important to consider how much initialization state should be constructed before fuzz input is injected into the process. It is also important to determine how many API calls should be used in a single fuzzer to target a particular aspect of the library. During the evaluation, we observed that adding certain consumers increased A 2 DG complexity without increasing the API diversity or covering new functionality. Merging too many consumers increases A 2 DG complexity without resulting in more interesting paths. Adding other consumers lead to the state inconsistency problem. Restricting the analysis to few consumers resulted in a more representative A 2 DG, but opens another question: which set of consumers provide a representative set of API calls? FuzzGen ranks the "quality" of consumers from a fuzzing perspective and creates fuzzers from high quality consumers. The intuition is the number of API calls per lines of consumer code (i.e., the fraction of API calls in a consumer) correlates to a relatively high usage of the target API. That is, FuzzGen selects consumers that are "library oriented". We empirically found that using four consumers demonstrates all features of our prototype, such as A 2 DG coalescing, and results in small fuzzers that are easy to verify. For the evaluation, the generated fuzzers are manually verified to not violate the implicit API dependencies or generate false positives.</p><p>However, in Appendix B we demonstrate how the number of consumers affects the set of API functions and how the generated A 2 DGs participate in the fuzzer. The number of applied consumers tail off at a certain point. That is, additional consumers increase fuzzer complexity without adding new "interesting" coverage of the API. In future work we plan to explore other heuristics or even random selections of consumers to construct potentially more precise A 2 DGs.</p><p>Formally, our heuristic for ranking consumers, is called consumer density, D c , and defined as follows:</p><formula xml:id="formula_3">D c ← # distinct API calls Total lines o f real code (2)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Measuring code coverage</head><p>Code coverage is important both as feedback for the fuzzer during execution and to compare different fuzzers' ability to explore a given program. Code overage can be measured at different granularities: function, basic block, instruction, basic block edges, and even lines of source code. FuzzGen, like AFL and libFuzzer, uses basic block edge coverage. For the evaluation, FuzzGen uses SanitizerCoverage <ref type="bibr" target="#b8">[9]</ref>, a feature that is available in Clang. During compilation, SanitizerCoverage adds instrumentation functions between CFG edges to trace program execution. To optimize performance, SanitizerCoverage does not add instrumentation functions on every edge as many edges are considered redundant. This means that the total number of edges that are available for instrumentation during fuzzing do not correspond to the total number of edges in the CFG.</p><p>Measuring code coverage for a single fuzzing run may be misleading <ref type="bibr" target="#b23">[24]</ref>. To address this, statistical testing is conducted across the five runs to calculate the average coverage over time. Since new code paths are found at different times, we cannot simply calculate the average coverage for a given time. To overcome this problem we use linear interpolation to approximate the coverage for each fuzzing run at given time intervals. Then we calculate the average code coverage on each interval and visualize it in <ref type="figure" target="#fig_5">Figure 5</ref> and <ref type="figure" target="#fig_6">Figure 6</ref>. Finally, we also report the results of the Mann-Whitney U test, comparing the maximum coverage across all runs for manual/generated fuzzers, according to <ref type="bibr" target="#b2">[3]</ref>. The coverage of the FuzzGen generated fuzzers are better (p &lt; 0.05, two-tailed) than the manually written fuzzers for all libraries except for libaom, where the result is not statistically significant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Android evaluation</head><p>To evaluate FuzzGen on Android, we set up a small device cluster (details are shown in Appendix D) to fuzz the first five (5) libraries. <ref type="table">Table 3</ref> shows the results of our fuzzing execution. The first observation is that manual fuzzers are   smaller in size as they target only a specific part of the library (e.g., a decoding routine). Second, manual fuzzers are more targeted. Due to the focus on a single component, manual fuzzers can expose more bugs in that component compared to FuzzGen fuzzers. Meanwhile, FuzzGen fuzzers are broader and achieve a higher code coverage as they encode more diverse API interactions. This however imposes complexity which results in performance overhead, reducing the number of executions per second. Given more additional resources, FuzzGen fuzzers therefore allow the exploration of a broader program surface in the long run.</p><formula xml:id="formula_4">� � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � � �</formula><p>To get a better intuition on the evolution of the fuzzing process, we visualize the edge coverage over time as shown in <ref type="figure" target="#fig_5">Figure 5a</ref> through <ref type="figure" target="#fig_5">Figure 5e</ref>. The libopus library has lower total coverage (39.99%) than the other libraries tested. This is because all selected consumers focused on the decoding functionality. This aspect is highlighted in <ref type="table">Table 2</ref>, where the fuzzer includes only 12 API calls while the API exposes 65 functions. A different selection of library consumers that utilize more aspects of the library (e.g., encoding functionality), would result in higher coverage, illustrating that selection of library consumers is crucial for FuzzGen fuzzing.</p><p>One of the key advantages of FuzzGen compared to manual fuzzer collection is the scalability and automation that FuzzGen provides. FuzzGen can leverage different sets of consumers to create many different fuzzers (e.g., a fuzzer stub focusing on encoding while another fuzzer stub focuses on decoding), allowing an analyst to explore different parts of the API in depth without having to manually create individual fuzzer stubs. These automatically created fuzzers can run at scale, simplifying the work of the analyst.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Debian evaluation</head><p>The Debian evaluation shows similar results to the Android evaluation. Two (2) additional codec libraries were selected for FuzzGen fuzzer generation. It is important to note the difference in library consumer selection. On Android, consumers are limited to those present in AOSP. On Debian, the package manager is referenced to search for consumers that depend on the given library. In both cases we leverage a "finite" ecosystem where we can iterate through all available packages and select candidates to synthesize our fuzzers.</p><p>The last two columns of <ref type="table">Table 3</ref> show the results of running libvpx and libaom on Debian. The edge coverage over time is shown in <ref type="figure" target="#fig_5">Figure 5f</ref> and <ref type="figure" target="#fig_6">Figure 6</ref> respectively. The first observation is that manual fuzzers have a lower rate of executions per second even though they are much smaller in size. This is because they contain loops. That is, they use a loop to continuously feed random input to the decoder. FuzzGen fuzzers are loop-free, which implies they spend less time on individual random inputs. For both libvpx and libaom, decoding multiple frames results in building a more complicated decoding state, which in turn triggers deeper code paths. It is better to have a fuzzer that contains loops for these cases, even though it achieves lower executions per second. For libopus, the decoding state is much simpler-since it is an audio library-so decoding multiple frames on each random input, affects performance, which results in a lower coverage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Discussion and future work</head><p>Our prototype demonstrates the power of automatic fuzzer generation and API dependency analysis. As this is a first step towards automation, we would like to highlight several opportunities for improvement.</p><p>Maximum code coverage FuzzGen generated fuzzers achieve 54.94% coverage on average compared to manually written fuzzers that achieve only 48.00%. While FuzzGen vastly simplifies the generation of fuzzers, it remains an open question if the additional coverage substantially improves the fuzzing effectiveness in itself and if full cumulative coverage can be achieved by improving FuzzGen. The coverage we report is the cumulative coverage across all inputs in a single run. Given a fuzzer stub, only a certain amount of coverage can be achieved given through a combination of the used API functions and the arguments used for those functions. The problem of the maximum possible coverage that a fuzzer can achieve given a fuzzer stub is left for future work.</p><p>Single library focus. For now, FuzzGen focuses on a single target library and does not consider interactions between libraries. FuzzGen could be extended to support multiple libraries and interactions between libraries. This extension poses the interesting challenge of complex inter-dependencies but will allow the exploration of such inter-dependencies through an automated fuzzer. We leave this as future work.</p><p>Coalescing dependence graphs into a unifying A 2 DG. When multiple library consumers are available, FuzzGen has to either coalesce all generated A 2 DG into a single one or generate a separate fuzzer of each library consumer While the first approach can expose deeper dependencies and therefore achieve deeper coverage, it could potentially result in state inconsistencies. The latter approach increases parallelism, as different clusters can fuzz different aspects of the library.</p><p>False positives. Imprecision in the static analysis and the A 2 DG coalescing may result in spurious paths that result in false positives. Fuzzing libraries is inherently challenging as the API dependencies are not known. The analysis could trace benign executions and extract benign API sequences to construct the A 2 DG. This would result in an under-approximation of all valid API sequences. However, the static analysis combined with A 2 DG coalescing results in an over-approximation. We argue that the over-approximation results in additional freedom for the fuzzer to generate more interesting path combinations, allowing FuzzGen to trigger deep bugs at the cost of a small false positive rate. In general, we propose to validate the API sequence during triaging. The analyst can trace the set of API calls and their parameters and manually check, for each reported crash, that the API sequence is valid. We empirically discovered that for some but few merged consumers, the likelihood of false positives is low. For our evaluation, we manually verified that the fuzzers cannot create false positives by double checking all API sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>Despite their effectiveness in vulnerability discovery, existing fuzzing techniques do not transfer well to libraries. Libraries cannot run as standalone applications and fuzzing them requires either a manually written libFuzzer stub that utilizes the library, or to fuzz the library through a library consumer. The wide diversity of the API and the interface of various libraries further complicates this task. To address this challenge, we presented FuzzGen, a framework that automatically infers API interactions from a library and synthesizes a targetspecific fuzzer for it. FuzzGen leverages a whole system analysis to collect library consumers and builds an Abstract API Dependence Graph (A 2 DG) for them.</p><p>We evaluated FuzzGen on 7 codec libraries -which are notorious for having a complicated interface-and in all cases, the generated fuzzers were able to discover 17 previously unknown vulnerabilities and received 6 CVEs.</p><p>The source code of our prototype is available online at https://github.com/HexHive/FuzzGen. The first module connects to a server and terminates the read side of the socket (as it only sends data). The second module both sends and receives data. If we ignore the arguments for now, the functions socket, connect and write are shared between the two consumers and they are therefore coalesced. The result is the coalesced fuzzer shown in (c). However this results in an inconsistency where the fuzzer closes the read side of the socket and later tries to read from it. Although the fuzzer does not crash, the coalesced module violates the state and is therefore not a useful fuzzer.  A 2 DG coalescing results in aggressive fuzzers that achieve deeper coverage and find more bugs. The downside is that coalescing may introduce false positives where the API is violated, resulting in false bugs. Without coalescing, the fuzzers are redundant and will not achieve coverage as deep as the coalesced fuzzers but will not introduce any false positives. In our empirical evaluation we discovered that the number of false positives is low and we therefore enable coalescing but leave it as a configurable option. In future work, we will look at how to tune coalescing aggressiveness, i.e., deciding how and when to coalesce based on a heuristic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Library Consumer Complexity</head><p>We empirically determined that a maximum of four consumers is a reasonable balance between complexity, breadth of explored API, and fuzzing effectiveness. To demonstrate the loss of effectiveness and the unnecessary increase in complexity  when adding too may consumers, we present a case study on the libopus library where we continuously and iteratively merge consumers. We start with one consumer and progressively add more consumers (following our predetermined ranking). We measure the total number of API calls found in the consumer along with the size of the corresponding A 2 DG. <ref type="table" target="#tab_9">Table 4</ref> shows how the number of consumers increases the size of the explored API. Only 7 consumers are enough to discover the complete API. However, the generated fuzzer only executes 33 different API calls. With increasing number of merged consumers, the fuzzer then executes more API calls until we reach a plateau at 13 merged consumers. Note that the fuzzer creates one path through the program that strings these API calls together. Libraries expose different functionality that are hard to streamline. This additional complexity slows down the fuzzer and prohibits it from discovering bugs quickly. Additionally, the generated fuzzers are harder for an analyst to analyze and, due to the repeated merging process, we increase the chances of false positives. Our observation is that it is better to create several smaller fuzzers than one complex fuzzer. <ref type="figure" target="#fig_8">Figure 7</ref> visualizes the discovery of API calls relative to the increasing set of merged library consumers. With 15 consumers FuzzGen generates a fuzzer stub with 8, 375 lines of code. Despite this enormous size, it compiled and discovered a crash. However verifying whether this crash is a false positive or not, is extremely challenging due to the complexity of the API interactions in the fuzzer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Overview of Disclosed Vulnerabilities</head><p>During our evaluation, the generated fuzzers discovered 17 vulnerabilities, 6 of which were assigned CVEs <ref type="table" target="#tab_11">(Table 5)</ref>. Following responsible disclosure, some vulnerabilities are still under embargo.</p><p>CVE-2019-2106 <ref type="bibr" target="#b12">[13]</ref> is a critical vulnerability found in the High Efficiency Video Coding (HEVC) <ref type="bibr" target="#b37">[38]</ref> library on Android. The vulnerability is an out of bounds writewhich could lead to an arbitrary write-and resides inside ihevc_sao_edge_offset_class2_chroma_ssse3, as shown below: Supplying a frame with malformed slices to the decoder triggers both an out-of-bounds write (using the first vulnerability) and an out-of-bounds read (using the second vulnerability).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D Lab setup used for Android evaluation</head><p>To evaluate our fuzzers we utilized a set of twelve (12) Pixel-2 (walleye) devices. This setup allowed us to run repeated 24-hour fuzzing sessions. <ref type="figure" target="#fig_10">Figure 8</ref> shows our device cluster. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: The main intuition behind FuzzGen. To synthesize a fuzzer, FuzzGen performs a whole system analysis to extract all valid API interactions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: The FuzzGen workflow. FuzzGen starts with a CFG (a) and extracts the corresponding A 2 DG (b) (see (c) for the graph of another module). The two A 2 DG graphs are then merged (d). The merged A 2 DG is then used to create fuzzers based on function orders (e). These graphs are autogenerated by FuzzGen.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2 :</head><label>2</label><figDesc>Codec libraries and consumers used in our evaluation. Library Information: Src Files = Number of source files, Total LoC = Total lines of code (without comments and blank lines), Funcs = Number of functions found in the library, API = Number of API functions. Consumer Information: Total = Total number of library consumers on the system, Used = Library consumers included in the evaluation, Total LoC = Total lines of code of all library consumers (without comments and blank lines), Avg D c = Average consumer density, UAPI = Number of API functions used in the consumers. Final A 2 DG: Graphs = Total number of A 2 DGs, Coalesced = Number of nodes coalesced (same as the number of A 2 DGs merges, since our algorithm uses a single node for merging), Nodes, Edges = Total number of nodes and edges (respectively) in the final A 2 DG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>3 :</head><label>3</label><figDesc>Results from fuzzer evaluation on codec libraries. We run each fuzzer 5 times. Total LoC = Total lines of fuzzer code, Edge Coverage % = edge coverage (max: maximum covarage from best run, avg: average coverage across all runs, min: maximum coverage from the worst run, std: standard deviation of the coverage), Bugs found = Number of total (T) and unique (U) bugs found, exec/sec = Average executions per second (from all runs), Difference = The difference between FuzzGen and manual fuzzers (p value from Mann-Whitney U test, unique bugs and maximum edge coverage). *The executions per second in this case are low because all 283 discovered bugs are timeouts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Code coverage (%) over time for each library. Blue line shows the average edge coverage over time for manual fuzzers and orange line shows the edge coverage for the best single run (among the 5) for manual fuzzers. Similarly, the green line shows the average edge coverage for FuzzGen fuzzers, and the red line the edge coverage from best single run for FuzzGen fuzzers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Code coverage over time for libaom.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Consumer tail off for distinct API calls for libopus library.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>;</head><label></label><figDesc>// Crash. OOB write ---&gt; CVE-2017-13187 [12] is another high severity vulnerabil- ity found in the same component. This time, the vulnerability is an out of bounds read-which can cause remote denial of service-and resides inside ihevcd_nal_unit as shown below: 1 IHEVCD_ERROR_T ihevcd_nal_unit(codec_t *ps_codec) 2 { 3 IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS; 4 5 / * NAL Header * / 6 nal_header_t s_nal; 7 8 ret = ihevcd_nal_unit_header(&amp;ps_codec-&gt;s_parse.s_bitstrm, 9 &amp;s_nal); 10 11 RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret); 12 13 if(ps_codec-&gt;i4_slice_error) 14 s_nal.i1_nal_unit_type = // Crash. OOB read. ---&gt; 15 ps_codec-&gt;s_parse.ps_slice_hdr-&gt;i1_nal_unit_type;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Our device fuzzing cluster.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Total LoC Funcs API Total Used Total LoC Avg D c UAPI Graphs Coal. Nodes Edges</head><label></label><figDesc>Internal Argument Value-Set inference. Possible values and their corresponding types for the function arguments are calculated through a per-function data flow analysis. FuzzGen assigns different attributes to each argument based on these observations. These attributes allow the fuzzer to better ex- plore the data space of the library. Note that this process is imprecise due to aliasing. Table 1 shows the set of possi- ble attributes. For example, if an argument is only used in a switch statement, it can be encoded as a set of predefined values. Similarly, if the first access to an argument is a write, the argument is used to output information. Arguments that are not modified (such as file descriptors or buffer lengths) receive the invariant attribute.</figDesc><table>Description 
dead 
Argument is not used 
invariant 
Argument is not modified 
predefined 
Argument takes a constant value from a set 
random 
Argument takes any (random) value 
array 
Argument is an array (pointers only) 
array size 
Argument represents an array size 
output 
Argument holds output (destination buffer) 
by value 
Argument is passed by value 
NULL 
Argument is a NULL pointer 
function pointer Argument is a function pointer 
dependent 
Argument is dependent on another argument 

Table 1: Inferable argument attributes from value-set analysis. 

External Argument Value-Set inference. Complement-
ing the internal argument value-set inference, FuzzGen per-
forms a backward slice from each API call through all con-
sumers, assigning the same attributes to the arguments. 

Argument Value-Set Merging. Due to imprecision in the 
analysis or potential misuses of the library, the attributes of 
the arguments may differ. We need to carefully consolidate 
the different attributes for each argument when merging the 
attributes. Generally, FuzzGen's analysis is more accurate 
with external arguments. These arguments tend to provide 
real use-cases of the function. Any internal assignments that 
give concrete values, are used to complement the externally 
observed values. Value-set merging is based on heuristics and 
may be adjusted in future work. 

Dependence analysis. Knowing the possible values for 
each argument is not enough, the fuzzer must additionally 
know when to reuse the same variable across multiple func-
tions. The dependence analysis infers when to reuse vari-
ables and when to create new ones between function calls. 
FuzzGen performs a per-consumer data-flow analysis using 
precise intra-procedural and coarse-grained inter-procedural 
tracking to connect multiple API calls. While a coarse-grained 
inter-procedural analysis may result in imprecision, it remains 
tractable and scales to large consumers. The analysis records 
any data flow between two API functions in the A 2 DG. Simi-
larly to other steps, aliasing may lead to further imprecision. 

Failure Heuristics. To handle some corner cases, FuzzGen 
uses a heuristic to discard error paths and dependencies. 
Many libraries contain ample error checking. Arguments are 
checked between API calls and, if an error is detected, the 
program signals an error. The argument analysis will detect 
theses checks as argument constraints. Instead of adding these 
checks to the A 2 DG, we discard them. FuzzGen detects func-
tions that terminate the program or pass on errors and starts 
the detection from there. 

A 2 DG Coalescing. After initial A 2 DG construction, each 
consumer results in a set of at least one A 2 DG. To create 
fuzzers that explore more state, FuzzGen tries to coalesce dif-
ferent A 2 DG. Starting from an A 2 DG node where an API call 
shares the exact same argument types and attributes, FuzzGen 
continuously merges the nodes or adds new nodes that are 
different. If the two graphs cannot be merged, i.e., there is a 
conflict for an API call then FuzzGen returns two A 2 DGs. If 
desired, the analyst can override merging policies based on 
the returned A 2 DGs. However, coalescing may combine an 
API call sequence that results in a state inconsistency (see 
Appendix A for an example). An analyst may optionally dis-
able coalescing and produce a less generic fuzzer for each 
consumer. Although this approach cannot expose deeper de-
pendencies, it increases parallelism, as different fuzzers can 
target different aspects of the library. 

A 2 DG Flattening. So far, the A 2 DG may contain complex 
control flow and loops. To create simple fuzzers, we "flat-
ten" the A 2 DG before synthesizing a fuzzer. Our flattening 
heuristic is to traverse the A 2 DG and to visit each API call 
at least once by removing backward edges (loops) and then 
applying a (relaxed) topological sort on the acyclic A 2 DG 
to find a valid order for API calls. While a topological sort 
would provide a total order of functions (and therefore result 
in an overly rigid fuzzer), we relax the sorting. At each step 
our algorithm removes all API functions of the same order 
and places them in a group of functions that may be called in 
random order. 

Fuzzer Synthesis. Based on a flattened A 2 DG, FuzzGen 
translates nodes into API calls and lays out the variables 
according to the inferred data flow. The fuzzer leverages some 
fuzz input to decode a concrete sequence for each group of 
functions of the same order, resulting in a random sequence 
at runtime. Before compiling the fuzzer, FuzzGen must also 
include all the necessary header files. During the consumer 
analysis, FuzzGen records a dependence graph of all includes 
and, again, uses a topological sort to find the correct order for 
all the header files. 

FuzzGen Preprocessor. The source code to LLVM IR 
translation is a lossy process. To include details such as 
header declarations, dependencies across header files, pointer 
arguments, array types, argument names, and struct names, 
FuzzGen leverages a preprocessor pass that records this infor-
mation for later analysis. 

USENIX Association 
29th USENIX Security Symposium 2279 

Library Information 

Consumer Information 
Final A 2 DG 
Name 
Type 
Src Files Android 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>Table</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>Table</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><head>Table 4 :</head><label>4</label><figDesc>Complexity increase for the libopus library. Con- sumers: Total number of consumers used. API: Used: Total number of distinct API calls used in the final fuzzer. Found: Total number of distict API calls identified in headers. A 2 DG: Total: Total number of A 2 DG graphs produced (if coalesc- ing is not possible there are more than one graphs). Nodes &amp; edges: The total number of nodes and edges across all A 2 DGs.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><head>Table 5 :</head><label>5</label><figDesc></figDesc><table>Assigned CVEs for the vulnerabilities found by Fuz-
zGen. 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank our shepherd Tuba Yavuz and the anonymous reviewers for their insightful comments. This project has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement No. 850868).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consumers</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>API</head><p>A 2 DG Used Found Total Nodes <ref type="table">Edges  0  0  0  1  0  0  1  6  34  1  7  12  2  6  34  1  9  14  3  10  34  1  16  22  4  12  34  1  24  30  5  25  51  1  142  289  6  31  51  2  148  303  7  33  65  2  181  438  8  44  65  1  540  1377  9  47  65  2  551  1393  10  50  65  2  611  1473  11  51  65  2  613  1475  12  53  65  2  697  1587  13  56  65  2  883  1773  14  56  65  2  885  1778  15  56  65  2  885  1778</ref> </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">An introduction to spike, the fuzzer creation kit. presentation slides)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dave</forename><surname>Aitel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Android open source project</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Open Handset Alliance</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">A hitchhiker&apos;s guide to statistical tests for assessing randomized algorithms in software engineering. Software Testing, Verification and Reliability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Arcuri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lionel</forename><surname>Briand</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="219" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Fudge: fuzz driver generation at scale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Domagoj</forename><surname>Babi´cbabi´c</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Bucur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yaohui</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Franjo</forename><surname>Ivanči´ivanči´c</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Kusano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Caroline</forename><surname>Lemieux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">László</forename><surname>Szekeres</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering</title>
		<meeting>the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2019" />
			<biblScope unit="page" from="975" to="985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Directed greybox fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcel</forename><surname>Böhme</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Van-Thuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manh-Dung</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abhik</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Roychoudhury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Coverage-based greybox fuzzing as markov chain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcel</forename><surname>Böhme</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Van-Thuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abhik</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Roychoudhury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Mops: an infrastructure for examining security properties of software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hao</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Wagner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th ACM conference on Computer and communications security</title>
		<meeting>the 9th ACM conference on Computer and communications security</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Angora: Efficient fuzzing by principled search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peng</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hao</forename><surname>Chen</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1803.01307</idno>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">The clang development team: Sanitizer coverage</title>
		<ptr target="http://clang.llvm.org/docs/SanitizerCoverage.html" />
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Difuze: interface aware fuzzing for kernel drivers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jake</forename><surname>Corina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aravind</forename><surname>Machiry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Salls</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yan</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shuang</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giovanni</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
				<ptr target="https://nvd.nist.gov/vuln/detail/CVE-2017-0858" />
		<title level="m">CVE-2017-0858: libavc: Another vulnerability in the android media framework</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
				<ptr target="https://nvd.nist.gov/vuln/detail/CVE-2017-13187" />
		<title level="m">CVE-2017-13187: libhevc: An information disclosure vulnerability in the android media framework</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
				<ptr target="https://nvd.nist.gov/vuln/detail/CVE-2019-2106" />
		<title level="m">CVE-2019-2106: libhevc: Stack-buffer-underflow in ihevc_sao_edge_offset_class2_chroma_ssse3</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
				<ptr target="https://nvd.nist.gov/vuln/detail/CVE-2019-2107" />
		<title level="m">CVE-2019-2107: libhevc: Multiple heap-buffer overflows in ihevcd_decode</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
				<title level="m">CVE-2019-2108: libhevc: Stack-buffer-overflow in ihevcd_ref_list</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cve-</forename></persName>
		</author>
		<title level="m">Heap buffer overflow in libhevcdec</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Stagefright: Scary code in the heart of android</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><surname>Drake</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
			<pubPlace>BlackHat USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Peach fuzzing platform. Peach Fuzzer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Eddington</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Collafl: Path sensitive fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shuitao</forename><surname>Gan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chao</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaojun</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xuwen</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhongyu</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zuoning</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CollAFL: Path Sensitive Fuzzing</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">From blackbox fuzzing to whitebox fuzzing towards verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrice</forename><surname>Godefroid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Presentation at the 2010 International Symposium on Software Testing and Analysis</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Vetting ssl usage in applications with sslint</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boyuan</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vaibhav</forename><surname>Rastogi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yinzhi</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Runqing</forename><surname>Vn Venkatakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhenrui</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE Symposium on Security and Privacy (SP)</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">zzuf-multi-purpose fuzzer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hocevar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Symbolic execution and program testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>James</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>King</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Evaluating fuzz testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Klees</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Ruef</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benji</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shiyi</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Hicks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2018 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Llvm: A compilation framework for lifelong program analysis &amp; transformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Lattner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vikram</forename><surname>Adve</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the international symposium on Code generation and optimization: feedback-directed and runtime optimization</title>
		<meeting>the international symposium on Code generation and optimization: feedback-directed and runtime optimization</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Fairfuzz: A targeted mutation strategy for increasing greybox fuzz testing coverage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Caroline</forename><surname>Lemieux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering</title>
		<meeting>the 33rd ACM/IEEE International Conference on Automated Software Engineering</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Fuzzing: the state of the art</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Mcnally</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ken</forename><surname>Yiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Duncan</forename><surname>Grove</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Damien</forename><surname>Gerhardy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DEFENCE SCIENCE AND TECHNOLOGY ORGAN-ISATION EDINBURGH</title>
		<imprint>
			<date type="published" when="2012" />
			<publisher>AUSTRALIA</publisher>
		</imprint>
	</monogr>
<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Tfuzz: fuzzing by program transformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hui</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yan</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathias</forename><surname>Payer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Automatic generation of object usage specifications from large method traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Pradel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><forename type="middle">R</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Automated Software Engineering</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Leveraging test generation and specification mining for automated bug detection without false positives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Pradel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><forename type="middle">R</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Engineering</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Vuzzer: Application-aware evolutionary fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vivek</forename><surname>Sanjay Rawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lucian</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristiano</forename><surname>Cojocar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herbert</forename><surname>Giuffrida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Network and Distributed System Security Symposium (NDSS</title>
		<meeting>the Network and Distributed System Security Symposium (NDSS</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Protos-systematic approach to eliminate software vulnerabilities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juha</forename><surname>Röning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ari</forename><surname>Lasko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Takanen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kaksonen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
	<note>Invited presentation at Microsoft Research</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">libfuzzer: A library for coverage-guided fuzz testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Serebryany</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>within llvm</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Addresssanitizer: A fast address sanity checker</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konstantin</forename><surname>Serebryany</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Derek</forename><surname>Bruening</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Potapenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dmitriy</forename><surname>Vyukov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title/>
		<ptr target="https://github.com/google/oss-fuzz" />
	</analytic>
	<monogr>
		<title level="j">Kostya Serebryany. Oss-fuzz</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Oss-fuzz -google&apos;s continuous fuzzing service for open source software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kostya</forename><surname>Serebryany</surname></persName>
		</author>
		<ptr target="https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/serebryany" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Driller: Augmenting fuzzing through selective symbolic execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Stephens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Grosen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Salls</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Dutcher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruoyu</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacopo</forename><surname>Corbetta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yan</forename><surname>Shoshitaishvili</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Kruegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giovanni</forename><surname>Vigna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Overview of the high efficiency video coding(hevc) standard. IEEE Transactions on circuits and systems for video technology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens-Rainer</forename><surname>Sullivan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Woo-Jin</forename><surname>Ohm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wiegand</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Swiecki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Honggfuzz</surname></persName>
		</author>
		<ptr target="http://code.google.com/p/honggfuzz" />
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Modeling and discovering vulnerabilities with code property graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabian</forename><surname>Yamaguchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nico</forename><surname>Golde</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Arp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konrad</forename><surname>Rieck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security and Privacy (SP), 2014 IEEE Symposium on</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Semfuzz: Semantics-based automatic generation of proof-ofconcept exploits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>You</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peiyuan</forename><surname>Zong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaofeng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaojing</forename><surname>Liao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pan</forename><surname>Bian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bin</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Qsym: a practical concolic execution engine tailored for hybrid fuzzing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sangho</forename><surname>Insu Yun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meng</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yeongjin</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th USENIX Security Symposium (USENIX Security 18)</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">APISan: Sanitizing API Usages through Semantic Cross-checking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Changwoo</forename><surname>Insu Yun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xujie</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yeongjin</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Jang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mayur</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Naik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Usenix Security Symposium</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">A State Inconsistency Although coalescing increases the generality of the fuzzers, it suffers from the state inconsistency problem. Consider for instance a fuzzer of a socket library and two library consumers (a) and (b) as shown below</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michal</forename><surname>Zalewski</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note>American fuzzy lop</note>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">SHUT_RD</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
