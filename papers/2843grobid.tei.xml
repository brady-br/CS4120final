<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/atharsefid/Desktop/grobid-0.5.3/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.3" ident="GROBID" when="2020-09-29T02:53+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Broom: sweeping out Garbage Collection from Big Data systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ionel</forename><surname>Gog</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jana</forename><surname>Giceva</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Malte</forename><surname>Schwarzkopf</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kapil</forename><surname>Vaswani</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dimitrios</forename><surname>Vytiniotis</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ganesan</forename><surname>Ramalingan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Costa</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Derek</forename><surname>Murray</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">∅</forename><forename type="middle">♦</forename><surname>Steven</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Isard</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">†</forename><surname>Eth</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zurich</forename></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Microsoft</forename><surname>Research</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">∅</forename><surname>Unaffiliated</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<region>Inc</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Broom: sweeping out Garbage Collection from Big Data systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>* parts of the work were done while at Microsoft Research Silicon Valley</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Many popular systems for processing &quot;big data&quot; are implemented in high-level programming languages with automatic memory management via garbage collection (GC). However, high object churn and large heap sizes put severe strain on the garbage collector. As a result, applications underperform significantly: GC increases the runtime of typical data processing tasks by up to 40%. We propose to use region-based memory management instead of GC in distributed data processing systems. In these systems, many objects have clearly defined lifetimes. Hence, it is natural to allocate these objects in fate-sharing regions, obviating the need to scan a large heap. Regions can be memory-safe and could be inferred automatically. Our initial results show that region-based memory management reduces emulated Naiad ver-tex runtime by 34% for typical data analytics jobs.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Memory-managed languages dominate the landscape of systems for computing with "big data": Hadoop, Spark <ref type="bibr" target="#b21">[22]</ref>, DryadLINQ <ref type="bibr" target="#b20">[21]</ref> and Naiad <ref type="bibr" target="#b14">[15]</ref> are only some examples of systems running atop a Java Virtual Machine (JVM) or the .NET common language runtime (CLR). Managed languages are attractive as they offer strong typing, automated memory management and higher-order functions. These features improve the productivity of system developers and end-users.</p><p>However, these benefits do not come for free. Data processing tasks stress the runtime GC by allocating a large number of objects <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b16">17]</ref>. This results in long GC pauses that reduce application throughput or cause "straggler" tasks <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b17">18]</ref>. In §2, we show that the impact of GC on job runtime can range between 20 and 40%.</p><p>In this paper, we argue that a different approach can be used in distributed data processing systems. Their operation is highly structured: most such systems are based on an implicit or explicit graph of stateful data-flow operators executed by worker threads. These operators perform event-based processing of arriving input data, and therefore behave as independent actors. For example, at any one time, MapReduce runs a "map" or "reduce" function (i.e., operator) in each task <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr">Dryad [11]</ref> and Naiad <ref type="bibr" target="#b14">[15]</ref> execute a "vertex" per worker thread, and Spark runs an "action" per task <ref type="bibr" target="#b21">[22]</ref>. Each data-flow operator's objects live at most as long as the operator itself. Moreover, they are often grouped in logical batchese.g., according to keys or timestamps -that can be freed atomically. This architecture presents an opportunity to revisit standard memory-management, because:</p><p>1. Actors explicitly share state via message-passing.</p><p>2. The state held by actors consists of many fatesharing objects with common lifetimes. 3. End-users only supply code fragments to systemdefined operators, which makes automatic program transformations and region annotations practical. In §3, we illustrate these points with reference to Naiad.</p><p>Region-based memory management <ref type="bibr" target="#b18">[19]</ref> works well for sets of related objects in the absence of implicit sharing. While writing programs using regions is difficult in the general case, this old concept is a good fit for the restricted domain of distributed data processing systems ( §4). In addition, region-based allocation can offer memory safety and may be as transparent to the user as GCbased memory management. We sketch how this can be achieved in a distributed data processing system in §5.</p><p>Using Broom, a proof-of-concept implementation of region-based memory allocation for Naiad vertices, we show that region-based memory management eliminates the overheads of GC and improves execution time by up to 34% in memory-intensive operators ( §6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Motivation</head><p>We illustrate the effect of GC on Naiad's performance using two simple experiments:</p><p>1. We measure the fraction of job runtime spent in GC for two data-intensive batch jobs: TPC-H Q17 and a join-heavy business analytics workflow ( §2.1). 2. We measure the effects of GC stalls when computing strongly connected components, an iterative workflow with frequent synchronization ( §2.2). We run Naiad v0.4 on Linux using Mono v2.10.8.1 with the generational GC (sgen) enabled.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Batch processing workflows</head><p>We run two typical batch processing workflows with high object churn on a single machine. <ref type="bibr" target="#b0">1</ref> The first is query 17 from the TPC-H benchmark and the second is "shopper", a business intelligence workflow that selects users from the same country who bought a specific product (a JOIN-SELECT-JOIN workflow). In these experiments, Naiad uses eleven worker threads on the 12-core machine.</p><p>With the default GC configuration, we found that the TPC-H workflow spends around 25% of its runtime in GC, while the "shopper" workflow reaches about 37% <ref type="figure">(Figure 1</ref>). This makes sense: "shopper" generates many small objects that are subsequently freed in minor collections of the 4 MB young generation heap. Increasing the size of the young generation heap reduces the number of objects promoted to the next generation in "shopper", and thus the overall number of collections <ref type="figure">(Fig- ure 2)</ref>. This reduces the time spent on GC for "shopper"  (where many objects die young), but the increased young generation heap size does not help TPC-H Q17 (which uses stateful JOINs). In fact, the number of minor collections in TPC-H Q17 increases with young generation heap size as they are traded for major ones ( <ref type="figure">Figure 2</ref>).</p><p>This experiment looked at the GC behavior of a single data-intensive process that does not communicate. In the next experiment, we show that the problem is exacerbated when dependencies exist between processes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Synchronized iterative workflow</head><p>We run an incremental strongly connected components workflow on a graph of 15M vertices and 80M edges. Each incremental step changes one random edge in the graph. The computation synchronizes all nodes after every graph change. We collect a trace of 24 Naiad processes on four machines (six per machine) by logging the timestamps of the synchronization steps and the times at which the processes run their GC. <ref type="figure" target="#fig_2">Figure 3</ref> shows a subset of the trace, with each gray vertical bar corresponding to a synchronization step at the end of an iteration. GC pauses are shown as horizontal bars for major (orange) and minor (green) collections. It is evident that GC invocations sometimes delay a synchronization by tens of milliseconds.</p><p>It is also worth observing that a GC in one process is occasionally immediately followed by another GC in a different process (e.g. at times 170-180, 430-460, 530-560 and 720-750). This occurs because some changes to the graph affect state in several processes. Downstream processes may trigger a GC as soon as they receive messages from upstream ones that have just finished their GC. In other words, the GCs are effectively serialized when a parallel execution would offer better performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Case study: Naiad</head><p>We illustrate the memory management patterns common in distributed data processing by example of Naiad. Listing 1 shows the code of the Naiad Aggregate vertex that groups and aggregates input data. The inputs to the vertex are batched in Message objects, each associated with a logical timestamp. The results of the aggregation are stored in a dictionary keyed by the logical timestamp (line 2). Upon receiving a message, Naiad calls the user-provided OnReceive method (ln. 4). The method processes the input and applies the Aggregate function to each entry (ln. 12), storing the results. Finally, the OnNotify method is called once the actor is guaranteed to receive no more messages with a logical timestamp less than or equal to the one passed (ln. 15). When OnNotify is called, all data held in the dictionary for the timestamp received by OnNotify can be freed.</p><p>Generational garbage collectors make the assumption that "most objects die young" <ref type="bibr" target="#b12">[13]</ref>. This is true in general applications, but in Naiad most objects can only be collected after their logical timestamp is notified. Consequently, there is no point in a GC traversing these objects. Moreover, objects' lifetime depends on the events triggered by other processes (e.g., OnReceive calls).</p><p>While the details of this example are specific to Naiad, other systems exhibit similar behavior. For example, MapReduce and Spark, retain intermediate data for a key until all the records with this key have been seen. Likewise, stream processing systems (e.g., Storm, S4 <ref type="bibr" target="#b15">[16]</ref>, Spark Streaming <ref type="bibr" target="#b22">[23]</ref>) have "windowed" operators that accumulate state for a fixed amount of time.</p><p>4 Broom: out with the GC! General purpose garbage collectors are not tuned to specific application patterns. While specialized concurrent real-time garbage collectors eliminate GC pauses <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>, these collectors still have to scan a large heap. Instead, we propose a radically different approach.</p><p>Region-based memory management works well when similar objects with known lifetimes are handled. This information is available in distributed data processing systems. Many such systems are based on a model of actors communicating via message-passing. This significantly simplifies the use of regions: data sharing is explicit, and an object's lifetime does not exceed the allocating actor's unless the object is sent in a message. Moreover, only system developers write object management code: users merely supply limited user-defined functions that access objects with defined lifetimes.</p><p>Hence, only three types of regions are required for distributed data processing using communicating actors:</p><p>1. In order to allocate within a region, a user must first get a handle to the region (e.g., ln. 7). Using the handle, an allocation context can be opened by calling OpenAlloc() (e.g., ln. 8). All objects created in an allocation context are stored in the corresponding region. <ref type="bibr" target="#b1">2</ref> The aggregate actor demonstrates the use of two region types: transferable and actor-scoped regions. In the actor scoped region (actorRegion, ln. 4), we keep two dictionaries (regions and state, ln. 2-3) that are alive for the entire duration of the computation. These dictionaries are indexed by logical timestamps and store region handles or references to data stored in those regions.</p><p>The data corresponding to each logical timestamp are stored in a transferable region (regions <ref type="bibr">[time]</ref>, ln. 14). This region is created when a Message with a new timestamp is received. After we create it, we store the region handle in the regions dictionary for reuse upon receipt of another message with the same timestamp. The OnNotify method is called by Naiad when it can guar- <ref type="bibr" target="#b1">2</ref> We piggy-back the manipulation of runtime region stacks onto C#'s existing using mechanism for nested scopes. <ref type="bibr" target="#b0">1</ref>  antee that no new messages with a timestamp smaller or equal to time are going to be received <ref type="bibr">(ln. 28)</ref>. In this method, we send out the aggregated data (ln. 30) and free the memory used by that particular timestamp (ln. 31).</p><p>Readers may notice that any allocations that Aggregate() (ln. 25) induces are now part of the transferable region regions <ref type="bibr">[time]</ref>. This may be undesirable as it pollutes the transferable region. Alternatively, the Naiad developer could create a statically scoped temporary region around the call to Aggregate. In this case, she must clone the result of Aggregate from the temporary to the transferable region.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussion</head><p>Regions are non-trivial to use, and while they have attractive benefits, they also introduce some challenges. However, we believe that many of these challenges have simple solutions in the context of distributed data processing.</p><p>Memory safety. References across objects residing in the different regions make it challenging to maintain memory safety. Broom therefore restricts the allowable relationships between objects in different region types. <ref type="figure" target="#fig_3">Figure 4</ref> shows the allowed points-to relationships:</p><p>(1) Objects in a temporary region can point to objects in the same region or any other temporary region that outlives it. They are also allowed to point to objects in the related actor-scoped region and to objects in a transferable region if both regions are owned by the same actor.</p><p>(2) An actor-scoped region can include references to its own objects. It can also include references to transferable region handles, as long as they have the same owner. However, objects in actor-scoped regions must not reference objects inside a transferable region.</p><p>(3) Every transferable region needs to be selfcontained and can only hold references to objects allocated in itself. Otherwise, transferring the ownership to another actor can lead to dangling pointers.</p><p>Our prototype does not yet enforce these restrictions on object references. We plan to enforce them through a combination of static and dynamic checks.</p><p>Programmability. The traditional downside of regionbased memory management is the additional complexity of working with regions. However, end-users who write high-level data processing queries (e.g. LINQ queries) for the systems we are concerned with do not need to be aware of regions at all. Instead, region annotations occur only in the implementation of the system-provided Naiad vertices (actors). By contrast, data processing system developers must still explicitly use the Broom API for region-based memory management. To reduce the annotation burden on system developers, we are working on techniques that infer regions and their types automatically using static analysis. As distributed data processing systems already perform complex source-to-source transformations and just-in-time compilation, even otherwise expensive analyses can be amortized.</p><p>GC compatibility. Regions can co-exist with a GC'ed heap, as long as the garbage collector does not traverse objects allocated inside regions. Furthermore, actorscoped regions may use a local GC within the region.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Preliminary results</head><p>As a proof of concept, we measure Broom's allocation performance and emulate several Naiad vertices after extending them with region support. All experiments were run on an AMD Opteron 2373 (4× 2.1 GHz) with 32GB RAM, running Windows Server 2012 R2.</p><p>Potential gain from using regions. Garbage collectors are most challenged by complicated structures of  many tightly cross-referenced objects: they must traverse the structure on each collection and might need to copy objects between generations. By contrast, no traversal is required when using regions. This allows us to empirically estimate an approximate upper bound on the performance benefit that regions can offer. To do so, we allocate lists of lists of basic objects, ensuring that the GC must visit every object. Each list contains n objects and there are n lists, with n ranging between 500 and 3000. <ref type="figure" target="#fig_5">Figure 5a</ref> shows the total time taken to allocate and free 40 such lists-of-lists as a function of the total number of objects allocated. Regionbased memory management yields a 59% reduction in runtime for this micro-benchmark.</p><p>Naiad vertices with regions. To estimate the benefits that a real-world Naiad computation would experience from using regions instead of GC, we implemented region-based memory management for several widelyused Naiad vertices <ref type="bibr">(SELECT, AGGREGATE and JOIN)</ref>.</p><p>In the following experiments, we run a single-threaded Naiad vertex (actor) on two synthetic, incrementally generated inputs: the documents data set receives 500,000-600,000 new entries per time epoch, and the authors data set receives 10-20 new entries per time epoch.</p><p>For each vertex, <ref type="figure" target="#fig_5">Figure 5b</ref> shows the reduction in runtime after 40 epochs using regions compared to using GC. Using epochs is always beneficial, but the magnitude of the benefit varies:</p><p>• Mostly stateless vertices (e.g. SELECT) stream data through, so objects are short-lived. Regions do not help much in this case, although there is some benefit (13% runtime reduction).</p><p>• The AGGREGATE vertex stores, for each time epoch, a Dictionary&lt;Key, Values&gt;. This contains a set of partial aggregation results and can be freed in one go when the time epoch ends. Regions offer a 20% runtime reduction compared to GC, which must traverse all dictionaries on collection.</p><p>• Highly stateful vertices such as JOIN store their complete input data (two large dictionaries per time epoch for JOIN). This is where regions help the most: runtime is reduced by 36% compared to GC. This confirms our expectations: computations with large collections of fate-sharing objects benefit the most from regions, coming close to the estimated upper bound.</p><p>Compared to the results of our batch processing experiments on Mono ( §2.1), these results are plausible: the shopper workflow, which consists of two JOINs and a SELECT spends 20-40% of its time in GC; regions would likely reduce this overhead significantly.</p><p>Yet, these experiments can only be indicative of realworld gains as they simplify matters somewhat. The single-threaded vertex case does not consider thread contention, network message delays or skew in data volume across workers. Analysing the effects of these on a real Naiad implementation is the subject of future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related work</head><p>Facade <ref type="bibr" target="#b16">[17]</ref> introduces a program transformation that splits applications' objects into (a) control objects stored on the GC'ed heap and (b) data objects stored in a periteration region. While Facade does not require changes to data processing systems themselves, end-users must identify "boundary classes" and annotate their code.</p><p>Berger et al. demonstrated that freeing individual objects in region-based memory management can be implemented efficiently <ref type="bibr" target="#b1">[2]</ref>. Their work targets general programs, but similar techniques could be applied in Broom.</p><p>Like Broom, real-time Java <ref type="bibr" target="#b2">[3]</ref> offers three types of memories: the GC heap, singleton immortal regions and statically scoped regions, but does not have transferable regions with dynamic lifetime. ML Kit, based on the Tofte-Talpin static type system <ref type="bibr" target="#b19">[20]</ref> introduces statically-scoped regions and static region inference. Later work extends it by combining GC and regions <ref type="bibr" target="#b8">[9]</ref>. Cyclone <ref type="bibr" target="#b7">[8]</ref> is a C variant with regions which relies on a strong type system for safety and region inference, and supports static and dynamic regions <ref type="bibr" target="#b9">[10]</ref>. Dynamic enforcement of memory safety for regions is also covered by Gay and Aiken <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusions</head><p>It's time to revisit regions! They are an excellent match for big data runtimes in modern high-level languages. Domain-specific knowledge of object lifetimes and region-agnostic LINQ interface to end-users can address traditional usability difficulties. The performance benefits are worthwhile and motivate further work on memory safety alongside with programmability.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>Figure 1: The Naiad TPC-H Q17 and "shopper" workflows spend 20-40% of their total runtime on GC, independent of the young generation heap size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>1</head><label></label><figDesc>AMD Opteron 4243 (12× 3.1 GHz) with 64 GB of DDR3-1600.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Trace of incremental strongly connected components in 24 parallel Naiad processes: uncoordinated GC pauses (orange and green bars) delay synchronization barriers (gray vertical lines).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Allowed points-to relationship between the different region types.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Runtime reduction attained by Broom regions micro-benchmark (a) and emulated Naiad vertices (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>public class RegionAggregateActor { 2 private Dictionary&lt;Time, &lt;Dictionary&lt;K, V&gt;&gt; state; 3 private Dictionary&lt;Time, Region&gt; regions; 4 private Region actorRegion; // actor-scoped region</head><label></label><figDesc></figDesc><table>5 

6 

public RAggregateActor (...) { 

7 

actorRegion = RegAlloc.NewRegion(ACTOR); 

8 

using (RegContext.OpenAlloc(actorRegion)) 

9 

state = new Dictionary(); 

10 

} 

11 

public void OnReceive(Time time, Message msg) { 

12 

if (state[time] == null) { 

13 

using (RegContext.OpenAlloc(actorRegion)) { 

14 

regions[time] = RegAlloc.NewRegion(TRANS); 

15 

// open transferable region for allocation 

16 

using (RegContext.OpenAlloc(regions[time])) 

17 

state[time] = new Dictionary(); 

18 

} 

19 

NotifyAt(time); 

20 

} 

21 

foreach (var entry in msg) { 

22 

// open state[time] region for object access 

23 

using (RegContext.OpenAlloc(regions[time])) 

24 

state[time][key] = 

25 

Aggregate(state[time][key], entry); 

26 

} 

27 

} 

28 

public void OnNotify(Time time) { 

29 

// send message, free state[time] 

30 

Send(state[time]); 

31 

RegAlloc.FreeRegion(regions[time]); 

32 

} 
33 } 

Listing 2: Region-based Naiad aggregate actor. 

</table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A real-time garbage collector with low overhead and consistent utilization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">F</forename><surname>Bacon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">T</forename><surname>And Rajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30 th ACM SIGPLAN Symposium on Principles of Programming Languages (POPL</title>
		<meeting>the 30 th ACM SIGPLAN Symposium on Principles of Programming Languages (POPL</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="285" to="298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Reconsidering custom memory allocation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">G</forename><surname>Zorn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mckinley</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th ACM SIGPLAN Conference on Object-oriented Programming, Systems, Languages, and Applications (OOPSLA)</title>
		<meeting>the 17th ACM SIGPLAN Conference on Object-oriented Programming, Systems, Languages, and Applications (OOPSLA)<address><addrLine>Seattle, Washington, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-11" />
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">The Real-Time Specification for Java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bollella</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Brosgol</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Dibble</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Furr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gosling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hardin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Turn-Bull</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Belliardi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2000-06" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A bloat-aware design for big data applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Borkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carey</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 International Symposium on Memory Management (ISMM) (2013)</title>
		<meeting>the 2013 International Symposium on Memory Management (ISMM) (2013)</meeting>
		<imprint>
			<biblScope unit="page" from="119" to="130" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Simplified Data Processing on Large Clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dean</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ghemawat</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mapreduce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="107" to="113" />
			<date type="published" when="2008-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Memory management with explicit regions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gay</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aiken</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 1998 Conference on Programming Language Design and Implementation (PLDI</title>
		<meeting>the ACM SIGPLAN 1998 Conference on Programming Language Design and Implementation (PLDI</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="313" to="323" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Language support for regions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gay</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aiken</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2001 Conference on Programming Language Design and Implementation (PLDI</title>
		<meeting>the ACM SIGPLAN 2001 Conference on Programming Language Design and Implementation (PLDI</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="70" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Regionbased memory management in cyclone</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Grossman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Morrisett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hicks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cheney</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation (PLDI</title>
		<meeting>the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation (PLDI</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="282" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Combining region inference and garbage collection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hallenberg</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Elsman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tofte</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation (PLDI</title>
		<meeting>the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation (PLDI</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="141" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Experience with safe manual memory-management in cyclone</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hicks</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Morrisett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2004 International Symposium on Memory Management (ISMM)</title>
		<meeting>the 2004 International Symposium on Memory Management (ISMM)</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="73" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dryad: distributed dataparallel programs from sequential building blocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isard</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Birrell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fetterly</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2 nd ACM European Conference on Computer Systems (EuroSys)</title>
		<meeting>the 2 nd ACM European Conference on Computer Systems (EuroSys)</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="59" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The Singularity System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larus</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hunt</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="72" to="79" />
			<date type="published" when="2010-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A real-time garbage collector based on the lifetimes of objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lieberman</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hewitt</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="419" to="429" />
			<date type="published" when="1983-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Trash day: Coordinating garbage collection in distributed systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maas</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Asanovi´casanovi´ Asanovi´c</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kubiatowicz</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15 th USENIX/ACM Workshop on Hot Topics in Operating Systems (HotOS) (Kartause Ittingen</title>
		<meeting>the 15 th USENIX/ACM Workshop on Hot Topics in Operating Systems (HotOS) (Kartause Ittingen<address><addrLine>Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Naiad: a timely dataflow system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Murray</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G</forename><surname>Mcsherry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Isaacs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Is-Ard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abadi</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24 th ACM Symposium on Operating Systems Principles (SOSP) (2013)</title>
		<meeting>the 24 th ACM Symposium on Operating Systems Principles (SOSP) (2013)</meeting>
		<imprint>
			<biblScope unit="page" from="439" to="455" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">S4: Distributed stream computing platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neumeyer</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Robbins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Nair</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kesari</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 International Conference on Data Mining (Workshops) (ICDM) (2010)</title>
		<meeting>the 2010 International Conference on Data Mining (Workshops) (ICDM) (2010)</meeting>
		<imprint>
			<biblScope unit="page" from="170" to="177" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Facade: A compiler and runtime for (almost) object-bounded big data applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nguyen</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20 th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</title>
		<meeting>the 20 th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Making sense of performance in data analytics frameworks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ousterhout</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Rasti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ratnasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chun</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B.-G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12 th USENIX Symposium on Networked Systems Design and Implementation (NSDI)</title>
		<meeting>the 12 th USENIX Symposium on Networked Systems Design and Implementation (NSDI)<address><addrLine>Oakland, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-05" />
			<biblScope unit="page" from="293" to="307" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Region-based memory management. Information and Computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tofte</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Talpin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-P</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="volume">132</biblScope>
			<biblScope unit="page" from="109" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Region-based memory management. Information and Computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tofte</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Talpin</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-P</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1997-02" />
			<biblScope unit="volume">132</biblScope>
			<biblScope unit="page" from="109" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A system for general-purpose distributed data-parallel computing using a high-level language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">U</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fetterly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">´</forename><forename type="middle">U</forename><surname>Gunda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Currey</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dryadlinq</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8 th USENIX Symposium on Operating Systems Design and Implementation (OSDI</title>
		<meeting>the 8 th USENIX Symposium on Operating Systems Design and Implementation (OSDI</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Resilient distributed datasets: A fault-tolerant abstraction for in-memory cluster computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zaharia</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chowdhury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dave</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mccauley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stoica</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9 th USENIX Conference on Networked Systems Design and Implementation (NSDI)</title>
		<meeting>the 9 th USENIX Conference on Networked Systems Design and Implementation (NSDI)</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Discretized streams: Fault-tolerant streaming computation at scale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zaharia</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hunter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stoica</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24 th ACM Symposium on Operating Systems Principles (SOSP) (2013)</title>
		<meeting>the 24 th ACM Symposium on Operating Systems Principles (SOSP) (2013)</meeting>
		<imprint>
			<biblScope unit="page" from="423" to="438" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
